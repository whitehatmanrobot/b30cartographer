= MAKEINTRESOURCE( IDS_APPNAME );
    pshead.phpage       = rPages;
    pshead.pszbmWatermark = MAKEINTRESOURCE( IDB_TITLEPAGE );
    pshead.pszbmHeader  = MAKEINTRESOURCE( IDB_HEADER );


    AddPage( &pshead, IDD_WELCOME,          WelcomeDlgProc,   0, 0 );
    AddPage( &pshead, IDD_SERVER,           ServerDlgProc,    IDS_SERVER_TITLE,    IDS_SERVER_SUBTITLE );
    AddPage( &pshead, IDD_OSDIRECTORY,      DirectoryDlgProc, IDS_DIRECTORY_TITLE, IDS_DIRECTORY_SUBTITLE );
    AddPage( &pshead, IDD_DEFAULTSIF,       SIFDlgProc,       IDS_SIF_TITLE,       IDS_SIF_SUBTITLE );
    AddPage( &pshead, IDD_COMPAT,           CompatibilityDlgProc,    IDS_COMPAT_TITLE,    IDS_COMPAT_SUBTITLE );
    AddPage( &pshead, IDD_STOPSVCWRN,       StopServiceWrnDlgProc,  IDS_STOPSVC_TITLE, IDS_STOPSVC_SUBTITLE );
    AddPage( &pshead, IDD_STOPSVC,          DoStopServiceDlgProc,  IDS_STOPSVC_TITLE, IDS_STOPSVC_SUBTITLE );
    AddPage( &pshead, IDD_APPLICATIONS_RUNNING, ApplicationDlgProc,    IDS_APPLICATION_TITLE,    IDS_APPLICATION_SUBTITLE );
    AddPage( &pshead, IDD_SUMMARY,          SummaryDlgProc,    IDS_FINISH_TITLE,    IDS_FINISH_SUBTITLE );
    AddPage( &pshead, IDD_COMPLETE,         CompleteDlgProc,    0,    0 );

    iResult = PropertySheet( &pshead );
    switch(iResult)
    {
    case 0:
        hr = E_FAIL;
        break;

    default:
        hr = S_OK;
        break;
    }

    RETURN(hr);
}

//
// IsWhiteSpace()
//
BOOL
IsWhiteSpace( WCHAR ch )
{
    if ( ch <=32 )
        return TRUE;

    return FALSE;
}

//
// CheckWhichOption()
DWORD
CheckWhichOption(
    LPWSTR pszOption )
{
    WCHAR szOptions[ 32 ];
    DWORD dw;

#ifdef DEBUG
    if ( StrCmpNI( pszOption, L"debug", 5 ) == 0 )
        return OPTION_DEBUG;
    if ( StrCmpNI( pszOption, L"func", 4 ) == 0 )
        return OPTION_FUNC;
#endif

    // Check for quiet flag
    dw = LoadString( g_hinstance, IDS_QUIET, szOptions, ARRAYSIZE( szOptions ) );
    Assert( dw );
    if ( StrCmpNI( pszOption, szOptions, wcslen(szOptions) ) == 0 )
        return OPTION_QUIET;

    if ( StrCmpNI( pszOption, L"PNP", 3 ) == 0 )
        return OPTION_PNP;

    //
    // By default, the Setup guys are going to remove all the desktop icons
    // during MiniSetup.  We'd like to keep those around for riprep installs,
    // so by default, we're going to set some registry keys to keep the
    // user's desktop around.  However, if the user gives us a -OEMDesktop flag,
    // then don't set these flags and allow the desktop to be cleaned up.
    //
    if( StrCmpNI( pszOption, L"OEMDesktop", 10 ) == 0 ) {
        return OPTION_OEMDESKTOP;
    }

    return OPTION_UNKNOWN;
}

//
// ParseCommandLine()
//
void
ParseCommandLine( LPWSTR lpCmdLine )
{
    WCHAR szPath[ MAX_PATH ];
    LPWSTR psz = NULL;
    BOOL endOfCommandLine;

    //
    // Check to see if the command line has the servername on it.
    //
    g_ServerName[0] = L'\0';
    if ( lpCmdLine[0] == L'\\' && lpCmdLine[1] == L'\\' )
    {
        psz = StrChr( &lpCmdLine[2], L'\\' );
        if ( psz && psz != &lpCmdLine[2] )
        {
            *psz = L'\0';
            lstrcpyn( g_ServerName, &lpCmdLine[2], ARRAYSIZE(g_ServerName) );
            *psz = L'\\';
        }
    }
    // See if it is a quoted path as well
    if ( lpCmdLine[0] == L'\"' && lpCmdLine[1] == L'\\' && lpCmdLine[2] == L'\\' )
    {
        psz = StrChr( &lpCmdLine[3], L'\\' );
        if ( psz && psz != &lpCmdLine[3] )
        {
            *psz = L'\0';
            lstrcpyn( g_ServerName, &lpCmdLine[3], ARRAYSIZE(g_ServerName) );
            *psz = L'\\';
        }
    }

    // See if there is a whitespace break
    psz = StrChr( lpCmdLine, L' ' );
    if ( psz )
    { // yes... search backwards from the whitespace for a slash.
        psz = StrRChr( lpCmdLine, psz, L'\\' );
    }
    else
    { // no... search backwards from the end of the command line for a slash.
        psz = StrRChr( lpCmdLine, &lpCmdLine[ wcslen( lpCmdLine ) ], L'\\' );
    }

    // Found the starting path, now try to set the current directory
    // to this.
    if ( psz )
    {
        WCHAR   TmpChar = *psz;
        
        *psz = L'\0';
        lstrcpyn( szPath, lpCmdLine, ARRAYSIZE(szPath) );
        *psz = TmpChar;

        // If quoted, add a trailing quote to the path
        if ( lpCmdLine[0] == L'\"' ) {
            wcsncat( szPath, L"\"", ARRAYSIZE(szPath) - lstrlen(szPath) );
            TERMINATE_BUFFER(szPath);
        }

        DebugMsg( "Set CD to %s\n", szPath );
        SetCurrentDirectory( szPath );
    }

    // Parse for command line arguments
    if (!psz) {
        psz = lpCmdLine;
    }
    endOfCommandLine = FALSE;
    while (!endOfCommandLine && (*psz != L'\0'))
    {
        if ( *psz == '/' || *psz == '-' )
        {
            LPWSTR pszStartOption = ++psz;

            while (*psz && !IsWhiteSpace( *psz ) )
                psz++;

            if (*psz == L'\0') {
                endOfCommandLine = TRUE;
            } else {
                *psz = '\0';    // terminate
            }

            switch ( CheckWhichOption( pszStartOption ) )
            {
#ifdef DEBUG
            case OPTION_DEBUG:
                g_dwTraceFlags |= 0x80000000;    // not defined, but not zero either
                break;
            case OPTION_FUNC:
                g_dwTraceFlags |= TF_FUNC;
                break;
#endif
            case OPTION_QUIET:
                g_fQuietFlag = TRUE;
                break;

            case OPTION_PNP:
                PnP = !PnP; // toggle
                break;

            case OPTION_OEMDESKTOP:
                g_OEMDesktop = TRUE;  // The user want to clean the desktop.
                break;

            case OPTION_UNKNOWN:
                
                MessageBoxFromMessage( 
                            NULL, 
                            MSG_USAGE, 
                            FALSE, 
                            MAKEINTRESOURCE(IDS_APPNAME),
                            MB_OK );

                g_CommandLineArgsValid = FALSE;

            }
        }

        psz++;
    }
}

//
// GetWorkstationLanguage( )
//
DWORD
GetWorkstationLanguage( )
{
    TraceFunc( "GetWorkstationLanguage( )\n" );

    DWORD dwErr = ERROR_SUCCESS;
    LANGID langID = GetSystemDefaultLangID( );
    UINT uResult = 0;
    
    uResult = GetLocaleInfo( langID, LOCALE_SENGLANGUAGE, g_Language, ARRAYSIZE(g_Language) );

    if ( uResult == 0 )
    {
        DWORD dw;
        dwErr = GetLastError( );
        dw = LoadString( g_hinstance, IDS_DEFAULT_LANGUAGE, g_Language, ARRAYSIZE(g_Language));
        Assert( dw );
    }

    //
    // Fix up the locale string we got back to ensure it
    // contains no spaces and non non-ASCII characters.
    // The localization guys changed this API so that neither
    // of these properties are guarenteed any longer.
    //
    if( dwErr == ERROR_SUCCESS ) {
        for( uResult = 0; uResult < wcslen(g_Language); uResult++ ) {
            if( (g_Language[uResult] <= TEXT(' ')) ||
                (g_Language[uResult] > TEXT('~')) ) {
                g_Language[uResult] = TEXT('\0');
                break;
            }
        }
    }

    RETURN(dwErr);
}


BOOLEAN
GetInstalledProductType( 
    PDWORD Type, 
    PDWORD Mask );

//
// GetProductSKUNumber
//
DWORD
GetProductSKUNumber(
    VOID
    )
/*++

Routine Description:

    Determine SKU number of installation, which should match the
    producttype value in txtsetup.sif
    
Arguments:

    none.

Return value:

    product sku number.  if it fails, we set the return value to 0, which
    is the sku code for professional.

--*/
{
    TraceFunc( "GetProductSKUNumber( )\n" );

    DWORD ProductType, ProductSuiteMask;

    if (!GetInstalledProductType( &ProductType, &ProductSuiteMask )) {
        return 0;
    }

    if (ProductType == VER_NT_SERVER) {
        if (ProductSuiteMask & VER_SUITE_DATACENTER) {
            return 3;
        }

        if (ProductSuiteMask & VER_SUITE_ENTERPRISE) {
            return 2;
        }

        return 1;
    }

    if (ProductSuiteMask & VER_SUITE_PERSONAL) {
        return 4;
    }

    return 0;
    
}



//
// GetHalName( )
//
DWORD
GetHalName(
    VOID
    )
/*++

Routine Description:

    Determine the actual name of the HAL running on the system.
    
    The actual name of the hal is stored in the originalfilename 
    in the version resource. 

Arguments:

    none.

Return value:

    Win32 error code indicating outcome.    

--*/
{
    TraceFunc( "GetHalName( )\n" );

    DWORD dwErr = ERROR_GEN_FAILURE;
    WCHAR HalPath[MAX_PATH];
    DWORD VersionHandle;
    DWORD FileVersionInfoSize;
    PVOID VersionInfo = NULL;
    DWORD *Language,LanguageSize;
    WCHAR OriginalFileNameString[64];
    PWSTR ActualHalName;    


    //
    // the hal is in system32 directory, build a path to it.
    //
    if (!GetSystemDirectory(HalPath,ARRAYSIZE(HalPath))) {
        dwErr = GetLastError();
        goto exit;
    }
        
    wcsncat(HalPath, L"\\hal.dll", ARRAYSIZE(HalPath) - lstrlen(HalPath) );
    TERMINATE_BUFFER(HalPath);

    //
    // you must call GetFileVersionInfoSize,GetFileVersionInfo before
    // you can call VerQueryValue()
    //
    FileVersionInfoSize = GetFileVersionInfoSize(HalPath, &VersionHandle);
    if (FileVersionInfoSize == 0) {
        goto exit;
    }
    
    VersionInfo = LocalAlloc( LPTR, FileVersionInfoSize );
    if (VersionInfo == NULL) {
        goto exit;
    }

    if (!GetFileVersionInfo(
                        HalPath,
                        0, //ignored
                        FileVersionInfoSize,
                        VersionInfo)) {
        goto exit;
    }

    //
    // ok, get the language of the file so we can look in the correct
    // StringFileInfo section for the file name
    //
    if (!VerQueryValue(
            VersionInfo, 
            L"\\VarFileInfo\\Translation",
            (LPVOID*)&Language,
            (PUINT)&LanguageSize)) {
        goto exit;
    }

    _snwprintf( 
        OriginalFileNameString,
        ARRAYSIZE(OriginalFileNameString),
        L"\\StringFileInfo\\%04x%04x\\OriginalFilename",
        LOWORD(*Language),
        HIWORD(*Language));
    TERMINATE_BUFFER(OriginalFileNameString);

    //
    // now retreive the actual OriginalFilename.
    //
    if (!VerQueryValue(
             VersionInfo,
             OriginalFileNameString,
             (LPVOID*)&ActualHalName,
             (PUINT)&LanguageSize)) {
        goto exit;
    }

    //
    // store this off in a global so we can use it later on
    //
    lstrcpyn(g_HalName ,ActualHalName, ARRAYSIZE(g_HalName));

    dwErr = ERROR_SUCCESS;
    
exit:
    if (VersionInfo) {
        LocalFree( VersionInfo );
    }
    RETURN(dwErr);
}



//
// CheckUserPermissions( )
//
BOOL
CheckUserPermissions( )
{
    TraceFunc( "CheckUserPermissions( )\n" );
    if( !pSetupIsUserAdmin()
     || !pSetupDoesUserHavePrivilege(SE_SHUTDOWN_NAME)
     || !pSetupDoesUserHavePrivilege(SE_BACKUP_NAME)
     || !pSetupDoesUserHavePrivilege(SE_RESTORE_NAME)
     || !pSetupDoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME)) {
        RETURN(FALSE);
    }
    RETURN(TRUE);
}


//
// GetProcessorType( )
//
DWORD
GetProcessorType( )
{
    TraceFunc( "GetProcessorType( )\n" );

    DWORD dwErr = ERROR_INVALID_PARAMETER;
    SYSTEM_INFO si;

    GetSystemInfo( &si );
    switch (si.wProcessorArchitecture)
    {
        case PROCESSOR_ARCHITECTURE_INTEL:
            dwErr = ERROR_SUCCESS;
            wcscpy( g_Architecture, L"i386" );
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            //dwErr = ERROR_SUCCESS;
            wcscpy( g_Architecture, L"ia64" );
            break;
        case PROCESSOR_ARCHITECTURE_UNKNOWN:
        default:
            break;
    }

    RETURN(dwErr);
}

//
// WinMain()
//
int APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{

    UNREFERENCED_PARAMETER(nCmdShow);
    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(hPrevInstance);

    TraceFunc( "WinMain( ... )\n" );

    HANDLE  hMutex;
    HRESULT hr = E_FAIL;
    IMIRROR_CALLBACK IMirrorCallbacks;
    HWND hwndTasks = NULL;
    LPWSTR pszCommandLine = GetCommandLine( );

    g_hinstance = hInstance;
    ghInstance  = hInstance;

    INITIALIZE_TRACE_MEMORY_PROCESS;

    pSetupInitializeUtils();

    // allow only one instance running at a time
    hMutex = CreateMutex( NULL, TRUE, L"RIPREP.Mutext");
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        MessageBoxFromStrings( NULL,
                               IDS_ALREADY_RUNNING_TITLE,
                               IDS_ALREADY_RUNNING_MESSAGE,
                               MB_OK | MB_ICONSTOP );
        goto Cleanup;
    }

    // parse command line arguments
    ParseCommandLine( pszCommandLine );
    if (!g_CommandLineArgsValid) {
        goto Cleanup;
    }

    //
    // Gather os version info.
    //
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersion);

    // determine the language of the workstation
    GetWorkstationLanguage( );

    if (ERROR_SUCCESS != GetHalName()) {
        MessageBoxFromStrings( NULL, IDS_INVALID_ARCHITECTURE_TITLE, IDS_INVALID_ARCHITECTURE_TEXT, MB_OK );
        goto Cleanup;
    }

    _snwprintf( g_ProductId, ARRAYSIZE(g_ProductId), L"%d", GetProductSKUNumber() );
    TERMINATE_BUFFER(g_ProductId);

    ProcessCompatibilityData();

    // determine the processor type
    if ( GetProcessorType( ) != ERROR_SUCCESS )
    {
        MessageBoxFromStrings( NULL, IDS_INVALID_ARCHITECTURE_TITLE, IDS_INVALID_ARCHITECTURE_TEXT, MB_OK );
        goto Cleanup;
    }

    if ( !CheckUserPermissions( ) )
    {
        MessageBoxFromStrings( NULL, IDS_MUST_BE_ADMINISTRATOR_TITLE, IDS_MUST_BE_ADMINISTRATOR_TEXT, MB_OK );
        goto Cleanup;
    }

    // get the name of the "Winnt" directory
    GetEnvironmentVariable( L"windir", g_WinntDirectory, ARRAYSIZE(g_WinntDirectory));
    g_dwWinntDirLength = wcslen( g_WinntDirectory );

    // setup IMIRROR.DLL callbacks
    IMirrorCallbacks.Context           = 0;
    IMirrorCallbacks.ErrorFn           = &ConvTestErrorFn;
    IMirrorCallbacks.GetSetupFn        = &ConvTestGetSetupFn;
    IMirrorCallbacks.NowDoingFn        = &ConvTestNowDoingFn;
    IMirrorCallbacks.FileCreateFn      = &ConvTestFileCreateFn;
    IMirrorCallbacks.RegSaveErrorFn    = NULL;
    IMirrorCallbacks.ReinitFn          = &ConvTestReinitFn;
    IMirrorCallbacks.GetMirrorDirFn    = &ConvTestGetMirrorDirFn;
    IMirrorCallbacks.SetSystemDirFn    = &ConvTestSetSystemFn;
    IMirrorCallbacks.AddToDoFn         = &ConvAddToDoItemFn;
    IMirrorCallbacks.RemoveToDoFn      = &ConvRemoveToDoItemFn;
    IMirrorCallbacks.RebootFn          = &ConvRebootFn;
    IMirrorInitCallback(&IMirrorCallbacks);

    // show property pages
    hr = WizardPages( );

    if ( hr != S_OK )
        goto Cleanup;

    // complete tasks... ignore the return code, not important
    BeginProcess( hwndTasks );

    // Display any errors recorded in the log, unless we are supposed
    // to reboot now.
    if ( g_fErrorOccurred && !g_fRebootOnExit )
    {
        HINSTANCE hRichedDLL;

        // Make sure the RichEdit control has been initialized.
        // Simply LoadLibbing it does this for us.
        hRichedDLL = LoadLibrary( L"RICHED32.DLL" );
        if ( hRichedDLL != NULL )
        {
            DialogBox( g_hinstance, MAKEINTRESOURCE( IDD_VIEWERRORS ), g_hMainWindow, ErrorsDlgProc );
            FreeLibrary (hRichedDLL);
        }
    }

Cleanup:
    
    if (g_hCompatibilityInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile( g_hCompatibilityInf );
    }

    CleanupCompatibilityData();

    if ( hMutex )
        CloseHandle( hMutex );

    pSetupUninitializeUtils();

    UNINITIALIZE_TRACE_MEMORY;

    if ( g_fRebootOnExit ) {
        (VOID)DoShutdown(TRUE);   // TRUE tells it to restart
    }

    RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by riprep.rc
//
#define IDS_APPNAME                     1
#define IDS_ALREADY_RUNNING_TITLE       2
#define IDS_ALREADY_RUNNING_MESSAGE     3
#define IDS_ERROR                       4
#define IDS_LARGEFONTNAME               5
#define IDS_CANCELCAPTION               6
#define IDS_CANCELTEXT                  7
#define IDS_SERVER_TITLE                8
#define IDS_SERVER_SUBTITLE             9
#define IDS_DIRECTORY_TITLE             10
#define IDS_DIRECTORY_SUBTITLE          11
#define IDS_SIF_TITLE                   12
#define IDS_SIF_SUBTITLE                13
#define IDS_FINISH_TITLE                14
#define IDS_FINISH_SUBTITLE             15
#define IDS_SETUPPATH_TITLE             16
#define IDS_SETUPPATH_SUBTITLE          17
#define IDS_INITIALIZE                  18
#define IDS_VERIFY_WINDOWS_VERSION      19
#define IDS_ANALYZE_PARTITIONS          20
#define IDS_COPY_PARTITIONS             21
#define IDS_COPY_FILES                  22
#define IDS_COPY_REGISTRY               23
#define IDS_PATH_DS_ENTRIES             24
#define IDS_UNKNOWN_TASK                25
#define IDS_INITIALIZING                26
#define IDS_VERIFYING_WINDOWS_VERSION   27
#define IDS_ANALYZING_PARTITIONS        28
#define IDS_COPYING_PARTITIONS          29
#define IDS_COPYING_FILES               30
#define IDS_COPYING_REGISTRY            31
#define IDS_UPDATING_DS_ENTRIES         32
#define IDS_DOING_UNKNOWN_TASK          33
#define IDS_REBOOT_SYSTEM               34
#define IDS_REBOOTING_SYSTEM            35
#define IDS_APPLICATION_TITLE           37
#define IDS_APPLICATION_SUBTITLE        38
#define IDS_OSCHOOSER_RESTRICTION_TITLE 42
#define IDS_OSCHOOSER_RESTRICTION_TEXT  43
#define IDS_DIRECTORY_EXISTS_TITLE      44
#define IDS_DIRECTORY_EXISTS_TEXT       45
#define IDS_FAILED_TO_CONTACT_SERVER_TITLE 46
#define IDS_NOT_A_BINL_SERVER_TITLE     47
#define IDS_NOT_A_BINL_SERVER_TEXT      48
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE 49
#define IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT 50
#define IDS_DEFAULT_LANGUAGE            51
#define IDS_UNKNOWN                     52
#define IDS_PROCESS_NAME_COLUMN         53
#define IDS_APPL_NAME_COLUMN            54
#define IDS_DISK_FULL_TITLE             55
#define IDS_DISK_FULL_TEXT              56
#define IDS_ENCRYPTED_FILE_TITLE        57
#define IDS_ENCRYPTED_FILE_TEXT         58
#define IDS_MUST_BE_ADMINISTRATOR_TITLE 59
#define IDS_MUST_BE_ADMINISTRATOR_TEXT  60
#define IDS_MUST_BE_WORKSTATION_TITLE   61
#define IDS_SHARING_VIOLATION_TITLE     64
#define IDS_SHARING_VIOLATION_TEXT      65
#define IDS_ACCESS_DENIED_TITLE         66
#define IDS_ACCESS_DENIED_TEXT          67
#define IDS_MULTIPLE_DISK_TITLE         68
#define IDS_MULTIPLE_DISK_TEXT          69
#define IDS_BOOT_PARTITION_TITLE        70
#define IDS_BOOT_PARTITION_TEXT         71
#define IDS_NOT_COPYING_REPARSE_POINT_TITLE 72
#define IDS_NOT_COPYING_REPARSE_POINT_TEXT 73
#define IDS_INVALID_ARCHITECTURE_TITLE  74
#define IDS_INVALID_ARCHITECTURE_TEXT   75
#define IDS_MISSING_BACKING_FLAT_IMAGE_TITLE 76
#define IDS_MISSING_BACKING_FLAT_IMAGE_TEXT 77
#define IDS_QUIET                       78
#define IDS_ACCESS_DENIED_LOG           79
#define IDS_SHARING_VIOLATION_LOG       80
#define IDS_NOT_COPYING_REPARSE_POINT_LOG 81
#define IDS_ENCRYPTED_FILE_LOG          82
#define IDS_BOOT_PARTITION_LOG          83
#define IDS_MULTIPLE_DISK_LOG           84
#define IDS_DISK_FULL_LOG               85
#define IDS_END_LOG                     86
#define IDS_ERROR_IGNORED               87
#define IDS_OPERATION_ABORTED           88
#define IDS_DYNAMIC_DISK_TITLE          89
#define IDS_DYNAMIC_DISK_TEXT           90
#define IDS_RETRY_ABORT_IGNORE_TEXT     91
#define IDS_STATUS_RETRY                92
#define IDS_UNKNOWN_OPTION_FORMAT       93
#define IDS_CANT_BE_DC_TITLE            94
#define IDS_CANT_BE_DC_TEXT             95
#define IDS_COMPAT_TITLE                96
#define IDS_COMPAT_SUBTITLE             97
#define IDS_COMPAT_ERR                  98
#define IDS_COMPAT_WRN                  99
#define IDS_COMPAT_ERR_WRN              100
#define IDD_SERVER                      101
#define IDD_WELCOME                     102
#define IDD_OSDIRECTORY                 103
#define IDI_SETUP                       104
#define IDD_SUMMARY                     104
#define IDB_X                           105
#define IDB_HEADER                      108
#define IDB_TITLEPAGE                   109
#define IDD_DEFAULTSIF                  110
#define IDB_ARROW                       110
#define IDD_TASKS                       111
#define IDB_CHECK                       111
#define IDD_SETUPPATH                   113
#define IDD_APPLICATIONS_RUNNING        114
#define IDD_COMPLETE                    115
#define IDD_VIEWERRORS                  116
#define IDD_COMPAT                      117
#define IDD_COMPATIBILITY_TEXT          118
#define IDS_STOPSVC_TITLE               119
#define IDS_STOPSVC_SUBTITLE            120
#define IDS_STOPSVC_WRN                 121
#define IDD_STOPSVCWRN                  122
#define IDS_SERVICE_DESCRIPTION_COLUMN  123
#define IDS_SERVICE_NAME_COLUMN         124
#define IDD_STOPSVC                     125
#define IDC_STOP_SERVICE                126
#define IDS_INCOMPAT_STOP_FORMAT        127
#define IDS_INCOMPAT_WARN_FORMAT        128
#define IDS_INCOMPAT_MSG_TITLE          129
#define IDS_STOPSVC_FAIL_TITLE          130
#define IDS_STOPSVC_FAIL_TEXT           131
#define IDS_SERVICE_DESC_UNKNOWN        200
#define IDS_SERVICE_DESC_FORMAT         201
#define IDS_MULTIPLE_PROFILES           202
#define IDS_MULTIPLE_PROFILES_DESC      203
#define IDS_SERVER_ACCESS               204
#define IDS_SERVER_ACCESS_DESC          205
#define IDS_ACTIVIATION_COUNT_EXCEEDED  206
#define IDS_ADMINISTRATOR1              207
#define IDS_OWNER1                      208
#define IDS_TEMP_DIR                    209
#define IDS_TEMP_INTERNET_DIR           210
#define IDS_SID_DIR1                    211
#define IDS_SID_DIR2                    212
#define IDS_SID_DIR3                    213 
#define IDS_HISTORY_DIR                 214
#define IDS_HISTORY_DIR_IE5             215
#define IDC_E_SERVER                    1000
#define IDC_E_OSDIRECTORY               1001
#define IDC_L_TASKS                     1005
#define IDC_L_IMAGES                    1005
#define IDC_L_PROCESSES                 1005
#define IDC_S_OPERATION                 1006
#define IDC_TITLE                       1008
#define IDC_S_SERVERNAME                1009
#define IDC_S_DIRECTORY                 1010
#define IDC_E_ERRORS                    1013
#define IDC_E_HELPTEXT                  1030
#define IDC_E_DESCRIPTION               1042
#define IDC_INTRO_TEXT                  1050
#define IDC_ROOT_LIST                   1051
#define IDC_DETAILS                     1052
#define IDT_DETAIL_TEXT                 1053
#define IDC_TEXT                        1054

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\rsrcutil.cpp ===
#include "pch.h"
#pragma hdrstop

#include "utils.h"

DEFINE_MODULE( "RIPREP" )

TCHAR   gBuffer0[5000];
TCHAR   gBuffer1[5000];


INT
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN LPCTSTR  CaptionString,
    IN UINT     Style,
    IN va_list *Args
    )
{

    if((DWORD_PTR)CaptionString > 0xffff) {
        //
        // It's a string already.
        //
        lstrcpyn(gBuffer0,CaptionString, ARRAYSIZE(gBuffer0));
    } else {
        //
        // It's a string id
        //
        if(!LoadString(g_hinstance,PtrToUlong(CaptionString),gBuffer0, ARRAYSIZE(gBuffer0))) {
            gBuffer0[0] = 0;
        }
    }

    FormatMessage(
        SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MessageId,
        0,
        gBuffer1,
        ARRAYSIZE(gBuffer1),
        Args
        );

    return(MessageBox(Window,gBuffer1,gBuffer0,Style));
}


INT
MessageBoxFromMessage(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN BOOL    SystemMessage,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    )
{
    va_list arglist;
    INT i;

    va_start(arglist,Style);

    i = MessageBoxFromMessageV(Window,MessageId,SystemMessage,CaptionString,Style,&arglist);

    va_end(arglist);

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\serverdlg.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"
#include <winver.h>
#include <sputils.h>

DEFINE_MODULE( "RIPREP" )


BOOLEAN
GetInstalledProductType(
    OUT PDWORD  ProductType,
    OUT PDWORD  ProductSuite
    ) 
/*++

Routine Description:

    retrieves the product type and suite from a running system

Arguments:

    ProductType - receives a VER_NT_* constant.
    ProductSuite - receives a VER_SUITE_* mask for the system.
    
Return Value:

    TRUE indicates success

--*/
{
    OSVERSIONINFOEX VersionInfo;

    VersionInfo.dwOSVersionInfoSize  = sizeof(VersionInfo);

    if (GetVersionEx((OSVERSIONINFO *)&VersionInfo)) {
        //
        // make domain controllers and servers look the same
        //
        *ProductType = (VersionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER)
                         ? VER_NT_SERVER 
                         : VersionInfo.wProductType;
        //
        // we only care about suites that have a SKU associated with them.
        //
        *ProductSuite = (VersionInfo.wSuiteMask   
            & (VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER | VER_SUITE_PERSONAL)) ;

        

        return(TRUE);
    }

    return(FALSE);

}

BOOL
pSetupEnablePrivilegeW(
    IN PCWSTR PrivilegeName,
    IN BOOL   Enable
    )

/*++

Routine Description:

    Enable or disable a given named privilege.

Arguments:

    PrivilegeName - supplies the name of a system privilege.

    Enable - flag indicating whether to enable or disable the privilege.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/

{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}


GetSuiteMaskFromPath(
    IN PCWSTR PathToSearch,
    OUT PDWORD SuiteMask
    )
{
    #define HIVENAME L"riprepsetupreg"
    TCHAR lpszSetupReg[MAX_PATH] = HIVENAME L"\\ControlSet001\\Services\\setupdd";

    WCHAR Path[MAX_PATH];
    WCHAR DestPath[MAX_PATH];
    LONG rslt;
    HKEY hKey;
    DWORD Type;
    DWORD Buffer[4];
    DWORD BufferSize = sizeof(Buffer);
    BOOLEAN RetVal = FALSE;

    GetTempPath(ARRAYSIZE(Path),Path);
    GetTempFileName( Path, L"ripr", 0, DestPath);

    if (-1 == _snwprintf(
                Path,
                MAX_PATH,
                L"%ws\\setupreg.hiv",
                PathToSearch)) {
        goto e0;
    }
    TERMINATE_BUFFER(Path);

    if (!CopyFile(Path,DestPath,FALSE)) {
        goto e0;
    }

    SetFileAttributes(DestPath,FILE_ATTRIBUTE_NORMAL);

    //
    // need SE_RESTORE_NAME priviledge to call this API!
    //
    pSetupEnablePrivilegeW( SE_RESTORE_NAME, TRUE );

    //
    // try to unload this first in case we faulted or something and the key is still loaded
    //
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HIVENAME );

    rslt = RegLoadKey( HKEY_LOCAL_MACHINE, HIVENAME, DestPath );
    if (rslt != ERROR_SUCCESS) {
        goto e1;
    }
          
    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszSetupReg,&hKey);
    if (rslt != ERROR_SUCCESS) {
        goto e2;
    }

    rslt = RegQueryValueEx(hKey, NULL, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != ERROR_SUCCESS || Type != REG_BINARY) {
        goto e3;
    }
    
    *SuiteMask=Buffer[3];
    
    RetVal = TRUE;

e3:
    RegCloseKey( hKey );
e2:
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HIVENAME );

e1:
    if (GetFileAttributes(DestPath) != 0xFFFFFFFF) {
        SetFileAttributes(DestPath,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(DestPath);
        wcscat(DestPath, L".LOG");
        SetFileAttributes(DestPath,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(DestPath);
    }

    pSetupEnablePrivilegeW( SE_RESTORE_NAME, FALSE );
e0:
    return(RetVal);
}

BOOLEAN
GetProductTypeFromPath(
    OUT PDWORD ProductType, 
    OUT PDWORD ProductSuite,
    IN  PCWSTR PathToSearch )
/*++

Routine Description:

    retrieves the product type and suite by looking in txtsetup.sif

Arguments:

    ProductType - receives a VER_NT_* constant.
    ProductSuite - receives a VER_SUITE_* mask for the system.
    PathToSearch - specifies the path to the txtsetup.sif to be searched
    
Return Value:

    TRUE indicates success

--*/
{
    WCHAR Path[MAX_PATH];
    UINT DontCare;
    HINF hInf;
    WCHAR Type[20];
    BOOLEAN RetVal = TRUE;
    INFCONTEXT Context;

    if (-1 == _snwprintf(
                Path,
                MAX_PATH,
                L"%ws\\txtsetup.sif",
                PathToSearch)) {
        RetVal = FALSE;
        goto e0;
    }
    TERMINATE_BUFFER(Path);

    hInf = SetupOpenInfFile( Path, NULL, INF_STYLE_WIN4, &DontCare );
    if (hInf == INVALID_HANDLE_VALUE) {
        RetVal = FALSE;
        goto e0;
    }
    
    if (SetupFindFirstLine( hInf, L"SetupData", L"ProductType", &Context) &&
    SetupGetStringField( &Context, 1, Type, ARRAYSIZE(Type), NULL)) {
        switch (Type[0]) {
        case L'0':
            *ProductType = VER_NT_WORKSTATION;
            *ProductSuite = 0;
            break;
        case L'1':
            *ProductType = VER_NT_SERVER;
            //
            // HACK alert: we have to call this API because txtsetup.sif 
            // didn't have the correct product type in it in win2k.  
            // So we do it the hard way.
            //
            if (!GetSuiteMaskFromPath( PathToSearch, ProductSuite)) {
                *ProductSuite = 0;
            }
            break;
        case L'2':
            *ProductType = VER_NT_SERVER;
            *ProductSuite = VER_SUITE_ENTERPRISE;
            break;
        case L'3':
            *ProductType = VER_NT_SERVER;
            *ProductSuite = VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER;
            break;
        case L'4':
            *ProductType = VER_NT_WORKSTATION;
            *ProductSuite = VER_SUITE_PERSONAL;
            break;
        default:
            ASSERT( FALSE && L"Unknown type in txtsetup.sif ProductType" );
            RetVal = FALSE;
            break;
        }

    }

    SetupCloseInfFile(hInf);        
    
e0:
    return(RetVal);

}

//
// GetNtVersionInfo( )
//
// Retrieves the build version from the kernel
//
BOOLEAN
GetNtVersionInfo(
    PULONGLONG Version,
    PWCHAR SearchDir
    )
{
    DWORD FileVersionInfoSize;
    DWORD VersionHandle;
    ULARGE_INTEGER TmpVersion;
    PVOID VersionInfo;
    VS_FIXEDFILEINFO * FixedFileInfo;
    UINT FixedFileInfoLength;
    WCHAR Path[MAX_PATH];
    BOOLEAN fResult = FALSE;

    TraceFunc("GetNtVersionInfo( )\n");

    // Resulting string should be something like:
    //      "\\server\reminst\Setup\English\Images\nt50.wks\i386\ntoskrnl.exe"

    if (!SearchDir) {
        goto e0;
    }
    lstrcpyn(Path, SearchDir, ARRAYSIZE(Path));
    wcsncat(Path, L"\\ntoskrnl.exe", ARRAYSIZE(Path) - lstrlen(Path));
    TERMINATE_BUFFER(Path);

    FileVersionInfoSize = GetFileVersionInfoSize(Path, &VersionHandle);
    if (FileVersionInfoSize == 0)
        goto e0;

    VersionInfo = LocalAlloc( LPTR, FileVersionInfoSize );
    if (VersionInfo == NULL)
        goto e0;

    if (!GetFileVersionInfo(
             Path,
             VersionHandle,
             FileVersionInfoSize,
             VersionInfo)) {
        goto e1;
    }

    if (!VerQueryValue(
             VersionInfo,
             L"\\",
             (LPVOID*)&FixedFileInfo,
             &FixedFileInfoLength)) {
        goto e1;
    }

    TmpVersion.HighPart = FixedFileInfo->dwFileVersionMS;
    TmpVersion.LowPart = FixedFileInfo->dwFileVersionLS;

    //
    // We need to whack the low 16 bits of the .LowPart so that
    // we ignore the service pack value.  For example, WindowsXP has a
    // version number of 5.1.2600.0.  XP-ServicePack1 has a version
    // number of 5.1.2600.1038.  We'd like those to match, so just whack
    // the servicepack number portion.
    //
    TmpVersion.LowPart &= 0xFFFF0000;

    *Version = TmpVersion.QuadPart;

    fResult = TRUE;

e1:
    LocalFree( VersionInfo );
e0:
    RETURN(fResult);
}

//
// VerifyMatchingFlatImage( )
//
BOOLEAN
VerifyMatchingFlatImage( 
    PULONGLONG VersionNeeded  OPTIONAL
    )
{
    TraceFunc( "VerifyMatchingFlatImage( )\n" );

    BOOLEAN fResult = FALSE;   // assume failure
    DWORD dwLen;
    WCHAR szPath[ MAX_PATH ];
    WIN32_FIND_DATA fd;    
    HANDLE hFind;
    ULONGLONG OurVersion;
    DWORD OurProductType = 0, OurProductSuiteMask = 0;

    GetSystemDirectory( szPath, ARRAYSIZE( szPath ));
    GetNtVersionInfo( &OurVersion, szPath );

    GetInstalledProductType( &OurProductType, &OurProductSuiteMask );

    if (VersionNeeded) {
        *VersionNeeded = OurVersion;
    }

    DebugMsg( 
        "Our NTOSKRNL verion: %u.%u:%u.%u Type: %d Suite: %d\n", 
        HIWORD(((PULARGE_INTEGER)&OurVersion)->HighPart),
        LOWORD(((PULARGE_INTEGER)&OurVersion)->HighPart),
        HIWORD(((PULARGE_INTEGER)&OurVersion)->LowPart),
        LOWORD(((PULARGE_INTEGER)&OurVersion)->LowPart),
        OurProductType,
        OurProductSuiteMask);

    _snwprintf( szPath,
                ARRAYSIZE(szPath),
                L"\\\\%s\\REMINST\\Setup\\%s\\%s\\",
                g_ServerName,
                g_Language,
                REMOTE_INSTALL_IMAGE_DIR_W );
    TERMINATE_BUFFER(szPath);

    dwLen = wcslen( szPath );

    wcsncat(szPath, L"*", ARRAYSIZE(szPath) - lstrlen(szPath));
    TERMINATE_BUFFER(szPath);

    hFind = FindFirstFile( szPath, &fd );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do {
            if ( (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
              && StrCmp( fd.cFileName, L"." ) != 0 
              && StrCmp( fd.cFileName, L".." ) != 0 )
            {
                ULONGLONG Version;
                DWORD ProductType = 0, ProductSuiteMask = 0;
                _snwprintf( &szPath[dwLen],
                            ARRAYSIZE(szPath) - dwLen,
                            L"%s\\%s",
                            fd.cFileName,
                            g_Architecture );
                TERMINATE_BUFFER(szPath);

                
                if ( GetNtVersionInfo( &Version, szPath ) &&
                     GetProductTypeFromPath( 
                                    &ProductType, 
                                    &ProductSuiteMask, 
                                    szPath ))
                {
                    DebugMsg( 
                        "%s's verion: %u.%u:%u.%u Type: %d Suite: %d\n",
                        fd.cFileName, 
                        HIWORD(((PULARGE_INTEGER)&Version)->HighPart),
                        LOWORD(((PULARGE_INTEGER)&Version)->HighPart),
                        HIWORD(((PULARGE_INTEGER)&Version)->LowPart),
                        LOWORD(((PULARGE_INTEGER)&Version)->LowPart),
                        ProductType,
                        ProductSuiteMask);
                                                      
                    if ( OurVersion == Version &&
                         OurProductType == ProductType &&
                         OurProductSuiteMask == ProductSuiteMask )
                    {
                        wcscpy( g_ImageName, szPath );
                        fResult = TRUE;
                        break;
                    }
                }                          
            }
        } while ( FindNextFile( hFind, &fd ) );
    }

    FindClose( hFind );

    RETURN(fResult);
}

//
// VerifyServerName( )
//
// Check to see if the server is a Remote Installation Server by
// checking for the existance of the "REMINST" share.
//
DWORD
VerifyServerName( )
{
    TraceFunc( "VerifyServerName( )\n" );

    NET_API_STATUS netStatus;
    SHARE_INFO_0 * psi;

    HCURSOR oldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

    netStatus = NetShareGetInfo( g_ServerName, L"REMINST", 0, (LPBYTE *) &psi );
    if ( netStatus == NERR_Success )
    {
        NetApiBufferFree( psi );
    }

    SetCursor( oldCursor );

    RETURN(netStatus);
}

BOOL
VerifyServerAccess(
    PCWSTR  ServerShareName,
    PCWSTR  ServerLanguage
    )
/*++

Routine Description:

    Checks permissions on the RIPREP server machine by trying to create a file on the
    server.  The temp file is then deleted.

Arguments:

    ServerShareName - path that we want to check permissions on.
    ServerLanguage  - indicates the language subdirectory to check for access in.
        

Return value:

    TRUE if the user has access to the server, FALSE otherwise.    

--*/
{
    TraceFunc( "VerifyServerAccess( )\n" );

    WCHAR FileName[MAX_PATH];
    WCHAR FilePath[MAX_PATH];
    BOOL RetVal;
    
    HCURSOR oldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

    _snwprintf(FilePath,
               ARRAYSIZE(FilePath),
               L"\\\\%s\\reminst\\Setup\\%s\\Images",
               ServerShareName, 
               ServerLanguage );
    TERMINATE_BUFFER(FilePath);

    RetVal = GetTempFileName( FilePath , L"ACC", 0, FileName );
    if (RetVal) {
        //
        // delete the file, we don't want to leave turds on the server
        //
        DeleteFile(FileName);
        RetVal = TRUE;
    } else if (GetLastError() == ERROR_ACCESS_DENIED) {
        RetVal = FALSE;
    } else {
        //
        // GetTempFileName failed, but not because of an access problem, so
        // return success
        //
        RetVal = TRUE;
    }
    
    SetCursor( oldCursor );

    RETURN(RetVal);
}




//
// ServerDlgCheckNextButtonActivation( )
//
VOID
ServerDlgCheckNextButtonActivation(
    HWND hDlg )
{
    TraceFunc( "ServerDlgCheckNextButtonActivation( )\n" );
    WCHAR szName[ MAX_PATH ];
    GetDlgItemText( hDlg, IDC_E_SERVER, szName, ARRAYSIZE(szName));
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | (wcslen(szName) ? PSWIZB_NEXT : 0 ) );
    TraceFuncExit( );
}

//
// ServerDlgProc()
//
INT_PTR CALLBACK
ServerDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    ULARGE_INTEGER ImageVersion;
    WCHAR szTemp[ 1024 ];
    WCHAR szCaption[ 1024 ];
    WCHAR ErrorText[ 1024 ];
    DWORD dw;

    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        CenterDialog( GetParent( hDlg ) );
        return FALSE;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_SERVER:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                ServerDlgCheckNextButtonActivation( hDlg );
            }
            break;
        }
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            {
                GetDlgItemText( hDlg, IDC_E_SERVER, g_ServerName, ARRAYSIZE(g_ServerName) );

                //remove the wackwack if found
                if ( g_ServerName[0] == L'\\' && g_ServerName[1] == L'\\' )
                {
                    wcscpy( g_ServerName, &g_ServerName[2] );
                }

                Assert( wcslen( g_ServerName ) );
                DWORD dwErr = VerifyServerName( );
                if ( dwErr != ERROR_SUCCESS )
                {
                    switch (dwErr)
                    {
                    case NERR_NetNameNotFound:
                        MessageBoxFromStrings( hDlg, IDS_NOT_A_BINL_SERVER_TITLE, IDS_NOT_A_BINL_SERVER_TEXT, MB_OK );
                        break;

                    default:
                        dw = LoadString( g_hinstance, IDS_FAILED_TO_CONTACT_SERVER_TITLE, szTemp, ARRAYSIZE(szTemp) );
						Assert( dw );
                        MessageBoxFromError( hDlg, szTemp, dwErr, NULL, MB_OK );
                        break;
                    }
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                    break;
                }

                BOOL fFoundMatchingFlatImage = VerifyMatchingFlatImage( (PULONGLONG)&ImageVersion );
                if ( !fFoundMatchingFlatImage )
                {
                    dw = LoadString( g_hinstance, IDS_MISSING_BACKING_FLAT_IMAGE_TEXT, szTemp, ARRAYSIZE(szTemp) );
                    ASSERT(dw);

                    dw = LoadString( g_hinstance, IDS_MISSING_BACKING_FLAT_IMAGE_TITLE, szCaption, ARRAYSIZE(szCaption) );
                    ASSERT(dw);

                    _snwprintf(
                        ErrorText,
                        ARRAYSIZE(ErrorText),
                        szTemp, 
                        HIWORD(ImageVersion.HighPart),
                        LOWORD(ImageVersion.HighPart),
                        HIWORD(ImageVersion.LowPart),
                        g_Language );
                    TERMINATE_BUFFER(ErrorText);

                    MessageBox( hDlg, ErrorText, szCaption, MB_OK );
                    
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                    break;
                }

                if (!VerifyServerAccess(g_ServerName,g_Language)) {
                    dw = LoadString( g_hinstance, IDS_SERVER_ACCESS_DESC, ErrorText, ARRAYSIZE(ErrorText) );
                    ASSERT(dw);

                    dw = LoadString( g_hinstance, IDS_SERVER_ACCESS, szCaption, ARRAYSIZE(szCaption) );
                    ASSERT(dw);

                    MessageBox( hDlg, ErrorText, szCaption, MB_OK );
                    
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                    break;
                }
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            SetDlgItemText( hDlg, IDC_E_SERVER, g_ServerName );
            ServerDlgCheckNextButtonActivation( hDlg );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\serverdlg.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.H


 ***************************************************************************/

#ifndef _SERVERDLG_H_
#define _SERVERDLG_H_

INT_PTR CALLBACK
ServerDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _SERVERDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\setup.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SETUP.CPP

 ***************************************************************************/

#include "pch.h"
#include "utils.h"
#include "logging.h"
#include "errorlog.h"
#include "tasks.h"

DEFINE_MODULE("RIPREP")

//
// EndProcess( )
//
HRESULT
EndProcess( 
    HWND hDlg )
{
    TraceFunc( "EndProcess( )\n" );
    HRESULT hr = S_OK;
    WCHAR szSrcPath[ MAX_PATH ];
    WCHAR szDestPath[ MAX_PATH ];
    WCHAR szMajor[ 10 ];
    WCHAR szMinor[ 10 ];
    WCHAR szBuild[ 10 ];
    BOOL b;
    DWORD dw;

    _snwprintf( szDestPath, 
                ARRAYSIZE(szDestPath),
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates", 
              g_ServerName, 
              g_Language, 
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    TERMINATE_BUFFER(szDestPath);
    CreateDirectory( szDestPath, NULL );

    _snwprintf( szSrcPath, ARRAYSIZE(szSrcPath), L"%s\\templates\\startrom.com", g_ImageName );
    TERMINATE_BUFFER(szSrcPath);
    _snwprintf( szDestPath, 
                ARRAYSIZE(szDestPath),
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates\\startrom.com", 
              g_ServerName, 
              g_Language, 
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    TERMINATE_BUFFER(szDestPath);
    b = CopyFile( szSrcPath, szDestPath, FALSE );
    if ( !b )
    {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"STARTROM.COM";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( hDlg, WM_ERROR_OK, 0, (LPARAM) &item );
    }

    _snwprintf( szSrcPath, ARRAYSIZE(szSrcPath), L"%s\\templates\\ntdetect.com", g_ImageName );
    TERMINATE_BUFFER(szSrcPath);
    _snwprintf( szDestPath,
                ARRAYSIZE(szDestPath),
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates\\ntdetect.com", 
              g_ServerName, 
              g_Language, 
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    TERMINATE_BUFFER(szDestPath);
    b = CopyFile( szSrcPath, szDestPath, FALSE );
    if ( !b )
    {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"NTDETECT.COM";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( hDlg, WM_ERROR_OK, 0, (LPARAM) &item );
    }

    _snwprintf( szSrcPath, ARRAYSIZE(szSrcPath), L"%s\\templates\\ntldr", g_ImageName );
    TERMINATE_BUFFER(szSrcPath);
    _snwprintf( szDestPath,
                ARRAYSIZE(szDestPath),
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates\\ntldr", 
              g_ServerName, 
              g_Language,
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    TERMINATE_BUFFER(szDestPath);
    b = CopyFile( szSrcPath, szDestPath, FALSE );
    if ( !b )
    {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"NTLDR";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( hDlg, WM_ERROR_OK, 0, (LPARAM) &item );
    }

    wsprintf( szMajor, L"%u", OsVersion.dwMajorVersion );
    wsprintf( szMinor, L"%u", OsVersion.dwMinorVersion );
    wsprintf( szBuild, L"%u", OsVersion.dwBuildNumber  );    

    //
    // Need to add "Quotes" around the text
    //
    WCHAR szDescription[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT  + 2 ];
    WCHAR szHelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT  + 2 ];
    WCHAR szOSVersion[ 30 ];
    WCHAR szSystemRoot[ MAX_PATH ];

    _snwprintf( szDescription, ARRAYSIZE(szDescription), L"\"%s\"", g_Description );
    TERMINATE_BUFFER(szDescription);
    _snwprintf( szHelpText, ARRAYSIZE(szHelpText), L"\"%s\"", g_HelpText );
    TERMINATE_BUFFER(szHelpText);
    _snwprintf( szOSVersion, ARRAYSIZE(szOSVersion), L"\"%s.%s (%s)\"", szMajor, szMinor, szBuild );
    TERMINATE_BUFFER(szOSVersion);
    _snwprintf( szSystemRoot, ARRAYSIZE(szSystemRoot), L"\"%s\"", g_SystemRoot );
    TERMINATE_BUFFER(szSystemRoot);
    _snwprintf( szDestPath,
                ARRAYSIZE(szDestPath),
              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s\\Templates\\riprep.sif", 
              g_ServerName, 
              g_Language,
              REMOTE_INSTALL_IMAGE_DIR_W, 
              g_MirrorDir, 
              g_Architecture );
    TERMINATE_BUFFER(szDestPath);

    _snwprintf( szSrcPath, ARRAYSIZE(szSrcPath), L"%s\\ristndrd.sif", g_ImageName );
    TERMINATE_BUFFER(szSrcPath);
    b = CopyFile( szSrcPath, szDestPath, FALSE );
    if ( !b )
    {
        LBITEMDATA item;

        // Error will be logged in TASKS.CPP
        item.fSeen   = FALSE;
        item.pszText = L"RISTNDRD.SIF";
        item.uState  = GetLastError( );
        item.todo    = RebootSystem;

        SendMessage( hDlg, WM_ERROR_OK, 0, (LPARAM) &item );
    }

    WritePrivateProfileString( L"OSChooser",
                               L"Description",
                               szDescription,
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"Help",
                               szHelpText,
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"ImageType",
                               L"SYSPREP",
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"Version",
                               szOSVersion,
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"SysPrepSystemRoot",
                               szSystemRoot,
                               szDestPath );

    WritePrivateProfileString( L"SetupData",
                               L"SysPrepDevice",
                               L"\"\\Device\\LanmanRedirector\\%SERVERNAME%\\RemInst\\%SYSPREPPATH%\"",
                               szDestPath );

    WritePrivateProfileString( L"SetupData",
                               L"SysPrepDriversDevice",
                               L"\"\\Device\\LanmanRedirector\\%SERVERNAME%\\RemInst\\%SYSPREPDRIVERS%\"",
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"LaunchFile",
                               L"\"%INSTALLPATH%\\%MACHINETYPE%\\templates\\startrom.com\"",
                               szDestPath );

//  WritePrivateProfileString( L"SetupData",
//                             L"OsLoadOptions",
//                             L"\"/noguiboot /fastdetect\"",
//                             szDestPath );

    WritePrivateProfileString( L"SetupData",
                               L"SetupSourceDevice",
                               L"\"\\Device\\LanmanRedirector\\%SERVERNAME%\\RemInst\\%INSTALLPATH%\"",
                               szDestPath );

    WritePrivateProfileString( L"UserData",
                               L"ComputerName",
                               L"\"%MACHINENAME%\"",
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"HalName",
                               g_HalName,
                               szDestPath );

    WritePrivateProfileString( L"OSChooser",
                               L"ProductType",
                               g_ProductId,
                               szDestPath );


    // End the log
    dw = LoadString( g_hinstance, IDS_END_LOG, szSrcPath, ARRAYSIZE( szSrcPath ));
    Assert( dw );
    LogMsg( szSrcPath );
    
    // Display any errors recorded in the log
    if ( g_fErrorOccurred ) 
    {
        HINSTANCE hRichedDLL;

        // Make sure the RichEdit control has been initialized.
        // Simply LoadLibbing it does this for us.
        hRichedDLL = LoadLibrary( L"RICHED32.DLL" );
        if ( hRichedDLL != NULL )
        {
            DialogBox( g_hinstance, MAKEINTRESOURCE( IDD_VIEWERRORS ), hDlg, ErrorsDlgProc );
            FreeLibrary (hRichedDLL);
        }
    }

    RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\setupdlg.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SETUPDLG.H


 ***************************************************************************/

#ifndef _SETUPDLG_H_
#define _SETUPDLG_H_

INT_PTR CALLBACK
SetupPathDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _SETUPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\setup.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SETUP.H

 ***************************************************************************/

#ifndef _SETUP_H_
#define _SETUP_H_

HRESULT
EndProcess( 
    HWND hDlg );

#endif // _SETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\sif.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.H


 ***************************************************************************/

#ifndef _SIF_H_
#define _SIF_H_

INT_PTR CALLBACK
SIFDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _SIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\setupdlg.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SETUPDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"

DEFINE_MODULE( "RIPREP" )

//
// DetermineSetupPath( )
//
// Try to figure out if the server selected is the same server
// that this client computer was installed from. If so, make the
// assumption that he'll choose the same image that installed it.
// We'll bypass the screen and auto-fill the g_ImageName.
//
// Returns: TRUE if we were able to that the system was installed
//               from the save server that we are posting to.
//          otherwize FALSE
//
BOOLEAN
DetermineSetupPath( )
{
    HKEY hkeySetup = (HKEY) INVALID_HANDLE_VALUE;
    LONG lResult;
    WCHAR szServerPath[ MAX_PATH ];
    WCHAR szPath[ MAX_PATH ];
    DWORD cbPath;
    BOOLEAN fMatch = FALSE;

    TraceFunc( "DetermineSetupPath( )\n" );

    _snwprintf( szServerPath, ARRAYSIZE(szServerPath), L"\\\\%s", g_ServerName );
    TERMINATE_BUFFER(szServerPath);

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup",
                            0, // reserved
                            KEY_READ,
                            &hkeySetup );
    if ( lResult != ERROR_SUCCESS )
        goto Error;

    cbPath = sizeof(szPath );
    lResult = RegQueryValueEx( hkeySetup,
                               L"SourcePath",
                               0, // reserved
                               NULL,
                               (LPBYTE) &szPath,
                               &cbPath );
    if ( lResult != ERROR_SUCCESS )
        goto Error;

    if ( StrCmpNI( szPath, szServerPath, wcslen( szServerPath ) ) == 0 )
    {
        _snwprintf( g_ImageName, ARRAYSIZE(g_ImageName), L"%s\\%s", szPath, g_Architecture );
        TERMINATE_BUFFER(g_ImageName);
        DebugMsg( "Found Match! Using %s for SetupPath\n", g_ImageName );
        fMatch = TRUE;
    }

Error:
    if ( hkeySetup != INVALID_HANDLE_VALUE )
        RegCloseKey( hkeySetup );

    RETURN(fMatch);
}

void
PopulateImagesListbox2(
    HWND hwndList,
    LPWSTR pszDirName,
    LPWSTR pszOSPath )
{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    WCHAR szPath[ MAX_PATH ];

    TraceFunc( "PopulateImagesListbox2( )\n" );

    _snwprintf( szPath, ARRAYSIZE(szPath), L"%s\\%s\\%s\\templates\\*.sif", pszOSPath, pszDirName, g_Architecture );
    TERMINATE_BUFFER(szPath);

    hFind = FindFirstFile( szPath, &fd );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if (( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
            {
                WCHAR szType[ 64 ];
                DWORD dwCount;
                _snwprintf( szPath, ARRAYSIZE(szPath), L"%s\\%s\\%s\\templates\\%s", pszOSPath, pszDirName, g_Architecture, fd.cFileName );
                TERMINATE_BUFFER(szPath);
                dwCount = GetPrivateProfileString( L"OSChooser",
                                                   L"ImageType",
                                                   L"",
                                                   szType,
                                                   ARRAYSIZE(szType),
                                                   szPath );
                if ( dwCount
                  && StrCmpIW( szType, L"flat" ) == 0 )
                {
                    ListBox_AddString( hwndList, pszDirName );
                    break; // list only once!
                }
            }
        } while ( FindNextFile( hFind, &fd ) );

        FindClose( hFind );
    }

    TraceFuncExit( );
}

void
PopulateImagesListbox(
    HWND hwndList )
{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    WCHAR szPath[ MAX_PATH ];

    TraceFunc( "PopulateImagesListbox( )\n" );

    ListBox_ResetContent( hwndList );

    _snwprintf( szPath, ARRAYSIZE(szPath), L"\\\\%s\\REMINST\\Setup\\%s\\%s\\*", g_ServerName, g_Language, REMOTE_INSTALL_IMAGE_DIR_W );
    TERMINATE_BUFFER(szPath);

    hFind = FindFirstFile( szPath, &fd );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        szPath[wcslen(szPath) - 2] = L'\0';
        do
        {
            if ( ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
              && StrCmp( fd.cFileName, L"." ) !=0
              && StrCmp( fd.cFileName, L".." ) !=0 )
            {
                PopulateImagesListbox2( hwndList, fd.cFileName, szPath );
            }
        } while ( FindNextFile( hFind, &fd ) );

        FindClose( hFind );
    }

    TraceFuncExit( );
}

//
// SetupPathCheckNextButtonActivation( )
//
VOID
SetupPathCheckNextButtonActivation(
    HWND hDlg )
{
    TraceFunc( "SetupPathCheckNextButtonActivation( )\n" );
    LRESULT lResult = ListBox_GetCurSel( GetDlgItem( hDlg, IDC_L_IMAGES ) );
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK  | ( lResult == LB_ERR ? 0 : PSWIZB_NEXT ));
    TraceFuncExit( );
}

//
// SetupPathDlgProc()
//
INT_PTR CALLBACK
SetupPathDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;
    case WM_INITDIALOG:
        CenterDialog( GetParent( hDlg ) );
        return FALSE;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDC_L_IMAGES:
            if ( HIWORD( wParam ) == LBN_SELCHANGE )
            {
                SetupPathCheckNextButtonActivation( hDlg );
            }
        }
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            {
                HWND hwndList = GetDlgItem( hDlg, IDC_L_IMAGES );
                UINT sel = ListBox_GetCurSel( hwndList );
                if ( sel == -1 )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                }
                else
                {
                    WCHAR szPath[ MAX_PATH ];
                    ListBox_GetText( hwndList, sel, szPath );
                    _snwprintf( g_ImageName,
                                ARRAYSIZE(g_ImageName),
                              L"\\\\%s\\REMINST\\Setup\\%s\\%s\\%s\\%s",
                              g_ServerName,
                              g_Language,
                              REMOTE_INSTALL_IMAGE_DIR_W,
                              szPath,
                              g_Architecture );
                    TERMINATE_BUFFER(g_ImageName);
                }
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            if ( DetermineSetupPath( ) )
            {
                DebugMsg( "Skipping SetupPath...\n" );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't show
            }
            else
            {
                PopulateImagesListbox( GetDlgItem( hDlg, IDC_L_IMAGES ) );
                SetupPathCheckNextButtonActivation( hDlg );
                ClearMessageQueue( );
            }
            break;
        }
        break;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\summary.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SUMMARY.H


 ***************************************************************************/

#ifndef _SUMMARY_H_
#define _SUMMARY_H_

INT_PTR CALLBACK
SummaryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _SUMMARY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\sif.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SERVERDLG.CPP


 ***************************************************************************/

#include "pch.h"
#include <remboot.h>
#include "callback.h"
#include "utils.h"

DEFINE_MODULE( "RIPREP" )

WNDPROC g_pOldEditWndProc;

//
// VerifySIFField( )
//
// Make sure that the directory name entered conforms to the
// restrictions that OSChooser has.
//
// Returns: S_OK if it does
//          E_FAIL if it does not
//
HRESULT
VerifySIFField(
    LPWSTR pszField
    )
{
    HRESULT hr = S_OK;

    TraceFunc( "VerifySIFField()\n" );

    while ( *pszField >= 32 && *pszField <= 127 )
    {
        pszField++;
    }

    if ( *pszField != L'\0' )
    {
        hr = E_FAIL;
    }

    HRETURN(hr);
}

//
// SIFDlgCheckNextButtonActivation( )
//
VOID
SIFDlgCheckNextButtonActivation(
    HWND hDlg )
{
    TraceFunc( "SIFDlgCheckNextButtonActivation( )\n" );
    GetDlgItemText( hDlg, IDC_E_DESCRIPTION, g_Description, ARRAYSIZE(g_Description));
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | (wcslen(g_Description) ? PSWIZB_NEXT : 0 ) );
    TraceFuncExit( );
}

//
// HelpTextEditWndProc( )
//
LRESULT CALLBACK
HelpTextEditWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch ( uMsg )
    {
    case WM_KEYDOWN:
        // fake button presses
        if ( LOWORD( wParam ) == VK_RETURN ) {
            PropSheet_PressButton( GetParent( GetParent( hWnd ) ), PSBTN_NEXT );
            return FALSE;
        } else if ( LOWORD( wParam ) == VK_ESCAPE ) {
            PropSheet_PressButton( GetParent( GetParent( hWnd ) ), PSBTN_CANCEL );
            return FALSE;
        }
        break;
    }

    return CallWindowProc(g_pOldEditWndProc, hWnd, uMsg, wParam, lParam);
}

//
// SIFDlgProc()
//
INT_PTR CALLBACK
SIFDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_DESCRIPTION ), ARRAYSIZE(g_Description) - 1 );
        Edit_LimitText( GetDlgItem( hDlg, IDC_E_HELPTEXT ), ARRAYSIZE(g_HelpText) - 1 );
        g_pOldEditWndProc = (WNDPROC) SetWindowLongPtr( GetDlgItem( hDlg, IDC_E_HELPTEXT), GWLP_WNDPROC, (LONG_PTR)&HelpTextEditWndProc);
        SetWindowLongPtr( GetDlgItem( hDlg, IDC_E_HELPTEXT), GWLP_WNDPROC, (LONG_PTR)&HelpTextEditWndProc);
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_DESCRIPTION:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                SIFDlgCheckNextButtonActivation( hDlg );
            }
            break;
        }
        break;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            GetDlgItemText( hDlg, IDC_E_DESCRIPTION, g_Description, ARRAYSIZE(g_Description) );
            Assert( wcslen( g_Description ) );
            GetDlgItemText( hDlg, IDC_E_HELPTEXT, g_HelpText, ARRAYSIZE(g_HelpText) );
            if ( FAILED( VerifySIFField( g_Description ) ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE, IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT, MB_OK );
                SetFocus( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                break;
            }
            if ( FAILED( VerifySIFField( g_HelpText ) ) )
            {
                MessageBoxFromStrings( hDlg, IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE, IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT, MB_OK );
                SetFocus( GetDlgItem( hDlg, IDC_E_HELPTEXT ) );
                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );    // don't go on
                break;
            }
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            SIFDlgCheckNextButtonActivation( hDlg );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\summary.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: SUMMARY.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"

//
// SummaryDlgProc()
//
INT_PTR CALLBACK
SummaryDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{

    UNREFERENCED_PARAMETER(wParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetDialogFont( hDlg, IDC_TITLE, DlgFontTitle );
        break;

    default:
        return FALSE;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_WIZNEXT:
            break;

        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            SetDlgItemText( hDlg, IDC_S_SERVERNAME, g_ServerName );
            SetDlgItemText( hDlg, IDC_S_DIRECTORY, g_MirrorDir );
            SetDlgItemText( hDlg, IDC_E_DESCRIPTION, g_Description );
            SetDlgItemText( hDlg, IDC_E_HELPTEXT, g_HelpText );
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\sysprep.c ===
/*++

File Description:

    This file contains all the functions required to add a registry entry
    to force execution of the system clone worker upon reboot.

--*/

#include <sysprep_.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\tasks.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: TASKS.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"
#include "tasks.h"
#include "logging.h"

DEFINE_MODULE("RIPREP")
extern HWND g_hTasksDialog;

typedef struct {
    HANDLE hChecked;
    HANDLE hError;
    HANDLE hArrow;
    HANDLE hFontNormal;
    HANDLE hFontBold;
    int    dwWidth;
    int    dwHeight;
} SETUPDLGDATA, *LPSETUPDLGDATA;


//
// TasksDlgProc()
//
INT_PTR CALLBACK
TasksDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    static HBRUSH hBrush = NULL;
    LPSETUPDLGDATA psdd = (LPSETUPDLGDATA) GetWindowLongPtr( hDlg, GWLP_USERDATA );
    INT_PTR result;

    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        {
            BITMAP bm;

            // grab the bitmaps
            psdd =
                (LPSETUPDLGDATA) TraceAlloc( GMEM_FIXED, sizeof(SETUPDLGDATA) );

            if ( psdd == NULL ) {
                // This returns FALSE at successful completion
                // So returning opposite 
                return TRUE;
            }

            psdd->hChecked = LoadImage( g_hinstance,
                                        MAKEINTRESOURCE( IDB_CHECK ),
                                        IMAGE_BITMAP,
                                        0, 0,
                                        LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
            DebugMemoryAddHandle( psdd->hChecked );
            GetObject( psdd->hChecked, sizeof(bm), &bm );
            psdd->dwWidth = bm.bmWidth;

            psdd->hError   = LoadImage( g_hinstance,
                                        MAKEINTRESOURCE( IDB_X ),
                                        IMAGE_BITMAP,
                                        0, 0,
                                        LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
            DebugMemoryAddHandle( psdd->hError );
            GetObject( psdd->hError, sizeof(bm), &bm );
            psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ? psdd->dwWidth : bm.bmWidth );

            psdd->hArrow   = LoadImage( g_hinstance,
                                        MAKEINTRESOURCE( IDB_ARROW ),
                                        IMAGE_BITMAP,
                                        0, 0,
                                        LR_DEFAULTSIZE | LR_LOADTRANSPARENT );
            DebugMemoryAddHandle( psdd->hArrow );
            GetObject( psdd->hArrow, sizeof(bm), &bm );
            psdd->dwWidth = ( psdd->dwWidth > bm.bmWidth ?
                              psdd->dwWidth :
                              bm.bmWidth );

            HWND    hwnd = GetDlgItem( hDlg, IDC_L_TASKS );

            HFONT hFontOld = (HFONT) SendMessage( hwnd, WM_GETFONT, 0, 0);
            if(hFontOld != NULL)
            {
                LOGFONT lf;
                if ( GetObject( hFontOld, sizeof(LOGFONT), (LPSTR) &lf ) )
                {
                    DWORD dw;
                     
                    dw = LoadString( g_hinstance,
                                     IDS_LARGEFONTNAME,
                                     lf.lfFaceName,
                                     LF_FACESIZE);
                    Assert( dw );

                    lf.lfWidth = 0;
                    lf.lfWeight = 400;
                    lf.lfHeight -= 4;
                    psdd->hFontNormal = CreateFontIndirect(&lf);
                    DebugMemoryAddHandle( psdd->hFontNormal );

                    lf.lfWeight = 700;
                    psdd->hFontBold = CreateFontIndirect(&lf);
                    DebugMemoryAddHandle( psdd->hFontBold );
                }
            }

            HDC hDC = GetDC( NULL );
            SelectObject( hDC, psdd->hFontBold );
            TEXTMETRIC tm;
            GetTextMetrics( hDC, &tm );
            psdd->dwHeight = tm.tmHeight;
            ReleaseDC( NULL, hDC );

            SetWindowLongPtr( hDlg, GWLP_USERDATA, (LONG_PTR) psdd );
            WCHAR szTitle[ 256 ];
            DWORD dw;
            dw = LoadString( g_hinstance, IDS_APPNAME, szTitle, ARRAYSIZE(szTitle));
            Assert( dw );
            SetWindowText( hDlg, szTitle );
            SetDlgItemText( hDlg, IDC_S_OPERATION, L"" );

            CenterDialog( hDlg );
            return FALSE;
        }
        break;

    case WM_MEASUREITEM:
        {
            LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam;
            RECT    rc;
            if ( lpmis == NULL ) {
                // Breaks and returns TRUE at successful completion
                // So returning opposite
                return FALSE;
            }
            HWND    hwnd = GetDlgItem( hDlg, IDC_L_TASKS );

            GetClientRect( hwnd, &rc );

            lpmis->itemWidth = rc.right - rc.left;
            lpmis->itemHeight = psdd->dwHeight;
        }
        break;

    case WM_DRAWITEM:
        {
            Assert( psdd );

            LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam;
            if ( !lpdis ) {
                // Below, another null pointer in the same
                // data field is taken care of. We are 
                // duplicating the result here.
                break; // ignore
            }
            LPLBITEMDATA plbid = (LPLBITEMDATA)lpdis->itemData;
            RECT rc = lpdis->rcItem;
            HANDLE hOldFont = INVALID_HANDLE_VALUE;
            WCHAR szText[MAX_PATH];

            if ( !plbid )
                break; // ignore

            ListBox_GetText(lpdis->hwndItem, lpdis->itemID, szText);
            rc.right = rc.bottom = psdd->dwWidth;

            switch ( plbid->uState )
            {
            case STATE_NOTSTARTED:
                hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                break;

            case STATE_STARTED:
                DrawBitmap( psdd->hArrow, lpdis, &rc );
                hOldFont = SelectObject( lpdis->hDC, psdd->hFontBold );
                break;

            case STATE_DONE:
                DrawBitmap( psdd->hChecked, lpdis, &rc );
                hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                break;

            case STATE_ERROR:
                DrawBitmap( psdd->hError, lpdis, &rc );
                hOldFont = SelectObject( lpdis->hDC, psdd->hFontNormal );
                break;
            }

            rc = lpdis->rcItem;
            rc.left += psdd->dwHeight;

            DrawText( lpdis->hDC, plbid->pszText, -1, &rc, DT_LEFT | DT_VCENTER );

            if ( hOldFont != INVALID_HANDLE_VALUE )
            {
                SelectObject( lpdis->hDC, hOldFont );
            }
        }
        break;

    case WM_CTLCOLORLISTBOX:
        if ( hBrush == NULL )
        {
            LOGBRUSH brush;
            brush.lbColor = GetSysColor( COLOR_3DFACE );
            brush.lbStyle = BS_SOLID;
            hBrush = (HBRUSH) CreateBrushIndirect( &brush );
            DebugMemoryAddHandle( hBrush );
        }
        SetBkMode( (HDC) wParam, OPAQUE );
        SetBkColor( (HDC) wParam, GetSysColor( COLOR_3DFACE ) );
        return (INT_PTR)hBrush;

    case WM_DESTROY:
        if ( hBrush != NULL )
        {
            DebugMemoryDelete( hBrush );
            DeleteObject(hBrush);
            hBrush = NULL;
        }
        Assert( psdd );
        DeleteObject( psdd->hChecked );
        DebugMemoryDelete( psdd->hChecked );
        DeleteObject( psdd->hError );
        DebugMemoryDelete( psdd->hError );
        DeleteObject( psdd->hArrow );
        DebugMemoryDelete( psdd->hArrow );
        DeleteObject( psdd->hFontNormal );
        DebugMemoryDelete( psdd->hFontNormal );
        DeleteObject( psdd->hFontBold );
        DebugMemoryDelete( psdd->hFontBold );
        TraceFree( psdd );
        SetWindowLongPtr( hDlg, GWLP_USERDATA, NULL );
        EndDialog( g_hTasksDialog, 0 );
        break;

    case WM_SETTINGCHANGE:
        if ( hBrush != NULL )
        {
            DebugMemoryDelete( hBrush );
            DeleteObject(hBrush);
            hBrush = NULL;
        }
        break;

    case WM_UPDATE:
        {

            LPWSTR pszOperation = (LPWSTR) wParam;
            LPWSTR pszObject = (LPWSTR) lParam;
            LPWSTR pszTemp = NULL;
            LPWSTR psz;

            if ( lParam && wParam ) {
                RECT rect;
                SIZE size;
                HDC hdc = GetDC( hDlg );
                ULONG pszTempSize = 0;

                INT iLength = wcslen( pszOperation );
                psz = pszObject;
                if ( psz && StrCmpN( psz, L"\\\\?\\", 4) == 0 )
                {
                    psz += 4;
                }
                GetWindowRect( GetDlgItem( hDlg, IDC_S_OPERATION ), &rect );
                if (hdc != NULL) {
                    GetTextExtentPoint( hdc, pszOperation, iLength, &size );
                    PathCompactPath( hdc, psz, rect.right - rect.left - size.cx );
                    ReleaseDC( hDlg, hdc );
                }

                pszTempSize = iLength + wcslen(psz) + 2;   // +1 space +1 NULL
                pszTemp = (LPWSTR) TraceAlloc( LMEM_FIXED, pszTempSize * sizeof(WCHAR));
                if (!pszTemp )
                    goto Update_Cleanup;
                _snwprintf( pszTemp, pszTempSize, pszOperation, psz );
                pszTemp[pszTempSize-1] = 0;
                psz = pszTemp;
            } else if ( pszObject ) {
                psz = pszObject;
            } else if ( wParam ) {
                psz = pszOperation;
            } else {
                psz = L"";
            }

            Assert( psz );
            SetDlgItemText( hDlg, IDC_S_OPERATION, psz );

Update_Cleanup:
            if ( pszTemp )
                TraceFree( pszTemp );
            if ( pszObject )
                TraceFree( pszObject );
            if ( pszOperation )
                TraceFree( pszOperation );
        }
        break;

    case WM_ERROR:
    case WM_ERROR_OK:
        //
        // Close the log file to prevent the "write-behind / data-loss" popups.
        //
        if ( g_hLogFile != INVALID_HANDLE_VALUE ) {
            CloseHandle( g_hLogFile );
            g_hLogFile = INVALID_HANDLE_VALUE;
        }

        // Signal that the error log should be displayed.
        g_fErrorOccurred = TRUE;

        result = TRUE;  // message processed

        if ( lParam != NULL )
        {
            LBITEMDATA * pitem = (LBITEMDATA *) lParam;
            LPWSTR     pszFile = pitem->pszText;
            DWORD      Error   = pitem->uState;

            // Remove the "\\?\" from the beginning of the line
            if ( pszFile != NULL 
              && StrCmpN( pszFile, L"\\\\?\\", 4 ) == 0 ) 
            {
                pszFile = &pszFile[4];
            }

            switch (Error)
            {
            case ERROR_DISK_FULL:
                {
                    WCHAR szTemplate[ 1024 ];
                    INT i = MessageBoxFromStrings( hDlg, IDS_DISK_FULL_TITLE, IDS_DISK_FULL_TEXT, MB_ABORTRETRYIGNORE );
                    DWORD dw;
                     
                    dw = LoadString( g_hinstance, IDS_DISK_FULL_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate );
                    if ( i == IDABORT )
                    {
                        pitem->uState = ERROR_REQUEST_ABORTED;
                    } 
                    else if ( i == IDRETRY )
                    {
                        pitem->uState = ERROR_RETRY;
                    }
                    else // ignore the error
                    {
                        pitem->uState = ERROR_SUCCESS;
                    }
                }
                break;

            case ERROR_FILE_ENCRYPTED:
                {
                    INT i = IDOK;
                    WCHAR szTemplate[ 1024 ];   // random
                    WCHAR szText[ ARRAYSIZE(szTemplate) + MAX_PATH ];
                    WCHAR szTitle[ MAX_PATH ];  // random
                    DWORD dw;
                    dw = LoadString( g_hinstance, IDS_ENCRYPTED_FILE_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    dw = LoadString( g_hinstance, IDS_ENCRYPTED_FILE_TITLE, szTitle, ARRAYSIZE(szTitle) );
                    Assert( dw );
                    _snwprintf( szText, ARRAYSIZE(szText), szTemplate, pszFile );
                    TERMINATE_BUFFER(szText);
                    if ( !g_fQuietFlag ) {
                        i = MessageBox( hDlg, szText, szTitle, MB_OKCANCEL );
                    }
                    dw = LoadString( g_hinstance, IDS_ENCRYPTED_FILE_LOG, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate, pszFile );
                    pitem->uState = ( i == IDOK ? ERROR_SUCCESS : ERROR_REQUEST_ABORTED );
                }
                break;

            case ERROR_SHARING_VIOLATION:
                {
                    BOOL SkipCheck = FALSE;
                    WCHAR szTemplate[ 1024 ];   // random
                    WCHAR szText[ ARRAYSIZE(szTemplate) + MAX_PATH ];
                    WCHAR szTitle[ MAX_PATH ];  // random
                    DWORD dw;

                    if (g_hCompatibilityInf != INVALID_HANDLE_VALUE) {
                        INFCONTEXT Context;
                        if (SetupFindFirstLine(
                                    g_hCompatibilityInf,
                                    L"FilesToIgnoreCopyErrors",
                                    pszFile,
                                    &Context)) {
                            pitem->uState = ERROR_SUCCESS;
                            SkipCheck = TRUE;
                        }
                    } 

                    if (!SkipCheck) {                                        
                        dw = LoadString( g_hinstance, IDS_SHARING_VIOLATION_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                        Assert( dw );
                        dw = LoadString( g_hinstance, IDS_SHARING_VIOLATION_TITLE, szTitle, ARRAYSIZE(szTitle) );
                        Assert( dw );
                        _snwprintf( szText, ARRAYSIZE(szText), szTemplate, pszFile );
                        TERMINATE_BUFFER(szText);
                        if ( !g_fQuietFlag ) 
                        {
                            INT i = MessageBox( hDlg, szText, szTitle, MB_ABORTRETRYIGNORE );
                            if ( i == IDABORT )
                            {
                                pitem->uState = ERROR_REQUEST_ABORTED;
                            } 
                            else if ( i == IDRETRY )
                            {
                                pitem->uState = ERROR_RETRY;
                            }
                            else // ignore the error
                            {
                                pitem->uState = ERROR_SUCCESS;
                            }
                        }
                        else // ignore the error - it will be logged
                        {
                            pitem->uState = ERROR_SUCCESS;
                        }
                    }

                    dw = LoadString( g_hinstance, IDS_SHARING_VIOLATION_LOG, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate, pszFile );
                }
                break;

            case ERROR_ACCESS_DENIED:
                {
                    INT i = IDOK;
                    WCHAR szTemplate[ 1024 ];   // random
                    WCHAR szText[ ARRAYSIZE(szTemplate) + MAX_PATH ];
                    WCHAR szTitle[ MAX_PATH ];  // random
                    DWORD dw;
                    dw = LoadString( g_hinstance, IDS_ACCESS_DENIED_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    dw = LoadString( g_hinstance, IDS_ACCESS_DENIED_TITLE, szTitle, ARRAYSIZE(szTitle) );
                    Assert( dw );
                    _snwprintf( szText, ARRAYSIZE(szText), szTemplate, pszFile );
                    TERMINATE_BUFFER(szText);
                    if ( !g_fQuietFlag ) {
                        i = MessageBox( hDlg, szText, szTitle, MB_OKCANCEL );
                    }
                    dw = LoadString( g_hinstance, IDS_ACCESS_DENIED_LOG, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate, pszFile );
                    pitem->uState = ( i == IDOK ? ERROR_SUCCESS : ERROR_REQUEST_ABORTED );
                }
                break;

            case ERROR_INVALID_DRIVE:   // special meaning multi-disk detected
                {
                    INT i = IDOK;
                    i = MessageBoxFromStrings( hDlg, IDS_MULTIPLE_DISK_TITLE, IDS_MULTIPLE_DISK_TEXT, MB_OKCANCEL );
                    pitem->uState = ( i == IDOK ? ERROR_SUCCESS : ERROR_REQUEST_ABORTED );
                }
                break;

            case ERROR_REPARSE_ATTRIBUTE_CONFLICT:
                {
                    INT i = IDOK;
                    WCHAR szTemplate[ 1024 ];   // random
                    WCHAR szText[ ARRAYSIZE(szTemplate) + MAX_PATH ];
                    WCHAR szTitle[ MAX_PATH ];  // random
                    DWORD dw;
                    dw = LoadString( g_hinstance, IDS_NOT_COPYING_REPARSE_POINT_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    dw = LoadString( g_hinstance, IDS_NOT_COPYING_REPARSE_POINT_TITLE, szTitle, ARRAYSIZE(szTitle) );
                    Assert( dw );
                    _snwprintf( szText, ARRAYSIZE(szText), szTemplate, pszFile );
                    TERMINATE_BUFFER(szText);
                    if ( !g_fQuietFlag ) {
                        i = MessageBox( hDlg, szText, szTitle, MB_OKCANCEL );
                    }
                    dw = LoadString( g_hinstance, IDS_NOT_COPYING_REPARSE_POINT_LOG, szTemplate, ARRAYSIZE(szTemplate) );
                    Assert( dw );
                    LogMsg( szTemplate, pszFile );
                    pitem->uState = ( i == IDOK ? ERROR_SUCCESS : ERROR_REQUEST_ABORTED );
                }
                break;

            case STATUS_MISSING_SYSTEMFILE:
                MessageBoxFromStrings( hDlg, IDS_BOOT_PARTITION_TITLE, IDS_BOOT_PARTITION_TEXT, MB_OK );
                pitem->uState = ERROR_REQUEST_ABORTED;    // stop copying
                break;

            case STATUS_OBJECT_TYPE_MISMATCH:
                MessageBoxFromStrings( hDlg, IDS_DYNAMIC_DISK_TITLE, IDS_DYNAMIC_DISK_TEXT, MB_OK );
                pitem->uState = ERROR_REQUEST_ABORTED;    // stop copying
                break;

            case ERROR_OLD_WIN_VERSION:
            default:
                if ( Error != ERROR_SUCCESS )
                {
                    if ( uMsg == WM_ERROR_OK || Error == ERROR_OLD_WIN_VERSION ) 
                    {
                        MessageBoxFromError( hDlg, (LPWSTR) pszFile, (DWORD) Error, NULL, MB_OK );
                        pitem->uState = ERROR_REQUEST_ABORTED;
                    } 
                    else // uMsg == WM_ERROR
                    { 
                        WCHAR szTemplate[ 1024 ]; // random
                        DWORD dw;
                         
                        dw = LoadString( g_hinstance, IDS_RETRY_ABORT_IGNORE_TEXT, szTemplate, ARRAYSIZE(szTemplate) );
                        Assert( dw );
                        
                        if ( !g_fQuietFlag ) 
                        {
                            INT i;
                             
                            i = MessageBoxFromError( 
                                            hDlg, 
                                            (LPWSTR) pszFile,
                                            // this may not be an NTSTATUS error.  See if it's
                                            // a winerror first.
                                            NT_SUCCESS(Error) ? Error : (DWORD)RtlNtStatusToDosError(Error), 
                                            szTemplate, 
                                            MB_ABORTRETRYIGNORE );

                            if ( i == IDABORT )
                            {
                                pitem->uState = ERROR_REQUEST_ABORTED;
                            } 
                            else if ( i == IDRETRY )
                            {
                                pitem->uState = ERROR_RETRY;
                            }
                            else // ignore the error
                            {
                                pitem->uState = ERROR_SUCCESS;
                            }
                        } 
                        else // ignore the error - it will be logged.
                        {
                            pitem->uState = ERROR_SUCCESS;
                        }
                    }

                    LogMsg( L"Error 0x%08x: %s\r\n", Error, pszFile );
                }
                break;
            }
        }

        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, result );
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\utils.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved
 
 ***************************************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

void 
CenterDialog( 
    HWND hwndDlg );

void 
ClearMessageQueue( void );

INT
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType );

INT
MessageBoxFromError(
    HWND hParent,
    LPTSTR pszTitle,
    DWORD dwErr,
    LPTSTR pszAdditionalText OPTIONAL,
    UINT uType );

INT
MessageBoxFromMessage(
    HWND Window,
    DWORD MessageId,
    BOOL SystemMessage,
    LPCTSTR CaptionString,
    UINT Style,
    ...
    );


//
// Enum for SetDialogFont().
//
typedef enum {
    DlgFontTitle,
    DlgFontBold
} MyDlgFont;


VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    );

void 
DrawBitmap( 
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc );

BOOL 
VerifyCancel( 
    HWND hParent );

class CWaitCursor
{
private:
    HCURSOR _hOldCursor;

public:
    CWaitCursor( ) { _hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( _hOldCursor ); };
};

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\tasks.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: TASKS.H


 ***************************************************************************/

#ifndef _TASKS_H_
#define _TASKS_H_

#define STATE_NOTSTARTED    ODS_DEFAULT
#define STATE_STARTED       ODS_SELECTED
#define STATE_DONE          ODS_CHECKED
#define STATE_ERROR         ODS_DISABLED

typedef struct {
    LPWSTR          pszText;
    DWORD           uState;
    IMIRROR_TODO    todo;
    BOOLEAN         fSeen;
} LBITEMDATA, *LPLBITEMDATA;

INT_PTR CALLBACK
TasksDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _TASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\welcome.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: WELCOME.H

 ***************************************************************************/

#ifndef _WELCOME_H_
#define _WELCOME_H_

INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam );


#endif // _WELCOME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\welcome.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1998
   All rights reserved

  File: WELCOME.CPP


 ***************************************************************************/

#include "pch.h"
#include "callback.h"
#include "utils.h"

//
// WelcomeDlgProc()
//
INT_PTR CALLBACK
WelcomeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    
    UNREFERENCED_PARAMETER(wParam);
    
    switch (uMsg)
    {
    default:
        return FALSE;

    case WM_INITDIALOG:
        SetDialogFont( hDlg, IDC_TITLE, DlgFontTitle );
        CenterDialog( GetParent( hDlg ) );
        return FALSE;

    case WM_NOTIFY:
        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
        LPNMHDR lpnmhdr = (LPNMHDR) lParam;
        switch ( lpnmhdr->code )
        {
        case PSN_QUERYCANCEL:
            return VerifyCancel( hDlg );

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
            ClearMessageQueue( );
            break;
        }
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\utils.cpp ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

 ***************************************************************************/

#include "pch.h"
#include "utils.h"

DEFINE_MODULE("RIPREP")

#define SMALL_BUFFER_SIZE   1024

//
// Centers a dialog.
//
void
CenterDialog(
    HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen;
    int     cyScreen;

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcScreen, 0 );

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect( hwndDlg, &rc );

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ( ( cyScreen - cyDlg ) / 2 );
    x = rcScreen.left + ( ( cxScreen - cxDlg ) / 2 );

    SetWindowPos( hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );
}

//
// Eats all mouse and keyboard messages.
//
void
ClearMessageQueue( void )
{
    MSG   msg;

    while ( PeekMessage( (LPMSG)&msg, NULL, WM_KEYFIRST, WM_MOUSELAST,
                PM_NOYIELD | PM_REMOVE ) );
}

//
// Create a message box from resource strings.
//
INT
MessageBoxFromStrings(
    HWND hParent,
    UINT idsCaption,
    UINT idsText,
    UINT uType )
{
    TCHAR szText[ SMALL_BUFFER_SIZE ];
    TCHAR szCaption[ SMALL_BUFFER_SIZE ];
    DWORD dw;

    dw = LoadString( g_hinstance, idsCaption, szCaption, ARRAYSIZE( szCaption ));
    Assert( dw );
    dw = LoadString( g_hinstance, idsText, szText, ARRAYSIZE( szText ));
    Assert( dw );

    return MessageBox( hParent, szText, szCaption, uType );
}

//
// Creates a error message box
//
INT
MessageBoxFromError(
    HWND hParent,
    LPTSTR pszTitle,
    DWORD dwErr,
    LPTSTR pszAdditionalText,
    UINT uType )
{
    WCHAR szText[ SMALL_BUFFER_SIZE ];
    LPTSTR lpMsgBuf;
    LPTSTR lpMsgBuf2;
    int retval;

    if ( dwErr == ERROR_SUCCESS ) {
        AssertMsg( dwErr, "Why was MessageBoxFromError() called when the dwErr == ERROR_SUCCES?" );
        return IDOK;
    }

    if ( !pszTitle ) {
        DWORD dw;
        dw = LoadString( g_hinstance, IDS_ERROR, szText, ARRAYSIZE( szText ));
        Assert( dw );
        pszTitle = szText;
    }

    if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf2,
            0,
            NULL )) {
    

        //
        // If additional text was given, allocate a buffer large enough for both
        // strings. If the allocation fails, just show the error text.
        //
    
        if ( pszAdditionalText != NULL ) {
            DWORD len = (wcslen(lpMsgBuf2) + wcslen(pszAdditionalText) + 1) * sizeof(WCHAR);
            lpMsgBuf = (LPTSTR)LocalAlloc( LPTR, len );
            if ( lpMsgBuf != NULL ) {
                wcscpy( lpMsgBuf, lpMsgBuf2 );
                wcscat( lpMsgBuf, pszAdditionalText );
            } else {
                lpMsgBuf = lpMsgBuf2;
            }
        } else {
            lpMsgBuf = lpMsgBuf2;
        }
    
        retval = MessageBox( hParent, lpMsgBuf, pszTitle, uType | MB_TASKMODAL | MB_ICONERROR );
    
        SetFocus( hParent );
    
        if (lpMsgBuf != NULL) {
            LocalFree( lpMsgBuf );
        }
    
        if ( lpMsgBuf2 != lpMsgBuf ) {
            LocalFree( lpMsgBuf2 );
        }
    
        return retval;

    } else {
        Assert(FALSE);
        return 0;
    }
}

VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    )
{
    static HFONT BigBoldFont = NULL;
    static HFONT BoldFont    = NULL;
    static HFONT NormalFont  = NULL;
    HFONT Font;
    LOGFONT LogFont;
    int FontSize;
    HDC hdc;

    switch(WhichFont) {

    case DlgFontTitle:

        if(!BigBoldFont) {

            if ( Font =
                (HFONT) SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0) )
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont) )
                {
                    DWORD dw;
                     
                    dw = LoadString( g_hinstance,
                                     IDS_LARGEFONTNAME,
                                     LogFont.lfFaceName,
                                     LF_FACESIZE);
                    Assert( dw );

                    // LogFont.lfWeight = 700;
                    FontSize = 14;

                    if ( hdc = GetDC(hdlg) )
                    {
                        LogFont.lfHeight =
                            0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                        BigBoldFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BigBoldFont;
        break;

    case DlgFontBold:

        if ( !BoldFont )
        {
            if ( Font =
                (HFONT) SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0 ))
            {
                if ( GetObject( Font, sizeof(LOGFONT), &LogFont ) )
                {

                    LogFont.lfWeight = FW_BOLD;

                    if ( hdc = GetDC( hdlg ) )
                    {
                        BoldFont = CreateFontIndirect( &LogFont );
                        ReleaseDC( hdlg, hdc );
                    }
                }
            }
        }
        Font = BoldFont;
        break;

    default:
        //
        // Nothing to do here.
        //
        Font = NULL;
        break;
    }

    if( Font )
    {
        SendDlgItemMessage( hdlg, ControlId, WM_SETFONT, (WPARAM) Font, 0 );
    }
}


//
// Adjusts and draws a bitmap transparently in the RECT prc.
//
void
DrawBitmap(
    HANDLE hBitmap,
    LPDRAWITEMSTRUCT lpdis,
    LPRECT prc )
{
    TraceFunc( "DrawBitmap( ... )\n" );

    BITMAP  bm;
    HDC     hDCBitmap;
    int     dy;

    if (GetObject( hBitmap, sizeof(bm), &bm ) &&
        (hDCBitmap = CreateCompatibleDC( NULL ))) {
    
        SelectObject( hDCBitmap, hBitmap );
    
        // center the image
        dy = 4 + prc->bottom - bm.bmHeight;
    
        StretchBlt( lpdis->hDC, prc->left, prc->top + dy, prc->right, prc->bottom,
              hDCBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCAND );
    
        DeleteDC( hDCBitmap );

    }

    TraceFuncExit( );
}

//
// Verifies that the user wanted to cancel setup.
//
BOOL
VerifyCancel( HWND hParent )
{
    TraceFunc( "VerifyCancel( ... )\n" );

    INT iReturn;
    BOOL fAbort = FALSE;

    iReturn = MessageBoxFromStrings( hParent,
                                     IDS_CANCELCAPTION,
                                     IDS_CANCELTEXT,
                                     MB_YESNO | MB_ICONQUESTION );
    if ( iReturn == IDYES ) {
        fAbort = TRUE;
    }

    SetWindowLongPtr( hParent, DWLP_MSGRESULT, ( fAbort ? 0 : -1 ));

    RETURN(!fAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\riprep\web.cpp ===
#include "pch.h"
#pragma hdrstop

#include <windows.h>
#include <ole2.h>
#include <exdisp.h>
#include <htiframe.h>

#define INITGUID

#include <initguid.h>
#include <shlguid.h>
#include <mshtml.h>

DEFINE_MODULE( "RIPREP" )

const VARIANT c_vaEmpty = {0};
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)



BOOL
IsIE3Installed(
    VOID
)
{
HRESULT         hr;
IWebBrowserApp  *pwb;

    hr = CoCreateInstance( CLSID_InternetExplorer,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IWebBrowserApp,
                           (void **)&pwb );
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
IsIE4Installed(
    VOID
)
{
HRESULT         hr;
IWebBrowserApp  *pwb;

    hr = CoCreateInstance( CLSID_InternetExplorer,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IWebBrowser2,
                           (void **)&pwb );

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
LaunchIE3Instance(
    LPWSTR szResourceURL
    )
{
    HRESULT hr;
    int dx, dy;
    IWebBrowserApp *pwb;
    BSTR Str;


    hr = CoCreateInstance(
        CLSID_InternetExplorer,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWebBrowserApp,
        (void **)&pwb
        );

    if (SUCCEEDED(hr)) {

        // turn off chrome
        hr = pwb->put_MenuBar(FALSE);
        hr = pwb->put_StatusBar(FALSE);
//        hr = pwb->put_ToolBar(FALSE);

        // set client area size
        int iWidth = 466L;
        int iHeight = 286L;

        pwb->ClientToWindow(&iWidth, &iHeight);

        if (iWidth > 0)
            pwb->put_Width(iWidth);

        if (iHeight > 0)
            pwb->put_Height(iHeight);

        if ((dx = ((GetSystemMetrics(SM_CXSCREEN) - iWidth) / 2)) > 0)     // center the on screen window
            pwb->put_Left(dx);

        if ((dy = ((GetSystemMetrics(SM_CYSCREEN) - iHeight) / 2)) > 0)
            pwb->put_Top(dy);

        pwb->put_Visible(TRUE);

        Str = szResourceURL;
        hr = pwb->Navigate(Str, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);

        pwb->Release();

        return(TRUE);
    }

    return(FALSE);
}


BOOL
LaunchIE4Instance(
    LPWSTR szResourceURL
    )
{
    HRESULT hr;
    int dx, dy;
    IWebBrowser2 *pwb;
    BSTR Str;


    hr = CoCreateInstance(
        CLSID_InternetExplorer,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWebBrowser2,
        (void **)&pwb
        );

    if (SUCCEEDED(hr)) {

        //
        //  this marks this window as a third party window,
        //  so that the window is not reused.
        //
        pwb->put_RegisterAsBrowser(VARIANT_TRUE);

        IHTMLWindow2 *phw;
        IServiceProvider *psp;

        if (SUCCEEDED(pwb->QueryInterface(IID_IServiceProvider, (void**) &psp)) && psp) {
            if (SUCCEEDED(psp->QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void**)&phw))) {
                VARIANT var;
                var.vt = VT_BOOL;
                var.boolVal = 666;
                phw->put_opener(var);
                phw->Release();
            } else
                MessageBox(NULL, TEXT("QueryInterface of IID_IHTMLWindow2 FAILED!!!!!"), NULL, MB_ICONERROR);
            psp->Release();
        }

        // turn off chrome
        pwb->put_MenuBar(FALSE);
        pwb->put_StatusBar(FALSE);
//        pwb->put_ToolBar(FALSE);
        pwb->put_AddressBar(FALSE);
//      pwb->put_Resizable(FALSE);


        // set client area size
        int iWidth = 466L;
        int iHeight = 286L;

        pwb->ClientToWindow(&iWidth, &iHeight);

        if (iWidth > 0)
            pwb->put_Width(iWidth);

        if (iHeight > 0)
            pwb->put_Height(iHeight);

        if ((dx = ((GetSystemMetrics(SM_CXSCREEN) - iWidth) / 2)) > 0)     // center the on screen window
            pwb->put_Left(dx);

        if ((dy = ((GetSystemMetrics(SM_CYSCREEN) - iHeight) / 2)) > 0)
            pwb->put_Top(dy);

        pwb->put_Visible(TRUE);

        Str = szResourceURL;
        hr = pwb->Navigate(Str, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);

        pwb->Release();

        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\screens\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

osc.cab: *.osc
   makecab.exe /F osc.ddf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\client\scbind.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   scbind.h

Abstract:

    Function prototypes for functions in scbind.c that are used externally.
    NOTE:  The RPC bind and unbind functions do not appear here because
    the RPC stubs are the only functions that call these functions.  The RPC
    stubs already have a prototype for those functions.

Author:

    Dan Lafferty (danl)     06-Jun-1991

Environment:

    User Mode -Win32

Revision History:


--*/

RPC_STATUS
InitializeStatusBinding( VOID);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\imports.h ===
#include "scpragma.h"

#include <windef.h>

#ifdef MIDL_PASS
#define LPSTR  [string] LPSTR
#define LPTSTR [string] LPTSTR
#define LPWSTR [string] wchar_t *
#define enum   [v1_enum] enum
#endif

#include <winsvc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\sccrypt.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    sccrypt.h

Abstract:

    Password ncryption and decription routines.

Author:

    Rita Wong (ritaw)     27-Apr-1992

Revision History:

--*/

#ifndef _SCCRYPT_INCLUDED_
#define _SCCRYPT_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif


DWORD
ScEncryptPassword(
    IN  SC_RPC_HANDLE ContextHandle,
    IN  LPWSTR Password,
    OUT LPBYTE *EncryptedPassword,
    OUT LPDWORD EncryptedPasswordSize
    );

DWORD
ScDecryptPassword(
    IN  SC_RPC_HANDLE ContextHandle,
    IN  LPBYTE EncryptedPassword,
    IN  DWORD EncryptedPasswordSize,
    OUT LPWSTR *Password
    );

#ifdef __cplusplus
}
#endif

#endif // _SCCRYPT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\control.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    control.h

Abstract:

    This file contains data structures and function prototypes for the
    Service Controller Control Interface.

Author:

    Dan Lafferty (danl)     28-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    28-Mar-1991     danl
        created

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
// Internal controls.
// These must not be in the range or public controls ( 1-10)
// or in the range of user-defined controls (0x00000080 - 0x000000ff)
//

//
// Range for OEM defined control opcodes
//
#define OEM_LOWER_LIMIT     128
#define OEM_UPPER_LIMIT     255

//
// Used to start a service that shares a process with other services.
//
#define SERVICE_CONTROL_START_SHARE    0x00000050    // INTERNAL

//
// Used to start a service that has its own process.
//
#define SERVICE_CONTROL_START_OWN      0x00000051    // INTERNAL

//
// Private access level for OpenService to get a context handle for SetServiceStatus.
// This MUST NOT CONFLICT with the access levels in winsvc.h.
//
#define SERVICE_SET_STATUS             0x8000        // INTERNAL

//
// Service controls that can be passed to a non-EX control handler.  Relies
// on ordering/values of SERVICE_CONTROL_* constants in winsvc.h.
//
#define IS_NON_EX_CONTROL(dwControl)                                                            \
            ((dwControl >= SERVICE_CONTROL_STOP && dwControl <= SERVICE_CONTROL_NETBINDDISABLE) \
               ||                                                                               \
             (dwControl >= OEM_LOWER_LIMIT && dwControl <= OEM_UPPER_LIMIT))

//
// Data Structures
//

//
// The control message has the following format:
//      [MessageHeader][ServiceNameString][CmdArg1Ptr][CmdArg2Ptr]
//      [...][CmdArgnPtr][CmdArg1String][CmdArg2String][...][CmdArgnString]
//
//  Where CmdArg pointers are replaced with offsets that are relative to
//  the location of the 1st command arg pointer (the top of the argv list).
//
//  In the header, the NumCmdArgs, StatusHandle, and ArgvOffset parameters
//  are only used when the SERVICE_START OpCode is passed in.  They are
//  expected to be 0 at all other times.  The ServiceNameOffset and the
//  ArgvOffset are relative to the top of the buffer containing the
//  message (ie. the header Count field).  The Count field in the header
//  contains the number of bytes in the entire message (including the
//  header).
//
//

typedef struct _CTRL_MSG_HEADER
{
    DWORD                   Count;              // num bytes in buffer.
    DWORD                   OpCode;             // control opcode.
    DWORD                   NumCmdArgs;         // number of command Args.
    DWORD                   ServiceNameOffset;  // pointer to ServiceNameString
    DWORD                   ArgvOffset;         // pointer to Argument Vectors.
}
CTRL_MSG_HEADER, *PCTRL_MSG_HEADER, *LPCTRL_MSG_HEADER;

typedef struct _PIPE_RESPONSE_MSG
{
    DWORD       dwDispatcherStatus;
    DWORD       dwHandlerRetVal;
}
PIPE_RESPONSE_MSG, *PPIPE_RESPONSE_MSG, *LPPIPE_RESPONSE_MSG;

typedef struct _PNP_ARGUMENTS
{
    DWORD       dwEventType;
    DWORD       dwEventDataSize;
    PVOID       EventData;
}
PNP_ARGUMENTS, *PPNP_ARGUMENTS, *LPPNP_ARGUMENTS;


//
// Union to hold arguments to ScSendControl
//
typedef union _CONTROL_ARGS {
    LPWSTR          *CmdArgs;
    PNP_ARGUMENTS   PnPArgs;
} CONTROL_ARGS, *PCONTROL_ARGS, *LPCONTROL_ARGS;


//
// Defines and Typedefs
//

#define CONTROL_PIPE_NAME           L"\\\\.\\pipe\\net\\NtControlPipe"

#define PID_LEN                     10      // Max PID (DWORD_MAX) is 10 digits

#define CONTROL_TIMEOUT             30000   // timeout for waiting for pipe.

#define RESPONSE_WAIT_TIME          5000   // wait until service response.

//
// Function Prototypes
//

DWORD
ScCreateControlInstance (
    OUT LPHANDLE    PipeHandlePtr,
    IN  DWORD       dwProcessId,
    IN  PSID        pAccountSid
    );

VOID
ScDeleteControlInstance (
    IN  HANDLE      PipeHandle
    );

DWORD
ScWaitForConnect (
    IN  HANDLE    PipeHandle,
    IN  HANDLE    hProcess       OPTIONAL,
    IN  LPWSTR    lpDisplayName,
    OUT LPDWORD   ProcessIdPtr
    );

DWORD
ScSendControl (
    IN  LPWSTR                  ServiceName,
    IN  LPWSTR                  DisplayName,
    IN  HANDLE                  PipeHandle,
    IN  DWORD                   OpCode,
    IN  LPCONTROL_ARGS          lpControlArgs OPTIONAL,
    IN  DWORD                   NumArgs,
    OUT LPDWORD                 lpdwHandlerRetVal OPTIONAL
    );

VOID
ScShutdownAllServices(
    VOID
    );

DWORD
ScSendPnPMessage(
    IN  SERVICE_STATUS_HANDLE   hServiceStatus,
    IN  DWORD                   OpCode,
    IN  DWORD                   dwEventType,
    IN  LPARAM                  EventData,
    OUT LPDWORD                 lpdwHandlerRetVal
    );

DWORD
ScValidatePnPService(
    IN  LPWSTR                   lpServiceName,
    OUT SERVICE_STATUS_HANDLE    *lphServiceStatus
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\client\scapi.cxx ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    scapi.c

Abstract:

    Contains the Service-related API that are implemented solely in
    DLL form.  These include:
        StartServiceCtrlDispatcherA
        StartServiceCtrlDispatcherW
        RegisterServiceCtrlHandlerW
        RegisterServiceCtrlHandlerA
        RegisterServiceCtrlHandlerExW
        RegisterServiceCtrlHandlerExA

    This file also contains the following local support routines:
        ScDispatcherLoop
        ScCreateDispatchTableW
        ScCreateDispatchTableA
        ScReadServiceParms
        ScConnectServiceController
        ScExpungeMessage
        ScGetPipeInput
        ScGetDispatchEntry
        ScNormalizeCmdLineArgs
        ScSendResponse
        ScSvcctrlThreadW
        ScSvcctrlThreadA
        RegisterServiceCtrlHandlerHelp

Author:

    Dan Lafferty (danl)     09 Apr-1991

Environment:

    User Mode -Win32

Revision History:

    12-May-1999 jschwart
        Convert SERVICE_STATUS_HANDLE to a context handle to fix security
        hole (any service can call SetServiceStatus with another service's
        handle and succeed)

    10-May-1999 jschwart
        Create a separate named pipe per service to fix security hole (any
        process could flood the pipe since the name was well-known -- pipe
        access is now limited to the service account and LocalSystem)

    10-Mar-1998 jschwart
        Add code to allow services to receive Plug-and-Play control messages
        and unpack the message arguments from the pipe

    30-Sep-1997 jschwart
        StartServiceCtrlDispatcher:  If this function [A or W] has already been
        called from within this process, return ERROR_SERVICE_ALREADY_RUNNING.
        Otherwise, can be destructive (e.g., overwrite AnsiFlag, etc.)

    06-Aug-1997 jschwart
        ScDispatcherLoop:  If the service is processing a shutdown command from
        the SCM, it no longer writes the status back to the SCM since the SCM is
        now using WriteFile on system shutdown (see control.cxx for more info).

    03-Jun-1996 AnirudhS
        ScGetPipeInput: If the message received from the service controller
        is not a SERVICE_CONTROL_START message, don't allocate space for the
        arguments, since there are none, and since that space never gets freed.

    22-Sep-1995 AnirudhS
        Return codes from InitializeStatusBinding were not being handled
        correctly; success was sometimes reported on failure.  Fixed this.

    12-Aug-1993 Danl
        ScGetDispatchEntry:  When the first entry in the table is marked as
        OwnProcess, then this function should just return the pointer to the
        top of the table.  It should ignore the ServiceName.  In all cases,
        when the service is started as an OWN_PROCESS, only the first entry
        in the dispath table should be used.

    04-Aug-1992 Danl
        When starting a service, always pass the service name as the
        first parameter in the argument list.

    27-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.

    09 Apr-1991     danl
        created

--*/

//
// INCLUDES
//

#include <scpragma.h>

extern "C"
{
#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h
}
#include <rpc.h>        // DataTypes and runtime APIs
#include <windef.h>     // windows types needed for winbase.h
#include <winbase.h>    // CreateFile
#include <winuser.h>    // wsprintf()
#include <winreg.h>     // RegOpenKeyEx / RegQueryValueEx

#include <string.h>     // strcmp
#include <stdlib.h>     // wide character c runtimes.
#include <tstr.h>       // WCSSIZE().

#include <winsvc.h>     // public Service Controller Interface.

#include "scbind.h"     // InitializeStatusBinding
#include <valid.h>      // MAX_SERVICE_NAME_LENGTH
#include <control.h>    // CONTROL_PIPE_NAME
#include <scdebug.h>    // STATIC
#include <sclib.h>      // ScConvertToUnicode

//
// Internal Dispatch Table.
//

//
// Bit flags for the dispatch table's dwFlags field
//
#define SERVICE_OWN_PROCESS     0x00000001
#define SERVICE_EX_HANDLER      0x00000002

typedef union  _START_ROUTINE_TYPE {
    LPSERVICE_MAIN_FUNCTIONW    U;      // unicode type
    LPSERVICE_MAIN_FUNCTIONA    A;      // ansi type
} START_ROUTINE_TYPE, *LPSTART_ROUTINE_TYPE;

typedef union  _HANDLER_FUNCTION_TYPE {
    LPHANDLER_FUNCTION          Regular;    // Regular version
    LPHANDLER_FUNCTION_EX       Ex;         // Extended version
} HANDLER_FUNCTION_TYPE, *LPHANDLER_FUNCTION_TYPE;

typedef struct _INTERNAL_DISPATCH_ENTRY {
    LPWSTR                      ServiceName;
    LPWSTR                      ServiceRealName;    // In case the names are different
    START_ROUTINE_TYPE          ServiceStartRoutine;
    HANDLER_FUNCTION_TYPE       ControlHandler;
    SC_HANDLE                   StatusHandle;
    DWORD                       dwFlags;
    PVOID                       pContext;
} INTERNAL_DISPATCH_ENTRY, *LPINTERNAL_DISPATCH_ENTRY;


//
//  This structure is passed to the internal
//  startup thread which calls the real user
//  startup routine with argv, argc parameters.
//

typedef struct _THREAD_STARTUP_PARMSW {
    DWORD                       NumArgs;
    LPSERVICE_MAIN_FUNCTIONW    ServiceStartRoutine;
    LPWSTR                      VectorTable;
} THREAD_STARTUP_PARMSW, *LPTHREAD_STARTUP_PARMSW;

typedef struct _THREAD_STARTUP_PARMSA {
    DWORD                       NumArgs;
    LPSERVICE_MAIN_FUNCTIONA    ServiceStartRoutine;
    LPSTR                       VectorTable;
} THREAD_STARTUP_PARMSA, *LPTHREAD_STARTUP_PARMSA;

//
// This structure contains the arguments passed
// to a service's extended control handler
//
typedef struct _HANDLEREX_PARMS {
    DWORD    dwEventType;
    LPVOID   lpEventData;
} HANDLEREX_PARMS, *LPHANDLEREX_PARMS;

//
// This union contains the arguments to the service
// passed from the server via named pipe
//

typedef union _SERVICE_PARAMS {
    THREAD_STARTUP_PARMSW   ThreadStartupParms;
    HANDLEREX_PARMS         HandlerExParms;
} SERVICE_PARAMS, *LPSERVICE_PARAMS;

//
// The following is the amount of time we will wait for the named pipe
// to become available from the Service Controller.
//
#ifdef DEBUG
#define CONTROL_WAIT_PERIOD     NMPWAIT_WAIT_FOREVER
#else
#define CONTROL_WAIT_PERIOD     15000       // 15 seconds
#endif

//
// This is the number of times we will continue to loop when pipe read
// failures occur.  After this many tries, we cease to read the pipe.
//
#define MAX_RETRY_COUNT         30

//
// Globals
//

    LPINTERNAL_DISPATCH_ENTRY   DispatchTable=NULL;  // table head.

    //
    // This flag is set to TRUE if the control dispatcher is to support
    // ANSI calls.  Otherwise the flag is set to FALSE.
    //
    BOOL     AnsiFlag = FALSE;

    //
    // This variable makes sure StartServiceCtrlDispatcher[A,W] doesn't
    // get called twice by the same process, since this is destructive.
    // It is initialized to 0 by the linker
    //
    LONG     g_fCalledBefore;

    //
    // Are we running in the security process?
    //
    BOOL    g_fIsSecProc;

#if defined(_X86_)    
    //
    // Are we running inside a Wow64 process (on Win64)
    //
    BOOL g_fWow64Process = FALSE;
#endif

//
// Internal Functions
//

DWORD
ScCreateDispatchTableW(
    IN  CONST SERVICE_TABLE_ENTRYW  *UserDispatchTable,
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchTablePtr
    );

DWORD
ScCreateDispatchTableA(
    IN  CONST SERVICE_TABLE_ENTRYA  *UserDispatchTable,
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchTablePtr
    );

DWORD
ScReadServiceParms(
    IN  LPCTRL_MSG_HEADER   Msg,
    IN  DWORD               dwNumBytesRead,
    OUT LPBYTE              *ppServiceParams,
    OUT LPBYTE              *ppTempArgPtr,
    OUT LPDWORD             lpdwRemainingArgBytes
    );

VOID
ScDispatcherLoop(
    IN  HANDLE              PipeHandle,
    IN  LPCTRL_MSG_HEADER   Msg,
    IN  DWORD               dwBufferSize
    );

DWORD
ScConnectServiceController (
    OUT LPHANDLE    pipeHandle
    );

VOID
ScExpungeMessage(
    IN  HANDLE  PipeHandle
    );

DWORD
ScGetPipeInput (
    IN      HANDLE              PipeHandle,
    IN OUT  LPCTRL_MSG_HEADER   Msg,
    IN      DWORD               dwBufferSize,
    OUT     LPSERVICE_PARAMS    *ppServiceParams
    );

DWORD
ScGetDispatchEntry (
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchEntry,
    IN  LPWSTR                      ServiceName
    );

VOID
ScNormalizeCmdLineArgs(
    IN OUT  LPCTRL_MSG_HEADER       Msg,
    IN OUT  LPTHREAD_STARTUP_PARMSW ThreadStartupParms
    );

VOID
ScSendResponse (
    IN  HANDLE  pipeHandle,
    IN  DWORD   Response,
    IN  DWORD   dwHandlerRetVal
    );

DWORD
ScSvcctrlThreadW(
    IN LPTHREAD_STARTUP_PARMSW  lpThreadStartupParms
    );

DWORD
ScSvcctrlThreadA(
    IN LPTHREAD_STARTUP_PARMSA  lpThreadStartupParms
    );

SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerHelp (
    IN  LPCWSTR                  ServiceName,
    IN  HANDLER_FUNCTION_TYPE    ControlHandler,
    IN  PVOID                    pContext,
    IN  DWORD                    dwFlags
    );


#if defined(_X86_)
//
// Detect if the current process is a 32-bit process running on Win64.
//
VOID DetectWow64Process()
{
    NTSTATUS NtStatus;
    PVOID Peb32;

    NtStatus = NtQueryInformationProcess(NtCurrentProcess(),
                                         ProcessWow64Information,
                                         &Peb32,
                                         sizeof(Peb32),
                                         NULL);

    if (NT_SUCCESS(NtStatus) && (Peb32 != NULL))
    {
        g_fWow64Process = TRUE;
    }
}
#endif


extern "C" {

//
// Private function for lsass.exe that tells us we're running
// in the security process
//

VOID
I_ScIsSecurityProcess(
    VOID
    )
{
    g_fIsSecProc = TRUE;
}


//
// Private function for PnP that looks up a service's REAL
// name given its context handle
//

DWORD
I_ScPnPGetServiceName(
    IN  SERVICE_STATUS_HANDLE  hServiceStatus,
    OUT LPWSTR                 lpServiceName,
    IN  DWORD                  cchBufSize
    )
{
    DWORD  dwError = ERROR_SERVICE_NOT_IN_EXE;

    ASSERT(cchBufSize >= MAX_SERVICE_NAME_LENGTH);

    //
    // Search the dispatch table.
    //

    if (DispatchTable != NULL)
    {
        LPINTERNAL_DISPATCH_ENTRY   dispatchEntry;

        for (dispatchEntry = DispatchTable;
             dispatchEntry->ServiceName != NULL;
             dispatchEntry++)
        {
            //
            // Note:  SC_HANDLE and SERVICE_STATUS_HANDLE were originally
            //        different handle types -- they are now the same as
            //        per the fix for bug #120359 (SERVICE_STATUS_HANDLE
            //        fix outlined in the file comments above), so this
            //        cast is OK.
            //
            if (dispatchEntry->StatusHandle == (SC_HANDLE)hServiceStatus)
            {
                ASSERT(dispatchEntry->ServiceRealName != NULL);
                ASSERT(wcslen(dispatchEntry->ServiceRealName) < cchBufSize);
                wcscpy(lpServiceName, dispatchEntry->ServiceRealName);
                dwError = NO_ERROR;
                break;
            }
        }
    }

    return dwError;
}    

}    // extern "C"


BOOL
WINAPI
StartServiceCtrlDispatcherA (
    IN  CONST SERVICE_TABLE_ENTRYA * lpServiceStartTable
    )


/*++

Routine Description:

    This function provides the ANSI interface for the
    StartServiceCtrlDispatcher function.

Arguments:



Return Value:



--*/
{
    DWORD                       status;
    NTSTATUS                    ntstatus;
    HANDLE                      pipeHandle;

    //
    // Make sure this is the only time the control dispatcher is being called
    //
    if (InterlockedExchange(&g_fCalledBefore, 1) == 1) {

       //
       // Problem -- the control dispatcher was already called from this process
       //
       SetLastError(ERROR_SERVICE_ALREADY_RUNNING);
       return(FALSE);
    }


    //
    // Set the AnsiFlag to indicate that the control dispatcher must support
    // ansi function calls only.
    //
    AnsiFlag = TRUE;

    //
    // Create an internal DispatchTable.
    //
    status = ScCreateDispatchTableA(
                (LPSERVICE_TABLE_ENTRYA)lpServiceStartTable,
                (LPINTERNAL_DISPATCH_ENTRY *)&DispatchTable);

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }

    //
    // Allocate a buffer big enough to contain at least the control message
    // header and a service name.  This ensures that if the message is not
    // a message with arguments, it can be read in a single ReadFile.
    //
    BYTE  bPipeMessageHeader[sizeof(CTRL_MSG_HEADER) +
                                (MAX_SERVICE_NAME_LENGTH+1) * sizeof(WCHAR)];

    //
    // Connect to the Service Controller
    //

    status = ScConnectServiceController (&pipeHandle);

    if (status != NO_ERROR) {
        goto CleanExit;
    }

    //
    // Initialize the binding for the status interface (NetServiceStatus).
    //

    SCC_LOG(TRACE,"Initialize the Status binding\n",0);

    ntstatus = InitializeStatusBinding();
    if (ntstatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntstatus);
        CloseHandle(pipeHandle);
        goto CleanExit;
    }

    //
    // Enter the dispatcher loop where we service control requests until
    // all services in the service table have terminated.
    //

    ScDispatcherLoop(pipeHandle,
                     (LPCTRL_MSG_HEADER)&bPipeMessageHeader,
                     sizeof(bPipeMessageHeader));

    CloseHandle(pipeHandle);

CleanExit:

    //
    // Clean up the dispatch table.  Since we created unicode versions
    // of all the service names, in ScCreateDispatchTableA, we now need to
    // free them.
    //

    if (DispatchTable != NULL) {

        LPINTERNAL_DISPATCH_ENTRY   dispatchEntry;

        //
        // If they're different, it's because we allocated the real name.
        // Only check the first entry since this can only happen in the
        // SERVICE_OWN_PROCESS case
        //
        if (DispatchTable->ServiceName != DispatchTable->ServiceRealName) {
            LocalFree(DispatchTable->ServiceRealName);
        }

        //
        // Do not free the dispatch table and the service name field if this
        // API is successful. This is because after exiting this API successfully on the last stop
        // service, a service can still be in the SetServiceStatus API at ScRemoveDispatchEntry.
        // That function walks the dispatch table and touches the ServiceName and StatusHandle
        // fields in the table.
        //
        if (status != NO_ERROR) {
            for (dispatchEntry = DispatchTable;
                 dispatchEntry->ServiceName != NULL;
                 dispatchEntry++) {

                LocalFree(dispatchEntry->ServiceName);
            }

            LocalFree(DispatchTable);
        }
    }

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
StartServiceCtrlDispatcherW (
    IN  CONST SERVICE_TABLE_ENTRYW * lpServiceStartTable
    )
/*++

Routine Description:

    This is the Control Dispatcher thread.  We do not return from this
    function call until the Control Dispatcher is told to shut down.
    The Control Dispatcher is responsible for connecting to the Service
    Controller's control pipe, and receiving messages from that pipe.
    The Control Dispatcher then dispatches the control messages to the
    correct control handling routine.

Arguments:

    lpServiceStartTable - This is a pointer to the top of a service dispatch
        table that the service main process passes in.  Each table entry
        contains pointers to the ServiceName, and the ServiceStartRotuine.

Return Value:

    NO_ERROR - The Control Dispatcher successfully terminated.

    ERROR_INVALID_DATA - The specified dispatch table does not contain
        entries in the proper format.

    ERROR_FAILED_SERVICE_CONTROLLER_CONNECT - The Control Dispatcher
        could not connect with the Service Controller.

    ERROR_SERVICE_ALREADY_RUNNING - The function has already been called
        from within the current process
--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    HANDLE                      pipeHandle;

    //
    // Make sure this is the only time the control dispatcher is being called
    //
    if (InterlockedExchange(&g_fCalledBefore, 1) == 1) {

       //
       // Problem -- the control dispatcher was already called from this process
       //
       SetLastError(ERROR_SERVICE_ALREADY_RUNNING);
       return(FALSE);
    }

    //
    // Create the Real Dispatch Table
    //

    __try {
        status = ScCreateDispatchTableW((LPSERVICE_TABLE_ENTRYW)lpServiceStartTable, &DispatchTable);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            SCC_LOG(ERROR,"StartServiceCtrlDispatcherW:Unexpected Exception 0x%lx\n",status);
        }
    }
    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }

    //
    // Allocate a buffer big enough to contain at least the control message
    // header and a service name.  This ensures that if the message is not
    // a message with arguments, it can be read in a single ReadFile.
    //
    BYTE  bPipeMessageHeader[sizeof(CTRL_MSG_HEADER) +
                                (MAX_SERVICE_NAME_LENGTH+1) * sizeof(WCHAR)];

    //
    // Connect to the Service Controller
    //

    status = ScConnectServiceController(&pipeHandle);
    if (status != NO_ERROR) {

        //
        // If they're different, it's because we allocated the real name.
        // Only check the first entry since this can only happen in the
        // SERVICE_OWN_PROCESS case
        //
        if (DispatchTable->ServiceName != DispatchTable->ServiceRealName) {
            LocalFree(DispatchTable->ServiceRealName);
        }

        LocalFree(DispatchTable);
        SetLastError(status);
        return(FALSE);
    }

    //
    // Initialize the binding for the status interface (NetServiceStatus).
    //

    SCC_LOG(TRACE,"Initialize the Status binding\n",0);

    ntStatus = InitializeStatusBinding();

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        CloseHandle(pipeHandle);

        //
        // If they're different, it's because we allocated the real name.
        // Only check the first entry since this can only happen in the
        // SERVICE_OWN_PROCESS case
        //
        if (DispatchTable->ServiceName != DispatchTable->ServiceRealName) {
            LocalFree(DispatchTable->ServiceRealName);
        }

        LocalFree(DispatchTable);
        SetLastError(status);
        return(FALSE);
    }

    //
    // Enter the dispatcher loop where we service control requests until
    // all services in the service table have terminated.
    //
    ScDispatcherLoop(pipeHandle,
                     (LPCTRL_MSG_HEADER)&bPipeMessageHeader,
                     sizeof(bPipeMessageHeader));

    CloseHandle(pipeHandle);

    //
    // If they're different, it's because we allocated the real name.
    // Only check the first entry since this can only happen in the
    // SERVICE_OWN_PROCESS case
    //
    if (DispatchTable->ServiceName != DispatchTable->ServiceRealName) {
        LocalFree(DispatchTable->ServiceRealName);
    }

    return(TRUE);
}



VOID
ScDispatcherLoop(
    IN  HANDLE              PipeHandle,
    IN  LPCTRL_MSG_HEADER   Msg,
    IN  DWORD               dwBufferSize
    )

/*++

Routine Description:

    This is the input loop that the Control Dispatcher stays in through-out
    its life.  Only two types of events will cause us to leave this loop:

        1) The service controller instructed the dispatcher to exit.
        2) The dispatcher can no longer communicate with the the
           service controller.

Arguments:

    PipeHandle:  This is a handle to the pipe over which control
        requests are received.

Return Value:

    none


--*/
{
    DWORD                       status;
    DWORD                       controlStatus;
    BOOL                        continueDispatch;
    LPWSTR                      serviceName     = NULL;
    LPSERVICE_PARAMS            lpServiceParams = NULL;
    LPTHREAD_START_ROUTINE      threadAddress   = NULL;
    LPVOID                      threadParms     = NULL;
    LPTHREAD_STARTUP_PARMSA     lpspAnsiParms;
    LPINTERNAL_DISPATCH_ENTRY   dispatchEntry   = NULL;
    DWORD                       threadId;
    HANDLE                      threadHandle;
    DWORD                       i;
    DWORD                       errorCount      = 0;
    DWORD                       dwHandlerRetVal = NO_ERROR;
    BOOL                        fCreatedThread;
    BOOL                        fOpenedService;

    //
    // Input Loop
    //

    continueDispatch = TRUE;

#if defined(_X86_)
    //
    // Detect if this is a Wow64 Process ?
    //
    DetectWow64Process();
#endif

    do
    {
        status         = NO_ERROR;
        fCreatedThread = FALSE;
        fOpenedService = FALSE;

        //
        // Wait for input
        //
        controlStatus = ScGetPipeInput(PipeHandle,
                                       Msg,
                                       dwBufferSize,
                                       &lpServiceParams);

        //
        // If we received good input, check to see if we are to shut down
        // the ControlDispatcher.  If not, then obtain the dispatchEntry
        // from the dispatch table.
        //

        if (controlStatus == NO_ERROR)
        {
            //
            // Clear the error count
            //
            errorCount = 0;

            serviceName = (LPWSTR) ((LPBYTE)Msg + Msg->ServiceNameOffset);

            SCC_LOG(TRACE, "Read from pipe succeeded for service %ws\n", serviceName);

            if ((serviceName[0] == L'\0') &&
                (Msg->OpCode == SERVICE_STOP))
            {
                //
                // The Dispatcher is being asked to shut down.
                //    (security check not required for this operation)
                //    although perhaps it would be a good idea to verify
                //    that the request came from the Service Controller.
                //
                controlStatus    = NO_ERROR;
                continueDispatch = FALSE;
            }
            else
            {
                dispatchEntry = DispatchTable;

                if (Msg->OpCode == SERVICE_CONTROL_START_OWN)
                {
                    dispatchEntry->dwFlags |= SERVICE_OWN_PROCESS;
                }

                //
                // Search the dispatch table to find the service's entry
                //
                if (!(dispatchEntry->dwFlags & SERVICE_OWN_PROCESS))
                {
                    controlStatus = ScGetDispatchEntry(&dispatchEntry, serviceName);
                }

                if (controlStatus != NO_ERROR)
                {
                    SCC_LOG(TRACE,"Service Name not in Dispatch Table\n",0);
                }
            }
        }
        else
        {
            if (controlStatus != ERROR_NOT_ENOUGH_MEMORY)
            {
                //
                // If an error occured and it is not an out-of-memory error,
                // then the pipe read must have failed.
                // In this case we Increment the error count.
                // When this count reaches the MAX_RETRY_COUNT, then
                // the service controller must be gone.  We want to log an
                // error and notify an administrator.  Then go to sleep forever.
                // Only a re-boot will solve this problem.
                //
                // We should be able to report out-of-memory errors back to
                // the caller.  It should be noted that out-of-memory errors
                // do not clear the error count.  But they don't add to it
                // either.
                //

                errorCount++;
                if (errorCount > MAX_RETRY_COUNT)
                {
                    Sleep(0xffffffff);
                }
            }

            //
            // Service params aren't allocated -- avoid freeing them later
            //

            lpServiceParams = NULL;
        }

        //
        // Dispatch the request
        //
        if ((continueDispatch == TRUE) && (controlStatus == NO_ERROR))
        {
            switch(Msg->OpCode)
            {
            case SERVICE_CONTROL_START_SHARE:
            case SERVICE_CONTROL_START_OWN:
            {
                SC_HANDLE  hScManager = OpenSCManagerW(NULL,
                                                       NULL,
                                                       SC_MANAGER_CONNECT);

                if (hScManager == NULL)
                {
                    status = GetLastError();

                    SCC_LOG1(ERROR,
                             "ScDispatcherLoop: OpenSCManagerW FAILED %d\n",
                             status);
                }
                else
                {
                    //
                    // Update the StatusHandle in the dispatch entry table
                    //

                    dispatchEntry->StatusHandle = OpenServiceW(hScManager,
                                                               serviceName,
                                                               SERVICE_SET_STATUS);

                    if (dispatchEntry->StatusHandle == NULL)
                    {
                        status = GetLastError();

                        SCC_LOG1(ERROR,
                                 "ScDispatcherLoop: OpenServiceW FAILED %d\n",
                                 status);
                    }
                    else
                    {
                        fOpenedService = TRUE;
                    }

                    CloseServiceHandle(hScManager);
                }

                if (status == NO_ERROR
                     &&
                    (dispatchEntry->dwFlags & SERVICE_OWN_PROCESS)
                     &&
                    (_wcsicmp(dispatchEntry->ServiceName, serviceName) != 0))
                {
                    //
                    // Since we don't look up the dispatch record in the OWN_PROCESS
                    // case (and can't since it will break existing services), there's
                    // no guarantee that the name in the dispatch table (acquired from
                    // the RegisterServiceCtrlHandler call) is the real key name of
                    // the service.  Since the SCM passes across the real name when
                    // the service is started, save it away here if necessary.
                    //

                    dispatchEntry->ServiceRealName = (LPWSTR)LocalAlloc(
                                                                 LMEM_FIXED,
                                                                 WCSSIZE(serviceName)
                                                                 );

                    if (dispatchEntry->ServiceRealName == NULL)
                    {
                        //
                        // In case somebody comes searching for the handle (though
                        // they shouldn't), it's nicer to return an incorrect name
                        // than to AV trying to copy a NULL pointer.
                        //
                        SCC_LOG1(ERROR,
                                 "ScDispatcherLoop: Could not duplicate name for service %ws\n",
                                 serviceName);

                        dispatchEntry->ServiceRealName = dispatchEntry->ServiceName;
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        wcscpy(dispatchEntry->ServiceRealName, serviceName);
                    }
                }

                if (status == NO_ERROR)
                {
                    //
                    // The Control Dispatcher is to start a service.
                    // start the new thread.
                    //
                    lpServiceParams->ThreadStartupParms.ServiceStartRoutine =
                        dispatchEntry->ServiceStartRoutine.U;

                    threadAddress = (LPTHREAD_START_ROUTINE)ScSvcctrlThreadW;
                    threadParms   = (LPVOID)&lpServiceParams->ThreadStartupParms;

                    //
                    // If the service needs to be called with ansi parameters,
                    // then do the conversion here.
                    //
                    if (AnsiFlag)
                    {
                        lpspAnsiParms = (LPTHREAD_STARTUP_PARMSA)
                                            &lpServiceParams->ThreadStartupParms;

                        for (i = 0;
                             i < lpServiceParams->ThreadStartupParms.NumArgs;
                             i++)
                        {
                            if (!ScConvertToAnsi(
                                 *(&lpspAnsiParms->VectorTable + i),
                                 *(&lpServiceParams->ThreadStartupParms.VectorTable + i))) {

                                //
                                // Conversion error occured.
                                //
                                SCC_LOG0(ERROR,
                                         "ScDispatcherLoop: Could not convert "
                                             "args to ANSI\n");

                                status = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }

                        threadAddress = (LPTHREAD_START_ROUTINE)ScSvcctrlThreadA;
                        threadParms   = lpspAnsiParms;
                    }
                }

                if (status == NO_ERROR)
                {
                    //
                    // Create the new thread
                    //
                    threadHandle = CreateThread (
                        NULL,                       // Thread Attributes.
                        0L,                         // Stack Size
                        threadAddress,              // lpStartAddress
                        threadParms,                // lpParameter
                        0L,                         // Creation Flags
                        &threadId);                 // lpThreadId

                    if (threadHandle == NULL)
                    {

                        SCC_LOG(ERROR,
                                "ScDispatcherLoop: CreateThread failed %d\n",
                                GetLastError());

                        status = ERROR_SERVICE_NO_THREAD;
                    }
                    else
                    {
                        fCreatedThread = TRUE;
                        CloseHandle(threadHandle);
                    }
                }

                break;
            }

            default:

                if (dispatchEntry->ControlHandler.Ex != NULL)
                {
                    __try
                    {
                        //
                        // Call the proper ControlHandler routine.
                        //

                        if (dispatchEntry->dwFlags & SERVICE_EX_HANDLER)
                        {
                            SCC_LOG2(TRACE,
                                     "Calling extended ControlHandler routine %x "
                                     "for service %ws\n",
                                     Msg->OpCode,
                                     serviceName);

                            if (lpServiceParams)
                            {
                                dwHandlerRetVal = dispatchEntry->ControlHandler.Ex(
                                                      Msg->OpCode,
                                                      lpServiceParams->HandlerExParms.dwEventType,
                                                      lpServiceParams->HandlerExParms.lpEventData,
                                                      dispatchEntry->pContext);
                            }
                            else
                            {
                                dwHandlerRetVal = dispatchEntry->ControlHandler.Ex(
                                                      Msg->OpCode,
                                                      0,
                                                      NULL,
                                                      dispatchEntry->pContext);
                            }

                            SCC_LOG3(TRACE,
                                     "Extended ControlHandler routine %x "
                                     "returned %d from call to service %ws\n",
                                     Msg->OpCode,
                                     dwHandlerRetVal,
                                     serviceName);
                        }
                        else if (IS_NON_EX_CONTROL(Msg->OpCode))
                        {
                            SCC_LOG2(TRACE,
                                     "Calling ControlHandler routine %x "
                                     "for service %ws\n",
                                     Msg->OpCode,
                                     serviceName);


#if defined(_X86_)
                            //
                            // Hack for __CDECL callbacks.  The Windows NT 3.1
                            // SDK didn't prototype control handler functions
                            // as WINAPI, so a number of existing 3rd-party
                            // services have their control handler functions
                            // built as __cdecl instead.  This is a workaround.
                            // Note that the call to the control handler must
                            // be the only code between the _asm statements
                            //
                            DWORD SaveEdi;
                            _asm mov SaveEdi, edi;
                            _asm mov edi, esp;      // Both __cdecl and WINAPI
                                                    // functions preserve EDI
#endif
                            //
                            // Do not add code here
                            //
                            dispatchEntry->ControlHandler.Regular(Msg->OpCode);
                            //
                            // Do not add code here
                            //
#if defined(_X86_)
                            _asm mov esp, edi;
                            _asm mov edi, SaveEdi;
#endif

                            SCC_LOG2(TRACE,
                                     "ControlHandler routine %x returned from "
                                     "call to service %ws\n",
                                     Msg->OpCode,
                                     serviceName);
                        }
                        else
                        {
                            //
                            // Service registered for an extended control without
                            // registering an extended handler.  The call into the
                            // service process succeeded, so keep status as NO_ERROR.
                            // Return an error from the "handler" to notify anybody
                            // watching for the return code (especially PnP).
                            //

                            dwHandlerRetVal = ERROR_CALL_NOT_IMPLEMENTED;
                        }
                    }
                    __except (GetExceptionCode() != STATUS_POSSIBLE_DEADLOCK ?
                                  EXCEPTION_EXECUTE_HANDLER :
                                  EXCEPTION_CONTINUE_SEARCH)
                    {
                        SCC_LOG2(ERROR,
                                 "ScDispatcherLoop: Exception 0x%lx "
                                 "occurred in service %ws\n",
                                 GetExceptionCode(),
                                 serviceName);

                        status = ERROR_EXCEPTION_IN_SERVICE;
                    }

                    //
                    // Just in case messages come across from the SCM in a weird
                    // order (e.g., two threads racing through ScSendControl where
                    // the one that wins sends SERVICE_CONTROL_STOP), make sure
                    // that we don't send controls to a service after we've sent
                    // it a stop code.  Ignore the handler return value in this
                    // case since no service should be rejecting/failing a stop
                    // control and the SCM's marked the service as stopped anyhow.
                    // We just want to make sure that no controls get to the service
                    // after SERVICE_CONTROL_STOP until it's restarted.
                    //

                    if (Msg->OpCode == SERVICE_CONTROL_STOP)
                    {
                        dispatchEntry->ControlHandler.Ex = NULL;
                    }
                }
                else
                {
                    //
                    // There is no control handling routine
                    // registered for this service
                    //
                    status = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
                }

                //
                // If status is not good here, then an exception occured
                // either because the pointer to the control handling
                // routine was bad, or because an exception occured
                // inside the control handling routine.
                //
                // ??EVENTLOG??
                //

                break;

            } // end switch.

            //
            // Send the status back to the sevice controller.
            //

            if (Msg->OpCode != SERVICE_CONTROL_SHUTDOWN)
            {
                SCC_LOG(TRACE, "Service %ws about to send response\n", serviceName);
                ScSendResponse (PipeHandle, status, dwHandlerRetVal);
                SCC_LOG(TRACE, "Service %ws returned from sending response\n", serviceName);
            }
        }
        else
        {
            //
            // The controlStatus indicates failure, we always want to try
            // to send the status back to the Service Controller.
            //

            SCC_LOG2(TRACE,
                     "Service %ws about to send response on error %lu\n",
                     serviceName,
                     controlStatus);

            ScSendResponse(PipeHandle, controlStatus, dwHandlerRetVal);

            SCC_LOG2(TRACE,
                     "Service %ws returned from sending response on error %lu\n",
                     serviceName,
                     controlStatus);

            switch (controlStatus)
            {
                case ERROR_SERVICE_NOT_IN_EXE:
                case ERROR_SERVICE_NO_THREAD:

                    //
                    // The Service Name is not in this .exe's dispatch table.
                    // Or a thread for a new service couldn't be created.
                    // ignore it.  The Service Controller will tell us to
                    // shut down if necessary.
                    //
                    controlStatus = NO_ERROR;
                    break;

                default:

                    //
                    // If the error is not specifically recognized, continue.
                    //
                    controlStatus = NO_ERROR;
                    break;
            }
        }

        if (!fCreatedThread && lpServiceParams != NULL)
        {
            LocalFree(lpServiceParams);
            lpServiceParams = NULL;
        }

        if (fOpenedService && status != NO_ERROR)
        {
            CloseServiceHandle(dispatchEntry->StatusHandle);
            dispatchEntry->StatusHandle = NULL;
        }
    }
    while (continueDispatch == TRUE);

    return;
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerHelp (
    IN  LPCWSTR                  ServiceName,
    IN  HANDLER_FUNCTION_TYPE    ControlHandler,
    IN  PVOID                    pContext,
    IN  DWORD                    dwFlags
    )

/*++

Routine Description:

    This helper function enters a pointer to a control handling routine
    and a pointer to a security descriptor into the Control Dispatcher's
    dispatch table.  It does the work for the RegisterServiceCtrlHandler*
    family of APIs

Arguments:

    ServiceName - This is a pointer to the Service Name string.

    ControlHandler - This is a pointer to the service's control handling
        routine.

    pContext - This is a pointer to context data supplied by the user.

    dwFlags - This is a set of flags that give information about the
        control handling routine (currently only discerns between extended
        and non-extended handlers)

Return Value:

    This function returns a handle to the service that is to be used in
    subsequent calls to SetServiceStatus.  If the return value is NULL,
    an error has occured, and GetLastError can be used to obtain the
    error value.  Possible values for error are:

    NO_ERROR - If the operation was successful.

    ERROR_INVALID_PARAMETER - The pointer to the control handler function
        is NULL.

    ERROR_INVALID_DATA -

    ERROR_SERVICE_NOT_IN_EXE - The serviceName could not be found in
        the dispatch table.  This indicates that the configuration database
        says the serice is in this process, but the service name doesn't
        exist in the dispatch table.

--*/
{

    DWORD                       status;
    LPINTERNAL_DISPATCH_ENTRY   dispatchEntry;

    //
    // Find the service in the dispatch table.
    //
    dispatchEntry = DispatchTable;
    __try {
        status = ScGetDispatchEntry(&dispatchEntry, (LPWSTR) ServiceName);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            SCC_LOG(ERROR,
                    "RegisterServiceCtrlHandlerHelp: Unexpected Exception 0x%lx\n",
                    status);
        }
    }

    if(status != NO_ERROR) {
        SCC_LOG(ERROR,
            "RegisterServiceCtrlHandlerHelp: can't find dispatch entry\n",0);

        SetLastError(status);
        return(0L);
    }

    //
    // Insert the ControlHandler pointer
    //
    if (ControlHandler.Ex == NULL) {
        SCC_LOG(ERROR,
                "RegisterServiceCtrlHandlerHelp: Ptr to ctrlhandler is NULL\n",
                0);

        SetLastError(ERROR_INVALID_PARAMETER);
        return(0L);
    }

    //
    // Insert the entries into the table
    //
    if (dwFlags & SERVICE_EX_HANDLER) {
        dispatchEntry->dwFlags          |= SERVICE_EX_HANDLER;
        dispatchEntry->ControlHandler.Ex = ControlHandler.Ex;
        dispatchEntry->pContext          = pContext;
    }
    else {
        dispatchEntry->dwFlags               &= ~(SERVICE_EX_HANDLER);
        dispatchEntry->ControlHandler.Regular = ControlHandler.Regular;
    }

    //
    // This cast is OK -- see comment in I_ScPnPGetServiceName
    //
    return( (SERVICE_STATUS_HANDLE) dispatchEntry->StatusHandle );
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerW (
    IN  LPCWSTR               ServiceName,
    IN  LPHANDLER_FUNCTION    ControlHandler
    )
/*++

Routine Description:

    This function enters a pointer to a control handling
    routine into the Control Dispatcher's dispatch table.

Arguments:

    ServiceName     -- The service's name
    ControlHandler  -- Pointer to the control handling routine

Return Value:

    Anything returned by RegisterServiceCtrlHandlerHelp

--*/
{
    HANDLER_FUNCTION_TYPE   Handler;

    Handler.Regular = ControlHandler;

    return RegisterServiceCtrlHandlerHelp(ServiceName,
                                          Handler,
                                          NULL,
                                          0);
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerA (
    IN  LPCSTR                ServiceName,
    IN  LPHANDLER_FUNCTION    ControlHandler
    )
/*++

Routine Description:

    This is the ansi entry point for RegisterServiceCtrlHandler.

Arguments:



Return Value:



--*/
{
    LPWSTR                  ServiceNameW;
    SERVICE_STATUS_HANDLE   statusHandle;

    if (!ScConvertToUnicode(&ServiceNameW, ServiceName)) {

        //
        // This can only fail because of a failed LocalAlloc call
        // or else the ansi string is garbage.
        //
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0L);
    }
    statusHandle = RegisterServiceCtrlHandlerW(ServiceNameW, ControlHandler);

    LocalFree(ServiceNameW);

    return(statusHandle);
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerExW (
    IN  LPCWSTR                  ServiceName,
    IN  LPHANDLER_FUNCTION_EX    ControlHandler,
    IN  PVOID                    pContext
    )

/*++

Routine Description:

    This function enters a pointer to an extended control handling
    routine into the Control Dispatcher's dispatch table.  It is
    analogous to RegisterServiceCtrlHandlerW.

Arguments:

    ServiceName     -- The service's name
    ControlHandler  -- A pointer to an extended control handling routine
    pContext        -- User-supplied data that is passed to the control handler

Return Value:

    Anything returned by RegisterServiceCtrlHandlerHelp

--*/
{
    HANDLER_FUNCTION_TYPE   Handler;

    Handler.Ex = ControlHandler;

    return RegisterServiceCtrlHandlerHelp(ServiceName,
                                          Handler,
                                          pContext,
                                          SERVICE_EX_HANDLER);
}


SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerExA (
    IN  LPCSTR                 ServiceName,
    IN  LPHANDLER_FUNCTION_EX  ControlHandler,
    IN  PVOID                  pContext
    )
/*++

Routine Description:

    This is the ansi entry point for RegisterServiceCtrlHandlerEx.

Arguments:



Return Value:



--*/
{
    LPWSTR                  ServiceNameW;
    SERVICE_STATUS_HANDLE   statusHandle;

    if(!ScConvertToUnicode(&ServiceNameW, ServiceName)) {

        //
        // This can only fail because of a failed LocalAlloc call
        // or else the ansi string is garbage.
        //
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0L);
    }
    statusHandle = RegisterServiceCtrlHandlerExW(ServiceNameW,
                                                 ControlHandler,
                                                 pContext);

    LocalFree(ServiceNameW);

    return(statusHandle);
}


DWORD
ScCreateDispatchTableW(
    IN  CONST SERVICE_TABLE_ENTRYW  *lpServiceStartTable,
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchTablePtr
    )

/*++

Routine Description:

    This routine allocates space for the Control Dispatchers Dispatch Table.
    It also initializes the table with the data that the service main
    routine passed in with the lpServiceStartTable parameter.

    This routine expects that pointers in the user's dispatch table point
    to valid information.  And that that information will stay valid and
    fixed through out the life of the Control Dispatcher.  In otherwords,
    the ServiceName string better not move or get cleared.

Arguments:

    lpServiceStartTable - This is a pointer to the first entry in the
        dispatch table that the service's main routine passed in .

    DispatchTablePtr - This is a pointer to the location where the
        Service Controller's dispatch table is to be stored.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation failed.

    ERROR_INVALID_PARAMETER - There are no entries in the dispatch table.

--*/
{
    DWORD                       numEntries;
    LPINTERNAL_DISPATCH_ENTRY   dispatchTable;
    const SERVICE_TABLE_ENTRYW * entryPtr;

    //
    // Count the number of entries in the user dispatch table
    //

    numEntries = 0;
    entryPtr = lpServiceStartTable;

    while (entryPtr->lpServiceName != NULL) {
        numEntries++;
        entryPtr++;
    }

    if (numEntries == 0) {
        SCC_LOG(ERROR,"ScCreateDispatchTable:No entries in Dispatch table!\n",0);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Allocate space for the Control Dispatcher's Dispatch Table
    //

    dispatchTable = (LPINTERNAL_DISPATCH_ENTRY)LocalAlloc(LMEM_ZEROINIT,
                        sizeof(INTERNAL_DISPATCH_ENTRY) * (numEntries + 1));

    if (dispatchTable == NULL) {
        SCC_LOG(ERROR,"ScCreateDispatchTable: Local Alloc failed rc = %d\n",
            GetLastError());
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Move user dispatch info into the Control Dispatcher's table.
    //

    *DispatchTablePtr = dispatchTable;
    entryPtr = lpServiceStartTable;

    while (entryPtr->lpServiceName != NULL) {
        dispatchTable->ServiceName          = entryPtr->lpServiceName;
        dispatchTable->ServiceRealName      = entryPtr->lpServiceName;
        dispatchTable->ServiceStartRoutine.U= entryPtr->lpServiceProc;
        dispatchTable->ControlHandler.Ex    = NULL;
        dispatchTable->StatusHandle         = NULL;
        dispatchTable->dwFlags              = 0;
        entryPtr++;
        dispatchTable++;
    }

    return (NO_ERROR);
}

DWORD
ScCreateDispatchTableA(
    IN  CONST SERVICE_TABLE_ENTRYA  *lpServiceStartTable,
    OUT LPINTERNAL_DISPATCH_ENTRY   *DispatchTablePtr
    )

/*++

Routine Description:

    This routine allocates space for the Control Dispatchers Dispatch Table.
    It also initializes the table with the data that the service main
    routine passed in with the lpServiceStartTable parameter.

    This routine expects that pointers in the user's dispatch table point
    to valid information.  And that that information will stay valid and
    fixed through out the life of the Control Dispatcher.  In otherwords,
    the ServiceName string better not move or get cleared.

Arguments:

    lpServiceStartTable - This is a pointer to the first entry in the
        dispatch table that the service's main routine passed in .

    DispatchTablePtr - This is a pointer to the location where the
        Service Controller's dispatch table is to be stored.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation failed.

    ERROR_INVALID_PARAMETER - There are no entries in the dispatch table.

--*/
{
    DWORD                       numEntries;
    DWORD                       status = NO_ERROR;
    LPINTERNAL_DISPATCH_ENTRY   dispatchTable;
    const SERVICE_TABLE_ENTRYA * entryPtr;

    //
    // Count the number of entries in the user dispatch table
    //

    numEntries = 0;
    entryPtr = lpServiceStartTable;

    while (entryPtr->lpServiceName != NULL) {
        numEntries++;
        entryPtr++;
    }

    if (numEntries == 0) {
        SCC_LOG(ERROR,"ScCreateDispatchTable:No entries in Dispatch table!\n",0);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Allocate space for the Control Dispatcher's Dispatch Table
    //

    dispatchTable = (LPINTERNAL_DISPATCH_ENTRY)LocalAlloc(LMEM_ZEROINIT,
                        sizeof(INTERNAL_DISPATCH_ENTRY) * (numEntries + 1));

    if (dispatchTable == NULL) {
        SCC_LOG(ERROR,"ScCreateDispatchTableA: Local Alloc failed rc = %d\n",
            GetLastError());
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Move user dispatch info into the Control Dispatcher's table.
    //

    *DispatchTablePtr = dispatchTable;
    entryPtr = lpServiceStartTable;

    while (entryPtr->lpServiceName != NULL) {

        //
        // Convert the service name to unicode
        //

        __try {
            if (!ScConvertToUnicode(
                    &(dispatchTable->ServiceName),
                    entryPtr->lpServiceName)) {

                //
                // The convert failed.
                //
                SCC_LOG(ERROR,"ScCreateDispatcherTableA:ScConvertToUnicode failed\n",0);

                //
                // This is the only reason for failure that I can think of.
                //
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
            if (status != EXCEPTION_ACCESS_VIOLATION) {
                SCC_LOG(ERROR,
                    "ScCreateDispatchTableA: Unexpected Exception 0x%lx\n",status);
            }
        }
        if (status != NO_ERROR) {
            //
            // If an error occured, free up the allocated resources.
            //
            dispatchTable = *DispatchTablePtr;

            while (dispatchTable->ServiceName != NULL) {
                LocalFree(dispatchTable->ServiceName);
                dispatchTable++;
            }
            LocalFree(*DispatchTablePtr);
            return(status);
        }

        //
        // Fill in the rest of the dispatch entry.
        //
        dispatchTable->ServiceRealName      = dispatchTable->ServiceName;
        dispatchTable->ServiceStartRoutine.A= entryPtr->lpServiceProc;
        dispatchTable->ControlHandler.Ex    = NULL;
        dispatchTable->StatusHandle         = NULL;
        dispatchTable->dwFlags              = 0;
        entryPtr++;
        dispatchTable++;
    }

    return (NO_ERROR);
}


DWORD
ScReadServiceParms(
    IN  LPCTRL_MSG_HEADER       Msg,
    IN  DWORD                   dwNumBytesRead,
    OUT LPBYTE                  *ppServiceParams,
    OUT LPBYTE                  *ppTempArgPtr,
    OUT LPDWORD                 lpdwRemainingArgBytes
    )

/*++

Routine Description:

    This routine calculates the number of bytes needed for the service's
    control parameters by using the arg count information in the
    message header.  The parameter structure is allocated and
    as many bytes of argument information as have been captured so far
    are placed into the buffer.  A second read of the pipe may be necessary
    to obtain the remaining bytes of argument information.

    NOTE:  This function allocates enough space in the startup parameter
    buffer for the service name and pointer as well as the rest of the
    arguments.  However, it does not put the service name into the argument
    list.  This is because it may take two calls to this routine to
    get all the argument information.  We can't insert the service name
    string until we have all the rest of the argument data.

    [serviceNamePtr][argv1][argv2]...[argv1Str][argv2Str]...[serviceNameStr]

    or

    [serviceNamePtr][dwEventType][EventData][serviceNameStr]


Arguments:

    Msg - A pointer to the pipe message header.

    dwNumBytesRead - The number of bytes read in the first pipe read.

    ppServiceParams - A pointer to a location where the pointer to the
        thread startup parameter structure is to be placed.

    ppTempArgPtr - A location that will contain the pointer to where
        more argument data can be placed by a second read of the pipe.

    lpdwRemainingArgBytes - Returns with a count of the number of argument
        bytes that remain to be read from the pipe.

Return Value:

    NO_ERROR - If the operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - If the memory allocation was unsuccessful.

Note:


--*/
{
    DWORD            dwNameSize;         // num bytes in ServiceName.
    DWORD            dwBufferSize;       // num bytes for parameter buffer
    LONG             lArgBytesRead;      // number of arg bytes in first read.
    LPSERVICE_PARAMS lpTempParams;

    //
    // Set out pointer to no arguments unless we discover otherwise
    //
    *ppTempArgPtr = NULL;

    SCC_LOG(TRACE,"ScReadServiceParms: Get service parameters from pipe\n",0);

    //
    // Note: Here we assume that the service name was read into the buffer
    // in its entirety.
    //
    dwNameSize = (DWORD) WCSSIZE((LPWSTR) ((LPBYTE) Msg + Msg->ServiceNameOffset));

    //
    // Calculate the size of buffer needed.  This will consist of a
    // SERVICE_PARAMS structure, plus the service name and a pointer
    // for it, plus the rest of the arg info sent in the message
    // (We are wasting 4 bytes here since the first pointer in
    // the vector table is accounted for twice - but what the heck!).
    //

    dwBufferSize = Msg->Count -
                   sizeof(CTRL_MSG_HEADER) +
                   sizeof(SERVICE_PARAMS) +
                   sizeof(LPWSTR);

    //
    // Allocate the memory for the service parameters
    //
    lpTempParams = (LPSERVICE_PARAMS) LocalAlloc (LMEM_ZEROINIT, dwBufferSize);

    if (lpTempParams == NULL)
    {
        SCC_LOG1(ERROR,
                "ScReadServiceParms: LocalAlloc failed rc = %d\n",
                GetLastError());

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lArgBytesRead          = dwNumBytesRead - sizeof(CTRL_MSG_HEADER) - dwNameSize;
    *lpdwRemainingArgBytes = Msg->Count - dwNumBytesRead;

    //
    // Unpack message-specific arguments
    //
    switch (Msg->OpCode) {

        case SERVICE_CONTROL_START_OWN:
        case SERVICE_CONTROL_START_SHARE:

            SCC_LOG(TRACE,"ScReadServiceParms: Starting a service\n", 0);

            if (Msg->NumCmdArgs != 0) {

                //
                // There's only a vector table and ThreadStartupParms
                // when the service starts up
                //
                *ppTempArgPtr = (LPBYTE) &lpTempParams->ThreadStartupParms.VectorTable;

                //
                // Leave the first vector location blank for the service name
                // pointer.
                //
                (*ppTempArgPtr) += sizeof(LPWSTR);

                //
                // adjust lArgBytesRead to remove any extra bytes that are
                // there for alignment.  If a name that is not in the dispatch
                // table is passed in, it could be larger than our buffer.
                // This could cause lArgBytesRead to become negative.
                // However it should fail safe anyway since the name simply
                // won't be recognized and an error will be returned.
                //
                lArgBytesRead -= (Msg->ArgvOffset - Msg->ServiceNameOffset - dwNameSize);

                //
                // Copy any portion of the command arg info from the first read
                // into the buffer that is to be used for the second read.
                //

                if (lArgBytesRead > 0) {

                    RtlCopyMemory(*ppTempArgPtr,
                                  (LPBYTE)Msg + Msg->ArgvOffset,
                                  lArgBytesRead);

                    *ppTempArgPtr += lArgBytesRead;
                }
            }
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
        case SERVICE_CONTROL_POWEREVENT:
        case SERVICE_CONTROL_SESSIONCHANGE:
        {
            //
            // This is a PnP, power, or TS message
            //
            SCC_LOG1(TRACE,
                     "ScReadServiceParms: Receiving PnP/power/TS event %x\n",
                     Msg->OpCode);

            //
            // adjust lArgBytesRead to remove any extra bytes that are
            // there for alignment.  If a name that is not in the dispatch
            // table is passed in, it could be larger than our buffer.
            // This could cause lArgBytesRead to become negative.
            // However it should fail safe anyway since the name simply
            // won't be recognized and an error will be returned.
            //
            lArgBytesRead -= (Msg->ArgvOffset - Msg->ServiceNameOffset - dwNameSize);

            *ppTempArgPtr = (LPBYTE) &lpTempParams->HandlerExParms.dwEventType;

            if (lArgBytesRead > 0)
            {
                LPBYTE             lpArgs;
                LPHANDLEREX_PARMS  lpHandlerExParms = (LPHANDLEREX_PARMS) (*ppTempArgPtr);

                lpArgs = (LPBYTE) Msg + Msg->ArgvOffset;
                lpHandlerExParms->dwEventType = *(LPDWORD) lpArgs;

                lpArgs += sizeof(DWORD);
                lArgBytesRead -= sizeof(DWORD);

                RtlCopyMemory(lpHandlerExParms + 1,
                              lpArgs,
                              lArgBytesRead);

                lpHandlerExParms->lpEventData = lpHandlerExParms + 1;

                *ppTempArgPtr = (LPBYTE) (lpHandlerExParms + 1) + lArgBytesRead;
            }

            break;
        }
    }

    *ppServiceParams = (LPBYTE) lpTempParams;

    return NO_ERROR;
}


DWORD
ScConnectServiceController(
    OUT LPHANDLE    PipeHandle
    )

/*++

Routine Description:

    This function connects to the Service Controller Pipe.

Arguments:

    PipeHandle - This is a pointer to the location where the PipeHandle
        is to be placed.

Return Value:

    NO_ERROR - if the operation was successful.

    ERROR_FAILED_SERVICE_CONTROLLER_CONNECT - if we failed to connect.


--*/

{
    BOOL    status;
    DWORD   apiStatus;
    DWORD   response;
    DWORD   pipeMode;
    DWORD   numBytesWritten;

    WCHAR wszPipeName[sizeof(CONTROL_PIPE_NAME) / sizeof(WCHAR) + PID_LEN] = CONTROL_PIPE_NAME;

    //
    // Generate the pipe name -- Security process uses PID 0 since the
    // SCM doesn't have the PID at connect-time (it gets it from the
    // pipe transaction with the LSA)
    //

    if (g_fIsSecProc) {
        response = 0;
    }
    else {

        //
        // Read this process's pipe ID from the registry.
        //
        HKEY    hCurrentValueKey;

        status = RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     "System\\CurrentControlSet\\Control\\ServiceCurrent",
                     0,
                     KEY_QUERY_VALUE,
                     &hCurrentValueKey);

        if (status == ERROR_SUCCESS)
        {
            DWORD   ValueType;
            DWORD   cbData = sizeof(response);

            status = RegQueryValueEx(
                        hCurrentValueKey,
                        NULL,                // Use key's unnamed value
                        0,
                        &ValueType,
                        (LPBYTE) &response,
                        &cbData);

            RegCloseKey(hCurrentValueKey);

            if (status != ERROR_SUCCESS || ValueType != REG_DWORD)
            {
                SCC_LOG(ERROR,
                        "ScConnectServiceController:  RegQueryValueEx FAILED %d\n",
                        status);

                return(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT);
            }
        }
        else
        {
            SCC_LOG(ERROR,
                    "ScConnectServiceController:  RegOpenKeyEx FAILED %d\n",
                    status);

            return(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT);
        }
    }

    _itow(response, wszPipeName + sizeof(CONTROL_PIPE_NAME) / sizeof(WCHAR) - 1, 10);

    status = WaitNamedPipeW (
                wszPipeName,
                CONTROL_WAIT_PERIOD);

    if (status != TRUE) {
        SCC_LOG(ERROR,"ScConnectServiceController:WaitNamedPipe failed rc = %d\n",
            GetLastError());
    }

    SCC_LOG(TRACE,"ScConnectServiceController:WaitNamedPipe success\n",0);


    *PipeHandle = CreateFileW(
                    wszPipeName,                        // lpFileName
                    GENERIC_READ | GENERIC_WRITE,       // dwDesiredAccess
                    FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
                    NULL,                               // lpSecurityAttributes
                    OPEN_EXISTING,                      // dwCreationDisposition
                    FILE_ATTRIBUTE_NORMAL,              // dwFileAttributes
                    0L);                                // hTemplateFile

    if (*PipeHandle == INVALID_HANDLE_VALUE) {
        SCC_LOG(ERROR,"ScConnectServiceController:CreateFile failed rc = %d\n",
            GetLastError());
        return(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT);
    }

    SCC_LOG(TRACE,"ScConnectServiceController:CreateFile success\n",0);


    //
    // Set pipe mode
    //

    pipeMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;
    status = SetNamedPipeHandleState (
                *PipeHandle,
                &pipeMode,
                NULL,
                NULL);

    if (status != TRUE) {
        SCC_LOG(ERROR,"ScConnectServiceController:SetNamedPipeHandleState failed rc = %d\n",
            GetLastError());
        return(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT);
    }
    else {
        SCC_LOG(TRACE,
            "ScConnectServiceController SetNamedPipeHandleState Success\n",0);
    }

    //
    // Send initial status - This is the process Id for the service process.
    //
    response = GetCurrentProcessId();

    apiStatus = WriteFile (
                *PipeHandle,
                &response,
                sizeof(response),
                &numBytesWritten,
                NULL);

    if (apiStatus != TRUE) {
        //
        // If this fails, there is a chance that the pipe is still in good
        // shape.  So we just go on.
        //
        // ??EVENTLOG??
        //
        SCC_LOG(ERROR,"ScConnectServiceController: WriteFile failed, rc= %d\n", GetLastError());
    }
    else {
        SCC_LOG(TRACE,
            "ScConnectServiceController: WriteFile success, bytes Written= %d\n",
            numBytesWritten);
    }

    return(NO_ERROR);
}


VOID
ScExpungeMessage(
    IN  HANDLE  PipeHandle
    )

/*++

Routine Description:

    This routine cleans the remaining portion of a message out of the pipe.
    It is called in response to an unsuccessful attempt to allocate the
    correct buffer size from the heap.  In this routine a small buffer is
    allocated on the stack, and successive reads are made until a status
    other than ERROR_MORE_DATA is received.

Arguments:

    PipeHandle - This is a handle to the pipe in which the message resides.

Return Value:

    none - If this operation fails, there is not much I can do about
           the data in the pipe.

--*/
{
#define EXPUNGE_BUF_SIZE    100

    DWORD      status;
    DWORD      dwNumBytesRead = 0;
    BYTE       msg[EXPUNGE_BUF_SIZE];


    do {
        status = ReadFile (
                    PipeHandle,
                    msg,
                    EXPUNGE_BUF_SIZE,
                    &dwNumBytesRead,
                    NULL);
    }
    while( status == ERROR_MORE_DATA);

}


DWORD
ScGetPipeInput (
    IN      HANDLE                  PipeHandle,
    IN OUT  LPCTRL_MSG_HEADER       Msg,
    IN      DWORD                   dwBufferSize,
    OUT     LPSERVICE_PARAMS        *ppServiceParams
    )

/*++

Routine Description:

    This routine reads a control message from the pipe and places it into
    a message buffer.  This routine also allocates a structure for
    the service thread information.  This structure will eventually
    contain everything that is needed to invoke the service startup
    routine in the context of a new thread.  Items contained in the
    structure are:
        1) The pointer to the startup routine,
        2) The number of arguments, and
        3) The table of vectors to the arguments.
    Since this routine has knowledge about the buffer size needed for
    the arguments, the allocation is done here.

Arguments:

    PipeHandle - This is the handle for the pipe that is to be read.

    Msg - This is a pointer to a buffer where the data is to be placed.

    dwBufferSize - This is the size (in bytes) of the buffer that data is to
        be placed in.

    ppServiceParams - This is the location where the command args will
        be placed

Return Value:

    NO_ERROR - if the operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to create a large
        enough buffer for the command line arguments.

    ERROR_INVALID_DATA - This is returned if we did not receive a complete
        CTRL_MESSAGE_HEADER on the first read.


    Any error that ReadFile might return could be returned by this function.
    (We may want to return something more specific like ERROR_READ_FAULT)

--*/
{
    DWORD       status;
    BOOL        readStatus;
    DWORD       dwNumBytesRead = 0;
    DWORD       dwRemainingArgBytes;
    LPBYTE      pTempArgPtr;

    *ppServiceParams = NULL;

    //
    // Read the header and name string from the pipe.
    // NOTE:  The number of bytes for the name string is determined by
    //   the longest service name in the service process.  If the actual
    //   string read is shorter, then the beginning of the command arg
    //   data may be read with this read.
    // Also note:  The buffer is large enough to accommodate the longest
    //   permissible service name.
    //

    readStatus = ReadFile(PipeHandle,
                          Msg,
                          dwBufferSize,
                          &dwNumBytesRead,
                          NULL);

    SCC_LOG(TRACE,"ScGetPipeInput:ReadFile buffer size = %ld\n",dwBufferSize);
    SCC_LOG(TRACE,"ScGetPipeInput:ReadFile dwNumBytesRead = %ld\n",dwNumBytesRead);


    if ((readStatus == TRUE) && (dwNumBytesRead > sizeof(CTRL_MSG_HEADER))) {

        //
        // The Read File read the complete message in one read.  So we
        // can return with the data.
        //

        SCC_LOG(TRACE,"ScGetPipeInput: Success!\n",0);

        switch (Msg->OpCode) {

            case SERVICE_CONTROL_START_OWN:
            case SERVICE_CONTROL_START_SHARE:

                //
                // Read in any start arguments for the service
                //
                status = ScReadServiceParms(Msg,
                                            dwNumBytesRead,
                                            (LPBYTE *)ppServiceParams,
                                            &pTempArgPtr,
                                            &dwRemainingArgBytes);

                if (status != NO_ERROR) {
                    return status;
                }

                //
                // Change the offsets back into pointers.
                //
                ScNormalizeCmdLineArgs(Msg,
                                       &(*ppServiceParams)->ThreadStartupParms);

                break;

            case SERVICE_CONTROL_DEVICEEVENT:
            case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
            case SERVICE_CONTROL_POWEREVENT:
            case SERVICE_CONTROL_SESSIONCHANGE:

                //
                // Read in the service's PnP/power arguments
                //
                status = ScReadServiceParms(Msg,
                                            dwNumBytesRead,
                                            (LPBYTE *)ppServiceParams,
                                            &pTempArgPtr,
                                            &dwRemainingArgBytes);

                if (status != NO_ERROR) {
                    return status;
                }

                break;

            default:
                ASSERT(Msg->NumCmdArgs == 0);
                break;
        }

        return NO_ERROR;
    }
    else {
        //
        // An error was returned from ReadFile.  ERROR_MORE_DATA
        // means that we need to read some arguments from the buffer.
        // Any other error is unexpected, and generates an internal error.
        //

        if (readStatus != TRUE) {
            status = GetLastError();
            if (status != ERROR_MORE_DATA) {

                SCC_LOG(ERROR,"ScGetPipeInput:Unexpected return code, rc= %ld\n",
                    status);

                return status;
            }
        }
        else {
            //
            // The read was successful, but we didn't get a complete
            // CTRL_MESSAGE_HEADER.
            //
            return ERROR_INVALID_DATA;
        }
    }

    //
    // We must have received an ERROR_MORE_DATA to go down this
    // path.  This means that the message contains more data.  Namely,
    // service arguments must be present. Therefore, the pipe must
    // be read again.  Since the header indicates how many bytes are
    // needed, we will allocate a buffer large enough to hold all the
    // service arguments.
    //
    // If a portion of the arguments was read in the first read,
    // they will be put in this new buffer.  That is so that all the
    // command line arg info is in one place.
    //
    status = ScReadServiceParms(Msg,
                                dwNumBytesRead,
                                (LPBYTE *)ppServiceParams,
                                &pTempArgPtr,
                                &dwRemainingArgBytes);


    if (status != NO_ERROR)
    {
        ScExpungeMessage(PipeHandle);
        LocalFree(*ppServiceParams);
        *ppServiceParams = NULL;
        return status;
    }

    readStatus = ReadFile(PipeHandle,
                          pTempArgPtr,
                          dwRemainingArgBytes,
                          &dwNumBytesRead,
                          NULL);

    if ((readStatus != TRUE) || (dwNumBytesRead < dwRemainingArgBytes)) {

        if (readStatus != TRUE) {
            status = GetLastError();
            SCC_LOG1(ERROR,
                    "ScGetPipeInput: ReadFile error (2nd read), rc = %ld\n",
                    status);
        }
        else {
            status = ERROR_BAD_LENGTH;
        }

        SCC_LOG2(ERROR,
                "ScGetPipeInput: ReadFile read: %d, expected: %d\n",
                dwNumBytesRead,
                dwRemainingArgBytes);

        LocalFree(*ppServiceParams);
        *ppServiceParams = NULL;
        return status;
    }

    if (Msg->OpCode == SERVICE_CONTROL_START_OWN ||
        Msg->OpCode == SERVICE_CONTROL_START_SHARE) {

        //
        // Change the offsets back into pointers.
        //
        ScNormalizeCmdLineArgs(Msg, &(*ppServiceParams)->ThreadStartupParms);
    }

    return NO_ERROR;
}



DWORD
ScGetDispatchEntry (
    IN OUT  LPINTERNAL_DISPATCH_ENTRY   *DispatchEntryPtr,
    IN      LPWSTR                      ServiceName
    )

/*++

Routine Description:

    Finds an entry in the Dispatch Table for a particular service which
    is identified by a service name string.

Arguments:

    DispatchEntryPtr - As an input, the is a location where a pointer to
        the top of the DispatchTable is placed.  On return, this is the
        location where the pointer to the specific dispatch entry is to
        be placed.  This is an opaque pointer because it could be either
        ansi or unicode depending on the operational state of the dispatcher.

    ServiceName - This is a pointer to the service name string that was
        supplied by the service.  Note that it may not be the service's
        real name since we never check services that run in their own
        process (bug that can never be fixed since it will break existing
        services).  We must check for this name instead of the real
        one.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_SERVICE_NOT_IN_EXE - The serviceName could not be found in
        the dispatch table.  This indicates that the configuration database
        says the serice is in this process, but the service name doesn't
        exist in the dispatch table.

--*/
{
    LPINTERNAL_DISPATCH_ENTRY   entryPtr;
    DWORD                       found = FALSE;

    entryPtr = *DispatchEntryPtr;

    if (entryPtr->dwFlags & SERVICE_OWN_PROCESS) {
        return (NO_ERROR);
    }

    while (entryPtr->ServiceName != NULL) {
        if (_wcsicmp(entryPtr->ServiceName, ServiceName) == 0) {
            found = TRUE;
            break;
        }
        entryPtr++;
    }
    if (found) {
        *DispatchEntryPtr = entryPtr;
    }
    else {
        SCC_LOG(ERROR,"ScGetDispatchEntry: DispatchEntry not found\n"
        "    Configuration error - the %ws service is not in this .exe file!\n"
        "    Check the table passed to StartServiceCtrlDispatcher.\n", ServiceName);
        return(ERROR_SERVICE_NOT_IN_EXE);
    }

    return(NO_ERROR);
}


DWORD
ScRemoveDispatchEntry(
    IN SC_HANDLE hStatusHandle
    )

/*++

Routine Description:

    Clears out the status handle for an entry in the Dispatch Table.

Arguments:

    hStatusHandle - service status handle given by RegisterServiceCtrlHandler/Ex.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_SERVICE_NOT_IN_EXE - The service of StatusHandle could not be found in
        the dispatch table.  This indicates that the configuration database
        says the serice is in this process, but the service doesn't exist in
        the dispatch table.

--*/
{
    LPINTERNAL_DISPATCH_ENTRY   dispatchEntry;

    //
    // This should only be called from SetServiceStatus when stopping
    // a service, so the table should already be there.
    //

    ASSERT(DispatchTable != NULL);

    dispatchEntry = DispatchTable;

    while (dispatchEntry->ServiceName != NULL)
    {
        if (dispatchEntry->StatusHandle == hStatusHandle)
        {
            dispatchEntry->StatusHandle = NULL;
            return NO_ERROR;
        }

        dispatchEntry++;
    }

    //
    // Shouldn't be called with a SERVICE_STATUS_HANDLE that's not in the table.
    //

    ASSERT(FALSE);

    return ERROR_SERVICE_NOT_IN_EXE;
}


VOID
ScNormalizeCmdLineArgs(
    IN OUT  LPCTRL_MSG_HEADER       Msg,
    IN OUT  LPTHREAD_STARTUP_PARMSW ThreadStartupParms
    )

/*++

Routine Description:

    Normalizes the command line argument information that came across in
    the pipe.  The argument information is stored in a buffer that consists
    of an array of string pointers followed by the strings themselves.
    However, in the pipe, the pointers are replaced with offsets.  This
    routine transforms the offsets into real pointers.

    This routine also puts the service name into the array of argument
    vectors, and adds the service name string to the end of the
    buffer (space has already been allocated for it).

Arguments:

    Msg - This is a pointer to the Message.  Useful information from this
        includes the NumCmdArgs and the service name.

    ThreadStartupParms - A pointer to the thread startup parameter structure.

Return Value:

    none.

--*/
{
    DWORD   i;
    LPWSTR  *argv;
    DWORD   numCmdArgs;
    LPWSTR  *serviceNameVector;
    LPWSTR  serviceNamePtr;
#if defined(_X86_)
    PULONG64 argv64 = NULL;
#endif

    numCmdArgs = Msg->NumCmdArgs;

    argv = &(ThreadStartupParms->VectorTable);

    //
    // Save the first argv for the service name.
    //
    serviceNameVector = argv;
    argv++;

    //
    // Normalize the Command Line Argument information by replacing
    // offsets in buffer with pointers.
    //
    // NOTE:  The elaborate casting that takes place here is because we
    //   are taking some (pointer sized) offsets, and turning them back
    //   into pointers to strings.  The offsets are in bytes, and are
    //   relative to the beginning of the vector table which contains
    //   pointers to the various command line arg strings.
    //

#if defined(_X86_)
    if (g_fWow64Process) {
        //
        // Pointers on the 64-bit land are 64-bit so make argv
        // point to the 1st arg after the service name offset
        //
        argv64 = (PULONG64)argv;

    }
#endif

    for (i = 0; i < numCmdArgs; i++) {
#if defined(_X86_)
        if (g_fWow64Process)
            argv[i] = (LPWSTR)((LPBYTE)argv + PtrToUlong(argv64[i]));
        else
#endif
            argv[i] = (LPWSTR)((LPBYTE)argv + PtrToUlong(argv[i]));
    }


    //
    // If we are starting a service, then we need to add the service name
    // to the argument vectors.
    //
    if ((Msg->OpCode == SERVICE_CONTROL_START_SHARE) ||
        (Msg->OpCode == SERVICE_CONTROL_START_OWN))  {

        numCmdArgs++;

        if (numCmdArgs > 1) {
            //
            // Find the location for the service name string by finding
            // the pointer to the last argument adding its string length
            // to it.
            //
            serviceNamePtr = argv[i-1];
            serviceNamePtr += (wcslen(serviceNamePtr) + 1);
        }
        else {
            serviceNamePtr = (LPWSTR)argv;
        }
        wcscpy(serviceNamePtr, (LPWSTR) ((LPBYTE)Msg + Msg->ServiceNameOffset));
        *serviceNameVector = serviceNamePtr;
    }

    ThreadStartupParms->NumArgs = numCmdArgs;
}


VOID
ScSendResponse (
    IN  HANDLE  PipeHandle,
    IN  DWORD   Response,
    IN  DWORD   dwHandlerRetVal
    )

/*++

Routine Description:

    This routine sends a status response to the Service Controller's pipe.

Arguments:

    Response - This is the status message that is to be sent.

    dwHandlerRetVal - This is the return value from the service's control
                      handler function (NO_ERROR for non-Ex handlers)

Return Value:

    none.

--*/
{
    DWORD  numBytesWritten;

    PIPE_RESPONSE_MSG  prmResponse;

    prmResponse.dwDispatcherStatus = Response;
    prmResponse.dwHandlerRetVal    = dwHandlerRetVal;

    if (!WriteFile(PipeHandle,
                   &prmResponse,
                   sizeof(PIPE_RESPONSE_MSG),
                   &numBytesWritten,
                   NULL))
    {
        SCC_LOG1(ERROR,
                 "ScSendResponse: WriteFile failed, rc= %d\n",
                 GetLastError());
    }
}


DWORD
ScSvcctrlThreadW(
    IN LPTHREAD_STARTUP_PARMSW  lpThreadStartupParms
    )

/*++

Routine Description:

    This is the thread for the newly started service.  This code
    calls the service's main thread with parameters from the
    ThreadStartupParms structure.

    NOTE:  The first item in the argument vector table is the pointer to
           the service registry path string.

Arguments:

    lpThreadStartupParms - This is a pointer to the ThreadStartupParms
        structure. (This is a unicode structure);

Return Value:



--*/
{

    //
    // Call the Service's Main Routine.
    //
    ((LPSERVICE_MAIN_FUNCTIONW)lpThreadStartupParms->ServiceStartRoutine) (
        lpThreadStartupParms->NumArgs,
        &lpThreadStartupParms->VectorTable);

    LocalFree(lpThreadStartupParms);

    return(0);
}


DWORD
ScSvcctrlThreadA(
    IN LPTHREAD_STARTUP_PARMSA  lpThreadStartupParms
    )

/*++

Routine Description:

    This is the thread for the newly started service.  This code
    calls the service's main thread with parameters from the
    ThreadStartupParms structure.

    NOTE:  The first item in the argument vector table is the pointer to
           the service registry path string.

Arguments:

    lpThreadStartupParms - This is a pointer to the ThreadStartupParms
        structure. (This is a unicode structure);

Return Value:



--*/
{
    //
    // Call the Service's Main Routine.
    //
    // NOTE:  The first item in the argument vector table is the pointer to
    //  the service registry path string.
    //
    ((LPSERVICE_MAIN_FUNCTIONA)lpThreadStartupParms->ServiceStartRoutine) (
        lpThreadStartupParms->NumArgs,
        &lpThreadStartupParms->VectorTable);

    LocalFree(lpThreadStartupParms);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\client\scwrap.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    scwrap.c

Abstract:

    These are the Service Controller API RPC client wrapper routines.
    These are the entry points that are exported by the dll.
        ControlService
        EnumServicesStatusW
        EnumServicesStatusA
        EnumServicesStatusExW
        EnumServicesStatusExA
        EnumServiceGroupW
        OpenServiceW
        CloseServiceHandle
        OpenSCManagerW
        QueryServiceStatus
        QueryServiceStatusEx
        StartServiceW
        SetServiceStatus
        I_ScSetServiceBitsW
        I_ScSetServiceBitsA
        I_ScGetCurrentGroupStateW
        I_ScSendTSMessage
        SetServiceBits

        OpenSCManagerA
        OpenServiceA
        StartServiceA

        QueryServiceObjectSecurity
        SetServiceObjectSecurity
        ScConvertOffsetsW
        ScConvertOffsetsA
        ScConvertOffsetsExW
        ScConvertOffsetsExA
        ScConvertOffsets64

        ChangeServiceConfigA
        ChangeServiceConfigW
        ChangeServiceConfig2A
        ChangeServiceConfig2W
        CreateServiceA
        CreateServiceW
        DeleteService
        EnumDependentServicesA
        EnumDependentServicesW
        GetServiceDisplayNameA
        GetServiceDisplayNameW
        GetServiceKeyNameA
        GetServiceKeyNameW
        LockServiceDatabase
        QueryServiceConfigA
        QueryServiceConfigW
        QueryServiceConfig2A
        QueryServiceConfig2W
        QueryServiceLockStatusA
        QueryServiceLockStatusW
        UnlockServiceDatabase
        NotifyBootConfigStatus

Author:

    Dan Lafferty    (danl)  03-Feb-1992

Environment:

    User Mode - Win32

Revision History:

    07-May-1998 jschwart
        Added QueryServiceStatusEx and EnumServicesStatusEx
    11-Oct-1996 AnirudhS
        Added ChangeServiceConfig2 and QueryServiceConfig2.
    14-Feb-1996 AnirudhS
        Added EnumServiceGroupW.
    22-Sep-1995 AnirudhS
        ScWaitForStart: Fixed race condition - OpenEvent needs to be tried
        a second time after CreateEvent.
    15-Aug-1995 AnirudhS
        Added I_ScGetCurrentGroupStateW.
    05-Nov-1992 Danl
        Added display name changes (CreateService, ChangeServiceConfig) and
        new api (GetServiceDisplayName, GetServiceKeyName).
    13-Oct-1992 Danl
        Allow 0 length buffers to be passed into EnumServicesStatus and
        EnumDependentServices.
    04-Aug-1992 Danl
        Allow 0 length buffers to be passed into QueryServiceConfig and
        QueryServiceLockStatus.
    28-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.
    14-Apr-1992 JohnRo
        Enable Lock and Unlock APIs.
    03-Feb-1992     Danl
        Created

--*/

//
// INCLUDES
//

extern "C"
{
#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed when we include windows.h
}
#include <rpc.h>        // DataTypes and runtime APIs

#include <windows.h>    // NO_ERROR
#include <svcctl.h>     // generated by the MIDL compiler
#include <lmcons.h>     // for lmserver.h
#include <srvann.h>     // MS-internal functions
#include <winsvcp.h>    // MS-internal functions
#include <rpcasync.h>   // I_RpcExceptionFilter

#include <string.h>     // needed by strarray.h
#include <scdebug.h>    // SCC_LOG
#include <sccrypt.h>    // ScEncryptPassword
#include <sclib.h>      // ScConvertToUnicode
#include <strarray.h>   // ScWStrArraySize
#include <lmerr.h>      // for lmserver.h
#include <lmserver.h>   // SV_TYPE_WORKSTATION ...
#include <scseclib.h>   // ScCreateStartEventSD
#include <scwow.h>      // 32/64-bit interop structures

//
// DEFINES
//
#define SC_START_TIMEOUT    180000      // 3 minute timeout

#define RESERVED_BITS  (SV_TYPE_WORKSTATION         |   \
                        SV_TYPE_SERVER              |   \
                        SV_TYPE_DOMAIN_CTRL         |   \
                        SV_TYPE_DOMAIN_BAKCTRL      |   \
                        SV_TYPE_TIME_SOURCE         |   \
                        SV_TYPE_AFP                 |   \
                        SV_TYPE_DOMAIN_MEMBER       |   \
                        SV_TYPE_PRINTQ_SERVER       |   \
                        SV_TYPE_DIALIN_SERVER       |   \
                        SV_TYPE_XENIX_SERVER        |   \
                        SV_TYPE_SERVER_UNIX         |   \
                        SV_TYPE_NT                  |   \
                        SV_TYPE_WFW                 |   \
                        SV_TYPE_POTENTIAL_BROWSER   |   \
                        SV_TYPE_BACKUP_BROWSER      |   \
                        SV_TYPE_MASTER_BROWSER      |   \
                        SV_TYPE_DOMAIN_MASTER       |   \
                        SV_TYPE_LOCAL_LIST_ONLY     |   \
                        SV_TYPE_DOMAIN_ENUM)



//
// LOCAL FUNCTIONS
//

VOID
ScConvertOffsetsW(
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   NumStructs
    );

VOID
ScConvertOffsetsA(
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   NumStructs
    );

VOID
ScConvertOffsetsExW(
    LPENUM_SERVICE_STATUS_PROCESSW  lpServices,
    DWORD                           NumStructs
    );

VOID
ScConvertOffsetsExA(
    LPENUM_SERVICE_STATUS_PROCESSA  lpServices,
    DWORD                           NumStructs
    );


#ifdef _WIN64

//
// API numbers for ScConvertOffsets64
//

typedef enum
{
    SC_API_ENUM_W = 0,
    SC_API_ENUM_A,
    SC_API_ENUM_GROUP,
    SC_API_ENUM_DEPEND_W,
    SC_API_ENUM_DEPEND_A,
    SC_API_ENUM_PROCESS_W,
    SC_API_ENUM_PROCESS_A,
    SC_API_QUERY_DESCRIPTION_W,
    SC_API_QUERY_DESCRIPTION_A,
    SC_API_QUERY_FAILURE_ACTIONS_W,
    SC_API_QUERY_FAILURE_ACTIONS_A,
    SC_API_MAX
}
SC_API_NUMBER;


BOOL
ScConvertOffsets64(
    SC_API_NUMBER  scApi,
    SC_HANDLE      hSCManager,
    DWORD          dwServiceType,
    DWORD          dwServiceState,
    LPBYTE         lpServices,
    DWORD          cbBufSize,
    LPDWORD        pcbBytesNeeded,
    LPDWORD        lpServicesReturned,
    LPDWORD        lpResumeIndex,
    LPVOID         pszGroupName,
    LPDWORD        lpdwError
    );

#endif // _WIN64


DWORD
ScMapRpcError(
    IN DWORD RpcError,
    IN DWORD BadContextError
    );

DWORD
ScWaitForStart(
    VOID
    );

DWORD
ScRemoveDispatchEntry(
    IN SC_HANDLE hStatusHandle
    );


//
// Globals
//

extern "C"
{

void
SccInit(
	DWORD dwReason
    )
{

    return;
}

}


BOOL
WINAPI
ControlService(
    IN  SC_HANDLE           hService,
    IN  DWORD               dwControl,
    OUT LPSERVICE_STATUS    lpServiceStatus
    )

/*++

Routine Description:

    This is the DLL entrypoint for Control Service

Arguments:


Return Value:



--*/
{
    DWORD      status;


    RpcTryExcept {

        status = RControlService (
                    (SC_RPC_HANDLE)hService,
                    dwControl,
                    lpServiceStatus);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
EnumServicesStatusW(
    IN      SC_HANDLE               hSCManager,
    IN      DWORD                   dwServiceType,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSW  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned,
    IN OUT  LPDWORD                 lpResumeIndex
    )
/*++

Routine Description:

    This is the DLL entrypoint for EnumServicesStatusW

Arguments:


Return Value:


Note:


--*/
{
    return EnumServiceGroupW(
                hSCManager,
                dwServiceType,
                dwServiceState,
                lpServices,
                cbBufSize,
                pcbBytesNeeded,
                lpServicesReturned,
                lpResumeIndex,
                NULL);
}


BOOL
WINAPI
EnumServicesStatusExW(
    IN      SC_HANDLE                  hSCManager,
    IN      SC_ENUM_TYPE               InfoLevel,
    IN      DWORD                      dwServiceType,
    IN      DWORD                      dwServiceState,
    OUT     LPBYTE                     lpServices,
    IN      DWORD                      cbBufSize,
    OUT     LPDWORD                    pcbBytesNeeded,
    OUT     LPDWORD                    lpServicesReturned,
    IN OUT  LPDWORD                    lpResumeIndex,
    IN      LPCWSTR                    pszGroupName
    )
/*++

Routine Description:

    This is the DLL entrypoint for EnumServicesStatusExW

Arguments:


Return Value:


Note:


--*/
{
    DWORD                           status;
    LPENUM_SERVICE_STATUS_PROCESSW  pEnumBuf;
    ENUM_SERVICE_STATUS_PROCESSW    enumBuf;
    DWORD                           tempBufSize;

#ifdef _WIN64

    DWORD                           dwOldResumeIndex = 0;

    if (lpResumeIndex != NULL)
    {
        dwOldResumeIndex = *lpResumeIndex;
    }

#endif // _WIN64

    //
    // Make sure we were passed a valid InfoLevel
    //
    if (InfoLevel != SC_ENUM_PROCESS_INFO)
    {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUS_PROCESSW) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUS_PROCESSW);
    }
    else {
        pEnumBuf = (LPENUM_SERVICE_STATUS_PROCESSW)lpServices;
    }


    RpcTryExcept {

        status = REnumServicesStatusExW (
                        hSCManager,
                        InfoLevel,
                        dwServiceType,
                        dwServiceState,
                        (LPBYTE)pEnumBuf,
                        tempBufSize,
                        pcbBytesNeeded,
                        lpServicesReturned,
                        lpResumeIndex,
                        pszGroupName);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_PROCESS_W,
                                    hSCManager,
                                    dwServiceType,
                                    dwServiceState,
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    &dwOldResumeIndex,
                                    (LPVOID) pszGroupName,
                                    &dwError))
            {
                status = dwError;

                if (lpResumeIndex != NULL)
                {
                    *lpResumeIndex = dwOldResumeIndex;
                }
            }

#else  // ndef _WIN64

            ScConvertOffsetsExW((LPENUM_SERVICE_STATUS_PROCESSW) lpServices,
                                *lpServicesReturned);

#endif // _WIN64

        }

#ifdef _WIN64

        //
        // The byte count returned is the size needed to hold all of
        // the 32-bit structures rather than the 64-bit ones.  Assume
        // a buffer full of fixed-length structures (i.e., no variable-
        // length data) and scale from 32- to 64-bit sizes to get the
        // minimum guaranteed size for all the 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUS_PROCESSW)
                              / sizeof(ENUM_SERVICE_STATUS_PROCESS_WOW64);

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
EnumServiceGroupW(
    IN      SC_HANDLE               hSCManager,
    IN      DWORD                   dwServiceType,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSW  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned,
    IN OUT  LPDWORD                 lpResumeIndex,
    IN      LPCWSTR                 pszGroupName
    )
/*++

Routine Description:

    This is the DLL entrypoint for EnumServiceGroupW

Arguments:


Return Value:


Note:

--*/
{
    DWORD                   status;
    LPENUM_SERVICE_STATUSW  pEnumBuf;
    ENUM_SERVICE_STATUSW    enumBuf;
    DWORD                   tempBufSize;

#ifdef _WIN64

    DWORD                   dwOldResumeIndex = 0;

    if (lpResumeIndex != NULL)
    {
        dwOldResumeIndex = *lpResumeIndex;
    }

#endif // _WIN64


    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUSW) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUSW);
    }
    else {
        pEnumBuf = lpServices;
    }


    RpcTryExcept {

        if (pszGroupName == NULL) {
            //
            // Call the downlevel API, so that the call will work on targeted
            // machines running Windows NT 3.51 or earlier
            //
            status = REnumServicesStatusW (
                        (SC_RPC_HANDLE)hSCManager,
                        dwServiceType,
                        dwServiceState,
                        (LPBYTE)pEnumBuf,
                        tempBufSize,
                        pcbBytesNeeded,
                        lpServicesReturned,
                        lpResumeIndex);
        }
        else {
            status = REnumServiceGroupW (
                        (SC_RPC_HANDLE)hSCManager,
                        dwServiceType,
                        dwServiceState,
                        (LPBYTE)pEnumBuf,
                        tempBufSize,
                        pcbBytesNeeded,
                        lpServicesReturned,
                        lpResumeIndex,
                        pszGroupName);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(pszGroupName ? SC_API_ENUM_GROUP :
                                                   SC_API_ENUM_W,
                                    hSCManager,
                                    dwServiceType,
                                    dwServiceState,
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    &dwOldResumeIndex,
                                    (LPVOID) pszGroupName,
                                    &dwError))
            {
                status = dwError;

                if (lpResumeIndex != NULL)
                {
                    *lpResumeIndex = dwOldResumeIndex;
                }
            }

#else  // ndef _WIN64

            ScConvertOffsetsW(lpServices, *lpServicesReturned);

#endif // _WIN64

        }

#ifdef _WIN64

        //
        // The byte count returned is the size needed to hold all of
        // the 32-bit structures rather than the 64-bit ones.  Assume
        // a buffer full of fixed-length structures (i.e., no variable-
        // length data) and scale from 32- to 64-bit sizes to get the
        // minimum guaranteed size for all the 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUSW)
                              / sizeof(ENUM_SERVICE_STATUS_WOW64);

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


SC_HANDLE
WINAPI
OpenServiceW(
    IN  SC_HANDLE   hSCManager,
    IN  LPCWSTR     lpServiceName,
    IN  DWORD       dwDesiredAccess
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/

{
    DWORD           status;
    SC_RPC_HANDLE   hService=NULL;


    RpcTryExcept {

        status = ROpenServiceW (
                    (SC_RPC_HANDLE)hSCManager,
                    (LPWSTR) lpServiceName,
                    dwDesiredAccess,
                    &hService);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)hService;
}

BOOL
WINAPI
CloseServiceHandle(
    IN  SC_HANDLE   hSCObject
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/

{
    DWORD      status;


    RpcTryExcept {

        status = RCloseServiceHandle((LPSC_RPC_HANDLE)&hSCObject);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


SC_HANDLE
WINAPI
OpenSCManagerW(
    IN  LPCWSTR lpMachineName,
    IN  LPCWSTR lpDatabaseName OPTIONAL,
    IN  DWORD   dwDesiredAccess
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD           status;
    SC_RPC_HANDLE   ScHandle=NULL;


    //
    // Check to see if the local Service Controller is started yet.
    // If not, then wait for it to start (or timeout).
    //

    status = ScWaitForStart();

    if (status != NO_ERROR) {
        SetLastError(status);
        return(NULL);
    }

    RpcTryExcept {

        status = ROpenSCManagerW (
                    (LPWSTR) lpMachineName,
                    (LPWSTR) lpDatabaseName,
                    dwDesiredAccess,
                    &ScHandle);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)ScHandle;
}

BOOL
WINAPI
QueryServiceStatus(
    IN  SC_HANDLE           hService,
    OUT LPSERVICE_STATUS    lpServiceStatus
    )
/*++

Routine Description:

    This is the DLL entrypoint for QueryServiceStatus.

Arguments:


Return Value:


--*/

{
    DWORD          status;

    RpcTryExcept {

        status = RQueryServiceStatus (
            (SC_RPC_HANDLE)hService,
            lpServiceStatus);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
QueryServiceStatusEx(
    IN      SC_HANDLE       hService,
    IN      SC_STATUS_TYPE  InfoLevel,
    OUT     LPBYTE          lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded
    )
/*++

Routine Description:

    This is the DLL entrypoint for QueryServiceStatusEx.

Arguments:


Return Value:


Note:

--*/
{
    DWORD                        status;

    switch (InfoLevel) {

        case SC_STATUS_PROCESS_INFO:

            if (cbBufSize < sizeof(SERVICE_STATUS_PROCESS)) {

                //
                // The buffer is too small -- since the structure is a fixed
                // size, we can handle this error on the client side
                //
                *pcbBytesNeeded = sizeof(SERVICE_STATUS_PROCESS);

                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }

            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }

    RpcTryExcept {

        status = RQueryServiceStatusEx (
            (SC_RPC_HANDLE)hService,
            InfoLevel,
            lpBuffer,
            cbBufSize,
            pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
StartServiceW(
    IN SC_HANDLE            hService,
    IN DWORD                dwNumServiceArgs,
    IN LPCWSTR              *lpServiceArgVectors
    )
/*++

Routine Description:

    This is the DLL entrypoint for StartServiceW

Arguments:

    servername - Points to a string containing the name of the computer
        that is to execute the API function.

    service- Points to a string containing the name of the service
        that is to be started.

    argc - Indicates the number or argument vectors in argv.

    argv - A pointer to an array of pointers to strings.  These
        are command line arguments that are to be passed to the service.

    bufptr - This is the address where a pointer to the service's
        information buffer (SERVICE_INFO_2) is to be placed.

Return Value:



--*/

{
    DWORD          status;



    RpcTryExcept {

        status = RStartServiceW (
                    (SC_RPC_HANDLE)hService,
                    dwNumServiceArgs,
                    (LPSTRING_PTRSW)lpServiceArgVectors);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
SetServiceStatus(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN LPSERVICE_STATUS         lpServiceStatus
    )
/*++

Routine Description:

    This is the DLL entrypoint for SetServiceStatus.  It is called from
    a service when that service changes its state or receives a control.
    The status is maintained by the service controller.

Arguments:

    hServiceStatus - This is a handle that was obtained from calling
        the RegisterControlHandler function.

    lpServiceStatus - This is a pointer to a service status structure.

Return Value:


--*/
{
    DWORD      status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {
        status = RSetServiceStatus (
                    (SC_HANDLE)hServiceStatus,
                    lpServiceStatus);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED) {

        //
        // Service is stopping -- close the handle we opened
        // in StartServiceCtrlDispatcher when the service started
        //

        ScRemoveDispatchEntry((SC_HANDLE) hServiceStatus);
        CloseServiceHandle((SC_HANDLE) hServiceStatus);
    }

    return(TRUE);
}

BOOL
I_ScSetServiceBitsA(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately,
    IN LPSTR                    pszTransportName
    )

/*++

Routine Description:

    This is an internal routine that sets the Server Announcement bits
    in the service controller.

Arguments:

    hServiceStatus -

    dwServiceBits -

Return Value:


Note:


--*/
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}


BOOL
I_ScSetServiceBitsW(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately,
    IN LPWSTR                   pszTransportName
    )

/*++

Routine Description:

    This is an internal routine that sets the Server Announcement bits
    in the service controller.

Arguments:

    hServiceStatus -

    dwServiceBits -

Return Value:


Note:


--*/
{
    DWORD   status;
    DWORD   setBitsOnFlag=0;
    DWORD   updateImmediatelyFlag=0;

    if(bSetBitsOn) {
        setBitsOnFlag = 1;
    }

    if(bUpdateImmediately) {
        updateImmediatelyFlag = 1;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept {
        status = RI_ScSetServiceBitsW (
                    (SC_HANDLE)hServiceStatus,
                    dwServiceBits,
                    setBitsOnFlag,
                    updateImmediatelyFlag,
                    pszTransportName);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


DWORD
I_ScGetCurrentGroupStateW(
    IN  SC_HANDLE               hSCManager,
    IN  LPWSTR                  pszGroupName,
    OUT LPDWORD                 pdwCurrentState
    )
/*++

Routine Description:

    This is obsolete but some (MS) apps still statically link to it.

--*/
{
    return ERROR_NOT_SUPPORTED;
}


extern "C" {

DWORD
I_ScSendTSMessage(
    DWORD        OpCode,
    DWORD        dwEvent,
    DWORD        cbData,
    LPBYTE       lpData
    )

/*++

Routine Description:

    Private entrypoint for Terminal Server to tell the SCM to send
    console switch notification to services that are interested.

--*/

{
    DWORD     status;
    SC_HANDLE hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCManager == NULL)
    {
        return GetLastError();
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //
    RpcTryExcept
    {
        status = RI_ScSendTSMessage(hSCManager,
                                    OpCode,
                                    dwEvent,
                                    cbData,
                                    lpData);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    CloseServiceHandle(hSCManager);

    return status;
}

}  // extern "C"


BOOL
NET_API_FUNCTION
SetServiceBits(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately
    )

/*++

Routine Description:

    This is an internal routine that sets the Server Announcement bits
    in the service controller.

Arguments:

    hServiceStatus -

    dwServiceBits -

Return Value:


Note:


--*/
{
    if (dwServiceBits & RESERVED_BITS) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }
    return(I_ScSetServiceBitsW(
            hServiceStatus,
            dwServiceBits,
            bSetBitsOn,
            bUpdateImmediately,
            (LPWSTR)NULL));
}


SC_HANDLE
WINAPI
OpenSCManagerA(
    IN  LPCSTR  lpMachineName,
    IN  LPCSTR  lpDatabaseName OPTIONAL,
    IN  DWORD   dwDesiredAccess
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD           status;
    SC_RPC_HANDLE   ScHandle=NULL;


    //
    // Check to see if the local Service Controller is started yet.
    // If not, then wait for it to start (or timeout).
    //

    status = ScWaitForStart();

    if (status != NO_ERROR) {
        SetLastError(status);
        return(NULL);
    };


    RpcTryExcept {

        status = ROpenSCManagerA (
                    (LPSTR) lpMachineName,
                    (LPSTR) lpDatabaseName,
                    dwDesiredAccess,
                    &ScHandle);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)ScHandle;
}



SC_HANDLE
WINAPI
OpenServiceA(
    IN  SC_HANDLE   hSCManager,
    IN  LPCSTR      lpServiceName,
    IN  DWORD       dwDesiredAccess
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    DWORD           status;
    SC_RPC_HANDLE   hService=NULL;


    RpcTryExcept {

        status = ROpenServiceA (
                    (SC_RPC_HANDLE)hSCManager,
                    (LPSTR) lpServiceName,
                    dwDesiredAccess,
                    &hService);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)hService;
}



BOOL
WINAPI
StartServiceA(
    IN SC_HANDLE            hService,
    IN DWORD                dwNumServiceArgs,
    IN LPCSTR               *lpServiceArgVectors
    )
/*++

Routine Description:



Arguments:

    servername - Points to a string containing the name of the computer
        that is to execute the API function.

    service- Points to a string containing the name of the service
        that is to be started.

    argc - Indicates the number or argument vectors in argv.

    argv - A pointer to an array of pointers to strings.  These
        are command line arguments that are to be passed to the service.

    bufptr - This is the address where a pointer to the service's
        information buffer (SERVICE_INFO_2) is to be placed.

Return Value:



--*/
{
    DWORD          status;

    RpcTryExcept {

        status = RStartServiceA (
                    (SC_RPC_HANDLE)hService,
                    dwNumServiceArgs,
                    (LPSTRING_PTRSA)lpServiceArgVectors);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}



BOOL
WINAPI
EnumServicesStatusA(
    IN      SC_HANDLE               hSCManager,
    IN      DWORD                   dwServiceType,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSA  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned,
    IN OUT  LPDWORD                 lpResumeIndex
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    DWORD                   status;
    LPENUM_SERVICE_STATUSA  pEnumBuf;
    ENUM_SERVICE_STATUSA    enumBuf;
    DWORD                   tempBufSize;

#ifdef _WIN64

    DWORD                   dwOldResumeIndex = 0;

    if (lpResumeIndex != NULL)
    {
        dwOldResumeIndex = *lpResumeIndex;
    }

#endif // _WIN64


    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUSA) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUSA);
    }
    else {
        pEnumBuf = lpServices;
    }

    RpcTryExcept {

        status = REnumServicesStatusA (
                    (SC_RPC_HANDLE)hSCManager,
                    dwServiceType,
                    dwServiceState,
                    (LPBYTE)pEnumBuf,
                    tempBufSize,
                    pcbBytesNeeded,
                    lpServicesReturned,
                    lpResumeIndex);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_A,
                                    hSCManager,
                                    dwServiceType,
                                    dwServiceState,
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    &dwOldResumeIndex,
                                    NULL,
                                    &dwError))
            {
                status = dwError;

                if (lpResumeIndex != NULL)
                {
                    *lpResumeIndex = dwOldResumeIndex;
                }
            }

#else  // ndef _WIN64

            ScConvertOffsetsA(lpServices, *lpServicesReturned);

#endif // _WIN64

        }

#ifdef _WIN64

        //
        // The byte count returned is the size needed to hold all of
        // the 32-bit structures rather than the 64-bit ones.  Assume
        // a buffer full of fixed-length structures (i.e., no variable-
        // length data) and scale from 32- to 64-bit sizes to get the
        // minimum guaranteed size for all the 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUSA)
                              / sizeof(ENUM_SERVICE_STATUS_WOW64);

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
EnumServicesStatusExA(
    IN      SC_HANDLE                  hSCManager,
    IN      SC_ENUM_TYPE               InfoLevel,
    IN      DWORD                      dwServiceType,
    IN      DWORD                      dwServiceState,
    OUT     LPBYTE                     lpServices,
    IN      DWORD                      cbBufSize,
    OUT     LPDWORD                    pcbBytesNeeded,
    OUT     LPDWORD                    lpServicesReturned,
    IN OUT  LPDWORD                    lpResumeIndex,
    IN      LPCTSTR                    pszGroupName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    DWORD                           status;
    LPENUM_SERVICE_STATUS_PROCESSA  pEnumBuf;
    ENUM_SERVICE_STATUS_PROCESSA    enumBuf;
    DWORD                           tempBufSize;

#ifdef _WIN64

    DWORD                           dwOldResumeIndex = 0;

    if (lpResumeIndex != NULL)
    {
        dwOldResumeIndex = *lpResumeIndex;
    }

#endif // _WIN64


    //
    // Make sure we were passed a valid InfoLevel
    //
    if (InfoLevel != SC_ENUM_PROCESS_INFO)
    {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUS_PROCESSA) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUS_PROCESSA);
    }
    else {
        pEnumBuf = (LPENUM_SERVICE_STATUS_PROCESSA) lpServices;
    }

    RpcTryExcept {

        status = REnumServicesStatusExA (
                    (SC_RPC_HANDLE)hSCManager,
                    InfoLevel,
                    dwServiceType,
                    dwServiceState,
                    (LPBYTE)pEnumBuf,
                    tempBufSize,
                    pcbBytesNeeded,
                    lpServicesReturned,
                    lpResumeIndex,
                    pszGroupName);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_PROCESS_A,
                                    hSCManager,
                                    dwServiceType,
                                    dwServiceState,
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    &dwOldResumeIndex,
                                    (LPVOID) pszGroupName,
                                    &dwError))
            {
                status = dwError;

                if (lpResumeIndex != NULL)
                {
                    *lpResumeIndex = dwOldResumeIndex;
                }
            }

#else  // ndef _WIN64

            ScConvertOffsetsExA((LPENUM_SERVICE_STATUS_PROCESSA) lpServices,
                                *lpServicesReturned);

#endif // _WIN64

        }

#ifdef _WIN64

        //
        // The byte count returned is the size needed to hold all of
        // the 32-bit structures rather than the 64-bit ones.  Assume
        // a buffer full of fixed-length structures (i.e., no variable-
        // length data) and scale from 32- to 64-bit sizes to get the
        // minimum guaranteed size for all the 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUS_PROCESSA)
                              / sizeof(ENUM_SERVICE_STATUS_PROCESS_WOW64);

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
QueryServiceObjectSecurity(
    IN  SC_HANDLE hService,
    IN  SECURITY_INFORMATION dwSecurityInformation,
    OUT PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    IN  DWORD cbBufSize,
    OUT LPDWORD pcbBytesNeeded
    )
/*++

Routine Description:

    This is the DLL entrypoint for the QueryServiceObjectSecurity API.

    This function returns to the caller requested security information
    currently assigned to an object.

    Based on the caller's access rights this procedure
    will return a security descriptor containing any or all of the
    object's owner ID, group ID, discretionary ACL or system ACL.  To
    read the owner ID, group ID, or the discretionary ACL the caller
    must be granted READ_CONTROL access to the object.  To read the
    system ACL the caller must be granted ACCESS_SYSTEM_SECURITY
    access.

Arguments:

    hService - Supplies a handle to an existing service object.

    dwSecurityInformation - Supplies a value describing which pieces of
        security information are being queried.

    lpSecurityInformation - Supplies the output buffer from the user
        which security descriptor information will be written to on
        return.

    cbBufSize - Supplies the size of lpSecurityInformation buffer.

    pcbBytesNeeded - Returns the number of bytes needed of the
        lpSecurityInformation buffer to get all the requested
        information.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened for
        either READ_CONTROL or ACCESS_SYSTEM_SECURITY
        access.

    ERROR_INVALID_PARAMETER - The dwSecurityInformation parameter is
        invalid.

    ERROR_INSUFFICIENT_BUFFER - The specified output buffer is smaller
        than the required size returned in pcbBytesNeeded.  None of
        the security descriptor is returned.

--*/
{
    DWORD status;

    RpcTryExcept {

        status = RQueryServiceObjectSecurity(
                     (SC_RPC_HANDLE) hService,
                     (DWORD) dwSecurityInformation,
                     (LPBYTE) lpSecurityDescriptor,
                     cbBufSize,
                     pcbBytesNeeded
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
SetServiceObjectSecurity(
    IN SC_HANDLE hService,
    IN SECURITY_INFORMATION dwSecurityInformation,
    IN PSECURITY_DESCRIPTOR lpSecurityDescriptor
    )
/*++

Routine Description:

    This is the DLL entrypoint for the SetServiceObjectSecurity API.

    This function takes a well-formed Security Descriptor provided by the
    caller and assigns specified portions of it to an existing service
    object.  Based on the flags set in the SecurityInformation
    parameter and the caller's access rights, this procedure will
    replace any or all of the security information associated with an
    object.

    This is the only function available to users and applications for
    changing security information, including the owner ID, group ID, and
    the discretionary and system ACLs of an object.  The caller must
    have WRITE_OWNER access to the object to change the owner or primary
    group of the object.  The caller must have WRITE_DAC access to the
    object to change the discretionary ACL.  The caller must have
    ACCESS_SYSTEM_SECURITY access to an object to assign a system ACL
    to the object.

Parameters:

    hService - Supplies a handle to an existing service object.

    dwSecurityInformation - Supplies a value describing which pieces of
        security information are being set.

    lpSecurityInformation - Supplies a pointer to a well-formed security
        descriptor.


Return Values:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened for
        either WRITE_OWNER, WRITE_DAC, or ACCESS_SYSTEM_SECURITY
        access.

    ERROR_INVALID_PARAMETER - The lpSecurityDescriptor or dwSecurityInformation
        parameter is invalid.

    ERROR_NOT_ENOUGH_MEMORY - Not enough memory to complete the API call.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    DWORD UserSdSize = 0;
    PSECURITY_DESCRIPTOR SelfRelativeSd;


    //
    // Find out the length of the user supplied security descriptor
    //
    ntstatus = RtlMakeSelfRelativeSD(
                   lpSecurityDescriptor,
                   NULL,
                   &UserSdSize
                   );

    if (ntstatus != STATUS_BUFFER_TOO_SMALL) {

        //
        // lpSecurityDescriptor is invalid
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    SelfRelativeSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_ZEROINIT, (UINT) UserSdSize);

    if (SelfRelativeSd == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Make a self-relative security descriptor for the RPC call
    //
    ntstatus = RtlMakeSelfRelativeSD(
                   lpSecurityDescriptor,
                   SelfRelativeSd,
                   &UserSdSize
                   );

    if (! NT_SUCCESS(ntstatus)) {
        LocalFree(SelfRelativeSd);
        SetLastError(RtlNtStatusToDosError(ntstatus));
        return(FALSE);
    }


    //
    // Call the server
    //
    RpcTryExcept {

        status = RSetServiceObjectSecurity(
                     (SC_RPC_HANDLE) hService,
                     (DWORD) dwSecurityInformation,
                     (LPBYTE) SelfRelativeSd,
                     UserSdSize
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    (void) LocalFree(SelfRelativeSd);

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


VOID
ScConvertOffsetsW(
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   NumStructs
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPBYTE  pBuffer;
    DWORD   i;

    pBuffer = (LPBYTE)lpServices;

    for (i=0; i<NumStructs; i++ ) {
        lpServices[i].lpServiceName = (LPWSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpServiceName));
        lpServices[i].lpDisplayName = (LPWSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpDisplayName));
    }
}

VOID
ScConvertOffsetsA(
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   NumStructs
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPBYTE  pBuffer;
    DWORD   i;

    pBuffer = (LPBYTE)lpServices;

    for (i=0; i<NumStructs; i++ ) {
        lpServices[i].lpServiceName = (LPSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpServiceName));
        lpServices[i].lpDisplayName = (LPSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpDisplayName));
    }
}

VOID
ScConvertOffsetsExW(
    LPENUM_SERVICE_STATUS_PROCESSW  lpServices,
    DWORD                      NumStructs
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPBYTE  pBuffer;
    DWORD   i;

    pBuffer = (LPBYTE)lpServices;

    for (i=0; i<NumStructs; i++ ) {
        lpServices[i].lpServiceName = (LPWSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpServiceName));
        lpServices[i].lpDisplayName = (LPWSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpDisplayName));
    }
}

VOID
ScConvertOffsetsExA(
    LPENUM_SERVICE_STATUS_PROCESSA  lpServices,
    DWORD                      NumStructs
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPBYTE  pBuffer;
    DWORD   i;

    pBuffer = (LPBYTE)lpServices;

    for (i=0; i<NumStructs; i++ ) {
        lpServices[i].lpServiceName = (LPSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpServiceName));
        lpServices[i].lpDisplayName = (LPSTR)(pBuffer +
                                      (DWORD)(ULONG_PTR)(lpServices[i].lpDisplayName));
    }
}


#ifdef _WIN64

BOOL
ScConvertOffsets64(
    SC_API_NUMBER  scApi,
    SC_HANDLE      hSCManager,
    DWORD          dwServiceType,
    DWORD          dwServiceState,
    LPBYTE         lpServices,
    DWORD          cbBufSize,
    LPDWORD        pcbBytesNeeded,
    LPDWORD        lpServicesReturned,
    LPDWORD        lpResumeIndex,
    LPVOID         pszGroupName,
    LPDWORD        lpdwError
    )
/*++

Routine Description:

    Perform API-specific offset-to-pointer conversions for the
    client side of the SCM APIs on 64-bit clients.

Arguments:



Return Value:

    TRUE if the conversion succeeded, FALSE otherwise (with lpdwError
    holding the true error).

--*/
{
    switch (scApi)
    {
        case SC_API_ENUM_W:
        case SC_API_ENUM_A:
        case SC_API_ENUM_GROUP:
        case SC_API_ENUM_PROCESS_W:
        case SC_API_ENUM_PROCESS_A:
        case SC_API_ENUM_DEPEND_W:
        case SC_API_ENUM_DEPEND_A:
        {
            //
            // Convert buffer returned by EnumServicesStatusW
            //

            LPBYTE  lpIter = lpServices;
            LPBYTE  lpConverted;
            DWORD   dwCount64;
            DWORD   dwTotalVarData = 0;
            DWORD   dwSize64 = 0;
            DWORD   dwStatusSize;
            DWORD   dwStrucSize64;
            DWORD   dwStrucSizeWOW;

            if (scApi == SC_API_ENUM_PROCESS_W || scApi == SC_API_ENUM_PROCESS_A)
            {
                dwStrucSize64  = sizeof(ENUM_SERVICE_STATUS_PROCESSW);
                dwStrucSizeWOW = sizeof(ENUM_SERVICE_STATUS_PROCESS_WOW64);
                dwStatusSize   = sizeof(SERVICE_STATUS_PROCESS);
            }
            else
            {
                dwStrucSize64  = sizeof(ENUM_SERVICE_STATUSW);
                dwStrucSizeWOW = sizeof(ENUM_SERVICE_STATUS_WOW64);
                dwStatusSize   = sizeof(SERVICE_STATUS);
            }

            for (dwCount64 = 0;
                 dwCount64 < *lpServicesReturned;
                 dwCount64++, lpIter += dwStrucSizeWOW)
            {
                DWORD  dwCurrentVarData;
                DWORD  dwOffset;

                //
                // Compute size of this record's variable-length data
                //

                dwOffset = ((LPENUM_SERVICE_STATUS_WOW64) lpIter)->dwDisplayNameOffset;

                dwCurrentVarData = cbBufSize - dwOffset - dwTotalVarData;


                //
                // Is there room to expand the current record to 64-bit pointers?
                //

                if (dwSize64 + dwStrucSize64 + dwCurrentVarData > cbBufSize)
                {
                    //
                    // Nope.
                    //

                    break;
                }

                //
                // Update the total number of variable-length data bytes
                // in the post-conversion buffer
                //

                dwTotalVarData += dwCurrentVarData;

                dwSize64 += dwStrucSize64 + dwCurrentVarData;
            }


            //
            // Set up the pointer to the last soon-to-be-converted structure.
            // Cast to INT to sign-extend the offset to 64 bits (required
            // when (dwCount64 == 0) or else the sum gets bizarre).
            //


            lpIter      = lpServices + (INT) (dwStrucSizeWOW * (dwCount64 - 1));
            lpConverted = lpServices + (INT) (dwStrucSize64 * (dwCount64 - 1));


            for ( ;
                  lpIter >= lpServices;
                  lpIter -= dwStrucSizeWOW, lpConverted -= dwStrucSize64)
            {
                LPENUM_SERVICE_STATUSW      lpEnum = (LPENUM_SERVICE_STATUSW) lpConverted;
                LPENUM_SERVICE_STATUS_WOW64 lpEnumWOW = (LPENUM_SERVICE_STATUS_WOW64) lpIter;

                //
                // Copy fields individually in reverse order in case there's overlap
                //

                RtlMoveMemory(&lpEnum->ServiceStatus,
                              &lpEnumWOW->ServiceStatus,
                              dwStatusSize);

                //
                // Do the offset-to-pointer conversion.  Can do straight addition
                // since we didn't move the variable length data.
                //

                lpEnum->lpDisplayName = (LPWSTR) (lpServices + lpEnumWOW->dwDisplayNameOffset);
                lpEnum->lpServiceName = (LPWSTR) (lpServices + lpEnumWOW->dwServiceNameOffset);
            }

            ASSERT(lpIter < lpServices && lpConverted < lpServices);

            if (*lpServicesReturned != dwCount64)
            {
                //
                // Not enough room to fit all the records returned.  Update
                // all the OUT parameters.  Add on the size of the overwritten
                // records' variable-length data first.
                //

                *pcbBytesNeeded += (cbBufSize
                                     - dwTotalVarData
                                     - *lpServicesReturned * dwStrucSizeWOW);

                //
                // And now do the fixed-length data.  Use the 32-bit structures
                // and the caller will multiply it up to 64-bit lengths.
                //

                *pcbBytesNeeded += (*lpServicesReturned - dwCount64)
                                       * dwStrucSizeWOW;

                //
                // Update the count of services returned
                //

                *lpServicesReturned = dwCount64;

                if (scApi == SC_API_ENUM_DEPEND_W || scApi == SC_API_ENUM_DEPEND_A)
                {
                    *lpdwError = ERROR_MORE_DATA;
                    return FALSE;
                }


                //
                // And now things get ugly.  We need to update the resume index
                // since we removed some services from the buffer.  However,
                // there's no easy way to get the resume index of a particular
                // service from the server side.  So we have to build up an
                // enum buffer that's just small enough to hold only the records
                // we're going to return and enum again just to get the RI.
                //

                LPBYTE  lpTemp;
                DWORD   status;
                DWORD   dwTempBytes;
                DWORD   dwTempCount;
                DWORD   dwTempSize = dwCount64 * dwStrucSizeWOW + dwTotalVarData;

                lpTemp = (LPBYTE) LocalAlloc(LMEM_FIXED, dwTempSize);

                if (lpTemp == NULL)
                {
                    *lpdwError = ERROR_NOT_ENOUGH_MEMORY;
                    return FALSE;
                }

                RpcTryExcept
                {
                    switch (scApi)
                    {
                        case SC_API_ENUM_W:

                            status = REnumServicesStatusW (
                                        (SC_RPC_HANDLE) hSCManager,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex);

                             break;

                        case SC_API_ENUM_A:

                            status = REnumServicesStatusA (
                                        (SC_RPC_HANDLE) hSCManager,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex);

                             break;

                        case SC_API_ENUM_GROUP:

                            status = REnumServiceGroupW (
                                        (SC_RPC_HANDLE) hSCManager,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex,
                                        (LPCWSTR) pszGroupName);

                            break;

                        case SC_API_ENUM_PROCESS_W:

                            status = REnumServicesStatusExW (
                                        hSCManager,
                                        SC_ENUM_PROCESS_INFO,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex,
                                        (LPCWSTR) pszGroupName);

                             break;

                        case SC_API_ENUM_PROCESS_A:

                            status = REnumServicesStatusExA (
                                        hSCManager,
                                        SC_ENUM_PROCESS_INFO,
                                        dwServiceType,
                                        dwServiceState,
                                        (LPBYTE) lpTemp,
                                        dwTempSize,
                                        &dwTempBytes,
                                        &dwTempCount,
                                        lpResumeIndex,
                                        (LPCSTR) pszGroupName);

                             break;

                        default:

                            ASSERT(FALSE && "Unsupported API in ScConvertOffsets64 enum path");
                            status = ERROR_NOT_SUPPORTED;
                    }
                }
                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                {
                    status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
                }
                RpcEndExcept

                LocalFree(lpTemp);

                //
                // We had to overwrite at least one structure so we need
                // to return some form of error, even if it's ERROR_MORE_DATA.
                //

                *lpdwError = status;
                return FALSE;
            }

            return TRUE;
            break;
        }

        case SC_API_QUERY_DESCRIPTION_W:
        case SC_API_QUERY_DESCRIPTION_A:
        {
            DWORD  dwBytesNeeded = *pcbBytesNeeded;
            DWORD  dwSizeDiff    = sizeof(SERVICE_DESCRIPTIONW) - sizeof(SERVICE_DESCRIPTION_WOW64);

            LPSERVICE_DESCRIPTION_WOW64  psdWOW = (LPSERVICE_DESCRIPTION_WOW64) lpServices;
            LPSERVICE_DESCRIPTIONW       psd    = (LPSERVICE_DESCRIPTIONW) lpServices;

            //
            // *pcbBytesNeeded is filled in on success or "buffer too small"
            // failure, so update it with the 64-bit size.
            //

            *pcbBytesNeeded += dwSizeDiff;

            if (*pcbBytesNeeded > cbBufSize)
            {
                return FALSE;
            }

            //
            // We have room -- move the variable-length data
            //

            RtlMoveMemory(psd + 1,
                          psdWOW + 1,
                          dwBytesNeeded - sizeof(SERVICE_DESCRIPTION_WOW64));

            //
            // Resize the offset from 4 to 8 bytes.
            //

            if (psdWOW->dwDescriptionOffset == 0)
            {
                psd->lpDescription = NULL;
            }
            else
            {
                psd->lpDescription = (LPWSTR) UlongToPtr(psdWOW->dwDescriptionOffset + dwSizeDiff);
            }

            return TRUE;
        }

        case SC_API_QUERY_FAILURE_ACTIONS_W:                          
        case SC_API_QUERY_FAILURE_ACTIONS_A:
        {
            DWORD dwBytesNeeded = *pcbBytesNeeded;
            DWORD dwSizeDiff    = sizeof(SERVICE_FAILURE_ACTIONSW) - sizeof(SERVICE_FAILURE_ACTIONS_WOW64);

            LPSERVICE_FAILURE_ACTIONS_WOW64 psfaWOW = (LPSERVICE_FAILURE_ACTIONS_WOW64) lpServices;
            LPSERVICE_FAILURE_ACTIONSW      psfa    = (LPSERVICE_FAILURE_ACTIONSW) lpServices;

            //
            // *pcbBytesNeeded is filled in on success or "buffer too small"
            // failure, so update it with the 64-bit size.
            //

            *pcbBytesNeeded += dwSizeDiff;

            if (*pcbBytesNeeded > cbBufSize)
            {
                return FALSE;
            }

            //
            // We have room -- move the variable-length data
            //

            RtlMoveMemory(psfa + 1,
                          psfaWOW + 1,
                          dwBytesNeeded - sizeof(SERVICE_FAILURE_ACTIONS_WOW64));

            //
            // Resize the offsets from 4 to 8 bytes.  Do this in reverse field order
            // to avoid trampling over any still-to-be-converted offsets.
            //

            if (psfaWOW->dwsaActionsOffset == 0)
            {
                psfa->lpsaActions = NULL;
            }
            else
            {
                psfa->lpsaActions = (SC_ACTION *) UlongToPtr(psfaWOW->dwsaActionsOffset + dwSizeDiff);
            }

            psfa->cActions = psfaWOW->cActions;

            if (psfaWOW->dwCommandOffset == 0)
            {
                psfa->lpCommand = NULL;
            }
            else
            {
                psfa->lpCommand = (LPWSTR) UlongToPtr(psfaWOW->dwCommandOffset + dwSizeDiff);
            }

            if (psfaWOW->dwRebootMsgOffset == 0)
            {
                psfa->lpRebootMsg = NULL;
            }
            else
            {
                psfa->lpRebootMsg = (LPWSTR) UlongToPtr(psfaWOW->dwRebootMsgOffset + dwSizeDiff);
            }

            psfa->dwResetPeriod = psfaWOW->dwResetPeriod;

            return TRUE;
        }

        default:
            ASSERT(FALSE && "Unsupported API passed to ScConvertOffsets64");
            *lpdwError = ERROR_NOT_SUPPORTED;
            return FALSE;
    }
}

#endif  // _WIN64    


BOOL
WINAPI
ChangeServiceConfigA(
    IN  SC_HANDLE    hService,
    IN  DWORD        dwServiceType,
    IN  DWORD        dwStartType,
    IN  DWORD        dwErrorControl,
    IN  LPCSTR       lpBinaryPathName,
    IN  LPCSTR       lpLoadOrderGroup,
    OUT LPDWORD      lpdwTagId,
    IN  LPCSTR       lpDependencies,
    IN  LPCSTR       lpServiceStartName,
    IN  LPCSTR       lpPassword,
    IN  LPCSTR       lpDisplayName
    )

/*++

Routine Description:

    This is the DLL entry point for the ChangeServiceConfig function.
    ChangeServiceConfig changes the service configuration kept in the
    Service Control Manager database.  This configuration information
    was first set in the database via the CreateService API, and can
    be queried (exept for the password parameter) using the
    QueryServiceConfig API.

Arguments:

    hService - Handle obtained from a previous OpenService call.

    dwServiceType - Value to indicate the type of service this is.

    dwStartType - Value to specify when to start the service.

    dwErrorControl - Value to specify the severity of the error if this
        service fails to start during boot so that the appropriate action
        can be taken.

    lpBinaryPathName - Fully-qualified path name to the service binary file.

    lpLoadOrderGroup - Name of the load ordering group which this service
        is a member of.  Groups of services are started based on the group
        order list specified in the registry at
        HKEY_LOCAL_SYSTEM\Control\Service_Group_Order.

    lpdwTagId - On output this pointer receives a unique tag identification
        number within the group.  If this parameter is specified (non-NULL)
        but lpLoadOrderGroup is not specified, ERROR_INVALID_PARAMETER
        will be returned.

    lpDependencies - NULL-separated names of services which must be
        running before this service can run.  An empty string means that
        this service has no dependencies.

    lpServiceStartName - If service type is SERVICE_WIN32, this name is
        the account name in the form of "DomainName\Username" which the
        service process will be logged on as when it runs.  If service
        type is SERVICE_DRIVER, this name must be the NT driver object
        name (e.g. \FileSystem\LanManRedirector or \Driver\Xns) which
        the I/O system uses to load the device driver.

    lpPassword - Password to the account name specified by
        lpServiceStartName if service type is SERVICE_WIN32.  This
        password will be changed periodically by the Service Control
        Manager so that it will not expire. If service type is
        SERVICE_DRIVER, this parameter is ignored.

    lpDisplayName - This is the internationalized name that is used for
        display purposes only.


Return Value:


Note:


--*/
{
    DWORD          status;

    LPWSTR lpPasswordW;
    LPBYTE EncryptedPassword = NULL;
    DWORD PasswordSize = 0;

    LPSTR Ptr;
    LPWSTR DependBuffer = NULL;
    DWORD DependSize = 0;


    RpcTryExcept {

        //
        // Create a unicode version of lpPassword, and then encrypt it.
        //
        if (ARGUMENT_PRESENT(lpPassword)) {

            if (! ScConvertToUnicode(&lpPasswordW, lpPassword)) {
                SCC_LOG0(ERROR,"ChangeServiceConfigA: convert password to Unicode failed\n");
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(FALSE);
            }

            status = ScEncryptPassword(
                         (SC_RPC_HANDLE)hService,
                         lpPasswordW,
                         &EncryptedPassword,
                         &PasswordSize
                         );

            (void) LocalFree(lpPasswordW);

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"ChangeServiceConfigA: ScEncryptPassword failed\n");
                SetLastError(status);
                return(FALSE);
            }
        }

        if (ARGUMENT_PRESENT(lpDependencies)) {

            DependSize = ScAStrArraySize((LPSTR) lpDependencies) / sizeof(CHAR) * sizeof(WCHAR);

            if ((DependBuffer = (LPWSTR)LocalAlloc(
                                            LMEM_ZEROINIT,
                                            (UINT) DependSize)) == NULL) {
                SCC_LOG1(ERROR,
                         "ChangeServiceConfigA: LocalAlloc of DependBuffer failed "
                         FORMAT_DWORD "\n", GetLastError());
                status = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (DependSize > sizeof(WCHAR)) {

                //
                // There is at least one dependency entry.
                //

                Ptr = (LPSTR) lpDependencies;

                //
                // Convert each dependency into Unicode, and append it to the
                // DependBuffer.
                //
                while (*Ptr != 0) {

                    LPWSTR ConvertedDependency = NULL;


                    if (! ScConvertToUnicode(&ConvertedDependency, Ptr)) {
                        SCC_LOG0(ERROR,
                                 "ChangeServiceConfigA: convert dependency to Unicode failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        goto CleanExit;
                    }

                    ScAddWStrToWStrArray(DependBuffer, ConvertedDependency);

                    (void) LocalFree(ConvertedDependency);

                    Ptr = ScNextAStrArrayEntry(Ptr);
                }
            }
        }

        status = RChangeServiceConfigA(
                    (SC_RPC_HANDLE)hService,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    (LPSTR) lpBinaryPathName,
                    (LPSTR) lpLoadOrderGroup,
                    lpdwTagId,
                    (LPBYTE) DependBuffer,
                    DependSize,
                    (LPSTR) lpServiceStartName,
                    EncryptedPassword,
                    PasswordSize,
                    (LPSTR)lpDisplayName);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

CleanExit:

    if (EncryptedPassword != NULL) {
        (void) LocalFree(EncryptedPassword);
    }

    if (DependBuffer != NULL) {
        (void) LocalFree(DependBuffer);
    }

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
WINAPI
ChangeServiceConfigW(
    IN  SC_HANDLE    hService,
    IN  DWORD        dwServiceType,
    IN  DWORD        dwStartType,
    IN  DWORD        dwErrorControl,
    IN  LPCWSTR      lpBinaryPathName,
    IN  LPCWSTR      lpLoadOrderGroup,
    OUT LPDWORD      lpdwTagId,
    IN  LPCWSTR      lpDependencies,
    IN  LPCWSTR      lpServiceStartName,
    IN  LPCWSTR      lpPassword,
    IN  LPCWSTR      lpDisplayName
    )

/*++

Routine Description:

    see ChangeServiceConfigA

Arguments:


Return Value:


Note:


--*/
{
    DWORD          status;

    LPBYTE EncryptedPassword = NULL;
    DWORD PasswordSize = 0;

    DWORD DependSize = 0;


    RpcTryExcept {

        //
        // Create a unicode version of lpPassword, and then encrypt it.
        //
        if (ARGUMENT_PRESENT(lpPassword)) {

            status = ScEncryptPassword(
                         (SC_RPC_HANDLE)hService,
                         (LPWSTR) lpPassword,
                         &EncryptedPassword,
                         &PasswordSize
                         );

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"ChangeServiceConfigW: ScEncryptPassword failed\n");
                SetLastError(status);
                return(FALSE);
            }
        }

        if (ARGUMENT_PRESENT(lpDependencies)) {
            DependSize = ScWStrArraySize((LPWSTR) lpDependencies);
        }

        status = RChangeServiceConfigW(
                    (SC_RPC_HANDLE)hService,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    (LPWSTR) lpBinaryPathName,
                    (LPWSTR) lpLoadOrderGroup,
                    lpdwTagId,
                    (LPBYTE) lpDependencies,
                    DependSize,
                    (LPWSTR) lpServiceStartName,
                    EncryptedPassword,
                    PasswordSize,
                    (LPWSTR)lpDisplayName);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (EncryptedPassword != NULL) {
        (void) LocalFree(EncryptedPassword);
    }
    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
WINAPI
ChangeServiceConfig2A(
    IN  SC_HANDLE    hService,
    IN  DWORD        dwInfoLevel,
    IN  LPVOID       lpInfo
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

--*/
{
    DWORD status;

    // Transform the parameters into a union that RPC likes
    SC_RPC_CONFIG_INFOA RpcInfo = { dwInfoLevel,
                                    (LPSERVICE_DESCRIPTIONA) lpInfo };

    RpcTryExcept
    {
        status = RChangeServiceConfig2A(
                        (SC_RPC_HANDLE) hService,
                        RpcInfo
                        );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status == RPC_S_INVALID_TAG)
    {
        status = ERROR_INVALID_LEVEL;
    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
ChangeServiceConfig2W(
    IN  SC_HANDLE    hService,
    IN  DWORD        dwInfoLevel,
    IN  LPVOID       lpInfo
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

--*/
{
    DWORD status;

    // Transform the parameters into a union that RPC likes
    SC_RPC_CONFIG_INFOW RpcInfo = { dwInfoLevel,
                                    (LPSERVICE_DESCRIPTIONW) lpInfo };

    RpcTryExcept
    {
        status = RChangeServiceConfig2W(
                        (SC_RPC_HANDLE) hService,
                        RpcInfo
                        );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status == RPC_S_INVALID_TAG)
    {
        status = ERROR_INVALID_LEVEL;
    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    return TRUE;
}

SC_HANDLE
WINAPI
CreateServiceA(
    IN  SC_HANDLE    hSCManager,
    IN  LPCSTR       lpServiceName,
    IN  LPCSTR       lpDisplayName,
    IN  DWORD        dwDesiredAccess,
    IN  DWORD        dwServiceType,
    IN  DWORD        dwStartType,
    IN  DWORD        dwErrorControl,
    IN  LPCSTR       lpBinaryPathName,
    IN  LPCSTR       lpLoadOrderGroup,
    OUT LPDWORD      lpdwTagId,
    IN  LPCSTR       lpDependencies,
    IN  LPCSTR       lpServiceStartName,
    IN  LPCSTR       lpPassword
    )

/*++

Routine Description:

    This function is the DLL entry point for the ansi version
    of CreateService.  On the server side, this function will create
    a service object and add it to the Service Control Manager database.

Arguments:

    hSCManager - Handle obtained from a previous OpenSCManager call.

    lpServiceName - Name of the service to install.

    lpDisplayName - This is the internationalized name that is used for
        display purposes only.

    dwDesiredAccess - Access types desired to access the service.

    dwServiceType - Value to indicate the type of service this is.

    dwStartType - Value to specify when to start the service.

    dwErrorControl - Value to specify the severity of the error if this
        service fails to start during boot so that the appropriate action
        can be taken.

    lpBinaryPathName - Fully-qualified path name to the service binary file.

    lpLoadOrderGroup - Name of the load ordering group which this service
        is a member of.  Groups of services are started based on the group
        order list specified in the registry at
        HKEY_LOCAL_SYSTEM\Control\Service_Group_Order.

    lpdwTagId - On output this pointer receives a unique tag identification
        number within the group.  If this parameter is specified (non-NULL)
        but lpLoadOrderGroup is not specified, ERROR_INVALID_PARAMETER
        will be returned.

    lpDependencies - Space-separated names of services which must be
        running before this service can run.  An empty string means that
        this service has no dependencies.

    lpServiceStartName - If service type is SERVICE_WIN32, this name is
        the account name in the form of "DomainName\Username" which the
        service process will be logged on as when it runs.  If service
        type is SERVICE_DRIVER, this name must be the NT driver object
        name (e.g. \FileSystem\LanManRedirector or \Driver\Xns) which
        the I/O system uses to load the device driver.

    lpPassword - Password to the account name specified by
        lpServiceStartName if service type is SERVICE_WIN32.  This
        password will be changed periodically by the Service Control
        Manager so that it will not expire. If service type is
        SERVICE_DRIVER, this parameter is ignored.

Return Value:


Note:


--*/
{
    DWORD           status;
    SC_RPC_HANDLE   hService=NULL;

    LPWSTR lpPasswordW;
    LPBYTE EncryptedPassword = NULL;
    DWORD PasswordSize = 0;

    LPSTR Ptr;
    LPWSTR DependBuffer = NULL;
    DWORD DependSize = 0;


    RpcTryExcept {

        //
        // Create a unicode version of lpPassword, and then encrypt it.
        //
        if (ARGUMENT_PRESENT(lpPassword)) {

            if (! ScConvertToUnicode(&lpPasswordW, lpPassword)) {
                SCC_LOG0(ERROR,"CreateServiceA: convert password to Unicode failed\n");
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(NULL);
            }

            status = ScEncryptPassword(
                         (SC_RPC_HANDLE)hSCManager,
                         lpPasswordW,
                         &EncryptedPassword,
                         &PasswordSize
                         );

            (void) LocalFree(lpPasswordW);

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"CreateServiceA: ScEncryptPassword failed\n");
                SetLastError(status);
                return(NULL);
            }
        }

        if (ARGUMENT_PRESENT(lpDependencies)) {

            DependSize = ScAStrArraySize((LPSTR) lpDependencies) / sizeof(CHAR) * sizeof(WCHAR);

            if ((DependBuffer = (LPWSTR)LocalAlloc(
                                            LMEM_ZEROINIT,
                                            (UINT) DependSize)) == NULL) {
                SCC_LOG1(ERROR,
                         "CreateServiceA: LocalAlloc of DependBuffer failed "
                         FORMAT_DWORD "\n", GetLastError());
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }

            if (DependSize > sizeof(WCHAR)) {

                //
                // There is at least one dependency entry.
                //

                Ptr = (LPSTR) lpDependencies;

                //
                // Convert each dependency into Unicode, and append it to the
                // DependBuffer.
                //
                while (*Ptr != 0) {

                    LPWSTR ConvertedDependency = NULL;


                    if (! ScConvertToUnicode(&ConvertedDependency, Ptr)) {
                        SCC_LOG0(ERROR,
                                 "CreateServiceA: convert dependency to Unicode failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        goto CleanExit;
                    }

                    ScAddWStrToWStrArray(DependBuffer, ConvertedDependency);

                    (void) LocalFree(ConvertedDependency);

                    Ptr = ScNextAStrArrayEntry(Ptr);
                }
            }
        }

        status = RCreateServiceA (
                    (SC_RPC_HANDLE)hSCManager,
                    (LPSTR) lpServiceName,
                    (LPSTR) lpDisplayName,
                    dwDesiredAccess,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    (LPSTR) lpBinaryPathName,
                    (LPSTR) lpLoadOrderGroup,
                    lpdwTagId,
                    (LPBYTE) DependBuffer,
                    DependSize,
                    (LPSTR) lpServiceStartName,
                    EncryptedPassword,
                    PasswordSize,
                    &hService);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

CleanExit:
    if (DependBuffer != NULL) {
        (void) LocalFree(DependBuffer);
    }

    if (EncryptedPassword != NULL) {
        (void) LocalFree(EncryptedPassword);
    }

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return (SC_HANDLE)hService;
}

SC_HANDLE
WINAPI
CreateServiceW(
    IN  SC_HANDLE    hSCManager,
    IN  LPCWSTR      lpServiceName,
    IN  LPCWSTR      lpDisplayName,
    IN  DWORD        dwDesiredAccess,
    IN  DWORD        dwServiceType,
    IN  DWORD        dwStartType,
    IN  DWORD        dwErrorControl,
    IN  LPCWSTR      lpBinaryPathName,
    IN  LPCWSTR      lpLoadOrderGroup,
    OUT LPDWORD      lpdwTagId,
    IN  LPCWSTR      lpDependencies,
    IN  LPCWSTR      lpServiceStartName,
    IN  LPCWSTR      lpPassword
    )

/*++

Routine Description:

    see CreateServiceA

Arguments:


Return Value:


Note:


--*/
{
    DWORD           status;
    SC_RPC_HANDLE   hService = NULL;

    LPBYTE EncryptedPassword = NULL;
    DWORD PasswordSize = 0;

    DWORD DependSize = 0;


    RpcTryExcept {

        if (ARGUMENT_PRESENT(lpPassword)) {

            status = ScEncryptPassword(
                         (SC_RPC_HANDLE)hSCManager,
                         (LPWSTR) lpPassword,
                         &EncryptedPassword,
                         &PasswordSize
                         );

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"CreateServiceW: ScEncryptPassword failed\n");
                SetLastError(status);
                return NULL;
            }
        }

        if (ARGUMENT_PRESENT(lpDependencies)) {
            DependSize = ScWStrArraySize((LPWSTR) lpDependencies);
        }

        status = RCreateServiceW (
                    (SC_RPC_HANDLE)hSCManager,
                    (LPWSTR) lpServiceName,
                    (LPWSTR) lpDisplayName,
                    dwDesiredAccess,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    (LPWSTR) lpBinaryPathName,
                    (LPWSTR) lpLoadOrderGroup,
                    lpdwTagId,
                    (LPBYTE) lpDependencies,
                    DependSize,
                    (LPWSTR) lpServiceStartName,
                    EncryptedPassword,
                    PasswordSize,
                    &hService);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (EncryptedPassword != NULL) {
        LocalFree(EncryptedPassword);
    }

    if (status != NO_ERROR){
        SetLastError(status);
        return NULL;
    }

    return (SC_HANDLE)hService;
}

BOOL
WINAPI
DeleteService(
    IN  SC_HANDLE   hService
    )

/*++

Routine Description:

    This is the DLL entry point for the DeleteService function.
    DeleteService removes the service from the Service Control
    Manager's database.

Arguments:

    hService - Handle obtained from a previous CreateService or
        OpenService call.

Return Value:


Note:


--*/
{
    DWORD          status;


    SCC_LOG1(TRACE,
             "---------DeleteService called (%ws)\n",
             GetCommandLineW());

    RpcTryExcept {

        status = RDeleteService ((SC_RPC_HANDLE)hService);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){

        SCC_LOG2(TRACE,
                 "---------DeleteService FAILED, %ld (%ws)\n",
                 status,
                 GetCommandLineW());

        SetLastError(status);
        return(FALSE);
    }

    SCC_LOG1(TRACE,
             "---------DeleteService SUCCESS (%ws)\n",
             GetCommandLineW());


    return TRUE;
}

BOOL
WINAPI
EnumDependentServicesA(
    IN      SC_HANDLE               hService,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSA  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned
    )


/*++

Routine Description:

    This function lists the services which depend on the specified
    service to be running before they can run.  The returned
    services entries are ordered in the reverse order of start
    dependencies with group order taken into account.  Services can
    be stopped in the proper order based on the order of entries
    written to the output buffer.

Arguments:

    hService - Handle obtained from a previous OpenService call.

    dwServiceState - Value to select the services to enumerate based on
        the running state.

    lpServices - A pointer to a buffer to receive an array of service
        entries; each entry is the ENUM_SERVICE_STATUS information
        structure.  The services returned in the buffer is ordered by
        the reverse dependency order.

    cbBufSize - Size of the buffer in bytes pointed to by lpServices.

    pcbBytesNeeded - A pointer to a variable to receive the number of
        bytes needed to fit the remaining service entries.

    lpServicesReturned - A pointer to a variable to receive the number
        of service entries returned.


Return Value:

    TRUE - if all Services are successfully written into the supplied
        output buffer.

    FALSE - If an error has occured - Use GetLastError to determine the
        cause of the failure.


--*/
{
    DWORD                   status;
    LPENUM_SERVICE_STATUSA  pEnumBuf;
    ENUM_SERVICE_STATUSA    enumBuf;
    DWORD                   tempBufSize;

    tempBufSize = cbBufSize;
    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUSA) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUSA);
    }
    else {
        pEnumBuf = lpServices;
    }


    RpcTryExcept {

        status = REnumDependentServicesA(
                    (SC_RPC_HANDLE)hService,
                    dwServiceState,
                    (LPBYTE)pEnumBuf,
                    tempBufSize,
                    pcbBytesNeeded,
                    lpServicesReturned);


    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //
    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_DEPEND_A,
                                    NULL,                  // no hSCManager
                                    0,                     // no service type
                                    0,                     // no service state
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    NULL,                  // no old resume index
                                    NULL,                  // no group name
                                    &dwError))
            {
                status = dwError;
            }
        }

        //
        // Scale required size up to the minimum size guaranteed to
        // succeed with 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUSA)
                              / sizeof(ENUM_SERVICE_STATUS_WOW64);


#else  // ndef _WIN64

            ScConvertOffsetsA(lpServices, *lpServicesReturned);
        }

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
EnumDependentServicesW(
    IN      SC_HANDLE               hService,
    IN      DWORD                   dwServiceState,
    OUT     LPENUM_SERVICE_STATUSW  lpServices,
    IN      DWORD                   cbBufSize,
    OUT     LPDWORD                 pcbBytesNeeded,
    OUT     LPDWORD                 lpServicesReturned
    )


/*++

Routine Description:

    This function lists the services which depend on the specified
    service to be running before they can run.  The returned
    services entries are ordered in the reverse order of start
    dependencies with group order taken into account.  Services can
    be stopped in the proper order based on the order of entries
    written to the output buffer.

Arguments:

    hService - Handle obtained from a previous OpenService call.

    dwServiceState - Value to select the services to enumerate based on
        the running state.

    lpServices - A pointer to a buffer to receive an array of service
        entries; each entry is the ENUM_SERVICE_STATUS information
        structure.  The services returned in the buffer is ordered by
        the reverse dependency order.

    cbBufSize - Size of the buffer in bytes pointed to by lpServices.

    pcbBytesNeeded - A pointer to a variable to receive the number of
        bytes needed to fit the remaining service entries.

    lpServicesReturned - A pointer to a variable to receive the number
        of service entries returned.


Return Value:

    TRUE - if all Services are successfully written into the supplied
        output buffer.

    FALSE - If an error has occured - Use GetLastError to determine the
        cause of the failure.


--*/
{
    DWORD                   status;
    LPENUM_SERVICE_STATUSW  pEnumBuf;
    ENUM_SERVICE_STATUSW    enumBuf;
    DWORD                   tempBufSize;

    tempBufSize = cbBufSize;
    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(ENUM_SERVICE_STATUSW) || (lpServices == NULL)) {
        pEnumBuf = &enumBuf;
        tempBufSize = sizeof(ENUM_SERVICE_STATUSW);
    }
    else {
        pEnumBuf = lpServices;
    }

    RpcTryExcept {

        status = REnumDependentServicesW(
                    (SC_RPC_HANDLE)hService,
                    dwServiceState,
                    (LPBYTE)pEnumBuf,
                    tempBufSize,
                    pcbBytesNeeded,
                    lpServicesReturned);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    //
    // If data is returned, convert Offsets in the Enum buffer to pointers.
    //

    if ((status == NO_ERROR) || (status == ERROR_MORE_DATA))
    {
        if ((*lpServicesReturned) > 0)
        {

#ifdef _WIN64

            DWORD dwError;

            if (!ScConvertOffsets64(SC_API_ENUM_DEPEND_W,
                                    NULL,                  // no hSCManager
                                    0,                     // no service type
                                    0,                     // no service state
                                    (LPBYTE) lpServices,
                                    cbBufSize,
                                    pcbBytesNeeded,
                                    lpServicesReturned,
                                    NULL,                  // no old resume index
                                    NULL,                  // no group name
                                    &dwError))
            {
                status = dwError;
            }
        }

        //
        // Scale required size up to the minimum size guaranteed to
        // succeed with 64-bit structures.
        //

        *pcbBytesNeeded = *pcbBytesNeeded
                              * sizeof(ENUM_SERVICE_STATUSA)
                              / sizeof(ENUM_SERVICE_STATUS_WOW64);

#else  // ndef _WIN64

            ScConvertOffsetsW(lpServices, *lpServicesReturned);
        }

#endif // _WIN64

    }

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
GetServiceDisplayNameA(
    SC_HANDLE       hSCManager,
    LPCSTR          lpServiceName,
    LPSTR           lpDisplayName,
    LPDWORD         lpcchBuffer
    )
/*++

Routine Description:

    This function returns the display name for a service that is identified
    by its key name (ServiceName).

Arguments:

    hSCManager - This is the handle to the Service Controller Manager that
        is expected to return the display name.

    lpServiceName -  This is the ServiceName (which is actually a key
        name) that identifies the service.

    lpDisplayName - This is a pointer to a buffer that is to receive the
        DisplayName string.

    lpcchBuffer - This is a pointer to the size (in characters) of the
        buffer that is to receive the DisplayName string.  If the buffer
        is not large enough to receive the entire string, then the required
        buffer size is returned in this location.  (NOTE:  Ansi Characters,
        including DBCS, are assumed to be 8 bits).

Return Value:



--*/
{
    DWORD   status;
    LPSTR   bufPtr;
    CHAR    tempString[] = "";

    //
    // Create a dummy buffer that is at least the size of a CHAR.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    RpcTryExcept {

        if ((*lpcchBuffer < sizeof(CHAR)) || (lpDisplayName == NULL)){
            bufPtr = tempString;
            *lpcchBuffer = sizeof(CHAR);
        }
        else {
            bufPtr = (LPSTR)lpDisplayName;
        }

        status = RGetServiceDisplayNameA(
                    (SC_RPC_HANDLE)hSCManager,
                    (LPSTR)lpServiceName,
                    bufPtr,
                    lpcchBuffer);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }
    return(TRUE);
}

BOOL
WINAPI
GetServiceDisplayNameW(
    SC_HANDLE       hSCManager,
    LPCWSTR         lpServiceName,
    LPWSTR          lpDisplayName,
    LPDWORD         lpcchBuffer
    )


/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD   status;
    LPWSTR  bufPtr;
    WCHAR   tempString[]=L"";

    //
    // Create a dummy buffer that is at least the size of a WCHAR.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    RpcTryExcept {

        if ((*lpcchBuffer < sizeof(WCHAR)) || (lpDisplayName == NULL)) {
            bufPtr = tempString;
            *lpcchBuffer = sizeof(WCHAR);
        }
        else {
            bufPtr = (LPWSTR)lpDisplayName;
        }

        status = RGetServiceDisplayNameW(
                    (SC_RPC_HANDLE)hSCManager,
                    (LPWSTR)lpServiceName,
                    bufPtr,
                    lpcchBuffer);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }
    return(TRUE);
}

BOOL
WINAPI
GetServiceKeyNameA(
    SC_HANDLE   hSCManager,
    LPCSTR      lpDisplayName,
    LPSTR       lpServiceName,
    LPDWORD     lpcchBuffer
    )

/*++

Routine Description:



Arguments:

    hSCManager - This is the handle to the Service Controller Manager that
        is expected to return the service name (key name).

    lpServiceName -  This is the Service Display Name that identifies
        the service.

    lpServiceName - This is a pointer to a buffer that is to receive the
        Service Key Name string.

    lpcchBuffer - This is a pointer to the size of the buffer that is
        to receive the Service Key Name string.  If the buffer is not large
        enough to receive the entire string, then the required buffer size
        is returned in this location.


Return Value:



--*/
{
    DWORD   status;
    LPSTR   bufPtr;
    CHAR    tempString[]="";

    //
    // Create a dummy buffer that is at least the size of a CHAR.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    RpcTryExcept {

        if ((*lpcchBuffer < sizeof(CHAR)) || (lpServiceName == NULL)) {
            bufPtr = tempString;
            *lpcchBuffer = sizeof(CHAR);
        }
        else {
            bufPtr = (LPSTR)lpServiceName;
        }

        status = RGetServiceKeyNameA(
                    (SC_RPC_HANDLE)hSCManager,
                    (LPSTR)lpDisplayName,
                    bufPtr,
                    lpcchBuffer);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }
    return(TRUE);
}

BOOL
WINAPI
GetServiceKeyNameW(
    SC_HANDLE   hSCManager,
    LPCWSTR     lpDisplayName,
    LPWSTR      lpServiceName,
    LPDWORD     lpcchBuffer
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD   status = NO_ERROR;
    LPWSTR  bufPtr;
    WCHAR   tempString[]=L"";

    //
    // Create a dummy buffer that is at least the size of a WCHAR.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    RpcTryExcept {

        if ((*lpcchBuffer < sizeof(WCHAR)) || (lpServiceName == NULL)) {
            bufPtr = tempString;
            *lpcchBuffer = sizeof(WCHAR);
        }
        else {
            bufPtr = (LPWSTR)lpServiceName;
        }

        status = RGetServiceKeyNameW(
                    (SC_RPC_HANDLE)hSCManager,
                    (LPWSTR)lpDisplayName,
                    bufPtr,
                    lpcchBuffer);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
        return(FALSE);
    }
    return(TRUE);
}


SC_LOCK
WINAPI
LockServiceDatabase(
    IN  SC_HANDLE   hSCManager
    )

/*++

Routine Description:

    This is the DLL entry point for the LockServiceDatabase function.
    This function acquires a lock on the database that was opened from
    a previous OpenSCManager call.  There can only be one lock
    outstanding on a database for a given time.

Arguments:

    hSCManager - Handle obtained from a previous OpenSCManager call
        which specifies the database to lock.

Return Value:



--*/
{
    DWORD           status;
    SC_RPC_LOCK     lock = NULL;


    RpcTryExcept {

        status = RLockServiceDatabase(
                    (SC_RPC_HANDLE)hSCManager,
                    &lock);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(NULL);
    }

    return((SC_LOCK)lock);
}


BOOL
WINAPI
QueryServiceConfigA(
    IN  SC_HANDLE               hService,
    OUT LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    IN  DWORD                   cbBufSize,
    OUT LPDWORD                 pcbBytesNeeded
    )

/*++

Routine Description:

    This is the DLL entry point for the QueryServiceConfig function.
    QueryServiceConfig obtains the service configuration information
    stored in the Service Control Manager database.  This configuration
    information was first set in the database via the CreateService API,
    and may have been updated via the ChangeServiceConfig API.

Arguments:

    hService - Handle obtained from a previous CreateService or
        OpenService call.

    lpServiceConfig - A pointer to a buffer to receive a
        QUERY_SERVICE_CONFIG information structure.

    cbBufSize - Size of the buffer in bytes pointed to by lpServiceConfig.

    pcbBytesNeeded - A pointer to a variable to receive the number of
        bytes needed to fit the entire QUERY_SERVICE_CONFIG information
        structure.

Return Value:


Note:


--*/
{
    DWORD                   status;
    LPSTR                   pDepend;
    LPQUERY_SERVICE_CONFIGA pConfigBuf;
    QUERY_SERVICE_CONFIGA   configBuf;
    DWORD                   tempBufSize;

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(QUERY_SERVICE_CONFIGA))
    {
        pConfigBuf = &configBuf;
        tempBufSize = sizeof(QUERY_SERVICE_CONFIGA);
    }
    else
    {
        pConfigBuf = lpServiceConfig;
    }

    RpcTryExcept
    {
        status = RQueryServiceConfigA(
                    (SC_RPC_HANDLE)hService,
                    pConfigBuf,
                    tempBufSize,
                    pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {

#ifdef _WIN64

        //
        // pcbBytesNeeded isn't filled in if the byte count is too
        // small (returned when the buffer size is large enough to
        // hold the 32-bit structure but too small to hold the
        // 64-bit structure.  Get the necessary (32-bit) size.
        //

        if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            RpcTryExcept
            {
                status = RQueryServiceConfigA(
                            (SC_RPC_HANDLE)hService,
                            pConfigBuf,
                            sizeof(QUERY_SERVICE_CONFIGA),
                            pcbBytesNeeded);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
            }
            RpcEndExcept
        }

        //
        // Since the ACF file specifies byte_count for this API, we're
        // responsible for managing the count of bytes needed by the
        // caller.  For 64-bit clients calling 32-bit servers, the
        // returned buffer size is too small because of differing
        // pointer sizes.  Add on the minimum number of bytes that
        // will guarantee enough space in the buffer for the next
        // call.
        //

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // 5 embedded pointers in the structure and max
            // space required for alignment.
            //
            *pcbBytesNeeded += 5 * (sizeof(PVOID) - sizeof(ULONG) + sizeof(PVOID));
        }

#endif  // _WIN64

        SetLastError(status);
        return(FALSE);
    }
    else
    {
        //
        // Replace the '/' separator characters by NULLs.  We used
        // separator characters in the double NULL terminated set of
        // strings so that RPC could treat it as a single string.
        //
        if ((pDepend = lpServiceConfig->lpDependencies) != NULL) {
            while (*pDepend != '\0') {
                if (*pDepend == '/') {
                    *pDepend = '\0';
                }
                pDepend++;
            }
        }
    }

    return(TRUE);
}


BOOL
WINAPI
QueryServiceConfigW(
    IN  SC_HANDLE               hService,
    OUT LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    IN  DWORD                   cbBufSize,
    OUT LPDWORD                 pcbBytesNeeded
    )

/*++

Routine Description:

    see QueryServiceConfigA

Arguments:


Return Value:


Note:


--*/
{
    DWORD                   status;
    LPWSTR                  pDepend;
    LPQUERY_SERVICE_CONFIGW pConfigBuf;
    QUERY_SERVICE_CONFIGW   configBuf;
    DWORD                   tempBufSize;

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(QUERY_SERVICE_CONFIGW))
    {
        pConfigBuf = &configBuf;
        tempBufSize = sizeof(QUERY_SERVICE_CONFIGW);
    }
    else
    {
        pConfigBuf = lpServiceConfig;
    }

    RpcTryExcept
    {
        status = RQueryServiceConfigW(
                    (SC_RPC_HANDLE)hService,
                    pConfigBuf,
                    tempBufSize,
                    pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {

#ifdef _WIN64

        //
        // pcbBytesNeeded isn't filled in if the byte count is too
        // small (returned when the buffer size is large enough to
        // hold the 32-bit structure but too small to hold the
        // 64-bit structure.  Get the necessary (32-bit) size.
        //

        if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            RpcTryExcept
            {
                status = RQueryServiceConfigW(
                            (SC_RPC_HANDLE)hService,
                            pConfigBuf,
                            sizeof(QUERY_SERVICE_CONFIGW),
                            pcbBytesNeeded);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
            }
            RpcEndExcept
        }

        //
        // Since the ACF file specifies byte_count for this API, we're
        // responsible for managing the count of bytes needed by the
        // caller.  For 64-bit clients calling 32-bit servers, the
        // returned buffer size is too small because of differing
        // pointer sizes.  Add on the minimum number of bytes that
        // will guarantee enough space in the buffer for the next
        // call.
        //

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // 5 embedded pointers in the structure and max
            // space required for alignment.
            //
            *pcbBytesNeeded += 5 * (sizeof(PVOID) - sizeof(ULONG) + sizeof(PVOID));
        }

#endif  // _WIN64

        SetLastError(status);
        return(FALSE);
    }
    else
    {
        //
        // Replace the '/' separator characters by NULLs.  We used
        // separator characters in the double NULL terminated set of
        // strings so that RPC could treat it as a single string.
        //
        if ((pDepend = lpServiceConfig->lpDependencies) != NULL) {
            while (*pDepend != L'\0') {
                if (*pDepend == L'/') {
                    *pDepend = L'\0';
                }
                pDepend++;
            }
        }
    }

    return(TRUE);
}


BOOL
WINAPI
QueryServiceConfig2A(
    IN  SC_HANDLE   hService,
    IN  DWORD       dwInfoLevel,
    OUT LPBYTE      lpBuffer,
    IN  DWORD       cbBufSize,
    OUT LPDWORD     pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                        status;
    LPBYTE                       lpTempBuffer;
    SERVICE_DESCRIPTIONA         sdDescription;
    SERVICE_FAILURE_ACTIONSA     sfaActions;
    DWORD                        tempBufSize;
    BOOL                         fDummyBuffer = FALSE;

    tempBufSize  = cbBufSize;
    lpTempBuffer = lpBuffer;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, put the correct size in the BytesNeeded parameter, and
    // fail the call.
    //
    switch(dwInfoLevel) {

    case SERVICE_CONFIG_DESCRIPTION:

        if (cbBufSize < sizeof(SERVICE_DESCRIPTION_WOW64)) {
            lpTempBuffer = (LPBYTE) &sdDescription;
            tempBufSize  = sizeof(SERVICE_DESCRIPTION_WOW64);
            fDummyBuffer = TRUE;
        }

        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:

        if (cbBufSize < sizeof(SERVICE_FAILURE_ACTIONS_WOW64)) {
            lpTempBuffer = (LPBYTE) &sfaActions;
            tempBufSize  = sizeof(SERVICE_FAILURE_ACTIONS_WOW64);
            fDummyBuffer = TRUE;
        }

        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept
    {
        status = RQueryServiceConfig2A(
                    (SC_RPC_HANDLE) hService,
                    dwInfoLevel,
                    lpTempBuffer,
                    tempBufSize,
                    pcbBytesNeeded);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept


#ifdef _WIN64

    //
    // 64-bit needs more space than the 32-bit-oriented structure
    // coming from the server.  Make sure we have it.  Do this
    // even if fDummyBuffer is TRUE since ScConvertOffsets64 will
    // update *pcbBytesNeeded appropriately.
    //

    if (status == NO_ERROR || status == ERROR_INSUFFICIENT_BUFFER)
    {
        if (!ScConvertOffsets64(dwInfoLevel == SERVICE_CONFIG_DESCRIPTION ?
                                    SC_API_QUERY_DESCRIPTION_A :
                                    SC_API_QUERY_FAILURE_ACTIONS_A,
                                NULL,
                                0,
                                0,
                                lpTempBuffer,
                                tempBufSize,
                                pcbBytesNeeded,
                                NULL,
                                NULL,
                                NULL,
                                NULL))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
    }

#endif // _WIN64


    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    //
    // Catch the case where the RPC call succeeded even though we used
    // a dummy buffer (e.g., SERVICE_FAILURE_ACTIONS on a service with
    // no command line or reboot message).  Note that the server side
    // of this API fills in pcbBytesNeeded even on success
    //
    if (fDummyBuffer)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Convert offsets to pointers in the returned structure
    //
    switch (dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        {
            LPSERVICE_DESCRIPTIONA psd =
                    (LPSERVICE_DESCRIPTIONA) lpBuffer;
            if (psd->lpDescription != NULL)
            {
                psd->lpDescription = (LPSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR)psd->lpDescription);
            }
        }
        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        {
            LPSERVICE_FAILURE_ACTIONSA psfa =
                    (LPSERVICE_FAILURE_ACTIONSA) lpBuffer;
            if (psfa->lpRebootMsg != NULL)
            {
                psfa->lpRebootMsg = (LPSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR)psfa->lpRebootMsg);
            }
            if (psfa->lpCommand != NULL)
            {
                psfa->lpCommand = (LPSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR)psfa->lpCommand);
            }
            if (psfa->lpsaActions != NULL)
            {
                psfa->lpsaActions = (SC_ACTION *)
                        (lpBuffer + (DWORD)(ULONG_PTR)psfa->lpsaActions);
            }
        }
        break;
    }

    return TRUE;
}


BOOL
WINAPI
QueryServiceConfig2W(
    IN  SC_HANDLE   hService,
    IN  DWORD       dwInfoLevel,
    OUT LPBYTE      lpBuffer,
    IN  DWORD       cbBufSize,
    OUT LPDWORD     pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                        status;
    LPBYTE                       lpTempBuffer;
    SERVICE_DESCRIPTIONW         sdDescription;
    SERVICE_FAILURE_ACTIONSW     sfaActions;
    DWORD                        tempBufSize;
    BOOL                         fDummyBuffer = FALSE;

    tempBufSize  = cbBufSize;
    lpTempBuffer = lpBuffer;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, put the correct size in the BytesNeeded parameter, and
    // fail the call.
    //
    switch(dwInfoLevel) {

    case SERVICE_CONFIG_DESCRIPTION:

        if (cbBufSize < sizeof(SERVICE_DESCRIPTIONW)) {
            lpTempBuffer = (LPBYTE) &sdDescription;
            tempBufSize  = sizeof(SERVICE_DESCRIPTIONW);
            fDummyBuffer = TRUE;
        }

        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:

        if (cbBufSize < sizeof(SERVICE_FAILURE_ACTIONSW)) {
            lpTempBuffer = (LPBYTE) &sfaActions;
            tempBufSize  = sizeof(SERVICE_FAILURE_ACTIONSW);
            fDummyBuffer = TRUE;
        }

        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept
    {
        status = RQueryServiceConfig2W(
                    (SC_RPC_HANDLE) hService,
                    dwInfoLevel,
                    lpTempBuffer,
                    tempBufSize,
                    pcbBytesNeeded);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept


#ifdef _WIN64

    //
    // 64-bit needs more space than the 32-bit-oriented structure
    // coming from the server.  Make sure we have it.  Do this
    // even if fDummyBuffer is TRUE since ScConvertOffsets64 will
    // update *pcbBytesNeeded appropriately.
    //

    if (status == NO_ERROR || status == ERROR_INSUFFICIENT_BUFFER)
    {
        if (!ScConvertOffsets64(dwInfoLevel == SERVICE_CONFIG_DESCRIPTION ?
                                    SC_API_QUERY_DESCRIPTION_W :
                                    SC_API_QUERY_FAILURE_ACTIONS_W,
                                NULL,
                                0,
                                0,
                                lpTempBuffer,
                                tempBufSize,
                                pcbBytesNeeded,
                                NULL,
                                NULL,
                                NULL,
                                NULL))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
    }

#endif // _WIN64


    if (status != NO_ERROR)
    {
        SetLastError(status);
        return FALSE;
    }

    //
    // Catch the case where the RPC call succeeded even though we used
    // a dummy buffer (e.g., SERVICE_FAILURE_ACTIONS on a service with
    // no command line or reboot message).  Note that the server side
    // of this API fills in pcbBytesNeeded even on success
    //
    if (fDummyBuffer)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Convert offsets to pointers in the returned structure
    //
    switch (dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        {
            LPSERVICE_DESCRIPTIONW psd =
                    (LPSERVICE_DESCRIPTIONW) lpBuffer;
            if (psd->lpDescription != NULL)
            {
                psd->lpDescription = (LPWSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR) psd->lpDescription);
            }
        }
        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        {
            LPSERVICE_FAILURE_ACTIONSW psfa =
                    (LPSERVICE_FAILURE_ACTIONSW) lpBuffer;
            if (psfa->lpRebootMsg != NULL)
            {
                psfa->lpRebootMsg = (LPWSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR) psfa->lpRebootMsg);
            }
            if (psfa->lpCommand != NULL)
            {
                psfa->lpCommand = (LPWSTR)
                        (lpBuffer + (DWORD)(ULONG_PTR) psfa->lpCommand);
            }
            if (psfa->lpsaActions != NULL)
            {
                psfa->lpsaActions = (SC_ACTION *)
                        (lpBuffer + (DWORD)(ULONG_PTR) psfa->lpsaActions);
            }
        }
        break;
    }

    return TRUE;
}


BOOL
WINAPI
QueryServiceLockStatusA(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    )

/*++

Routine Description:

    This is the DLL entry point for the QueryServiceLockStatus function.
    This function returns lock status information on a Service Control
    Manager database.


Arguments:

    hSCManager - Handled obtained from a previous call to OpenSCManager
        call.

    lpLockStatus - A pointer to a buffer to receive a
        QUERY_SERVICE_LOCK_STATUS information structure.

Return Value:


Note:


--*/
{
    DWORD                           status;
    LPQUERY_SERVICE_LOCK_STATUSA    pStatusBuf;
    QUERY_SERVICE_LOCK_STATUSA      statusBuf;
    DWORD                           tempBufSize;

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(QUERY_SERVICE_LOCK_STATUSA))
    {
        pStatusBuf = &statusBuf;
        tempBufSize = sizeof(QUERY_SERVICE_LOCK_STATUSA);
    }
    else
    {
        pStatusBuf = lpLockStatus;
    }

    RpcTryExcept
    {
        status = RQueryServiceLockStatusA(
                    (SC_RPC_HANDLE)hSCManager,
                    pStatusBuf,
                    tempBufSize,
                    pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {

#ifdef _WIN64

        //
        // pcbBytesNeeded isn't filled in if the byte count is too
        // small (returned when the buffer size is large enough to
        // hold the 32-bit structure but too small to hold the
        // 64-bit structure.  Get the necessary (32-bit) size.
        //

        if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            RpcTryExcept
            {
                status = RQueryServiceLockStatusA(
                            (SC_RPC_HANDLE)hSCManager,
                            pStatusBuf,
                            sizeof(QUERY_SERVICE_LOCK_STATUSA),
                            pcbBytesNeeded);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
            }
            RpcEndExcept
        }


        //
        // Since the ACF file specifies byte_count for this API, we're
        // responsible for managing the count of bytes needed by the
        // caller.  For 64-bit clients calling 32-bit servers, the
        // returned buffer size is too small because of differing
        // pointer sizes.  Add on the minimum number of bytes that
        // will guarantee enough space in the buffer for the next
        // call.
        //

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // 1 embedded pointer in the structure and max
            // space required for alignment.
            //
            *pcbBytesNeeded += (sizeof(PVOID) - sizeof(ULONG) + sizeof(PVOID));
        }
        else if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            //
            // We get here if we called a 32-bit server where the lock
            // was unowned and we used a buffer size smaller than
            // sizeof(QUERY_SERVICE_LOCK_STATUSA).
            //

            *pcbBytesNeeded = sizeof(QUERY_SERVICE_LOCK_STATUSA) + sizeof(WCHAR);
            status = ERROR_INSUFFICIENT_BUFFER;
        }

#endif  // _WIN64

        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
QueryServiceLockStatusW(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    )

/*++

Routine Description:

    see QueryServiceLockStatusA

Arguments:


Return Value:


Note:


--*/
{
    DWORD                           status;
    LPQUERY_SERVICE_LOCK_STATUSW    pStatusBuf;
    QUERY_SERVICE_LOCK_STATUSW      statusBuf;
    DWORD                           tempBufSize;

    tempBufSize = cbBufSize;

    //
    // Create a dummy buffer that is at least the size of the structure.
    // This way RPC should at least send the request to the server side.
    // The server should recognize that the buffer is to small for any
    // strings, and put the correct size in the BytesNeeded parameter,
    // and fail the call.
    //
    if (cbBufSize < sizeof(QUERY_SERVICE_LOCK_STATUSW))
    {
        pStatusBuf = &statusBuf;
        tempBufSize = sizeof(QUERY_SERVICE_LOCK_STATUSW);
    }
    else
    {
        pStatusBuf = lpLockStatus;
    }

    RpcTryExcept
    {
        status = RQueryServiceLockStatusW(
                    (SC_RPC_HANDLE)hSCManager,
                    pStatusBuf,
                    tempBufSize,
                    pcbBytesNeeded);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {

#ifdef _WIN64

        //
        // pcbBytesNeeded isn't filled in if the byte count is too
        // small (returned when the buffer size is large enough to
        // hold the 32-bit structure but too small to hold the
        // 64-bit structure.  Get the necessary (32-bit) size.
        //

        if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            RpcTryExcept
            {
                status = RQueryServiceLockStatusW(
                            (SC_RPC_HANDLE)hSCManager,
                            pStatusBuf,
                            sizeof(QUERY_SERVICE_LOCK_STATUSW),
                            pcbBytesNeeded);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
            }
            RpcEndExcept
        }

        //
        // Since the ACF file specifies byte_count for this API, we're
        // responsible for managing the count of bytes needed by the
        // caller.  For 64-bit clients calling 32-bit servers, the
        // returned buffer size is too small because of differing
        // pointer sizes.  Add on the minimum number of bytes that
        // will guarantee enough space in the buffer for the next
        // call.
        //

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // 1 embedded pointer in the structure and max
            // space required for alignment.
            //
            *pcbBytesNeeded += (sizeof(PVOID) - sizeof(ULONG) + sizeof(PVOID));
        }
        else if (status == RPC_X_BYTE_COUNT_TOO_SMALL)
        {
            //
            // We get here if we called a 32-bit server where the lock
            // was unowned and we used a buffer size smaller than
            // sizeof(QUERY_SERVICE_LOCK_STATUSW).
            //

            *pcbBytesNeeded = sizeof(QUERY_SERVICE_LOCK_STATUSW) + sizeof(WCHAR);
            status = ERROR_INSUFFICIENT_BUFFER;
        }

#endif  // _WIN64

        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WINAPI
UnlockServiceDatabase(
    IN  SC_LOCK     ScLock
    )

/*++

Routine Description:

    This is the DLL entry point for the UnlockServiceDatabase function.
    This function releases a lock on a Service Control Manager database.


Arguments:

    ScLock - Lock obtained from a previous LockServiceDatabase call.

Return Value:



--*/
{
    DWORD          status;


    UNREFERENCED_PARAMETER(ScLock);

    RpcTryExcept {

        status = RUnlockServiceDatabase((LPSC_RPC_LOCK)&ScLock);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_SERVICE_LOCK);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
WINAPI
NotifyBootConfigStatus(
    IN BOOL     BootAcceptable
    )

/*++

Routine Description:

    If we are not currently booted with Last Known Good, this function
    will revert to Last Known Good if the boot is not acceptable.  Or it
    will save the boot configuration that we last booted from as the
    Last Known Good.  This is the configuration that we will fall back
    to if a future boot fails.

Arguments:

    BootAcceptable - This indicates whether or not the boot was acceptable.

Return Value:

    TRUE - This is only returned if the boot is acceptable, and we
        successfully replaced Last Known Good with the current boot
        configuration.

    FALSE - This is returned if an error occured when attempting to replace
        Last Known Good or if the system is currently booted from Last
        Known Good.


--*/
{
    DWORD          status;


    RpcTryExcept {

        status = RNotifyBootConfigStatus(
                    NULL,                   // A Local Call Only.
                    (DWORD)BootAcceptable);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        status = ScMapRpcError(RpcExceptionCode(), ERROR_INVALID_HANDLE);
    }
    RpcEndExcept

    if (status != NO_ERROR){
        SetLastError(status);
        return(FALSE);
    }

    return(TRUE);
}

DWORD
ScWaitForStart(
    VOID
    )

/*++

Routine Description:

    This routine waits until the SC_INTERNAL_START_EVENT is set or until
    a timeout occurs.  Then it returns.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD                   status;
    HANDLE                  ScStartEvent = NULL;

    //
    // Try opening the event first because it will work most of the
    // time.
    //
    ScStartEvent = OpenEventW(
                    SYNCHRONIZE,
                    FALSE,
                    SC_INTERNAL_START_EVENT );

    if (ScStartEvent == NULL) {

        status = GetLastError();

        if (status == ERROR_FILE_NOT_FOUND) {
            //
            // Only if we can't find the event do we attempt to create
            // it here.
            //

            SCC_LOG0(ERROR,
                     "ScWaitForStart: Event does not exist -- attempting to create it\n");

            //
            // Create the event that the OpenSCManager will use to wait on the
            // service controller with.
            //
            SECURITY_ATTRIBUTES     SecurityAttributes;
            PSECURITY_DESCRIPTOR    SecurityDescriptor=NULL;

            status = ScCreateStartEventSD(&SecurityDescriptor);

            if (status != NO_ERROR) {
                SCC_LOG0(ERROR,"ScGetStartEvent: Couldn't allocate for SecurityDesc\n");
                return status;
            }

            SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
            SecurityAttributes.bInheritHandle = FALSE;
            SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;

            ScStartEvent = CreateEventW(
                        &SecurityAttributes,
                        TRUE,                   // Must be manually reset
                        FALSE,                  // The event is initially not signalled
                        SC_INTERNAL_START_EVENT );

            status = GetLastError();    // must do this before LocalFree

            LocalFree(SecurityDescriptor);

            if (ScStartEvent == NULL) {
                //
                // Failed to create StartEvent.
                //
                // If we failed to create it because someone else created
                // it between our calls to OpenEvent and CreateEvent, try
                // to open it once more.
                //
                if (status == ERROR_ALREADY_EXISTS) {

                    ScStartEvent = OpenEventW(
                                    SYNCHRONIZE,
                                    FALSE,
                                    SC_INTERNAL_START_EVENT );

                    if (ScStartEvent == NULL) {

                        status = GetLastError();

                        SCC_LOG1(ERROR,"ScWaitForStart: OpenEvent (StartEvent) failed "
                                FORMAT_DWORD " on second attempt\n", status);
                        return status;
                    }
                }
                else {
                    SCC_LOG1(ERROR,"ScWaitForStart: CreateEvent (StartEvent) Failed "
                            FORMAT_DWORD "\n", status);
                    return status;
                }
            }
        }
        else {
            //
            // Could not open the event for some unknown reason.  Give up.
            //
            SCC_LOG1(ERROR,"ScWaitForStart: OpenEvent (StartEvent) Failed "
                    FORMAT_DWORD "\n", status);
            return status;
        }
    }

    SCC_LOG0(TRACE,"Beginning wait for ScStartEvent\n");

    status = WaitForSingleObject(ScStartEvent, SC_START_TIMEOUT);

    CloseHandle(ScStartEvent);

    if (status == WAIT_TIMEOUT) {
        SCC_LOG0(ERROR,"ScWaitForStart: TIMEOUT waiting for StartEvent\n");
        return ERROR_TIMEOUT;
    }

    return NO_ERROR;
}


DWORD
ScMapRpcError(
    IN DWORD RpcError,
    IN DWORD BadContextError
    )
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful error
    for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

    BadContextError - Supplies the error code to return whenever an error
        which indicates invalid context is received.  In some cases, this
        value is ERROR_INVALID_HANDLE; in others, it is ERROR_INVALID_SERVICE_LOCK.

Return Value:

    Returns the mapped error.

--*/
{
    switch (RpcError)
    {
        case RPC_S_INVALID_BINDING:
        case RPC_X_SS_IN_NULL_CONTEXT:
        case RPC_X_SS_CONTEXT_DAMAGED:
        case RPC_X_SS_HANDLES_MISMATCH:
        case ERROR_INVALID_HANDLE:
            return BadContextError;

        case RPC_X_NULL_REF_POINTER:
        case EXCEPTION_ACCESS_VIOLATION:
            return ERROR_INVALID_ADDRESS;

        case RPC_S_INVALID_TAG:
            return ERROR_INVALID_LEVEL;

        case RPC_S_PROCNUM_OUT_OF_RANGE:
            return ERROR_CALL_NOT_IMPLEMENTED;

        default:
            return RpcError;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\client\scbind.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    scbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Service Controller.

Author:

    Dan Lafferty (danl)     19-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    19-Mar-1991     danl
        created

--*/

//
// INCLUDES
//

extern "C"
{
#include <nt.h>         // DbgPrint prototype
}
#include <rpc.h>        // DataTypes and runtime APIs
#include <svcctl.h>     // generated by the MIDL compiler
#include <ntrpcp.h>     // RpcUtils for binding

#include <sclib.h>      // ansi to unicode conversion functions.
#include <scdebug.h>    // SCC_LOG
#include <sclib.h>      // ScConvertToUnicode

//
// GLOBALS      -   This handle maintains a static binding for status
//                  messages between the service process and the service
//                  controller.
//
    static handle_t StatusBindHandle;


RPC_STATUS
InitializeStatusBinding( VOID)

/*++

Routine Description:

    This routine initializes the global StatusBindHandle that is used for
    the status connection to the service controller.  This routine is called
    by the Service Process (NetServiceStartCtrlDispatcher) when it starts up.


Arguments:

    none

Return Value:

    NERR_Success - (or 0) if the operation was successful.

    Otherwise, it returns any RPC failure status that can be returned
    from RpcBindToInterface.


--*/
{
    RPC_STATUS      status;

    status = RpcpBindRpc (
                NULL,
                L"svcctl",
                0,
                &StatusBindHandle);

    SCC_LOG(TRACE,"InitializeStatusBinding:RpcpBindRpc status=%d\n", status);

    SCC_LOG(TRACE,"InitializeStatusBinding: handle=%d\n",StatusBindHandle);

    return(status);
}



/****************************************************************************/
handle_t
SVCCTL_HANDLEW_bind (
    SVCCTL_HANDLEW   ServerName
    )

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the service controller client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle;
    RPC_STATUS  status;

    status = RpcpBindRpc (
                ServerName,
                L"svcctl",
                L"Security=Impersonation Dynamic False",
                &bindingHandle);

    SCC_LOG(TRACE,"SVCCTL_HANDLEW_bind:RpcpBindRpc status=%d\n",status);
    SCC_LOG(TRACE,"SVCCTL_HANDLEW_bind: handle=%d\n",bindingHandle);

    return( bindingHandle);
}



/****************************************************************************/
void
SVCCTL_HANDLEW_unbind (
    SVCCTL_HANDLEW   ServerName,
    handle_t         BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the Service Controller client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);     // This parameter is not used

    SCC_LOG(TRACE,"SVCCTL_HANDLEW_unbind: handle=%d\n",BindingHandle);

    RpcpUnbindRpc ( BindingHandle);
    return;
}

/****************************************************************************/
handle_t
SVCCTL_HANDLEA_bind (
    SVCCTL_HANDLEA   ServerName
    )

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the service controller client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle;
    RPC_STATUS  status;
    LPWSTR      pServerNameW = NULL;

    if (ServerName != NULL) {
        if (!ScConvertToUnicode(&pServerNameW, ServerName)) {
            SCC_LOG(ERROR,"SVCCTL_HANDLEA_bind:ScConvertToUnicode failed\n",0);
            return(NULL);
        }
    }

    status = RpcpBindRpc (
                pServerNameW,
                L"svcctl",
                L"Security=Impersonation Dynamic False",
                &bindingHandle);

    (void) LocalFree(pServerNameW);

    SCC_LOG(TRACE,"SVCCTL_HANDLEA_bind:RpcpBindRpc status=%d\n",status);
    SCC_LOG(TRACE,"SVCCTL_HANDLEA_bind: handle=%d\n",bindingHandle);

    return( bindingHandle);
}



/****************************************************************************/
void
SVCCTL_HANDLEA_unbind (
    SVCCTL_HANDLEA   ServerName,
    handle_t         BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the Service Controller client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);     // This parameter is not used

    SCC_LOG(TRACE,"SVCCTL_HANDLEA_unbind: handle=%d\n",BindingHandle);

    RpcpUnbindRpc ( BindingHandle);
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\scpragma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    scpragma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let the Service Controller compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\scwow.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    scwow.h

Abstract:

    Structure definitions for 32/64-bit interop

Author:

    Jonathan Schwartz (jschwart)   18-Sep-2000

Revision History:

--*/

#ifndef SCWOW_INCLUDED
#define SCWOW_INCLUDED


//
// Internal structures for the enum functions for 64/32-bit interop
// since the ENUM_SERVICE_STATUS* structures contain two pointers
// and we don't want to pass back structures of an indeterminate
// size.  Since the pointer fields are used as offsets only across
// the wire, use these structures to force those fields to be a
// known length (32 bits for compatibility with older clients).
//

typedef struct _ENUM_SERVICE_STATUS_WOW64
{
    DWORD          dwServiceNameOffset;
    DWORD          dwDisplayNameOffset;
    SERVICE_STATUS ServiceStatus;
}
ENUM_SERVICE_STATUS_WOW64, *LPENUM_SERVICE_STATUS_WOW64;

typedef struct _ENUM_SERVICE_STATUS_PROCESS_WOW64
{
    DWORD                  dwServiceNameOffset;
    DWORD                  dwDisplayNameOffset;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
}
ENUM_SERVICE_STATUS_PROCESS_WOW64, *LPENUM_SERVICE_STATUS_PROCESS_WOW64;


//
// Internal structures for QueryServiceConfig2 for 64/32-bit interop
//

typedef struct _SERVICE_DESCRIPTION_WOW64
{
    DWORD    dwDescriptionOffset;
}
SERVICE_DESCRIPTION_WOW64, *LPSERVICE_DESCRIPTION_WOW64;

typedef struct _SERVICE_FAILURE_ACTIONS_WOW64
{
    DWORD    dwResetPeriod;
    DWORD    dwRebootMsgOffset;
    DWORD    dwCommandOffset;
    DWORD    cActions;
    DWORD    dwsaActionsOffset;
}
SERVICE_FAILURE_ACTIONS_WOW64, *LPSERVICE_FAILURE_ACTIONS_WOW64;


#endif // #ifndef SCWOW_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\strarray.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    StrArray.h

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

Author:

    John Rogers (JohnRo) 03-Jan-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Jan-1992 JohnRo
        Created this file from bits and pieces in RxCommon and NetLib.

--*/

#ifndef _STRARRAY_
#define _STRARRAY_


// These must be included first:

#include <windef.h>             // IN, LPTSTR, LPVOID, etc.

// These may be included in any order:

// (none)



#ifdef __cplusplus
extern "C" {
#endif

VOID
ScAddWStrToWStrArray (
    IN OUT LPWSTR Dest,
    IN LPWSTR Src
    );

// BOOL
// ScIsWStrArrayEmpty (
//     IN LPWSTR Array
//     );
#define ScIsWStrArrayEmpty( Array )  \
    ( ( (*(Array)) == 0) ? TRUE : FALSE )



#if DBG

VOID
ScDisplayWStrArray (
    IN LPWSTR Array
    );

#else // not DBG

#define ScDisplayWStrArray(Array)     /* nothing */

#endif // not DBG


// LPWSTR
// ScNextWStrArrayEntry (
//     IN LPWSTR Array
//     );
#define ScNextWStrArrayEntry(Array) \
    ( ((LPWSTR)(Array)) + (wcslen(Array) + 1) )


// LPSTR
// ScNextAStrArrayEntry (
//     IN LPSTR Array
//     );
#define ScNextAStrArrayEntry(Array) \
    ( ((LPSTR)(Array)) + (strlen(Array) + 1) )

//
// Return number of bytes to allocate for this string array.
// This includes the "extra" trailing null char.
//
DWORD
ScWStrArraySize(
    IN LPWSTR Array
    );

DWORD
ScAStrArraySize(
    IN LPSTR Array
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _STRARRAY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\scdebug.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    scdebug.h

Abstract:

    Contains debug macros used by the Service Controller.

Author:

    Dan Lafferty (danl)     22-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    10-Apr-1992 JohnRo
        Added SC_ASSERT() and SCC_ASSERT() macros.
    16-Apr-1992 JohnRo
        Added debug flags for config APIs and database lock APIs.
        Include <debugfmt.h> to get FORMAT_ equates.
        Made changes suggested by PC-LINT.
    21-Apr-1992 JohnRo
        Added SC_LOG0(), etc.
    12-Nov-1995 AnirudhS
        Make SC_LOG macros use one DbgPrint instead of two.
    15-May-1996 AnirudhS
        Have SC_LOG macros print the thread id.

--*/


#ifndef SCDEBUG_H
#define SCDEBUG_H


#include <debugfmt.h>   // FORMAT_ equates.


#ifdef __cplusplus
extern "C" {
#endif

//
// Debug macros and constants.
//

#if !DBG || defined(lint) || defined(_lint)

#define DEBUG_STATE 0
#define STATIC static

#else // just DBG

#define DEBUG_STATE 1
#define STATIC

#endif // just DBG

//
// The following macros allow debug print syntax to look like:
//
//   SC_LOG1(TRACE, "An error occured: " FORMAT_DWORD "\n",status)
//

#if DBG

//
// Server-side debugging macros.
//

#define SC_LOG0(level, string)                      \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId()))

#define SC_LOG1(level, string, var)                 \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var))

#define SC_LOG2(level, string, var1, var2)          \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var1,                                \
               var2))

#define SC_LOG3(level, string, var1, var2, var3)    \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var1,                                \
               var2,                                \
               var3))

#define SC_LOG4(level, string, var1, var2, var3, var4) \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var1,                                \
               var2,                                \
               var3,                                \
               var4))

#define SC_LOG(level, string, var)                  \
    KdPrintEx((DPFLTR_SCSERVER_ID,                  \
               DEBUG_##level,                       \
               "[SC] %lx: " string,                 \
               GetCurrentThreadId(),                \
               var))

#define SC_ASSERT(boolExpr) ASSERT(boolExpr)


#define SVCHOST_LOG0(level, string)                 \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId()))

#define SVCHOST_LOG1(level, string, var)            \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var))

#define SVCHOST_LOG2(level, string, var1, var2)     \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var1,                                \
               var2))

#define SVCHOST_LOG3(level, string, var1, var2, var3) \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var1,                                \
               var2,                                \
               var3))

#define SVCHOST_LOG4(level, string, var1, var2, var3, var4) \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var1,                                \
               var2,                                \
               var3,                                \
               var4))

#define SVCHOST_LOG(level, string, var)             \
    KdPrintEx((DPFLTR_SVCHOST_ID,                   \
               DEBUG_##level,                       \
               "[SVCHOST] %lx.%lx: " string,        \
               GetCurrentProcessId(),               \
               GetCurrentThreadId(),                \
               var))


//
// Client-side debugging macros.
//

#define SCC_LOG0(level, string)                     \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId()))

#define SCC_LOG1(level, string, var)                \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId(),               \
               var))

#define SCC_LOG2(level, string, var1, var2)         \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId(),               \
               var1,                                \
               var2))

#define SCC_LOG3(level, string, var1, var2, var3)   \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId(),               \
               var1,                                \
               var2,                                \
               var3))

#define SCC_LOG(level, string, var)                 \
    KdPrintEx((DPFLTR_SCCLIENT_ID,                  \
               DEBUG_##level,                       \
               "[SC-CLIENT] %lx: " string,          \
               GetCurrentProcessId(),               \
               var))

#define SCC_ASSERT(boolExpr) ASSERT(boolExpr)

#else

#define SC_ASSERT(boolExpr)

#define SC_LOG0(level, string)
#define SC_LOG1(level, string, var)
#define SC_LOG2(level, string, var1, var2)
#define SC_LOG3(level, string, var1, var2, var3)
#define SC_LOG4(level, string, var1, var2, var3, var4)
#define SC_LOG(level, string, var)

#define SVCHOST_LOG0(level, string)
#define SVCHOST_LOG1(level, string, var)
#define SVCHOST_LOG2(level, string, var1, var2)
#define SVCHOST_LOG3(level, string, var1, var2, var3)
#define SVCHOST_LOG4(level, string, var1, var2, var3, var4)
#define SVCHOST_LOG(level, string, var)


#define SCC_ASSERT(boolExpr)

#define SCC_LOG0(level, string)
#define SCC_LOG1(level, string, var)
#define SCC_LOG2(level, string, var1, var2)
#define SCC_LOG3(level, string, var1, var2, var3)
#define SCC_LOG(level, string, var)

#endif

//
// Debug output is filtered at two levels: A global level and a component
// specific level.
//
// Each debug output request specifies a component id and a filter level
// or mask. These variables are used to access the debug print filter
// database maintained by the system. The component id selects a 32-bit
// mask value and the level either specified a bit within that mask or is
// as mask value itself.
//
// If any of the bits specified by the level or mask are set in either the
// component mask or the global mask, then the debug output is permitted.
// Otherwise, the debug output is filtered and not printed.
//
// The component mask for filtering the debug output of this component is
// Kd_SCSERVER_Mask or Kd_SCCLIENT_Mask and may be set via the registry or
// the kernel debugger.
//
// The global mask for filtering the debug output of all components is
// Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.
//
// The registry key for setting the mask value for this component is:
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\
//     Session Manager\Debug Print Filter\SCSERVER or SCCLIENT
//
// The key "Debug Print Filter" may have to be created in order to create
// the component key.
//

#define DEBUG_ERROR       (0x00000001 | DPFLTR_MASK)
#define DEBUG_WARNING     (0x00000002 | DPFLTR_MASK)
#define DEBUG_TRACE       (0x00000004 | DPFLTR_MASK)
#define DEBUG_INFO        (0x00000008 | DPFLTR_MASK)
#define DEBUG_SECURITY    (0x00000010 | DPFLTR_MASK)
#define DEBUG_CONFIG      (0x00000020 | DPFLTR_MASK)
#define DEBUG_DEPEND      (0x00000040 | DPFLTR_MASK)
#define DEBUG_DEPEND_DUMP (0x00000080 | DPFLTR_MASK)
#define DEBUG_CONFIG_API  (0x00000100 | DPFLTR_MASK)
#define DEBUG_LOCK_API    (0x00000200 | DPFLTR_MASK)
#define DEBUG_ACCOUNT     (0x00000400 | DPFLTR_MASK)
#define DEBUG_USECOUNT    (0x00000800 | DPFLTR_MASK)
#define DEBUG_NETBIOS     (0x00001000 | DPFLTR_MASK)
#define DEBUG_THREADS     (0x00002000 | DPFLTR_MASK)
#define DEBUG_BSM         (0x00004000 | DPFLTR_MASK)
#define DEBUG_SHUTDOWN    (0x00008000 | DPFLTR_MASK)
#define DEBUG_WHY         (0x00010000 | DPFLTR_MASK)
#define DEBUG_BOOT        (0x00020000 | DPFLTR_MASK)
#define DEBUG_HANDLE      (0x00040000 | DPFLTR_MASK)
#define DEBUG_LOCKS       (0x10000000 | DPFLTR_MASK)

#define DEBUG_ALL         (0xffffffff | DPFLTR_MASK)

#ifdef __cplusplus
}
#endif

#endif // def SCDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\svcslib.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    svcslib.h

Abstract:

    Contains information for connecting services to the controller process.

Author:

    Dan Lafferty (danl)     26-Oct-1993

Environment:

    User Mode -Win32

Revision History:

    26-Oct-1993     danl
        created
    04-Dec-1996     anirudhs
        Added CWorkItemContext

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//
DWORD
SvcStartLocalDispatcher(
    VOID
    );

BOOL
SetupInProgress(
    HKEY    SystemKey,
    LPDWORD pdwOOBEMode    OPTIONAL
    );

#ifdef __cplusplus

//===================
// CWorkItemContext
//===================
// Higher-level wrapper for Rtl thread pool functions
//
// An instance of this class is a callback context for the Rtl thread pool functions
//
class CWorkItemContext
{
public:

    NTSTATUS            AddWorkItem(
                            IN  DWORD    dwFlags
                            )
                        {
                            return RtlQueueWorkItem(CallBack,
                                                    this,     // pContext
                                                    dwFlags);
                        }

    NTSTATUS            AddDelayedWorkItem(
                            IN  DWORD    dwTimeout,
                            IN  DWORD    dwFlags
                            );

    VOID             RemoveDelayedWorkItem(
                         VOID
                         )
                     {
                         ASSERT(m_hWorkItem != NULL);
                         RtlDeregisterWait(m_hWorkItem);
                         m_hWorkItem = NULL;
                     }

    static BOOL         Init();
    static void         UnInit();

protected:

    virtual VOID        Perform(
                            IN BOOLEAN   fWaitStatus
                            ) = 0;

    HANDLE              m_hWorkItem;

private:
    static VOID         CallBack(
                            IN PVOID     pContext
                            );

    static VOID         DelayCallBack(
                            IN PVOID     pContext,
                            IN BOOLEAN   fWaitStatus
                            );

    static HANDLE       s_hNeverSignaled;
};

#define DECLARE_CWorkItemContext                        \
protected:                                              \
    VOID                Perform(                        \
                            IN BOOLEAN   fWaitStatus    \
                            );

} // extern "C"

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\sclib.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ScLib.h

Abstract:

    Prototypes routines which may be shared between Client (DLL) and
    Server (EXE) halves of service controller.

Author:

    Dan Lafferty (danl)     04-Feb-1992

Environment:

    User Mode -Win32

Revision History:

    04-Feb-1992     danl
        created
    10-Apr-1992 JohnRo
        Added ScIsValidImagePath() and ScImagePathsMatch().
    14-Apr-1992 JohnRo
        Added ScCheckServiceConfigParms(), ScIsValid{Account,Driver,Start}Name.
    27-May-1992 JohnRo
        Use CONST where possible.
        Fixed a UNICODE bug.

--*/


#ifndef SCLIB_H
#define SCLIB_H

////////////////////////////////////////////////////////////////////////////
// DEFINES
//

//
// Used by the client side of OpenSCManager to wait until the Service
// Controller has been started.
//
#define SC_INTERNAL_START_EVENT L"Global\\SvcctrlStartEvent_A3752DX"


////////////////////////////////////////////////////////////////////////////
// FUNCTION PROTOTYPES
//

//
// From acctname.cxx
//
BOOL
ScIsValidAccountName(
    IN  LPCWSTR lpAccountName
    );

//
// From confparm.cxx
//
DWORD
ScCheckServiceConfigParms(
    IN  BOOL            Change,
    IN  LPCWSTR         lpServiceName,
    IN  DWORD           dwActualServiceType,
    IN  DWORD           dwNewServiceType,
    IN  DWORD           dwStartType,
    IN  DWORD           dwErrorControl,
    IN  LPCWSTR         lpBinaryPathName OPTIONAL,
    IN  LPCWSTR         lpLoadOrderGroup OPTIONAL,
    IN  LPCWSTR         lpDependencies   OPTIONAL,
    IN  DWORD           dwDependSize
    );

//
// From convert.cxx
//
BOOL
ScConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPCSTR  AnsiIn
    );

BOOL
ScConvertToAnsi(
    OUT LPSTR    AnsiOut,
    IN  LPCWSTR  UnicodeIn
    );

//
// From packstr.cxx
//
BOOL
ScCopyStringToBufferW (
    IN      LPCWSTR  String OPTIONAL,
    IN      DWORD   CharacterCount,
    IN      LPCWSTR  FixedDataEnd,
    IN OUT  LPWSTR  *EndOfVariableData,
    OUT     LPWSTR  *VariableDataPointer,
    IN      const LPBYTE lpBufferStart    OPTIONAL
    );

//
// From path.cxx
//
BOOL
ScImagePathsMatch(
    IN  LPCWSTR OnePath,
    IN  LPCWSTR TheOtherPath
    );

BOOL
ScIsValidImagePath(
    IN  LPCWSTR ImagePathName,
    IN  DWORD ServiceType
    );

//
// From startnam.cxx
//
BOOL
ScIsValidStartName(
    IN  LPCWSTR lpStartName,
    IN  DWORD dwServiceType
    );

//
// From util.cxx
//
BOOL
ScIsValidServiceName(
    IN  LPCWSTR ServiceName
    );

#endif // SCLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\scseclib.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    scseclib.h

Abstract:

    This header file defines the structures and function prototypes of
    routines which simplify the creation of security descriptors for
    user-mode objects.

Author:

    Rita Wong (ritaw) 27-Feb-1991

Revision History:

--*/

#ifndef _SCSECLIB_INCLUDED_
#define _SCSECLIB_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

//
// Global declarations
//

//
// NT well-known SIDs
//

extern PSID NullSid;                   // No members SID
extern PSID WorldSid;                  // All users SID
extern PSID LocalSid;                  // NT local users SID
extern PSID NetworkSid;                // NT remote users SID
extern PSID LocalSystemSid;            // NT system processes SID
extern PSID LocalServiceSid;           // NT LocalService SID
extern PSID NetworkServiceSid;         // NT NetworkService SID
extern PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain
extern PSID AuthenticatedUserSid;      // NT authenticated users SID
extern PSID AnonymousLogonSid;         // Anonymous Logon SID

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

extern PSID AliasAdminsSid;            // Administrator Sid
extern PSID AliasUsersSid;             // User Sid
extern PSID AliasGuestsSid;            // Guest Sid
extern PSID AliasPowerUsersSid;        // Power User Sid
extern PSID AliasAccountOpsSid;        // Account Operator Sid
extern PSID AliasSystemOpsSid;         // System Operator Sid
extern PSID AliasPrintOpsSid;          // Print Operator Sid
extern PSID AliasBackupOpsSid;         // Backup Operator Sid

//
// Structure to hold information about an ACE to be created
//

typedef struct {
    UCHAR AceType;
    UCHAR InheritFlags;
    UCHAR AceFlags;
    ACCESS_MASK Mask;
    PSID *Sid;
} SC_ACE_DATA, *PSC_ACE_DATA;


NTSTATUS
ScCreateWellKnownSids(
    VOID
    );

NTSTATUS
ScAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    );

NTSTATUS
ScDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    );

NTSTATUS
ScCreateAndSetSD(
    IN  PSC_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

NTSTATUS
ScCreateUserSecurityObject(
    IN  PSECURITY_DESCRIPTOR ParentSD,
    IN  PSC_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  BOOLEAN IsDirectoryObject,
    IN  BOOLEAN UseImpersonationToken,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

DWORD
ScCreateStartEventSD(
    PSECURITY_DESCRIPTOR    *pEventSD
    );

#ifdef __cplusplus
}
#endif

#endif // ifdef _SCSECLIB_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\inc\valid.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    valid.h

Abstract:

    Contains validation macros and function prototypes for service
    controller parameters.

Author:

    Dan Lafferty (danl) 29-Mar-1992

Environment:

    User Mode - Win32

Revision History:

    29-Mar-1992 danl
        Created
    10-Apr-1992 JohnRo
        Added START_TYPE_INVALID().
        Changed SERVICE_TYPE_INVALID() into SERVICE_TYPE_MASK_INVALID() and
        added a stricter SERVICE_TYPE_INVALID() which checks for one type.
        Made other macros less likely to be evaluated wrong.

--*/


#ifndef VALID_H
#define VALID_H

#ifdef __cplusplus
extern "C" {
#endif

//
// INCLUDES
//

//
// DEFINITIONS
//
#define MAX_SERVICE_NAME_LENGTH   256


//
// MACROS
//

#define CONTROLS_ACCEPTED_INVALID(cA)  \
           (((cA) & ~(SERVICE_ACCEPT_STOP |             \
                      SERVICE_ACCEPT_PAUSE_CONTINUE |   \
                      SERVICE_ACCEPT_SHUTDOWN |         \
                      SERVICE_ACCEPT_PARAMCHANGE |      \
                      SERVICE_ACCEPT_HARDWAREPROFILECHANGE |      \
                      SERVICE_ACCEPT_NETBINDCHANGE |    \
                      SERVICE_ACCEPT_POWEREVENT |       \
                      SERVICE_ACCEPT_SESSIONCHANGE)) !=0)

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define ERROR_CONTROL_INVALID( eC ) \
    ( \
        ( (eC) != SERVICE_ERROR_NORMAL ) && \
        ( (eC) != SERVICE_ERROR_SEVERE ) && \
        ( (eC) != SERVICE_ERROR_IGNORE ) && \
        ( (eC) != SERVICE_ERROR_CRITICAL ) \
    )

#define SERVICE_STATUS_TYPE_INVALID(sT) \
    ( \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32_OWN_PROCESS ) && \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32_SHARE_PROCESS ) && \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32 ) && \
        ( (sT) != SERVICE_DRIVER ) \
    )

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define SERVICE_TYPE_INVALID(sT) \
    ( \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32_OWN_PROCESS ) && \
        ( ((sT) & (~SERVICE_INTERACTIVE_PROCESS)) != SERVICE_WIN32_SHARE_PROCESS ) && \
        ( (sT) != SERVICE_KERNEL_DRIVER ) && \
        ( (sT) != SERVICE_FILE_SYSTEM_DRIVER ) \
    )

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define SERVICE_TYPE_MASK_INVALID(sT)                \
            ((((sT) &  SERVICE_TYPE_ALL) == 0 )  ||  \
             (((sT) & ~SERVICE_TYPE_ALL) != 0 ))

#define ENUM_STATE_MASK_INVALID(sS)                   \
            ((((sS) &  SERVICE_STATE_ALL) == 0 )  || \
             (((sS) & ~SERVICE_STATE_ALL) != 0 ))

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define START_TYPE_INVALID(sT)                \
    ( \
        ( (sT) != SERVICE_BOOT_START ) && \
        ( (sT) != SERVICE_SYSTEM_START ) && \
        ( (sT) != SERVICE_AUTO_START ) && \
        ( (sT) != SERVICE_DEMAND_START ) && \
        ( (sT) != SERVICE_DISABLED ) \
    )

// Note that this macro does not allow SERVICE_NO_CHANGE.
#define ACTION_TYPE_INVALID(aT)           \
    ( \
        ( (aT) != SC_ACTION_NONE ) && \
        ( (aT) != SC_ACTION_RESTART ) && \
        ( (aT) != SC_ACTION_REBOOT ) && \
        ( (aT) != SC_ACTION_RUN_COMMAND ) \
    )

//
// FUNCTION PROTOTYPES
//

BOOL
ScCurrentStateInvalid(
    DWORD   dwCurrentState
    );

DWORD
ScValidateMultiSZ(
    LPCWSTR lpStrings,
    DWORD   cbStrings
    );

#ifdef __cplusplus
}
#endif

#endif // VALID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\acctname.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    AcctName.c

Abstract:

    Contains miscellaneous utility functions used by the Service
    Controller:

        ScIsValidAccountName

Author:

    John Rogers (JohnRo) 14-Apr-1992

Environment:

    User Mode -Win32

Revision History:

    14-Apr-1992 JohnRo
        Created.
    20-May-1992 JohnRo
        Use CONST where possible.

--*/

#include <nt.h>
#include <ntrtl.h>
//#include <nturtl.h>
#include <windef.h>

#include <scdebug.h>    // SC_ASSERT().
#include <sclib.h>      // My prototype.
#include <stdlib.h>      // wcschr().



BOOL
ScIsValidAccountName(
    IN  LPCWSTR lpAccountName
    )

/*++

Routine Description:

    This function validates a given service Account name.

Arguments:

    lpAccountName - Supplies the Account name to be validated.

Return Value:

    TRUE - The name is valid.

    FALSE - The name is invalid.

--*/

{

    if (lpAccountName == NULL) {
        return (FALSE);          // Missing name isn't valid.
    } else if ( (*lpAccountName) == L'\0' ) {
        return (FALSE);          // Missing name isn't valid.
    }

    //
    // name is account name ("domain\user" or ".\user" or LocalSystem).
    //
    if (lpAccountName[0] == L'\\') {
        return (FALSE);
    }

    //
    // The account name is canonicalized and validated later.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\confparm.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfParm.c

Abstract:

    This file contains:
        ScCheckServiceConfigParms


Author:

    John Rogers (JohnRo) 14-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    14-Apr-1992 JohnRo
        Created.
    20-May-1992 JohnRo
        Use CONST where possible.
    09-Dec-1996     AnirudhS
        Added SC_LOG printouts to help diagnose the annoying
        ERROR_INVALID_PARAMETER and ERROR_INVALID_SERVICE_ACCOUNT return codes.

--*/


//
// INCLUDES
//

#include <scpragma.h>

#include <nt.h>
#include <ntrtl.h>      // Needed by <scdebug.h>
#include <nturtl.h>
#include <stdlib.h>      // wcsicmp

#include <windef.h>
#include <winbase.h>    // GetCurrentThreadId, for SC_LOG

#include <scdebug.h>    // SC_ASSERT().
#include <sclib.h>      // My prototype.
#include <valid.h>      // ERROR_CONTROL_INVALID(), SERVICE_TYPE_INVALID(), etc.
#include <winerror.h>   // NO_ERROR and ERROR_ equates.
#include <winsvc.h>     // SERVICE_ equates.



DWORD
ScCheckServiceConfigParms(
    IN  BOOL            Change,
    IN  LPCWSTR         lpServiceName,
    IN  DWORD           dwActualServiceType,
    IN  DWORD           dwNewServiceType,
    IN  DWORD           dwStartType,
    IN  DWORD           dwErrorControl,
    IN  LPCWSTR         lpBinaryPathName OPTIONAL,
    IN  LPCWSTR         lpLoadOrderGroup OPTIONAL,
    IN  LPCWSTR         lpDependencies   OPTIONAL,
    IN  DWORD           dwDependSize
    )

/*++

Routine Description:

    This routine checks parameters for a CreateService() or a
    ChangeServiceConfig() API.

Arguments:

    Change - TRUE if this is the result of a ChangeServiceConfig API.
        (This flag is used to determine whether other parameters may be
        SERVICE_NO_CHANGE or NULL pointers.)

    dwActualServiceType - For ChangeServiceConfig, contains the current
        service type associated with this service.  Otherwise, this is
        the same value as dwNewServiceType.

    dwNewServiceType - SERVICE_NO_CHANGE or the service type given by app.

    (Other parameters same as CreateService and ChangeServiceConfig APIs.)

Return Value:

    NO_ERROR or error code.

--*/

{
    DWORD dwFinalServiceType;

#define PARM_MISSING( ws )   ( ((ws)==NULL) || ((*(ws)) == L'\0') )

    if ( !Change ) {

        //
        // Almost all fields must be present for creating a service.
        // (Exceptions are dependencies and password.)
        //
        if ( (dwNewServiceType  == SERVICE_NO_CHANGE) ||
             (dwStartType       == SERVICE_NO_CHANGE) ||
             (dwErrorControl    == SERVICE_NO_CHANGE) ||
             PARM_MISSING(lpBinaryPathName) ) {

            SC_LOG0(ERROR, "ServiceType, StartType, ErrorControl or BinPath missing\n");
            return (ERROR_INVALID_PARAMETER);

        }
    }

    //
    // Validate actual and desired service types.
    //
    if (dwNewServiceType != SERVICE_NO_CHANGE) {
        if ( SERVICE_TYPE_INVALID( dwNewServiceType ) ) {
            SC_LOG0(ERROR, "ServiceType invalid\n");
            return (ERROR_INVALID_PARAMETER);
        }

        //
        // Not allowed to change the service type from Win32 to Driver
        // or Driver to Win32.
        //
        if ( ((dwNewServiceType & SERVICE_DRIVER) &&
              (dwActualServiceType & SERVICE_WIN32)) ||
             ((dwNewServiceType & SERVICE_WIN32) &&
              (dwActualServiceType & SERVICE_DRIVER)) ) {
            SC_LOG0(ERROR, "Can't change service type between Win32 and Driver\n");
            return (ERROR_INVALID_PARAMETER);
        }
    }
    if (dwActualServiceType == SERVICE_NO_CHANGE) {
        SC_LOG0(ERROR, "Current ServiceType missing\n");
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate start type (if that was given).
    //
    if (dwStartType != SERVICE_NO_CHANGE) {

        if ( START_TYPE_INVALID( dwStartType ) ) {
            SC_LOG0(ERROR, "StartType invalid\n");
            return (ERROR_INVALID_PARAMETER);
        }

        //
        // A boot-start or system-start service must be a driver
        //
        if (dwStartType == SERVICE_BOOT_START ||
            dwStartType == SERVICE_SYSTEM_START) {

            if (dwNewServiceType == SERVICE_NO_CHANGE) {

                if (dwActualServiceType != SERVICE_KERNEL_DRIVER &&
                    dwActualServiceType != SERVICE_FILE_SYSTEM_DRIVER) {

                    SC_LOG0(ERROR, "StartType is boot or system but service is not a driver\n");
                    return (ERROR_INVALID_PARAMETER);
                }
            }
            else {
                if (dwNewServiceType != SERVICE_KERNEL_DRIVER &&
                    dwNewServiceType != SERVICE_FILE_SYSTEM_DRIVER) {

                    SC_LOG0(ERROR, "StartType is boot or system but ServiceType is not driver\n");
                    return (ERROR_INVALID_PARAMETER);
                }
            }
        }
    }

    //
    // Validate error control...
    //
    if (dwErrorControl != SERVICE_NO_CHANGE) {
        if ( ERROR_CONTROL_INVALID( dwErrorControl ) ) {
            SC_LOG0(ERROR, "ErrorControl invalid\n");
            return (ERROR_INVALID_PARAMETER);
        }
    }

    //
    // Path type depends on final service type.
    //
    if (dwNewServiceType == SERVICE_NO_CHANGE) {
        dwFinalServiceType = dwActualServiceType;
    } else {
        dwFinalServiceType = dwNewServiceType;
    }
    SC_ASSERT( dwFinalServiceType != SERVICE_NO_CHANGE );

    //
    // Validate binary path name.
    //
    if (lpBinaryPathName != NULL) {

        // Check path name syntax and make sure it matches service type.
        // Path type depends on final service type.
        if ( !ScIsValidImagePath( lpBinaryPathName, dwFinalServiceType ) ) {
            SC_LOG0(ERROR, "ImagePath invalid for this service type\n");
            return (ERROR_INVALID_PARAMETER);
        }
    }

    //
    // Check for trivial cases of circular dependencies:
    //    1) Service is dependent on itself
    //    2) Service is dependent on a group it is a member of
    //
    LPWSTR DependPtr = (LPWSTR) lpDependencies;

    if (DependPtr != NULL && (*DependPtr != L'\0'))
    {
        DWORD  dwError = ScValidateMultiSZ(DependPtr, dwDependSize);

        if (dwError != NO_ERROR)
        {
            SC_LOG(ERROR,
                   "ScCheckServiceConfigParms: Invalid dependencies %d\n",
                   dwError);

            return dwError;
        }

        while (*DependPtr != 0) {

            if (*DependPtr == SC_GROUP_IDENTIFIERW) {

                if ((lpLoadOrderGroup != NULL) && (*lpLoadOrderGroup != 0)) {

                    if (_wcsicmp(DependPtr + 1, lpLoadOrderGroup) == 0) {

                        //
                        // Service depends on the group it is in
                        //
                        SC_LOG0(ERROR, "Service depends on the group it is in\n");
                        return (ERROR_CIRCULAR_DEPENDENCY);
                    }
                }
            }
            else {

                if (_wcsicmp(DependPtr, lpServiceName) == 0) {

                    //
                    // Service depends on itself
                    //
                    SC_LOG0(ERROR, "Service depends on itself\n");
                    return (ERROR_CIRCULAR_DEPENDENCY);
                }
            }

            DependPtr += (wcslen(DependPtr) + 1);
        }
    }

    //
    // Start name is checked and canonicalized in ScValidateAndSaveAccount
    // if service type is Win32.  If service type is driver, it's up to
    // the I/O system to validate the driver name (it can be NULL and the
    // I/O system will use the default driver name).
    //

    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\path.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Path.c

Abstract:

    Contains image path functions:

        ScIsValidImagePath
        ScImagePathsMatch

Author:

    John Rogers (JohnRo) 10-Apr-1992

Environment:

    User Mode -Win32

Revision History:

    10-Apr-1992 JohnRo
        Created.
    20-May-1992 JohnRo
        Use CONST where possible.

--*/

#include <scpragma.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <scdebug.h>    // SC_ASSERT().
#include <sclib.h>      // My prototypes.
#include <valid.h>      // SERVICE_TYPE_INVALID().
#include <stdlib.h>      // _wcsicmp().
#include <winsvc.h>     // SERVICE_ equates.



BOOL
ScIsValidImagePath(
    IN  LPCWSTR ImagePathName,
    IN  DWORD ServiceType
    )
/*++

Routine Description:

    This function validates a given image path name.
    It makes sure the path name is consistent with the service type.
    For instance, a file name of .SYS is used for SERVICE_DRIVER only.

Arguments:

    ImagePathName - Supplies the image path name to be validated.

    ServiceType - Tells which kind of service the path name must be
        consistent with.  ServiceType must be valid.

Return Value:

    TRUE - The name is valid.

    FALSE - The name is invalid.

--*/
{
    if (ImagePathName == NULL) {
        return (FALSE);   // Not valid.
    } else if ( (*ImagePathName) == L'\0' ) {
        return (FALSE);   // Not valid.
    }

    SC_ASSERT( !SERVICE_TYPE_INVALID( ServiceType ) );

    return TRUE;

} // ScIsValidImagePath


BOOL
ScImagePathsMatch(
    IN  LPCWSTR OnePath,
    IN  LPCWSTR TheOtherPath
    )
{
    SC_ASSERT( OnePath != NULL );
    SC_ASSERT( TheOtherPath != NULL );

    SC_ASSERT( (*OnePath) != L'\0' );
    SC_ASSERT( (*TheOtherPath) != L'\0' );

    if ( _wcsicmp( OnePath, TheOtherPath ) == 0 ) {

        return (TRUE);  // They match.

    } else {

        return (FALSE);  // They don't match.

    }

} // ScImagePathsMatch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\packstr.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    packstr.c

Abstract:

    Contains functions for packing strings into buffers that also contain
    structures.

Author:

    Dan Lafferty (danl)     13-Jan-1992

Environment:

    User Mode -Win32

Revision History:

    13-Jan-1992     danl
        stole from netlib.
    27-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.
        Fixed a UNICODE-related bug.

--*/

#include <scpragma.h>

#include <windef.h>     // IN, OUT, etc.
#include <sclib.h>      // My prototypes.
#include <string.h>     // strncpy
#include <stdlib.h>      // wcsncpy


BOOL
ScCopyStringToBufferW (
    IN      LPCWSTR String OPTIONAL,
    IN      DWORD   CharacterCount,
    IN      LPCWSTR FixedDataEnd,
    IN OUT  LPWSTR  *EndOfVariableData,
    OUT     LPWSTR  *VariableDataPointer,
    IN      const LPBYTE lpBufferStart    OPTIONAL
    )

/*++

Routine Description:

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

    The code is swiped from svcsupp.c written by DavidTr.

    Sample usage:

            LPBYTE FixedDataEnd = OutputBuffer + sizeof(WKSTA_INFO_202);
            LPWSTR EndOfVariableData = OutputBuffer + OutputBufferSize;

            //
            // Copy user name
            //

            ScCopyStringToBuffer(
                UserInfo->UserName.Buffer;
                UserInfo->UserName.Length;
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaInfo->wki202_username,
                NULL
                );

Arguments:

    String - Supplies a pointer to the source string to copy into the
        output buffer.  If String is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of String, not including zero
        terminator.  (This in units of characters - not bytes).

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer or offset to the
        variable data should be written.  Pointer vs. offset is decided
        based on the presence of lpBufferStart

    lpBufferStart - If NULL, VariableDataPointer should be filled with
        a pointer to the string written into the buffer.  If non-NULL,
        VariableDataPointer should be filled with an offset to the
        string written into the buffer.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{
    DWORD CharsNeeded = (CharacterCount + 1);

    //
    // Determine if string will fit, allowing for a zero terminator.  If no,
    // just set the pointer to NULL.
    //

    if ((*EndOfVariableData - CharsNeeded) >= FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= CharsNeeded;

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && String != NULL) {

            wcsncpy(*EndOfVariableData, String, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = L'\0';

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        if (lpBufferStart != NULL)
        {
            *(LPDWORD) VariableDataPointer =
                           (DWORD) ((LPBYTE) *EndOfVariableData - lpBufferStart);
        }
        else
        {
            *VariableDataPointer = *EndOfVariableData;
        }

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        if (lpBufferStart != NULL)
        {
            *(LPDWORD) VariableDataPointer = 0;
        }
        else
        {
            *VariableDataPointer = NULL;
        }

        return FALSE;
    }
} // ScCopyStringToBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\convert.cxx ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    convert.c

Abstract:

    Contains functions for converting unicode and ansi strings.

Author:

    Dan Lafferty (danl)     04-Jan-1992

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

    04-Jan-1992     danl
        created
    20-May-1992 JohnRo
        Use CONST where possible.

--*/

#include <scpragma.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>    // LocalAlloc

#include <string.h>
#include <scdebug.h>    // SC_LOG
#include <sclib.h>      // My prototype.

BOOL
ScConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPCSTR  AnsiIn
    )

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.

Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = ((DWORD) strlen(AnsiIn) + 1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR) LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (*UnicodeOut == NULL) {
        SC_LOG(ERROR,"ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlAnsiStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                (BOOLEAN) FALSE);   // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG(ERROR,
               "ScConvertToUnicode:RtlAnsiStringToUnicodeString Failure %lx\n",
               ntStatus);

        LocalFree(*UnicodeOut);
        *UnicodeOut = NULL;
        return(FALSE);
    }

    return(TRUE);
}


BOOL
ScConvertToAnsi(
    OUT LPSTR    AnsiOut,
    IN  LPCWSTR  UnicodeIn
    )

/*++

Routine Description:

    This function translates a UnicodeString into an Ansi string.

    BEWARE!
        It is assumped that the buffer pointed to by AnsiOut is large
        enough to hold the Unicode String.  Check sizes first.

    If it is desired, UnicodeIn and AnsiIn can point to the same
    location.  Since the ansi string will always be smaller than the
    unicode string, translation can take place in the same buffer.

Arguments:

    UnicodeIn - This is a pointer to a unicode that is to be converted.

    AnsiOut - This is a pointer to a buffer that will contain the
        ansi string on return from this function call.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.

--*/
{

    NTSTATUS        ntStatus;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Initialize the string structures
    //
    RtlInitUnicodeString( &unicodeString, UnicodeIn);

    ansiString.Buffer = AnsiOut;
    ansiString.MaximumLength = unicodeString.MaximumLength;
    ansiString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlUnicodeStringToAnsiString (
                &ansiString,        // Destination
                &unicodeString,     // Source
                (BOOLEAN) FALSE);   // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {


    SC_LOG(ERROR,"ScConvertToAnsi:RtlUnicodeStrintToAnsiString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\sccrypt.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    sccrypt.c

Abstract:

    This module provides support routines to encrypt and decrypt
    a password.

Author:

    Rita Wong      (ritaw)  27-Apr-1992

Environment:

    Contains NT specific code.

Revision History:

--*/

#include <scpragma.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <crypt.h>

#include <windef.h>     // DWORD (needed by scdebug.h).
#include <winerror.h>   // NO_ERROR
#include <winbase.h>    // LocalAlloc

#include <stdlib.h>

#include <scdebug.h>    // STATIC.
#include <svcctl.h>     // SC_RPC_HANDLE
#include <sccrypt.h>    // Exported function prototypes


DWORD
ScEncryptPassword(
    IN  SC_RPC_HANDLE ContextHandle,
    IN  LPWSTR Password,
    OUT LPBYTE *EncryptedPassword,
    OUT LPDWORD EncryptedPasswordSize
    )
/*++

Routine Description:

    This function encrypts a user specified clear text password with
    the user session key gotten from the RPC context handle.

    This is called by the RPC client.

Arguments:

    ContextHandle - Supplies the RPC context handle.

    Password - Supplies the user specified password.

    EncryptedPassword - Receives a pointer to memory which contains
        the encrypted password.  This memory must be freed with LocalFree
        when done.

    EncryptedPasswordSize - Receives the number of bytes of encrypted
        password returned.

Return Value:

    NO_ERROR - Successful encryption.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate the EncryptedPassword
        buffer.

    ERROR_GEN_FAILURE - Any other failures encountered by this function.

--*/
{
    NTSTATUS ntstatus;
    USER_SESSION_KEY SessionKey;

    CLEAR_DATA ClearTextPW;
    DATA_KEY DataKey;
    CYPHER_DATA EncryptPW;


    ntstatus = RtlGetUserSessionKeyClient((PVOID) ContextHandle, &SessionKey);

    if (!NT_SUCCESS(ntstatus))
    {
        SCC_LOG1(ERROR,
                 "ScEncryptPassword: RtlGetUserSessionKeyClient returned "
                 FORMAT_NTSTATUS "\n", ntstatus);

        return RtlNtStatusToDosErrorNoTeb(ntstatus);
    }

    //
    // Encryption includes the NULL terminator.
    //

    ClearTextPW.Length = ((DWORD) wcslen(Password) + 1) * sizeof(WCHAR);
    ClearTextPW.MaximumLength = ClearTextPW.Length;
    ClearTextPW.Buffer = (PVOID) Password;

    DataKey.Length = USER_SESSION_KEY_LENGTH;
    DataKey.MaximumLength = USER_SESSION_KEY_LENGTH;
    DataKey.Buffer = (PVOID) &SessionKey;

    EncryptPW.Length = 0;
    EncryptPW.MaximumLength = 0;
    EncryptPW.Buffer = NULL;

    //
    // Call RtlEncryptData with 0 length so that it will return the
    // required length.
    //

    ntstatus = RtlEncryptData(
                   &ClearTextPW,
                   &DataKey,
                   &EncryptPW
                   );

    if (ntstatus != STATUS_BUFFER_TOO_SMALL)
    {
        SCC_LOG1(ERROR,
                 "ScEncryptPassword: RtlEncryptData returned "
                 FORMAT_NTSTATUS "\n", ntstatus);

        return RtlNtStatusToDosErrorNoTeb(ntstatus);
    }

    if ((EncryptPW.Buffer = (PVOID) LocalAlloc(0, EncryptPW.Length)) == NULL)
    {
        SCC_LOG1(ERROR,
                 "ScEncryptPassword: LocalAlloc failed "
                 FORMAT_DWORD "\n", GetLastError());

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    EncryptPW.MaximumLength = EncryptPW.Length;

    ntstatus = RtlEncryptData(
                   &ClearTextPW,
                   &DataKey,
                   &EncryptPW
                   );

    if (!NT_SUCCESS(ntstatus))
    {
        SCC_LOG1(ERROR,
                 "ScEncryptPassword: RtlEncryptData returned "
                 FORMAT_NTSTATUS "\n", ntstatus);

        LocalFree(EncryptPW.Buffer);
        return RtlNtStatusToDosErrorNoTeb(ntstatus);
    }

    *EncryptedPassword = (LPBYTE) EncryptPW.Buffer;
    *EncryptedPasswordSize = EncryptPW.Length;

    return NO_ERROR;
}


DWORD
ScDecryptPassword(
    IN  SC_RPC_HANDLE ContextHandle,
    IN  LPBYTE EncryptedPassword,
    IN  DWORD EncryptedPasswordSize,
    OUT LPWSTR *Password
    )
/*++

Routine Description:

    This function decrypts a given encrypted password back to clear
    text with the user session key gotten from the RPC context handle.

    This is called by the RPC server.

Arguments:

    ContextHandle - Supplies the RPC context handle.


    EncryptedPassword - Supplies a buffer which contains the encrypted
        password.

    EncryptedPasswordSize - Supplies the number of bytes in
        EncryptedPassword.

    Password - Receives a pointer to the memory which contains the
        clear text password.  This memory must be freed with LocalFree
        when done.

Return Value:

    NO_ERROR - Successful encryption.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate the Password buffer.

    ERROR_GEN_FAILURE - Any other failures encountered by this function.

--*/
{
    NTSTATUS ntstatus;
    USER_SESSION_KEY SessionKey;

    CYPHER_DATA EncryptPW;
    DATA_KEY DataKey;
    CLEAR_DATA ClearTextPW;


    ntstatus = RtlGetUserSessionKeyServer((PVOID) ContextHandle, &SessionKey);

    if (!NT_SUCCESS(ntstatus))
    {
        SC_LOG1(ERROR,
                 "ScDecryptPassword: RtlGetUserSessionKeyClient returned "
                 FORMAT_NTSTATUS "\n", ntstatus);

        return RtlNtStatusToDosErrorNoTeb(ntstatus);
    }

    EncryptPW.Length = EncryptedPasswordSize;
    EncryptPW.MaximumLength = EncryptedPasswordSize;
    EncryptPW.Buffer = (PVOID) EncryptedPassword;

    DataKey.Length = USER_SESSION_KEY_LENGTH;
    DataKey.MaximumLength = USER_SESSION_KEY_LENGTH;
    DataKey.Buffer = (PVOID) &SessionKey;

    ClearTextPW.Length = 0;
    ClearTextPW.MaximumLength = 0;
    ClearTextPW.Buffer = NULL;

    //
    // Call RtlDecryptData with 0 length so that it will return the
    // required length.
    //
    ntstatus = RtlDecryptData(
                   &EncryptPW,
                   &DataKey,
                   &ClearTextPW
                   );

    if (ntstatus != STATUS_BUFFER_TOO_SMALL)
    {
        if (ntstatus == STATUS_SUCCESS && ClearTextPW.Length == 0)
        {
            //
            // Assume empty password
            //
            *Password = NULL;
            return NO_ERROR;
        }

        SC_LOG1(ERROR,
                 "ScDecryptPassword: RtlDecryptData returned "
                 FORMAT_NTSTATUS "\n", ntstatus);

        return RtlNtStatusToDosErrorNoTeb(ntstatus);
    }

    //
    // Allocate exact size needed because NULL terminator is included in
    // the encrypted string.
    //
    if ((ClearTextPW.Buffer = (PVOID) LocalAlloc(LMEM_ZEROINIT, ClearTextPW.Length)) == NULL)
    {
        SC_LOG1(ERROR,
                 "ScDecryptPassword: LocalAlloc failed "
                 FORMAT_DWORD "\n", GetLastError());

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ClearTextPW.MaximumLength = ClearTextPW.Length;

    ntstatus = RtlDecryptData(
                   &EncryptPW,
                   &DataKey,
                   &ClearTextPW
                   );

    if (!NT_SUCCESS(ntstatus))
    {
        SC_LOG1(ERROR,
                 "ScDecryptPassword: RtlDecryptData returned "
                 FORMAT_NTSTATUS "\n", ntstatus);

        return RtlNtStatusToDosErrorNoTeb(ntstatus);
    }

    *Password = (LPWSTR) ClearTextPW.Buffer;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\scseclib.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    scseclib.c

Abstract:

    This module provides support routines to simplify the creation of
    security descriptors.

Author:

    Rita Wong      (ritaw)  27-Feb-1991
    Cliff Van Dyke (cliffv)
    Richard Ward   (richardw) 8-April-92  Modified for Cairo

Environment:

    Contains NT specific code.

Revision History:

    13-Apr-1992 JohnRo
        Made changes suggested by PC-LINT.
--*/

#include <scpragma.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windef.h>     // DWORD (needed by scdebug.h).
#include <winbase.h>
#include <stdlib.h>        // max()
#include <scdebug.h>    // STATIC.
#include <scseclib.h>


//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

NTSTATUS
ScInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    );

NTSTATUS
ScInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    );

NTSTATUS
ScInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//


//
// NT well-known SIDs
//

PSID NullSid              = NULL;     // No members SID
PSID WorldSid             = NULL;     // All users SID
PSID LocalSid             = NULL;     // NT local users SID
PSID NetworkSid           = NULL;     // NT remote users SID
PSID LocalSystemSid       = NULL;     // NT system processes SID
PSID LocalServiceSid      = NULL;     // NT LocalService SID
PSID NetworkServiceSid    = NULL;     // NT NetworkService SID
PSID BuiltinDomainSid     = NULL;     // Domain Id of the Builtin Domain
PSID AuthenticatedUserSid = NULL;     // NT authenticated users SID
PSID AnonymousLogonSid    = NULL;     // Anonymous Logon SID

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//
PSID AliasAdminsSid       = NULL;
PSID AliasUsersSid        = NULL;
PSID AliasGuestsSid       = NULL;
PSID AliasPowerUsersSid   = NULL;
PSID AliasAccountOpsSid   = NULL;
PSID AliasSystemOpsSid    = NULL;
PSID AliasPrintOpsSid     = NULL;
PSID AliasBackupOpsSid    = NULL;


//
// Data describing the well-known SIDs created by ScCreateWellKnownSids.
//

struct _SID_DATA {
    PSID *Sid;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    ULONG SubAuthority;
} SidData[] = {
 {&NullSid,              SECURITY_NULL_SID_AUTHORITY,  SECURITY_NULL_RID},
 {&WorldSid,             SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID},
 {&LocalSid,             SECURITY_LOCAL_SID_AUTHORITY, SECURITY_LOCAL_RID},
 {&NetworkSid,           SECURITY_NT_AUTHORITY,        SECURITY_NETWORK_RID},
 {&LocalSystemSid,       SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SYSTEM_RID},
 {&LocalServiceSid,      SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SERVICE_RID},
 {&NetworkServiceSid,    SECURITY_NT_AUTHORITY,        SECURITY_NETWORK_SERVICE_RID},
 {&BuiltinDomainSid,     SECURITY_NT_AUTHORITY,        SECURITY_BUILTIN_DOMAIN_RID},
 {&AuthenticatedUserSid, SECURITY_NT_AUTHORITY,        SECURITY_AUTHENTICATED_USER_RID},
 {&AnonymousLogonSid,    SECURITY_NT_AUTHORITY,        SECURITY_ANONYMOUS_LOGON_RID}
};


struct _BUILTIN_DOMAIN_SID_DATA {
    PSID *Sid;
    ULONG RelativeId;
} BuiltinDomainSidData[] = {
    { &AliasAdminsSid,      DOMAIN_ALIAS_RID_ADMINS },
    { &AliasUsersSid,       DOMAIN_ALIAS_RID_USERS },
    { &AliasGuestsSid,      DOMAIN_ALIAS_RID_GUESTS },
    { &AliasPowerUsersSid,  DOMAIN_ALIAS_RID_POWER_USERS },
    { &AliasAccountOpsSid,  DOMAIN_ALIAS_RID_ACCOUNT_OPS },
    { &AliasSystemOpsSid,   DOMAIN_ALIAS_RID_SYSTEM_OPS },
    { &AliasPrintOpsSid,    DOMAIN_ALIAS_RID_PRINT_OPS },
    { &AliasBackupOpsSid,   DOMAIN_ALIAS_RID_BACKUP_OPS }
};



NTSTATUS
ScCreateWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function creates some well-known SIDs and store them in global
    variables:

        //
        // NT well-known SIDs
        //

        PSID NullSid;                     // No members SID
        PSID WorldSid;                    // All users SID
        PSID LocalSid;                    // NT local users SID
        PSID NetworkSid;                  // NT remote users SID
        PSID LocalSystemSid;              // NT system processes SID
        PSID LocalServiceSid;             // NT LocalService SID
        PSID NetworkServiceSid;           // NT NetworkService SID
        PSID BuiltinDomainSid;            // Domain Id of the Builtin Domain
        PSID AuthenticatedUserSid;        // NT authenticated users SID
        PSID AnonymousLogonSid;           // NT anonymous logon

        //
        // Well Known Aliases.
        //
        // These are aliases that are relative to the built-in domain.
        //

        PSID AliasAdminsSid;
        PSID AliasUsersSid;
        PSID AliasGuestsSid;
        PSID AliasPowerUsersSid;
        PSID AliasAccountOpsSid;
        PSID AliasSystemOpsSid;
        PSID AliasPrintOpsSid;
        PSID AliasBackupOpsSid;

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/
{
    NTSTATUS ntstatus;
    ULONG i;


    //
    // Allocate and initialize well-known SIDs which aren't relative to
    // the domain Id.
    //

    for (i = 0; i < (sizeof(SidData) / sizeof(SidData[0])) ; i++) {

        ntstatus = ScAllocateAndInitializeSid(
                       SidData[i].Sid,
                       &(SidData[i].IdentifierAuthority),
                       1);

        if (! NT_SUCCESS(ntstatus)) {
            return STATUS_NO_MEMORY;
        }

        *(RtlSubAuthoritySid(*(SidData[i].Sid), 0)) = SidData[i].SubAuthority;
    }

    //
    // Build each SID which is relative to the Builtin Domain Id.
    //

    for ( i = 0;
          i < (sizeof(BuiltinDomainSidData) / sizeof(BuiltinDomainSidData[0]));
          i++) {

        ntstatus = ScDomainIdToSid(
                       BuiltinDomainSid,
                       BuiltinDomainSidData[i].RelativeId,
                       BuiltinDomainSidData[i].Sid );

        if (! NT_SUCCESS(ntstatus)) {
            return STATUS_NO_MEMORY;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ScAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    )
/*++

Routine Description:

    This function allocates memory for a SID and initializes it.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/
{
    *Sid = (PSID) RtlAllocateHeap(
                      RtlProcessHeap(), 0,
                      RtlLengthRequiredSid(SubAuthorityCount)
                      );

    if (*Sid == NULL) {
        return STATUS_NO_MEMORY;
    }

    (VOID) RtlInitializeSid(
            *Sid,
            IdentifierAuthority,
            (UCHAR)SubAuthorityCount );

    return STATUS_SUCCESS;
}


NTSTATUS
ScDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Given a domain Id and a relative ID create a SID.

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

    Sid - Returns a pointer to an allocated buffer containing the resultant
            Sid.  Free this buffer using RtlFreeHeap.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

    Any error status from RtlCopySid

--*/
{
    NTSTATUS ntstatus;
    UCHAR DomainIdSubAuthorityCount; // Number of sub authorities in domain ID
    ULONG SidLength;    // Length of newly allocated SID

    PVOID HeapHandle = RtlProcessHeap();


    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    SidLength = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((*Sid = (PSID) RtlAllocateHeap(
                           HeapHandle, 0,
                           SidLength
                           )) == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //
    ntstatus = RtlCopySid(SidLength, *Sid, DomainId);

    if (! NT_SUCCESS(ntstatus)) {
        (void) RtlFreeHeap(HeapHandle, 0, *Sid);
        return ntstatus;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( *Sid ))) ++;
    *RtlSubAuthoritySid( *Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return STATUS_SUCCESS;
}


NTSTATUS
ScCreateAndSetSD(
    IN  PSC_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates an absolute security descriptor containing
    the supplied ACE information.

    A sample usage of this function:

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        SE_ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &AliasAdminsSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        PSECURITY_DESCRIPTOR WkstaSecurityDescriptor;


        return SeCreateAndSetSD(
                   AceData,
                   4,
                   LocalSystemSid,
                   LocalSystemSid,
                   &WkstaSecurityDescriptor
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.  If not specified, a security descriptor with no owner
        will be created.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.  If not specified, a security descriptor with no primary
        group will be created.

    NewDescriptor - Returns a pointer to the absolute security descriptor
        allocated using RtlAllocateHeap.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the user security object created by calling this function may be
                freed up by calling RtlDeleteSecurityObject().

--*/
{

    NTSTATUS ntstatus;
    ULONG i;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PACL Dacl = NULL;   // Pointer to the DACL portion of above buffer
    PACL Sacl = NULL;   // Pointer to the SACL portion of above buffer

    ULONG DaclSize = sizeof(ACL);
    ULONG SaclSize = sizeof(ACL);
    ULONG MaxAceSize = 0;
    PACCESS_ALLOWED_ACE MaxAce = NULL;

    PCHAR CurrentAvailable;
    ULONG Size;

    PVOID HeapHandle = RtlProcessHeap();


    ASSERT( AceCount > 0 );

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //

    for (i = 0; i < AceCount; i++) {
        ULONG AceSize;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            AceSize += sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG);
            DaclSize += AceSize;
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG);
            DaclSize += AceSize;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE) - sizeof(ULONG);
            SaclSize += AceSize;
            break;

        default:
            return STATUS_INVALID_PARAMETER;
        }

        MaxAceSize = max( MaxAceSize, AceSize );
    }

    //
    // Allocate a chunk of memory large enough for the security
    // descriptor, the DACL, the SACL and all ACEs.
    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    Size = SECURITY_DESCRIPTOR_MIN_LENGTH;
    if ( DaclSize != sizeof(ACL) ) {
        Size += DaclSize;
    }
    if ( SaclSize != sizeof(ACL) ) {
        Size += SaclSize;
    }

    if ((AbsoluteSd = RtlAllocateHeap(
                          HeapHandle, 0,
                          Size
                          )) == NULL) {
        KdPrint(("SeCreateAndSetSD: No memory to create absolute SD\n"));
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the Dacl and Sacl
    //

    CurrentAvailable = (PCHAR)AbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {
        Dacl = (PACL)CurrentAvailable;
        CurrentAvailable += DaclSize;

        ntstatus = RtlCreateAcl( Dacl, DaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            KdPrint(("ScCreateAndSetSD: Fail DACL Create %08lx\n",
                     ntstatus));
            goto Cleanup;
        }
    }

    if ( SaclSize != sizeof(ACL) ) {
        Sacl = (PACL)CurrentAvailable;
        CurrentAvailable += SaclSize;

        ntstatus = RtlCreateAcl( Sacl, SaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            KdPrint(("ScCreateAndSetSD: Fail SACL Create %08lx\n",
                     ntstatus));
            goto Cleanup;
        }
    }

    //
    // Allocate a temporary buffer big enough for the biggest ACE.
    //

    if ((MaxAce = (PACCESS_ALLOWED_ACE) RtlAllocateHeap(
                      HeapHandle, 0,
                      MaxAceSize
                      )) == NULL ) {
        KdPrint(("ScCreateAndSetSD: No memory to create max ace\n"));
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize each ACE, and append it into the end of the DACL or SACL.
    //

    for (i = 0; i < AceCount; i++) {
        ULONG AceSize;
        PACL CurrentAcl;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:

            AceSize += sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG);
            CurrentAcl = Dacl;
            ntstatus = ScInitializeAllowedAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG);
            CurrentAcl = Dacl;
            ntstatus = ScInitializeDeniedAce(
                           (PACCESS_DENIED_ACE) MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE) - sizeof(ULONG);
            CurrentAcl = Sacl;
            ntstatus = ScInitializeAuditAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        default:
            SC_LOG2(ERROR,
                    "ScCreateAndSetSD: Invalid AceType %d in ACE %d\n",
                    AceData[i].AceType,
                    i);

            ASSERT(FALSE);
            CurrentAcl = NULL;
            ntstatus = STATUS_UNSUCCESSFUL;
        }

        if ( !NT_SUCCESS( ntstatus ) ) {
            KdPrint((
                    "ScCreateAndSetSD: Fail InitAce i: %d ntstatus: %08lx\n",
                     i, ntstatus));
            goto Cleanup;
        }

        //
        // Append the initialized ACE to the end of DACL or SACL
        //

        if (! NT_SUCCESS (ntstatus = RtlAddAce(
                                         CurrentAcl,
                                         ACL_REVISION,
                                         MAXULONG,
                                         MaxAce,
                                         AceSize
                                         ))) {
            KdPrint((
                    "ScCreateAndSetSD: Fail add ace i: %d ntstatus: %08lx\n",
                    i, ntstatus));
            goto Cleanup;
        }
    }

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = OwnerSid
    // Group = GroupSid
    // Dacl  = Dacl
    // Sacl  = Sacl
    //

    if (! NT_SUCCESS(ntstatus = RtlCreateSecurityDescriptor(
                                    AbsoluteSd,
                                    SECURITY_DESCRIPTOR_REVISION
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetOwnerSecurityDescriptor(
                                    AbsoluteSd,
                                    OwnerSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetGroupSecurityDescriptor(
                                    AbsoluteSd,
                                    GroupSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetDaclSecurityDescriptor(
                                    AbsoluteSd,
                                    (BOOLEAN)(Dacl ? TRUE : FALSE),
                                    Dacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetSaclSecurityDescriptor(
                                    AbsoluteSd,
                                    (BOOLEAN)(Sacl ? TRUE : FALSE),
                                    Sacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    //
    // Done
    //

    ntstatus = STATUS_SUCCESS;

    //
    // Clean up
    //

Cleanup:
    //
    // Either return the security descriptor to the caller or delete it
    //

    if ( NT_SUCCESS( ntstatus ) ) {
        *NewDescriptor = AbsoluteSd;
    } else if ( AbsoluteSd != NULL ) {
        RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
    }

    //
    // Delete the temporary ACE
    //

    if ( MaxAce != NULL ) {
        RtlFreeHeap(HeapHandle, 0, MaxAce);
    }

    return ntstatus;
}


NTSTATUS
ScCreateUserSecurityObject(
    IN  PSECURITY_DESCRIPTOR ParentSD,
    IN  PSC_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  BOOLEAN IsDirectoryObject,
    IN  BOOLEAN UseImpersonationToken,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates the DACL for the security descriptor based on
    on the ACE information specified, and creates the security descriptor
    which becomes the user-mode security object.

    A sample usage of this function:

        //
        // Structure that describes the mapping of Generic access rights to
        // object specific access rights for the ConfigurationInfo object.
        //

        GENERIC_MAPPING WsConfigInfoMapping = {
            STANDARD_RIGHTS_READ            |      // Generic read
                WKSTA_CONFIG_GUEST_INFO_GET |
                WKSTA_CONFIG_USER_INFO_GET  |
                WKSTA_CONFIG_ADMIN_INFO_GET,
            STANDARD_RIGHTS_WRITE |                // Generic write
                WKSTA_CONFIG_INFO_SET,
            STANDARD_RIGHTS_EXECUTE,               // Generic execute
            WKSTA_CONFIG_ALL_ACCESS                // Generic all
            };

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        SE_ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &AliasAdminsSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        PSECURITY_DESCRIPTOR WkstaSecurityObject;


        return ScCreateUserSecurityObject(
                   AceData,
                   4,
                   LocalSystemSid,
                   LocalSystemSid,
                   FALSE,
                   &WsConfigInfoMapping,
                   &WkstaSecurityObject
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.

    IsDirectoryObject - Supplies the flag which indicates whether the
        user-mode object is a directory object.

    GenericMapping - Supplies the pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

    NewDescriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the user security object created by calling this function may be
                freed up by calling RtlDeleteSecurityObject().

--*/
{
    NTSTATUS ntstatus;
    PSECURITY_DESCRIPTOR AbsoluteSd;
    HANDLE TokenHandle;
    PVOID HeapHandle = RtlProcessHeap();

    ntstatus = ScCreateAndSetSD(
                   AceData,
                   AceCount,
                   OwnerSid,
                   GroupSid,
                   &AbsoluteSd
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint((
                "ScCreateUserSecurityObject: ScCreateAndSetSD returned "
                "%08lx\n", ntstatus));
        return ntstatus;
    }

    if (UseImpersonationToken) {
        ntstatus = NtOpenThreadToken(
                       NtCurrentThread(),
                       TOKEN_QUERY,
                       FALSE,
                       &TokenHandle
                       );
    }
    else {
        ntstatus = NtOpenProcessToken(
                       NtCurrentProcess(),
                       TOKEN_QUERY,
                       &TokenHandle
                       );
    }

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint((
                "ScCreateUserSecurityObject: NtOpen...Token returned "
                "%08lx\n", ntstatus));
        (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
        return ntstatus;
    }

    //
    // Create the security object (a user-mode object is really a pseudo-
    // object represented by a security descriptor that have relative
    // pointers to SIDs and ACLs).  This routine allocates the memory to
    // hold the relative security descriptor so the memory allocated for the
    // DACL, ACEs, and the absolute descriptor can be freed.
    //
    ntstatus = RtlNewSecurityObject(
                   ParentSD,               // Parent descriptor
                   AbsoluteSd,             // Creator descriptor
                   NewDescriptor,          // Pointer to new descriptor
                   IsDirectoryObject,      // Is directory object
                   TokenHandle,            // Token
                   GenericMapping          // Generic mapping
                   );

    (void) NtClose(TokenHandle);

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint((
                "RtlCreateUserSecurityObject: RtlNewSecurityObject returned "
                "%08lx\n", ntstatus));
    }

    //
    // Free dynamic memory before returning
    //
    (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
    return ntstatus;
}


NTSTATUS
ScInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an allowed type ACE.

Arguments:

    AllowedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is allowed
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AllowedAce->Header.AceSize = AceSize;
    AllowedAce->Header.AceFlags = AceFlags | InheritFlags;

    AllowedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AllowedSid),
               &(AllowedAce->SidStart),
               AllowedSid
               );
}


NTSTATUS
ScInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into a denied type ACE.

Arguments:

    DeniedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the denied access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is denied
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    DeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    DeniedAce->Header.AceSize = AceSize;
    DeniedAce->Header.AceFlags = AceFlags | InheritFlags;

    DeniedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(DeniedSid),
               &(DeniedAce->SidStart),
               DeniedSid
               );
}


NTSTATUS
ScInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an audit type ACE.

Arguments:

    AuditAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AuditSid - Supplies the pointer to the SID of user/group which is to be
        audited.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AuditAce->Header.AceSize = AceSize;
    AuditAce->Header.AceFlags = AceFlags | InheritFlags;

    AuditAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AuditSid),
               &(AuditAce->SidStart),
               AuditSid
               );
}

DWORD
ScCreateStartEventSD(
    PSECURITY_DESCRIPTOR    *pEventSD
    )

/*++

Routine Description:

    This routine creates a security descriptor for the
    SC_INTERNAL_START_EVENT.  This function may be called from
    either the client or server side.

    NOTE:  it is up to the caller to free the memory for the
    security descriptor.

Arguments:

    pEventSD - Pointer to a location where the pointer to
        the newly created security descriptor can be placed.

Return Value:

    NO_ERROR - indicates success.

    all other values indicate failure.

--*/
{
    NTSTATUS                ntstatus;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;

    SID_IDENTIFIER_AUTHORITY    WorldSidAuth[1] = {
            SECURITY_WORLD_SID_AUTHORITY};
    SID_IDENTIFIER_AUTHORITY    LocalSystemSidAuth[1] = {
            SECURITY_NT_AUTHORITY};

    SC_ACE_DATA AceData[2] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            SYNCHRONIZE,    &WorldSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            GENERIC_ALL,    &LocalSystemSid}
        };

    //
    // Check against NULL for these SIDs as the client-side code calls
    // this routine and doesn't call ScCreateWellKnownSids.  These
    // should always be non-NULL by this point in services.exe itself.
    //

    if (WorldSid == NULL) {
        if (!AllocateAndInitializeSid(
                    WorldSidAuth,
                    1,
                    SECURITY_WORLD_RID,
                    0,0,0,0,0,0,0,
                    &WorldSid))  {

            SC_LOG1(ERROR, "AllocateAndInitWorldSid failed %d\n",GetLastError());
            return(GetLastError());
        }
    }

    if (LocalSystemSid == NULL) {
        if (!AllocateAndInitializeSid(
                    LocalSystemSidAuth,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0,0,0,0,0,0,0,
                    &LocalSystemSid)) {

            SC_LOG1(ERROR, "AllocateAndInitLocalSysSid failed %d\n",GetLastError());
            return(GetLastError());
        }
    }

    ntstatus = ScCreateAndSetSD(
                AceData,
                2,
                LocalSystemSid,
                LocalSystemSid,
                &SecurityDescriptor);

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR, "ScCreateAndSetSD failed %0x%lx\n",ntstatus);
        return(RtlNtStatusToDosError(ntstatus));
    }

    *pEventSD = SecurityDescriptor;
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\strarray.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    StrArray.c

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

    These functions are useful for the NetServerDiskEnum and NetConfigGetAll
    APIs, and possibly others.

Author:

    John Rogers (JohnRo) 24-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Note:

    This function assumes that the machine's default codepage is the same
    as the LAN's default codepage.

Revision History:

    24-Oct-1991 JohnRo
        Created.
    02-Jan-1992 JohnRo
        Moved my RxpCopyStrArrayToTStrArray() from RxCommon to NetLib,
        and renamed it.  Added some other random functions.
    30-Jan-1992 JohnRo
        Fixed off-by-one bug in NetpAddTStrToTStrArray().
        Enhanced handling of "empty" TCHAR string arrays.
        Use TCHAR_EOS equate.
    29-Apr-1992 RitaW
        Changed for service controller use.

--*/

#include <scpragma.h>

#include <stdlib.h>
#include <string.h>             // strlen() for codepage strings.

#include <nt.h>
#include <ntrtl.h>              // Needed by <scdebug.h>

// These must be included first:

#include <windef.h>             // IN, VOID, LPWSTR, etc.

// These can be in any order:

#include <strarray.h>           // Exported function prototypes
#include <tstr.h>               // WCSSIZE

#include <scdebug.h>            // SC_ASSERT


VOID
ScAddWStrToWStrArray (
    IN OUT LPWSTR DestArray,
    IN LPWSTR Src
    )
{
    DWORD AddSize;  // byte count (including null char) of string being added
    LPWSTR DestStringStart;
    DWORD NewArraySize;
    DWORD OldArraySize;

    SC_ASSERT( DestArray != NULL );
    SC_ASSERT( Src != NULL );
    if ((DestArray == NULL) || (Src == NULL)) {
        return;
    }

    OldArraySize = ScWStrArraySize( DestArray );  // May be 2 bytes.

    SC_ASSERT( wcslen(Src) > 0 );  // We couldn't tell from end of array.

    AddSize = (DWORD) WCSSIZE( Src );

    NewArraySize = OldArraySize + AddSize;

    SC_ASSERT( NewArraySize > 0 );  // We couldn't tell from end of array.

    //
    // Figure-out where new string would start.  Note that OldArraySize
    // includes the null char which was the end of the array, so we have
    // to subtract a character to start the new one where that null char is.
    //
    DestStringStart = (LPWSTR) ((DWORD_PTR) DestArray + OldArraySize-sizeof(WCHAR));
    SC_ASSERT( DestStringStart != NULL );

    (void) wcscpy(
            DestStringStart,            // dest
            Src);                       // src

    // Mark end of array.
    DestArray[NewArraySize / sizeof(WCHAR) - 1] = 0;

    SC_ASSERT( ! ScIsWStrArrayEmpty( DestArray ) );

} // ScAddWStrToWStrArray


#if DBG

VOID
ScDisplayWStrArray (
    IN LPWSTR Array
    )
{
    LPWSTR CurrentEntry = Array;

    if (Array == NULL) {
        return;
    }

    if (*CurrentEntry == 0) {
        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP | DEBUG_WARNING | DEBUG_CONFIG,
                   "   (empty)\n"));
    } else {
        while (*CurrentEntry != 0) {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_DEPEND_DUMP | DEBUG_WARNING | DEBUG_CONFIG,
                       "   "  FORMAT_LPWSTR "\n",
                       (LPWSTR)CurrentEntry));

            CurrentEntry += ( wcslen( CurrentEntry ) + 1 );
        }
    }

} // ScDisplayWStrArray

#endif // DBG


DWORD
ScWStrArraySize(
    IN LPWSTR Array
    )
{
    DWORD ArrayByteCount = 0;
    LPWSTR Entry = Array;

    if (Array == NULL) {
        return(0);
    }

    //
    // Loop for each string in the array.
    //
    while ( (*Entry) != 0 ) {

        DWORD EntryByteCount = (DWORD) WCSSIZE(Entry);  // This entry and its null.

        ArrayByteCount += EntryByteCount;

        Entry = (LPWSTR) ((LPBYTE) Entry + EntryByteCount);
    }

    ArrayByteCount += sizeof(WCHAR);    // Indicate end of array.

    return (ArrayByteCount);

} // ScWStrArraySize


DWORD
ScAStrArraySize(
    IN LPSTR Array
    )
{
    DWORD ArrayByteCount = 0;
    LPSTR Entry = Array;


    if (Array == NULL) {
        return(0);
    }

    //
    // Loop for each string in the array.
    //
    while ( (*Entry) != 0 ) {

        DWORD EntryByteCount = (DWORD) strlen(Entry) + sizeof(CHAR);

        ArrayByteCount += EntryByteCount;

        Entry = (LPSTR) ((LPBYTE) Entry + EntryByteCount);
    }

    ArrayByteCount += sizeof(CHAR);    // Indicate end of array.

    return (ArrayByteCount);

} // ScAStrArraySize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\util.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Contains miscellaneous utility functions used by the Service
    Controller:

        ScIsValidServiceName

Author:

    Rita Wong (ritaw)     15-Mar-1992

Environment:

    User Mode -Win32

Revision History:

    11-Apr-1992 JohnRo
        Added an assertion check.
        Include <sclib.h> so compiler checks prototypes.
    20-May-1992 JohnRo
        winsvc.h and related file cleanup.

--*/

#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <scdebug.h>    // SC_ASSERT().
#include <sclib.h>      // My prototype.
#include <valid.h>      // MAX_SERVICE_NAME_LENGTH



BOOL
ScIsValidServiceName(
    IN  LPCWSTR ServiceName
    )
/*++

Routine Description:

    This function validates a given service name.  The name length
    cannot be greater than 256 characters, and must not contain any
    forward-slash, or back-slash.

Arguments:

    ServiceName - Supplies the service name to be validated.

Return Value:

    TRUE - The name is valid.

    FALSE - The name is invalid.

--*/
{
    LPCWSTR IllegalChars = L"\\/";
    DWORD NameLength;

    SC_ASSERT( ServiceName != NULL );  // Avoid memory access fault in wcslen().

    if (*ServiceName == 0) {
        return FALSE;
    }

    if ((NameLength = (DWORD) wcslen(ServiceName)) > MAX_SERVICE_NAME_LENGTH) {
        return FALSE;
    }

    if (wcscspn(ServiceName, IllegalChars) < NameLength) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\lib\valid.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    valid.c

Abstract:

    Contains validation routines for service controller parameters.

Author:

    Dan Lafferty (danl) 29-Mar-1992

Environment:

    User Mode - Win32

Revision History:

    29-Mar-1992 danl
        Created
    10-Apr-1992 JohnRo
        Include <valid.h> so compiler checks prototypes.

--*/

//
// INCLUDES
//
#include <nt.h>
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h when ntrtl is present
#include <windows.h>    // CRITICAL_SECTION

#include <scdebug.h>    // SC_LOG
#include <winsvc.h>     // SERVICE_STATUS
#include <valid.h>      // My prototypes.




BOOL
ScCurrentStateInvalid(
    DWORD   dwCurrentState
    )
/*++

Routine Description:

    This function returns TRUE if the CurrentState is invalid.
    Otherwise FALSE is returned.

Arguments:

    dwCurrentState - This is the ServiceState that is being validiated.

Return Value:

    TRUE - The CurrentState is invalid.

    FALSE - The CurrentState is valid.

Note:


--*/
{
    if ((dwCurrentState == SERVICE_STOPPED)             ||
        (dwCurrentState == SERVICE_START_PENDING)       ||
        (dwCurrentState == SERVICE_STOP_PENDING)        ||
        (dwCurrentState == SERVICE_RUNNING)             ||
        (dwCurrentState == SERVICE_CONTINUE_PENDING)    ||
        (dwCurrentState == SERVICE_PAUSE_PENDING)       ||
        (dwCurrentState == SERVICE_PAUSED )) {

        return(FALSE);
    }
    return(TRUE);
}


DWORD
ScValidateMultiSZ(
    LPCWSTR lpStrings,
    DWORD   cbStrings
    )

/*++

Routine Description:

    This function takes a MULTI_SZ value read in from the registry or
    passed in via RPC and validates it.

Arguments:



Return Value:



--*/

{
    DWORD  dwLastChar;

    //
    // Make sure the MULTI_SZ is well-formed. As long as it is properly
    // double NULL terminated, things should be ok.
    //
    if ((cbStrings % 2) ||
        (cbStrings < sizeof(WCHAR)*2)) {

        //
        // There's an odd number of bytes, this can't be well-formed
        //
        return ERROR_INVALID_PARAMETER;
    }

    dwLastChar = (cbStrings / sizeof(WCHAR)) - 1;

    if ((lpStrings[dwLastChar]     != L'\0') ||
        (lpStrings[dwLastChar - 1] != L'\0')) {

        //
        // The buffer is not double-NUL terminated
        //
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\sc\sc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    SC.C

Abstract:

    Test Routines for the Service Controller.

Author:

    Dan Lafferty    (danl)  08-May-1991

Environment:

    User Mode - Win32

Revision History:

    09-Feb-1992     danl
        Modified to work with new service controller.
    08-May-1991     danl
        created

--*/

//
// INCLUDES
//
#include <scpragma.h>

#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h

#include <stdlib.h>     // atoi
#include <conio.h>      // getche
#include <string.h>     // strcmp
#include <windows.h>    // win32 typedefs
#include <tstr.h>       // Unicode
#include <tchar.h>      // Unicode from CRT

#include <winsvc.h>     // Service Control Manager API.
#include <winsvcp.h>    // Internal Service Control Manager API

#include <sddl.h>       // Security descriptor <--> string APIs

#include "msg.h"

//
// CONSTANTS
//

#define DEFAULT_ENUM_BUFFER_SIZE    4096
#define DEFAULT_ENUM_BUFFER_STRING  L"4096"

#define MESSAGE_BUFFER_LENGTH       1024


//
// TYPE DEFINITIONS
//

typedef union
{
    LPSERVICE_STATUS         Regular;
    LPSERVICE_STATUS_PROCESS Ex;
}
STATUS_UNION, *LPSTATUS_UNION;


WCHAR  MessageBuffer[MESSAGE_BUFFER_LENGTH];
HANDLE g_hStdOut;


//
// FUNCTION PROTOTYPES
//

LPWSTR
GetErrorText(
    IN  DWORD Error
    );

VOID
DisplayStatus (
    IN  LPTSTR              ServiceName,
    IN  LPTSTR              DisplayName,
    IN  LPSTATUS_UNION      ServiceStatus,
    IN  BOOL                fIsStatusOld
    );

VOID
Usage(
    VOID
    );

VOID
ConfigUsage(
    VOID
    );

VOID
ChangeFailureUsage(
    VOID
    );

DWORD
SendControlToService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  DWORD       control,
    OUT LPSC_HANDLE lphService
    );

DWORD
SendConfigToService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *Argv,
    IN  DWORD       argc,
    OUT LPSC_HANDLE lphService
    );

DWORD
ChangeServiceDescription(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      pNewDescription,
    OUT LPSC_HANDLE lphService
    );

DWORD
ChangeServiceFailure(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *argv,
    IN  DWORD       dwArgCount,
    OUT LPSC_HANDLE lphService
    );

DWORD
GetServiceConfig(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufferSize,
    OUT LPSC_HANDLE lphService
    );

DWORD
GetConfigInfo(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufferSize,
    OUT LPSC_HANDLE lphService,
    IN  DWORD       dwInfoLevel
    );

DWORD
GetServiceLockStatus(
    IN  SC_HANDLE   hScManager,
    IN  DWORD       bufferSize
    );

VOID
EnumDepend(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufSize
    );

VOID
ShowSecurity(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName
    );

VOID
SetSecurity(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  LPTSTR      lpServiceSD
    );

VOID
LockServiceActiveDatabase(
    IN SC_HANDLE    hScManager
    );

DWORD
DoCreateService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *argv,
    IN  DWORD       argc
    );

VOID
CreateUsage(
    VOID
    );

VOID
FormatAndDisplayMessage(
    DWORD  dwMessageId,
    LPWSTR *lplpInsertionStrings
    );

VOID
MyWriteConsole(
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    );

VOID
APISucceeded(
    LPWSTR  lpAPI
    );

VOID
APIFailed(
    LPWSTR  lpAPI,
    DWORD   dwError
    );

VOID
APINeedsLargerBuffer(
    LPWSTR lpAPI,
    UINT   uMsg,
    DWORD  dwBufSize,
    DWORD  dwResumeIndex
    );

VOID
APIInvalidField(
    LPWSTR lpField
    );

int 
GetPromptCharacter(
    DWORD msgId
    );


//
// MACROS
//

#define OPEN_MANAGER(dwAccess)                                               \
                                                                             \
                        hScManager = OpenSCManager(pServerName,              \
                                                   NULL,                     \
                                                   dwAccess);                \
                                                                             \
                        if (hScManager == NULL)                              \
                        {                                                    \
                            APIFailed(L"OpenSCManager", GetLastError());     \
                            goto CleanExit;                                  \
                        }                                                    \



/****************************************************************************/
int __cdecl
wmain (
    DWORD       argc,
    LPWSTR      argv[]
    )

/*++

Routine Description:

    Allows manual testing of the Service Controller by typing commands on
    the command line.


Arguments:



Return Value:



--*/

{
    DWORD                            status;
    LPTSTR                           *argPtr;
    LPBYTE                           buffer       = NULL;
    LPENUM_SERVICE_STATUS            enumBuffer   = NULL;
    LPENUM_SERVICE_STATUS_PROCESS    enumBufferEx = NULL;
    STATUS_UNION                     statusBuffer;
    SC_HANDLE                        hScManager = NULL;
    SC_HANDLE                        hService   = NULL;

    DWORD           entriesRead;
    DWORD           type;
    DWORD           state;
    DWORD           resumeIndex;
    DWORD           bufSize;
    DWORD           bytesNeeded;
    DWORD           i;
    LPTSTR          pServiceName = NULL;
    LPTSTR          pServerName;
    LPTSTR          pGroupName;
    DWORD           itIsEnum;
    BOOL            fIsQueryOld;
    DWORD           argIndex;
    DWORD           userControl;
    LPTSTR          *FixArgv;
    BOOL            bTestError=FALSE;

    g_hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (g_hStdOut == INVALID_HANDLE_VALUE)
    {
        return 1;
    }

    if (argc < 2)
    {
        Usage();
        return 1;
    }

    FixArgv = (LPWSTR *) argv;

    //
    // Open a handle to the service controller.
    //
    //  I need to know the server name.  Do this by allowing
    //  a check of FixArgv[1] to see if it is of the form \\name.  If it
    //  is, make all further work be relative to argIndex.
    //

    pServerName = NULL;
    argIndex = 1;

    if (STRNCMP (FixArgv[1], TEXT("\\\\"), 2) == 0)
    {
        if (argc == 2)
        {
            Usage();
            return 1;
        }

        pServerName = FixArgv[1];
        argIndex++;
    }

    //------------------------------
    // QUERY & ENUM SERVICE STATUS
    //------------------------------

    fIsQueryOld = !STRICMP(FixArgv[argIndex], TEXT("query"));

    if (fIsQueryOld ||
        STRICMP (FixArgv[argIndex], TEXT("queryex") ) == 0 )
    {
        //
        // Set up the defaults
        //

        resumeIndex = 0;
        state       = SERVICE_ACTIVE;
        type        = 0x0;
        bufSize     = DEFAULT_ENUM_BUFFER_SIZE;
        itIsEnum    = TRUE;
        pGroupName  = NULL;

        //
        // Look for Enum or Query Options.
        //

        i = argIndex + 1;

        while (argc > i)
        {
            if (STRCMP (FixArgv[i], TEXT("ri=")) == 0)
            {
                i++;
                if (argc > i)
                {
                    resumeIndex = _ttol(FixArgv[i]);
                }
            }

            else if (STRCMP (FixArgv[i], TEXT("type=")) == 0)
            {
                i++;

                if (argc > i)
                {
                    if (STRCMP (FixArgv[i], TEXT("driver")) == 0)
                    {
                        type |= SERVICE_DRIVER;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("service")) == 0)
                    {
                        type |= SERVICE_WIN32;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("all")) == 0)
                    {
                        type |= SERVICE_TYPE_ALL;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("interact")) == 0)
                    {
                        type |= SERVICE_INTERACTIVE_PROCESS;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("error")) == 0)
                    {
                        type |= 0xffffffff;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("none")) == 0)
                    {
                        type = 0x0;
                        bTestError = TRUE;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("kernel")) == 0)
                    {
                        type |= SERVICE_KERNEL_DRIVER;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("filesys")) == 0)
                    {
                        type |= SERVICE_FILE_SYSTEM_DRIVER;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("adapter")) == 0)
                    {
                        type |= SERVICE_ADAPTER;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("own")) == 0)
                    {
                        type |= SERVICE_WIN32_OWN_PROCESS;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("share")) == 0)
                    {
                        type |= SERVICE_WIN32_SHARE_PROCESS;
                    }
                    else
                    {
                        APIInvalidField(L"type=");
                        goto CleanExit;
                    }
                }
            }
            else if (STRCMP (FixArgv[i], TEXT("state=")) == 0)
            {
                i++;

                if (argc > i)
                {
                    if (STRCMP (FixArgv[i], TEXT("inactive")) == 0)
                    {
                        state = SERVICE_INACTIVE;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("all")) == 0)
                    {
                        state = SERVICE_STATE_ALL;
                    }
                    else if (STRCMP (FixArgv[i], TEXT("error")) == 0)
                    {
                        state = 0xffffffff;
                    }
                    else
                    {
                        APIInvalidField(L"state=");
                        goto CleanExit;
                    }
                }
            }
            else if (STRCMP (FixArgv[i], TEXT("group=")) == 0)
            {
                i++;

                if (argc > i)
                {
                    pGroupName = FixArgv[i];
                }
            }
            else if (STRCMP (FixArgv[i], TEXT("bufsize=")) == 0)
            {
                i++;

                if (argc > i)
                {
                    bufSize = _ttol(FixArgv[i]);
                }
            }
            else
            {
                //
                // The string was not a valid option.
                //
                //
                // If this is still the 2nd argument, then it could be
                // the service name.  In this case, we will do a
                // QueryServiceStatus.  But first we want to go back and
                // see if there is a buffer size constraint to be placed
                // on the Query.
                //
                if (i == ( argIndex+1 ))
                {
                    pServiceName = FixArgv[i];
                    itIsEnum = FALSE;
                    i++;
                }
                else
                {
                    FormatAndDisplayMessage(SC_API_INVALID_OPTION, NULL);
                    Usage();
                    goto CleanExit;
                }
            }

            //
            // Increment to the next command line parameter.
            //

            i++;

        } // End While

        //
        // Allocate a buffer to receive the data.
        //

        if (bufSize != 0)
        {
            buffer = (LPBYTE) LocalAlloc(LMEM_FIXED,(UINT)bufSize);

            if (buffer == NULL)
            {
                APIFailed(L"EnumQueryServicesStatus: LocalAlloc", GetLastError());
                goto CleanExit;
            }
        }
        else
        {
            buffer = NULL;
        }

        if ( itIsEnum )
        {
            //////////////////////////
            //                      //
            // EnumServiceStatus    //
            //                      //
            //////////////////////////

            OPEN_MANAGER(SC_MANAGER_ENUMERATE_SERVICE);

            if ((type == 0x0) && (!bTestError))
            {
                type = SERVICE_WIN32;
            }

            do
            {
                status = NO_ERROR;

                //
                // Enumerate the ServiceStatus
                //

                if (fIsQueryOld)
                {
                    enumBuffer = (LPENUM_SERVICE_STATUS)buffer;

                    if (pGroupName == NULL)
                    {
                        if (!EnumServicesStatus(
                                    hScManager,
                                    type,
                                    state,
                                    enumBuffer,
                                    bufSize,
                                    &bytesNeeded,
                                    &entriesRead,
                                    &resumeIndex))
                        {
                            status = GetLastError();
                        }
                    }
                    else
                    {
                        if (!EnumServiceGroupW (
                                    hScManager,
                                    type,
                                    state,
                                    enumBuffer,
                                    bufSize,
                                    &bytesNeeded,
                                    &entriesRead,
                                    &resumeIndex,
                                    pGroupName))
                        {
                            status = GetLastError();
                        }
                    }
                }
                else
                {
                    //
                    // "queryex" used -- call the extended enum
                    //

                    enumBufferEx = (LPENUM_SERVICE_STATUS_PROCESS) buffer;

                    if (!EnumServicesStatusEx(
                                hScManager,
                                SC_ENUM_PROCESS_INFO,
                                type,
                                state,
                                (LPBYTE) enumBufferEx,
                                bufSize,
                                &bytesNeeded,
                                &entriesRead,
                                &resumeIndex,
                                pGroupName))
                    {
                        status = GetLastError();
                    }
                }

                if ((status == NO_ERROR)    ||
                    (status == ERROR_MORE_DATA))
                {
                    for (i = 0; i < entriesRead; i++)
                    {
                        if (fIsQueryOld)
                        {
                            statusBuffer.Regular = &(enumBuffer->ServiceStatus);

                            DisplayStatus(
                                enumBuffer->lpServiceName,
                                enumBuffer->lpDisplayName,
                                &statusBuffer,
                                TRUE);

                            enumBuffer++;
                        }
                        else
                        {
                            statusBuffer.Ex = &(enumBufferEx->ServiceStatusProcess);

                            DisplayStatus(
                                enumBufferEx->lpServiceName,
                                enumBufferEx->lpDisplayName,
                                &statusBuffer,
                                FALSE);

                            enumBufferEx++;
                        }
                    }
                }
                else
                {
                    //
                    // Length of "EnumServicesStatusEx" + NULL
                    //

                    WCHAR APIName[21] = L"EnumServicesStatusEx";

                    if (fIsQueryOld)
                    {
                        APIName[18] = L'\0';
                    }

                    APIFailed(APIName, status);
                }
            }
            while (status == ERROR_MORE_DATA && entriesRead != 0);

            if (status == ERROR_MORE_DATA)
            {
                APINeedsLargerBuffer(L"EnumServicesStatus",
                                     SC_API_INSUFFICIENT_BUFFER_ENUM,
                                     bytesNeeded,
                                     resumeIndex);
            }
        }
        else
        {
            //////////////////////////
            //                      //
            // QueryServiceStatus   //
            //                      //
            //////////////////////////

            if (pGroupName != NULL)
            {
                FormatAndDisplayMessage(SC_API_NO_NAME_WITH_GROUP, NULL);
                goto CleanExit;
            }

            OPEN_MANAGER(GENERIC_READ);

            //
            // Open a handle to the service
            //

            hService = OpenService(
                        hScManager,
                        pServiceName,
                        SERVICE_QUERY_STATUS);

            if (hService == NULL)
            {
                APIFailed(L"EnumQueryServicesStatus:OpenService", GetLastError());
                goto CleanExit;
            }

            //
            // Query the Service Status
            //
            status = NO_ERROR;

            if (fIsQueryOld)
            {
                statusBuffer.Regular = (LPSERVICE_STATUS) buffer;

                if (!QueryServiceStatus(hService,statusBuffer.Regular))
                {
                    status = GetLastError();
                }
            }
            else
            {
                DWORD dwBytesNeeded;

                statusBuffer.Ex = (LPSERVICE_STATUS_PROCESS) buffer;

                if (!QueryServiceStatusEx(
                        hService,
                        SC_STATUS_PROCESS_INFO,
                        (LPBYTE)statusBuffer.Ex,
                        bufSize,
                        &dwBytesNeeded))
                {
                    status = GetLastError();
                }
            }

            if (status == NO_ERROR)
            {
                DisplayStatus(pServiceName, NULL, &statusBuffer, fIsQueryOld);
            }
            else
            {
                //
                // Length of "QueryServiceStatusEx" + NULL
                //

                WCHAR APIName[21] = L"QueryServiceStatusEx";

                if (fIsQueryOld)
                {
                    APIName[18] = L'\0';
                }

                APIFailed(APIName, status);
            }
        }
    }
    else if (argc < (argIndex + 1))
    {
        FormatAndDisplayMessage(SC_API_NAME_REQUIRED, NULL);
        Usage();
        goto CleanExit;
    }

    //-----------------------
    // START SERVICE
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("start")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_START, NULL);
            goto CleanExit;
        }

        pServiceName = FixArgv[argIndex + 1];

        //
        // Open a handle to the service.
        //

        OPEN_MANAGER(GENERIC_READ);

        hService = OpenService(
                    hScManager,
                    pServiceName,
                    SERVICE_START | SERVICE_QUERY_STATUS);

        if (hService == NULL)
        {
            APIFailed(L"StartService: OpenService", GetLastError());
            goto CleanExit;
        }

        argPtr = NULL;

        if (argc > argIndex + 2)
        {
            argPtr = (LPTSTR *) &FixArgv[argIndex + 2];
        }

        //
        // Start the service.
        //
        status = NO_ERROR;

        if (!StartService(
                hService,
                argc-(argIndex+2),
                argPtr))
        {
            APIFailed(L"StartService", GetLastError());
        }
        else
        {
            DWORD                     dwBytesNeeded;
            SERVICE_STATUS_PROCESS    serviceStatusProcess;

            status = NO_ERROR;

            //
            // Get the service status since StartService does not return it
            //
            if (!QueryServiceStatusEx(hService,
                                      SC_STATUS_PROCESS_INFO,
                                      (LPBYTE) &serviceStatusProcess,
                                      sizeof(SERVICE_STATUS_PROCESS),
                                      &dwBytesNeeded))
            {
                status = GetLastError();
            }

            statusBuffer.Ex = &serviceStatusProcess;

            if (status == NO_ERROR)
            {
                DisplayStatus(pServiceName, NULL, &statusBuffer, FALSE);
            }
            else
            {
                APIFailed(L"QueryServiceStatusEx", status);
            }
        }
    }

    //-----------------------
    // PAUSE SERVICE
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("pause")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_PAUSE, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],       // pointer to service name
            SERVICE_CONTROL_PAUSE,  // the control to send
            &hService);             // the handle to the service
    }

    //-----------------------
    // INTERROGATE SERVICE
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("interrogate")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_INTERROGATE, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],       // pointer to service name
            SERVICE_CONTROL_INTERROGATE, // the control to send
            &hService);             // the handle to the service
    }

    //-----------------------
    // CONTROL SERVICE
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("control")) == 0)
    {
        if (argc < (argIndex + 3))
        {
            FormatAndDisplayMessage(SC_HELP_CONTROL, NULL);
            goto CleanExit;
        }

        userControl = _ttol(FixArgv[argIndex+2]);

        if (userControl == 0)
        {
            if (STRICMP (FixArgv[argIndex+2], TEXT("paramchange")) == 0) {
                userControl = SERVICE_CONTROL_PARAMCHANGE;
            }
            else if (STRICMP (FixArgv[argIndex+2], TEXT("netbindadd")) == 0) {
                userControl = SERVICE_CONTROL_NETBINDADD;
            }
            else if (STRICMP (FixArgv[argIndex+2], TEXT("netbindremove")) == 0) {
                userControl = SERVICE_CONTROL_NETBINDREMOVE;
            }
            else if (STRICMP (FixArgv[argIndex+2], TEXT("netbindenable")) == 0) {
                userControl = SERVICE_CONTROL_NETBINDENABLE;
            }
            else if (STRICMP (FixArgv[argIndex+2], TEXT("netbinddisable")) == 0) {
                userControl = SERVICE_CONTROL_NETBINDDISABLE;
            }
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            userControl,            // the control to send
            &hService);             // the handle to the service
    }

    //-----------------------
    // CONTINUE SERVICE
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("continue")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_CONTINUE, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,                 // handle to service controller
            FixArgv[argIndex+1],        // pointer to service name
            SERVICE_CONTROL_CONTINUE,   // the control to send
            &hService);                 // the handle to the service
    }

    //-----------------------
    // STOP SERVICE
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("stop")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_STOP, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendControlToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],       // pointer to service name
            SERVICE_CONTROL_STOP,   // the control to send
            &hService);             // the handle to the service
    }

    //---------------
    // CHANGE CONFIG 
    //---------------
    else if (STRICMP (FixArgv[argIndex], TEXT("config")) == 0)
    {
        if (argc < (argIndex + 3))
        {
            ConfigUsage();
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        SendConfigToService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            &FixArgv[argIndex+2],   // the argument switches
            argc-(argIndex+2),      // the switch count.
            &hService);             // the handle to the service
    }

    //-----------------------------
    // CHANGE SERVICE DESCRIPTION
    //-----------------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("description")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_CHANGE_DESCRIPTION, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        ChangeServiceDescription(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            FixArgv[argIndex+2],    // the description (rest of argv)
            &hService);             // the handle to the service
    }

    //-----------------------------
    // CHANGE FAILURE ACTIONS
    //-----------------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("failure")) == 0) {

        if (argc < (argIndex + 2)) {
            ChangeFailureUsage();
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        ChangeServiceFailure(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            &FixArgv[argIndex+2],   // the argument switches
            argc-(argIndex+2),      // the switch count
            &hService);             // the handle to the service
    }


    //-----------------------
    // QUERY SERVICE CONFIG
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("qc")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_QUERY_CONFIG, NULL);
            goto CleanExit;
        }

        bufSize = 500;
        if (argc > (argIndex + 2) ) {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        OPEN_MANAGER(GENERIC_READ);

        GetServiceConfig(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            bufSize,                // the size of the buffer to use
            &hService);             // the handle to the service
    }

    //-------------------
    // QUERY DESCRIPTION 
    //-------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("qdescription")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_QUERY_DESCRIPTION, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) )
        {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        GetConfigInfo(
            hScManager,                     // handle to service controller
            FixArgv[argIndex + 1],          // pointer to service name
            bufSize,                        // the size of the buffer to use
            &hService,                      // the handle to the service
            SERVICE_CONFIG_DESCRIPTION);    // which config data is requested
    }

    //-----------------------
    // QUERY FAILURE ACTIONS
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("qfailure")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_QUERY_FAILURE, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) )
        {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        GetConfigInfo(
            hScManager,                         // handle to service controller
            FixArgv[argIndex + 1],              // pointer to service name
            bufSize,                            // the size of the buffer to use
            &hService,                          // the handle to the service
            SERVICE_CONFIG_FAILURE_ACTIONS);    // which config data is requested
    }

    //--------------------------
    // QUERY SERVICE LOCK STATUS
    //--------------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("querylock")) == 0)
    {
        if (argc < (argIndex + 1))
        {
            FormatAndDisplayMessage(SC_HELP_QUERY_LOCK, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(SC_MANAGER_QUERY_LOCK_STATUS);

        bufSize = 500;
        if (argc > (argIndex + 1) )
        {
            bufSize = _ttol(FixArgv[argIndex+1]);
        }

        GetServiceLockStatus(
            hScManager,             // handle to service controller
            bufSize);               // the size of the buffer to use
    }


    //----------------------
    // LOCK SERVICE DATABASE
    //----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("lock")) == 0)
    {
        OPEN_MANAGER(SC_MANAGER_LOCK);

        LockServiceActiveDatabase(hScManager);
    }


    //-----------------------
    // DELETE SERVICE
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("delete")) == 0)
    {
        if (argc < (argIndex + 2))
        {
            FormatAndDisplayMessage(SC_HELP_DELETE, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        //
        // Open a handle to the service.
        //

        hService = OpenService(
                        hScManager,
                        FixArgv[argIndex+1],
                        DELETE);

        if (hService == NULL)
        {
            APIFailed(L"OpenService", GetLastError());
            goto CleanExit;
        }

        //
        // Delete the service
        //

        if (!DeleteService(hService))
        {
            APIFailed(L"DeleteService", GetLastError());
        }
        else
        {
            APISucceeded(L"DeleteService");
        }
    }

    //-----------------------
    // CREATE SERVICE
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("create")) == 0)
    {
        if (argc < (argIndex + 3))
        {
            CreateUsage();
            goto CleanExit;
        }

        OPEN_MANAGER(SC_MANAGER_CREATE_SERVICE);

        DoCreateService(
            hScManager,             // handle to service controller
            FixArgv[argIndex+1],    // pointer to service name
            &FixArgv[argIndex+2],   // the argument switches.
            argc-(argIndex+2));     // the switch count.
    }

    //-----------------------
    // NOTIFY BOOT CONFIG
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("boot")) == 0)
    {
        BOOL fOK = TRUE;

        if (argc >= (argIndex + 2))
        {
            if (STRICMP (FixArgv[argIndex+1], TEXT("ok")) == 0)
            {
                if (!NotifyBootConfigStatus(TRUE))
                {
                    APIFailed(L"NotifyBootConfigStatus", GetLastError());
                }
            }
            else if (STRICMP (FixArgv[argIndex+1], TEXT("bad")) == 0)
            {
                if (!NotifyBootConfigStatus(FALSE))
                {
                    APIFailed(L"NotifyBootConfigStatus", GetLastError());
                }
            }
            else
            {
                fOK = FALSE;
            }
        }
        else
        {
            fOK = FALSE;
        }

        if (!fOK)
        {
            FormatAndDisplayMessage(SC_HELP_BOOT, NULL);
        }
    }

    //-----------------------
    // GetServiceDisplayName
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("GetDisplayName")) == 0)
    {
        LPTSTR  DisplayName;

        if (argc < argIndex + 2)
        {
            FormatAndDisplayMessage(SC_HELP_GET_DISPLAY_NAME, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) )
        {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        if (bufSize != 0)
        {
            DisplayName = (LPTSTR) LocalAlloc(LMEM_FIXED, bufSize*sizeof(TCHAR));

            if (DisplayName == NULL)
            {
                APIFailed(L"GetServiceDisplayName: LocalAlloc", GetLastError());
                goto CleanExit;
            }
        }
        else
        {
            DisplayName = NULL;
        }

        if (!GetServiceDisplayName(
                hScManager,
                FixArgv[argIndex+1],
                DisplayName,
                &bufSize))
        {
            DWORD dwError = GetLastError();

            //
            // Returned size does not include the trailing NULL
            //

            APIFailed(L"GetServiceDisplayName", dwError);

            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                APINeedsLargerBuffer(L"GetServiceDisplayName",
                                     SC_API_INSUFFICIENT_BUFFER,
                                     bufSize + 1,
                                     0);
            }
        }
        else
        {
            APISucceeded(L"GetServiceDisplayName");
            FormatAndDisplayMessage(SC_DISPLAY_GET_NAME, &DisplayName);
        }
    }

    //-----------------------
    // GetServiceKeyName
    //-----------------------
    else if (STRICMP (FixArgv[argIndex], TEXT("GetKeyName")) == 0)
    {
        LPTSTR  KeyName;

        if (argc < argIndex + 2)
        {
            FormatAndDisplayMessage(SC_HELP_GET_KEY_NAME, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;
        if (argc > (argIndex + 2) )
        {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        if (bufSize != 0)
        {
            KeyName = (LPTSTR)LocalAlloc(LMEM_FIXED, bufSize*sizeof(TCHAR));

            if (KeyName == NULL)
            {
                APIFailed(L"GetServiceKeyName: LocalAlloc", GetLastError());
                goto CleanExit;
            }
        }
        else
        {
            KeyName = NULL;
        }

        if (!GetServiceKeyName(
                hScManager,
                FixArgv[argIndex+1],
                KeyName,
                &bufSize))
        {
            DWORD dwError = GetLastError();

            //
            // Returned size does not include the trailing NULL
            //

            APIFailed(L"GetServiceKeyName", dwError);

            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                APINeedsLargerBuffer(L"GetServiceKeyName", SC_API_INSUFFICIENT_BUFFER, bufSize + 1, 0);
            }
        }
        else
        {
            APISucceeded(L"GetServiceKeyName");
            FormatAndDisplayMessage(SC_DISPLAY_GET_NAME, &KeyName);
        }
    }

    //-----------------------
    // EnumDependentServices
    //-----------------------

    else if (STRICMP (FixArgv[argIndex], TEXT("EnumDepend")) == 0)
    {
        if (argc < argIndex + 2)
        {
            FormatAndDisplayMessage(SC_HELP_ENUM_DEPEND, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        bufSize = 500;

        if (argc > (argIndex + 2) )
        {
            bufSize = _ttol(FixArgv[argIndex+2]);
        }

        EnumDepend(hScManager,FixArgv[argIndex+1], bufSize);
    }

    //-----------------
    // Show Service SD
    //-----------------

    else if (STRICMP (FixArgv[argIndex], TEXT("sdshow")) == 0)
    {
        if (argc < argIndex + 2)
        {
            FormatAndDisplayMessage(SC_HELP_SDSHOW, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_READ);

        ShowSecurity(hScManager, FixArgv[argIndex + 1]);
    }

    //----------------
    // Set Service SD
    //----------------

    else if (STRICMP (FixArgv[argIndex], TEXT("sdset")) == 0)
    {
        if (argc < argIndex + 3)
        {
            FormatAndDisplayMessage(SC_HELP_SDSET, NULL);
            goto CleanExit;
        }

        OPEN_MANAGER(GENERIC_WRITE);

        SetSecurity(hScManager, FixArgv[argIndex + 1], FixArgv[argIndex + 2]);
    }

    else
    {
        FormatAndDisplayMessage(SC_API_UNRECOGNIZED_COMMAND, NULL);
        Usage();
        goto CleanExit;
    }


CleanExit:

    LocalFree(buffer);

    if(hService != NULL)
    {
        CloseServiceHandle(hService);
    }

    if(hScManager != NULL)
    {
        CloseServiceHandle(hScManager);
    }

    return 0;
}


DWORD
SendControlToService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  DWORD       control,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    SERVICE_STATUS          ServiceStatus;
    STATUS_UNION            StatusUnion;
    DWORD                   status = NO_ERROR;

    DWORD                   DesiredAccess;

    //
    // If the service name is "svcctrl" and the control code is
    // stop, then set up the special secret code to shut down the
    // service controller.
    //
    // NOTE:  This only works if the service controller is built with
    //  a special debug variable defined.
    //
    if ((control == SERVICE_CONTROL_STOP) &&
        (STRICMP (pServiceName, TEXT("svcctrl")) == 0))
    {
        control = 5555;       // Secret Code
    }

    switch (control)
    {
        case SERVICE_CONTROL_STOP:
            DesiredAccess = SERVICE_STOP;
            break;

        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_PARAMCHANGE:
        case SERVICE_CONTROL_NETBINDADD:
        case SERVICE_CONTROL_NETBINDREMOVE:
        case SERVICE_CONTROL_NETBINDENABLE:
        case SERVICE_CONTROL_NETBINDDISABLE:
            DesiredAccess = SERVICE_PAUSE_CONTINUE;
            break;

        case SERVICE_CONTROL_INTERROGATE:
            DesiredAccess = SERVICE_INTERROGATE;
            break;

        default:
            DesiredAccess = SERVICE_USER_DEFINED_CONTROL;
    }

    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    pServiceName,
                    DesiredAccess);

    if (*lphService == NULL)
    {
        APIFailed(L"OpenService", GetLastError());
        return 0;
    }

    if (!ControlService (
            *lphService,
            control,
            &ServiceStatus))
    {
        status = GetLastError();
    }

    if (status == NO_ERROR)
    {
        StatusUnion.Regular = &ServiceStatus;
        DisplayStatus(pServiceName, NULL, &StatusUnion, TRUE);
    }
    else
    {
        APIFailed(L"ControlService", status);
    }

    return 0;
}


DWORD
SendConfigToService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *argv,
    IN  DWORD       argc,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:

    hScManager - This is the handle to the ScManager.

    pServicename - This is a pointer to the service name string

    Argv - Pointer to an array of argument pointers.  These pointers
        in the array point to the strings used as input parameters for
        ChangeConfigStatus

    argc - The number of arguments in the array of argument pointers

    lphService - Pointer to location to where the handle to the service
        is to be returned.


Return Value:



--*/
{
    DWORD       status = NO_ERROR;
    DWORD       i;
    DWORD       dwServiceType   = SERVICE_NO_CHANGE;
    DWORD       dwStartType     = SERVICE_NO_CHANGE;
    DWORD       dwErrorControl  = SERVICE_NO_CHANGE;
    LPTSTR      lpBinaryPathName    = NULL;
    LPTSTR      lpLoadOrderGroup    = NULL;
    LPTSTR      lpDependencies      = NULL;
    LPTSTR      lpServiceStartName  = NULL;
    LPTSTR      lpPassword          = NULL;
    LPTSTR      lpDisplayName       = NULL;
    LPTSTR      tempDepend = NULL;
    UINT        bufSize;

    LPDWORD     lpdwTagId = NULL;
    DWORD       TagId;


    //
    // Look at parameter list
    //
    for (i = 0; i < argc; i++)
    {
        if (STRICMP(argv[i], TEXT("type=")) == 0 && (i + 1 < argc))
        {
            //--------------------------------------------------------
            // We want to allow for several arguments of type= in the
            // same line.  These should cause the different arguments
            // to be or'd together.  So if we come in and dwServiceType
            // is NO_CHANGE, we set the value to 0 (for or'ing).  If
            // it is still 0 on exit, we re-set the value to
            // NO_CHANGE.
            //--------------------------------------------------------

            if (dwServiceType == SERVICE_NO_CHANGE)
            {
                dwServiceType = 0;
            }

            if (STRICMP(argv[i+1],TEXT("own")) == 0)
            {
                dwServiceType |= SERVICE_WIN32_OWN_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("share")) == 0)
            {
                dwServiceType |= SERVICE_WIN32_SHARE_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("interact")) == 0)
            {
                dwServiceType |= SERVICE_INTERACTIVE_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("kernel")) == 0)
            {
                dwServiceType |= SERVICE_KERNEL_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("filesys")) == 0)
            {
                dwServiceType |= SERVICE_FILE_SYSTEM_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("rec")) == 0)
            {
                dwServiceType |= SERVICE_RECOGNIZER_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("adapt")) == 0)
            {
                dwServiceType |= SERVICE_ADAPTER;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0)
            {
                dwServiceType |= 0x2f309a20;
            }
            else
            {
                APIInvalidField(L"type=");
                ConfigUsage();
                return(0);
            }

            if (dwServiceType == 0)
            {
                dwServiceType = SERVICE_NO_CHANGE;
            }

            i++;
        }
        else if (STRICMP(argv[i], TEXT("start=")) == 0 && (i+1 < argc))
        {
            if (STRICMP(argv[i+1],TEXT("boot")) == 0)
            {
                dwStartType = SERVICE_BOOT_START;
            }
            else if (STRICMP(argv[i+1],TEXT("system")) == 0)
            {
                dwStartType = SERVICE_SYSTEM_START;
            }
            else if (STRICMP(argv[i+1],TEXT("auto")) == 0)
            {
                dwStartType = SERVICE_AUTO_START;
            }
            else if (STRICMP(argv[i+1],TEXT("demand")) == 0)
            {
                dwStartType = SERVICE_DEMAND_START;
            }
            else if (STRICMP(argv[i+1],TEXT("disabled")) == 0)
            {
                dwStartType = SERVICE_DISABLED;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0)
            {
                dwStartType = 0xd0034911;
            }
            else
            {
                APIInvalidField(L"start=");
                ConfigUsage();
                return(0);
            }

            i++;
        }
        else if (STRICMP(argv[i], TEXT("error=")) == 0 && (i+1 < argc))
        {
            if (STRICMP(argv[i+1],TEXT("normal")) == 0)
            {
                dwErrorControl = SERVICE_ERROR_NORMAL;
            }
            else if (STRICMP(argv[i+1],TEXT("severe")) == 0)
            {
                dwErrorControl = SERVICE_ERROR_SEVERE;
            }
            else if (STRICMP(argv[i+1],TEXT("ignore")) == 0)
            {
                dwErrorControl = SERVICE_ERROR_IGNORE;
            }
            else if (STRICMP(argv[i+1],TEXT("critical")) == 0)
            {
                dwErrorControl = SERVICE_ERROR_CRITICAL;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0)
            {
                dwErrorControl = 0x00d74550;
            }
            else
            {
                APIInvalidField(L"error=");
                ConfigUsage();
                return(0);
            }

            i++;
        }
        else if (STRICMP(argv[i], TEXT("binPath=")) == 0 && (i+1 < argc))
        {
            lpBinaryPathName = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("group=")) == 0 && (i+1 < argc))
        {
            lpLoadOrderGroup = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("tag=")) == 0 && (i+1 < argc))
        {
            if (STRICMP(argv[i+1], TEXT("YES"))==0)
            {
                lpdwTagId = &TagId;
            }

            i++;
        }
        else if (STRICMP(argv[i], TEXT("depend=")) == 0 && (i+1 < argc))
        {
            tempDepend = argv[i+1];
            bufSize = (UINT)STRSIZE(tempDepend);
            lpDependencies = (LPTSTR)LocalAlloc(
                                LMEM_ZEROINIT,
                                bufSize + sizeof(TCHAR));

            if (lpDependencies == NULL)
            {
                APIFailed(L"SendConfigToService: LocalAlloc", GetLastError());
                return 0;
            }

            //
            // Put NULLs in place of forward slashes in the string.
            //
            STRCPY(lpDependencies, tempDepend);
            tempDepend = lpDependencies;

            while (*tempDepend != TEXT('\0'))
            {
                if (*tempDepend == TEXT('/'))
                {
                    *tempDepend = TEXT('\0');
                }

                tempDepend++;
            }

            i++;
        }
        else if (STRICMP(argv[i], TEXT("obj=")) == 0 && (i+1 < argc)) {
            lpServiceStartName = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("password=")) == 0 && (i+1 < argc)) {
            lpPassword = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("DisplayName=")) == 0 && (i+1 < argc)) {
            lpDisplayName = argv[i+1];
            i++;
        }
        else {
            ConfigUsage();
            return(0);
        }
    }



    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    pServiceName,
                    SERVICE_CHANGE_CONFIG);

    if (*lphService == NULL)
    {
        APIFailed(L"OpenService", GetLastError());
        return 0;
    }

    if (!ChangeServiceConfig(
            *lphService,        // hService
            dwServiceType,      // dwServiceType
            dwStartType,        // dwStartType
            dwErrorControl,     // dwErrorControl
            lpBinaryPathName,   // lpBinaryPathName
            lpLoadOrderGroup,   // lpLoadOrderGroup
            lpdwTagId,          // lpdwTagId
            lpDependencies,     // lpDependencies
            lpServiceStartName, // lpServiceStartName
            lpPassword,         // lpPassword
            lpDisplayName))     // lpDisplayName
    {
        status = GetLastError();
    }

    if (status == NO_ERROR)
    {
        APISucceeded(L"ChangeServiceConfig");

        if (lpdwTagId != NULL)
        {
            WCHAR  wszTag[11];
            LPWSTR lpStrings[1];

            _itow(*lpdwTagId, wszTag, 10);
            lpStrings[0] = wszTag;

            FormatAndDisplayMessage(SC_DISPLAY_TAG, lpStrings);
        }
    }
    else
    {
        APIFailed(L"ChangeServiceConfig", status);
    }

    return 0;
}


DWORD
ChangeServiceDescription(
    IN SC_HANDLE    hScManager,
    IN LPTSTR       pServiceName,
    IN LPTSTR       pNewDescription,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD                   status = NO_ERROR;
    SERVICE_DESCRIPTION     sdNewDescription;


    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    pServiceName,
                    SERVICE_CHANGE_CONFIG);

    if (*lphService == NULL)
    {
        APIFailed(L"OpenService", GetLastError());
        return 0;
    }
    
    sdNewDescription.lpDescription = pNewDescription;

    if (!ChangeServiceConfig2(
            *lphService,                    // handle to service
            SERVICE_CONFIG_DESCRIPTION,     // description ID
            &sdNewDescription))             // pointer to config info
    {
        status = GetLastError();
    }

    if (status == NO_ERROR)
    {
        APISucceeded(L"ChangeServiceConfig2");
    }
    else
    {
        APIFailed(L"ChangeServiceConfig2", status);
    }

    return 0;
}


DWORD
ChangeServiceFailure(
    IN SC_HANDLE    hScManager,
    IN LPTSTR       pServiceName,
    IN LPTSTR       *argv,
    IN DWORD        argc,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    BOOL                    fReset              = FALSE;
    BOOL                    fActions            = FALSE;
    NTSTATUS                ntsStatus;
    DWORD                   status              = NO_ERROR;
    DWORD                   i;
    DWORD                   dwActionNum         = 0;
    DWORD                   dwReset             = 0;
    DWORD                   dwAccess            = SERVICE_CHANGE_CONFIG;
    LPTSTR                  lpReboot            = NULL;
    LPTSTR                  lpCommandLine       = NULL;
    LPTSTR                  pActionStart;
    LPTSTR                  pActionEnd;
    LPTSTR                  pActionLastNull;
    SC_ACTION               *lpsaTempActions    = NULL;
    BOOLEAN                 fActionDelay        = TRUE;
    BOOLEAN                 fGarbage;
    BOOLEAN                 fAdjustPrivilege    = FALSE;
    SERVICE_FAILURE_ACTIONS sfaActions;
    
    //
    // Look at parameter list
    //
    for (i=0; i < argc; i++ ) {
        if (STRICMP(argv[i], TEXT("reset=")) == 0 && (i+1 < argc)) {

            if (STRICMP(argv[i+1], TEXT("infinite")) == 0) {
                dwReset = INFINITE;
            }
            else {              
                dwReset = _ttol(argv[i+1]);
            }
            fReset = TRUE;
            i++;
        }
        else if (STRICMP(argv[i], TEXT("reboot=")) == 0 && (i+1 < argc)) {
            lpReboot = argv[i+1];
            i++;
        }
        else if (STRICMP(argv[i], TEXT("command=")) == 0 && (i+1 < argc)) {
            lpCommandLine = argv[i+1];
            i++;
        }

        else if (STRICMP(argv[i], TEXT("actions=")) == 0 && (i+1 < argc)) {
            
            pActionStart = argv[i+1];

            //
            // Count the number of actions in order to allocate the action array.  Since one
            // action will be missed (NULL char at the end instead of '/'), add one after the loop
            //

            while (*pActionStart != TEXT('\0')) {
                if (*pActionStart == TEXT('/')) {
                    dwActionNum++;
                }
                pActionStart++;
            }
            dwActionNum++;

            //
            // Allocate the action array.  Round the number up in case an action was given without
            // a delay at the end.  If this is the case, the delay will be treated as 0
            //

            lpsaTempActions = (SC_ACTION *)LocalAlloc(LMEM_ZEROINIT,
                                                        (dwActionNum + 1) / 2 * sizeof(SC_ACTION));     
            if (lpsaTempActions == NULL)
            {
                APIFailed(L"ChangeServiceFailure: LocalAlloc", GetLastError());
                return 0;
            }

            pActionStart = pActionEnd = argv[i + 1];

            //
            // Reparse the actions, filling in the SC_ACTION array as we go.  Turn the
            // final NULL into a '/' character so we don't clip the final failure
            // action (it's converted back into a NULL below).
            //

            dwActionNum      = 0;
            pActionLastNull  = pActionStart + STRLEN(pActionStart);
            *pActionLastNull = TEXT('/');

            while (pActionEnd <= pActionLastNull) {
                if (*pActionEnd == TEXT('/')) {
                    *pActionEnd = TEXT('\0');

                    //
                    // Use fActionDelay to "remember" if it's an action or a delay being parsed
                    //

                    if (fActionDelay) {

                        if (STRICMP(pActionStart, TEXT("restart")) == 0) {
                            lpsaTempActions[dwActionNum].Type = SC_ACTION_RESTART;
                            dwAccess |= SERVICE_START;
                        }
                        else if (STRICMP(pActionStart, TEXT("reboot")) == 0) {
                            lpsaTempActions[dwActionNum].Type = SC_ACTION_REBOOT;
                            fAdjustPrivilege = TRUE;
                        }
                        else if (STRICMP(pActionStart, TEXT("run")) == 0) {
                            lpsaTempActions[dwActionNum].Type = SC_ACTION_RUN_COMMAND;
                        }
                        else {
                            lpsaTempActions[dwActionNum].Type = SC_ACTION_NONE;
                        }
                    }
                    else {
                        lpsaTempActions[dwActionNum++].Delay = _ttol(pActionStart);
                    }
                
                    fActionDelay = !fActionDelay;
                    pActionStart = pActionEnd + 1;
                }
                pActionEnd++;
            }
            fActions = TRUE;
            i++;
        }
        else
        {
            FormatAndDisplayMessage(SC_API_INVALID_OPTION, NULL);
            ChangeFailureUsage();
            return 0;
        }
    }

    if (fReset != fActions)
    {
        FormatAndDisplayMessage(SC_API_RESET_AND_ACTIONS, NULL);
        ChangeFailureUsage();
        return 0;
    }

    if (fAdjustPrivilege)
    {
        ntsStatus = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                       TRUE,
                                       FALSE,
                                       &fGarbage);

        if (!NT_SUCCESS(ntsStatus))
        {
            APIFailed(L"ChangeServiceFailure: RtlAdjustPrivilege", RtlNtStatusToDosError(ntsStatus));
            return 0;
        }
    }

    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    pServiceName,
                    dwAccess);

    if (*lphService == NULL)
    {
        APIFailed(L"OpenService", GetLastError());
        return 0;
    }


    sfaActions.dwResetPeriod    = dwReset;
    sfaActions.lpRebootMsg      = lpReboot;
    sfaActions.lpCommand        = lpCommandLine;
    sfaActions.cActions         = dwActionNum;
    sfaActions.lpsaActions      = lpsaTempActions;

    
    if (!ChangeServiceConfig2(
                *lphService,                        // handle to service
                SERVICE_CONFIG_FAILURE_ACTIONS,     // config info ID
                &sfaActions))                       // pointer to config info
    {
        status = GetLastError();
    }

    if (status == NO_ERROR)
    {
        APISucceeded(L"ChangeServiceConfig2");
    }
    else
    {
        APIFailed(L"ChangeServiceConfig2", status);
    }

    return 0;
}


DWORD
DoCreateService(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      pServiceName,
    IN  LPTSTR      *argv,
    IN  DWORD       argc
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD       i;
    DWORD       dwServiceType   = SERVICE_NO_CHANGE;
    DWORD       dwStartType     = SERVICE_DEMAND_START;
    DWORD       dwErrorControl  = SERVICE_ERROR_NORMAL;
    LPTSTR      lpBinaryPathName    = NULL;
    LPTSTR      lpLoadOrderGroup    = NULL;
    DWORD       TagId               = 0;
    LPDWORD     lpdwTagId           = NULL;
    LPTSTR      lpDependencies      = NULL;
    LPTSTR      lpServiceStartName  = NULL;
    LPTSTR      lpDisplayName       = NULL;
    LPTSTR      lpPassword          = NULL;
    LPTSTR      tempDepend = NULL;
    SC_HANDLE   hService = NULL;
    UINT        bufSize;


    //
    // Look at parameter list
    //
    for (i=0;i<argc ;i++ )
    {
        //---------------
        // ServiceType
        //---------------
        if (STRICMP(argv[i], TEXT("type=")) == 0 && (i+1 < argc))
        {
            //--------------------------------------------------------
            // We want to allow for several arguments of type= in the
            // same line.  These should cause the different arguments
            // to be or'd together.  So if we come in and dwServiceType
            // is NO_CHANGE, we set the value to 0 (for or'ing).  If
            // it is still 0 on exit, we re-set the value to
            // WIN32_OWN_PROCESS.
            //--------------------------------------------------------

            if (dwServiceType == SERVICE_NO_CHANGE)
            {
                dwServiceType = 0;
            }

            if (STRICMP(argv[i+1],TEXT("own")) == 0)
            {
                dwServiceType |= SERVICE_WIN32_OWN_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("share")) == 0)
            {
                dwServiceType |= SERVICE_WIN32_SHARE_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("interact")) == 0)
            {
                dwServiceType |= SERVICE_INTERACTIVE_PROCESS;
            }
            else if (STRICMP(argv[i+1],TEXT("kernel")) == 0)
            {
                dwServiceType |= SERVICE_KERNEL_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("filesys")) == 0)
            {
                dwServiceType |= SERVICE_FILE_SYSTEM_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("rec")) == 0)
            {
                dwServiceType |= SERVICE_RECOGNIZER_DRIVER;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0)
            {
                dwServiceType |= 0x2f309a20;
            }
            else
            {
                APIInvalidField(L"type=");
                CreateUsage();
                return(0);
            }

            if (dwServiceType == 0)
            {
                dwServiceType = SERVICE_WIN32_OWN_PROCESS;
            }

            i++;
        }

        //---------------
        // StartType
        //---------------

        else if (STRICMP(argv[i], TEXT("start=")) == 0 && (i+1 < argc))
        {
            if (STRICMP(argv[i+1],TEXT("boot")) == 0)
            {
                dwStartType = SERVICE_BOOT_START;
            }
            else if (STRICMP(argv[i+1],TEXT("system")) == 0)
            {
                dwStartType = SERVICE_SYSTEM_START;
            }
            else if (STRICMP(argv[i+1],TEXT("auto")) == 0)
            {
                dwStartType = SERVICE_AUTO_START;
            }
            else if (STRICMP(argv[i+1],TEXT("demand")) == 0)
            {
                dwStartType = SERVICE_DEMAND_START;
            }
            else if (STRICMP(argv[i+1],TEXT("disabled")) == 0)
            {
                dwStartType = SERVICE_DISABLED;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0)
            {
                dwStartType = 0xd0034911;
            }
            else
            {
                APIInvalidField(L"start=");
                CreateUsage();
                return(0);
            }

            i++;
        }

        //---------------
        // ErrorControl
        //---------------

        else if (STRICMP(argv[i], TEXT("error=")) == 0 && (i+1 < argc))
        {
            if (STRICMP(argv[i+1],TEXT("normal")) == 0)
            {
                dwErrorControl = SERVICE_ERROR_NORMAL;
            }
            else if (STRICMP(argv[i+1],TEXT("severe")) == 0)
            {
                dwErrorControl = SERVICE_ERROR_SEVERE;
            }
            else if (STRICMP(argv[i+1],TEXT("critical")) == 0)
            {
                dwErrorControl = SERVICE_ERROR_CRITICAL;
            }
            else if (STRICMP(argv[i+1],TEXT("ignore")) == 0)
            {
                dwErrorControl = SERVICE_ERROR_IGNORE;
            }
            else if (STRICMP(argv[i+1],TEXT("error")) == 0)
            {
                dwErrorControl = 0x00d74550;
            }
            else
            {
                APIInvalidField(L"error=");
                CreateUsage();
                return(0);
            }

            i++;
        }

        //---------------
        // BinaryPath
        //---------------

        else if (STRICMP(argv[i], TEXT("binPath=")) == 0 && (i+1 < argc))
        {
            lpBinaryPathName = argv[i+1];
            i++;
        }

        //---------------
        // LoadOrderGroup
        //---------------

        else if (STRICMP(argv[i], TEXT("group=")) == 0 && (i+1 < argc))
        {
            lpLoadOrderGroup = argv[i+1];
            i++;
        }

        //---------------
        // Tags
        //---------------

        else if (STRICMP(argv[i], TEXT("tag=")) == 0 && (i+1 < argc))
        {
            if (STRICMP(argv[i+1], TEXT("YES"))==0)
            {
                lpdwTagId = &TagId;
            }

            i++;
        }

        //---------------
        // DisplayName
        //---------------

        else if (STRICMP(argv[i], TEXT("DisplayName=")) == 0 && (i+1 < argc))
        {
            lpDisplayName = argv[i+1];
            i++;
        }

        //---------------
        // Dependencies
        //---------------

        else if (STRICMP(argv[i], TEXT("depend=")) == 0 && (i+1 < argc))
        {
            tempDepend = argv[i+1];
            bufSize = (UINT)STRSIZE(tempDepend);

            lpDependencies = (LPTSTR)LocalAlloc(
                                LMEM_ZEROINIT,
                                bufSize + sizeof(TCHAR));

            if (lpDependencies == NULL)
            {
                APIFailed(L"SendConfigToService: LocalAlloc", GetLastError());
                return 0;
            }

            //
            // Put NULLs in place of forward slashes in the string.
            //

            STRCPY(lpDependencies, tempDepend);
            tempDepend = lpDependencies;

            while (*tempDepend != TEXT('\0'))
            {
                if (*tempDepend == TEXT('/'))
                {
                    *tempDepend = TEXT('\0');
                }

                tempDepend++;
            }

            i++;
        }

        //------------------
        // ServiceStartName
        //------------------

        else if (STRICMP(argv[i], TEXT("obj=")) == 0 && (i+1 < argc))
        {
            lpServiceStartName = argv[i+1];
            i++;
        }

        //---------------
        // Password
        //---------------

        else if (STRICMP(argv[i], TEXT("password=")) == 0 && (i+1 < argc))
        {
            lpPassword = argv[i+1];
            i++;
        }
        else
        {
            CreateUsage();
            return(0);
        }
    }

    if (dwServiceType == SERVICE_NO_CHANGE)
    {
        dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    }

    hService = CreateService(
                    hScManager,                     // hSCManager
                    pServiceName,                   // lpServiceName
                    lpDisplayName,                  // lpDisplayName
                    SERVICE_ALL_ACCESS,             // dwDesiredAccess
                    dwServiceType,                  // dwServiceType
                    dwStartType,                    // dwStartType
                    dwErrorControl,                 // dwErrorControl
                    lpBinaryPathName,               // lpBinaryPathName
                    lpLoadOrderGroup,               // lpLoadOrderGroup
                    lpdwTagId,                      // lpdwTagId
                    lpDependencies,                 // lpDependencies
                    lpServiceStartName,             // lpServiceStartName
                    lpPassword);                    // lpPassword

    if (hService == NULL)
    {
        APIFailed(L"CreateService", GetLastError());
    }
    else
    {
        APISucceeded(L"CreateService");
    }

    CloseServiceHandle(hService);

    return 0;
}


VOID
EnumDepend(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufSize
    )

/*++

Routine Description:

    Enumerates the services dependent on the service identified by the
    ServiceName argument.

Arguments:



Return Value:



--*/
{
    SC_HANDLE               hService;
    DWORD                   status=NO_ERROR;
    DWORD                   i;
    LPENUM_SERVICE_STATUS   enumBuffer = NULL;
    LPENUM_SERVICE_STATUS   tempBuffer;
    STATUS_UNION            StatusUnion;
    DWORD                   entriesRead;
    DWORD                   bytesNeeded;

    hService = OpenService(
                hScManager,
                ServiceName,
                SERVICE_ENUMERATE_DEPENDENTS);

    if (hService == NULL)
    {
        APIFailed(L"OpenService", GetLastError());
        return;
    }

    if (bufSize > 0)
    {
        enumBuffer = (LPENUM_SERVICE_STATUS) LocalAlloc(LMEM_FIXED, bufSize);

        if (enumBuffer == NULL)
        {
            APIFailed(L"EnumDepend: LocalAlloc", GetLastError());
            CloseServiceHandle(hService);
            return;
        }
    }
    else
    {
        enumBuffer = NULL;
    }

    if (!EnumDependentServices(
            hService,
            SERVICE_ACTIVE | SERVICE_INACTIVE,
            enumBuffer,
            bufSize,
            &bytesNeeded,
            &entriesRead))
    {
        status = GetLastError();
    }

    //===========================
    // Display the returned data
    //===========================

    if ((status == NO_ERROR)       ||
        (status == ERROR_MORE_DATA))
    {
        APINeedsLargerBuffer(L"EnumDependentServices", SC_DISPLAY_ENUM_NUMBER, entriesRead, 0);

        for (i = 0, tempBuffer = enumBuffer; i < entriesRead; i++ )
        {
            StatusUnion.Regular = &(tempBuffer->ServiceStatus);

            DisplayStatus(
                tempBuffer->lpServiceName,
                tempBuffer->lpDisplayName,
                &StatusUnion,
                TRUE);

            tempBuffer++;
        }

        if (status == ERROR_MORE_DATA)
        {
            APINeedsLargerBuffer(L"EnumDependentServices",
                                 SC_API_INSUFFICIENT_BUFFER_ENUMDEPEND,
                                 bytesNeeded,
                                 0);
        }
    }
    else
    {
        APIFailed(L"EnumDependentServices", status);
    }

    if (enumBuffer != NULL)
    {
        LocalFree(enumBuffer);
    }
}


VOID
ShowSecurity(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName
    )
{
    SC_HANDLE   hService;
    DWORD       status = NO_ERROR;
    DWORD       dwDummy;
    DWORD       dwOpenLevel = READ_CONTROL;
    DWORD       dwLevel;
    BYTE        lpBuffer[1024];
    LPBYTE      lpActualBuffer = lpBuffer;
    LPTSTR      lpStringSD;
    NTSTATUS    EnableStatus;
    BOOLEAN     fWasEnabled = FALSE;

    //
    // Try for DACL + SACL -- if that fails, try for DACL only
    //

    EnableStatus = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                                      TRUE,
                                      FALSE,
                                      &fWasEnabled);

    if (NT_SUCCESS(EnableStatus))
    {
        //
        // We have the security privilege so we can get the SACL
        //

        dwOpenLevel |= ACCESS_SYSTEM_SECURITY;
    }

    hService = OpenService(hScManager,
                           ServiceName,
                           dwOpenLevel);

    if (hService == NULL)
    {
        status = GetLastError();
    }

    //
    // Release the privilege if we got it
    //

    if (NT_SUCCESS(EnableStatus))
    {
        RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                           fWasEnabled,
                           FALSE,
                           &fWasEnabled);
    }

    if (status == ERROR_ACCESS_DENIED && (dwOpenLevel & ACCESS_SYSTEM_SECURITY))
    {
        //
        // Try again, but just for the DACL
        //

        status      = NO_ERROR;
        dwOpenLevel = READ_CONTROL;

        hService = OpenService(hScManager,
                               ServiceName,
                               dwOpenLevel);

        if (hService == NULL)
        {
            status = GetLastError();
        }
    }

    if (status != NO_ERROR)
    {
        APIFailed(L"OpenService", status);
        return;
    }

    dwLevel = (dwOpenLevel & ACCESS_SYSTEM_SECURITY) ?
                  DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION :
                  DACL_SECURITY_INFORMATION;

    if (!QueryServiceObjectSecurity(hService,
                                    dwLevel,
                                    (PSECURITY_DESCRIPTOR) lpBuffer,
                                    sizeof(lpBuffer),
                                    &dwDummy))
    {
        status = GetLastError();

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            lpActualBuffer = LocalAlloc(LMEM_FIXED, dwDummy);

            if (lpActualBuffer == NULL)
            {
                APIFailed(L"QueryServiceObjectSecurity", GetLastError());
                CloseServiceHandle(hService);
                return;
            }

            status = NO_ERROR;

            if (!QueryServiceObjectSecurity(hService,
                                            dwLevel,
                                            (PSECURITY_DESCRIPTOR) lpActualBuffer,
                                            dwDummy,
                                            &dwDummy))
            {
                status = GetLastError();
            }
        }
    }

    if (status != NO_ERROR)
    {
        APIFailed(L"QueryServiceObjectSecurity", status);

        CloseServiceHandle(hService);

        if (lpActualBuffer != lpBuffer)
        {
            LocalFree(lpActualBuffer);
        }

        return;
    }

    if (!ConvertSecurityDescriptorToStringSecurityDescriptor(
            (PSECURITY_DESCRIPTOR) lpBuffer,
            SDDL_REVISION_1,
            dwLevel,
            &lpStringSD,
            NULL))
    {
        APIFailed(L"ConvertSecurityDescriptorToStringSecurityDescriptor", GetLastError());

        CloseServiceHandle(hService);

        if (lpActualBuffer != lpBuffer)
        {
            LocalFree(lpActualBuffer);
        }

        return;
    }

    FormatAndDisplayMessage(SC_DISPLAY_SD, &lpStringSD);

    LocalFree(lpStringSD);

    CloseServiceHandle(hService);

    if (lpActualBuffer != lpBuffer)
    {
        LocalFree(lpActualBuffer);
    }
}


VOID
SetSecurity(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  LPTSTR      lpStringSD
    )
{
    SC_HANDLE   hService;
    DWORD       dwLevel = 0;
    DWORD       dwOpenLevel = 0;
    DWORD       dwRevision;
    NTSTATUS    EnableStatus = STATUS_UNSUCCESSFUL;
    BOOLEAN     fWasEnabled;

    PSECURITY_DESCRIPTOR         pSD;
    SECURITY_DESCRIPTOR_CONTROL  Control;

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            lpStringSD,
            SDDL_REVISION_1,
            &pSD,
            NULL))
    {
        APIFailed(L"ConvertStringSecurityDescriptorToSecurityDescriptor", GetLastError());
        return;
    }

    if (!GetSecurityDescriptorControl(pSD, &Control, &dwRevision))
    {
        APIFailed(L"GetSecurityDescriptorControl", GetLastError());
        LocalFree(pSD);
        return;
    }

    if (Control & SE_DACL_PRESENT)
    {
        dwLevel     |= DACL_SECURITY_INFORMATION;
        dwOpenLevel |= WRITE_DAC;
    }

    if (Control & SE_SACL_PRESENT)
    {
        dwLevel     |= SACL_SECURITY_INFORMATION;
        dwOpenLevel |= ACCESS_SYSTEM_SECURITY;

        //
        // Setting the SACL requires the security privilege
        //

        EnableStatus = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                                          TRUE,
                                          FALSE,
                                          &fWasEnabled);
    }

    hService = OpenService(hScManager,
                           ServiceName,
                           dwOpenLevel);

    if (hService == NULL)
    {
        APIFailed(L"OpenService", GetLastError());
        LocalFree(pSD);
        return;
    }

    //
    // Release the privilege if we enabled it
    //

    if (NT_SUCCESS(EnableStatus))
    {
        RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                           TRUE,
                           FALSE,
                           &fWasEnabled);
    }

    if (!SetServiceObjectSecurity(hService, dwLevel, pSD))
    {
        APIFailed(L"SetServiceObjectSecurity", GetLastError());
    }
    else
    {
        APISucceeded(L"SetServiceObjectSecurity");
    }

    CloseServiceHandle(hService);
    LocalFree(pSD);
}    


DWORD
GetServiceLockStatus(
    IN  SC_HANDLE   hScManager,
    IN  DWORD       bufferSize
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD                           status = NO_ERROR;
    LPQUERY_SERVICE_LOCK_STATUS     LockStatus;
    DWORD                           bytesNeeded;
    WCHAR                           wszDuration[11];
    LPWSTR                          lpStrings[2];

    //
    // Allocate memory for the buffer.
    //
    LockStatus = (LPQUERY_SERVICE_LOCK_STATUS) LocalAlloc(LMEM_FIXED, (UINT) bufferSize);

    if (LockStatus == NULL)
    {
        APIFailed(L"GetServiceLockStatus: LocalAlloc", GetLastError());
        return 0;
    }


    if (!QueryServiceLockStatus(
            hScManager,
            LockStatus,
            bufferSize,
            &bytesNeeded))
    {
        APIFailed(L"QueryServiceLockStatus", GetLastError());

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            APINeedsLargerBuffer(L"QueryServiceLockStatus",
                                 SC_API_INSUFFICIENT_BUFFER,
                                 bytesNeeded,
                                 0);
        }

        return 0;
    }

    APISucceeded(L"QueryServiceLockStatus");

    if (LockStatus->fIsLocked)
    {
        FormatAndDisplayMessage(SC_DISPLAY_LOCKED_TRUE, NULL);
    }
    else
    {
        FormatAndDisplayMessage(SC_DISPLAY_LOCKED_FALSE, NULL);
    }

    lpStrings[0] = LockStatus->lpLockOwner;

    _itow(LockStatus->dwLockDuration, wszDuration, 10);
    lpStrings[1] = wszDuration;

    FormatAndDisplayMessage(SC_DISPLAY_LOCK_STATS, lpStrings);
    return 0;
}


VOID
LockServiceActiveDatabase(
    IN SC_HANDLE    hScManager
    )
{
    SC_LOCK Lock;
    int ch;

    Lock = LockServiceDatabase(hScManager);

    CloseServiceHandle(hScManager);

    if (Lock == NULL)
    {
        APIFailed(L"LockServiceDatabase", GetLastError());
        return;
    }

    FormatAndDisplayMessage(SC_DISPLAY_DATABASE_LOCKED, NULL);

    ch = _getche();
    if ( isupper( ch ))
        ch = _tolower( ch );

    if (ch == GetPromptCharacter( SC_PROMPT_UNLOCK_CHARACTER ))
    {
        //
        // Call API to unlock
        //
        if (!UnlockServiceDatabase(Lock))
        {
            APIFailed(L"UnlockServiceDatabase", GetLastError());
        }
        else
        {
            APISucceeded(L"UnlockServiceDatabase");
        }

        return;
    }

    //
    // Otherwise just exit, RPC rundown routine will unlock.
    //

    FormatAndDisplayMessage(SC_DISPLAY_DATABASE_UNLOCKING, NULL);
}


LPWSTR
GetErrorText(
    IN  DWORD Error
    )
{
    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  Error,
                  0,
                  MessageBuffer,
                  MESSAGE_BUFFER_LENGTH,
                  NULL);

    return MessageBuffer;
}


VOID
DisplayStatus (
    IN  LPTSTR              ServiceName,
    IN  LPTSTR              DisplayName,
    IN  LPSTATUS_UNION      lpStatusUnion,
    IN  BOOL                fIsStatusOld
    )

/*++

Routine Description:

    Displays the service name and  the service status.

    |
    |SERVICE_NAME: messenger
    |DISPLAY_NAME: messenger
    |        TYPE       : WIN32
    |        STATE      : ACTIVE,STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN
    |        EXIT_CODE  : 0xC002001
    |        CHECKPOINT : 0x00000001
    |        WAIT_HINT  : 0x00003f21
    |

Arguments:

    ServiceName - This is a pointer to a string containing the name of
        the service.

    DisplayName - This is a pointer to a string containing the display
        name for the service.

    ServiceStatus - This is a pointer to a SERVICE_STATUS structure from
        which information is to be displayed.

Return Value:

    none.

--*/
{
    DWORD   TempServiceType;
    BOOL    InteractiveBit = FALSE;
    LPWSTR  lpStrings[18];
    WCHAR   wszType[11];
    WCHAR   wszState[11];
    WCHAR   wszWin32ExitCode[11];
    WCHAR   wszWin32ExitCodeHex[11];
    WCHAR   wszServiceExitCode[11];
    WCHAR   wszServiceExitCodeHex[11];
    WCHAR   wszCheckPoint[11];
    WCHAR   wszWaitHint[11];
    WCHAR   wszPid[11];
    UINT    uMsg = SC_DISPLAY_STATUS_WITHOUT_DISPLAY_NAME;

    LPSERVICE_STATUS ServiceStatus;

    if (fIsStatusOld)
    {
        ServiceStatus = lpStatusUnion->Regular;
    }
    else
    {
        ServiceStatus = (LPSERVICE_STATUS) lpStatusUnion->Ex;
        uMsg = SC_DISPLAY_STATUSEX_WITHOUT_DISPLAY_NAME;
    }

    TempServiceType = ServiceStatus->dwServiceType;

    if (TempServiceType & SERVICE_INTERACTIVE_PROCESS)
    {
        InteractiveBit = TRUE;
        TempServiceType &= (~SERVICE_INTERACTIVE_PROCESS);
    }

    lpStrings[0] = ServiceName;

    if (DisplayName == NULL)
    {
        lpStrings[1] = L"";
    }
    else
    {
        //
        // Relies on "status w/ display name" string IDs being one
        // greater than associated "status w/o display name" IDs
        //

        uMsg++;
        lpStrings[1] = DisplayName;
    }

    _itow(ServiceStatus->dwServiceType, wszType, 16);
    lpStrings[2] = wszType;

    switch(TempServiceType)
    {
        case SERVICE_WIN32_OWN_PROCESS:
            lpStrings[3] = L"WIN32_OWN_PROCESS ";
            break;

        case SERVICE_WIN32_SHARE_PROCESS:
            lpStrings[3] = L"WIN32_SHARE_PROCESS ";
            break;

        case SERVICE_WIN32:
            lpStrings[3] = L"WIN32 ";
            break;

        case SERVICE_ADAPTER:
            lpStrings[3] = L"ADAPTER ";
            break;

        case SERVICE_KERNEL_DRIVER:
            lpStrings[3] = L"KERNEL_DRIVER ";
            break;

        case SERVICE_FILE_SYSTEM_DRIVER:
            lpStrings[3] = L"FILE_SYSTEM_DRIVER ";
            break;

        case SERVICE_DRIVER:
            lpStrings[3] = L"DRIVER ";
            break;

        default:
            lpStrings[3] = L" ERROR ";
    }

    if (InteractiveBit)
    {
        lpStrings[4] = L"(interactive)";
    }
    else
    {
        lpStrings[4] = L"";
    }

    _itow(ServiceStatus->dwCurrentState, wszState, 16);
    lpStrings[5] = wszState;

    switch(ServiceStatus->dwCurrentState)
    {
        case SERVICE_STOPPED:
            lpStrings[6] = L"STOPPED ";
            break;

        case SERVICE_START_PENDING:
            lpStrings[6] = L"START_PENDING ";
            break;

        case SERVICE_STOP_PENDING:
            lpStrings[6] = L"STOP_PENDING ";
            break;

        case SERVICE_RUNNING:
            lpStrings[6] = L"RUNNING ";
            break;

        case SERVICE_CONTINUE_PENDING:
            lpStrings[6] = L"CONTINUE_PENDING ";
            break;

        case SERVICE_PAUSE_PENDING:
            lpStrings[6] = L"PAUSE_PENDING ";
            break;

        case SERVICE_PAUSED:
            lpStrings[6] = L"PAUSED ";
            break;

        default:
            lpStrings[6] = L" ERROR ";
    }

    //
    // Controls Accepted Information
    //

    lpStrings[7] = ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_STOP ?
                       L"STOPPABLE" : L"NOT_STOPPABLE";

    lpStrings[8] = ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE ?
                       L"PAUSABLE" : L"NOT_PAUSABLE";

    lpStrings[9] = ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN ?
                       L"ACCEPTS_SHUTDOWN" : L"IGNORES_SHUTDOWN)";

    //
    // Exit Code
    //

    _itow(ServiceStatus->dwWin32ExitCode, wszWin32ExitCode, 10);
    lpStrings[10] = wszWin32ExitCode;

    _itow(ServiceStatus->dwWin32ExitCode, wszWin32ExitCodeHex, 16);
    lpStrings[11] = wszWin32ExitCodeHex;

    _itow(ServiceStatus->dwServiceSpecificExitCode, wszServiceExitCode, 10);
    lpStrings[12] = wszServiceExitCode;

    _itow(ServiceStatus->dwServiceSpecificExitCode, wszServiceExitCodeHex, 16);
    lpStrings[13] = wszServiceExitCodeHex;

    //
    // CheckPoint & WaitHint Information
    //

    _itow(ServiceStatus->dwCheckPoint, wszCheckPoint, 16);
    lpStrings[14] = wszCheckPoint;

    _itow(ServiceStatus->dwWaitHint, wszWaitHint, 16);
    lpStrings[15] = wszWaitHint;


    //
    // PID and flags (if QueryServiceStatusEx was called)
    //

    if (!fIsStatusOld)
    {
        _itow(lpStatusUnion->Ex->dwProcessId, wszPid, 10);
        lpStrings[16] = wszPid;

        lpStrings[17] = lpStatusUnion->Ex->dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS ?
                            L"RUNS_IN_SYSTEM_PROCESS" :
                            L"";
    }

    FormatAndDisplayMessage(uMsg, lpStrings);

    return;
}


DWORD
GetServiceConfig(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufferSize,
    OUT LPSC_HANDLE lphService
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD                   status = NO_ERROR;
    LPQUERY_SERVICE_CONFIG  ServiceConfig;
    DWORD                   bytesNeeded;
    LPTSTR                  pDepend;

    //
    // Allocate memory for the buffer.
    //
    if (bufferSize != 0)
    {
        ServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_FIXED, (UINT)bufferSize);

        if (ServiceConfig == NULL)
        {
            APIFailed(L"GetServiceConfig: LocalAlloc", GetLastError());
            return 0;
        }
    }
    else
    {
        ServiceConfig = NULL;
    }

    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    ServiceName,
                    SERVICE_QUERY_CONFIG);

    if (*lphService == NULL)
    {
        APIFailed(L"OpenService", GetLastError());
        return 0; 
    }

    if (!QueryServiceConfig(
            *lphService,
            ServiceConfig,
            bufferSize,
            &bytesNeeded))
    {
        status = GetLastError();
    }

    if (status == NO_ERROR)
    {
        DWORD   TempServiceType = ServiceConfig->dwServiceType;
        BOOL    InteractiveBit = FALSE;
        LPWSTR  lpStrings[13];
        WCHAR   wszType[11];
        WCHAR   wszStartType[11];
        WCHAR   wszErrorControl[11];
        WCHAR   wszTag[11];

        if (TempServiceType & SERVICE_INTERACTIVE_PROCESS)
        {
            InteractiveBit = TRUE;
            TempServiceType &= (~SERVICE_INTERACTIVE_PROCESS);
        }

        APISucceeded(L"QueryServiceConfig");

        lpStrings[0] = ServiceName;

        _itow(ServiceConfig->dwServiceType, wszType, 16);
        lpStrings[1] = wszType;

        switch(TempServiceType)
        {
            case SERVICE_WIN32_OWN_PROCESS:
                lpStrings[2] = L"WIN32_OWN_PROCESS";
                break;

            case SERVICE_WIN32_SHARE_PROCESS:
                lpStrings[2] = L"WIN32_SHARE_PROCESS";
                break;

            case SERVICE_WIN32:
                lpStrings[2] = L"WIN32";
                break;

            case SERVICE_ADAPTER:
                lpStrings[2] = L"ADAPTER";
                break;

            case SERVICE_KERNEL_DRIVER:
                lpStrings[2] = L"KERNEL_DRIVER";
                break;

            case SERVICE_FILE_SYSTEM_DRIVER:
                lpStrings[2] = L"FILE_SYSTEM_DRIVER";
                break;

            case SERVICE_DRIVER:
                lpStrings[2] = L"DRIVER";
                break;

            default:
                lpStrings[2] = L"ERROR";
        }

        lpStrings[3] = InteractiveBit ? L"(interactive)" : L"";

        _itow(ServiceConfig->dwStartType, wszStartType, 16);
        lpStrings[4] = wszStartType;

        switch(ServiceConfig->dwStartType)
        {
            case SERVICE_BOOT_START:
                lpStrings[5] = L"BOOT_START";
                break;

            case SERVICE_SYSTEM_START:
                lpStrings[5] = L"SYSTEM_START";
                break;

            case SERVICE_AUTO_START:
                lpStrings[5] = L"AUTO_START";
                break;

            case SERVICE_DEMAND_START:
                lpStrings[5] = L"DEMAND_START";
                break;

            case SERVICE_DISABLED:
                lpStrings[5] = L"DISABLED";
                break;

            default:
                lpStrings[5] = L"ERROR";
        }


        _itow(ServiceConfig->dwErrorControl, wszErrorControl, 16);
        lpStrings[6] = wszErrorControl;

        switch(ServiceConfig->dwErrorControl)
        {
            case SERVICE_ERROR_NORMAL:
                lpStrings[7] = L"NORMAL";
                break;

            case SERVICE_ERROR_SEVERE:
                lpStrings[7] = L"SEVERE";
                break;

            case SERVICE_ERROR_CRITICAL:
                lpStrings[7] = L"CRITICAL";
                break;

            case SERVICE_ERROR_IGNORE:
                lpStrings[7] = L"IGNORE";
                break;

            default:
                lpStrings[7] = L"ERROR";
        }

        lpStrings[8]  = ServiceConfig->lpBinaryPathName;
        lpStrings[9]  = ServiceConfig->lpLoadOrderGroup;

        _itow(ServiceConfig->dwTagId, wszTag, 10);
        lpStrings[10] = wszTag;

        lpStrings[11] = ServiceConfig->lpDisplayName;
        lpStrings[12] = ServiceConfig->lpDependencies;

        FormatAndDisplayMessage(SC_DISPLAY_CONFIG, lpStrings);

        //
        // Print the dependencies in the double terminated array of strings.
        //

        pDepend = ServiceConfig->lpDependencies;
        pDepend = pDepend + (STRLEN(pDepend)+1);

        while (*pDepend != '\0')
        {
            if (*pDepend != '\0')
            {
                FormatAndDisplayMessage(SC_DISPLAY_CONFIG_DEPENDENCY, &pDepend);
            }

            pDepend = pDepend + (STRLEN(pDepend)+1);
        }

        FormatAndDisplayMessage(SC_DISPLAY_CONFIG_START_NAME, &ServiceConfig->lpServiceStartName);
    }
    else
    {
        APIFailed(L"QueryServiceConfig", status);

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            APINeedsLargerBuffer(L"GetServiceConfig",
                                 SC_API_INSUFFICIENT_BUFFER,
                                 bytesNeeded,
                                 0);
        }
    }

    return 0;
}


DWORD
GetConfigInfo(
    IN  SC_HANDLE   hScManager,
    IN  LPTSTR      ServiceName,
    IN  DWORD       bufferSize,
    OUT LPSC_HANDLE lphService,
    IN  DWORD       dwInfoLevel
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/

{
    DWORD       status = NO_ERROR;
    LPBYTE      lpBuffer;
    DWORD       bytesNeeded;
    SC_ACTION   currentAction;
    DWORD       actionIndex;
    
    //
    // Allocate memory for the buffer.
    //
    if (bufferSize != 0)
    {
        lpBuffer = (LPBYTE) LocalAlloc(LMEM_FIXED, (UINT)bufferSize);

        if (lpBuffer == NULL)
        {
            APIFailed(L"GetConfigInfo: LocalAlloc", GetLastError());
            return 0;
        }
    }
    else
    {
        lpBuffer = NULL;
    }

    //
    // Open a handle to the service.
    //

    *lphService = OpenService(
                    hScManager,
                    ServiceName,
                    SERVICE_QUERY_CONFIG);

    if (*lphService == NULL)
    {
        APIFailed(L"OpenService", GetLastError());
        return 0;
    }

    //
    // Put the query info into lpBuffer
    //

    if (!QueryServiceConfig2(
                *lphService,
                dwInfoLevel,
                lpBuffer,
                bufferSize,
                &bytesNeeded))
    {
        status = GetLastError();
    }
        
    if (status == NO_ERROR)
    {
        APISucceeded(L"QueryServiceConfig2");
        
        if (dwInfoLevel == SERVICE_CONFIG_DESCRIPTION)
        {
            LPSERVICE_DESCRIPTION lpService = (LPSERVICE_DESCRIPTION) lpBuffer;

            LPWSTR lpStrings[2];

            lpStrings[0] = ServiceName;
            lpStrings[1] = lpService->lpDescription == NULL ? L"" : lpService->lpDescription;

            FormatAndDisplayMessage(SC_DISPLAY_DESCRIPTION, lpStrings);
        }
        else if (dwInfoLevel == SERVICE_CONFIG_FAILURE_ACTIONS)
        {
            LPWSTR lpStrings[5];
            WCHAR  wszPeriod[11];
            UINT   uMsg;

            LPSERVICE_FAILURE_ACTIONS lpFailure = (LPSERVICE_FAILURE_ACTIONS) lpBuffer;

            lpStrings[0] = ServiceName;

            if (lpFailure->dwResetPeriod == INFINITE)
            {
                lpStrings[1] = L"INFINITE";
            }
            else
            {
                _itow(lpFailure->dwResetPeriod, wszPeriod, 10);
                lpStrings[1] = wszPeriod;
            }

            lpStrings[2] = lpFailure->lpRebootMsg == NULL ? L"" : lpFailure->lpRebootMsg;
            lpStrings[3] = lpFailure->lpCommand == NULL   ? L"" : lpFailure->lpCommand;

            FormatAndDisplayMessage(SC_DISPLAY_FAILURE, lpStrings);

            for (actionIndex = 0; actionIndex < lpFailure->cActions; actionIndex++)
            {
                currentAction = lpFailure->lpsaActions[actionIndex];

                //
                // Print the action and delay -- for no action, print nothing.
                //

                switch (currentAction.Type)
                {
                    case SC_ACTION_RESTART:
                    case SC_ACTION_REBOOT:
                    case SC_ACTION_RUN_COMMAND:
                    {
                        LPWSTR lpStrings[1];

                        if (currentAction.Type == SC_ACTION_RESTART)
                        {
                            uMsg = SC_DISPLAY_FAILURE_RESTART_FIRST;
                        }
                        else if (currentAction.Type == SC_ACTION_REBOOT)
                        {
                            uMsg = SC_DISPLAY_FAILURE_REBOOT_FIRST;
                        }
                        else
                        {
                            uMsg = SC_DISPLAY_FAILURE_COMMAND_FIRST;
                        }

                        if (actionIndex != 0)
                        {
                            //
                            // Relies on message string IDs for 2nd+-time actions
                            // being one greater than their 1st-time counterparts
                            //

                            uMsg++;
                        }

                        _itow(currentAction.Delay, wszPeriod, 10);
                        lpStrings[0] = wszPeriod;

                        FormatAndDisplayMessage(uMsg, lpStrings);
                        break;
                    }

                    case SC_ACTION_NONE:
                    default:
                        break;
                }
            }

            FormatAndDisplayMessage(SC_DISPLAY_NEWLINE, NULL);
        }
    }
    else
    {
        APIFailed(L"QueryServiceConfig2", status);

        if (status == ERROR_INSUFFICIENT_BUFFER)
        {
            APINeedsLargerBuffer(L"GetConfigInfo",
                                 SC_API_INSUFFICIENT_BUFFER,
                                 bytesNeeded,
                                 0);
        }
    }

    return 0;
}


VOID
Usage(
    VOID
    )
{
    int    ch;
    LPWSTR lpEnumSize = DEFAULT_ENUM_BUFFER_STRING;

    FormatAndDisplayMessage(SC_HELP_GENERIC, NULL);

    ch = _getche();
    if ( isupper( ch ))
        ch = _tolower( ch );

    if (ch == GetPromptCharacter( SC_PROMPT_YES_CHARACTER ))
    {
        FormatAndDisplayMessage(SC_HELP_QUERY, &lpEnumSize);
    }

    MyWriteConsole(L"\n", 2);
}


VOID
ConfigUsage(
    VOID
    )
{
    FormatAndDisplayMessage(SC_HELP_CONFIG, NULL);
}


VOID
CreateUsage(
    VOID
    )
{
    FormatAndDisplayMessage(SC_HELP_CREATE, NULL);
}


VOID
ChangeFailureUsage(
    VOID
    )
{
    FormatAndDisplayMessage(SC_HELP_CHANGE_FAILURE, NULL);
}


VOID
APISucceeded(
    LPWSTR  lpAPI
    )
{
    FormatAndDisplayMessage(SC_API_SUCCEEDED, &lpAPI);
}


VOID
APIFailed(
    LPWSTR  lpAPI,
    DWORD   dwError
    )
{
    //
    // 10 characters can hold the largest DWORD as a string
    //

    WCHAR  wszErrorNum[11];
    LPWSTR lpStrings[3];

    _itow(dwError, wszErrorNum, 10);

    lpStrings[0] = lpAPI;
    lpStrings[1] = wszErrorNum;
    lpStrings[2] = GetErrorText(dwError);

    FormatAndDisplayMessage(SC_API_FAILED, lpStrings);
}


VOID
APINeedsLargerBuffer(
    LPWSTR lpAPI,
    UINT   uMsg,
    DWORD  dwBufSize,
    DWORD  dwResumeIndex
    )
{
    WCHAR  wszBufSize[11];
    WCHAR  wszResumeIndex[11];
    LPWSTR lpStrings[3];

    _itow(dwBufSize, wszBufSize, 10);

    lpStrings[0] = lpAPI;
    lpStrings[1] = wszBufSize;

    if (uMsg == SC_API_INSUFFICIENT_BUFFER_ENUM)
    {
        _itow(dwResumeIndex, wszResumeIndex, 10);
        lpStrings[2] = wszResumeIndex;
    }

    FormatAndDisplayMessage(uMsg, lpStrings);
}


VOID
APIInvalidField(
    LPWSTR lpField
    )
{
    FormatAndDisplayMessage(SC_API_INVALID_FIELD, &lpField);
}


VOID
FormatAndDisplayMessage(
    DWORD  dwMessageId,
    LPWSTR *lplpInsertionStrings
    )
{
    DWORD  dwNumChars;
    LPWSTR lpBuffer;

    dwNumChars = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_HMODULE |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               NULL,
                               dwMessageId,
                               0,
                               (LPWSTR) &lpBuffer,
                               INFINITE,
                               (va_list *) lplpInsertionStrings);

    if (dwNumChars != 0)
    {
        MyWriteConsole(lpBuffer, dwNumChars);
        LocalFree(lpBuffer);
    }
}


BOOL
FileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}


VOID
MyWriteConsole(
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(g_hStdOut))
    {
	WriteConsole(g_hStdOut, lpBuffer, cchBuffer, &cchBuffer, NULL);
    }
    else
    {
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, cchBuffer * sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            lpBuffer,
                                            cchBuffer,
                                            lpAnsiBuffer,
                                            cchBuffer * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                WriteFile(g_hStdOut, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL);
            }

            LocalFree(lpAnsiBuffer);
        }
    }
}

int
GetPromptCharacter(
    DWORD msgId
    )
{
    DWORD  dwNumChars;
    PSTR   lpBuffer;
    int    chRet = 'u';

    dwNumChars = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_HMODULE |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               NULL,
                               msgId,
                               0,
                               (PSTR) &lpBuffer,
                               INFINITE,
                               NULL );

    if (dwNumChars != 0)
    {
        chRet = lpBuffer[ 0 ];
        LocalFree(lpBuffer);
    }

    return chRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\account.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    account.h

Abstract:

    Security related function prototypes.

Author:

    Rita Wong (ritaw)     10-Apr-1992

Revision History:

--*/

#ifndef _SCACCOUNT_INCLUDED_
#define _SCACCOUNT_INCLUDED_

#define SC_LOCAL_DOMAIN_NAME         L"."
#define SC_LOCAL_DOMAIN_NAME_LENGTH  (sizeof(SC_LOCAL_DOMAIN_NAME) / sizeof(WCHAR) - 1)

#define SC_LOCAL_SYSTEM_USER_NAME   L"LocalSystem"
#define SC_LOCAL_NTAUTH_NAME        L"NT AUTHORITY"

#define SCDOMAIN_USERNAME_SEPARATOR L'\\'


//
// External global variables used by the lockapi.c module
//
extern UNICODE_STRING ScComputerName;
extern UNICODE_STRING ScAccountDomain;

BOOL
ScGetComputerNameAndMutex(
    VOID
    );

VOID
ScEndServiceAccount(
    VOID
    );

BOOL
ScInitServiceAccount(
    VOID
    );

DWORD
ScCanonAccountName(
    IN  LPWSTR AccountName,
    OUT LPWSTR *CanonAccountName
    );

DWORD
ScValidateAndSaveAccount(
    IN LPWSTR ServiceName,
    IN HKEY ServiceNameKey,
    IN LPWSTR CanonAccountName,
    IN LPWSTR Password OPTIONAL
    );

DWORD
ScValidateAndChangeAccount(
    IN LPSERVICE_RECORD ServiceRecord,
    IN HKEY             ServiceNameKey,
    IN LPWSTR           OldAccountName,
    IN LPWSTR           CanonAccountName,
    IN LPWSTR           Password OPTIONAL
    );

VOID
ScRemoveAccount(
    IN LPWSTR ServiceName
    );

DWORD
ScLookupServiceAccount(
    IN LPWSTR ServiceName,
    OUT LPWSTR *AccountName
    );

DWORD
ScLogonService(
    IN LPWSTR    ServiceName,
    IN LPWSTR    AccountName,
    OUT LPHANDLE ServiceToken,
    OUT LPHANDLE ProfileHandle OPTIONAL,
    OUT PSID     *ServiceSid
    );

DWORD
ScGetAccountDomainInfo(
    VOID
    );

#endif // _SCACCOUNT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\bootcfg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bootcfg.h

Abstract:

    Contains function prototypes for external functions in bootcfg.c

Author:

    Dan Lafferty (danl)     23-Apr-1991

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

    23-Apr-1991     danl
        created

--*/

#ifndef _BOOTCFG_INCLUDED
#define _BOOTCFG_INCLUDED

#include <winreg.h>

    extern  DWORD   ScGlobalLastKnownGood;

//
// The following are bit masks that are use to qualify our
// running with the Last Known Good configuration.
//  RUNNING_LKG     This flag is set anytime we are running LKG
//  REVERTED_TO_LKG This flag is only set if we are running LKG because
//                  of a failure.  (ie.  This flag is not set on the
//                  first boot when CURRENT=LKG).
//  AUTO_START_DONE This flag is set when the service controller is done
//                  auto-starting services.  This flag is protected by
//                  the ScBootConfigCriticalSection.
//  ACCEPT_DEFERRED This flag is set when the current configuration has
//                  been accepted as the LastKnownGood configuration.  This
//                  flag is protected by the ScBootConfigCriticalSection.
//
#define RUNNING_LKG     0x00000001
#define REVERTED_TO_LKG 0x00000002
#define AUTO_START_DONE 0x00000004
#define ACCEPT_DEFERRED 0x00000008

BOOL
ScCheckLastKnownGood(
    VOID
    );

DWORD
ScRevertToLastKnownGood(
    VOID
    );

VOID
ScDeleteRegServiceEntry(
    LPWSTR  ServiceName
    );

VOID
ScRunAcceptBootPgm(
    VOID
    );

#endif // #ifndef _BOOTCFG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\account.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    account.cxx

Abstract:

    This module contains service account related routines:
        ScInitServiceAccount
        ScEndServiceAccount
        ScCanonAccountName
        ScValidateAndSaveAccount
        ScValidateAndChangeAccount
        ScRemoveAccount
        ScLookupAccount
        ScSetPassword
        ScDeletePassword
        ScOpenPolicy
        ScFormSecretName
        ScLookupServiceAccount
        ScLogonService
        ScLoadUserProfile
        ScUPNToAccountName

Author:

    Rita Wong (ritaw)     19-Apr-1992

Environment:

    Calls NT native APIs.

Revision History:

    24-Jan-1993     Danl
        Added call to WNetLogonNotify when logging on a service (ScLogonService).

    29-Apr-1993     Danl
        ScGetAccountDomainInfo() is now only called at init time.  Otherwise,
        we risked race conditions because it updates a global location.
        (ScLocalDomain).

    17-Jan-1995     AnirudhS
        Added call to LsaOpenSecret when the secret already exists in
        ScCreatePassword.

    29-Nov-1995     AnirudhS
        Added call to LoadUserProfile when logging on a service.

    14-May-1996     AnirudhS
        Changed to simpler Lsa PrivateData APIs instead of Lsa Secret APIs
        for storing secrets and removed the use of OldPassword (as done in
        the _CAIRO_ version of this file on 05-Apr-1995).

    22-Oct-1997     JSchwart  (after AnirudhS in _CAIRO_ 10-Apr-1995)
        Split out ScLookupServiceAccount from ScLogonService.

    04-Mar-1999     jschwart
        Added support for UPNs

--*/

#include "precomp.hxx"
#include <stdlib.h>                 // srand, rand

extern "C" {
#include <ntlsa.h>                  // LsaOpenPolicy, LsaCreateSecret
}

#include <winerror.h>
#include <userenv.h>                // LoadUserProfile
#include <userenvp.h>               // PI_HIDEPROFILE flag
#include <tstr.h>                   // WCSSIZE
#include <ntdsapi.h>                // DsCrackNames
#include <sclib.h>                  // _wcsicmp
#include <scseclib.h>               // LocalSid
#include <svcslib.h>                // SetupInProgress()
#include "scconfig.h"               // ScWriteStartName
#include "account.h"                // Exported function prototypes

//-------------------------------------------------------------------//
//                                                                   //
// Constants and Macros                                              //
//                                                                   //
//-------------------------------------------------------------------//

#define SC_SECRET_PREFIX               L"_SC_"
#define SC_SECRET_PREFIX_LENGTH        (sizeof(SC_SECRET_PREFIX) / sizeof(WCHAR) - 1)

#define SC_UPN_SYMBOL                  L'@'

//-------------------------------------------------------------------//
//                                                                   //
// Static global variables                                           //
//                                                                   //
//-------------------------------------------------------------------//

//
// Mutex to serialize access to secret objects
//
HANDLE ScSecretObjectsMutex = (HANDLE) NULL;

UNICODE_STRING ScComputerName;
UNICODE_STRING ScAccountDomain;


//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
ScLookupAccount(
    IN  LPWSTR AccountName,
    OUT LPWSTR *DomainName,
    OUT LPWSTR *UserName
    );

DWORD
ScSetPassword(
    IN LPWSTR ServiceName,
    IN LPWSTR Password
    );

DWORD
ScDeletePassword(
    IN LPWSTR ServiceName
    );

DWORD
ScOpenPolicy(
    IN  ACCESS_MASK DesiredAccess,
    OUT LSA_HANDLE *PolicyHandle
    );

DWORD
ScFormSecretName(
    IN  LPWSTR ServiceName,
    OUT LPWSTR *LsaSecretName
    );

VOID
ScLoadUserProfile(
    IN  HANDLE  LogonToken,
    IN  LPWSTR  DomainName,
    IN  LPWSTR  UserName,
    OUT PHANDLE pProfileHandle OPTIONAL
    );

DWORD
ScUPNToAccountName(
    IN  LPWSTR  lpUPN,
    OUT LPWSTR  *ppAccountName
    );


//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//


BOOL
ScGetComputerNameAndMutex(
    VOID
    )
/*++

Routine Description:

    This function allocates the memory for the ScComputerName global
    pointer and retrieves the current computer name into it.  This
    functionality used to be in the ScInitAccount routine but has to
    be put into its own routine because the main initialization code
    needs to call this before ScInitDatabase() since the computername
    is needed for deleting service entries that have the persistent
    delete flag set.

    This function also creates ScSecretObjectsMutex because it is used
    to remove accounts early in the init process.

    If successful, the pointer to the computername must be freed when
    done.  This is freed by the ScEndServiceAccount routine called
    by SvcctrlMain().  The handle to ScSecretObjectsMutex is closed
    by ScSecretObjectsMutex.

Arguments:

    None

Return Value:

    TRUE - The operation was completely successful.

    FALSE - An error occurred.

--*/
{
    DWORD ComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;



    ScComputerName.Buffer = NULL;

    //
    // Allocate the exact size needed to hold the computername
    //
    if ((ScComputerName.Buffer = (LPWSTR)LocalAlloc(
                                     LMEM_ZEROINIT,
                                     (UINT) ComputerNameSize * sizeof(WCHAR)
                                     )) == NULL) {

        SC_LOG1(ERROR, "ScInitServiceAccount: LocalAlloc failed %lu\n", GetLastError());
        return FALSE;
    }

    ScComputerName.MaximumLength = (USHORT) ComputerNameSize * sizeof(WCHAR);

    if (! GetComputerNameW(
            ScComputerName.Buffer,
            &ComputerNameSize
            )) {

        SC_LOG2(ERROR, "GetComputerNameW returned %lu, required size=%lu\n",
                GetLastError(), ComputerNameSize);

        LocalFree(ScComputerName.Buffer);
        ScComputerName.Buffer = NULL;

        return FALSE;
    }

    ScComputerName.Length = (USHORT) (wcslen(ScComputerName.Buffer) * sizeof(WCHAR));

    SC_LOG(ACCOUNT, "ScInitServiceAccount: ScComputerName is "
           FORMAT_LPWSTR "\n", ScComputerName.Buffer);

    //
    // Create a mutex to serialize accesses to all secret objects.  A secret
    // object can be created, deleted, or set by installation programs, set
    // by the service controller during periodic password changes, and queried
    // or set by a start service operation.
    //
    ScSecretObjectsMutex = CreateMutex(NULL, FALSE, NULL);

    if (ScSecretObjectsMutex == NULL) {
        SC_LOG1(ERROR, "ScInitServiceAccount: CreateMutex failed "
                FORMAT_DWORD "\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}



BOOL
ScInitServiceAccount(
    VOID
    )
/*++

Routine Description:

    This function initializes accounts for services by
         2) Register service controller as an LSA logon process and
            lookup the MS V 1.0 authentication package.

Arguments:

    None

Return Value:

    TRUE - The operation was completely successful.

    FALSE - An error occurred.

--*/
{
    DWORD    status;

    //
    // Initialize the account domain buffer so that we know if it has
    // been filled in.
    //
    ScAccountDomain.Buffer = NULL;

    status = ScGetAccountDomainInfo();

    if (status != NO_ERROR)
    {
        SC_LOG1(ERROR, "ScInitServiceAccount: ScGetAccountDomainInfo failed "
                FORMAT_DWORD "\n", status);
        return FALSE;
    }

    return TRUE;
}


VOID
ScEndServiceAccount(
    VOID
    )
/*++

Routine Description:

    This function frees the memory for the ScComputerName global pointer,
    and closes the ScSecretObjectsMutex.

Arguments:

    None.

Return Value:

    None.
--*/
{
    //
    // Free computer name buffer allocated by ScGetComputerName
    //
    LocalFree(ScComputerName.Buffer);
    ScComputerName.Buffer = NULL;

    if (ScSecretObjectsMutex != (HANDLE) NULL)
    {
        CloseHandle(ScSecretObjectsMutex);
    }

    LocalFree(ScAccountDomain.Buffer);
}


DWORD
ScValidateAndSaveAccount(
    IN LPWSTR ServiceName,
    IN HKEY   ServiceNameKey,
    IN LPWSTR CanonAccountName,
    IN LPWSTR Password OPTIONAL
    )
/*++

Routine Description:

    This function verifies that the account is valid, and then saves
    the account information away.  The account name is saved in the
    registry under the service node in the ObjectName value.  The
    password is saved in an LSA secret object created which can be
    looked up based on the name string formed with the service name.

    This function can only be called for the installation of a Win32
    service (CreateService).

    NOTE:  The registry ServiceNameKey is NOT flushed by this function.

Arguments:

    ServiceName - Supplies the name of the service to save away account
        info for.  This makes up part of the secret object name to tuck
        away the password.

    ServiceNameKey - Supplies an opened registry key handle for the service.

    CanonAccountName - Supplies a canonicalized account name string in the
        format of DomainName\Username, LocalSystem, or UPN

    Password - Supplies the password of the account, if any.  This is
        ignored if LocalSystem is specified for the account name.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_SERVICE_ACCOUNT - The account name is invalid.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate work buffer.

    Registry error codes caused by failure to read old account name
    string.

--*/
{
    DWORD status;

    LPWSTR DomainName;
    LPWSTR UserName;

    LPWSTR lpNameToParse = CanonAccountName;

    //
    // Empty account name is invalid.
    //
    if ((CanonAccountName == NULL) || (*CanonAccountName == 0)) {
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    if (_wcsicmp(CanonAccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // CanonAccountName is LocalSystem.  Write to the registry and
        // we are done.
        //
        return ScWriteStartName(
                   ServiceNameKey,
                   SC_LOCAL_SYSTEM_USER_NAME
                   );

    }

    //
    // Account name is DomainName\UserName or a UPN
    //

    if (wcschr(CanonAccountName, SCDOMAIN_USERNAME_SEPARATOR) == NULL
         &&
        wcschr(CanonAccountName, SC_UPN_SYMBOL) != NULL)
    {
        //
        // It's a UPN -- we need to crack it
        //
        status = ScUPNToAccountName(CanonAccountName, &lpNameToParse);

        if (status != NO_ERROR) {
            return status;
        }
    }

    //
    // Look up the account to see if it exists.
    //
    if ((status = ScLookupAccount(
                      lpNameToParse,
                      &DomainName,
                      &UserName
                      )) != NO_ERROR) {

        if (lpNameToParse != CanonAccountName) {
            LocalFree(lpNameToParse);
        }

        return status;
    }

    //
    // Write the new account name to the registry.
    // Note -- for UPNs, write the UPN to the registry, not
    // the cracked UPN
    //
    if ((status = ScWriteStartName(
                      ServiceNameKey,
                      CanonAccountName
                      )) != NO_ERROR) {

        if (lpNameToParse != CanonAccountName) {
            LocalFree(lpNameToParse);
        }

        LocalFree(DomainName);
        return status;
    }

    //
    // Create the password for the new account.
    //
    status = ScSetPassword(
                 ServiceName,
                 Password
                 );

    if (lpNameToParse != CanonAccountName) {
        LocalFree(lpNameToParse);
    }

    LocalFree(DomainName);
    return status;

    //
    // Don't have to worry about removing the account name written to
    // the registry if ScSetPassword returned an error because the
    // entire service key will be deleted by the caller of this routine.
    //
}


DWORD
ScValidateAndChangeAccount(
    IN LPSERVICE_RECORD  ServiceRecord,
    IN HKEY              ServiceNameKey,
    IN LPWSTR            OldAccountName,
    IN LPWSTR            CanonAccountName,
    IN LPWSTR            Password OPTIONAL
    )
/*++

Routine Description:

    This function validates that the account is valid, and then replaces
    the old account information.  The account name is saved in the
    registry under the service node in the ObjectName value.  The
    password is saved in an LSA secret object created which can be
    looked up based on the name string formed with the service name.

    This function can only be called for the reconfiguration of a Win32
    service (ChangeServiceConfig).

    NOTE:  The registry ServiceNameKey is NOT flushed by this function.

Arguments:

    ServiceRecord - Supplies the record of the service to change account
        info.  This makes up part of the secret object name to tuck
        away the password.

    ServiceNameKey - Supplies an opened registry key handle for the service.

    OldAccountName - Supplies the string to the old account name.

    CanonAccountName - Supplies a canonicalized account name string in the
        format of DomainName\Username, LocalSystem, or a UPN.

    Password - Supplies the password of the account, if any.  This is
        ignored if LocalSystem is specified for the account name.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_SERVICE_ACCOUNT - The account name is invalid.

    ERROR_ALREADY_EXISTS - Attempt to create an LSA secret object that
        already exists.

    Registry error codes caused by failure to read old account name
    string.

--*/
{
    DWORD status;

    LPWSTR DomainName;
    LPWSTR UserName;

    BOOL   fIsUPN = FALSE;
    LPWSTR lpNameToParse = CanonAccountName;

    if ((CanonAccountName == OldAccountName) ||
        (_wcsicmp(CanonAccountName, OldAccountName) == 0)) {

        //
        // Newly specified account name is identical to existing
        // account name.
        //

        if (Password == NULL) {

            //
            // Not changing account name or password.
            //
            return NO_ERROR;
        }

        if (_wcsicmp(CanonAccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

            //
            // Account name is LocalSystem and password is specified.
            // Just ignore.
            //
            return NO_ERROR;
        }
        else {

            //
            // Account name is DomainName\UserName or a UPN.
            // Set the specified password.
            //

            status = ScSetPassword(
                         ServiceRecord->ServiceName,
                         Password);

            return status;
        }
    }

    //
    // Newly specified account name is different from existing
    // account name.
    //

    if (_wcsicmp(CanonAccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // Change from DomainName\UserName or UPN to LocalSystem
        //

        //
        // Write the new account name to the registry.
        //
        if ((status = ScWriteStartName(
                          ServiceNameKey,
                          SC_LOCAL_SYSTEM_USER_NAME
                          )) != NO_ERROR) {

            return status;
        }

        //
        // Account name is LocalSystem and password is specified.
        // Ignore the password specified, and delete the password
        // for the old account.
        //
        status = ScDeletePassword(ServiceRecord->ServiceName);

        if (status != NO_ERROR) {
            //
            // Restore the old account name to the registry.
            //
            ScWriteStartName(ServiceNameKey,
                             OldAccountName);

        }
        else {

            LPWSTR  CurrentDependencies;

            //
            // Get rid of the implicit dependency on NetLogon since this
            // service no longer runs in an account.  Since the dependency
            // on NetLogon is soft (i.e., not stored in the registry),
            // simply read in the dependencies and update the service record
            //

            status = ScReadDependencies(ServiceNameKey,
                                        &CurrentDependencies,
                                        ServiceRecord->ServiceName);

            if (status == NO_ERROR) {

                //
                // Dynamically update the dependencies
                //

                status = ScUpdateServiceRecordConfig(
                             ServiceRecord,
                             SERVICE_NO_CHANGE,
                             SERVICE_NO_CHANGE,
                             SERVICE_NO_CHANGE,
                             NULL,
                             (LPBYTE) CurrentDependencies);

                if (status != NO_ERROR) {

                    SC_LOG1(ERROR,
                            "ScValidateAndChangeAccount: ScUpdateServiceRecordConfig "
                                "FAILED %d\n",
                            status);
                }

                LocalFree(CurrentDependencies);
            }
            else {

                SC_LOG1(ERROR,
                        "ScValidateAndChangeAccount: ScReadDependencies "
                            "FAILED %d\n",
                        status);
            }
        }

        return status;
    }

    if (Password == NULL)
    {
        //
        // Cannot specify new non-SYSTEM account name
        // without specifying the password also.
        //

        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    if (_wcsicmp(OldAccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0)
    {
        //
        // Change from LocalSystem to DomainName\UserName or UPN.
        //
        if (wcschr(CanonAccountName, SCDOMAIN_USERNAME_SEPARATOR) == NULL
             &&
            wcschr(CanonAccountName, SC_UPN_SYMBOL) != NULL)
        {
            fIsUPN = TRUE;
            status = ScUPNToAccountName(CanonAccountName, &lpNameToParse);

            if (status != NO_ERROR)
            {
                return status;
            }
        }

        if ((status = ScLookupAccount(
                          lpNameToParse,
                          &DomainName,
                          &UserName
                          )) != NO_ERROR)
        {
            if (fIsUPN)
            {
                LocalFree(lpNameToParse);
            }

            return status;
        }

        //
        // Write the new account name to the registry.
        //
        if ((status = ScWriteStartName(
                          ServiceNameKey,
                          CanonAccountName
                          )) != NO_ERROR)
        {
            if (fIsUPN)
            {
                LocalFree(lpNameToParse);
            }

            LocalFree(DomainName);
            return status;
        }

        //
        // Create the password for the new account.
        //
        status = ScSetPassword(ServiceRecord->ServiceName, Password);


        if (status != NO_ERROR)
        {
            //
            // Restore the old account name to the registry.
            //

            ScWriteStartName(ServiceNameKey, SC_LOCAL_SYSTEM_USER_NAME);
        }

        if (fIsUPN)
        {
            LocalFree(lpNameToParse);
        }

        LocalFree(DomainName);
        return status;
    }

    //
    // Must be changing an account of DomainName\UserName or UPN to
    // DomainName\UserName or UPN
    //
    if (wcschr(CanonAccountName, SCDOMAIN_USERNAME_SEPARATOR) == NULL
         &&
        wcschr(CanonAccountName, SC_UPN_SYMBOL) != NULL)
    {
        fIsUPN = TRUE;
        status = ScUPNToAccountName(CanonAccountName, &lpNameToParse);

        if (status != NO_ERROR)
        {
            return status;
        }
    }

    if ((status = ScLookupAccount(lpNameToParse, &DomainName, &UserName)) != NO_ERROR)
    {
        if (fIsUPN)
        {
            LocalFree(lpNameToParse);
        }

        return status;
    }

    //
    // Write the new account name to the registry.
    //
    if ((status = ScWriteStartName(ServiceNameKey, CanonAccountName)) != NO_ERROR)
    {
        if (fIsUPN)
        {
            LocalFree(lpNameToParse);
        }

        LocalFree(DomainName);
        return status;
    }

    //
    // Set the password for the new account.
    //
    status = ScSetPassword(ServiceRecord->ServiceName, Password);

    if (status != NO_ERROR)
    {

        //
        // Restore the old account name to the registry.
        //
        ScWriteStartName(ServiceNameKey, OldAccountName);
    }
    else if (*DomainName == L'.' && !fIsUPN)
    {
        LPWSTR CurrentDependencies;

        //
        // Get rid of the implicit dependency on NetLogon since this
        // service now runs in a local account (domain is ".\")
        //

        status = ScReadDependencies(ServiceNameKey,
                                    &CurrentDependencies,
                                    ServiceRecord->ServiceName);

        if (status == NO_ERROR)
        {

            //
            // Dynamically update the dependencies
            //

            status = ScUpdateServiceRecordConfig(
                         ServiceRecord,
                         SERVICE_NO_CHANGE,
                         SERVICE_NO_CHANGE,
                         SERVICE_NO_CHANGE,
                         NULL,
                         (LPBYTE) CurrentDependencies);

            if (status != NO_ERROR)
            {
                SC_LOG1(ERROR,
                        "ScValidateAndChangeAccount: ScUpdateServiceRecordConfig "
                            "FAILED %d\n",
                        status);
            }

            LocalFree(CurrentDependencies);
        }
        else
        {
            SC_LOG1(ERROR,
                    "ScValidateAndChangeAccount: ScReadDependencies "
                        "FAILED %d\n",
                    status);
        }
    }

    if (fIsUPN)
    {
        LocalFree(lpNameToParse);
    }

    LocalFree(DomainName);
    return status;
}


VOID
ScRemoveAccount(
    IN LPWSTR ServiceName
    )
{
    ScDeletePassword(ServiceName);
}


DWORD
ScCanonAccountName(
    IN  LPWSTR AccountName,
    OUT LPWSTR *CanonAccountName
    )
/*++

Routine Description:

    This function canonicalizes the account name and allocates the
    returned buffer for returning the canonicalized string.

      AccountName               *CanonAccountName
      -----------               -----------------

      .\UserName                .\UserName
      ComputerName\UserName     .\UserName

      LocalSystem               LocalSystem
      .\LocalSystem             LocalSystem
      ComputerName\LocalSystem  LocalSystem

      DomainName\UserName       DomainName\UserName

      DomainName\LocalSystem    Error!

      UPN (foo@bar)             UPN (foo@bar)


    Caller must free the CanonAccountName pointer with LocalFree when done.

Arguments:

    AccountName - Supplies a pointer to the account name.

    CanonAccountName - Receives a pointer to the buffer (allocated by this
        routine) which contains the canonicalized account name.  Must
        free this pointer with LocalFree.

Return Value:

    NO_ERROR - Successful canonicalization.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory trying to allocate CanonAccountName
        buffer.

    ERROR_INVALID_SERVICE_ACCOUNT - Invalid account name.

--*/
{
    LPWSTR BufPtr = wcschr(AccountName, SCDOMAIN_USERNAME_SEPARATOR);


    //
    // Allocate buffer for receiving the canonicalized account name.
    //
    if ((*CanonAccountName = (LPWSTR)LocalAlloc(
                                 0,
                                 WCSSIZE(AccountName) +
                                     ScComputerName.MaximumLength
                                 )) == NULL) {

        SC_LOG1(ERROR, "ScCanonAccountName: LocalAlloc failed %lu\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (BufPtr == NULL) {

        //
        // Backslash is not found.
        //

        if (_wcsicmp(AccountName, SC_LOCAL_SYSTEM_USER_NAME) == 0
             ||
             wcschr(AccountName, SC_UPN_SYMBOL) != NULL)
        {
            //
            // Account name is LocalSystem or a UPN
            //
            wcscpy(*CanonAccountName, AccountName);
            return NO_ERROR;
        }
        else {

            //
            // The AccountName is neither LocalSystem nor a UPN -- invalid.
            //
            SC_LOG1(ERROR,
                    "Account name %ws is not LocalSystem and has no \\ or @\n",
                    AccountName);

            LocalFree(*CanonAccountName);
            *CanonAccountName = NULL;
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }
    }

    //
    // BufPtr points to the first occurrence of backslash in
    // AccountName.
    //

    //
    // If first portion of the AccountName matches ".\" or "ComputerName\"
    //
    if ((wcsncmp(AccountName, L".\\", 2) == 0) ||
        ((_wcsnicmp(AccountName, ScComputerName.Buffer,
                  ScComputerName.Length / sizeof(WCHAR)) == 0) &&
        ((LPWSTR) ((DWORD_PTR) AccountName + ScComputerName.Length) == BufPtr))) {

        if (_wcsicmp(BufPtr + 1, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

            //
            // .\LocalSystem -> LocalSystem OR
            // Computer\LocalSystem -> LocalSystem
            //
            wcscpy(*CanonAccountName, SC_LOCAL_SYSTEM_USER_NAME);
            return NO_ERROR;
        }

        //
        // .\XXX -> .\XXX
        // ComputerName\XXX -> .\XXX
        //
        wcscpy(*CanonAccountName, SC_LOCAL_DOMAIN_NAME);
        wcscat(*CanonAccountName, BufPtr);
        return NO_ERROR;
    }

    //
    // First portion of the AccountName specifies a domain name other than
    // the local one.  This domain name will be validated later in
    // ScValidateAndSaveAccount.
    //
    if (_wcsicmp(BufPtr + 1, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // XXX\LocalSystem is invalid.
        //
        LocalFree(*CanonAccountName);
        *CanonAccountName = NULL;
        SC_LOG0(ERROR, "Account name is LocalSystem but is not local\n");
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    wcscpy(*CanonAccountName, AccountName);
    return NO_ERROR;
}


BOOL
GetDefaultDomainName(
    LPWSTR DomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;


    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        return FALSE;
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        LsaClose(LsaPolicyHandle);
        return(FALSE);
    }


    LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache...
    //

    CopyMemory( DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // ...and null terminate it appropriately
    //

    DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //

    LsaFreeMemory(DomainInfo);

    return TRUE;
}


DWORD
ScLookupAccount(
    IN  LPWSTR AccountName,
    OUT LPWSTR *DomainName,
    OUT LPWSTR *UserName
    )
/*++

Routine Description:

    This function calls LsaLookupNames to see if the specified username
    exists in the specified domain name.  If this function returns
    NO_ERROR, DomainName and UserName pointers will be set to the
    domain name and username strings in the buffer allocated by this
    function.

    The caller must free the returned buffer by calling LocalFree
    on the pointer returned in DomainName.

Arguments:

    AccountName - Supplies the account name in the format of
        DomainName\UserName to look up.

    DomainName - Receives a pointer to the allocated buffer which
        contains the NULL-terminated domain name string, followed
        by the NULL-terminated user name string.

    UserName - Receives a pointer to the username in the returned
        buffer allocated by this routine.

Return Value:

    NO_ERROR - UserName is found in the DomainName.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate work buffer.

    ERROR_INVALID_SERVICE_ACCOUNT - any other error that is encountered
        in this function.
--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    LSA_HANDLE PolicyHandle;

    UNICODE_STRING AccountNameString;

    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains;
    PLSA_TRANSLATED_SID Sids;

    LPWSTR BackSlashPtr;

    LPWSTR LocalAccount = NULL;

    WCHAR Domain[MAX_COMPUTERNAME_LENGTH+1];


    //
    // Allocate buffer for separating AccountName into DomainName and
    // UserName.
    //
    if ((*DomainName = (LPWSTR) LocalAlloc(
                                    0,
                                    WCSSIZE(AccountName)
                                    )) == NULL) {
        SC_LOG1(ERROR, "ScLookupAccount: LocalAlloc failed %lu\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Find the backslash character in the specified account name
    //
    wcscpy(*DomainName, AccountName);
    BackSlashPtr = wcschr(*DomainName, SCDOMAIN_USERNAME_SEPARATOR);

    if (BackSlashPtr == NULL) {
        SC_LOG0(ERROR, "ScLookupAccount: No backslash in account name!\n");

        ScLogEvent(NEVENT_BAD_ACCOUNT_NAME);
            
        SC_ASSERT(FALSE);
        status = ERROR_GEN_FAILURE;
        goto CleanExit;
    }

    *UserName = BackSlashPtr + 1; // Skip the backslash

    if (_wcsnicmp(*DomainName, SC_LOCAL_DOMAIN_NAME, SC_LOCAL_DOMAIN_NAME_LENGTH) == 0)
    {
        //
        // DomainName is "." (local domain), so convert "." to the
        // local domain name, which on WinNT systems is the computername,
        // and on Adv Server systems it's the account domain name.
        //

        //
        // This code does not use a global containing the local domain
        // because it contains invalid data during gui mode setup.
        // Calling the GetDefaultDomainName funtion guarantees that we
        // have the correct value in all cases.
        //

        if (!GetDefaultDomainName( Domain ))
        {
            SC_LOG0( ERROR, "ScLookupAccount: GetDefaultDomainName failed\n");
            status = ERROR_GEN_FAILURE;
            goto CleanExit;
        }

        if ((LocalAccount = (LPWSTR) LocalAlloc(
                                         LMEM_ZEROINIT,
                                         WCSSIZE(Domain) + WCSSIZE(*UserName)
                                         )) == NULL)
        {
            SC_LOG1(ERROR, "ScLookupAccount: LocalAlloc failed %lu\n", GetLastError());
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }

        wcscpy( LocalAccount, Domain );
        wcscat( LocalAccount, BackSlashPtr );

        RtlInitUnicodeString( &AccountNameString, LocalAccount );
    }
    else
    {
        //
        // Lookup the domain-qualified name.
        //

        RtlInitUnicodeString(&AccountNameString, *DomainName);
    }

    //
    // Open a handle to the local security policy.
    //
    if (ScOpenPolicy(
            POLICY_LOOKUP_NAMES |
                POLICY_VIEW_LOCAL_INFORMATION,
            &PolicyHandle
            ) != NO_ERROR)
    {
        SC_LOG0(ERROR, "ScLookupAccount: ScOpenPolicy failed\n");
        status = ERROR_INVALID_SERVICE_ACCOUNT;
        goto CleanExit;
    }


    ntstatus = LsaLookupNames(
                   PolicyHandle,
                   1,
                   &AccountNameString,
                   &ReferencedDomains,
                   &Sids
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR,
               "ScLookupAccount: LsaLookupNames returned " FORMAT_NTSTATUS "\n",
               ntstatus);

        LsaClose(PolicyHandle);

        status = ERROR_INVALID_SERVICE_ACCOUNT;
        goto CleanExit;
    }

    //
    // Don't need PolicyHandle anymore
    //

    LsaClose(PolicyHandle);


    //
    // Free the returned SIDs since we don't look at them.
    //

    if (Sids != NULL)
    {
        LsaFreeMemory(Sids);
    }

    if (ReferencedDomains == NULL) {
        SC_LOG1(ERROR, "ScLookupAccount: Did not find " FORMAT_LPWSTR
               " in any domain\n", AccountNameString.Buffer);
        status = ERROR_INVALID_SERVICE_ACCOUNT;
        goto CleanExit;
    }
    else {
        LsaFreeMemory((PVOID) ReferencedDomains);
    }

    status = NO_ERROR;

    //
    // Convert DomainName\UserName into DomainName0UserName.
    //

    *BackSlashPtr = 0;

CleanExit:

    LocalFree(LocalAccount);

    if (status != NO_ERROR) {
        LocalFree(*DomainName);
        *DomainName = NULL;
    }

    return status;
}



DWORD
ScSetPassword(
    IN LPWSTR ServiceName,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This function sets the secret object for the service with the specified
    password.  If the secret object doesn't already exist, it is created.

Arguments:

    ServiceName - Supplies the service name which is part of the secret
        object name to be created.

    Password - Supplies the user specified password for an account.

Return Value:

    NO_ERROR - Secret object for the password is created and set with new value.

    ERROR_INVALID_SERVICE_ACCOUNT - for any error encountered in this
        function.  The true error is written to the event log.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    LSA_HANDLE PolicyHandle;
    LPWSTR LsaSecretName;
    UNICODE_STRING SecretNameString;
    UNICODE_STRING NewPasswordString;

    //
    // Open a handle to the local security policy.
    //
    if (ScOpenPolicy(
            POLICY_CREATE_SECRET,
            &PolicyHandle
            ) != NO_ERROR) {
        SC_LOG0(ERROR, "ScSetPassword: ScOpenPolicy failed\n");
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    //
    // Create the secret object.  But first, let's form a secret
    // name that is oh-so-difficult to guess.
    //
    if ((status = ScFormSecretName(
                      ServiceName,
                      &LsaSecretName
                      )) != NO_ERROR) {
        LsaClose(PolicyHandle);
        return status;
    }

    //
    // Serialize secret object operations
    //
    // CODEWORK:  This mutex may not be necessary if we're always holding
    //            a write lock when ScSetPassword/ScDeletePassword are called
    //
    if (WaitForSingleObject(ScSecretObjectsMutex, INFINITE) == MAXULONG) {

        status = GetLastError();
        SC_LOG1(ERROR, "ScSetPassword: WaitForSingleObject failed "
                FORMAT_DWORD "\n", status);

        LocalFree(LsaSecretName);
        LsaClose(PolicyHandle);
        return status;
    }

    RtlInitUnicodeString(&SecretNameString, LsaSecretName);
    RtlInitUnicodeString(&NewPasswordString, Password);

    ntstatus = LsaStorePrivateData(
                   PolicyHandle,
                   &SecretNameString,
                   &NewPasswordString
                   );

    if (NT_SUCCESS(ntstatus)) {

        SC_LOG1(ACCOUNT, "ScSetPassword " FORMAT_LPWSTR " success\n",
                ServiceName);

        status = NO_ERROR;
    }
    else {

        SC_LOG2(ERROR,
                "ScSetPassword: LsaStorePrivateData returned " FORMAT_NTSTATUS
                " for " FORMAT_LPWSTR "\n", ntstatus, LsaSecretName);
        //
        // The ntstatus code was not mapped to a windows error because it wasn't
        // clear if all the mappings made sense, and the feeling was that
        // information would be lost during the mapping.
        //

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_LSA_STOREPRIVATEDATA,
            ntstatus);

        status = ERROR_INVALID_SERVICE_ACCOUNT;
    }

    LocalFree(LsaSecretName);
    LsaClose(PolicyHandle);
    ReleaseMutex(ScSecretObjectsMutex);

    return status;
}


DWORD
ScDeletePassword(
    IN LPWSTR ServiceName
    )
/*++

Routine Description:

    This function deletes the LSA secret object whose name is derived
    from the specified ServiceName.

Arguments:

    ServiceName - Supplies the service name which is part of the secret
        object name to be deleted.

Return Value:

    NO_ERROR - Secret object for password is deleted.

    ERROR_INVALID_SERVICE_ACCOUNT - for any error encountered in this
        function.  The true error is written to the event log.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretNameString;
    LPWSTR LsaSecretName;

    //
    // Open a handle to the local security policy.
    //
    if (ScOpenPolicy(
            POLICY_VIEW_LOCAL_INFORMATION,
            &PolicyHandle
            ) != NO_ERROR) {
        SC_LOG0(ERROR, "ScDeletePassword: ScOpenPolicy failed\n");
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    //
    // Get the secret object name from the specified service name.
    //
    if ((status = ScFormSecretName(
                      ServiceName,
                      &LsaSecretName
                      )) != NO_ERROR) {
        (void) LsaClose(PolicyHandle);
        return status;
    }

    //
    // Serialize secret object operations
    //
    if (WaitForSingleObject(ScSecretObjectsMutex, INFINITE) == MAXULONG) {

        status = GetLastError();
        SC_LOG1(ERROR, "ScDeletePassword: WaitForSingleObject failed "
                FORMAT_DWORD "\n", status);

        LocalFree(LsaSecretName);
        LsaClose(PolicyHandle);
        return status;
    }

    RtlInitUnicodeString(&SecretNameString, LsaSecretName);

    ntstatus = LsaStorePrivateData(
                   PolicyHandle,
                   &SecretNameString,
                   NULL
                   );

    //
    // Treat STATUS_OBJECT_NAME_NOT_FOUND as success since the
    // password's already deleted (effectively) in that case.
    //

    if (NT_SUCCESS(ntstatus) || (ntstatus == STATUS_OBJECT_NAME_NOT_FOUND))
    {
        SC_LOG1(ACCOUNT, "ScDeletePassword " FORMAT_LPWSTR " success\n",
                ServiceName);

        status = NO_ERROR;
    }
    else
    {
        SC_LOG2(ERROR,
                "ScDeletePassword: LsaStorePrivateData returned " FORMAT_NTSTATUS
                " for " FORMAT_LPWSTR "\n", ntstatus, LsaSecretName);
        //
        // The ntstatus code was not mapped to a windows error because it wasn't
        // clear if all the mappings made sense, and the feeling was that
        // information would be lost during the mapping.
        //

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_LSA_STOREPRIVATEDATA,
            ntstatus);

        status = ERROR_INVALID_SERVICE_ACCOUNT;
    }

    LocalFree(LsaSecretName);
    LsaClose(PolicyHandle);
    ReleaseMutex(ScSecretObjectsMutex);

    return status;
}


DWORD
ScOpenPolicy(
    IN  ACCESS_MASK DesiredAccess,
    OUT LSA_HANDLE *PolicyHandle
    )
/*++

Routine Description:

    This function gets a handle to the local security policy by calling
    LsaOpenPolicy.

Arguments:

    DesiredAccess - Supplies the desired access to the local security
        policy.

    PolicyHandle - Receives a handle to the opened policy.

Return Value:

    NO_ERROR - Policy handle is returned.

    ERROR_INVALID_SERVICE_ACCOUNT - for any error encountered in this
        function.

--*/
{
    NTSTATUS ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    ntstatus = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   DesiredAccess,
                   PolicyHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR,
                "ScOpenPolicy: LsaOpenPolicy returned " FORMAT_NTSTATUS "\n",
                ntstatus);

        //
        // The ntstatus code was not mapped to a windows error because it wasn't
        // clear if all the mappings made sense, and the feeling was that
        // information would be lost during the mapping.
        //

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_LSA_OPENPOLICY,
            ntstatus
            );

        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    return NO_ERROR;
}


DWORD
ScFormSecretName(
    IN  LPWSTR ServiceName,
    OUT LPWSTR *LsaSecretName
    )
/*++

Routine Description:

    This function creates a secret name from the service name.
    It also allocates the buffer to return the created secret name which
    must be freed by the caller using LocalFree when done with it.

Arguments:

    ServiceName - Supplies the service name which is part of the secret
        object name we are creating.

    LsaSecretName - Receives a pointer to the buffer which contains the
        secret object name.

Return Value:

    NO_ERROR - Successfully returned secret name.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate buffer to hold the secret
        name.

--*/
{
    if ((*LsaSecretName = (LPWSTR)LocalAlloc(
                              0,
                              (SC_SECRET_PREFIX_LENGTH +
                               wcslen(ServiceName) +
                               1) * sizeof(WCHAR)
                              )) == NULL) {

        SC_LOG1(ERROR, "ScFormSecretName: LocalAlloc failed %lu\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*LsaSecretName, SC_SECRET_PREFIX);
    wcscat(*LsaSecretName, ServiceName);

    return NO_ERROR;
}


DWORD
ScLookupServiceAccount(
    IN  LPWSTR ServiceName,
    OUT LPWSTR *AccountName
    )
/*++

Routine Description:

    This function looks up the service account from the registry.

Arguments:

    ServiceName - Supplies the service name to logon.

    AccountName - Receives a pointer to a string containing the name of
        the account that the service is configured to logon under.  The
        pointer returned is NULL if the service account is LocalSystem.
        Otherwise the string is in the form .\UserName or
        DomainName\UserName where DomainName != the local computername.
        It must be freed with LocalAlloc when done.

Return Value:

    NO_ERROR - Secret object for password is changed to new value.

    ERROR_INVALID_SERVICE_ACCOUNT - The account name obtained from the
        registry is invalid.

    Other errors from registry APIs.

--*/
{
    DWORD status;

    HKEY ServiceNameKey;
    LPWSTR DomainName = NULL;
    LPWSTR UserName;
    LPWSTR Separator;

    LPWSTR lpNameToParse;

    *AccountName = NULL;

    //
    // Open the service name key.
    //
    status = ScOpenServiceConfigKey(
                 ServiceName,
                 KEY_READ,
                 FALSE,               // Create if missing
                 &ServiceNameKey
                 );

    if (status != NO_ERROR) {
        return status;
    }

    //
    // Read the account name from the registry.
    //
    status = ScReadStartName(
                 ServiceNameKey,
                 &lpNameToParse
                 );

    ScRegCloseKey(ServiceNameKey);

    if (status != NO_ERROR) {
        return status;
    }

    if (lpNameToParse == NULL) {
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    //
    // Check if the account name is LocalSystem.
    //

    if (_wcsicmp(lpNameToParse, SC_LOCAL_SYSTEM_USER_NAME) == 0) {
        LocalFree(lpNameToParse);
        return NO_ERROR;
    }

    //
    // If it isn't LocalSystem, it must be in the form
    // Domain\User or .\User.
    //
    Separator = wcsrchr(lpNameToParse, SCDOMAIN_USERNAME_SEPARATOR);

    if (Separator == NULL) {

        if (wcsrchr(lpNameToParse, SC_UPN_SYMBOL) != NULL) {

            //
            // It's a UPN -- crack it
            //
            status = ScUPNToAccountName(lpNameToParse, &DomainName);

            LocalFree(lpNameToParse);

            if (status != NO_ERROR
                 ||
                (Separator = wcschr(DomainName, SCDOMAIN_USERNAME_SEPARATOR)) == NULL)
            {
                SC_LOG1(ERROR,
                        "ScLookupServiceAccount: ScUPNToAccountName failed %d\n",
                        status);

                if (status == NO_ERROR) {

                    SC_LOG1(ACCOUNT,
                            "Cracked account name was %ws\n",
                            DomainName);
                }

                LocalFree(DomainName);
                return ERROR_INVALID_SERVICE_ACCOUNT;
            }
        }
        else {

            SC_LOG1(ERROR,
                    "ScLookupServiceAccount: No \\ or @ in account name %ws\n",
                    lpNameToParse);

            LocalFree(lpNameToParse);
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }
    }
    else {

        DomainName = lpNameToParse;
    }

    *Separator = 0;
    UserName = Separator + 1;

    //
    // Translate ComputerName into . (to facilitate subsequent comparison
    // of account names)
    //

    if (_wcsicmp(DomainName, ScComputerName.Buffer) == 0)
    {
        WCHAR *Dest, *Src;

        // Assumption: "." is no longer than any computer name
        SC_ASSERT(wcslen(SC_LOCAL_DOMAIN_NAME) == 1 &&
                  wcslen(DomainName) >= 1);

        wcscpy(DomainName, SC_LOCAL_DOMAIN_NAME);
        Separator = DomainName + SC_LOCAL_DOMAIN_NAME_LENGTH;

        // Shift username left
        Src = UserName;
        UserName = Separator + 1;
        Dest = UserName;
        while (*Dest++ = *Src++)
            ;
    }

    //
    // Check if the user name is LocalSystem
    //

    if (_wcsicmp(UserName, SC_LOCAL_SYSTEM_USER_NAME) == 0) {

        //
        // This is only acceptable if DomainName is "."
        //

        if (_wcsicmp(DomainName, SC_LOCAL_DOMAIN_NAME) == 0) {
            status = NO_ERROR;
        }
        else {
            status = ERROR_INVALID_SERVICE_ACCOUNT;
        }

        LocalFree(DomainName);
        return status;
    }

    //
    // Restore the "\"
    //

    *Separator = SCDOMAIN_USERNAME_SEPARATOR;
    *AccountName = DomainName;

    return NO_ERROR;
}


DWORD
ScLogonService(
    IN  LPWSTR   ServiceName,
    IN  LPWSTR   AccountName,
    OUT LPHANDLE ServiceToken,
    OUT LPHANDLE pProfileHandle OPTIONAL,
    OUT PSID     *ServiceSid
    )
/*++

Routine Description:

    This function looks up the service account from the registry and
    the password from the secret object to logon the service.  If
    successful, the handle to the logon token is returned.

Arguments:

    ServiceName - Supplies the service name to logon.

    AccountName - Supplies the account name to logon the service under.
        (Supplied as an optimization since ScLookupServiceAccount will
        have been called before calling this routine.)  It must be of
        the form .\UserName or DomainName\UserName, where DomainName !=
        the local computer name and UserName != LocalSystem.

    ServiceToken - Receives a handle to the logon token for the
        service.  The handle returned is NULL if the service account
        is LocalSystem (i.e. spawn as child process of the service
        controller).

    ServiceSid - Receives a pointer to the logon SID of the service.
        This must be freed with LocalAlloc when done.

Return Value:

    NO_ERROR - Secret object for password is changed to new value.

    ERROR_SERVICE_LOGON_FAILED - for any error encountered in this
        function.

--*/
{
    DWORD         status;
    LPWSTR        Separator;
    LPWSTR        LsaSecretName  = NULL;

    *ServiceToken = NULL;
    *ServiceSid   = NULL;

    status = ScFormSecretName(ServiceName, &LsaSecretName);

    if (status != NO_ERROR)
    {
        SC_LOG(ERROR, "ScLogonService: ScFormSecretname failed %lu\n", status);
        return ERROR_SERVICE_LOGON_FAILED;
    }

    Separator = wcsrchr(AccountName, SCDOMAIN_USERNAME_SEPARATOR);

    if (Separator == NULL)
    {
        SC_ASSERT(Separator != NULL);
        LocalFree(LsaSecretName);
        return ERROR_INVALID_SERVICE_ACCOUNT;
    }

    *Separator = 0;

    //
    // Get the service token
    //
    if (!LogonUserEx(Separator + 1,              // Username
                     AccountName,                // Domain
                     LsaSecretName,              // Password
                     LOGON32_LOGON_SERVICE,      // Logon type
                     LOGON32_PROVIDER_DEFAULT,   // Default logon provider
                     ServiceToken,               // Pointer to token handle
                     ServiceSid,                 // Logon Sid
                     NULL,                       // Profile buffer
                     NULL,                       // Length of profile buffer
                     NULL))                      // Quota limits
    {
        status = GetLastError();

        *Separator = SCDOMAIN_USERNAME_SEPARATOR;

        SC_LOG2(ERROR,
                "ScLogonService: LogonUser for %ws service failed %d\n",
                ServiceName,
                status);

        ScLogEvent(NEVENT_FIRST_LOGON_FAILED_II,
                   ServiceName,
                   AccountName,
                   status);

        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(pProfileHandle))
    {
        //
        // Load the user profile for the service
        // (Errors are written to the event log, but otherwise ignored)
        //
        ScLoadUserProfile(*ServiceToken,
                          AccountName,        // Domain
                          Separator + 1,      // Username
                          pProfileHandle);
    }

    LocalFree(LsaSecretName);
    *Separator = SCDOMAIN_USERNAME_SEPARATOR;

    return NO_ERROR;

Cleanup:

    LocalFree(LsaSecretName);
    *Separator = SCDOMAIN_USERNAME_SEPARATOR;

    LocalFree(*ServiceSid);
    *ServiceSid = NULL;

    if (*ServiceToken != NULL)
    {
        CloseHandle(*ServiceToken);
        *ServiceToken = NULL;
    }

    return ERROR_SERVICE_LOGON_FAILED;
}



DWORD
ScGetAccountDomainInfo(
    VOID
    )
{
    NTSTATUS ntstatus;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;

    //
    // Account domain info is cached.  Look it up it this is the first
    // time.
    //
    if (ScAccountDomain.Buffer == NULL) {

        //
        // Open a handle to the local security policy.
        //
        if (ScOpenPolicy(
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                ) != NO_ERROR) {
            SC_LOG0(ERROR, "ScGetAccountDomainInfo: ScOpenPolicy failed\n");
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }

        //
        // Get the name of the account domain from LSA if we have
        // not done it already.
        //
        ntstatus = LsaQueryInformationPolicy(
                       PolicyHandle,
                       PolicyAccountDomainInformation,
                       (PVOID *) &AccountDomainInfo
                       );

        if (! NT_SUCCESS(ntstatus)) {
            SC_LOG1(ERROR, "ScGetAccountDomainInfo: LsaQueryInformationPolicy failed "
                   FORMAT_NTSTATUS "\n", ntstatus);
            LsaClose(PolicyHandle);
            return ERROR_INVALID_SERVICE_ACCOUNT;
        }

        LsaClose(PolicyHandle);

        if ((ScAccountDomain.Buffer = (LPWSTR)LocalAlloc(
                                          LMEM_ZEROINIT,
                                          (UINT) (AccountDomainInfo->DomainName.Length +
                                              sizeof(WCHAR))
                                          )) == NULL) {

            LsaFreeMemory(AccountDomainInfo);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ScAccountDomain.MaximumLength = (USHORT) (AccountDomainInfo->DomainName.Length +
                                            sizeof(WCHAR));

        RtlCopyUnicodeString(&ScAccountDomain, &AccountDomainInfo->DomainName);

        SC_LOG1(ACCOUNT, "ScGetAccountDomainInfo got " FORMAT_LPWSTR "\n",
                ScAccountDomain.Buffer);

        LsaFreeMemory(AccountDomainInfo);
    }

    return NO_ERROR;
}



VOID
ScLoadUserProfile(
    IN  HANDLE   LogonToken,
    IN  LPWSTR   DomainName,
    IN  LPWSTR   UserName,
    OUT PHANDLE  pProfileHandle
    )
/*++

Routine Description:

    This function loads the user profile for the account that a service
    process will run under, so that the process has an HKEY_CURRENT_USER.

Arguments:

    LogonToken - The token handle returned by LogonUser.

    UserName - The account's user name.  (Used by LoadUserProfile to
        generate a profile directory name.)

    pProfileHandle - A handle to the profile is returned here.  It must
        be closed by calling UnloadUserProfile after the service process
        exits.

Return Value:

    None.  Errors from LoadUserProfile are written to the event log.

--*/
{
    PROFILEINFO ProfileInfo =
        {
            sizeof(ProfileInfo),  // dwSize
            PI_NOUI,              // dwFlags - no UI
            UserName,             // lpUserName (used for dir name)
            NULL,                 // lpProfilePath
            NULL,                 // lpDefaultPath
            NULL,                 // lpServerName (used to get group info - N/A)
            NULL,                 // lpPolicyPath
            NULL                  // hProfile (filled in by LoadUserProfile)
        };

    SC_ASSERT(pProfileHandle != NULL);


    if (_wcsicmp(DomainName, SC_LOCAL_NTAUTH_NAME) == 0)
    {
        //
        // Hide LocalService/NetworkService profiles from the Admin
        // (i.e., they won't show up via "dir", etc).
        //

        ProfileInfo.dwFlags |= PI_HIDEPROFILE;
    }


    //
    // NOTE:  This ignores a service with a roaming profile.  May need
    //        to use the profile path from the LogonUserEx call.
    //

    if (LoadUserProfile(LogonToken, &ProfileInfo))
    {
        SC_ASSERT(ProfileInfo.hProfile != NULL);
        *pProfileHandle = ProfileInfo.hProfile;
    }
    else if (!SetupInProgress(NULL, NULL))
    {
        //
        // Don't log during GUI-mode setup in case a
        // non-SYSTEM service is started then.
        //

        DWORD Error = GetLastError();

        SC_LOG(ERROR, "LoadUserProfile failed %lu\n", Error);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_LOAD_USER_PROFILE,
            Error);

        *pProfileHandle = NULL;
    }
}


DWORD
ScUPNToAccountName(
    IN  LPWSTR  lpUPN,
    OUT LPWSTR  *ppAccountName
    )
/*++

Routine Description:

    This function attempts to convert a UPN into Domain\User

Arguments:

    lpUPN - The UPN

    ppAccountName - Pointer to the location to create/copy the account name

Return Value:

    NO_ERROR -- Success (ppAccountName contains the converted UPN)
    
    Any other Win32 error -- error at some stage of conversion

--*/
{
    DWORD               dwError;
    HANDLE              hDS;
    PDS_NAME_RESULT     pdsResult;

    SC_ASSERT(ppAccountName != NULL);

    SC_LOG1(ACCOUNT, "ScUPNToAccountName: Converting %ws\n", lpUPN);

    //
    // Get a binding handle to the DS
    //
    dwError = DsBind(NULL, NULL, &hDS);

    if (dwError != NO_ERROR)
    {
        SC_LOG1(ERROR, "ScUPNToAccountName: DsBind failed %d\n", dwError);
        return dwError;
    }

    dwError = DsCrackNames(hDS,                     // Handle to the DS
                           DS_NAME_NO_FLAGS,        // No parsing flags
                           DS_USER_PRINCIPAL_NAME,  // We have a UPN
                           DS_NT4_ACCOUNT_NAME,     // We want Domain\User
                           1,                       // Number of names to crack
                           &lpUPN,                  // Array of name(s)
                           &pdsResult);             // Filled in by API

    if (dwError != NO_ERROR)
    {
        SC_LOG1(ERROR,
                "ScUPNToAccountName: DsCrackNames failed %d\n",
                dwError);

        DsUnBind(&hDS);
        return dwError;
    }

    SC_ASSERT(pdsResult->cItems == 1);
    SC_ASSERT(pdsResult->rItems != NULL);

    if (pdsResult->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY)
    {
        //
        // Couldn't crack the name but we got the name of
        // the domain where it is -- let's try it
        //
        DsUnBind(&hDS);

        SC_ASSERT(pdsResult->rItems[0].pDomain != NULL);

        SC_LOG1(ACCOUNT,
                "Retrying DsBind on domain %ws\n",
                pdsResult->rItems[0].pDomain);

        dwError = DsBind(NULL, pdsResult->rItems[0].pDomain, &hDS);

        //
        // Free up the structure holding the old info
        //
        DsFreeNameResult(pdsResult);

        if (dwError != NO_ERROR)
        {
            SC_LOG1(ERROR,
                    "ScUPNToAccountName: DsBind #2 failed %d\n",
                    dwError);

            return dwError;
        }

        dwError = DsCrackNames(hDS,                     // Handle to the DS
                               DS_NAME_NO_FLAGS,        // No parsing flags
                               DS_USER_PRINCIPAL_NAME,  // We have a UPN
                               DS_NT4_ACCOUNT_NAME,     // We want Domain\User
                               1,                       // Number of names to crack
                               &lpUPN,                  // Array of name(s)
                               &pdsResult);             // Filled in by API

        if (dwError != NO_ERROR)
        {
            SC_LOG1(ERROR,
                    "ScUPNToAccountName: DsCrackNames #2 failed %d\n",
                    dwError);

            DsUnBind(&hDS);
            return dwError;
        }

        SC_ASSERT(pdsResult->cItems == 1);
        SC_ASSERT(pdsResult->rItems != NULL);
    }

    if (pdsResult->rItems[0].status != DS_NAME_NO_ERROR)
    {
        SC_LOG1(ERROR,
                "ScUPNToAccountName: DsCrackNames failure (status %#x)\n",
                pdsResult->rItems[0].status);

        //
        // DS errors don't map to Win32 errors -- this is the best we can do
        //
        dwError = ERROR_INVALID_SERVICE_ACCOUNT;
    }
    else
    {
        *ppAccountName = (LPWSTR)LocalAlloc(
                                   LPTR,
                                   (wcslen(pdsResult->rItems[0].pName) + 1) * sizeof(WCHAR));

        if (*ppAccountName != NULL)
        {
            wcscpy(*ppAccountName, pdsResult->rItems[0].pName);
        }
        else
        {
            dwError = GetLastError();
            SC_LOG1(ERROR, "ScUPNToAccountName: LocalAlloc failed %d\n", dwError);
        }
    }

    DsUnBind(&hDS);
    DsFreeNameResult(pdsResult);
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\bootcfg.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    BOOTCFG.CXX

Abstract:

    Contains functions used for managing the system control sets in the
    system portion of the registry.

    ScCheckLastKnownGood
    ScRevertToLastKnownGood
    NotifyBootConfigStatus

    ScGetTopKeys
    ScGetCtrlSetIds
    ScDeleteRegTree
    ScBuildCtrlSetName
    ScGetCtrlSetHandle
    ScDeleteTree
    ScCopyKeyRecursive
    ScCopyKeyValues
    ScDeleteRegServiceEntry
    ScGatherOrphanIds
    ScDeleteCtrlSetOrphans
    ScMatchInArray
    ScStartCtrlSetCleanupThread
    ScCleanupThread
    ScRunAcceptBootPgm
    ScAcceptTheBoot

Author:

    Dan Lafferty (danl) 19-Apr-1992

Environment:

    User Mode - Win32

Notes:


Revision History:

    24-Aug-1998 Elliot Shmukler (t-ellios)
        Most of the LKG related work has now been moved into the Kernel.
        The tree copies & clone deletions formerly performed by functions
        in this file has now been replaced by calls to NtInitializeRegistry.

    28-Jun-1995 AnirudhS
        SetupInProgress: This function is now called from more than one place.
        Cache the return value so we only examine the registry once.

    04-Feb-1994 Danl
        RevertToLastKnownGood:  If the boot has been accepted, then we won't
        allow a revert.

    15-Jun-1993 Danl
        Ignore LastKnownGood adjustments if setup is still running.
        Use the SystemSetupInProgress value in the registry to determine
        if is running.

    01-Apr-1993 Danl
        Add ability to take ownership if we cannot open one of the keys due
        to an access denied error.

    08-Feb-1993 Danl
        Changed the clearing of the LKG_ENV_VAR so that it is done whenever
        we are booting LKG.  Reguardless of whether or not it is the last
        boot.  Prior to this, it was only cleared when a revert occured, and
        not on the first boot.

    04-Feb-1993 Danl
        Use NtUnloadKey to delete the clone tree.  The clone tree is now
        in a separate hive.  So this is allowed.

    18-Jan-1993 Danl
        Make use of the LastKnownGood Environment Variable.  Now we do
        not alter the default control set when we need to revert.  We
        just set the Environment Variable to True, and reboot.  Phase2
        and ScCheckLastKnownGood do the right thing.

    19-Apr-1992 danl
        Created

--*/

//
// INCLUDES
//
#include "precomp.hxx"
#include <stdlib.h>     // ultoa
#include "scsec.h"      // ScAccessValidate()
#include "bootcfg.h"    // ScRegDeleteTree()
#include "scconfig.h"   // ScOpenServicesKey()
#include <svcslib.h>    // SetupInProgress()
#include <ntsetup.h>    // REGSTR_VALUE_OOBEINPROGRESS

#include <bootstatus.h>

//
// DEFINES
//

#define SYSTEM_KEY      L"system"
#define SELECT_KEY      L"select"
#define SERVICES_KEY    L"System\\CurrentControlSet\\Services"
#define ACCEPT_BOOT_KEY L"System\\CurrentControlSet\\Control\\BootVerificationProgram"
#define SETUP_PROG_KEY  L"Setup"

#define CURRENT_VALUE_NAME      L"Current"
#define DEFAULT_VALUE_NAME      L"Default"
#define LKG_VALUE_NAME          L"LastKnownGood"
#define FAILED_VALUE_NAME       L"Failed"
#define IMAGE_PATH_NAME         L"ImagePath"
#define SETUP_PROG_VALUE_NAME   L"SystemSetupInProgress"

#define CTRL_SET_NAME_TEMPLATE   L"ControlSet000"
#define CTRL_SET_NAME_CHAR_COUNT 13
#define CTRL_SET_NAME_NUM_OFFSET 10
#define CTRL_SET_NAME_BYTES      ((CTRL_SET_CHAR_COUNT+1) * sizeof(WCHAR))

#define CLONE_SECURITY_INFORMATION (OWNER_SECURITY_INFORMATION | \
                                    GROUP_SECURITY_INFORMATION | \
                                    DACL_SECURITY_INFORMATION  | \
                                    SACL_SECURITY_INFORMATION)

//
// STANDARD access is obtained for the system and select keys.
// We read and write to these keys.
//
#define SC_STANDARD_KEY_ACCESS  KEY_READ   | \
                                READ_CONTROL |  \
                                WRITE_OWNER  |  \
                                KEY_WRITE

//
// CLONE access is obtained for the top level clone key
// We must be able to copy and delete clone trees.
//

#define SC_CLONE_KEY_ACCESS     KEY_READ     |  \
                                READ_CONTROL |  \
                                WRITE_OWNER  |  \
                                DELETE       |  \
                                ACCESS_SYSTEM_SECURITY

//
// CONTROL_SET access is obtained for the top level control sets.
// We must be able to copy and delete control sets.
// NOTE:  SE_SECURITY_PRIVILEGE is required to get ACCESS_SYSTEM_SECURITY.
//
#define SC_CONTROL_SET_KEY_ACCESS   KEY_READ     |          \
                                    KEY_WRITE    |          \
                                    DELETE       |          \
                                    READ_CONTROL |          \
                                    WRITE_OWNER  |          \
                                    ACCESS_SYSTEM_SECURITY

//
// COPY access is obtained for each subkey in a control set as it is being
// copied.
// NOTE:  SE_SECURITY_PRIVILEGE is required to get ACCESS_SYSTEM_SECURITY.
//
#define SC_COPY_KEY_ACCESS      KEY_READ     |          \
                                READ_CONTROL |          \
                                ACCESS_SYSTEM_SECURITY
//
// DELETE access is obtained for each subkey in a control set that is being
// deleted.
//
#define SC_DELETE_KEY_ACCESS    DELETE      | \
                                KEY_READ

//
// CREATE access is the access used for all keys created by this
// process.
//

#define SC_CREATE_KEY_ACCESS    KEY_WRITE   |           \
                                WRITE_OWNER |           \
                                WRITE_DAC   |           \
                                ACCESS_SYSTEM_SECURITY

//
// Control Set IDs are stored in an array of DWORDs.  The array has the
// following offsets for each ID:
//

#define CURRENT_ID  0
#define DEFAULT_ID  1
#define LKG_ID      2
#define FAILED_ID   3

#define NUM_IDS     4


//
// Macros
//

#define SET_LKG_ENV_VAR(pString)                        \
    {                                                   \
    UNICODE_STRING  Name,Value;                         \
                                                        \
    RtlInitUnicodeString(&Name, L"LastKnownGood");      \
    RtlInitUnicodeString(&Value,pString);               \
                                                        \
    status = RtlNtStatusToDosError(NtSetSystemEnvironmentValue(&Name,&Value)); \
    }

//
// GLOBALS
//

    //
    // This flag is set when ScCheckLastKnownGood is called.  It is later
    // checked when either ScRevertToLastKnownGood or NotifyBootConfigStatus
    // is called.  TRUE indicates that we know we are booting LastKnownGood.
    //

    DWORD               ScGlobalLastKnownGood;
    BOOL                ScGlobalBootAccepted = FALSE;

    CRITICAL_SECTION    ScBootConfigCriticalSection;

    LPDWORD             ScGlobalOrphanIds = NULL;

//
// LOCAL FUNCTION PROTOTYPES
//

DWORD
ScGetTopKeys(
    PHKEY   SystemKey,
    PHKEY   SelectKey
    );

DWORD
ScGetCtrlSetIds(
    HKEY    SelectKey,
    LPDWORD IdArray
    );

BOOL
ScBuildCtrlSetName(
    LPWSTR  ControlSetName,
    DWORD   ControlId
    );

HKEY
ScGetCtrlSetHandle(
    HKEY    SystemKey,
    DWORD   ControlId,
    LPWSTR  ControlSetName
    );

VOID
ScDeleteTree(
    IN HKEY KeyHandle
    );

VOID
ScCopyKeyRecursive(
    HKEY    ParentKey,
    PHKEY   DestKeyPtr,
    HKEY    SourceKey,
    LPWSTR  DestKeyName
    );

VOID
ScCopyKeyValues(
    HKEY    DestKey,
    HKEY    SourceKey,
    DWORD   NumberOfValues,
    DWORD   MaxValueNameLength,
    DWORD   MaxValueDataLength
    );

VOID
ScDeleteRegTree(
    HKEY    ParentKey,
    HKEY    KeyToDelete,
    LPWSTR  NameOfKeyToDelete
    );

VOID
ScGatherOrphanIds(
    HKEY        SystemKey,
    LPDWORD     *OrphanIdPtr,
    LPDWORD     idArray
    );

BOOL
ScMatchInArray(
    DWORD       Value,
    LPDWORD     IdArray
    );

VOID
ScStartCtrlSetCleanupThread();

DWORD
ScCleanupThread();

DWORD
ScAcceptTheBoot(
    VOID
    );

DWORD
ScGetNewCtrlSetId(
      LPDWORD IdArray,
      LPDWORD NewIdPtr
      );


BOOL
ScCheckLastKnownGood(
    VOID
    )

/*++

Routine Description:

    This function is called early in the service controller initialization.
    Its purpose is to protect the LastKnownGood control set.  If this
    function finds that the control set that we are booting is the
    LastKnownGood control set, it will save the clone tree to a new
    control set and make this LastKnownGood.  The clone tree in this case
    is an unchanged version of LKG.  The Current control is not!  Current
    may have been modified by drivers that were started before the service
    controller was started.

    Phase 2 of the boot procedure is always responsible for actually
    doing the revert to LastKnownGood.  We determine that we have reverted
    by noting that Current and LKG will be the same control sets, and
    Default will be different.  If Default is the same (all three control
    sets are the same), then it is the very first boot, and we don't consider
    it a failure case.  If Phase 2 is causing the boot from LastKnownGood,
    then we want to set
        Failed  to Default  and
        Current to LKG      and
        Set the LKG environment variable to FALSE.
    The assumption here is that Phase2 is using LastKnownGood because
    The Default Control Set was not acceptable.

Arguments:

    TRUE - If all the necessary operations were successful.

    FALSE - If any of the control set manipulation could not be completed
        successfully.

Return Value:


Note:


--*/
{
    DWORD   status;
    BOOL    retStat;
    HKEY    systemKey=0;
    HKEY    selectKey=0;
    HKEY    failedKey=0;
    HKEY    newKey=0;

    DWORD   idArray[NUM_IDS];
    WCHAR   failedKeyName[CTRL_SET_NAME_CHAR_COUNT+1];

    DWORD   savedLkgId;
    DWORD   newId;
    ULONG   privileges[5];

    //
    // Initialize the Critical section that will synchronize access to
    // these routines.  The service controller could call
    // ScRevertToLastKnownGood at the same time that someone calls
    // NotifyBootConfigStatus().  This could cause the control set pointers
    // to get corrupted.  So access to these functions is restricted by
    // a critical section.  It is initialized here because this function
    // must be called prior to starting any services, or starting the
    // RPC server.  Therefore we can't get asynchronous calls to these
    // routines at this time.
    //
    InitializeCriticalSection(&ScBootConfigCriticalSection);

    //
    // This thread gets SE_SECURITY_PRIVILEGE for copying security
    // descriptors and deleting keys.
    //
    privileges[0] = SE_BACKUP_PRIVILEGE;
    privileges[1] = SE_RESTORE_PRIVILEGE;
    privileges[2] = SE_SECURITY_PRIVILEGE;
    privileges[3] = SE_TAKE_OWNERSHIP_PRIVILEGE;
    privileges[4] = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;

    status = ScGetPrivilege( 5, privileges);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScCheckLastKnownGood: ScGetPrivilege Failed %d\n",
            status);
        return(FALSE);
    }


    //
    // Get the System, Select, and Clone Keys
    //
    status = ScGetTopKeys(&systemKey, &selectKey);
    if (status != NO_ERROR) {
        SC_LOG0(ERROR,"ScCheckLastKnownGood: ScGetTopKeys failed\n");
        retStat = FALSE;
        goto CleanExit;
    }

    //
    // Get the ControlSetIds stored in the \system\select key.
    //

    status = ScGetCtrlSetIds(
                selectKey,
                idArray);

    if (status != NO_ERROR) {

        ScRegCloseKey(systemKey);
        ScRegCloseKey(selectKey);
        SC_LOG0(ERROR,"ScCheckLastKnownGood: ScGetCtrlSetIds Failed\n");
        retStat = FALSE;
        goto CleanExit;
    }

    //
    // Scan for Orphaned Control Sets.
    // This is required prior to calling ScGetNewCtrlSetId (which
    // avoids the orphaned numbers).
    //
    ScGatherOrphanIds(systemKey,&ScGlobalOrphanIds,idArray);

    if ((SetupInProgress(systemKey, NULL)) ||
        (idArray[CURRENT_ID] != idArray[LKG_ID])) {
        //
        // We are not booting from LastKnownGood, so we don't do
        // anything except make sure the LKG_FLAG not set.
        //

        ScGlobalLastKnownGood = 0;

        ScRegCloseKey(systemKey);
        ScRegCloseKey(selectKey);
        retStat = TRUE;
        goto CleanExit;
    }
    else {
        //
        // We Must be booting the LastKnownGood configuration.
        // Put LkgControlSetId into SavedLkgControlSetId.
        //
        SC_LOG0(TRACE,"ScCheckLastKnownGood, We are booting LKG\n");
        savedLkgId = idArray[LKG_ID];

        //
        // Set the LKG environment variable to FALSE - so Phase 2
        // does not automatically revert again.
        //
        SET_LKG_ENV_VAR(L"False");
        if (status != NO_ERROR) {
            SC_LOG1(ERROR,"ScCheckLastKnownGood: Couldn't clear LKG "
            "environment variable %d\n",status);
        }

        //
        // Copy the Clone tree into a non-volatile node (new ControlSetId).
        //

        SC_LOG0(TRACE,"ScCheckLastKnownGood, Copy Clone to new ctrl set\n");

        status = ScGetNewCtrlSetId( idArray, &newId);
        if(status == NO_ERROR)
        {
           status = RtlNtStatusToDosError(NtInitializeRegistry(REG_INIT_BOOT_ACCEPTED_BASE +
                                                               (USHORT)newId));
        }

        if (status != NO_ERROR) {

            SC_LOG0(ERROR,"ScCheckLastKnownGood: ScGetNewCtrlSetId Failed\n");
            SC_LOG0(ERROR,"SERIOUS ERROR - Unable to copy control set that "
                         "is to be saved as LastKnownGood\n");
        }
        else {
            SC_LOG0(TRACE,"ScCheckLastKnownGood, Copy Clone is complete\n");

            //
            // Set LkgControlSetId to this new ControlSetId.
            //

            SC_LOG0(TRACE,"ScCheckLastKnownGood, Set LKG to this new ctrl set\n");

            idArray[LKG_ID]  = newId;
            status = ScRegSetValueExW(
                        selectKey,                  // hKey
                        LKG_VALUE_NAME,             // lpValueName
                        0,                          // dwValueTitle (OPTIONAL)
                        REG_DWORD,                  // dwType
                        (LPBYTE)&(idArray[LKG_ID]), // lpData
                        sizeof(DWORD));             // cbData

            ScRegCloseKey(newKey);

            if (status != NO_ERROR) {
                SC_LOG1(ERROR,"ScCheckLastKnownGood: ScRegSetValueEx (lkgValue) "
                "failed %d\n",status);
                SC_LOG1(ERROR,"Semi-SERIOUS ERROR - Unable to Set Select Value "
                             "For LastKnownGood.\nThe new ControlSet%d should "
                             "be LKG\n",newId);
            }
            else {


                //
                // Since we already generated a LKG, we don't want to allow the
                // user or the boot verfication program to try to go through the
                // motions of generating it again.  So we set the global flag that
                // indicates that the boot was accepted as LKG.
                //
                ScGlobalBootAccepted = TRUE;

                //
                // Set Global LKG_FLAG to indicate that we are running LKG, and
                // whether or not we are here because we reverted.  The only
                // reason we would be here without reverting is because it is the
                // very first boot.  But in the very first boot, FAILED is 0.
                //

                ScGlobalLastKnownGood |= RUNNING_LKG;
                if (idArray[FAILED_ID] != 0) {
                    ScGlobalLastKnownGood |= REVERTED_TO_LKG;
                }

            } //endif - Set LKG Id to NetCtrlSet ID;

        } //endif - MakeNewCtrlSet == TRUE;

        //
        // If the DefaultControlSetId is the same as the original
        // LkgControlSetId, then Phase2 of the boot must have reverted
        // to Last Known Good.
        //
        if (idArray[DEFAULT_ID] != savedLkgId) {
            //
            // We are booting LastKnownGood because it was set that way
            // by Phase2 of the boot.  In this case, we want to set the
            // FailedControlSetId to the DefaultControlSetId.  Then we
            // want to set the DefaultControlSetId to the CurrentControlSetId.
            //
            // NOTE:  On the very first boot, we don't go through this path
            // because current=default=lkg.
            //

            SC_LOG0(TRACE,"ScCheckLastKnownGood, Phase 2 caused LKG"
                         " so we delete the failed tree and put\n"
                         "   Default->Failed\n"
                         "   Lkg -> Default\n");

            if (idArray[FAILED_ID] != 0) {
                SC_LOG0(TRACE,"ScCheckLastKnownGood: Deleting Old Failed Tree\n");
                failedKey = ScGetCtrlSetHandle(
                                systemKey,
                                idArray[FAILED_ID],
                                failedKeyName);

                ScDeleteRegTree(systemKey, failedKey, failedKeyName);
            }

            //
            // Put the DefaultId into the Failed value.
            //
            idArray[FAILED_ID]  = idArray[DEFAULT_ID];
            status = ScRegSetValueExW(
                        selectKey,                      // hKey
                        FAILED_VALUE_NAME,              // lpValueName
                        0,                              // dwValueTitle (OPTIONAL)
                        REG_DWORD,                      // dwType
                        (LPBYTE)&(idArray[FAILED_ID]),  // lpData
                        sizeof(DWORD));                 // cbData

            if (status != NO_ERROR) {
                SC_LOG1(ERROR,"ScCheckLastKnownGood: ScRegSetValueEx (failedValue) failed %d\n",
                    status);
            }

            //
            // Put the CurrentId into the Default Value.
            //
            idArray[DEFAULT_ID] = idArray[CURRENT_ID];
            status = ScRegSetValueExW(
                        selectKey,                      // hKey
                        DEFAULT_VALUE_NAME,             // lpValueName
                        0,                              // dwValueTitle (OPTIONAL)
                        REG_DWORD,                      // dwType
                        (LPBYTE)&(idArray[CURRENT_ID]), // lpData
                        sizeof(DWORD));                 // cbData

            if (status != NO_ERROR) {
                SC_LOG1(ERROR,"ScCheckLastKnownGood: ScRegSetValueEx (DefaultValue) failed %d\n",
                    status);
                ScRegCloseKey(selectKey);
                ScRegCloseKey(systemKey);
                retStat = FALSE;
                goto CleanExit;
            }
        }

        ScRegCloseKey(systemKey);
        ScRegCloseKey(selectKey);
    }

    retStat = TRUE;

CleanExit:

    //
    // If the code above was successful then mark the boot as having been 
    // successful.
    //

    if(retStat) {

        HANDLE bootStatusData;
        BOOL b = TRUE;

        status = RtlLockBootStatusData(&bootStatusData);

        if(NT_SUCCESS(status)) {

            RtlGetSetBootStatusData(bootStatusData,
                                    FALSE,
                                    RtlBsdItemBootGood,
                                    &b,
                                    sizeof(BOOL),
                                    NULL);
    
            RtlUnlockBootStatusData(bootStatusData);
        }
    }

    //
    // Restore privileges for the current thread.
    //
    (VOID)ScReleasePrivilege();

    //
    // Remove any control sets that need to be deleted (clone or orphans).
    // This is performed by a seperate thread.
    //
    if (ScGlobalOrphanIds != NULL) {
        ScStartCtrlSetCleanupThread();
    }
    return(retStat);
}


DWORD
ScRevertToLastKnownGood(
    VOID
    )

/*++

Routine Description:

    This function attempts to revert to the last known good control set.

    It does this in the following manner:
    If not running LastKnownGood:
        Set the LKG environment variable so that phase 2 of the boot
        procedure will cause the revert to happen.  Then shutdown the
        system so it will boot again.


Arguments:


Return Value:


Note:


--*/
{
    DWORD       status;
    NTSTATUS    ntStatus;

    ULONG   privileges[6];

    //
    // If we are not currently running LastKnownGood, then set the tree we
    // are booting from (clone) to failed. Set the Default to point to
    // LastKnownGood.  Then reboot.
    //
    if (!(ScGlobalLastKnownGood & RUNNING_LKG)) {

        EnterCriticalSection(&ScBootConfigCriticalSection);
        if (ScGlobalBootAccepted) {
            //
            // If the boot has already been accepted, then we don't want
            // to allow a forced revert.
            //

            LeaveCriticalSection(&ScBootConfigCriticalSection);
            return(ERROR_BOOT_ALREADY_ACCEPTED);
        }

        SC_LOG0(TRACE,"ScRevertToLastKnownGood: Reverting...\n");
        //
        // This thread gets SE_SECURITY_PRIVILEGE for copying security
        // descriptors and deleting keys.
        //
        privileges[0] = SE_BACKUP_PRIVILEGE;
        privileges[1] = SE_RESTORE_PRIVILEGE;
        privileges[2] = SE_SECURITY_PRIVILEGE;
        privileges[3] = SE_SHUTDOWN_PRIVILEGE;
        privileges[4] = SE_SYSTEM_ENVIRONMENT_PRIVILEGE;
        privileges[5] = SE_TAKE_OWNERSHIP_PRIVILEGE;

        status = ScGetPrivilege( 6, privileges);
        if (status != NO_ERROR) {
            SC_LOG1(ERROR, "ScRevertToLastKnownGood: ScGetPrivilege Failed %d\n",
                status);
            LeaveCriticalSection(&ScBootConfigCriticalSection);
            return(status);
        }

        //
        // Set the LKG environment variable to True - so Phase 2
        // will automatically revert, or put up the screen asking if the
        // user wants to revert.
        //

        SET_LKG_ENV_VAR(L"True");
        if (status != NO_ERROR) {
            //
            // If we could not set the environment variable that causes
            // the revert, there is no reason to reboot.  Otherwise, we
            // we would reboot continuously.
            //
            // WE SHOULD LOG AN EVENT HERE - that says that we should
            // reboot, but we didn't.
            //
            SC_LOG1(ERROR,"RevertToLastKnownGood: Couldn't set LKG "
            "environment variable %d\n",status);

            (VOID)ScReleasePrivilege();
            LeaveCriticalSection(&ScBootConfigCriticalSection);
            return(NO_ERROR);
        }

        //
        // Re-boot.
        //
        SC_LOG0(ERROR,"Reverted To LastKnownGood.  Now Rebooting...\n");

        ScLogEvent(NEVENT_REVERTED_TO_LASTKNOWNGOOD);

        //
        // Just prior to shutting down, sleep for 5 seconds so that the
        // system has time to flush the events to disk.
        //
        Sleep(5000);

        LeaveCriticalSection(&ScBootConfigCriticalSection);
        ntStatus = NtShutdownSystem(ShutdownReboot);

        if (!NT_SUCCESS(ntStatus)) {
            SC_LOG1(ERROR,"NtShutdownSystem Failed 0x%lx\n",ntStatus);
        }

        //
        // Restore privileges for the current thread.
        //
        (VOID)ScReleasePrivilege();

        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Otherwise... just return back to the caller.
    //
    return(ERROR_ALREADY_RUNNING_LKG);
}

DWORD
RNotifyBootConfigStatus(
    IN LPWSTR   lpMachineName,
    IN DWORD    BootAcceptable
    )

/*++

Routine Description:

    If we are not currently booted with Last Known Good, this function
    will revert to Last Known Good if the boot is not acceptable.  Or it
    will save the boot configuration that we last booted from as the
    Last Known Good.  This is the configuration that we will fall back
    to if a future boot fails.

Arguments:

    BootAcceptable - This indicates whether or not the boot was acceptable.

Return Value:

    TRUE - This is only returned if the boot is acceptable, and we
        successfully replaced Last Known Good with the current boot
        configuration.

    FALSE - This is returned if an error occured when attempting to replace
        Last Known Good or if the system is currently booted from Last
        Known Good.

Note:


--*/
{
    DWORD   status=NO_ERROR;
    SC_HANDLE_STRUCT  scManagerHandle;

    UNREFERENCED_PARAMETER(lpMachineName);  // This should always be null.

    //
    // Perform a security check to see if the caller has
    // SC_MANAGER_MODIFY_BOOT_CONFIG access.
    //

    scManagerHandle.Signature = SC_SIGNATURE;
    scManagerHandle.Type.ScManagerObject.DatabaseName = NULL;

    status = ScAccessValidate(&scManagerHandle,SC_MANAGER_MODIFY_BOOT_CONFIG);
    if (status != NO_ERROR) {
        return(status);
    }

    if (ScGlobalLastKnownGood & RUNNING_LKG) {
        //
        // If we are already booting LastKnownGood, then return false.
        //
        return(ERROR_ALREADY_RUNNING_LKG);
    }

    if (BootAcceptable) {

        SC_LOG0(TRACE,"NotifyBootConfigStatus: Boot is Acceptable\n");
        //
        // Must enter critical section before progressing.
        //
        EnterCriticalSection(&ScBootConfigCriticalSection);

        if (ScGlobalBootAccepted) {
            LeaveCriticalSection(&ScBootConfigCriticalSection);
            return(ERROR_BOOT_ALREADY_ACCEPTED);
        }

        //
        // If Auto-Start is not complete yet, then we just want to mark
        // to boot as accepted and operate on it after auto-start completion.
        // We also want to set the ScGlobalBootAccepted flag so that
        // further requests to accept the boot will be ignored.
        //
        if (!(ScGlobalLastKnownGood & AUTO_START_DONE)) {
            SC_LOG0(BOOT,"RNotifyBootConfigStatus: Boot Accepted, but Auto-start "
                "is not complete.  Defer acceptance\n");
            ScGlobalLastKnownGood |= ACCEPT_DEFERRED;
            ScGlobalBootAccepted = TRUE;
        }
        else {
            SC_LOG0(BOOT,"RNotifyBootConfigStatus: Boot Accepted and Auto-start "
                "is complete\n");
            status = ScAcceptTheBoot();
        }

        LeaveCriticalSection(&ScBootConfigCriticalSection);

        return(status);
    }

    else {

        //
        // The Boot was not acceptable.
        //
        // NOTE:  We should never return from the call to
        //        ScRevertToLastKnownGood.
        //
        //
        SC_LOG0(TRACE,"NotifyBootConfigStatus: Boot is Not Acceptable. Revert!\n");
        return(ScRevertToLastKnownGood());
    }
}

DWORD
ScGetTopKeys(
    PHKEY   SystemKey,
    PHKEY   SelectKey
    )

/*++

Routine Description:

    This function opens handles to the SystemKey, and the SelectKey.

Arguments:


Return Value:


Note:



--*/

{
    DWORD   status;

    //
    // Get the System Key
    //

    status = ScRegOpenKeyExW(
                HKEY_LOCAL_MACHINE,     // hKey
                SYSTEM_KEY,             // lpSubKey
                0L,                     // ulOptions (reserved)
                SC_STANDARD_KEY_ACCESS, // desired access
                SystemKey);             // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetTopKeys: ScRegOpenKeyEx (system key) failed %d\n",status);
        return (status);
    }

    //
    // Get the Select Key
    //
    status = ScRegOpenKeyExW(
                *SystemKey,             // hKey
                SELECT_KEY,             // lpSubKey
                0L,                     // ulOptions (reserved)
                SC_STANDARD_KEY_ACCESS, // desired access
                SelectKey);             // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetTopKeys: ScRegOpenKeyEx (select key) failed %d\n",status);
        ScRegCloseKey(*SystemKey);
        return (status);
    }

    return(NO_ERROR);
}

DWORD
ScGetCtrlSetIds(
    HKEY    SelectKey,
    LPDWORD IdArray
    )

/*++

Routine Description:

    This function obtains all the important Control Set IDs from the
    \system\select portion of the registry.  These IDs are in the form
    of a DWORD that is used to build the Key name for that control set.
    For instance the DWORD=003 is used to build the string
    "control_set_003".

    If a control set for one of these is not present, a 0 is returned
    for that ID.

Arguments:

    SelectKey - This is the Key Handle for the \system\select portion of
        the registry.

    IdArray - This is an array of DWORDs where each element is an ID.
        This array contains elements for Current, Default, LKG, and Failed.

Return Value:

    NO_ERROR - If the operation was successful.

    OTHER - Any error that can be returned from RegQueryValueEx could be
        returned here if we fail to get an ID for Current, Default, or
        LKG.  We expect Failed To be empty to start with.

Note:


--*/
{
    DWORD   status;
    DWORD   bufferSize;

    //
    // Get the Current Id
    //
    bufferSize = sizeof(DWORD);
    status = ScRegQueryValueExW (
                SelectKey,                      // hKey
                CURRENT_VALUE_NAME,             // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)&IdArray[CURRENT_ID],   // lpData
                &bufferSize);                   // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetCtrlSetIds,ScRegQueryValueEx(current) failed %d\n",status);
        IdArray[CURRENT_ID] = 0;
        return(status);
    }

    //
    // Get the DefaultID
    //
    bufferSize = sizeof(DWORD);
    status = ScRegQueryValueExW (
                SelectKey,                      // hKey
                DEFAULT_VALUE_NAME,             // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)&IdArray[DEFAULT_ID],   // lpData
                &bufferSize);                   // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetCtrlSetIds,ScRegQueryValueEx(default) failed %d\n",status);
        IdArray[DEFAULT_ID] = 0;
        return(status);
    }

    //
    // Get the LKG Id
    //
    bufferSize = sizeof(DWORD);
    status = ScRegQueryValueExW (
                SelectKey,                  // hKey
                LKG_VALUE_NAME,             // lpValueName
                NULL,                       // lpTitleIndex
                NULL,                       // lpType
                (LPBYTE)&IdArray[LKG_ID],   // lpData
                &bufferSize);               // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetCtrlSetIds,ScRegQueryValueEx(LKG) failed %d\n",status);
        IdArray[LKG_ID] = 0;
        return(status);
    }

    //
    // Get the Failed Id
    //
    bufferSize = sizeof(DWORD);
    status = ScRegQueryValueExW (
                SelectKey,                      // hKey
                FAILED_VALUE_NAME,              // lpValueName
                NULL,                           // lpTitleIndex
                NULL,                           // lpType
                (LPBYTE)&IdArray[FAILED_ID],    // lpData
                &bufferSize);                   // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetCtrlSetIds,ScRegQueryValueEx(Failed) failed %d\n",status);
        IdArray[FAILED_ID] = 0;
    }

    return(NO_ERROR);
}

VOID
ScDeleteRegTree(
    HKEY    ParentKey,
    HKEY    KeyToDelete,
    LPWSTR  NameOfKeyToDelete
    )

/*++

Routine Description:

    This function walks through a Key Tree and deletes all the sub-keys
    contained within.  It then closes the top level Key Handle, and deletes
    that key (which is a subkey of the parent).

    This function also closes the handle for the key being deleted.

Arguments:

    ParentKey - This is the handle to the parent key whose sub-key is being
        deleted.

    KeyToDelete - A handle to the key that is to be deleted.

    NameOfKeyToDelete - This is a pointer to a string that Identifies the
        name of the key that is to be deleted.

Return Value:

    none.

Note:


--*/
{
    DWORD   status;

    if (KeyToDelete == NULL)
    {
        return;
    }

    //
    // Delete the tree.
    //
    ScDeleteTree(KeyToDelete);

    ScRegCloseKey(KeyToDelete);


    status = ScRegDeleteKeyW(ParentKey, NameOfKeyToDelete);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScDeleteRegTree, ScRegDeleteKey failed %d\n",status);
    }

    return;
}

BOOL
ScBuildCtrlSetName(
    LPWSTR  ControlSetName,
    DWORD   ControlId
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

--*/
{
    DWORD   NumOffset = CTRL_SET_NAME_NUM_OFFSET;

    //
    // Build the name.  NumOffset is the array offset of where the
    // number portion of the name is to be stored.  The number initially
    // contains 000.  And the offset points to the first zero.  If only
    // two digits are to be stored, the offset is first incremented to
    // point to where the last two digits go.
    //
    if (ControlId > 999) {
        SC_LOG1(ERROR, "ScBuildCtrlSetName,ControlId Too Large -- %d\n",ControlId);
        return(FALSE);
    }

    if (ControlId < 100) {
        NumOffset++;
    }

    if (ControlId < 10) {
        NumOffset++;
    }

    wcscpy(ControlSetName, CTRL_SET_NAME_TEMPLATE);

    //
    // The above checks should assure that the _ultow call will not
    // overflow the buffer.
    //
    _ultow(ControlId, &(ControlSetName[NumOffset]), 10);

    return(TRUE);
}

HKEY
ScGetCtrlSetHandle(
    HKEY    SystemKey,
    DWORD   ControlId,
    LPWSTR  ControlSetName
    )

/*++

Routine Description:

    This function uses the ControlId to create the name of the control set
    to open.  Then it opens a Key (handle) to this control set.
    Then name was well as the key handle are returned.

Arguments:

    SystemKey - This is the handle for the System Key.  The Control Sets
        are sub-keys for this key.

    ControlId - This is the ID for the Control Set for which we are
        desiring a handle (key).

    KeyName - This is a pointer to a location where the name of the key
        is to be placed.

Return Value:

    HKEY - This is the Key handle for the control set in question.  If the
        control set does not exist, a NULL is returned.

Note:


--*/

{
    DWORD   status;
    HKEY    ctrlSetKey;

    //
    // Build the Control Set Name
    //
    if (!ScBuildCtrlSetName(ControlSetName, ControlId)) {
        return(NULL);
    }

    //
    // Open the Key for this name.
    //

    SC_LOG1(TRACE,"ScGetCtrlSetHandle: ControlSetName = "FORMAT_LPWSTR"\n",
        ControlSetName);

    //
    // Get the ControlSetName
    //

    status = ScRegOpenKeyExW(
                SystemKey,                  // hKey
                ControlSetName,             // lpSubKey
                0L,                         // ulOptions (reserved)
                SC_CONTROL_SET_KEY_ACCESS,  // desired access
                &ctrlSetKey);               // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG2(ERROR,"ScGetCtrlSetHandle: ScRegOpenKeyEx (%ws) failed %d\n",
            ControlSetName,
            status);
        return (NULL);
    }

    return(ctrlSetKey);

}


DWORD
ScGetNewCtrlSetId(
      LPDWORD IdArray,
      LPDWORD NewIdPtr
      )
/*++

Routine Description:

    This routine computes the new control set ID to be used for
    the LKG control set

Arguments:

    IdArray - Supplies the ID array filled in by ScGetCtrlSetIds

    NewIdPtr - Returns a free ID to be used for the LKG control set

Return Value:

    Either NO_ERROR if successful or ERROR_NO_MORE_ITEMS if there
    are no more free IDs (should never happen)

--*/
{
   DWORD newId, i;
   BOOL inArray;

   for(newId = 1; newId < 1000; newId++)
   {
      inArray = FALSE;
      for(i = 0; i < NUM_IDS; i++)
      {
         if(IdArray[i] == newId)
         {
            inArray = TRUE;
            break;
         }
      }

      if (!inArray && !ScMatchInArray(newId, ScGlobalOrphanIds))
      {
         *NewIdPtr = newId;
         return NO_ERROR;
      }
   }

   return ERROR_NO_MORE_ITEMS;
}


VOID
ScDeleteTree(
    IN HKEY KeyHandle
    )

/*++

Routine Description:

    This function recursively deletes all keys under the key handle that
    is passed in.

Arguments:

    KeyHandle - This is the handle for the Key Tree that is being deleted.

Return Value:

    none.

Note:

    This was cut & pasted from ..\..\winreg\tools\crdel\crdel.c
    The only modifications were changing TSTR to WSTR and calling the
    UNICODE version of the functions.

--*/

{
    DWORD   status;
    DWORD   Index;
    HKEY    ChildHandle;
    DWORD   bytesReturned;
    BYTE    buffer[ sizeof( KEY_FULL_INFORMATION) + sizeof( WCHAR) * MAX_PATH];
    DWORD   NumberOfSubKeys;
    PWCHAR  KeyName;

    status = NtQueryKey(
                (HANDLE)KeyHandle,
                KeyFullInformation,
                (PVOID)buffer,
                sizeof( buffer),
                &bytesReturned
                );

    if ( status != STATUS_SUCCESS) {
        SC_LOG1(ERROR, "ScDeleteTree: NtQueryKey Failed 0x%x\n",status);
        return;
    }

    NumberOfSubKeys = ((PKEY_FULL_INFORMATION)buffer)->SubKeys;
    KeyName = (PWCHAR)buffer;

    for( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        status = ScRegEnumKeyW(
                    KeyHandle,
                    0,
                    KeyName,
                    sizeof( buffer)
                    );

        if (status != NO_ERROR) {
            SC_LOG1(ERROR, "ScDeleteTree: ScRegEnumKeyW Failed %d\n",status);
            return;
        }

        status = ScRegOpenKeyExW(
                    KeyHandle,
                    KeyName,
                    REG_OPTION_RESERVED,
                    SC_DELETE_KEY_ACCESS,
                    &ChildHandle
                    );
        if (status != NO_ERROR) {
            SC_LOG2(ERROR, "ScDeleteTree: ScRegOpenKeyExW (%ws) Failed %d\n",
                KeyName,
                status);
            return;
        }

        ScDeleteTree( ChildHandle );


        status = ScRegDeleteKeyW(
                    KeyHandle,
                    KeyName);

        NtClose( (HANDLE)ChildHandle);

        if ( status != NO_ERROR) {
            SC_LOG1(ERROR, "ScDeleteTree: ScRegDeleteKeyW Failed 0x%x\n", status);
            return;
        }
    }
}


VOID
ScDeleteRegServiceEntry(
    LPWSTR  ServiceName
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD   status;
    HKEY    parentKey;
    HKEY    keyToDelete;
    ULONG   privileges[4];
    LPWSTR  ServicesKeyPath = SERVICES_KEY;

    //*******************************
    //  Delete the registry node for
    //  This service.
    //*******************************

    privileges[0] = SE_BACKUP_PRIVILEGE;
    privileges[1] = SE_RESTORE_PRIVILEGE;
    privileges[2] = SE_SECURITY_PRIVILEGE;
    privileges[3] = SE_TAKE_OWNERSHIP_PRIVILEGE;
    status = ScGetPrivilege( 4, privileges);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScDeleteRegServiceEntry: ScGetPrivilege Failed %d\n",
            status);
        return;
    }

    //
    // Open the "services" section of the CurrentControlSet.
    //
    status = ScRegOpenKeyExW(
                HKEY_LOCAL_MACHINE,         // hKey
                ServicesKeyPath,            // lpSubKey
                0L,                         // ulOptions (reserved)
                SC_DELETE_KEY_ACCESS,       // desired access
                &parentKey);                // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG2(ERROR,"ScDeleteRegServiceEntry: "
            "ScRegOpenKeyEx (%ws) failed %d\n",ServicesKeyPath,
            status);

        //
        // Restore privileges for the current thread.
        //
        (VOID)ScReleasePrivilege();
        return;
    }
    //
    // Get Key for the Tree we are to delete
    //
    status = ScRegOpenKeyExW(
                parentKey,                  // hKey
                ServiceName,                // lpSubKey
                0L,                         // ulOptions (reserved)
                SC_DELETE_KEY_ACCESS,       // desired access
                &keyToDelete);              // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG2(ERROR,"ScDeleteRegServiceEntry: "
            "ScRegOpenKeyEx (%ws) failed %d\n",ServiceName,
            status);

        ScRegCloseKey(parentKey);
        //
        // Restore privileges for the current thread.
        //
        (VOID)ScReleasePrivilege();
        return;
    }

    //
    // Delete the Key.
    // NOTE: ScDeleteRegTree will also close the handle to the keyToDelete.
    //
    ScDeleteRegTree(parentKey, keyToDelete, ServiceName);

    ScRegCloseKey(parentKey);

    //
    // Restore privileges for the current thread.
    //
    (VOID)ScReleasePrivilege();

    return;

}

VOID
ScGatherOrphanIds(
    HKEY        SystemKey,
    LPDWORD     *OrphanIdPtr,
    LPDWORD     idArray
    )

/*++

Routine Description:

    This function searches through the system key to find any orphan control
    set ids.  If any are found, they are packed into an array of ids that
    are passed back to the caller.

    NOTE:  This function allocates memory for *OrphanIdPtr if orphans
        exist.  It is the responsibility of the caller to free this memory.

Arguments:

    SystemKey - This is an open handle to the system key.

    OrphanIdPtr - This is a pointer to a location for the pointer to
        the array of Orphan IDs.  If there are no orphans, then this pointer
        is NULL on return from this routine.

    idArray - This is the array of IDs that are used in the select key.

Return Value:


Note:


--*/
{
    DWORD   enumStatus;
    DWORD   status;
    WCHAR   KeyName[ MAX_PATH ];
    DWORD   KeyNameLength = MAX_PATH;
    DWORD   i=0;
    DWORD   j=0;
    DWORD   numOrphans=0;
    DWORD   num;
    LPDWORD tempIdArray;
    DWORD   matchInArray;

    WCHAR       ClassName[ MAX_PATH ];
    DWORD       ClassNameLength=MAX_PATH;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;

    //
    // If the pointer points to something - free it. and make the pointer
    // NULL.
    //
    LocalFree(*OrphanIdPtr);
    *OrphanIdPtr = NULL;

    //
    // Find out how many subkeys there are in the system key.
    // This will tell us the maximum size of array required to store
    // potential orphan control set IDs.
    //
    status = ScRegQueryInfoKeyW(
                SystemKey,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );

    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScGatherOrphanIds: ScRegQueryInfoKey Failed %d\n",status);
        return;
    }

    //
    // Allocate a buffer for the orphan control set IDs.  This buffer is
    // initialized to 0 to guanantee that the array if IDs will be terminated
    // by a 0.
    //
    tempIdArray = (LPDWORD)LocalAlloc(LMEM_ZEROINIT, sizeof(DWORD) * (NumberOfSubKeys+1));
    if (tempIdArray == NULL) {
        SC_LOG0(ERROR, "ScGatherOrphanIds:LocalAlloc Failed\n");
        return;
    }

    do {
        enumStatus = ScRegEnumKeyW(
                        SystemKey,
                        i,
                        KeyName,
                        KeyNameLength);

        if (enumStatus == NO_ERROR) {
            //
            // We have a key name, is it a control set?
            //
            if ((wcslen(KeyName) == (CTRL_SET_NAME_CHAR_COUNT)) &&
                (!wcsncmp(
                    CTRL_SET_NAME_TEMPLATE,
                    KeyName,
                    CTRL_SET_NAME_NUM_OFFSET))) {

                //
                // It appears to be a control set, now get the number
                // and see if it is in the array of ids from the select
                // key.
                //
                num = (DWORD)_wtol(KeyName+CTRL_SET_NAME_NUM_OFFSET);

                matchInArray = FALSE;
                for (j=0; j<NUM_IDS; j++) {
                    if (num == idArray[j]) {
                        matchInArray = TRUE;
                        break;
                    }
                }
                //
                // It's not in the array of ids from the select key.
                // Add it to the number of orphans.
                //
                if ((matchInArray == FALSE) && (num < 1000)) {
                    if (numOrphans < NumberOfSubKeys) {
                        tempIdArray[numOrphans] = num;
                        numOrphans++;
                    }
                }
            }
        }
        i++;
    }
    while (enumStatus == NO_ERROR);

    if (numOrphans > 0) {
        *OrphanIdPtr = tempIdArray;
    }
    else {
        *OrphanIdPtr = NULL;
        LocalFree(tempIdArray);
    }
    return;
}

VOID
ScDeleteCtrlSetOrphans(
    VOID
    )

/*++

Routine Description:

    This function deletes orphaned control sets if any exist.  The control
    set numbers for these orphaned sets are pointed to by a global
    memory pointer.  If this pointer is non-null, then there are control sets
    to delete.  After deletion, the memory pointed to by this pointer is
    freed.

    NOTE:  The necessary privileges are expected to be held prior to calling
        this function.

Arguments:

    none

Return Value:

    none

--*/

{
    DWORD   status;
    DWORD   i;
    HKEY    systemKey;
    HKEY    keyToDelete;
    LPWSTR  SystemKeyPath = SYSTEM_KEY;
    WCHAR   nameOfKeyToDelete[CTRL_SET_NAME_CHAR_COUNT+1];

    if (ScGlobalOrphanIds != NULL) {

        //
        // Open the SYSTEM key in the registry.
        //
        status = ScRegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,         // hKey
                    SystemKeyPath,              // lpSubKey
                    0L,                         // ulOptions (reserved)
                    SC_DELETE_KEY_ACCESS,       // desired access
                    &systemKey);                // Newly Opened Key Handle

        if (status != NO_ERROR) {
            SC_LOG2(ERROR,"ScDeleteCtrlSetOrphans: "
                "ScRegOpenKeyEx (%ws) failed %d\n",SystemKeyPath,
                status);

            return;
        }

        for (i=0; ScGlobalOrphanIds[i]!=0; i++) {
            //
            // Use the ID number to get the name and key handle for the
            // KeyToDelete.
            //
            keyToDelete = ScGetCtrlSetHandle(
                            systemKey,
                            ScGlobalOrphanIds[i],
                            nameOfKeyToDelete);

            //
            // Delete the entire tree.  Then go onto the next ID.
            //
            SC_LOG1(TRACE,
                "ScDeleteCtrlSetOrphans, Delete orphan control set %d\n",
                ScGlobalOrphanIds[i]);
            ScDeleteRegTree(systemKey, keyToDelete, nameOfKeyToDelete);
            SC_LOG0(TRACE,"ScDeleteCtrlSetOrphans, Finished Deleting orphan control set\n");
        }

        //
        // Free memory for IDs, and set the global pointer to NULL.
        //
        LocalFree(ScGlobalOrphanIds);
        ScGlobalOrphanIds = NULL;
    }
    return;
}

BOOL
ScMatchInArray(
    DWORD       Value,
    LPDWORD     Array
    )

/*++

Routine Description:

    This function scans through a null terminated array of DWORDs looking
    for a match with the DWORD value that is passed in.

Arguments:

    Value - The DWORD value that we are looking for.

    Array - The pointer to the Array of DWORDs that we are scanning through.

Return Value:

    TRUE - If a the Value is found in the Array.

    FALSE - If it is not found.

--*/
{

    DWORD   i;

    if (Array != NULL) {
        for(i=0; Array[i] != 0; i++) {
            if (Value == Array[i]) {
                return(TRUE);
            }
        }
    }
    return(FALSE);
}

VOID
ScStartCtrlSetCleanupThread(
    )

/*++

Routine Description:

    This function starts a thread that will delete delete any orphaned control sets.

Arguments:

    NONE.


Return Value:

    none

--*/
{
    DWORD   status;
    HANDLE  threadHandle;
    DWORD   threadId;

    threadHandle = CreateThread (
        NULL,                                   // Thread Attributes.
        0L,                                     // Stack Size
        (LPTHREAD_START_ROUTINE)ScCleanupThread,// lpStartAddress
        (LPVOID)0L,                             // lpParameter
        0L,                                     // Creation Flags
        &threadId);                             // lpThreadId

    if (threadHandle == (HANDLE) NULL) {
        SC_LOG1(ERROR,"ScStartCtrlSetCleanupThread:CreateThread failed %d\n",
            GetLastError());
        //
        // If we couldn't create the thread for some reason, then just
        // go ahead and to the cleanup with this thread.  This may make
        // booting the system slow, but it's the best I can do.
        //
        status = ScCleanupThread();
    }
    else {
        CloseHandle(threadHandle);
    }
}

DWORD
ScCleanupThread(
    )

/*++

Routine Description:

    This functions looks through the system key to see if
    there are any orphan control sets to delete.  If found, the orphans
    are deleted.  Orphaned control sets are control sets that exist in
    the system key, but are not referenced in the \system\select key.

    NOTE:  This function should only be called when no other threads are
    creating control sets.  Otherwise, this function may see a new control
    set that is not yet in the select key, and attempt to delete it.

Arguments:

    NONE.

Return Value:

    none.

--*/

{
    DWORD   status;
    HKEY    systemKey=0;
    HKEY    selectKey=0;
    DWORD   idArray[NUM_IDS];
    ULONG   privileges[4];

    //
    // This thread gets SE_SECURITY_PRIVILEGE for copying security
    // descriptors and deleting keys.
    //
    privileges[0] = SE_BACKUP_PRIVILEGE;
    privileges[1] = SE_RESTORE_PRIVILEGE;
    privileges[2] = SE_SECURITY_PRIVILEGE;
    privileges[3] = SE_TAKE_OWNERSHIP_PRIVILEGE;

    status = ScGetPrivilege( 4, privileges);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScCheckLastKnownGood: ScGetPrivilege Failed %d\n",
            status);
        return(FALSE);
    }
    EnterCriticalSection(&ScBootConfigCriticalSection);
    //
    // Get the System, Select, and Clone Keys
    //
    status = ScGetTopKeys(&systemKey, &selectKey);
    if (status != NO_ERROR) {
        SC_LOG0(ERROR,"ScCleanupThread: ScGetTopKeys failed\n");
        LeaveCriticalSection(&ScBootConfigCriticalSection);
        goto CleanExit;
    }

    //
    // Get the ControlSetIds stored in the \system\select key.
    //

    status = ScGetCtrlSetIds(
                selectKey,
                idArray);

    if (status != NO_ERROR) {
        SC_LOG0(ERROR,"ScCleanupThread: ScGetCtrlSetIds Failed\n");
        LeaveCriticalSection(&ScBootConfigCriticalSection);
        goto CleanExit;
    }

    //
    // Scan for Orphaned Control Sets.
    //
    ScGatherOrphanIds(systemKey,&ScGlobalOrphanIds,idArray);

    LeaveCriticalSection(&ScBootConfigCriticalSection);

    if (ScGlobalOrphanIds != NULL) {
        ScDeleteCtrlSetOrphans();
    }

CleanExit:
    if (systemKey != 0) {
        ScRegCloseKey(systemKey);
    }
    if (selectKey != 0) {
        ScRegCloseKey(selectKey);
    }
    (VOID)ScReleasePrivilege();
    return(0);
}

VOID
ScRunAcceptBootPgm(
    VOID
    )

/*++

Routine Description:

    This function is called after the Service Controller has finished
    auto-starting all the auto-start services.  If the boot has already
    been accepted (for instance, WinLogon already called
    NotifyBootConfigStatus()), then at this point we can accept the boot.

    If the boot has not yet been accepted, this function looks in the
    ACCEPT_BOOT_KEY portion of the registry to
    see if there is a value containing the image path of the boot verify
    program to execute.  The program can have any name or path.  If it
    is in the registry, this function will run it.

    This function is called when the service controller thinks that the
    boot has completed successfully.  It is up to the exec'd program
    to decide if this is true or not, and take appropriate action if
    necessary.  The default boot verify program will simply accept the
    boot as is.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD               status;
    LPWSTR              AcceptBootKeyPath = ACCEPT_BOOT_KEY;
    HKEY                AcceptBootKey;
    DWORD               ValueType;
    LPWSTR              pTempImagePath;
    LPWSTR              pImagePath;
    PROCESS_INFORMATION processInfo;
    STARTUPINFOW        StartupInfo;
    DWORD               bufferSize;
    DWORD               charCount;


    //
    // Check to see if the boot has already been accepted.
    //
    EnterCriticalSection(&ScBootConfigCriticalSection);
    ScGlobalLastKnownGood |= AUTO_START_DONE;
    if (ScGlobalLastKnownGood & ACCEPT_DEFERRED) {
        SC_LOG0(BOOT,"ScRunAcceptBootPgm: Boot Acceptance was deferred. Accept "
            "it now\n");
        ScAcceptTheBoot();
        LeaveCriticalSection(&ScBootConfigCriticalSection);
        return;
    }
    LeaveCriticalSection(&ScBootConfigCriticalSection);

    //
    // Open the \CurrentControlSet\Control\AcceptBootPgm Key
    //

    //
    // Get the System Key
    //

    status = ScRegOpenKeyExW(
                HKEY_LOCAL_MACHINE,     // hKey
                AcceptBootKeyPath,      // lpSubKey
                0L,                     // ulOptions (reserved)
                KEY_READ,               // desired access
                &AcceptBootKey);        // Newly Opened Key Handle

    if (status != NO_ERROR) {
        SC_LOG2(TRACE,"ScRunAcceptBootPgm: ScRegOpenKeyEx (%ws) failed %d\n",
        AcceptBootKeyPath, status);
        return;
    }

    //
    // If the ImagePath value is there, then run the specified
    // program.
    //
    bufferSize = MAX_PATH * sizeof(WCHAR);
    pTempImagePath = (LPWSTR)LocalAlloc(LMEM_FIXED, bufferSize*2);
    if (pTempImagePath == NULL) {
        SC_LOG0(TRACE,"ScRunAcceptBootPgm,LocalAlloc failed \n");
        return;
    }
    pImagePath = pTempImagePath + MAX_PATH;

    status = ScRegQueryValueExW (
                AcceptBootKey,                  // hKey
                IMAGE_PATH_NAME,                // lpValueName
                NULL,                           // lpTitleIndex
                &ValueType,                     // lpType
                (LPBYTE)pTempImagePath,         // lpData
                &bufferSize);                   // lpcbData

    if (status != NO_ERROR) {
        SC_LOG1(TRACE,"ScRunAcceptBootPgm,ScRegQueryValueEx failed %d\n",status);
        ScRegCloseKey(AcceptBootKey);
        LocalFree(pTempImagePath);
        return;
    }
    SC_LOG1(TRACE,"ScRunAcceptBootPgm:Executing the %ws program\n",pTempImagePath);

    if ((ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ))
    {
        WCHAR wszEmpty[1] = {0};

        if (ValueType == REG_EXPAND_SZ)
        {
            charCount = ExpandEnvironmentStringsW (
                            pTempImagePath,
                            pImagePath,
                            MAX_PATH);

            if (charCount > MAX_PATH)
            {
                SC_LOG0(ERROR,"ScRunAcceptBootPgm: ImagePath is too big\n");
                LocalFree(pTempImagePath);
                return;
            }
        }
        else
        {
            pImagePath = pTempImagePath;
        }

        //
        // Exec the program.
        //

        StartupInfo.cb              = sizeof(STARTUPINFOW); // size
        StartupInfo.lpReserved      = NULL;                 // lpReserved
        StartupInfo.lpDesktop       = NULL;                 // DeskTop
        StartupInfo.lpTitle         = NULL;                 // Title
        StartupInfo.dwX             = 0;                    // X (position)
        StartupInfo.dwY             = 0;                    // Y (position)
        StartupInfo.dwXSize         = 0;                    // XSize (dimension)
        StartupInfo.dwYSize         = 0;                    // YSize (dimension)
        StartupInfo.dwXCountChars   = 0;                    // XCountChars
        StartupInfo.dwYCountChars   = 0;                    // YCountChars
        StartupInfo.dwFillAttribute = 0;                    // FillAttributes
        StartupInfo.dwFlags         = STARTF_FORCEOFFFEEDBACK;
                                                            // Flags - should be STARTF_TASKNOTCLOSABLE
        StartupInfo.wShowWindow     = SW_HIDE;              // ShowWindow
        StartupInfo.cbReserved2     = 0L;                   // cbReserved
        StartupInfo.lpReserved2     = NULL;                 // lpReserved

        if (!CreateProcessW (
                pImagePath,         // Fully qualified image name
                wszEmpty,           // Command Line
                NULL,               // Process Attributes
                NULL,               // Thread Attributes
                FALSE,              // Inherit Handles
                DETACHED_PROCESS,   // Creation Flags
                NULL,               // Pointer to Environment block
                NULL,               // Pointer to Current Directory
                &StartupInfo,       // Startup Info
                &processInfo))      // ProcessInformation
        {
            status = GetLastError();
            SC_LOG1(ERROR,
                "ScRunAcceptBootPgm: CreateProcess failed " FORMAT_DWORD "\n",
                 status);
        }
    }

    LocalFree(pTempImagePath);
    ScRegCloseKey(AcceptBootKey);
    return;
}


DWORD
ScAcceptTheBoot(
    VOID
    )

/*++

Routine Description:

    This function does the actual work of accepting the current boot as
    the LKG configuration.

    NOTE:  Before the function is called, the ScBootConfigCriticalSection
    is expected to be entered.

Arguments:


Return Value:


--*/
{
    DWORD   status;
    HKEY    systemKey=0;
    HKEY    selectKey=0;
    DWORD   idArray[NUM_IDS];
    DWORD   newId;
    ULONG   privileges[4];

    //
    // This thread gets SE_SECURITY_PRIVILEGE for copying security
    // descriptors and deleting keys.
    //
    privileges[0] = SE_BACKUP_PRIVILEGE;
    privileges[1] = SE_RESTORE_PRIVILEGE;
    privileges[2] = SE_SECURITY_PRIVILEGE;
    privileges[3] = SE_TAKE_OWNERSHIP_PRIVILEGE;

    status = ScGetPrivilege( 4, privileges);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "RNotifyBootConfigStatus: ScGetPrivilege Failed %d\n",
            status);
        return(status);
    }

    //
    // Get the System, Select, and Clone Keys
    //
    status = ScGetTopKeys(&systemKey, &selectKey);

    if (status != NO_ERROR) {
        SC_LOG0(ERROR,"ScAcceptTheBoot: ScGetTopKeys failed\n");
        SetLastError(status);
        //
        // Restore privileges for the current thread.
        //
        (VOID)ScReleasePrivilege();

        return(status);
    }

    //
    // Get the ControlSetIds stored in the \system\select key.
    //

    status = ScGetCtrlSetIds(
                selectKey,
                idArray);

    if (status != NO_ERROR) {

        SC_LOG0(ERROR,"ScAcceptTheBoot: ScGetCtrlSetIds Failed\n");
        goto CleanExit;
    }

    //
    // Don't commit the LKG profile if this is safe mode, unless we actually
    // booted into the LKG profile.
    //
    if (g_SafeBootEnabled) {

        if (idArray[LKG_ID] != idArray[CURRENT_ID]) {

            ScGlobalBootAccepted = TRUE;
            status = NO_ERROR;
            SC_LOG0(TRACE,"ScAcceptTheBoot: Safe mode boot, not committing LKG\n");
            goto CleanExit;
        }
    }

    //
    // Scan for Orphaned Control Sets.
    // This is required prior to calling ScMakeNewCtrlSet (which
    // avoids the orphaned numbers).
    //
    ScGatherOrphanIds(systemKey,&ScGlobalOrphanIds,idArray);

    //
    // Delete the LastKnownGood ControlSet if there are no other
    // references to that control set.
    //

    SC_LOG0(TRACE,"ScAcceptTheBoot: Delete LKG ControlSet if no ref\n");

    if (  (idArray[LKG_ID] != idArray[FAILED_ID])   &&
          (idArray[LKG_ID] != idArray[DEFAULT_ID])  &&
          (idArray[LKG_ID] != idArray[CURRENT_ID])) {

       newId = idArray[LKG_ID];
    }
    else
    {
       status = ScGetNewCtrlSetId(idArray, &newId);
       if(status != NO_ERROR)
       {
          SC_LOG0(ERROR, "ScAcceptTheBoot: Could Not Get New Control Set Id.\n");
          goto CleanExit;
       }
    }

    //
    // Accept the boot and save the boot configuration as LKG.
    //

    status = RtlNtStatusToDosError(NtInitializeRegistry(REG_INIT_BOOT_ACCEPTED_BASE +
                                                        (USHORT)newId));
    if(status != NO_ERROR)
    {
       SC_LOG1(ERROR, "ScAcceptTheBoot: NtInitializeRegistry Failed with %d",
               status);
       goto CleanExit;
    }

    //
    // Make this control set the LastKnownGood Control Set.
    // This is the ControlSet that we last booted from.
    //

    if(newId != idArray[LKG_ID])
    {
        //
        // We only need to do anything if we did not overwrite the old LKG
        // with NtInitializeRegistry.
        //

        idArray[LKG_ID] = newId;

        status = ScRegSetValueExW(
                                  selectKey,                      // hKey
                                  LKG_VALUE_NAME,                 // lpValueName
                                  0,                              // dwValueTitle (OPTIONAL)
                                  REG_DWORD,                      // dwType
                                  (LPBYTE)&(idArray[LKG_ID]),     // lpData
                                  sizeof(DWORD));                 // cbData

        if (status != NO_ERROR) {
           SC_LOG1(ERROR,"ScAcceptTheBoot: ScRegSetValueEx (LkgValue) failed %d\n",
                   status);
           goto CleanExit;
        }
    }

    //
    // Commit this boot by deleting anything we would undo since previous boot.
    //
    status = ScLastGoodFileCleanup();

    if (status != NO_ERROR) {

        SC_LOG1(ERROR,"ScAcceptTheBoot: LastGoodFileCleanup failed %d\n",
                status);
        goto CleanExit;
    }

    ScGlobalBootAccepted = TRUE;

    status = NO_ERROR;
    SC_LOG0(TRACE,"ScAcceptTheBoot: Done\n");

CleanExit:
    if (systemKey != 0) {
        ScRegCloseKey(systemKey);
    }
    if (selectKey != 0) {
        ScRegCloseKey(selectKey);
    }

    //
    // Restore privileges for the current thread.
    //
    (VOID)ScReleasePrivilege();

    return(status);
}


BOOL
SetupInProgress(
    HKEY    SystemKey,
    LPDWORD pdwOOBEMode    OPTIONAL
    )

/*++

Routine Description:

    Checks a registry location to determine if Setup is in Progress.
    \HKEY_LOCAL_MACHINE\System\Setup
         value=DWORD SystemSetupInProgress
    The value is cached so that the registry is examined only on the
    first call to this function.

Arguments:

    SystemKey - open handle to HKEY_LOCAL_MACHINE\System.
        This is ignored in all except the first call to this function.

Return Value:

    TRUE - If Setup is in progress

    FALSE - If Setup isn't in progress

--*/
{
    static  DWORD TheValue=0xffffffff; // 0=false, 1=true,
                                       // 0xffffffff=uninitialized
    static  DWORD IsOOBE;

    DWORD   status = NO_ERROR;
    DWORD   BytesRequired = sizeof(TheValue);
    HKEY    KeyHandle;

    if (TheValue == 0xffffffff)
    {
        //
        // First call
        //

        SC_ASSERT(SystemKey != NULL);

        TheValue = 0;
        IsOOBE = 0;

        status = ScRegOpenKeyExW(
                    SystemKey,
                    SETUP_PROG_KEY,
                    0L,
                    KEY_READ,
                    &KeyHandle);

        if (status == NO_ERROR)
        {
            //
            // There are two registry values that may be set here:
            //
            //    1.  OobeInProgress -- if it exists and is non-zero,
            //            this is an OOBE boot.
            //
            //    2.  SystemSetupInProgress -- if it exists and is
            //            non-zero AND it's not an OOBE boot, it's
            //            GUI-mode setup.  If OOBE's in progress,
            //            don't even bother checking this one (it may
            //            or may not be set depending on whether we're
            //            in retail OOBE or mini-setup OOBE) and return
            //            FALSE from SetupInProgress (along with the
            //            appropriate OOBE value).
            //

            status = ScRegQueryValueExW(
                        KeyHandle,
                        REGSTR_VALUE_OOBEINPROGRESS,
                        NULL,
                        NULL,
                        (LPBYTE) &IsOOBE,
                        &BytesRequired);

            if (IsOOBE != 0)
            {
                SC_ASSERT(status == NO_ERROR);
            }

            if (IsOOBE == 0)
            {
                status = ScRegQueryValueExW(
                            KeyHandle,
                            SETUP_PROG_VALUE_NAME,
                            NULL,
                            NULL,
                            (LPBYTE) &TheValue,
                            &BytesRequired);

                if (TheValue != 0)
                {
                    SC_ASSERT(status == NO_ERROR);
                    TheValue = 1;
                }
            }

            ScRegCloseKey(KeyHandle);
        }
    }

    SC_LOG(TRACE,"SetupInProgress = %d (0=FALSE,else TRUE)\n", TheValue);

    if (pdwOOBEMode)
    {
        SC_LOG(TRACE, "SetupInProgress:  OOBE mode = %d (0 = none, 1 = OOBE, 2 = SP install)\n", IsOOBE);
        *pdwOOBEMode = IsOOBE;
    }

    return TheValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\cfgapi.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    CfgAPI.cxx

Abstract:

    This file contains the Service Controller's Config API.
        RChangeServiceConfigW
        RCreateServiceW
        RDeleteService
        RQueryServiceConfigW
        ScCanonDriverImagePath


Author:

    John Rogers (JohnRo) 10-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    26-Mar-1992 danl
        Created the stubbed out version for RPC.
    22-Apr-1992 JohnRo
        Use SC_LOG0(), FORMAT_ equates, etc
        Wrote real code for these APIs.
        Split lock APIs into server/lockapi.c.
        Added some assertion checks here and there.  Added handle checks too.
    28-Apr-1992 JohnRo
        Undo all group operations (ifdef USE_GROUPS).
    28-May-1992 JohnRo
        Put back load order group in APIs.
        Avoid compiler warnings.
    02-Jun-1992 JohnRo
        RAID 10709: QueryServiceConfig() has bad length check.
    08-Aug-1992 Danl
        RDeleteService: Add call to ScMarkForDelete so the registry entry
        is marked for deletion.
    25-Aug-1992 Danl
        RQueryServiceConfig: Fix problem where it failed if it couldn't
        read the StartName from the registry.  (This should be optional).
    21-Jan-1994 Danl
        RChangeServiceConfigW: Fixed BUG where a unicode DisplayName was
        being copied into a buffer whose size assumed ansi characters.
        Also changed so that displayname is not allocated unless it is
        different from the ServiceName.
    24-Mar-1994 Danl
        RQueryServiceConfigW:  Add worse case number of bytes (3) for RPC
        alignment.  I removed the exact calculation because it assumed
        that strings went into the buffer in a particular order.  Since RPC
        picks the order for unmarshalling into the users buffer, the order
        may be random.
    06-Jun-1994 Danl
        We were allocating memory for the display name in the service record only
        when it was the same.  It should have been doing this only when different.
        The behaviour was such that if you changed the display name to something
        other than the KeyName, the new name was placed in the registry, but not
        in the service record.  So GetKeyName on the new name would fail.
    20-Jun-1994 Danl
        Added SERVICE_WIN32_INTERACTIVE support to service type.
    21-Jan-1995     AnirudhS
        RCreateServiceW: This was calling ScAccessValidate to check if the caller
        had the desired access to the object on creation of a new service object.
        Fixed this to just grant the desired access instead.
    26-Feb-1996     AnirudhS
        RChangeServiceConfigW: Would generate a tag only if the group name
        changed.  Fixed it to always generate and return a tag if one is
        requested, just like RCreateServiceW.
    09-Dec-1996     AnirudhS
        Added SC_LOG printouts to help diagnose the annoying
        ERROR_INVALID_PARAMETER and ERROR_INVALID_SERVICE_ACCOUNT return codes.
    22-Oct-1997     JSchwart  (after AnirudhS in _CAIRO_ 12-Apr-1995)
        RChangeServiceConfigW and RCreateServiceW: Allow services that run under
        accounts other than LocalSystem to share processes too.

--*/


//
// INCLUDES
//

#include "precomp.hxx"
#include <scconfig.h>   // ScGetImageFileName().
#include <sclib.h>      // ScImagePathsMatch(), ScIsValidImagePath(), etc.
#include <scsec.h>      // ScAccessValidate().
#include <valid.h>      // SERVICE_TYPE_INVALID(), etc.
#include <sccrypt.h>    // ScDecryptPassword
#include "account.h"    // ScValidateAndSaveAccount
#include <strarray.h>   // ScWStrArraySize
#include <align.h>      // ROUND_UP_COUNT
#include "smartp.h"     // CHeapPtr
#include "resource.h"   // IDS_SC_CONFIG_* constants
#include "scaudit.h"    // ScGenerateServiceInstallAudit

#define SC_NT_SYSTEM_ROOT         L"\\SystemRoot\\"
#define SC_NT_SYSTEM_ROOT_LENGTH  (sizeof(SC_NT_SYSTEM_ROOT) / sizeof(WCHAR) - 1)

#define SC_DOS_SYSTEM_ROOT        L"%SystemRoot%\\"
#define SC_DOS_SYSTEM_ROOT_LENGTH (sizeof(SC_DOS_SYSTEM_ROOT) / sizeof(WCHAR) - 1)

#define ARC_PREFIX                L"\\Arcname"
#define ARC_PREFIX_LENGTH         (sizeof(ARC_PREFIX) / sizeof(WCHAR) - 1)


#define SERVICE_TYPE_CHANGED            0x00000001
#define START_TYPE_CHANGED              0x00000002
#define ERROR_CONTROL_CHANGED           0x00000004
#define BINARY_PATH_CHANGED             0x00000008
#define REG_GROUP_CHANGED               0x00000010
#define TAG_ID_CHANGED                  0x00000020
#define DEPENDENCIES_CHANGED_SR         0x00000040    // Not in NT4
#define DEPENDENCIES_CHANGED_REG        0x00000080    // Not in NT4
#define START_NAME_CHANGED              0x00000100
#define SR_GROUP_CHANGED                0x00000200
#define DISPLAY_NAME_CHANGED_SR         0x00000400
#define DISPLAY_NAME_CHANGED_REG        0x00000800

DWORD
ScCanonDriverImagePath(
    IN DWORD DriverStartType,
    IN LPWSTR DriverPath,
    OUT LPWSTR *CanonDriverPath
    );

DWORD
ScConvertToBootPathName(
    LPWSTR FullQualPathName,
    LPWSTR * RelativePathName
    );

DWORD
ScValidateDisplayName(
    LPWSTR              lpDisplayName,
    LPSERVICE_RECORD    lpServiceRecord
    );

BOOLEAN
ScIsArcName(
    LPWSTR              PathName
    );


DWORD
RChangeServiceConfigW(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwServiceType,
    IN  DWORD           dwStartType,
    IN  DWORD           dwErrorControl,
    IN  LPWSTR          lpBinaryPathName,
    IN  LPWSTR          lpLoadOrderGroup,
    OUT LPDWORD         lpdwTagId,
    IN  LPBYTE          lpDependencies,
    IN  DWORD           dwDependSize,
    IN  LPWSTR          lpServiceStartName,
    IN  LPBYTE          EncryptedPassword,
    IN  DWORD           PasswordSize,
    IN  LPWSTR          lpDisplayName
    )

/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    DWORD               ApiStatus;
    DWORD               backoutStatus;
    DWORD               newServiceType;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hService;
    HKEY                ServiceNameKey      = NULL;
    LPSERVICE_RECORD    serviceRecord;
    LPWSTR              CanonBinaryPath     = NULL;
    LPWSTR              NewBinaryPath       = NULL;

    LPWSTR              OldAccountName      = NULL;
    LPWSTR              CanonAccountName    = NULL;
    DWORD               CurrentServiceType  = 0;
    DWORD               CurrentStartType    = 0;
    DWORD               CurrentErrorControl = 0;
    LPWSTR              CurrentImageName    = NULL;
    LPWSTR              CurrentDependencies = NULL;
    LPWSTR              CurrentDisplayName  = NULL;
    LPWSTR              CurrentGroup        = NULL;
    LPWSTR              CurrentStartName    = NULL;
    DWORD               CurrentTag          = 0;
    DWORD               Tag                 = 0;
    DWORD               Progress            = 0;
    LPWSTR              Password            = NULL;
    LPWSTR              OldSRDisplayName    = NULL;
    LPWSTR              NewDisplayName      = NULL;


    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if ( !ScIsValidServiceHandle( hService ) ) {
        return(ERROR_INVALID_HANDLE);
    }

    SC_LOG(CONFIG_API, "RChangeServiceConfigW(%ws)\n",
           serviceHandleStruct->Type.ScServiceObject.ServiceRecord->ServiceName);

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              SERVICE_CHANGE_CONFIG
              )) {

        return(ERROR_ACCESS_DENIED);
    }

    if (lpdwTagId != NULL) {

        //
        // Asking for new tag value but didn't specify group
        //
        if ((lpLoadOrderGroup == NULL) || (*lpLoadOrderGroup == 0)) {

            SC_LOG0(ERROR, "Asking for new tag value but didn't specify group\n");
            return(ERROR_INVALID_PARAMETER);
        }
    }

    //
    // Lock database, as we want to add stuff without other threads tripping
    // on our feet.  NOTE:  since we may need the group list lock, we
    // must get that lock first.
    //
    CGroupListExclusiveLock GLock;
    CServiceListSharedLock LLock;
    CServiceRecordExclusiveLock RLock;

    //
    // Find the service record for this handle.
    //
    serviceRecord =
        serviceHandleStruct->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT( serviceRecord != NULL );
    SC_ASSERT( serviceRecord->Signature == SERVICE_SIGNATURE );

    //
    // Disallow this call if record is marked for delete.
    //
    if (DELETE_FLAG_IS_SET(serviceRecord)) {
        return(ERROR_SERVICE_MARKED_FOR_DELETE);
    }

    //
    // If there is a DisplayName specified, check to see if it already
    // exists.
    //
    ApiStatus = ScValidateDisplayName(lpDisplayName,serviceRecord);
    if (ApiStatus != NO_ERROR) {
        SC_LOG0(ERROR, "DisplayName invalid\n");
        return(ApiStatus);
    }

    //
    // Figure-out what the resulting service type will be.
    // (Some other stuff below depends on this.)
    //
    if (dwServiceType != SERVICE_NO_CHANGE) {
        if ( SERVICE_TYPE_INVALID( dwServiceType ) ) {
            SC_LOG0(ERROR, "ServiceType invalid\n");
            return(ERROR_INVALID_PARAMETER);
        }
        newServiceType = dwServiceType;
    }
    else {
        newServiceType = serviceRecord->ServiceStatus.dwServiceType;
    }
    SC_ASSERT( newServiceType != SERVICE_NO_CHANGE );

    //
    // Validate other parameters.
    //
    ApiStatus = ScCheckServiceConfigParms(
                    TRUE,                    // This is a change operation
                    serviceRecord->ServiceName,
                    serviceRecord->ServiceStatus.dwServiceType, // new actual type
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    lpBinaryPathName,
                    lpLoadOrderGroup,
                    (LPWSTR)lpDependencies,
                    dwDependSize);

    if (ApiStatus != NO_ERROR) {
        return(ApiStatus);
    }

    //-----------------------------
    //
    // Begin Updating the Registry
    //
    //-----------------------------
    ApiStatus = ScOpenServiceConfigKey(
            serviceRecord->ServiceName,
            KEY_WRITE | KEY_READ,
            FALSE,              // don't create if missing
            & ServiceNameKey );
    if (ApiStatus != NO_ERROR) {
        return(ApiStatus);
    }


    //--------------------------------------
    // (from here on we need to use Cleanup)
    //
    // Service Type
    //--------------------------------------
    if (dwServiceType != SERVICE_NO_CHANGE) {

        //
        // If this service is supposed to be interactive, make sure
        // the service account is LocalSystem.  Otherwise, it should
        // fail with ERROR_INVALID_PARAMETER.
        //
        if (dwServiceType & SERVICE_INTERACTIVE_PROCESS) {
            if (ARGUMENT_PRESENT(lpServiceStartName)) {
                ApiStatus = ScCanonAccountName(lpServiceStartName, &CanonAccountName);
                if (ApiStatus != NO_ERROR) {
                    goto Cleanup;
                }
                if (_wcsicmp(CanonAccountName,SC_LOCAL_SYSTEM_USER_NAME) != 0) {
                    SC_LOG0(ERROR, "Service must run in LocalSystem account to be interactive\n");
                    ApiStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
            else {
                //
                // Get old account name
                //
                ApiStatus = ScReadStartName(ServiceNameKey, &OldAccountName);
                if (ApiStatus != NO_ERROR) {
                    goto Cleanup;
                }
                if (_wcsicmp(OldAccountName, SC_LOCAL_SYSTEM_USER_NAME) != 0) {
                    SC_LOG0(ERROR, "Service must run in LocalSystem account to be interactive\n");
                    ApiStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
        }

        ApiStatus = ScReadServiceType( ServiceNameKey, &CurrentServiceType);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        ApiStatus = ScWriteServiceType( ServiceNameKey, dwServiceType);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= SERVICE_TYPE_CHANGED;

    }
    else {
        //
        // ServiceType is not being changed.
        //
        CurrentServiceType = serviceRecord->ServiceStatus.dwServiceType;

        //
        // if the current service type contains the interactive bit, and the
        // account type is being changed to something other than LocalSystem,
        // then we should fail the call with ERROR_INVALID_PARAMETER.
        //
        if (ARGUMENT_PRESENT(lpServiceStartName)) {
            if ((CurrentServiceType & SERVICE_INTERACTIVE_PROCESS) &&
                (_wcsicmp(lpServiceStartName,SC_LOCAL_SYSTEM_USER_NAME) != 0)) {
                SC_LOG0(ERROR, "Service must run in LocalSystem account to be interactive\n");
                ApiStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
    }

    //---------------------
    // Start Type
    //---------------------
    if (dwStartType != SERVICE_NO_CHANGE) {

        ApiStatus = ScReadStartType( ServiceNameKey, &CurrentStartType);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        ApiStatus = ScWriteStartType( ServiceNameKey, dwStartType);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= START_TYPE_CHANGED;

        //
        // If they're supplying a new binary name, making it correct for the
        // Start type will happen automatically.  If they're keeping the
        // same imagepath, we need to make sure it of the correct format,
        // and if not, fix it.
        //

        if (lpBinaryPathName == NULL) {
            //
            // If the start type is changing from SERVICE_BOOT_START we need
            // to turn the start path into a fully qualified NT name (BOOT
            // drivers have paths relative to systemroot)
            //
            if (CurrentStartType == SERVICE_BOOT_START &&
                dwStartType != SERVICE_BOOT_START) {

                //
                // Note:  The following call allocates storage for the
                //        CurrentImageName
                //

                ApiStatus = ScGetImageFileName (
                                serviceRecord->ServiceName,
                                &CurrentImageName );

                if (ApiStatus != NO_ERROR && ApiStatus != ERROR_PATH_NOT_FOUND) {
                    SC_LOG(ERROR,"RChangeServiceConfigW: ScGetImageFileName failed %d\n",
                        ApiStatus);
                    goto Cleanup;
                }

                //
                // If there's an existing path, we need to fix
                // If it is an ARC name, leave it alone
                //
                //

                if (ApiStatus != ERROR_PATH_NOT_FOUND &&
                    !ScIsArcName(CurrentImageName)) {

                    //
                    // Prepend \systemroot\ to the beginning of the path
                    //

                    NewBinaryPath = (LPWSTR)LocalAlloc(LMEM_ZEROINIT,
                        (UINT) ((wcslen(CurrentImageName) +
                        SC_NT_SYSTEM_ROOT_LENGTH + 1) * sizeof(WCHAR)));

                    if (!NewBinaryPath) {
                        SC_LOG(ERROR,"RChangeServiceConfigW: LocalAlloc failed %d\n",
                            GetLastError());
                        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }

                    wcscpy(NewBinaryPath, SC_NT_SYSTEM_ROOT);
                    wcscat(NewBinaryPath, CurrentImageName);
                    lpBinaryPathName = NewBinaryPath;

                }

                ApiStatus = NO_ERROR;

                LocalFree(CurrentImageName);
            }

            //
            // If the start type is changing to SERVICE_BOOT_START, we need
            // to make sure the ImagePath gets canonicalized
            //

            else if (dwStartType == SERVICE_BOOT_START && CurrentStartType != SERVICE_BOOT_START)
            {
                //
                // Note:  The following call allocates storage for the
                //        CurrentImageName
                //

                ApiStatus = ScGetImageFileName (
                                serviceRecord->ServiceName,
                                &CurrentImageName );

                if (ApiStatus != NO_ERROR && ApiStatus != ERROR_PATH_NOT_FOUND) {
                    SC_LOG(ERROR,"RChangeServiceConfigW: ScGetImageFileName failed %d\n",
                        ApiStatus);
                    goto Cleanup;
                }

                //
                // If there's an existing path and it's not an ARC name, we
                // need to fix
                //

                if (ApiStatus != ERROR_PATH_NOT_FOUND &&
                    !ScIsArcName(CurrentImageName)) {

                    //
                    // Now make sure it's in the proper canonical form for a
                    // boot driver.
                    //

                    ApiStatus = ScConvertToBootPathName(
                                    CurrentImageName,
                                    &NewBinaryPath
                                    );
                    if (ApiStatus != NO_ERROR) {
                        SC_LOG(ERROR, "ScConvertToBootPathName error %lu\n", ApiStatus);
                        goto Cleanup;
                    }

                    lpBinaryPathName = NewBinaryPath;

                    LocalFree(CurrentImageName);
                }

                ApiStatus = NO_ERROR;
            }
        }
    }

    //---------------------
    // ErrorControl
    //---------------------
    if (dwErrorControl != SERVICE_NO_CHANGE) {

        ApiStatus = ScReadErrorControl( ServiceNameKey, &CurrentErrorControl);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        ApiStatus = ScWriteErrorControl( ServiceNameKey, dwErrorControl );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= ERROR_CONTROL_CHANGED;
    }

    //---------------------
    // DisplayName
    //---------------------
    if (lpDisplayName != NULL) {

        //
        // UPDATE SERVICE RECORD
        //
        // We always update the display name in the service record - even
        // if we delay in updating the rest of the config.  If we don't
        // do this, then we leave an opening where two services can end
        // up with the same display name.
        // The following scenario can take place if we don't update
        // the service record until the service is stopped:
        //
        //  Until serviceA is stopped, the new display name only exists
        //  in the registry.  In the meantime, another service (serviceB)
        //  can be given the same name.  Name validation only looks in
        //  the service records for duplicate names.  Then when serviceA is
        //  stopped, it takes on the new name which is the same as the
        //  display name for serviceB.
        //

        OldSRDisplayName = serviceRecord->DisplayName;

        //
        // If the display name is the same as the service name,
        // then set the display name pointer to point to
        // the service name.
        //
        if ((*lpDisplayName != L'\0') &&
            (_wcsicmp(lpDisplayName,serviceRecord->ServiceName) != 0)) {

            NewDisplayName = (LPWSTR)LocalAlloc(
                                LMEM_FIXED,
                                WCSSIZE(lpDisplayName));

            if (NewDisplayName == NULL) {
                SC_LOG0(ERROR,"RChangeServiceConfigW: LocalAlloc failed\n");
                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                serviceRecord->DisplayName = OldSRDisplayName;
                goto Cleanup;
            }
            //
            // Copy the display name into new buffer, and free up memory
            // for old name if necessary.
            //
            wcscpy(NewDisplayName, lpDisplayName);
        }
        else {
            NewDisplayName = serviceRecord->ServiceName;
        }

        serviceRecord->DisplayName = NewDisplayName;

        Progress |= DISPLAY_NAME_CHANGED_SR;

        //
        // UPDATE REGISTRY
        //
        ApiStatus = ScReadDisplayName(ServiceNameKey, &CurrentDisplayName);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        ApiStatus = ScWriteDisplayName( ServiceNameKey, lpDisplayName);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        Progress |= DISPLAY_NAME_CHANGED_REG;
    }

    //---------------------
    // BinaryPathName
    //---------------------
    if (lpBinaryPathName != NULL) {

        //
        // Note:  The following call allocates storage for the CurrentImageName
        //
        ApiStatus = ScGetImageFileName (
                        serviceRecord->ServiceName,
                        &CurrentImageName );

        if (ApiStatus != NO_ERROR && ApiStatus != ERROR_PATH_NOT_FOUND) {
            SC_LOG(ERROR,"RChangeServiceConfigW: ScGetImageFileName failed %d\n",
                ApiStatus);
            goto Cleanup;
        }

        if (CurrentServiceType & SERVICE_DRIVER) {
            //
            // Driver service
            //
            ApiStatus = ScCanonDriverImagePath(
                            dwStartType,
                            lpBinaryPathName,
                            &CanonBinaryPath
                            );
            if (ApiStatus != NO_ERROR) {
                SC_LOG(ERROR, "ScCanonDriverImagePath error %lu\n", ApiStatus);
                goto Cleanup;
            }

            if (CurrentImageName == NULL ||
                !ScImagePathsMatch(CanonBinaryPath, CurrentImageName)) {

                ApiStatus = ScWriteImageFileName(ServiceNameKey, CanonBinaryPath);
                if (ApiStatus != NO_ERROR) {
                    SC_LOG(ERROR,"RChangeServiceConfigW: ScWriteImageFileName "
                        "failed %d\n",ApiStatus);
                    goto Cleanup;
                }
                Progress |= BINARY_PATH_CHANGED;
            }
        }
        else {
            //
            // Win32 service
            //
            if (CurrentImageName == NULL ||
                !ScImagePathsMatch(lpBinaryPathName, CurrentImageName)) {

                ApiStatus = ScWriteImageFileName(ServiceNameKey, lpBinaryPathName);
                if (ApiStatus != NO_ERROR) {
                    SC_LOG(ERROR,"RChangeServiceConfigW: ScWriteImageFileName "
                        "failed %d\n",ApiStatus);
                    goto Cleanup;
                }
                Progress |= BINARY_PATH_CHANGED;
            }
        }
    }


    //---------------------
    // Dependencies
    //---------------------
    if (lpDependencies != NULL) {

        //
        // Read the existing dependencies from registry so
        // that we can restore it in case of failure later.
        // We don't check for error here.  We assume a failure means
        // that there are no current dependencies.
        //
        ScReadDependencies(
            ServiceNameKey,
            &CurrentDependencies,
            serviceRecord->ServiceName);

        //
        // Dynamically update the dependencies and check to make sure
        // updating was error-free
        //

        ApiStatus = ScUpdateServiceRecordConfig(
                        serviceRecord,
                        SERVICE_NO_CHANGE,
                        SERVICE_NO_CHANGE,
                        SERVICE_NO_CHANGE,
                        NULL,
                        (LPBYTE)lpDependencies);

        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        Progress |= DEPENDENCIES_CHANGED_SR;

        //
        // Update the dependencies in the registry
        //

        ApiStatus = ScWriteDependencies(
                        ServiceNameKey,
                        (LPWSTR) lpDependencies,
                        dwDependSize
                        );

        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= DEPENDENCIES_CHANGED_REG;
    }


    //---------------------
    // Load order group
    //---------------------

    if (lpLoadOrderGroup != NULL) {

        //
        // Save existing group membership info so that we can restore
        // it in case of error.
        // Read the current LoadOrderGroup value from Registry
        //
        if (ScAllocateAndReadConfigValue(
                ServiceNameKey,
                GROUP_VALUENAME_W,
                &CurrentGroup,
                NULL
                ) != NO_ERROR) {

            CurrentGroup = NULL;
        }

        //
        // Read current Tag Id to save in case of error.
        //

        CurrentTag = serviceRecord->Tag;

        if ((CurrentGroup != NULL) &&
            (_wcsicmp(lpLoadOrderGroup, CurrentGroup) == 0)) {
            //
            // The new load order group is the same as what is currently
            // in the registry.  This means that no group change is occuring.
            //
            if (lpdwTagId != NULL) {
                //
                // The caller requested a tag.  If there isn't one, generate
                // one and write it to the registry.
                //
                Tag = CurrentTag;

                if (CurrentTag == 0) {

                    ScGetUniqueTag(
                        lpLoadOrderGroup,
                        &Tag
                        );

                    ApiStatus = ScWriteTag(ServiceNameKey, Tag);

                    if (ApiStatus != NO_ERROR) {
                        goto Cleanup;
                    }

                    //
                    // Update the service record with the tag id.
                    //
                    serviceRecord->Tag = Tag;

                    Progress |= TAG_ID_CHANGED;
                }
            }
        }
        else {
            //
            // The new load order group is different from what is currently
            // stored in the registry.  Save the new one in the registry.
            //

            ApiStatus = ScWriteGroupForThisService(
                            ServiceNameKey,
                            lpLoadOrderGroup);

            if (ApiStatus != NO_ERROR) {
                goto Cleanup;
            }
            //
            // Also save it in the service controller database.
            //

            Progress |= REG_GROUP_CHANGED;

            ScDeleteRegistryGroupPointer(serviceRecord);

            ApiStatus = ScCreateRegistryGroupPointer(
                            serviceRecord,
                            lpLoadOrderGroup);

            if (ApiStatus != NO_ERROR) {
                goto Cleanup;
            }

            Progress |= SR_GROUP_CHANGED;

            //
            // Check to see if the LoadOrderGroup is being cleared
            // (0 length string) or set to a new string.  If there
            // is a new string, we need to get a new unique Tag for it.
            //
            if (*lpLoadOrderGroup != 0) {

                //
                // We have a new LoadOrderGroup information.  Get a unique
                // Tag value.
                //
                if (lpdwTagId != NULL) {
                    ScGetUniqueTag(
                        lpLoadOrderGroup,
                        &Tag
                        );
                }
            }

            //
            // Write tag entry to registry if not 0.  If 0, we delete the tag
            // value from the registry.
            //

            if (Tag == 0) {
                ScDeleteTag(ServiceNameKey);
            }
            else {
                ApiStatus = ScWriteTag(ServiceNameKey, Tag);
            }

            if (ApiStatus != NO_ERROR) {
                goto Cleanup;
            }

            //
            // Update the service record with the tag id.
            //
            serviceRecord->Tag = Tag;

            Progress |= TAG_ID_CHANGED;
        }
    }


    //---------------------
    // ServiceStartName
    //---------------------
    //
    // If the service type is a DRIVER then we must interpret the
    // lpServiceStartName as an NT driver object name and add it to
    // the registry.  If the type is WIN32, then lpServiceStartName
    // must be an account name.  This will be handled by
    // ScUpdateServiceRecordConfig.
    //
    if ((newServiceType & SERVICE_DRIVER) &&
             (ARGUMENT_PRESENT(lpServiceStartName))) {

        //
        // Read StartName to save in case of error.
        //
        ApiStatus = ScReadStartName( ServiceNameKey, &CurrentStartName);
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        //
        // Write the driver objectname to the registry.
        //
        ApiStatus = ScWriteStartName(
                        ServiceNameKey,
                        lpServiceStartName
                        );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        Progress |= START_NAME_CHANGED;
    }

    //==============================
    // UPDATE Account Information
    //==============================

    if ((newServiceType & SERVICE_WIN32) &&
        (ARGUMENT_PRESENT(lpServiceStartName) ||
         ARGUMENT_PRESENT(EncryptedPassword))) {

        //
        // Changing the account.
        //

        //
        // Get old account name.
        // It may have already been retreived when we were handling
        // ServiceType (above).
        //
        if (OldAccountName == NULL) {
            ApiStatus = ScReadStartName(ServiceNameKey, &OldAccountName);
            if (ApiStatus != NO_ERROR) {
                goto Cleanup;
            }
        }

        if (! ARGUMENT_PRESENT(lpServiceStartName)) {

            //
            // Account name is specified as the one saved in the registry
            //
            CanonAccountName = OldAccountName;
        }
        else {
            //
            // NOTE:  We may have already obtained a CanonAccountName when we
            // checked the INTERACTIVE service type.
            //
            if (CanonAccountName == NULL) {
                ApiStatus = ScCanonAccountName(lpServiceStartName, &CanonAccountName);
                if (ApiStatus != NO_ERROR) {
                    goto Cleanup;
                }
            }
        }

        //
        // Decrypt the password.  This function returns a pointer to
        // the decrypted password that must be freed later.
        //
        if (ARGUMENT_PRESENT(EncryptedPassword)) {
            ApiStatus = ScDecryptPassword(
                            hService,
                            EncryptedPassword,
                            PasswordSize,
                            &Password
                            );
            if (ApiStatus != NO_ERROR) {
                SC_LOG0(ERROR, "RChangeServiceConfigW: ScDecryptPassword failed\n");
                goto Cleanup;
            }
        }

        //
        // NOTE:  The following needs to be the last operation in the
        //  function.  This is because there is no way to back out of this
        //  if something after it fails.
        //

        //
        // Validate and update internal data structures for the new
        // account, as well as write the new AccountName back to the
        // registry if appropriate.
        //

        ApiStatus = ScValidateAndChangeAccount(
                        serviceRecord,
                        ServiceNameKey,
                        OldAccountName,
                        CanonAccountName,
                        Password
                        );

        if (ApiStatus != NO_ERROR) {
            SC_LOG(ERROR, "ScValidateAndChangeAccount error %lu\n", ApiStatus);
            goto Cleanup;
        }
    }

    //
    // Update the service record with the new configuration if the
    // service is stopped.  If it is running, then set a flag to
    // remind us to do it later.  We don't update the dependencies
    // here since it is done dynamically in RChangeServiceConfigW
    //
    if (serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

        //
        // Dependencies are NULL since they're updated dynamically
        //
        ApiStatus = ScUpdateServiceRecordConfig(
                        serviceRecord,
                        dwServiceType,
                        dwStartType,
                        dwErrorControl,
                        lpLoadOrderGroup,
                        NULL);


        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }
    else {
        //
        // The service is running.  Mark is so that we update the status
        // when it stops.
        //
        SET_UPDATE_FLAG(serviceRecord);
    }

Cleanup:

    if (ApiStatus == NO_ERROR)
    {
        if (lpdwTagId != NULL)
        {
            *lpdwTagId = Tag;
        }
        if (Progress & DISPLAY_NAME_CHANGED_SR)
        {
            if (OldSRDisplayName != serviceRecord->ServiceName)
            {
                LocalFree(OldSRDisplayName);
            }
        }
    }
    else
    {
        //
        // An error occured.  Backout any changes that may have occured.
        //
        if (Progress & SERVICE_TYPE_CHANGED) {
            backoutStatus = ScWriteServiceType( ServiceNameKey, CurrentServiceType);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_SERVICE_TYPE);
            }
        }
        if (Progress & START_TYPE_CHANGED) {
            backoutStatus = ScWriteStartType( ServiceNameKey, CurrentStartType);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_START_TYPE);
            }
        }
        if (Progress & ERROR_CONTROL_CHANGED) {
            backoutStatus = ScWriteErrorControl( ServiceNameKey, CurrentErrorControl);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_ERROR_CONTROL);
            }
        }
        if (Progress & DISPLAY_NAME_CHANGED_REG) {
            if (CurrentDisplayName == NULL) {
                backoutStatus = ScWriteDisplayName(
                                    ServiceNameKey,
                                    L"");
            }
            else {
                backoutStatus = ScWriteDisplayName(
                                    ServiceNameKey,
                                    CurrentDisplayName);
            }

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_DISPLAY_NAME);
            }
        }
        if (Progress & DISPLAY_NAME_CHANGED_SR) {
            if (serviceRecord->DisplayName != serviceRecord->ServiceName) {
                LocalFree(serviceRecord->DisplayName);
                serviceRecord->DisplayName = OldSRDisplayName;
            }
        }
        if (Progress & BINARY_PATH_CHANGED) {
            if (CurrentImageName == NULL) {
                ScRegDeleteValue(ServiceNameKey, IMAGE_VALUENAME_W);
            }
            else {
                backoutStatus = ScWriteImageFileName( ServiceNameKey, CurrentImageName);

                if (backoutStatus != NO_ERROR)
                {
                    ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                      OldSRDisplayName ? OldSRDisplayName :
                                                         serviceRecord->DisplayName,
                                      IDS_SC_CONFIG_BINARY_PATH);
                }
            }
        }
        if (Progress & DEPENDENCIES_CHANGED_REG) {

            //
            // ScWriteDependencies doesn't like NULL dependencies
            //
            LPWSTR lpTempDepend = (CurrentDependencies ? CurrentDependencies : L"\0");

            backoutStatus = ScWriteDependencies(
                            ServiceNameKey,
                            lpTempDepend,
                            ScWStrArraySize(lpTempDepend));

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_DEPENDENCIES);
            }
        }
        if (Progress & DEPENDENCIES_CHANGED_SR) {
           backoutStatus = ScUpdateServiceRecordConfig(
                              serviceRecord,
                              SERVICE_NO_CHANGE,
                              SERVICE_NO_CHANGE,
                              SERVICE_NO_CHANGE,
                              NULL,
                              (LPBYTE)CurrentDependencies);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_DEPENDENCIES);
            }
        }
        if (Progress & REG_GROUP_CHANGED) {
            if (CurrentGroup != NULL) {
                backoutStatus = ScWriteGroupForThisService(
                                ServiceNameKey, CurrentGroup);

                if (backoutStatus != NO_ERROR)
                {
                    ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                      OldSRDisplayName ? OldSRDisplayName :
                                                         serviceRecord->DisplayName,
                                      IDS_SC_CONFIG_GROUP);
                }
            }
            else {
                ScRegDeleteValue(ServiceNameKey, GROUP_VALUENAME_W);
            }
        }
        if (Progress & SR_GROUP_CHANGED) {
            ScDeleteRegistryGroupPointer(serviceRecord);
            backoutStatus = ScCreateRegistryGroupPointer( serviceRecord, CurrentGroup);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_GROUP);
            }
        }
        if (Progress & TAG_ID_CHANGED)
        {
            if (CurrentTag == 0)
            {
                ScDeleteTag(ServiceNameKey);
            }
            else
            {
                backoutStatus = ScWriteTag( ServiceNameKey, CurrentTag);

                if (backoutStatus != NO_ERROR)
                {
                    ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                      OldSRDisplayName ? OldSRDisplayName :
                                                         serviceRecord->DisplayName,
                                      IDS_SC_CONFIG_TAG);
                }
            }
            serviceRecord->Tag = CurrentTag;
        }

        if (Progress & START_NAME_CHANGED)
        {
            backoutStatus = ScWriteStartName( ServiceNameKey, CurrentStartName);

            if (backoutStatus != NO_ERROR)
            {
                ScLogControlEvent(NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
                                  OldSRDisplayName ? OldSRDisplayName :
                                                     serviceRecord->DisplayName,
                                  IDS_SC_CONFIG_ACCOUNT);
            }
        }
    }

    if (CanonAccountName == OldAccountName) {
        LocalFree(OldAccountName);
    }
    else {
        LocalFree(OldAccountName);
        LocalFree(CanonAccountName);
    }

    //
    // Free memory resources
    //
    LocalFree(CurrentDisplayName);
    LocalFree(CurrentImageName);
    LocalFree(CurrentDependencies);
    LocalFree(CurrentGroup);
    LocalFree(CurrentStartName);
    LocalFree(CanonBinaryPath);
    LocalFree(NewBinaryPath);
    LocalFree(Password);

    if (ServiceNameKey != NULL) {
        ScRegFlushKey(ServiceNameKey);
        ScRegCloseKey(ServiceNameKey);
    }

    SC_LOG1(CONFIG_API, "RChangeServiceConfigW returning status " FORMAT_DWORD ".\n", ApiStatus);

    return ApiStatus;
}


DWORD
RCreateServiceW(
    IN      SC_RPC_HANDLE   hSCManager,
    IN      LPWSTR          lpServiceName,
    IN      LPWSTR          lpDisplayName,
    IN      DWORD           dwDesiredAccess,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwStartType,
    IN      DWORD           dwErrorControl,
    IN      LPWSTR          lpBinaryPathName,
    IN      LPWSTR          lpLoadOrderGroup,
    OUT     LPDWORD         lpdwTagId OPTIONAL,
    IN      LPBYTE          lpDependencies OPTIONAL,
    IN      DWORD           dwDependSize,
    IN      LPWSTR          lpServiceStartName OPTIONAL,
    IN      LPBYTE          EncryptedPassword OPTIONAL,
    IN      DWORD           PasswordSize,
    IN OUT  LPSC_RPC_HANDLE lpServiceHandle
    )


/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD               ApiStatus;
    LPSERVICE_RECORD    newServiceRecord = NULL;
    LPSERVICE_RECORD    oldServiceRecord;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = NULL;
    HKEY                serviceKey = NULL;
    CHeapPtr<LPWSTR>    Password;
    CHeapPtr<LPWSTR>    CanonAccountName;
    CHeapPtr<LPWSTR>    CanonBinaryPath;
    DWORD               Tag = 0;


    SC_LOG1( CONFIG_API, "In RCreateServiceW - creating %ws\n",lpServiceName);

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    if ( !ScIsValidScManagerHandle( hSCManager ) ) {
        ApiStatus = ERROR_INVALID_HANDLE;
        return(ApiStatus);
    }

    if ( !RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hSCManager)->AccessGranted,
              SC_MANAGER_CREATE_SERVICE
              )) {
        ApiStatus = ERROR_ACCESS_DENIED;
        return(ApiStatus);
    }

    if ( !ScIsValidServiceName( lpServiceName ) ) {
        ApiStatus = ERROR_INVALID_NAME;
        return(ApiStatus);
    }

    //
    // Validate other parameters.
    //
    ApiStatus = ScCheckServiceConfigParms(
            FALSE,              // no, this is not a change operation
            lpServiceName,
            dwServiceType,      // new actual type = same one app gave us.
            dwServiceType,
            dwStartType,
            dwErrorControl,
            lpBinaryPathName,
            lpLoadOrderGroup,
            (LPWSTR)lpDependencies,
            dwDependSize);

    if (ApiStatus != NO_ERROR) {
        return(ApiStatus);
    }

    if (lpdwTagId != NULL) {

        //
        // Asking for tag value but didn't specify group
        //
        if ((lpLoadOrderGroup == NULL) ||
           ((lpLoadOrderGroup != NULL) && (*lpLoadOrderGroup == 0))){

            SC_LOG0(ERROR, "Asking for tag value but didn't specify group\n");
            ApiStatus = ERROR_INVALID_PARAMETER;
            return(ApiStatus);
        }
    }

    if (dwServiceType & SERVICE_WIN32) {

        //
        // Canonicalize the StartName if it is an account name.
        //

        LPWSTR AccountName = SC_LOCAL_SYSTEM_USER_NAME;  // Default


        if (ARGUMENT_PRESENT(lpServiceStartName)) {
            AccountName = lpServiceStartName;
        }

        ApiStatus = ScCanonAccountName(
                        AccountName,
                        &CanonAccountName
                        );

        if (ApiStatus != NO_ERROR) {
            return(ApiStatus);
        }

        //
        // The services that are expected to be interactive MUST
        // run in the LocalSystem account only.
        //
        if ((dwServiceType & SERVICE_INTERACTIVE_PROCESS) &&
            (_wcsicmp(CanonAccountName,SC_LOCAL_SYSTEM_USER_NAME) != 0)) {
            SC_LOG0(ERROR, "Service must run in LocalSystem account to be interactive\n");
            ApiStatus = ERROR_INVALID_PARAMETER;
            return(ApiStatus);
        }
    }
    else if (dwServiceType & SERVICE_DRIVER) {

        //
        // Canonicalize the path name for drivers
        //
        ApiStatus = ScCanonDriverImagePath(
                        dwStartType,
                        lpBinaryPathName,
                        &CanonBinaryPath
                        );
        if (ApiStatus != NO_ERROR) {
            SC_LOG(ERROR, "ScCanonDriverImagePath error %lu\n", ApiStatus);
            return(ApiStatus);
        }
    }

    if (lpServiceHandle == NULL) {
        SC_LOG0(ERROR, "Null lpServiceHandle\n");
        ApiStatus = ERROR_INVALID_PARAMETER;
        return(ApiStatus);
    }

    //
    // Lock database, as we want to add stuff without other threads tripping
    // on our feet.  NOTE:  since we may need the group list lock, we must
    // get that lock first.
    //

    CGroupListExclusiveLock GLock;
    CServiceListExclusiveLock LLock;
    CServiceRecordExclusiveLock RLock;

    //
    // Look for unique tag
    //
    if (lpdwTagId != NULL) {
        ScGetUniqueTag(
            lpLoadOrderGroup,
            &Tag
            );
    }

    //
    // Look for an existing service.
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: See if Service already exists\n");

    ApiStatus = ScGetNamedServiceRecord (
            lpServiceName,
            &oldServiceRecord );

    if (ApiStatus == NO_ERROR) {
        if (DELETE_FLAG_IS_SET(oldServiceRecord)) {
            ApiStatus = ERROR_SERVICE_MARKED_FOR_DELETE;
        }
        else {
            ApiStatus = ERROR_SERVICE_EXISTS;
        }
        goto Cleanup;

    } else if (ApiStatus != ERROR_SERVICE_DOES_NOT_EXIST) {
        goto Cleanup;
    }

    //
    // If there is a DisplayName specified, check to see if it already
    // exists.
    //
    ApiStatus = ScValidateDisplayName(lpDisplayName, NULL);
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Allocate new service record.  Put the service name in the record too.
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: Create a new service record\n");
    ApiStatus = ScCreateServiceRecord(
            lpServiceName,
            & newServiceRecord );
    if (ApiStatus != NO_ERROR) {

        goto Cleanup;
    }

    SC_LOG0( CONFIG_API, "RCreateServiceW: Add Config Info to Service Record\n");
    ApiStatus = ScAddConfigInfoServiceRecord(
                    newServiceRecord,
                    dwServiceType,
                    dwStartType,
                    dwErrorControl,
                    lpLoadOrderGroup,
                    Tag,
                    (LPWSTR) lpDependencies,
                    lpDisplayName,
                    NULL    // Create new security descriptor
                    );

    if (ApiStatus != NO_ERROR) {
        SC_LOG(ERROR, "ScAddConfigInfoServiceRecord error %lu\n", ApiStatus);
        goto Cleanup;
    }

    SC_LOG0( CONFIG_API, "RCreateServiceW: Set dependency pointers\n");
    ApiStatus = ScSetDependencyPointers(
                    newServiceRecord
                    );

    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //--------------------------------------------
    // Create a key in registry for this service.
    //--------------------------------------------
    SC_LOG0( CONFIG_API, "RCreateServiceW: Open Registry Key for service\n");
    ApiStatus = ScOpenServiceConfigKey(
            lpServiceName,
            KEY_READ | KEY_WRITE,       // desired access
            TRUE,                       // create if it doesn't exist
            &serviceKey );

    if (ApiStatus != NO_ERROR) {
        SC_LOG1( CONFIG_API, "RCreateServiceW: ScOpenServiceConfigKey failed %d\n",
            ApiStatus);
        goto Cleanup;
    }

    //
    // Write stuff to the registry (except user name and password).
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: Write RegistryInfo\n");
    ApiStatus = ScWriteServiceType( serviceKey, dwServiceType );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }
    ApiStatus = ScWriteStartType( serviceKey, dwStartType );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }
    ApiStatus = ScWriteErrorControl( serviceKey, dwErrorControl );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }
    if (lpdwTagId != NULL) {
        ApiStatus = ScWriteTag( serviceKey, Tag );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    if (dwServiceType & SERVICE_WIN32) {
        ApiStatus = ScWriteImageFileName( serviceKey, lpBinaryPathName );
    }
    else if (dwServiceType & SERVICE_DRIVER) {
        ApiStatus = ScWriteImageFileName( serviceKey, CanonBinaryPath );
    }
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    ScWriteDisplayName(serviceKey, lpDisplayName);

    if ( (lpLoadOrderGroup != NULL) && ( (*lpLoadOrderGroup) != L'\0' ) ) {
        ApiStatus = ScWriteGroupForThisService( serviceKey, lpLoadOrderGroup );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    if ( (lpDependencies != NULL) && ( (*lpDependencies) != L'\0' ) ) {

        ApiStatus = ScWriteDependencies(
                        serviceKey,
                        (LPWSTR) lpDependencies,
                        dwDependSize );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    if (newServiceRecord != NULL && newServiceRecord->ServiceSd != NULL) {
        ApiStatus = ScWriteSd(
                        serviceKey,
                        newServiceRecord->ServiceSd
                        );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    //
    // Create a handle which caller can use.
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: Create Service Handle\n");
    ApiStatus = ScCreateServiceHandle( newServiceRecord,
            &serviceHandleStruct );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Give the handle the access that the caller requested.
    //
    ApiStatus = ScGrantAccess(
                    serviceHandleStruct,
                    dwDesiredAccess);
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Resolve outstanding dependency to this service.
    //
    SC_LOG0( CONFIG_API, "RCreateServiceW: Resolve Dependencies\n");
    ApiStatus = ScResolveDependencyToService(newServiceRecord);
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Decrypt the password.  This function returns a pointer to
    // the decrypted password that must be freed later.
    //
    if (ARGUMENT_PRESENT(EncryptedPassword)) {
        ApiStatus = ScDecryptPassword(
                        hSCManager,
                        EncryptedPassword,
                        PasswordSize,
                        &Password
                        );
        if (ApiStatus != NO_ERROR) {
            SC_LOG0(ERROR, "RCreateServiceW: ScDecryptPassword failed\n");
            goto Cleanup;
        }
    }

    //
    // The LAST thing we must do (which might fail) is call
    // ScValidateAndSaveAccount().  This must be last because there is no
    // way to undo this routine's actions.
    //
    if (dwServiceType & SERVICE_WIN32) {

        SC_LOG0( CONFIG_API, "RCreateServiceW: Validate and save account\n");
        ApiStatus = ScValidateAndSaveAccount(
                        lpServiceName,
                        serviceKey,
                        CanonAccountName,
                        Password
                        );
        if (ApiStatus != NO_ERROR) {
            SC_LOG(ERROR, "ScValidateAndSaveAccount error %lu\n", ApiStatus);
            goto Cleanup;
        }
    }
    else if ((dwServiceType & SERVICE_DRIVER) &&
             (ARGUMENT_PRESENT(lpServiceStartName))) {

        SC_LOG0( CONFIG_API, "RCreateServiceW: Write Driver ObjectName to "
            "registry\n");
        //
        // Write the driver objectname to the registry.
        //
        ApiStatus = ScWriteStartName(
                        serviceKey,
                        lpServiceStartName
                        );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
    }

    SC_LOG0( CONFIG_API, "RCreateServiceW: Done - No Errors\n");
    ApiStatus = NO_ERROR;

    //
    // generate an audit 
    //

    ScGenerateServiceInstallAudit(
        lpServiceName,
        lpBinaryPathName,
        dwServiceType,
        dwStartType,
        lpServiceStartName
        );
    
Cleanup:

    if (serviceKey != NULL) {
        ScRegFlushKey( serviceKey);
        ScRegCloseKey( serviceKey );
    }

    if (ApiStatus == NO_ERROR) {
        newServiceRecord->UseCount = 1;
        *lpServiceHandle = (SC_RPC_HANDLE) serviceHandleStruct;

        SC_LOG2(USECOUNT, "CreateService: " FORMAT_LPWSTR
                " increment USECOUNT=%lu\n", newServiceRecord->ServiceName, newServiceRecord->UseCount);

        if (lpdwTagId != NULL) {
            *lpdwTagId = Tag;
        }
    }
    else {

        if (newServiceRecord != NULL) {
            //
            // Delete partially created service record.
            //
            SET_DELETE_FLAG(newServiceRecord);
            newServiceRecord->UseCount = 1;
            SC_LOG2(USECOUNT, "CreateService: " FORMAT_LPWSTR
                " increment USECOUNT=%lu\n", newServiceRecord->ServiceName, newServiceRecord->UseCount);
            //
            // ScDecrementUseCountAndDelete deletes the service record
            // and the registry entry for that service.
            //
            ScDecrementUseCountAndDelete(newServiceRecord);
            newServiceRecord = NULL;
        }

        LocalFree(serviceHandleStruct);

        if (lpServiceHandle != NULL) {
            *lpServiceHandle = NULL;
        }
    }

    SC_LOG2( CONFIG_API, "RCreateServiceW returning status " FORMAT_DWORD
            " and handle " FORMAT_LPVOID ".\n", ApiStatus,
            (LPVOID) serviceHandleStruct );

    return(ApiStatus);
}


DWORD
RDeleteService(
    IN  SC_RPC_HANDLE       hService
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS            status;
    RPC_STATUS          RpcStatus;
    UNICODE_STRING      Subsystem;
    ULONG               privileges[1];
    DWORD               ApiStatus;
    BOOL                fImpersonated = TRUE;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hService;
    LPSERVICE_RECORD    serviceRecord;

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if ( !ScIsValidServiceHandle( hService ) ) {
        return(ERROR_INVALID_HANDLE);
    }

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              DELETE
              )) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // Lock database, as we want to change stuff without other threads tripping
    // on our feet.
    //
    CServiceRecordExclusiveLock RLock;

    //
    // Find the service record
    //
    serviceRecord = serviceHandleStruct->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT( serviceRecord != NULL );
    SC_ASSERT( serviceRecord->Signature == SERVICE_SIGNATURE );

    //
    // Check if marked for deletion (by another call to this API).
    //
    if (DELETE_FLAG_IS_SET(serviceRecord)) {
        ApiStatus = ERROR_SERVICE_MARKED_FOR_DELETE;
        goto Cleanup;
    }

    //
    // Mark the service for deletion.
    // It will actually be deleted when the last handle to it is closed.
    // NOTE:  Since the service itself owns a handle, the deletion is
    // not complete until the service has stopped.
    //
    SET_DELETE_FLAG(serviceRecord);

    //
    // Set the start type to disabled.  If we're deleting a driver that's
    // started by the system, we don't want the system to start it on the
    // next boot since we're going to remove the key from the registry
    //
    serviceRecord->StartType = SERVICE_DISABLED;

    //
    // Mark the registry entry for this service for deletion.  If we notice
    // this as being present when we go throught our initialization routine
    // (during boot), the service entry in the registry will be deleted.
    //
    ScMarkForDelete(serviceRecord);

    //
    // Get Audit Privilege
    //
    privileges[0] = SE_AUDIT_PRIVILEGE;
    status = ScGetPrivilege( 1, privileges);

    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "RDeleteService: ScGetPrivilege (Enable) failed %d\n",
                status);
    }

    //
    // Generate the audit -- must be done as the user as per C2 requirements.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        SC_LOG1(ERROR,
                "RCloseServiceHandle: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
                RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_IMPERSONATE,
            RpcStatus);

        //
        // Can't impersonate the user -- do the audit as System instead so
        // the close is at least logged.
        //

        fImpersonated = FALSE;
    }

    RtlInitUnicodeString(&Subsystem, SC_MANAGER_AUDIT_NAME);
    status = NtDeleteObjectAuditAlarm(
                &Subsystem,
                hService,
                (BOOLEAN)((serviceHandleStruct->Flags
                    & SC_HANDLE_GENERATE_ON_CLOSE) != 0));

    if (!NT_SUCCESS(status))
    {
        SC_LOG1(ERROR, "RDeleteService: NtDeleteObjectAuditAlarm failed %#lx\n",
                status);
    }

    if (fImpersonated)
    {
        RpcStatus = RpcRevertToSelf();

        if (RpcStatus != RPC_S_OK)
        {
            SC_LOG(ERROR,
                   "RCloseServiceHandle: Fail to revert to self %08lx\n",
                   RpcStatus);

            ScLogEvent(
                NEVENT_CALL_TO_FUNCTION_FAILED,
                SC_RPC_REVERT,
                RpcStatus);

            ASSERT(FALSE);

            //
            // Not much else we can do at this point -- keep on going.
            //
        }
    }

    ScReleasePrivilege();

    ApiStatus = NO_ERROR;

Cleanup:

    SC_LOG2( CONFIG_API, "RDeleteService(%ws) returning status " FORMAT_DWORD
            ".\n", serviceRecord->ServiceName, ApiStatus );

    return (ApiStatus);
}


DWORD
RQueryServiceConfigW(
    IN    SC_RPC_HANDLE           hService,
    OUT   LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    IN    DWORD                   cbBufSize,
    OUT   LPDWORD                 pcbBytesNeeded
    )


/*++

Routine Description:

    This function returns the service configuration information that
    is currently stored in the registry.

    NOTE:
    When a service is running and its configuration is changed, the
    change only affects the registry information as long as the service
    is running.  During this period (while the service is running), it is
    not possible to obtain the configuration of the running service.
    All that can be obtained is the configuration stored in the registry.
    This is the configuration that the service will have the next time
    it is run.  Stopping a service causes it to get its configuration
    information refreshed from the registry.

Arguments:


Return Value:


--*/
{
    DWORD               ApiStatus;
    DWORD               bytesNeeded = sizeof(QUERY_SERVICE_CONFIG); // (initial)
    LPWSTR              endOfVariableData;
    LPWSTR              fixedDataEnd;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hService;
    LPSERVICE_RECORD    serviceRecord = NULL;
    HKEY                ServiceNameKey = (HKEY) NULL;
    DWORD               bufSize;
    DWORD               dependSize=0;
    LPWSTR              CurrentImagePathName = NULL;
    LPWSTR              CurrentDependencies = NULL;
    LPWSTR              CurrentGroup = NULL;
    LPWSTR              CurrentStartName = NULL;
    LPWSTR              pDependString;
    LPWSTR              CurrentDisplayName = NULL;
    LPWSTR              ConvertImageName;

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if ( !ScIsValidServiceHandle( hService ) ) {
        return(ERROR_INVALID_HANDLE);
    }

    //
    // Check other caller parms (except buffer too small, we need more info).
    //
    if (lpServiceConfig == NULL) {
        return(ERROR_INVALID_PARAMETER);
    } else if (pcbBytesNeeded == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              SERVICE_QUERY_CONFIG
              )) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // Lock database, as we want to look at stuff without other threads changing
    // fields at the same time.
    //
    CServiceRecordSharedLock RLock;

    serviceRecord = serviceHandleStruct->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT( serviceRecord != NULL );


    //
    // Open the service name key.
    //
    ApiStatus = ScOpenServiceConfigKey(
                    serviceRecord->ServiceName,
                    KEY_READ,
                    FALSE,               // Create if missing
                    &ServiceNameKey
                    );

    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //--------------------------------
    // Get the BinaryPathName
    //--------------------------------
    SC_ASSERT( serviceRecord->ServiceName != NULL );

    ApiStatus = ScGetImageFileName (
           serviceRecord->ServiceName,
           & CurrentImagePathName );       // alloc and set ptr.

    if (ApiStatus != NO_ERROR) {
        CurrentImagePathName = NULL;
    }

    ApiStatus = ScReadConfigFromReg(
                    serviceRecord,
                    &lpServiceConfig->dwServiceType,
                    &lpServiceConfig->dwStartType,
                    &lpServiceConfig->dwErrorControl,
                    &lpServiceConfig->dwTagId,
                    &CurrentDependencies,
                    &CurrentGroup,
                    &CurrentDisplayName);

    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // If the starttype is SERVICE_BOOT_START the name is a relative path
    // from \SystemRoot.  Fix it to be a fully qualified name, unless it is
    // an ARC name, then leave it alone.
    //

    if (CurrentImagePathName &&
        lpServiceConfig->dwStartType == SERVICE_BOOT_START &&
        !ScIsArcName(CurrentImagePathName)) {

        ConvertImageName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((wcslen(CurrentImagePathName) +
            SC_NT_SYSTEM_ROOT_LENGTH + 1) * sizeof(WCHAR)));

        if (ConvertImageName == NULL) {
            SC_LOG1(ERROR, "RQueryServiceConfigW: LocalAlloc failed %lu\n",
                    GetLastError());
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy(ConvertImageName, SC_NT_SYSTEM_ROOT);
        wcscat(ConvertImageName, CurrentImagePathName);
        LocalFree(CurrentImagePathName);
        CurrentImagePathName = ConvertImageName;
    }

    //--------------------------------
    // Get StartName
    //--------------------------------
    ApiStatus = ScReadStartName( ServiceNameKey, &CurrentStartName);
    if (ApiStatus != NO_ERROR) {
        SC_LOG1(TRACE,"StartName for %ws service does not exist\n",
            serviceRecord->ServiceName);
        CurrentStartName = NULL;
    }


    //
    // Figure-out how much space we'll need for the record.
    // We've already got the initial (fixed) size in bytesNeeded...
    //
    SC_ASSERT( bytesNeeded == sizeof(QUERY_SERVICE_CONFIG) );


    //
    // Add on some extra for RPC byte count alignment.
    // NOTE:  We don't try to solve any exact alignment problem because
    //        RPC will choose a random order in which to load strings into
    //        the buffer.
    //
    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    if (CurrentImagePathName != NULL)
    {
        bytesNeeded += (DWORD) WCSSIZE(CurrentImagePathName);
    }
    else {
        bytesNeeded += sizeof(WCHAR);
    }

    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    //
    // If the display name is not stored in the registry, the
    // Service Name is returned instead.
    //

    if (CurrentDisplayName == NULL) {
        CurrentDisplayName = serviceRecord->ServiceName;
    }

    bytesNeeded += (DWORD) WCSSIZE(CurrentDisplayName);

    //
    // Add on some extra for RPC byte count alignment.
    //
    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    if (CurrentGroup != NULL) {
        bytesNeeded += (DWORD) WCSSIZE(CurrentGroup);
    }
    else {
        bytesNeeded += sizeof(WCHAR);
    }

    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    if (CurrentDependencies != NULL) {
        dependSize = ScWStrArraySize(CurrentDependencies);
        bytesNeeded += dependSize;
    }
    else {
        bytesNeeded += (2 * sizeof(WCHAR));
    }

    bytesNeeded += sizeof(ULONG_PTR) - 1;       // extra for RPC alignment

    if (CurrentStartName != NULL) {
        bytesNeeded += (DWORD) WCSSIZE(CurrentStartName);
    }
    else {
        bytesNeeded += sizeof(WCHAR);
    }

    bytesNeeded = ROUND_UP_COUNT(bytesNeeded, ALIGN_WCHAR);

    //
    // Make sure app gave us enough space.
    //
    if (bytesNeeded > cbBufSize) {
        *pcbBytesNeeded = bytesNeeded;
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //========================
    // Fill in the strings.
    //========================
    fixedDataEnd = (LPWSTR) (lpServiceConfig + 1);
    endOfVariableData = (LPWSTR) ((LPBYTE)lpServiceConfig + bytesNeeded);


    bufSize = 0;
    if (CurrentImagePathName != NULL) {
        bufSize = (DWORD) wcslen( CurrentImagePathName );
    }

    if ( !ScCopyStringToBufferW (
            CurrentImagePathName,
            bufSize,
            fixedDataEnd,
            & endOfVariableData,
            & lpServiceConfig->lpBinaryPathName,
            NULL
            ) ) {

        SC_LOG0(ERROR,
            "RQueryServiceConfigW:ScCopyStringtoBufferW "
            "(BinaryPathName)Failed\n");

        SC_ASSERT( FALSE );
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    bufSize = 0;

    if (CurrentGroup != NULL) {
        bufSize = (DWORD) wcslen( CurrentGroup );
    }

    if ( !ScCopyStringToBufferW (
            CurrentGroup,
            bufSize,
            fixedDataEnd,
            &endOfVariableData,
            &lpServiceConfig->lpLoadOrderGroup,
            NULL
            ) ) {

        SC_LOG0(ERROR,
            "RQueryServiceConfigW:ScCopyStringtoBufferW "
            "(LoadOrderGroup)Failed\n");

        SC_ASSERT( FALSE );
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //
    // Dependencies
    //
    if ((CurrentDependencies == NULL) || (dependSize == 0)) {
        //
        // There are no dependencies so put in a double null terminated
        // null string.
        //
        // NOTE:  The separator character '/' is inserted to allow the
        //  double NULL terminated string to make it across RPC.
        //  This is removed by the client side.
        //
        lpServiceConfig->lpDependencies = endOfVariableData - 2;
        endOfVariableData = lpServiceConfig->lpDependencies;
        lpServiceConfig->lpDependencies[0] = L'/';
        lpServiceConfig->lpDependencies[1] = L'\0';
    }
    else {
        lpServiceConfig->lpDependencies = (LPWSTR)((LPBYTE)endOfVariableData - dependSize);
        pDependString = lpServiceConfig->lpDependencies;
        endOfVariableData = pDependString;

        RtlCopyMemory(lpServiceConfig->lpDependencies, CurrentDependencies, dependSize);

        //
        // Add separator characters.
        //
        while ((bufSize = (DWORD) wcslen(pDependString)) != 0) {
            pDependString += bufSize;
            *pDependString = L'/';
            pDependString++;
        }
    }

    //
    // StartName
    //
    bufSize = 0;
    if (CurrentStartName != NULL) {
        bufSize = (DWORD) wcslen(CurrentStartName);
    }

    if ( !ScCopyStringToBufferW (
            CurrentStartName,
            bufSize,
            fixedDataEnd,
            & endOfVariableData,
            & lpServiceConfig->lpServiceStartName,
            NULL
            ) ) {

        SC_LOG0(ERROR,
            "RQueryServiceConfigW:ScCopyStringtoBufferW (StartName)Failed\n");

        SC_ASSERT( FALSE );
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //
    // DisplayName
    //
    bufSize = 0;

    SC_ASSERT(CurrentDisplayName);

    bufSize = (DWORD) wcslen(CurrentDisplayName);

    if ( !ScCopyStringToBufferW (
            CurrentDisplayName,
            bufSize,
            fixedDataEnd,
            & endOfVariableData,
            & lpServiceConfig->lpDisplayName,
            NULL
            ) ) {

        SC_LOG0(ERROR,
            "RQueryServiceConfigW:ScCopyStringtoBufferW (DisplayName)Failed\n");

        SC_ASSERT( FALSE );
        ApiStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //
    // That's all, folks!  --JR
    //
    ApiStatus = NO_ERROR;

Cleanup:

    if (ServiceNameKey != (HKEY) NULL) {
        ScRegCloseKey(ServiceNameKey);
    }

    LocalFree(CurrentStartName);
    LocalFree(CurrentImagePathName);

    if (serviceRecord != NULL && CurrentDisplayName != serviceRecord->DisplayName)
    {
        LocalFree( CurrentDisplayName );
    }

    LocalFree( CurrentGroup );
    LocalFree( CurrentDependencies );

    if (pcbBytesNeeded != NULL) {
        *pcbBytesNeeded = bytesNeeded;
    }

    SC_LOG2( CONFIG_API, "RQueryServiceConfigW returning status " FORMAT_DWORD
            " and size needed " FORMAT_DWORD ".\n", ApiStatus, bytesNeeded );

    //
    // If an error occurs, we set the pointers in the structure to NULL.
    // This is for RPC. Since we are using the byte_count feature, the
    // server marshalling code must look at the pointers.  Otherwise, it
    // doesn't know how to marshall the strings.
    //
    if (ApiStatus != NO_ERROR) {
        lpServiceConfig->lpBinaryPathName   = NULL;
        lpServiceConfig->lpLoadOrderGroup   = NULL;
        lpServiceConfig->lpDependencies     = NULL;
        lpServiceConfig->lpServiceStartName = NULL;
        lpServiceConfig->lpDisplayName      = NULL;
    }

    return (ApiStatus);
}


DWORD
ScCanonDriverImagePath(
    IN DWORD DriverStartType,
    IN LPWSTR DriverPath,
    OUT LPWSTR *CanonDriverPath
    )
/*++

Routine Description:

    This function converts the user specified DOS path name to the driver
    binary file into an NT path format understood by NtLoadDriver.

    Examples:

        C:\nt\system32\file.sys -> \DosDevices\c:\nt\system32\file.sys

        %SystemRoot%\system32\drivers\file.sys -> \SystemRoot\system32\driver\file.sys


Arguments:

    DriverPath - User specified DOS path name to driver .SYS file.

    CanonDriverPath - Receives a pointer to a buffer which contains the
        NT path to the driver .SYS file.  This buffer should be freed
        with LocalFree.

Return Value:

    NO_ERROR - successful.

    ERROR_NOT_ENOUGH_MEMORY - no memory to allocate output buffer.

    ERROR_INVALID_PARAMETER - RtlDosPathNameToNtPath_U failure.

--*/
{

    UNICODE_STRING NewPath;
    DWORD DriverPathLength;
    LPWSTR RelativeCanonPath;
    DWORD Status;

    SC_LOG1(DEPEND, "ScCanonDriverImagePath: Input path " FORMAT_LPWSTR "\n", DriverPath);

    DriverPathLength = (DWORD) wcslen(DriverPath);

    if (DriverPathLength > SC_NT_SYSTEM_ROOT_LENGTH &&
        (_wcsnicmp(SC_NT_SYSTEM_ROOT, DriverPath, SC_NT_SYSTEM_ROOT_LENGTH) == 0))
    {
        //
        // Path is already in NT form with \SystemRoot\ prefix.
        // Just return a buffer that contains the same path as input.
        //

        *CanonDriverPath = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((DriverPathLength + 1) * sizeof(WCHAR)));

        if (*CanonDriverPath == NULL) {
            SC_LOG1(ERROR, "ScCanonDriverPathName: LocalAlloc failed %lu\n",
                    GetLastError());
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Boot drivers need relative path names
        //

        if (DriverStartType == SERVICE_BOOT_START) {
            wcscpy(*CanonDriverPath, DriverPath + SC_NT_SYSTEM_ROOT_LENGTH);
        }
        else {
            wcscpy(*CanonDriverPath, DriverPath);
        }

        SC_LOG1(DEPEND, "ScCanonDriverImagePath: Canonicalized path "
                FORMAT_LPWSTR "\n", *CanonDriverPath);

        return NO_ERROR;
    }

    if (DriverPathLength > SC_DOS_SYSTEM_ROOT_LENGTH &&
        (_wcsnicmp(SC_DOS_SYSTEM_ROOT, DriverPath, SC_DOS_SYSTEM_ROOT_LENGTH) == 0))
    {
        //
        // DOS path has %SystemRoot%\ prefix
        //

        *CanonDriverPath = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((DriverPathLength + 1) * sizeof(WCHAR)));

        if (*CanonDriverPath == NULL) {
            SC_LOG1(ERROR, "ScCanonDriverPathName: LocalAlloc failed %lu\n",
                    GetLastError());
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (DriverStartType != SERVICE_BOOT_START) {
            wcscpy(*CanonDriverPath, SC_NT_SYSTEM_ROOT);
        }
        else {
            *CanonDriverPath[0] = '\0';
        }

        wcscat(*CanonDriverPath, DriverPath + SC_DOS_SYSTEM_ROOT_LENGTH);

        SC_LOG1(DEPEND, "ScCanonDriverImagePath: Canonicalized path "
                FORMAT_LPWSTR "\n", *CanonDriverPath);

        return NO_ERROR;
    }

    //
    // If it's already a relative path name, leave it alone
    //

    if (DriverPath[0] != L'\\' && DriverPath[1] != L':')
    {
        *CanonDriverPath = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((DriverPathLength + 1) * sizeof(WCHAR)));

        if (*CanonDriverPath == NULL)
        {
            SC_LOG1(ERROR, "ScCanonDriverPathName: LocalAlloc failed %lu\n",
                    GetLastError());
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*CanonDriverPath, DriverPath);
        return NO_ERROR;
    }

    //
    // Convert DOS path to NT path using Rtl routine which allocates
    // the Unicode string buffer.
    //
    if (! RtlDosPathNameToNtPathName_U(
              (PCWSTR) DriverPath,
              &NewPath,
              NULL,
              NULL
              ))
    {
        return ERROR_INVALID_PARAMETER;
    }

    *CanonDriverPath = (LPWSTR) LocalAlloc(
                                    LMEM_ZEROINIT,
                                    (UINT) NewPath.Length + sizeof(WCHAR)
                                    );

    if (*CanonDriverPath == NULL) {

        SC_LOG1(ERROR, "ScCanonDriverPathName: LocalAlloc failed %lu\n",
                GetLastError());

        RtlFreeUnicodeString(&NewPath);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcsncpy(*CanonDriverPath, NewPath.Buffer, NewPath.Length / sizeof(WCHAR));

    RtlFreeUnicodeString(&NewPath);

    //
    // Boot drivers' imagepath must be relative to \systemroot
    //

    if (DriverStartType == SERVICE_BOOT_START)
    {
        Status = ScConvertToBootPathName(*CanonDriverPath, &RelativeCanonPath);

        if (Status == NO_ERROR)
        {
            SC_ASSERT(RelativeCanonPath != NULL);
            wcscpy(*CanonDriverPath, RelativeCanonPath + SC_NT_SYSTEM_ROOT_LENGTH);
            LocalFree(RelativeCanonPath);
        }
        else
        {
            LocalFree(*CanonDriverPath);
            *CanonDriverPath = NULL;
        }

        return Status;
    }

    SC_LOG1(DEPEND, "ScCanonDriverImagePath: Canonicalized path "
            FORMAT_LPWSTR "\n", *CanonDriverPath);

    return NO_ERROR;
}


DWORD
RGetServiceDisplayNameW(
    SC_RPC_HANDLE   hSCManager,
    LPWSTR          lpServiceName,
    LPWSTR          lpDisplayName,
    LPDWORD         lpcchBuffer
    )
/*++

Routine Description:

    This function returns the DisplayName that is associated with a
    particular ServiceName.  If the buffer that is to receive the
    DisplayName is too small, no data is returned in the buffer.  Instead,
    the actual string size (in characters - not including NUL terminator)
    is returned in *lpcchBuffer.

Arguments:

    hSCManager - Handle to the Service Control Manager.  This parameter
        is the RPC handle that was used to get us to this point.

    lpServiceName - This is a pointer to the service name string.  This
        name is the same as the registry key name for that service.

    lpDisplayName - This is a pointer to the buffer where the display name
        is to be placed.  If this function fails, this buffer will contain
        an empty string.

    lpcchBuffer - This is a pointer to a DWORD that contains the size of
        the buffer (in characters) upon input.  On return, this DWORD
        indicates how many characters (excluding the NUL terminator) are
        in the DisplayName.

Return Value:

    NO_ERROR - If the operation was successful.

    ERROR_INSUFFICIENT_BUFFER - if the buffer is too small to contain the
        whole string.

    ERROR_SERVICE_DOES_NOT_EXIST - If there is no record of a service
        by this name in the database.

    ERROR_INVALID_NAME - if the ServiceName is invalid (NULL);

--*/
{
    DWORD               status;
    DWORD               reqSize;
    LPSERVICE_RECORD    ServiceRecord;

    UNREFERENCED_PARAMETER(hSCManager);

    //
    // Find the proper service record.
    //
    CServiceListSharedLock LLock;
    CServiceRecordSharedLock RLock;

    status = ScGetNamedServiceRecord(lpServiceName, &ServiceRecord);
    if (status != NO_ERROR) {
        return(status);
    }

    //
    // Get the display name and determine if it will fit in the buffer.
    //
    reqSize = (DWORD) wcslen(ServiceRecord->DisplayName);

    if (*lpcchBuffer < (reqSize + 1))
    {
        *lpcchBuffer = reqSize;
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    wcscpy(lpDisplayName, ServiceRecord->DisplayName);
    *lpcchBuffer = reqSize;

    return(NO_ERROR);
}


DWORD
RGetServiceKeyNameW(
    SC_RPC_HANDLE   hSCManager,
    LPWSTR          lpDisplayName,
    LPWSTR          lpServiceName,
    LPDWORD         lpcchBuffer
    )

/*++

Routine Description:

    This function returns the ServiceName that is associated with a
    particular DisplayName.  If the buffer that is to receive the
    ServiceName is too small, no data is returned in the buffer.  Instead,
    the actual string size (in characters - not including NUL terminator)
    is returned in *lpcchBuffer.


Arguments:

    hSCManager - Handle to the Service Control Manager.  This parameter
        is the RPC handle that was used to get us to this point.

    lpDisplayName - This is a pointer to the service display name string.

    lpServiceName - This is a pointer to the buffer where the service name
        string is to be placed.  If this function fails, this buffer will
        contain an empty string.

    lpcchBuffer - This is a pointer to a DWORD that contains the size of
        the buffer (in characters) upon input.  On return, this DWORD
        indicates how many characters (excluding the NUL terminator) are
        in the DisplayName.

Return Value:



--*/
{
    DWORD               status;
    DWORD               reqSize;
    LPSERVICE_RECORD    ServiceRecord;

    UNREFERENCED_PARAMETER(hSCManager);

    //
    // Find the proper service record.
    //
    CServiceListSharedLock LLock;
    CServiceRecordSharedLock RLock;

    status = ScGetDisplayNamedServiceRecord(lpDisplayName, &ServiceRecord);

    if (status != NO_ERROR)
    {
        return(status);
    }

    //
    // Get the service key name and determine if it will fit in the buffer.
    //
    reqSize = (DWORD) wcslen(ServiceRecord->ServiceName);

    if (*lpcchBuffer < (reqSize + 1)) {
        *lpcchBuffer = reqSize;
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    wcscpy(lpServiceName, ServiceRecord->ServiceName);
    *lpcchBuffer = reqSize;

    return(NO_ERROR);
}


DWORD
ScValidateDisplayName(
    LPWSTR              lpDisplayName,
    LPSERVICE_RECORD    lpServiceRecord
    )

/*++

Routine Description:

    This function validates display names by checking to see if the name
    string already exists in the database.  The display name must not match
    any other display name or another service name.  The display name can
    match the service name if it they both refer to the same service.

Arguments:

    lpDisplayName - A pointer to the proposed DisplayName.

    lpServiceRecord - A pointer to the service record to which the display
        name is to be added.  If this function is called from CreateService,
        the lpServiceRecord pointer will be NULL.

Return Value:

    NO_ERROR - If the DisplayName doesn't conflict with any other names
        in the database.

    ERROR_DUPLICATE_SERVICE_NAME - If the DisplayName conflicts with another name.



--*/
{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    displayServiceRecord;

    if (lpDisplayName != NULL) {

        if (wcslen(lpDisplayName) > MAX_SERVICE_NAME_LENGTH) {
            return(ERROR_INVALID_NAME);
        }

        status = ScGetDisplayNamedServiceRecord(
                    lpDisplayName,
                    &displayServiceRecord);

        if (status == NO_ERROR)
        {
            if (displayServiceRecord != lpServiceRecord)
            {
                //
                // The display name already exists for a different
                // service.  Therefore we must reject it.
                //
                return(ERROR_DUPLICATE_SERVICE_NAME);
            }
        }

        status = ScGetNamedServiceRecord(lpDisplayName, &displayServiceRecord);

        if (status == NO_ERROR)
        {
            if (displayServiceRecord != lpServiceRecord)
            {
                //
                // The display name is already used as a service name.
                // Therefore we must reject it.
                //
                return(ERROR_DUPLICATE_SERVICE_NAME);
            }
        }
    }

    return NO_ERROR;
}


DWORD
ScConvertToBootPathName(
    LPWSTR              FullQualPathName,
    LPWSTR *            RelativePathName
    )

/*++

Routine Description:

    This function takes an NT style image path name and turns it into an
    NT style path name that is accessed via \systemroot.  This is required
    for drivers that are loaded by the boot loader.

Arguments:

    FullQualPathName - The fully qualified name

    RelativePathName - A pointer to the pointer for the new buffer which
                       contains the fully qualified path name using
                       \systemroot\.  The caller must free this buffer using
                       LocalFree.

Return Value:

    NO_ERROR - If the name can be converted.

    ERROR_INVALID_PARAMETER - If the Name is not relative to \systemroot

--*/
{
    WCHAR Dummy;
    ULONG PrefixLength;
    LPWSTR Prefix = &Dummy;
    UNICODE_STRING NewPrefix;
    DWORD PathLength;
    DWORD NumRequired;
    DWORD CharsReturned;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle = NULL;
    UNICODE_STRING FileName;
    UNICODE_STRING LinkTarget = { 0, 0, NULL };

    NTSTATUS Status;
    DWORD    dwError = NO_ERROR;

    DWORD BytesRequired;

    PathLength = (DWORD) wcslen(FullQualPathName);

    if ((PathLength > SC_NT_SYSTEM_ROOT_LENGTH) &&
        (_wcsnicmp(SC_NT_SYSTEM_ROOT, FullQualPathName, SC_NT_SYSTEM_ROOT_LENGTH) == 0))
    {
        //
        // Path is already in NT form with \SystemRoot\ prefix.
        // Just return it
        //

        *RelativePathName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) (PathLength + 1) * sizeof(WCHAR));

        if (*RelativePathName == NULL)
        {
            SC_LOG1(ERROR, "ScConvertToBootName: LocalAlloc failed %d\n",
                GetLastError());
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        wcscpy(*RelativePathName, FullQualPathName);
        return(ERROR_SUCCESS);
    }

    if (PathLength > SC_DOS_SYSTEM_ROOT_LENGTH &&
        (_wcsnicmp(SC_DOS_SYSTEM_ROOT, FullQualPathName, SC_DOS_SYSTEM_ROOT_LENGTH) == 0))
    {
        //
        // Path is in DOS form with %SystemRoot% prefix.
        // Just return it after replacing the %SystemRoot%\ prefix with
        // \SystemRoot
        //

        *RelativePathName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) (PathLength - SC_DOS_SYSTEM_ROOT_LENGTH + SC_NT_SYSTEM_ROOT_LENGTH + 1)
            * sizeof(WCHAR));

        if (*RelativePathName == NULL) {
            SC_LOG1(ERROR, "ScConvertToBootName: LocalAlloc failed %d\n",
                GetLastError());
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        wcscpy(*RelativePathName, SC_NT_SYSTEM_ROOT);
        wcscat(*RelativePathName, FullQualPathName + SC_DOS_SYSTEM_ROOT_LENGTH);
        return NO_ERROR;
    }

    //
    // Create a string that represents the path to systemroot that you
    // would get if you started with a Dos style name
    //

    //
    // Make the first call just to get the number of characters that
    // will be returned.
    //

    NumRequired = ExpandEnvironmentStringsW (SC_DOS_SYSTEM_ROOT, Prefix, 1);

    if (NumRequired > 1) {

        Prefix = (LPWSTR)LocalAlloc(LMEM_ZEROINIT,
            (UINT) ((NumRequired + 1) * sizeof(WCHAR)));

        if (Prefix == NULL) {
            SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
                FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                NumRequired + 1, GetLastError());
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Now expand the string into a dos type path
        //

        CharsReturned = ExpandEnvironmentStringsW (
                            SC_DOS_SYSTEM_ROOT,
                            Prefix,
                            NumRequired);

        if (CharsReturned > NumRequired) {
            SC_LOG1(ERROR, "ScConvertToBootName: ExpandEnvironmentStrings "
                " failed for " FORMAT_LPWSTR " \n", SC_DOS_SYSTEM_ROOT);
            LocalFree(Prefix);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    else {

        //
        // This shouldn't ever happen
        //
        ASSERT(FALSE);
        return ERROR_INVALID_ENVIRONMENT;
    }

    //
    // Now convert the DOS path to an NT path
    //

    if (! RtlDosPathNameToNtPathName_U(
              (PCWSTR) Prefix,
              &NewPrefix,
              NULL,
              NULL
              ))
    {
        //
        // This shouldn't ever happen
        //
        ASSERT(FALSE);
        LocalFree(Prefix);
        return ERROR_INVALID_ENVIRONMENT;
    }

    LocalFree(Prefix);

    PrefixLength = NewPrefix.Length / sizeof(WCHAR);

    Prefix = (LPWSTR)LocalAlloc(LMEM_ZEROINIT,
        (UINT) (NewPrefix.Length + sizeof(WCHAR)));

    if (Prefix == NULL)
    {
        SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
            FORMAT_DWORD " failed " FORMAT_DWORD "\n",
            NewPrefix.Length + sizeof(WCHAR), GetLastError());

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    wcsncpy(Prefix, NewPrefix.Buffer, PrefixLength);

    if (PathLength > PrefixLength &&
        (_wcsnicmp(Prefix, FullQualPathName, PrefixLength) == 0))
    {
        //
        // Path is in DOS form without using %systemroot%
        // Convert to \SystemRoot format
        //

        *RelativePathName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) (PathLength - PrefixLength + SC_NT_SYSTEM_ROOT_LENGTH + 1)
            * sizeof(WCHAR));

        if (*RelativePathName == NULL)
        {
            SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
                FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                (PathLength - PrefixLength + SC_NT_SYSTEM_ROOT_LENGTH + 1) *
                sizeof(WCHAR), GetLastError());

            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy(*RelativePathName, SC_NT_SYSTEM_ROOT);
        wcscat(*RelativePathName, FullQualPathName + PrefixLength);

        dwError = NO_ERROR;
        goto CleanExit;
    }

    //
    // Create a string that represents the path to systemroot that you
    // would get if you started with a NT style name
    //

    //
    // Make the first call just to get the number of characters that
    // will be returned.
    //

    RtlInitUnicodeString(&FileName, L"\\SystemRoot");

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &FileName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

    Status = NtOpenSymbolicLinkObject(&Handle, SYMBOLIC_LINK_QUERY, &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        //
        // This should never happen
        //
        ASSERT(FALSE);
        dwError = ERROR_INVALID_ENVIRONMENT;
        goto ErrorExit;
    }

    Status = NtQuerySymbolicLinkObject(Handle, &LinkTarget, &BytesRequired);

    if (!NT_SUCCESS(Status) && Status != STATUS_BUFFER_TOO_SMALL)
    {
        //
        // This should never happen
        //
        ASSERT(FALSE);
        dwError = ERROR_INVALID_ENVIRONMENT;
        goto ErrorExit;
    }

    LinkTarget.Buffer = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
                                            BytesRequired + sizeof(WCHAR));

    if (LinkTarget.Buffer == NULL)
    {
        SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
            FORMAT_DWORD " failed " FORMAT_DWORD "\n",
            BytesRequired, GetLastError());

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    LinkTarget.Length = (USHORT) BytesRequired;
    LinkTarget.MaximumLength = (USHORT) (BytesRequired + sizeof(WCHAR));
    Status = NtQuerySymbolicLinkObject(Handle, &LinkTarget, &BytesRequired);

    if (!NT_SUCCESS(Status))
    {
        //
        // This should never happen
        //
        ASSERT(FALSE);
        dwError = ERROR_INVALID_ENVIRONMENT;
        goto ErrorExit;
    }

    PrefixLength = LinkTarget.Length / sizeof(WCHAR);
    if (PathLength > PrefixLength &&
        (_wcsnicmp(LinkTarget.Buffer, FullQualPathName, PrefixLength) == 0))
    {
        //
        // Path is in NT form without using \Systemroot
        // Convert to \SystemRoot format
        //

        *RelativePathName = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
            (UINT) (PathLength - PrefixLength + SC_NT_SYSTEM_ROOT_LENGTH + 1)
            * sizeof(WCHAR));

        if (*RelativePathName == NULL)
        {
            SC_LOG2(ERROR, "ScConvertToBootName: LocalAlloc of numChar= "
                FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                (PathLength - PrefixLength + SC_NT_SYSTEM_ROOT_LENGTH + 1) *
                sizeof(WCHAR), GetLastError());

            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy(*RelativePathName, SC_NT_SYSTEM_ROOT);

        //
        // Skip the \ between \SystemRoot and the relative name
        //

        wcscat(*RelativePathName, FullQualPathName + PrefixLength + 1);

        dwError = NO_ERROR;
        goto CleanExit;
    }

    //
    // If we get this far, the imagepath is not relative to the systemroot.
    //
    dwError = ERROR_INVALID_PARAMETER;

ErrorExit:

    //
    // Return an error and a NULL pointer.
    //

    *RelativePathName = NULL;

CleanExit:

    if (Handle)
    {
        NtClose(Handle);
    }

    LocalFree(LinkTarget.Buffer);
    RtlFreeUnicodeString(&NewPrefix);
    LocalFree(Prefix);

    return dwError;
}


BOOLEAN
ScIsArcName(
    LPWSTR              PathName
    )

/*++

Routine Description:

    This function takes a driver's path name and determines if it is an
    ARC style name.  This is done by trying to open the file with \Arcname
    prepended.  There are symbolic links of this form for every valid arcname.

Arguments:

    PathName - The image path

Return Value:

    TRUE - If it is an arcname
    FALSE - If it's not an arcname

--*/
{
   OBJECT_ATTRIBUTES ObjectAttributes;
   HANDLE Handle;
   IO_STATUS_BLOCK IoStatusBlock;
   UNICODE_STRING FileName;
   NTSTATUS Status;
   LPWSTR NewString;
   UINT BufferSize;

   //
   // Allocate the buffer for the composite string
   //

   BufferSize = ((DWORD) wcslen(PathName) + ARC_PREFIX_LENGTH + 1) * sizeof(WCHAR);

   NewString = (LPWSTR) LocalAlloc(LMEM_ZEROINIT, BufferSize);

   if (NewString == NULL)
   {
       SC_LOG2(ERROR, "ScIsArcName: LocalAlloc of numChar= "
           FORMAT_DWORD " failed " FORMAT_DWORD "\n", BufferSize, GetLastError());

       return FALSE;
   }

   //
   // Create the composite string
   //
   wcscpy(NewString, ARC_PREFIX);
   wcscat(NewString, PathName);

   RtlInitUnicodeString(&FileName, NewString);

   //
   // Try to open it
   //
   InitializeObjectAttributes(
                   &ObjectAttributes,
                   &FileName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL);

   Status = NtOpenFile(&Handle,
                       FILE_GENERIC_READ,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       FILE_SHARE_READ,
                       FILE_SYNCHRONOUS_IO_NONALERT);


   LocalFree(NewString);

   //
   // If you could open it, it's an arcname
   //
   if (NT_SUCCESS(Status))
   {
       //
       // Close it, we just need the status
       //
       NtClose(Handle);

       return TRUE;
   }
   else
   {
       return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\cfgapi2.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    CfgAPI2.cxx

Abstract:

    This file contains the Service Controller's extended Config API.
        RChangeServiceConfig2W
        RQueryServiceConfig2W
        COutBuf
        CUpdateOptionalString::Update
        CUpdateOptionalString::~CUpdateOptionalString
        PrintConfig2Parms


Author:

    Anirudh Sahni (AnirudhS)  11-Oct-96

Environment:

    User Mode - Win32

Revision History:

    11-Oct-1996 AnirudhS
        Created.

--*/


//
// INCLUDES
//

#include "precomp.hxx"
#include <tstr.h>       // Unicode string macros
#include <align.h>      // COUNT_IS_ALIGNED
#include <valid.h>      // ACTION_TYPE_INVALID
#include <sclib.h>      // ScImagePathsMatch
#include <scwow.h>      // 32/64-bit interop structures
#include "scconfig.h"   // ScOpenServiceConfigKey, etc.
#include "scsec.h"      // ScPrivilegeCheckAndAudit
#include "smartp.h"     // CHeapPtr


#if DBG == 1
VOID
PrintConfig2Parms(
    IN  SC_RPC_HANDLE       hService,
    IN  SC_RPC_CONFIG_INFOW Info
    );
#endif

#define FLDREF(s,f) (s.f)

//
// Class definitions
//

//+-------------------------------------------------------------------------
//
//  Class:      COutBuf
//
//  Purpose:    Abstraction of an output buffer that is written sequentially
//
//  History:    22-Nov-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

class COutBuf
{
public:
    COutBuf(LPBYTE lpBuffer) :
        _Start(lpBuffer),
        _Used(0)
        { }

    LPBYTE  Next() const         { return (_Start + _Used); }
    DWORD   OffsetNext() const   { return _Used; }
    void    AddUsed(DWORD Bytes) { _Used += Bytes; }

    void    AppendBytes(void * Source, DWORD Bytes)
                    {
                        RtlCopyMemory(Next(), Source, Bytes);
                        AddUsed(Bytes);
                    }
private:
    LPBYTE  _Start;
    DWORD   _Used;
};


//+-------------------------------------------------------------------------
//
//  Class:      CUpdateOptionalString
//
//  Purpose:    An object of this class represents an update of an optional
//              string value in the registry.  The update takes place when
//              the Update() method is called.  When the object is destroyed
//              the operation is undone, unless the Commit() method has been
//              called.
//
//              This class simplifies the writing of APIs like
//              ChangeServiceConfig2.
//
//  History:    27-Nov-96 AnirudhS  Created.
//
//--------------------------------------------------------------------------

class CUpdateOptionalString
{
public:
            CUpdateOptionalString (HKEY Key, LPCWSTR ValueName) :
                    _Key(Key),
                    _ValueName(ValueName),
                    _UndoNeeded(FALSE)
                        { }
           ~CUpdateOptionalString();
    DWORD   Update (LPCWSTR NewValue);
    void    Commit ()
                        { _UndoNeeded = FALSE; }

private:
    HKEY        _Key;
    LPCWSTR     _ValueName;
    CHeapPtr< LPWSTR >  _OldValue;
    BOOL        _UndoNeeded;
};



DWORD
CUpdateOptionalString::Update(
    IN LPCWSTR NewValue
    )
/*++

Routine Description:

    See class definition.

--*/
{
    // This method should be called only once in the object's lifetime
    SC_ASSERT(_UndoNeeded == FALSE && _OldValue == NULL);

    //
    // Read the old value.
    //
    DWORD Error = ScReadOptionalString(_Key, _ValueName, &_OldValue);
    if (Error != ERROR_SUCCESS)
    {
        return Error;
    }

    //
    // Write the new value.  Note that NULL means no change.
    //
    Error = ScWriteOptionalString(_Key, _ValueName, NewValue);

    //
    // Remember whether the change needs to be undone.
    //
    if (Error == ERROR_SUCCESS && NewValue != NULL)
    {
        _UndoNeeded = TRUE;
    }

    return Error;
}




CUpdateOptionalString::~CUpdateOptionalString(
    )
/*++

Routine Description:

    See class definition.

--*/
{
    if (_UndoNeeded)
    {
        DWORD Error = ScWriteOptionalString(
                            _Key,
                            _ValueName,
                            _OldValue ? _OldValue : L""
                            );

        if (Error != ERROR_SUCCESS)
        {
            // Nothing we can do about it
            SC_LOG3(ERROR, "Couldn't roll back update to %ws value, error %lu."
                           "  Old value was \"%ws\".\n",
                           _ValueName, Error, _OldValue);
        }
    }
}



DWORD
RChangeServiceConfig2W(
    IN  SC_RPC_HANDLE       hService,
    IN  SC_RPC_CONFIG_INFOW Info
    )

/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    SC_LOG(CONFIG_API, "In RChangeServiceConfig2W for service handle %#lx\n", hService);

#if DBG == 1
    PrintConfig2Parms(hService,
                      Info);
#endif // DBG == 1

    if (ScShutdownInProgress)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Do we have permission to do this?
    //
    if (!RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT) hService)->AccessGranted,
              SERVICE_CHANGE_CONFIG
              ))
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Lock database, as we want to add stuff without other threads tripping
    // on our feet.
    //
    CServiceRecordExclusiveLock RLock;

    //
    // Find the service record for this handle.
    //
    LPSERVICE_RECORD serviceRecord =
        ((LPSC_HANDLE_STRUCT) hService)->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT(serviceRecord != NULL);
    SC_ASSERT(serviceRecord->Signature == SERVICE_SIGNATURE);

    //
    // Disallow this call if record is marked for delete.
    //
    if (DELETE_FLAG_IS_SET(serviceRecord))
    {
        return ERROR_SERVICE_MARKED_FOR_DELETE;
    }

    //-----------------------------
    //
    // Begin Updating the Registry
    //
    //-----------------------------
    HKEY  ServiceNameKey = NULL;
    DWORD ApiStatus = ScOpenServiceConfigKey(
                            serviceRecord->ServiceName,
                            KEY_WRITE | KEY_READ,
                            FALSE,              // don't create if missing
                            &ServiceNameKey
                            );
    if (ApiStatus != NO_ERROR)
    {
        goto Cleanup;
    }


    switch (FLDREF(Info,dwInfoLevel))
    {
    //-----------------------------
    //
    // Service Description
    //
    //-----------------------------
    case SERVICE_CONFIG_DESCRIPTION:

        //
        // NULL means no change
        //
        if (FLDREF(Info,psd) == NULL)
        {
            ApiStatus = NO_ERROR;
            break;
        }

        ApiStatus = ScWriteDescription(ServiceNameKey, FLDREF(Info,psd->lpDescription));
        break;

    //-----------------------------
    //
    // Service Failure Actions
    //
    //-----------------------------
    case SERVICE_CONFIG_FAILURE_ACTIONS:
        {
            LPSERVICE_FAILURE_ACTIONSW psfa = FLDREF(Info,psfa);

            //
            // NULL means no change
            //
            if (psfa == NULL)
            {
                ApiStatus = NO_ERROR;
                break;
            }

            //
            // Validate the structure and permissions
            //
            if (psfa->lpsaActions != NULL &&
                psfa->cActions != 0)
            {
                //
                // These settings are only valid for Win32 services
                //
                if (! (serviceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32))
                {
                    ApiStatus = ERROR_CANNOT_DETECT_DRIVER_FAILURE;
                    break;
                }

                BOOL RebootRequested = FALSE;
                BOOL RestartRequested = FALSE;
                for (DWORD i = 0; i < psfa->cActions; i++)
                {
                    SC_ACTION_TYPE Type = psfa->lpsaActions[i].Type;
                    if (Type == SC_ACTION_RESTART)
                    {
                        RestartRequested = TRUE;
                    }
                    else if (Type == SC_ACTION_REBOOT)
                    {
                        RebootRequested = TRUE;
                    }
                    else if (ACTION_TYPE_INVALID(Type))
                    {
                        SC_LOG(ERROR, "RChangeServiceConfig2W: invalid action type %#lx\n", Type);
                        ApiStatus = ERROR_INVALID_PARAMETER;
                        goto Cleanup;
                    }
                }

                if (RestartRequested)
                {
                    if (!RtlAreAllAccessesGranted(
                              ((LPSC_HANDLE_STRUCT) hService)->AccessGranted,
                              SERVICE_START
                              ))
                    {
                        SC_LOG0(ERROR, "Service handle lacks start access\n");
                        ApiStatus = ERROR_ACCESS_DENIED;
                        break;
                    }
                }

                if (RebootRequested)
                {
                    NTSTATUS Status = ScPrivilegeCheckAndAudit(
                                            SE_SHUTDOWN_PRIVILEGE,
                                            hService,
                                            SERVICE_CHANGE_CONFIG
                                            );
                    if (!NT_SUCCESS(Status))
                    {
                        SC_LOG0(ERROR, "Caller lacks shutdown privilege\n");
                        ApiStatus = ERROR_ACCESS_DENIED;
                        break;
                    }
                }

                //
                // Get the service's image path
                //
                CHeapPtr<LPWSTR> ImageName;
                ApiStatus = ScGetImageFileName(serviceRecord->ServiceName, &ImageName);
                if (ApiStatus != NO_ERROR)
                {
                    SC_LOG(ERROR,"RChangeServiceConfig2W: GetImageFileName failed %lu\n", ApiStatus);
                    break;
                }

                //
                // If the service runs in services.exe, we certainly won't
                // detect if the service process dies, so don't pretend we will
                //
                if (ScImagePathsMatch(ImageName, ScGlobalThisExePath))
                {
                    ApiStatus = ERROR_CANNOT_DETECT_PROCESS_ABORT;
                    break;
                }
            }

            //
            // Write the string values, followed by the non-string values.
            // If anything fails, the values written up to that point will be
            // backed out.
            // (Backing out the update of the non-string values is a little
            // more complicated than backing out the string updates.  So we
            // do the non-string update last, to avoid having to back it out.)
            //
            CUpdateOptionalString UpdateRebootMessage
                        (ServiceNameKey, REBOOTMESSAGE_VALUENAME_W);
            CUpdateOptionalString UpdateFailureCommand
                        (ServiceNameKey, FAILURECOMMAND_VALUENAME_W);

            if ((ApiStatus = UpdateRebootMessage.Update(psfa->lpRebootMsg)) == ERROR_SUCCESS &&
                (ApiStatus = UpdateFailureCommand.Update(psfa->lpCommand)) == ERROR_SUCCESS &&
                (ApiStatus = ScWriteFailureActions(ServiceNameKey, psfa)) == ERROR_SUCCESS)
            {
                UpdateRebootMessage.Commit();
                UpdateFailureCommand.Commit();
            }
        }
        break;

    //-----------------------------
    //
    // Other (invalid)
    //
    //-----------------------------
    default:
        ApiStatus = ERROR_INVALID_LEVEL;
        break;
    }

Cleanup:

    if (ServiceNameKey != NULL)
    {
        ScRegFlushKey(ServiceNameKey);
        ScRegCloseKey(ServiceNameKey);
    }

    SC_LOG1(CONFIG_API, "RChangeServiceConfig2W returning %lu\n", ApiStatus);

    return ApiStatus;
}



DWORD
RQueryServiceConfig2W(
    IN  SC_RPC_HANDLE       hService,
    IN  DWORD               dwInfoLevel,
    OUT LPBYTE              lpBuffer,
    IN  DWORD               cbBufSize,
    OUT LPDWORD             pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    SC_LOG(CONFIG_API, "In RQueryServiceConfig2W for service handle %#lx\n", hService);

    if (ScShutdownInProgress)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // MIDL doesn't support optional [out] parameters efficiently, so
    // we require these parameters.
    //
    if (lpBuffer == NULL || pcbBytesNeeded == NULL)
    {
        SC_ASSERT(!"RPC passed NULL for [out] pointers");
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Do we have permission to do this?
    //
    if (!RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT) hService)->AccessGranted,
              SERVICE_QUERY_CONFIG
              ))
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Initialize *pcbBytesNeeded.  It is incremented below.
    // (For consistency with QueryServiceConfig, it is set even on a success
    // return.)
    //
    *pcbBytesNeeded = 0;

    //
    // Lock database, as we want to look at stuff without other threads changing
    // fields at the same time.
    //
    CServiceRecordSharedLock RLock;

    LPSERVICE_RECORD serviceRecord =
        ((LPSC_HANDLE_STRUCT) hService)->Type.ScServiceObject.ServiceRecord;
    SC_ASSERT(serviceRecord != NULL);


    //
    // Open the service name key.
    //
    HKEY  ServiceNameKey = NULL;
    DWORD ApiStatus = ScOpenServiceConfigKey(
                    serviceRecord->ServiceName,
                    KEY_READ,
                    FALSE,               // Create if missing
                    &ServiceNameKey
                    );

    if (ApiStatus != NO_ERROR)
    {
        return ApiStatus;
    }


    switch (dwInfoLevel)
    {
    //-----------------------------
    //
    // Service Description
    //
    //-----------------------------
    case SERVICE_CONFIG_DESCRIPTION:
        {
            *pcbBytesNeeded = sizeof(SERVICE_DESCRIPTION_WOW64);

            //
            // Read the string from the registry
            //
            CHeapPtr< LPWSTR > pszDescription;
            ApiStatus = ScReadDescription(
                                ServiceNameKey,
                                &pszDescription,
                                pcbBytesNeeded
                                );

            SC_ASSERT(ApiStatus != ERROR_INSUFFICIENT_BUFFER);

            if (ApiStatus != NO_ERROR)
            {
                break;
            }

            //
            // Check for sufficient buffer space
            //
            if (cbBufSize < *pcbBytesNeeded)
            {
                ApiStatus = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            //
            // Copy the information to the output buffer
            // The format is:
            //   SERVICE_DESCRIPTION_WOW64 struct
            //   description string
            // Pointers in the struct are replaced with offsets based at the
            // start of the buffer.  NULL pointers remain NULL.
            //
            COutBuf OutBuf(lpBuffer);

            LPSERVICE_DESCRIPTION_WOW64 psdOut =
                (LPSERVICE_DESCRIPTION_WOW64) OutBuf.Next();
            OutBuf.AddUsed(sizeof(SERVICE_DESCRIPTION_WOW64));
            SC_ASSERT(COUNT_IS_ALIGNED(OutBuf.OffsetNext(), sizeof(WCHAR)));

            if (pszDescription != NULL)
            {
                psdOut->dwDescriptionOffset = OutBuf.OffsetNext();
                OutBuf.AppendBytes(pszDescription, (DWORD) WCSSIZE(pszDescription));
            }
            else
            {
                psdOut->dwDescriptionOffset = 0;
            }
        }
        break;

    //-----------------------------
    //
    // Service Failure Actions
    //
    //-----------------------------
    case SERVICE_CONFIG_FAILURE_ACTIONS:
        {
            //
            // Read the non-string info
            //
            CHeapPtr< LPSERVICE_FAILURE_ACTIONS_WOW64 > psfa;

            ApiStatus = ScReadFailureActions(ServiceNameKey, &psfa, pcbBytesNeeded);
            if (ApiStatus != NO_ERROR)
            {
                break;
            }
            if (psfa == NULL)
            {
                SC_ASSERT(*pcbBytesNeeded == 0);
                *pcbBytesNeeded = sizeof(SERVICE_FAILURE_ACTIONS_WOW64);
            }
            SC_ASSERT(COUNT_IS_ALIGNED(*pcbBytesNeeded, sizeof(WCHAR)));

            //
            // Read the string values
            //
            CHeapPtr< LPWSTR > RebootMessage;

            ApiStatus = ScReadRebootMessage(
                                ServiceNameKey,
                                &RebootMessage,
                                pcbBytesNeeded
                                );
            if (ApiStatus != NO_ERROR)
            {
                break;
            }
            SC_ASSERT(COUNT_IS_ALIGNED(*pcbBytesNeeded, sizeof(WCHAR)));

            CHeapPtr< LPWSTR > FailureCommand;

            ApiStatus = ScReadFailureCommand(
                                ServiceNameKey,
                                &FailureCommand,
                                pcbBytesNeeded
                                );
            if (ApiStatus != NO_ERROR)
            {
                break;
            }

            //
            // Check for sufficient buffer space
            //
            if (cbBufSize < *pcbBytesNeeded)
            {
                ApiStatus = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            //
            // Copy the information to the output buffer
            // The format is:
            //   SERVICE_FAILURE_ACTIONS_WOW64 struct
            //   SC_ACTIONS array
            //   strings
            // Pointers in the struct are replaced with offsets based at the
            // start of the buffer.  NULL pointers remain NULL.
            //
            COutBuf OutBuf(lpBuffer);

            LPSERVICE_FAILURE_ACTIONS_WOW64 psfaOut =
                (LPSERVICE_FAILURE_ACTIONS_WOW64) OutBuf.Next();

            if (psfa != NULL)
            {
                psfaOut->dwResetPeriod = ((LPSERVICE_FAILURE_ACTIONS_WOW64) psfa)->dwResetPeriod;
                psfaOut->cActions      = ((LPSERVICE_FAILURE_ACTIONS_WOW64) psfa)->cActions;
            }
            else
            {
                psfaOut->dwResetPeriod = 0;
                psfaOut->cActions      = 0;
            }
            OutBuf.AddUsed(sizeof(SERVICE_FAILURE_ACTIONS_WOW64));

            if (psfaOut->cActions != 0)
            {
                psfaOut->dwsaActionsOffset = OutBuf.OffsetNext();

                OutBuf.AppendBytes(psfa + 1,
                                   psfaOut->cActions * sizeof(SC_ACTION));
            }
            else
            {
                psfaOut->dwsaActionsOffset = 0;
            }
            SC_ASSERT(COUNT_IS_ALIGNED(OutBuf.OffsetNext(), sizeof(WCHAR)));

            if (RebootMessage != NULL)
            {
                psfaOut->dwRebootMsgOffset = OutBuf.OffsetNext();
                OutBuf.AppendBytes(RebootMessage, (DWORD) WCSSIZE(RebootMessage));
            }
            else
            {
                psfaOut->dwRebootMsgOffset = 0;
            }

            if (FailureCommand != NULL)
            {
                psfaOut->dwCommandOffset = OutBuf.OffsetNext();
                OutBuf.AppendBytes(FailureCommand, (DWORD) WCSSIZE(FailureCommand));
            }
            else
            {
                psfaOut->dwCommandOffset = 0;
            }
        }
        break;

    //-----------------------------
    //
    // Other (invalid)
    //
    //-----------------------------
    default:
        ApiStatus = ERROR_INVALID_LEVEL;
        break;
    }


    ScRegCloseKey(ServiceNameKey);

    SC_LOG1(CONFIG_API, "RQueryServiceConfig2W returning %lu\n", ApiStatus);

    return ApiStatus;
}



#if DBG == 1

VOID
PrintConfig2Parms(
    IN  SC_RPC_HANDLE       hService,
    IN  SC_RPC_CONFIG_INFOW Info
    )
{
    KdPrintEx((DPFLTR_SCSERVER_ID,
               DEBUG_CONFIG_API,
               "Parameters to RChangeServiceConfig2W:\n"));

    LPSTR psz;
    switch (Info.dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        psz = "SERVICE_CONFIG_DESCRIPTION";
        break;
    case SERVICE_CONFIG_FAILURE_ACTIONS:
        psz = "SERVICE_CONFIG_FAILURE_ACTIONS";
        break;
    default:
        psz = "invalid";
        break;
    }
    KdPrintEx((DPFLTR_SCSERVER_ID,
               DEBUG_CONFIG_API,
               "  dwInfoLevel = %ld (%s)\n", Info.dwInfoLevel,
               psz));

    switch (Info.dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:

        if (Info.psd == NULL)
        {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_CONFIG_API,
                       "  NULL information pointer -- no action requested\n\n"));

            break;
        }

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  pszDescription = \"%ws\"\n",
                   Info.psd->lpDescription));

        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        if (Info.psfa == NULL)
        {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_CONFIG_API,
                       "  NULL information pointer -- no action requested\n\n"));

            break;
        }

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  dwResetPeriod = %ld\n",
                   Info.psfa->dwResetPeriod));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  lpRebootMsg   = \"%ws\"\n",
                   Info.psfa->lpRebootMsg));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  lpCommand     = \"%ws\"\n",
                   Info.psfa->lpCommand));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_CONFIG_API,
                   "  %ld failure %s\n",
                   Info.psfa->cActions,
                   Info.psfa->cActions == 0 ? "actions." :
                       Info.psfa->cActions == 1 ? "action:"  : "actions:"));

        if (Info.psfa->lpsaActions == NULL)
        {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_CONFIG_API,
                       "  NULL array pointer -- no change in fixed info\n\n"));
        }
        else
        {
            for (DWORD i = 0; i < Info.psfa->cActions; i++)
            {
                SC_ACTION& sa = Info.psfa->lpsaActions[i];
                KdPrintEx((DPFLTR_SCSERVER_ID,
                           DEBUG_CONFIG_API,
                           "    %ld: Action %ld, Delay %ld\n",
                           i,
                           sa.Type,
                           sa.Delay));
            }
        }
        break;
    }

    KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_CONFIG_API, "\n"));
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\control.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    control.cxx

Abstract:

    Contains code for setting up and maintaining the control interface
    and sending controls to services. Functions in this module:

    RControlService
    RI_ScSendTSMessage
    ScCreateControlInstance
    ScWaitForConnect
    ScSendControl
    ScInitTransactNamedPipe
    ScShutdownAllServices

Author:

    Dan Lafferty (danl)     20-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    13-Mar-1999     jschwart
    Added per-account security on the SCM <--> service control pipe

    07-Apr-1998     jschwart
    ScInitTransactNamedPipe:  Check registry for a user-supplied named
    pipe timeout value before setting it to the default.  With the old
    default (30000 ms), services could be double-started on a heavily
    loaded machine when the server would send to the client, the client's
    response would time out, and the server would assume it hadn't started.

    10-Mar-1998     jschwart
    Added ScSendPnPMessage and code to ScSendControl to enable passing
    of PnP-related service controls to services.  Got rid of flag added
    on 06-Aug-1997 since we can just check the passed-in OpCode instead

    06-Aug-1997     jschwart
        SendControl:  Added flag to tell SendControl if it is sending a
        shutdown message.  If so, it uses WriteFile, since using
        TransactNamedPipe with a poorly behaved service (that doesn't send
        an ACK back to the SCM) otherwise hangs the SCM.

        ShutdownAllServices:  Since SendControl now uses WriteFile (asynch
        write), added a case to the switch that checks to see if any services
        are still running.  If so, it gives them 30 seconds to become
        STOP_PENDING before it gives up and shuts itself down.

    05-Mar-1997     AnirudhS
    Eliminated limit of 100 pipe instances.

    04-Mar-1997     AnirudhS
    Added PARAMCHANGE, NETBINDADD, etc. controls for Plug and Play.

    28-May-1996     AnirudhS
    ScSendControl, ScWaitForConnect and ScCleanoutPipe:  If we time out
    waiting for a named pipe operation to complete, cancel it before
    returning.  Otherwise it trashes the stack if it does complete later.

    21-Feb-1995     AnirudhS
    ScShutdownAllServices: Fixed logic to wait for services in pending
    stop state.

    19-Oct-1993     Danl
    Initialize the Overlapped structures that are allocated on the stack.

    20-Jul-1993     danl
    SendControl:  If we get ERROR_PIPE_BUSY back from the transact call,
    then we need to clean out the pipe by reading it first - then do
    the transact.

    29-Dec-1992     danl
    Simplified calculation of elapsed time.  This removed complier
    warning about overflow in constant arithmetic.

    06-Mar-1992     danl
    SendControl: Fixed heap trashing problem where it didn't allocate
    the 4 extra alignment bytes in the case where there are no arguments.
    The registry name path becomes an argument even if there are no
    other agruments.  Therefore it requires alignment for any start cmd.

    20-Feb-1992     danl
    Get Pipe Handle only after we know we have an active service & the
    image record is good.

    20-Feb-1992     danl
    Only add 4 extra alignment bytes to control buffer when there
    are arguments to pass.

    31-Oct-1991     danl
    Fixed the logic governing the behavior under various service state
    and control opcode conditions.  Added State Table to description.
    This logic was taken directly from LM2.0.

    03-Sept-1991    danl
    Fixed alignment problem when marshalling args in ScSendControl.
    The array of offsets needs to be 4 byte aligned after the Service
    Name.

    20-Mar-1991     danl
    created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <stdlib.h>     // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <align.h>      // ROUND_UP_POINTER macro
#include <control.h>
#include <scseclib.h>   // ScCreateAndSetSD
#include "depend.h"     // ScDependentsStopped()
#include "driver.h"     // ScControlDriver()
#include "sclib.h"      // ScIsValidServiceName()
#include "scsec.h"      // ScStatusAccessCheck()
#include "valid.h"      // MAX_SERVICE_NAME_LENGTH

#include <dbt.h>        // PDEV_BROADCAST_HDR

#include <ntrpcp.h>     // Rpcp... function prototypes
#include <svcs.h>       // SVCS_RPC_PIPE, SVCS_LRPC_PROTOCOl, SVCS_LRPC_PORT
#include <scesrv.h>


//
// Constants
//
#define SC_DEFAULT_PIPE_TRANSACT_TIMEOUT    30000   // 30 sec
#define SC_PIPE_CLEANOUT_TIMEOUT            30      // 30 msec

//
// Registry key and value for the pipe timeout value
//
#define REGKEY_PIPE_TIMEOUT     L"System\\CurrentControlSet\\Control"
#define REGVAL_PIPE_TIMEOUT     L"ServicesPipeTimeout"

//
// Registry key, value, and constant for the shutdown performance metric
//
// #define SC_SHUTDOWN_METRIC

#ifdef SC_SHUTDOWN_METRIC

#define REGKEY_SHUTDOWN_TIMEOUT L"System\\CurrentControlSet\\Control"
#define REGVAL_SHUTDOWN_TIMEOUT L"ShutdownTimeout"

#endif  // SC_SHUTDOWN_METRIC

//
// STATIC DATA
//

/* static */ CRITICAL_SECTION   ScTransactNPCriticalSection;

//
// Globals
//
DWORD   g_dwScPipeTransactTimeout = SC_DEFAULT_PIPE_TRANSACT_TIMEOUT;


//
// Local Structure/Function Prototypes
//
typedef struct
{
    WCHAR   lpServiceName[MAX_SERVICE_NAME_LENGTH + 1];
    WCHAR   lpDisplayName[MAX_SERVICE_NAME_LENGTH + 1];
    HANDLE  hPipe;
}
TS_CONTROL_INFO, *PTS_CONTROL_INFO, *LPTS_CONTROL_INFO;

VOID
ScCleanOutPipe(
    HANDLE  PipeHandle
    );


/****************************************************************************/
DWORD
RControlService (
    IN  SC_RPC_HANDLE       hService,
    IN  DWORD               OpCode,
    OUT LPSERVICE_STATUS    lpServiceStatus
    )

/*++

Routine Description:

    RPC entry point for the RControlService API function.

    The following state table describes what is to happen under various
    state/Opcode conditions:

                                            [OpCode]

                                   STOP    INTERROGATE     OTHER
      [Current State]          _____________________________________
                              |           |            |            |
                      STOPPED |   (c)     |    (c)     |    (c)     |
                              |           |            |            |
                 STOP_PENDING |   (b)     |    (b)     |    (b)     |
                              |           |            |            |
                   START_PEND |   (a)     |    (d)     |    (b)     |
                              |           |            |            |
                      RUNNING |   (a)     |    (a)     |    (a)     |
                              |           |            |            |
                CONTINUE_PEND |   (a)     |    (a)     |    (a)     |
                              |           |            |            |
                PAUSE_PENDING |   (a)     |    (a)     |    (a)     |
                              |           |            |            |
                       PAUSED |   (a)     |    (a)     |    (a)     |
                              |___________|____________|____________|

    (a) Send control code to the service if the service is set up
        to receive this type of opcode.  If it is not set up to
        receive the opcode, return ERROR_INVALID_SERVICE_CONTROL.
        An example of this would be the case of sending a PAUSE to a
        service that is listed as NOT_PAUSABLE.

    (b) Do NOT send control code to the service.  Instead return
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL.

    (c) Do NOT send control code to the service.  Instead, return
        ERROR_SERVICE_NOT_ACTIVE.

    (d) Do NOT send control code to the service.  Instead, return
        the last known state of the service with a SUCCESS status.
        NOTE -- this case (and this case only) differs from the
        SDK doc, which hides the fact that you can interrogate a
        service that's in the START_PENDING state


Arguments:

    hService - This is a handle to the service.  It is actually a pointer
    to a service handle structure.

    OpCode - The control request code.

    lpServiceStatus - pointer to a location where the service status is to
    be returned.  If this pointer is invalid, it will be set to NULL
    upon return.

Return Value:

    The returned lpServiceStatus structure is valid as long as the returned
    status is NO_ERROR.

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The handle passed in was not a valid hService
    handle.

    NERR_InternalError - LocalAlloc or TransactNamedPipe failed, or
    TransactNamedPipe returned fewer bytes than expected.

    ERROR_SERVICE_REQUEST_TIMEOUT - The service did not respond with a status
    message within the fixed timeout limit (RESPONSE_WAIT_TIMEOUT).

    NERR_ServiceKillProc - The service process had to be killed because
    it wouldn't terminate when requested.

    ERROR_SERVICE_CANNOT_ACCEPT_CTRL - The service cannot accept control
    messages at this time.

    ERROR_INVALID_SERVICE_CONTROL - The request is not valid for this service.
    For instance, a PAUSE request is not valid for a service that
    lists itself as NOT_PAUSABLE.

    ERROR_INVALID_PARAMETER - The requested control is not valid.

    ERROR_ACCESS_DENIED - This is a status response from the service
    security check.


Note:
    Because there are multiple services in a process, we cannot simply
    kill the process if the service does not respond to a terminate
    request.  This situation is handled by first checking to see if
    this is the last service in the process.  If it is, then it is
    removed from the installed database, and the process is terminated.
    If it isn't the last service, then we indicate timeout and do
    nothing.

--*/

{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    serviceRecord;
    DWORD               currentState;
    DWORD               controlsAccepted;
    DWORD               controlsAcceptedMask = 0;
    HANDLE              pipeHandle = NULL;
    LPWSTR              serviceName = NULL;
    LPWSTR              displayName = NULL;
    ACCESS_MASK         desiredAccess;


    if (ScShutdownInProgress)
    {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Set the desired access based on the control requested.
    // Figure out which "controls accepted" bits must be set for the
    // service to accept the control.
    //

    switch (OpCode) {
    case SERVICE_CONTROL_STOP:
        desiredAccess = SERVICE_STOP;
        controlsAcceptedMask = SERVICE_ACCEPT_STOP;
        break;

    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
        desiredAccess = SERVICE_PAUSE_CONTINUE;
        controlsAcceptedMask = SERVICE_ACCEPT_PAUSE_CONTINUE;
        break;

    case SERVICE_CONTROL_INTERROGATE:
        desiredAccess = SERVICE_INTERROGATE;
        break;

    case SERVICE_CONTROL_PARAMCHANGE:
        desiredAccess = SERVICE_PAUSE_CONTINUE;
        controlsAcceptedMask = SERVICE_ACCEPT_PARAMCHANGE;
        break;

    case SERVICE_CONTROL_NETBINDADD:
    case SERVICE_CONTROL_NETBINDREMOVE:
    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:
        desiredAccess = SERVICE_PAUSE_CONTINUE;
        controlsAcceptedMask = SERVICE_ACCEPT_NETBINDCHANGE;
        break;

    default:
        if ((OpCode >= OEM_LOWER_LIMIT) &&
            (OpCode <= OEM_UPPER_LIMIT))
        {
            desiredAccess = SERVICE_USER_DEFINED_CONTROL;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Was the handle opened with desired control access?
    //
    if (! RtlAreAllAccessesGranted(
          ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
          desiredAccess))
    {
        return(ERROR_ACCESS_DENIED);
    }

    serviceRecord = ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;


    //
    // If this control is for a driver, call ScControlDriver and return.
    //
    if (serviceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER)
    {
        return(ScControlDriver(OpCode, serviceRecord, lpServiceStatus));
    }


    //
    // Obtain a shared lock on the database - read the data we need,
    // Then free the lock.
    //
    {
        CServiceRecordSharedLock RLock;

        //
        // Once we get to this point, copy in the last known
        // status to return to the caller (Bug #188874)
        //

        RtlCopyMemory(lpServiceStatus,
                      &(serviceRecord->ServiceStatus),
                      sizeof(SERVICE_STATUS));

        currentState     = serviceRecord->ServiceStatus.dwCurrentState;
        controlsAccepted = serviceRecord->ServiceStatus.dwControlsAccepted;

        serviceName = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                          2 * (MAX_SERVICE_NAME_LENGTH + 1) * sizeof(WCHAR));

        if (serviceName == NULL)
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            displayName = serviceName + MAX_SERVICE_NAME_LENGTH + 1;

            wcscpy(serviceName, serviceRecord->ServiceName);
            wcscpy(displayName, serviceRecord->DisplayName);

            //
            // If we can obtain a pipe handle, do so.  Otherwise, return an error.
            // (but first release the lock).  Refcount the pipe handle to make sure
            // it doesn't go away while we're sending this control as ScSendControl
            // doesn't hold locks around the transact.
            //

            if ((currentState != SERVICE_STOPPED) &&
                (serviceRecord->ImageRecord != NULL))
            {
                if (!DuplicateHandle(GetCurrentProcess(),
                                     serviceRecord->ImageRecord->PipeHandle,
                                     GetCurrentProcess(),
                                     &pipeHandle,
                                     0,
                                     FALSE,
                                     DUPLICATE_SAME_ACCESS))
                {
                    pipeHandle = NULL;
                    status = GetLastError();
                }
            }
            else
            {
                status = ERROR_SERVICE_NOT_ACTIVE;
            }
        }
    }

    if (status != NO_ERROR)
    {
        goto CleanExit;
    }

    //
    // The control is not sent to the service if the service is in
    // either the STOP_PENDING or START_PENDING state EXCEPT - we
    // allow STOP controls to a service that is START_PENDING.
    //
    // If we decide not to allow the control to be sent, we either
    // return current info (INTERROGATE) or an error (any other opcode).
    //
    if (currentState == SERVICE_STOP_PENDING)
    {
        status = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
        goto CleanExit;
    }
    else if (currentState == SERVICE_START_PENDING)
    {
        switch (OpCode)
        {
            case SERVICE_CONTROL_INTERROGATE:

                //
                // Just return the last known status.  This behavior is unpublished.
                //

                status = NO_ERROR;
                goto CleanExit;

            case SERVICE_CONTROL_STOP:
                break;

            default:
                status = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
                goto CleanExit;
        }
    }

    //
    // Check if the service accepts the control.
    //
    if ( (controlsAccepted & controlsAcceptedMask) != controlsAcceptedMask )
    {
        status = ERROR_INVALID_SERVICE_CONTROL;
        goto CleanExit;
    }

    //
    // Check for dependent services still running
    //
    BOOL fLastService = FALSE;

    if (OpCode == SERVICE_CONTROL_STOP)
    {
        CServiceRecordSharedLock RLock;

        if (! ScDependentsStopped(serviceRecord))
        {
            status = ERROR_DEPENDENT_SERVICES_RUNNING;
            goto CleanExit;
        }

        if (serviceRecord->ImageRecord != NULL &&
            serviceRecord->ImageRecord->ServiceCount == 1)
        {
            fLastService = TRUE;
        }
    }

    //
    // Send the control request to the target service
    //

    status = ScSendControl(serviceName,    // ServiceName
                           displayName,    // DisplayName
                           pipeHandle,     // pipeHandle
                           OpCode,         // Opcode
                           NULL,           // CmdArgs (vector ptr)
                           0L,             // NumArgs
                           NULL);          // Ignore handler return value

    if (status == NO_ERROR)
    {
        //
        // If no errors occured, copy the latest status into the return
        // buffer.  The shared lock is required for this.
        //
        CServiceRecordSharedLock RLock;

        RtlCopyMemory(lpServiceStatus,
                      &(serviceRecord->ServiceStatus),
                      sizeof(SERVICE_STATUS));
    }
    else
    {
        SC_LOG2(ERROR,"RControlService:SendControl to %ws service failed %ld\n",
            serviceRecord->ServiceName, status);

        if (OpCode == SERVICE_CONTROL_STOP)
        {
            //
            // If sending the control failed, and the control was a request
            // to stop, and if this service is the only running service in
            // the process, we can force the process to stop.  ScRemoveService
            // will handle this if the ServiceCount is one.
            //

            if (fLastService)
            {
                SC_LOG0(TRACE,"RControlService:Forcing Service Shutdown\n");
                ScRemoveService(serviceRecord);
            }
        }
    }

CleanExit:

    LocalFree(serviceName);

    if (pipeHandle != NULL)
    {
        CloseHandle(pipeHandle);
    }    

    return status;
}



/****************************************************************************/
DWORD
ScCreateControlInstance (
    OUT LPHANDLE    PipeHandlePtr,
    IN  DWORD       dwCurrentService,
    IN  PSID        pAccountSid
    )

/*++

Routine Description:

    This function creates an instance of the control pipe

Arguments:

    PipeHandlePtr - This is a pointer to a location where the pipe handle
                    is to be placed upon return.

    dwCurrentService - This is used to create a uniquely-named pipe

    pAccountSid - The SID of the account that is allowed to access this pipe

Return Value:

    NO_ERROR - The operation was successful.

    other - Any error returned by CreateNamedPipe could be returned.

--*/
{
    DWORD                status;

    NTSTATUS             ntstatus;
    SECURITY_ATTRIBUTES  SecurityAttr;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    WCHAR wszPipeName[sizeof(CONTROL_PIPE_NAME) / sizeof(WCHAR) + PID_LEN] = CONTROL_PIPE_NAME;

    SC_ACE_DATA AceData[1] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
            GENERIC_ALL,                  &pAccountSid}

        };

    //
    // Generate the pipe name
    //
    _itow(dwCurrentService, wszPipeName + sizeof(CONTROL_PIPE_NAME) / sizeof(WCHAR) - 1, 10);

    //
    // Create a security descriptor for the control named pipe so
    // that we can grant access to it solely to the service's account
    //
    ntstatus = ScCreateAndSetSD(
           AceData,
           1,
           LocalSystemSid,
           LocalSystemSid,
           &SecurityDescriptor
           );

    if (! NT_SUCCESS(ntstatus)) {

        SC_LOG1(ERROR, "ScCreateAndSetSD failed " FORMAT_NTSTATUS
            "\n", ntstatus);
        return (RtlNtStatusToDosError(ntstatus));
    }

    SecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttr.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttr.bInheritHandle = FALSE;

    //
    // Create the service controller's end of the named pipe that will
    // be used for communicating control requests to the service process.
    // Use FILE_FLAG_FIRST_PIPE_INSTANCE to make sure that we're the
    // creator of the named pipe (vs. a malicious process that creates
    // the pipe first and thereby gains access to the client service
    // that connects to it).
    //

    *PipeHandlePtr = CreateNamedPipe (
            wszPipeName,
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
            PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE,
            1,                         // one instance per process
            8000,
            sizeof(PIPE_RESPONSE_MSG),
            CONTROL_TIMEOUT,           // Default Timeout
            &SecurityAttr);            // Security Descriptor

    status = NO_ERROR;

    if (*PipeHandlePtr == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        SC_LOG1(ERROR,
            "CreateControlInstance: CreateNamedPipe failed, %ld\n",status);
    }

    (void) RtlDeleteSecurityObject(&SecurityDescriptor);
    return(status);
}


/****************************************************************************/
DWORD
ScWaitForConnect (
    IN  HANDLE    PipeHandle,
    IN  HANDLE    hProcess       OPTIONAL,
    IN  LPWSTR    lpDisplayName,
    OUT LPDWORD   ProcessIdPtr
    )

/*++

Routine Description:

    This function waits until a connection is made to the pipe handle.
    It then waits for the first status message to be sent from the
    service process.

    The first message from the service contains the processId.  This
    helps to verify that we are talking to the correct process.

Arguments:

    PipeHandle - This is the handle to the pipe instance that is waiting
                 for a connect.

    hProcess - The handle to the service process.  We wait on this handle
               and the pipe handle in case the process exits before the
               pipe transaction times out.

    lpDisplayName - The name of the service for which we're waiting.

    ProcessIdPtr - This is a pointer to the location where the processId is
                   to be stored.

Return Value:

    NO_ERROR - The pipe is in the connected state.

    any error that ReadFile can produce may be returned.

Note:
    The ConnectNamedPipe called is done asynchronously and we wait
    on its completion using the pipe handle.  This can only work
    correctly when it is guaranteed that no other IO is issued
    while we are waiting on the pipe handle (except for the service
    itself to connect to the pipe with call to CreateFile).

--*/
{
    PIPE_RESPONSE_MSG   serviceResponseBuffer;
    DWORD               numBytesRead;
    BOOL                status;
    DWORD               apiStatus;
    OVERLAPPED          overlapped={0,0,0,0,0};// overlapped structure to implement
                           // timeout on TransactNamedPipe

    CONST HANDLE phHandles[] = { PipeHandle, hProcess };
    DWORD        dwCount     = (hProcess == NULL ? 1 : 2);

#if DBG

    DWORD   dwStartTick;
    DWORD   dwTotalTime;

#endif  // DBG


    SC_LOG(TRACE,"ServiceController waiting for pipe connect\n",0);

    overlapped.hEvent = (HANDLE) NULL;   // Wait on pipe handle

    //
    // Wait for the service to connect.
    //
    status = ConnectNamedPipe(PipeHandle, &overlapped);

    if (status == FALSE) {

        apiStatus = GetLastError();

        if (apiStatus == ERROR_IO_PENDING) {

#if DBG

            dwStartTick = GetTickCount();

#endif  // DBG

            //
            // Connection is pending
            //
            apiStatus = WaitForMultipleObjects(dwCount,
                                               phHandles,
                                               FALSE,     // Wait for any
                                               g_dwScPipeTransactTimeout);

#if DBG

            dwTotalTime = GetTickCount() - dwStartTick;

            if (dwTotalTime > SC_DEFAULT_PIPE_TRANSACT_TIMEOUT) {

                SC_LOG1(ERROR,
                        "ScWaitForConnect: Wait on ConnectNamedPipe took %u milliseconds\n",
                        dwTotalTime);
            }

#endif  // DBG

            if (apiStatus == WAIT_OBJECT_0) {

                //
                // Wait completed successfully -- the object that
                // signalled was the pipe handle
                //
                status = GetOverlappedResult(
                         PipeHandle,
                         &overlapped,
                         &numBytesRead,
                         TRUE
                         );

                if (status == FALSE) {
                    apiStatus = GetLastError();

                    SC_LOG(ERROR,
                           "ScWaitForConnect: GetOverlappedResult failed, rc=%lu\n",
                           apiStatus);

                    return apiStatus;

                }
            }

            else {

                //
                // Either the connection timed out or the service process
                // exited before calling StartServiceCtrlDispatcher
                //

                SC_LOG2(ERROR,
                        "ScWaitForConnect: Wait for connection for %u secs timed out --"
                            "service process DID %s exit\n",
                        g_dwScPipeTransactTimeout / 1000,
                        (apiStatus == WAIT_TIMEOUT ? "NOT" : ""));

                //
                // The service didn't respond.  Cancel the named pipe operation.
                //
                status = CancelIo(PipeHandle);

                if (status == FALSE) {

                    SC_LOG(ERROR, "ScWaitForConnect: CancelIo failed, %lu\n", GetLastError());
                }

                ScLogEvent(
                    NEVENT_CONNECTION_TIMEOUT,
                    g_dwScPipeTransactTimeout,
                    lpDisplayName
                    );

                return ERROR_SERVICE_REQUEST_TIMEOUT;
            }
        }
        else if (apiStatus != ERROR_PIPE_CONNECTED) {

            SC_LOG(ERROR,"ScWaitForConnect: ConnectNamedPipe failed, rc=%lu\n",
                   apiStatus);

            return apiStatus;
        }

        //
        // If we received the ERROR_PIPE_CONNECTED status, then things
        // are still ok.
        //
    }


    SC_LOG(TRACE,"WaitForConnect:ConnectNamedPipe Success\n",0);

    //
    // Wait for initial status message
    //
    overlapped.hEvent = (HANDLE) NULL;   // Wait on pipe handle

    status = ReadFile (PipeHandle,
                       (LPVOID)&serviceResponseBuffer,
                       sizeof(serviceResponseBuffer),
                       &numBytesRead,
                       &overlapped);

    if (status == FALSE) {

        apiStatus = GetLastError();

        if (apiStatus == ERROR_IO_PENDING) {

#if DBG

            dwStartTick = GetTickCount();

#endif  // DBG

            //
            // Connection is pending
            //
            apiStatus = WaitForSingleObject(PipeHandle, g_dwScPipeTransactTimeout);

#if DBG

            dwTotalTime = GetTickCount() - dwStartTick;

            if (dwTotalTime > SC_DEFAULT_PIPE_TRANSACT_TIMEOUT) {

                SC_LOG1(ERROR,
                        "ScWaitForConnect: Wait on ReadFile took %u milliseconds\n",
                        dwTotalTime);
            }

#endif  // DBG

            if (apiStatus == WAIT_TIMEOUT) {

                SC_LOG(ERROR,
                       "ScWaitForConnect: Wait for ReadFile for %u secs timed out\n",
                       g_dwScPipeTransactTimeout / 1000 );

                //
                // Cancel the named pipe operation.
                //
                status = CancelIo(PipeHandle);

                if (status == FALSE) {

                    SC_LOG(ERROR, "ScWaitForConnect: CancelIo failed, %lu\n", GetLastError());
                }

                ScLogEvent(
                    NEVENT_READFILE_TIMEOUT,
                    g_dwScPipeTransactTimeout
                    );

                return ERROR_SERVICE_REQUEST_TIMEOUT;


            } else if (apiStatus == 0) {

                //
                // Wait completed successfully
                //
                status = GetOverlappedResult(PipeHandle,
                                             &overlapped,
                                             &numBytesRead,
                                             TRUE);

                if (status == FALSE) {
                    apiStatus = GetLastError();

                    SC_LOG(ERROR,
                           "ScWaitForConnect: GetOverlappedResult for ReadFile failed, rc=%lu\n",
                           apiStatus);

                    return apiStatus;
                }
            }
        }
        else {
            SC_LOG(ERROR,"ScWaitForConnect: ReadFile failed, rc=%lu\n",
            apiStatus);
            return apiStatus;
        }
    }

    SC_LOG0(TRACE,"WaitForConnect:ReadFile success\n");

    SC_LOG(
        TRACE,
        "WaitForConnect:ReadFile buffer size = %ld\n",
        sizeof(serviceResponseBuffer));

    SC_LOG(
        TRACE,
        "WaitForConnect:ReadFile numBytesRead = %ld\n",
        numBytesRead);


    *ProcessIdPtr = serviceResponseBuffer.dwDispatcherStatus;

    return(NO_ERROR);
}


/****************************************************************************/
DWORD
ScValidatePnPService(
    IN  LPWSTR                   lpServiceName,
    OUT SERVICE_STATUS_HANDLE    *lphServiceStatus
    )
{
    DWORD               dwError;
    LPSERVICE_RECORD    lpServiceRecord;

    //
    // Make sure PnP is supplying a valid OUT parameter
    //
    SC_ASSERT(lphServiceStatus != NULL);

    //
    // Validate the format of the service name.
    //
    if (! ScIsValidServiceName(lpServiceName))
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Find the service record in the database.
    //

    CServiceListSharedLock LLock;

    dwError = ScGetNamedServiceRecord(lpServiceName,
                                      &lpServiceRecord);

    if (dwError != NO_ERROR)
    {
        return(dwError);
    }

    CServiceRecordSharedLock RLock;

    //
    // Make sure the service specified is the service
    // that requested device notification
    //
    dwError = ScStatusAccessCheck(lpServiceRecord);

    if (dwError == NO_ERROR)
    {
        *lphServiceStatus = (SERVICE_STATUS_HANDLE)lpServiceRecord;
    }

    return dwError;
}


DWORD
ScSendPnPMessage(
    IN  SERVICE_STATUS_HANDLE   hServiceStatus,
    IN  DWORD                   OpCode,
    IN  DWORD                   dwEventType,
    IN  LPARAM                  EventData,
    OUT LPDWORD                 lpdwHandlerRetVal
    )

/*++

Routine Description:

    This function is called by PnP when it needs to send a control to a
    service that has requested notification.  It simply packs the args and
    calls ScSendControl.

Arguments:

    OpCode - This is the opcode that is to be passed to the service.

    dwEventType - The PnP event that has occurred

    EventData - Pointer to other information the service may want


Return Value:

    ERROR_SERVICE_NOT_ACTIVE - The named service has no image record

    In addition, any value passed back from ScGetNamedImageRecord or ScSendControl

--*/

{
    LPSERVICE_RECORD    lpServiceRecord;
    CONTROL_ARGS        ControlArgs;
    LPWSTR              lpServiceName;
    LPWSTR              lpDisplayName;
    HANDLE              hPipe;
    DWORD               dwError = NO_ERROR;

    //
    // Make sure this handle is valid (in case the service in question
    // was deleted and was signed up for device notifications)
    //
    // BUGBUG -- We should call a PnP callback and have it free up the
    //           node for the service in question if it's deleted
    //

    SC_ASSERT(((LPSERVICE_RECORD) hServiceStatus)->Signature == SERVICE_SIGNATURE);

    //
    // Make sure PnP is giving us a valid OUT parameter
    //
    SC_ASSERT(lpdwHandlerRetVal != NULL);

    lpServiceRecord = (LPSERVICE_RECORD) hServiceStatus;

    {
        //
        // Get the information we need then release the lock
        //

        CServiceRecordSharedLock  RLock;

        if (lpServiceRecord->ImageRecord == NULL)
        {
            return ERROR_SERVICE_NOT_ACTIVE;
        }

        lpServiceName = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                            2 * (MAX_SERVICE_NAME_LENGTH + 1) * sizeof(WCHAR));

        if (lpServiceName == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        lpDisplayName = lpServiceName + MAX_SERVICE_NAME_LENGTH + 1;

        wcscpy(lpServiceName, lpServiceRecord->ServiceName);
        wcscpy(lpDisplayName, lpServiceRecord->DisplayName);

        //
        // Refcount the pipe handle to prevent it from going away midway through
        // the call as ScSendControl doesn't hold locks around the pipe transact.
        //

        if (!DuplicateHandle(GetCurrentProcess(),
                             lpServiceRecord->ImageRecord->PipeHandle,
                             GetCurrentProcess(),
                             &hPipe,
                             0,
                             FALSE,
                             DUPLICATE_SAME_ACCESS))
        {
            dwError = GetLastError();
            LocalFree(lpServiceName);
            return dwError;
        }
    }

    //
    // If it's a PnP device event, pass along the arguments for the named pipe
    //

    switch (OpCode)
    {
        case SERVICE_CONTROL_DEVICEEVENT:

            //
            // Make sure that either both the size and buffer are
            // 0 and NULL or that they're non-zero and non-NULL
            //
            SC_ASSERT(((PDEV_BROADCAST_HDR)EventData)->dbch_size && EventData ||
                      !((PDEV_BROADCAST_HDR)EventData)->dbch_size && !EventData);

            ControlArgs.PnPArgs.dwEventType     = dwEventType;
            ControlArgs.PnPArgs.dwEventDataSize = ((PDEV_BROADCAST_HDR)EventData)->dbch_size;
            ControlArgs.PnPArgs.EventData       = (VOID *)EventData;

            break;

        case SERVICE_CONTROL_POWEREVENT:
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE:

            //
            // Hardware Profile Change and Power messages have no LPARAM.
            // They just tell a service that something noteworthy has happened.
            //
            SC_ASSERT(EventData == NULL);

            ControlArgs.PnPArgs.dwEventType     = dwEventType;
            ControlArgs.PnPArgs.dwEventDataSize = 0;
            ControlArgs.PnPArgs.EventData       = NULL;
            break;


        default:
            SC_ASSERT(FALSE);
            break;
    }

    dwError = ScSendControl(lpServiceName,
                            lpDisplayName,
                            hPipe,
                            OpCode,
                            &ControlArgs,
                            3,             // 3 PnP arguments
                            lpdwHandlerRetVal);

    LocalFree(lpServiceName);
    CloseHandle(hPipe);
    return dwError;
}


DWORD
RI_ScSendTSMessage (
    IN SC_RPC_HANDLE   hSCManager,
    IN DWORD           OpCode,
    IN DWORD           dwEvent,
    IN DWORD           cbData,
    IN LPBYTE          lpData
    )
{
    LPSERVICE_RECORD   lpServiceRecord;
    CONTROL_ARGS       ControlArgs;
    DWORD              dwAcceptedMask;
    DWORD              dwError = NO_ERROR;
    DWORD              dwNumServices = 0;
    DWORD              i;
    LPTS_CONTROL_INFO  lpControlInfo;

    lpServiceRecord = NULL;

    ControlArgs.PnPArgs.dwEventType     = dwEvent;
    ControlArgs.PnPArgs.dwEventDataSize = cbData;
    ControlArgs.PnPArgs.EventData       = lpData;

    if (OpCode != SERVICE_CONTROL_SESSIONCHANGE)
    {
        ASSERT(OpCode == SERVICE_CONTROL_SESSIONCHANGE);
        return ERROR_INVALID_PARAMETER;
    }

    dwAcceptedMask = SERVICE_ACCEPT_SESSIONCHANGE;

    //
    // Make sure that the caller is LocalSystem
    //

    dwError = ScStatusAccessCheck(NULL);

    if (dwError != NO_ERROR)
    {
        SC_LOG1(ERROR,
                "RI_ScSendTSMessage: ScStatusAccessCheck failed %d\n",
                dwError);

        return dwError;
    }

    {
        CServiceListSharedLock       LLock;
        CServiceRecordExclusiveLock  RLock;

        //
        // Go through the list and copy out the pointer to the service name and
        // the pipe handle for each service that wants to receive this control.
        // We do this so we can call ScSendControl for each service afterwards
        // without holding the locks required to traverse the list.
        //

        FOR_SERVICES_THAT(lpServiceRecord,
        (lpServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32) &&
        (lpServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED) &&
        (lpServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) &&
        (lpServiceRecord->ServiceStatus.dwControlsAccepted & dwAcceptedMask) &&
        (lpServiceRecord->ImageRecord != NULL)
        )
        {
            dwNumServices++;
        }

        if (dwNumServices == 0)
        {
            //
            // No services accept the control
            //

            return NO_ERROR;
        }

        lpControlInfo = (LPTS_CONTROL_INFO) LocalAlloc(LMEM_ZEROINIT,
                                                       dwNumServices * sizeof(TS_CONTROL_INFO));

        if (lpControlInfo == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwNumServices = 0;

        FOR_SERVICES_THAT(lpServiceRecord,
        (lpServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32) &&
        (lpServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED) &&
        (lpServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) &&
        (lpServiceRecord->ServiceStatus.dwControlsAccepted & dwAcceptedMask) &&
        (lpServiceRecord->ImageRecord != NULL)
        )
        {
            //
            // Copy out the information we need
            //

            wcscpy(lpControlInfo[dwNumServices].lpServiceName, lpServiceRecord->ServiceName);
            wcscpy(lpControlInfo[dwNumServices].lpDisplayName, lpServiceRecord->DisplayName);

            if (!DuplicateHandle(GetCurrentProcess(),
                                 lpServiceRecord->ImageRecord->PipeHandle,
                                 GetCurrentProcess(),
                                 &lpControlInfo[dwNumServices].hPipe,
                                 0,
                                 FALSE,
                                 DUPLICATE_SAME_ACCESS))
            {
                dwError = GetLastError();
                goto CleanExit;
            }

            dwNumServices++;
        }
    }

    for (i = 0; i < dwNumServices; i++)
    {
        //
        // Send the control
        //

        dwError = ScSendControl(lpControlInfo[i].lpServiceName,
                                lpControlInfo[i].lpDisplayName,
                                lpControlInfo[i].hPipe,
                                OpCode,
                                &ControlArgs,
                                3,
                                NULL);

        //
        // Ignore any errors sending the control
        //

        if (dwError != NO_ERROR)
        {
            SC_LOG2(ERROR,
                    "RI_ScSendTSMessage:  Error %d sending control to %ws service\n",
                    dwError,
                    lpControlInfo[i].lpServiceName);
        }

        CloseHandle(lpControlInfo[i].hPipe);
    }

    LocalFree(lpControlInfo);
    return NO_ERROR;

CleanExit:

    for (i = 0; i < dwNumServices; i++)
    {
        //
        // The only time lpControlInfo[i].hPipe may be NULL is if the DuplicateHandle
        // call for it failed above.  In that case, however, dwNumServices wasn't
        // incremented and we jumped straight here, so by looping until dwNumServices,
        // we're guaranteed to be closing valid pipe handles.
        //

        CloseHandle(lpControlInfo[i].hPipe);
    }

    LocalFree(lpControlInfo);

    return dwError;
}


/****************************************************************************/
DWORD
ScSendControl(
    IN  LPWSTR                  ServiceName,
    IN  LPWSTR                  DisplayName,
    IN  HANDLE                  PipeHandle,
    IN  DWORD                   OpCode,
    IN  LPCONTROL_ARGS          lpControlArgs OPTIONAL,
    IN  DWORD                   NumArgs,
    OUT LPDWORD                 lpdwHandlerRetVal OPTIONAL
    )

/*++

Routine Description:

    This function sends a control request to a service via a
    TransactNamedPipe call.  A buffer is allocated for the transaction,
    and then freed when done.

    LOCKS:
    Normally locks are not held when this function is called.  This is
    because we need to allow status messages to come in prior to the
    transact completing.  The exception is when we send the message
    to the control dispatcher to shutdown.  No status message is sent
    in response to that.

    There is a ScTransactNPCriticalSection that is held during the actual
    Transact.

Arguments:

    ServiceName - This is a pointer to a NUL terminated service name string.

    PipeHandle - This is the pipe handle to which the request is directed.

    OpCode - This is the opcode that is to be passed to the service.

    lpControlArgs - This is an optional pointer to a CONTROL_ARGS union,
    which can contain either an array of pointers to NUL-terminated
    strings (for the SERVICE_CONTROL_START case) or a structure that
    holds Plug-and-Play arguments (for the SERVICE_CONTROL_DEVICEEVENT,
    SERVICE_CONTROL_POWEREVENT, SERVICE_CONTROL_HARDWAREPROFILECHANGE,
    and SERVICE_CONTROL_SESSIONCHANGE cases).

    NumArgs - This indicates how many arguments are in the structure
    lpControlArgs contains.  For SERVICE_CONTROL_START, it's the number
    of strings in the argument array.  For Plug-and-Play events, it's
    the number of arguments in a Plug-and-Play message (currently 3)

    lpdwHandlerRetVal - The return value from the Service's control handler

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_GEN_FAILURE - An incorrect number of bytes was received
    in the response message.

    ERROR_ACCESS_DENIED - This is a status response from the service
    security check by the Control Dispatcher on the other end of the
    pipe.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate memory for the transaction
    buffer. (Local Alloc failed).

    other - Any error from TransactNamedPipe could be returned - Or any
        error from the Control Dispatcher on the other end of the pipe.

--*/
{
    DWORD               returnStatus = NO_ERROR;
    LPCTRL_MSG_HEADER   lpcmhBuffer;        // Message buffer
    DWORD               serviceNameSize;
    DWORD               sendBufferSize;
    BOOL                status;
    PIPE_RESPONSE_MSG   serviceResponseBuffer;
    DWORD               bytesRead;
    DWORD               i;

    static OVERLAPPED   overlapped={0,0,0,0,0}; // overlapped structure to implement
                                                // timeout on TransactNamedPipe
                                                // static because on shutdown, we'll
                                                // be firing off a bunch of async
                                                // writes, which write to the overlapped
                                                // structure upon completion, and we
                                                // don't want them trashing the stack

    if (ARGUMENT_PRESENT(lpdwHandlerRetVal))
    {
        //
        // Initialize the OUT pointer
        //
        *lpdwHandlerRetVal = NO_ERROR;
    }

    serviceNameSize = (DWORD) WCSSIZE(ServiceName);
    sendBufferSize = serviceNameSize + sizeof(CTRL_MSG_HEADER);

    //
    // Add an extra PVOID size to help settle alignment problems that
    // may occur when the array of pointers follows the service name string.
    //
    sendBufferSize += sizeof(PVOID);

    //
    // There are control arguments, so add their size to the buffer size
    //
    if (lpControlArgs != NULL) {

        if (OpCode == SERVICE_CONTROL_START_SHARE ||
            OpCode == SERVICE_CONTROL_START_OWN) {

            //
            // Service is starting
            //
            for (i = 0; i < NumArgs; i++) {
                sendBufferSize += (DWORD) WCSSIZE(lpControlArgs->CmdArgs[i]) +
                                  sizeof(LPWSTR);
            }
        }
        else {

            SC_ASSERT(OpCode == SERVICE_CONTROL_DEVICEEVENT ||
                      OpCode == SERVICE_CONTROL_HARDWAREPROFILECHANGE ||
                      OpCode == SERVICE_CONTROL_POWEREVENT ||
                      OpCode == SERVICE_CONTROL_SESSIONCHANGE);

            //
            // PnP event
            //
            sendBufferSize += sizeof(lpControlArgs->PnPArgs.dwEventType);
            sendBufferSize += sizeof(lpControlArgs->PnPArgs.dwEventDataSize);

            sendBufferSize += lpControlArgs->PnPArgs.dwEventDataSize;
        }
    }


    //
    // Allocate the buffer and set a pointer to it that knows the structure
    // of the header.
    //
    lpcmhBuffer = (LPCTRL_MSG_HEADER)LocalAlloc(LMEM_ZEROINIT, sendBufferSize);

    if (lpcmhBuffer == NULL) {
        SC_LOG(TRACE,"SendControl:LocalAlloc failed, rc=%d/n", GetLastError());
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    /////////////////////////////////////////////////////////////////////
    // Marshall the data into the buffer.
    //
    //
    // The Control Message looks like this for service start:
    //  CTRL_MSG_HEADER     Header
    //  WCHAR               ServiceName[?]
    //  LPWSTR              Argv0 offset
    //  LPWSTR              Argv1 offset
    //  LPWSTR              Argv2 offset
    //  LPWSTR              ...
    //  WCHAR               Argv0[?]
    //  WCHAR               Argv1[?]
    //  WCHAR               Argv2[?]
    //  WCHAR               ...
    //
    // and like this for PNP events:
    //  CTRL_MSG_HEADER     Header
    //  WCHAR               ServiceName[?]
    //  DWORD               wParam
    //  BYTE                lParam[?]
    //

    lpcmhBuffer->OpCode       = OpCode;
    lpcmhBuffer->Count        = sendBufferSize;

    //
    // Copy the service name to buffer and store the offset.
    //

    lpcmhBuffer->ServiceNameOffset = sizeof(CTRL_MSG_HEADER);
    wcscpy((LPWSTR)(lpcmhBuffer + 1), ServiceName);

    //
    // Pack message-specific arguments as necessary
    //
    switch (OpCode) {

        case SERVICE_CONTROL_START_SHARE:
        case SERVICE_CONTROL_START_OWN:

            if (NumArgs > 0) {

                //
                // Service start -- Determine the offset from the top of the argv
                // array to the first argv string.  Also determine the pointer value
                // for that location.
                //
                DWORD     dwOffset   = NumArgs * sizeof(LPWSTR);
                LPWSTR    *ppwszArgs;

                //
                // Calculate the beginning of the string area and the beginning
                // of the arg vector area.  Align the vector pointer on a PVOID
                // boundary.
                //

                ppwszArgs = (LPWSTR *)((LPBYTE)(lpcmhBuffer + 1) + serviceNameSize);
                ppwszArgs = (LPWSTR *)ROUND_UP_POINTER(ppwszArgs, sizeof(PVOID));

                lpcmhBuffer->ArgvOffset = (DWORD)((LPBYTE)ppwszArgs - (LPBYTE)lpcmhBuffer);
                lpcmhBuffer->NumCmdArgs = NumArgs;

                //
                // Copy the command arg strings to the buffer and update the argv
                // pointers with offsets.  Remember - we already have one argument
                // in there for the service registry path.
                //
                for (i = 0; i < NumArgs; i++) {

                    wcscpy((LPWSTR) ((LPBYTE)ppwszArgs + dwOffset),
                           lpControlArgs->CmdArgs[i]);

                    ppwszArgs[i] = (LPWSTR)(DWORD_PTR) dwOffset;
                    dwOffset    += (DWORD) WCSSIZE(lpControlArgs->CmdArgs[i]);
                }
            }
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
        case SERVICE_CONTROL_POWEREVENT:
        case SERVICE_CONTROL_SESSIONCHANGE:
        {
            LPDWORD   lpdwArgLocation;

            //
            // Calculate the location for the PnP/power arguments.
            // Align the pointer on a PVOID boundary.
            //
            lpdwArgLocation = (LPDWORD)((LPBYTE)(lpcmhBuffer + 1) + serviceNameSize);
            lpdwArgLocation = (LPDWORD)ROUND_UP_POINTER(lpdwArgLocation, sizeof(PVOID));

            lpcmhBuffer->ArgvOffset = (DWORD)((LPBYTE)lpdwArgLocation - (LPBYTE)lpcmhBuffer);

            //
            // Copy the wParam into the buffer
            //
            *lpdwArgLocation = lpControlArgs->PnPArgs.dwEventType;

            //
            // Copy the lParam into the buffer
            //
            RtlCopyMemory(lpdwArgLocation + 1,
                          lpControlArgs->PnPArgs.EventData,
                          lpControlArgs->PnPArgs.dwEventDataSize);
            break;
        }
    }


    // If the SCM is sending a shutdown message to a service, we want to just
    // use WriteFile instead of TransactNamedPipe, since a badly behaved service
    // that doesn't write back to the pipe leaves the SCM hanging and unable to
    // properly shut down the remaining services

    SC_LOG0(LOCKS,"SendControl: Entering TransactPipe Critical Section.\n");
    EnterCriticalSection(&ScTransactNPCriticalSection);

    if (OpCode == SERVICE_CONTROL_SHUTDOWN) {

        SC_LOG0(SHUTDOWN,
                "ScSendControl: Using WriteFile to send a service shutdown message.\n");

        status = WriteFile(
                    PipeHandle,
                    lpcmhBuffer,
                    sendBufferSize,
                    &bytesRead,
                    &overlapped);

        if (status || (returnStatus = GetLastError()) == ERROR_IO_PENDING) {
            returnStatus = NO_ERROR;
        }

        SC_LOG(SHUTDOWN, "ScSendControl returning with code %d\n", returnStatus);
    }
    else {
        //
        // The parameters are marshalled, now send the buffer and wait for
        // response.
        //

        SC_LOG(TRACE,"SendControl: Sending a TransactMessage.\n",0);

        returnStatus = NO_ERROR;
        status = TransactNamedPipe(PipeHandle,
                                   lpcmhBuffer,
                                   sendBufferSize,
                                   &serviceResponseBuffer,
                                   sizeof(PIPE_RESPONSE_MSG),
                                   &bytesRead,
                                   &overlapped);

        if (status == FALSE) {

            returnStatus = GetLastError();
            if (returnStatus == ERROR_PIPE_BUSY) {
                SC_LOG(ERROR, "Cleaning out pipe for %ws service\n", ServiceName);
                ScCleanOutPipe(PipeHandle);
                status = TRUE;
                returnStatus = NO_ERROR;
                status = TransactNamedPipe(PipeHandle,
                                           lpcmhBuffer,
                                           sendBufferSize,
                                           &serviceResponseBuffer,
                                           sizeof(PIPE_RESPONSE_MSG),
                                           &bytesRead,
                                           &overlapped);

                if (status == FALSE) {
                    returnStatus = GetLastError();
                }
            }
        }

        if (status == FALSE) {
            if (returnStatus != ERROR_IO_PENDING) {

                SC_LOG2(ERROR,
                        "SendControl:TransactNamedPipe to %ws service failed, rc=%lu\n",
                        ServiceName,
                        returnStatus);

                goto CleanUp;

            } else {

#if DBG

                DWORD   dwStartTick = GetTickCount();
                DWORD   dwTotalTime;

#endif  // DBG

                //
                // Transaction is pending
                //
                status = WaitForSingleObject(PipeHandle, g_dwScPipeTransactTimeout);

#if DBG

                dwTotalTime = GetTickCount() - dwStartTick;

                if (dwTotalTime > SC_DEFAULT_PIPE_TRANSACT_TIMEOUT) {

                    SC_LOG3(ERROR,
                            "ScSendControl: Pipe transaction to service %ws on "
                            "control %u took %u milliseconds\n",
                            ServiceName,
                            OpCode,
                            dwTotalTime);
                }

#endif  // DBG

                if (status == WAIT_TIMEOUT) {

                    SC_LOG2(ERROR,
                        "SendControl: Wait on transact to %ws service for %u millisecs timed out\n",
                        ServiceName, g_dwScPipeTransactTimeout);

                    //
                    // Cancel the named pipe operation.
                    // NOTE:  CancelIo cancels ALL pending I/O operations issued by
                    // this thread on the PipeHandle.  Since the service controller
                    // functions do nothing but wait after starting asynchronous
                    // named pipe operations, there should be no other operations.
                    //
                    status = CancelIo(PipeHandle);

                    if (status == FALSE) {

                        SC_LOG(ERROR, "SendControl: CancelIo failed, %lu\n", GetLastError());
                    }

                    ScLogEvent(
                        NEVENT_TRANSACT_TIMEOUT,
                        g_dwScPipeTransactTimeout,
                        ServiceName
                        );

                    returnStatus = ERROR_SERVICE_REQUEST_TIMEOUT;
                    goto CleanUp;

                } else if (status == 0) {

                    //
                    // Wait completed successfully
                    //
                    status = GetOverlappedResult(
                                 PipeHandle,
                                 &overlapped,
                                 &bytesRead,
                                 TRUE
                                 );

                    if (status == FALSE) {
                        returnStatus = GetLastError();
                        SC_LOG(ERROR,
                            "SendControl: GetOverlappedResult failed, rc=%lu\n",
                            returnStatus);
                        goto CleanUp;

                    }
                }
            }
        }

        //
        // Response received from the control dispatcher
        //
        if (bytesRead != sizeof(PIPE_RESPONSE_MSG)) {

            //
            // Successful transact, but we didn't get proper input.
            // (note: we should never receive more bytes unless there
            // is a bug in TransactNamedPipe).
            //

            SC_LOG(ERROR,
                "SendControl: Incorrect num bytes in response, num=%d",
                bytesRead);

            ScLogEvent(NEVENT_TRANSACT_INVALID);

            returnStatus = ERROR_GEN_FAILURE;
        }
        else {
            returnStatus = serviceResponseBuffer.dwDispatcherStatus;

            if (ARGUMENT_PRESENT(lpdwHandlerRetVal)) {
                *lpdwHandlerRetVal = serviceResponseBuffer.dwHandlerRetVal;
            }
        }
    }

CleanUp:
    SC_LOG(LOCKS,"SendControl: Leaving TransactPipe Critical Section.\n",0);

    LeaveCriticalSection(&ScTransactNPCriticalSection);

    LocalFree(lpcmhBuffer);

    if (returnStatus == NO_ERROR
         &&
        IS_CONTROL_LOGGABLE(OpCode)
         &&
        DisplayName != NULL && DisplayName[0] != L'\0')
    {
        ScLogControlEvent(NEVENT_SERVICE_CONTROL_SUCCESS,
                          DisplayName,
                          OpCode);
    }

    return(returnStatus);
}


VOID
ScInitTransactNamedPipe(
    VOID
    )

/*++

Routine Description:

    This function initializes the Critical Section that serializes
    calls to TransactNamedPipe and sets the pipe timeout value.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD   dwStatus;
    HKEY    hKeyControl;
    DWORD   dwValueType;
    DWORD   dwBufSize = sizeof(DWORD);


    InitializeCriticalSection(&ScTransactNPCriticalSection);

    //
    // Read the pipe timeout value from the registry if it exists.
    // If the read fails or the value's not there, use the default.
    //
    dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,     // hKey
                            REGKEY_PIPE_TIMEOUT,    // lpSubKey
                            0,
                            KEY_READ,               // Read access
                            &hKeyControl);          // Newly Opened Key Handle

    if (dwStatus == NO_ERROR) {

        dwStatus = RegQueryValueEx(hKeyControl,
                                   REGVAL_PIPE_TIMEOUT,
                                   NULL,
                                   &dwValueType,
                                   (LPBYTE)&g_dwScPipeTransactTimeout,
                                   &dwBufSize);

        if (dwStatus != NO_ERROR || dwValueType != REG_DWORD) {

            //
            // The value's either not there or bogus so just use the default
            //
            SC_LOG0(TRACE,
                    "ScInitTransactNamedPipe: Can't find ServicesPipeTimeout "
                    "value in registry\n");
        }

        RegCloseKey(hKeyControl);
    }
    else {

        //
        // Not an error for this function, although a missing control
        // key is probably relatively bad, so notify everybody
        //
        SC_LOG0(ERROR,
                "ScInitTransactNamedPipe: Can't find Control "
                "key in registry!\n");
    }

    SC_LOG1(TRACE,
            "ScInitTransactNamedPipe: Using pipe timeout value of %u\n",
            g_dwScPipeTransactTimeout);
}



VOID
ScShutdownAllServices(
    VOID
    )

/*++

Routine Description:

    (called at system shutdown).
    This function sends shutdown requests to all services that have
    registered an interest in shutdown notification.

    When we leave this routine, to the best of our knowledge, all the
    services that should stop have stopped - or are in some hung state.

    Note:  It is expected that the RPC entry points are no longer serviced,
    so we should not be receiving any requests that will add or delete
    service records.  Therefore, locks are not used when reading service
    records during the shutdown loop.


Arguments:

    none

Return Value:

    none

Note:


--*/

{
    DWORD               status;
    LPSERVICE_RECORD    *affectedServices;
    DWORD               serviceIndex        = 0;
    DWORD               arrayEnd            = 0;
    BOOL                ServicesStopping;
    DWORD               maxWait             = 0;
    DWORD               startTime;
    DWORD               arraySize;

#ifdef SC_SHUTDOWN_METRIC

    //
    // Local variables for shutdown performance metrics
    //
    DWORD               dwShutdownTimeout = 0;
    HKEY                hKeyControl;
    DWORD               dwValueType;
    DWORD               dwBufSize = sizeof(DWORD);

#endif  // SC_SHUTDOWN_METRIC


    //
    // Allocate a temporary array of services which we're interested in.
    // (This is purely an optimization to avoid repeated traversals of the
    // entire database of installed services.)
    //
    CServiceListSharedLock LLock;
    arraySize = ScGetTotalNumberOfRecords();

    affectedServices = (LPSERVICE_RECORD *)LocalAlloc(
                            LMEM_FIXED,
                            arraySize * sizeof(LPSERVICE_RECORD));

    if (affectedServices == NULL) {
        SC_LOG0(ERROR,"ScShutdownAllServices: LocalAlloc Failed\n");
        return;
    }

#ifdef SC_SHUTDOWN_METRIC

    //
    // Read the shutdown timeout value from the registry if it exists.
    // If the read fails or the value's not there, use the default.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,      // hKey
                     REGKEY_SHUTDOWN_TIMEOUT, // lpSubKey
                     0,
                     KEY_READ,                // Read access
                     &hKeyControl)            // Handle to newly-opened key

            == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKeyControl,
                        REGVAL_SHUTDOWN_TIMEOUT,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwShutdownTimeout,
                        &dwBufSize);

        RegCloseKey(hKeyControl);
    }

#endif  // SC_SHUTDOWN_METRIC

    //-------------------------------------------------------------------
    //
    // Loop through service list sending stop requests to all that
    // should receive such requests.
    //
    //-------------------------------------------------------------------
    SC_LOG0(SHUTDOWN,"***** BEGIN SENDING STOPS TO SERVICES *****\n");

    FOR_SERVICES_THAT(Service,
    (Service->ServiceStatus.dwServiceType & SERVICE_WIN32) &&
    (Service->ServiceStatus.dwCurrentState != SERVICE_STOPPED) &&
    (Service->ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) &&
    (Service->ServiceStatus.dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) &&
    (Service->ImageRecord != NULL)
    )
    {
        //
        // If the service is not in the stopped or stop pending
        // state, it should be ok to send the control.
        //
        SC_LOG1(SHUTDOWN,"Shutdown: Sending Stop to Service : %ws\n",
                Service->ServiceName);

        status = ScSendControl(Service->ServiceName,
                               Service->DisplayName,
                               Service->ImageRecord->PipeHandle,
                               SERVICE_CONTROL_SHUTDOWN,
                               NULL,                           // CmdArgs
                               0L,                             // NumArgs
                               NULL);                          // Ignore handler return value

        if (status != NO_ERROR) {
            SC_LOG1(ERROR,"ScShutdownAllServices: ScSendControl "
            "Failed for %ws\n",Service->ServiceName);
        }
        else {

            //
            // Save the services that have been sent stop requests
            // in the temporary array.
            //
            SC_ASSERT(serviceIndex < arraySize);

            if (serviceIndex < arraySize) {
                    affectedServices[serviceIndex++] = Service;
            }
        }
    }

    SC_LOG0(SHUTDOWN,"***** DONE SENDING STOPS TO SERVICES *****\n");

    //-------------------------------------------------------------------
    //
    // Now check to see if these services stopped.
    //
    //-------------------------------------------------------------------

    startTime     = GetTickCount();
    arrayEnd      = serviceIndex;
    ServicesStopping = (serviceIndex != 0);

    SC_LOG(SHUTDOWN,"Waiting for services to stop. Start time is %lu\n",
    startTime);

    while (ServicesStopping) {

        //
        // Wait a bit for the services to become stopped.
        //
        Sleep(500);

        //
        // We are going to check all the services in our shutdown
        // list and see if we still have services to wait on.
        //
        ServicesStopping = FALSE;
        maxWait = 0;

        for (serviceIndex = 0; serviceIndex < arrayEnd ; serviceIndex++) {

            Service = affectedServices[serviceIndex];

            //
            // If the service is in the stop pending state, then wait
            // a bit and check back.  Maximum wait time is the maximum
            // wait hint period of all the services.  If a service's
            // wait hint is 0, use 20 seconds as its wait hint.
            //
            // Note that this is different from how dwWaitHint is
            // interpreted for all other operations.  We ignore
            // dwCheckPoint here.
            //
            switch (Service->ServiceStatus.dwCurrentState) {

            case SERVICE_STOP_PENDING:

                SC_LOG2(SHUTDOWN,
                        "%ws Service is still pending, wait hint = %lu\n",
                        Service->ServiceName,
                        Service->ServiceStatus.dwWaitHint);

                if (Service->ServiceStatus.dwWaitHint == 0) {
                    if (maxWait < 20000) {
                        maxWait = 20000;
                    }
                }
                else {
                    if (maxWait < Service->ServiceStatus.dwWaitHint) {
                        maxWait = Service->ServiceStatus.dwWaitHint;
                    }
                }
                ServicesStopping = TRUE;
                break;

            case SERVICE_STOPPED:
                break;

            case SERVICE_RUNNING:

                if (maxWait < 30000) {
                    maxWait = 30000;
                }

                SC_LOG2(SHUTDOWN, "%ws Service is still running, maxWait is %lu\n",
                        Service->ServiceName, maxWait);

                ServicesStopping = TRUE;
                break;

            default:
                //
                // This is an error.  But we can't do anything about
                // it, so it will be ignored.
                //
                SC_LOG2(SHUTDOWN,"ERROR: %ws Service is in invalid state %#lx\n",
                        Service->ServiceName,
                        Service->ServiceStatus.dwCurrentState);
                break;

            } // end switch

        } // end for


        //
        // We have examined all the services.  If there are still services
        // with the STOP_PENDING, then see if we have timed out the
        // maxWait period yet.
        //
        if (ServicesStopping) {

#ifdef SC_SHUTDOWN_METRIC

            //
            // Performance hook for service shutdown -- if a shutdown
            // timeout was specified in the registry and it's been
            // longer than the timeout, print out a list of all the
            // unstopped services and break into the debugger.  Do this
            // on both free and checked builds.  Note that this must be
            // #if'ed out prior to shipping NT 5.0.
            //
            if (dwShutdownTimeout != 0
                &&
                (GetTickCount() - startTime) > dwShutdownTimeout) {

                //
                // Uh oh -- we've exceeded the max shutdown time
                //
                DbgPrint("\n[SC-SHUTDOWN] The following services failed to "
                             "shut down in %lu seconds:\n",
                         dwShutdownTimeout / 1000);

                for (serviceIndex = 0; serviceIndex < arrayEnd; serviceIndex++) {

                    Service = affectedServices[serviceIndex];

                    if (Service->ServiceStatus.dwCurrentState != SERVICE_STOPPED) {

                        DbgPrint("%ws service is still running (state = %lu)\n",
                                 Service->ServiceName,
                                 Service->ServiceStatus.dwCurrentState);
                    }
                }

                DebugBreak();
            }

#endif  // SC_SHUTDOWN_METRIC

            if ( (GetTickCount() - startTime) > maxWait ) {

                //
                // The maximum wait period has been exceeded. At this
                // point we should end this shutdown effort.  There is
                // no point in forcing shutdown.  So we just exit.
                //
                SC_LOG(ERROR,
                       "The Services didn't stop within the timeout "
                         "period of %lu.\n   --- There is still at least one "
                         "service running\n",
                       maxWait);

#if DBG
                SC_LOG0(ERROR, "The following Services failed to shut down:\n");

                for (serviceIndex = 0; serviceIndex < arrayEnd ; serviceIndex++) {

                    Service = affectedServices[serviceIndex];

                    if (Service->ServiceStatus.dwCurrentState != SERVICE_STOPPED) {

                        SC_LOG2(ERROR, "%ws Service is still running (Service state = %lu)\n",
                                Service->ServiceName, Service->ServiceStatus.dwCurrentState);
                    }
                }
#endif // DBG

                ServicesStopping = FALSE;
            }
        }
    }

    SC_LOG0(SHUTDOWN,"Done Waiting for services to stop\n");

    //
    // With a FAT file system and critical update notification enabled, we
    // need to shut down the SCE's RPC server to avoid a dirty shutdown.
    // If we don't, SCE will access files under %windir%\security after
    // FAT has marked the volumes as clean.
    //

    ScesrvTerminateServer((PSVCS_STOP_RPC_SERVER) RpcpStopRpcServer);
}


VOID
ScCleanOutPipe(
    HANDLE  PipeHandle
    )

/*++

Routine Description:

    This function reads and throws away all data that is currently in the
    pipe.  This function is called if the pipe is busy when it shouldn't be.
    The PIPE_BUSY occurs when (1) the transact never returns, or (2) the
    last transact timed-out, and the return message was eventually placed
    in the pipe after the timeout.

    This function is called to fix the (2) case by cleaning out the pipe.

Arguments:

    PipeHandle - A Handle to the pipe to be cleaned out.

Return Value:

    none.

--*/
{
#define EXPUNGE_BUF_SIZE    100

    DWORD      status;
    DWORD      returnStatus;
    DWORD      numBytesRead=0;
    BYTE       msg[EXPUNGE_BUF_SIZE];
    OVERLAPPED overlapped={0,0,0,0,0};

    do {
        overlapped.hEvent = (HANDLE) NULL;   // Wait on pipe handle

        status = ReadFile (
                PipeHandle,
                msg,
                EXPUNGE_BUF_SIZE,
                &numBytesRead,
                &overlapped);

        if (status == FALSE) {
            returnStatus = GetLastError();

            if (returnStatus == ERROR_IO_PENDING) {

                status = WaitForSingleObject(
                        PipeHandle,
                        SC_PIPE_CLEANOUT_TIMEOUT);

                if (status == WAIT_TIMEOUT) {
                    SC_LOG0(ERROR, "ControlPipe was busy but we were unable to "
                    "clean it out in the timeout period\n");

                    //
                    // Cancel the named pipe operation.
                    //
                    status = CancelIo(PipeHandle);

                    if (status == FALSE) {
                        SC_LOG(ERROR,
                               "ScCleanOutPipe: CancelIo failed, %lu\n",
                               GetLastError());
                    }
                }
            }
            else {
            SC_LOG1(ERROR, "ControlPipe was busy.  The attempt to clean"
                "it out failed with %d\n", returnStatus);
            }
        }
    }
    while (status == ERROR_MORE_DATA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\crash.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    crash.cxx

Abstract:

    Contains code concerned with recovery actions that are taken when
    a service crashes.  This file contains the following functions:
        ScQueueRecoveryAction
        CCrashRecord::IncrementCount
        CRestartContext::Perform
        CRebootMessageContext::Perform
        CRebootContext::Perform
        CRunCommandContext::Perform

Author:

    Anirudh Sahni (anirudhs)    02-Dec-1996

Environment:

    User Mode -Win32

Revision History:

    22-Oct-1998     jschwart
        Convert SCM to use NT thread pool APIs

    02-Dec-1996     AnirudhS
        Created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <lmcons.h>     // needed for other lm headers
#include <lmerr.h>      // NERR_Success
#include <lmshare.h>    // NetSessionEnum
#include <lmmsg.h>      // NetMessageBufferSend
#include <lmapibuf.h>   // NetApiBufferFree
#include <valid.h>      // ACTION_TYPE_INVALID
#include <svcslib.h>    // CWorkItemContext
#include "smartp.h"     // CHeapPtr
#include "scconfig.h"   // ScReadFailureActions, etc.
#include "depend.h"     // ScStartServiceAndDependencies
#include "account.h"    // ScLogonService
#include "scseclib.h"   // ScCreateAndSetSD
#include "start.h"      // ScAllowInteractiveServices, ScInitStartupInfo
#include "resource.h"   // IDS_SC_ACTION_BASE

//
// Defines and Typedefs
//
#define FILETIMES_PER_SEC       ((__int64) 10000000)   // (1 second)/(100 ns)
#define LENGTH(array)           (sizeof(array)/sizeof((array)[0]))

//
//  Globals
//


//
// Local Function Prototypes
//
VOID
ScLogRecoveryFailure(
    IN  SC_ACTION_TYPE  ActionType,
    IN  LPCWSTR         ServiceDisplayName,
    IN  DWORD           Error
    );

inline LPWSTR
LocalDup(
    LPCWSTR String
    )
{
    LPWSTR Dup = (LPWSTR) LocalAlloc(0, WCSSIZE(String));
    if (Dup != NULL)
    {
        wcscpy(Dup, String);
    }
    return Dup;
}

//
// Callback context for restarting a service
//
class CRestartContext : public CWorkItemContext
{
                DECLARE_CWorkItemContext
public:
                CRestartContext(
                    IN LPSERVICE_RECORD ServiceRecord
                    ) :
                        _ServiceRecord(ServiceRecord)
                        {
                            ServiceRecord->UseCount++;
                            SC_LOG2(USECOUNT, "CRestartContext: %ws increment "
                                    "USECOUNT=%lu\n", ServiceRecord->ServiceName,
                                    ServiceRecord->UseCount);
                        }

               ~CRestartContext()
                        {
                            CServiceRecordExclusiveLock RLock;
                            ScDecrementUseCountAndDelete(_ServiceRecord);
                        }

private:
    LPSERVICE_RECORD    _ServiceRecord;
};

//
// Callback context for broadcasting a reboot message
//
class CRebootMessageContext : public CWorkItemContext
{
                DECLARE_CWorkItemContext
public:
                CRebootMessageContext(
                    IN LPWSTR RebootMessage,
                    IN DWORD  Delay,
                    IN LPWSTR DisplayName
                    ) :
                        _RebootMessage(RebootMessage),
                        _Delay(Delay),
                        _DisplayName(LocalDup(DisplayName))
                        { }

               ~CRebootMessageContext()
                        {
                            LocalFree(_RebootMessage);
                        }

private:
    LPWSTR      _RebootMessage;
    DWORD       _Delay;
    LPWSTR      _DisplayName;
};

//
// Callback context for a reboot
// (The service name is used only for logging)
//
class CRebootContext : public CWorkItemContext
{
                DECLARE_CWorkItemContext
public:
                CRebootContext(
                    IN DWORD  ActionDelay,
                    IN LPWSTR DisplayName
                    ) :
                        _Delay(ActionDelay),
                        _DisplayName(DisplayName)
                        { }

               ~CRebootContext()
                        {
                            LocalFree(_DisplayName);
                        }

private:
    DWORD       _Delay;
    LPWSTR      _DisplayName;
};

//
// Callback context for running a recovery command
//
class CRunCommandContext : public CWorkItemContext
{
                DECLARE_CWorkItemContext
public:
                CRunCommandContext(
                    IN LPSERVICE_RECORD ServiceRecord,
                    IN LPWSTR FailureCommand
                    ) :
                        _ServiceRecord(ServiceRecord),
                        _FailureCommand(FailureCommand)
                        {
                            //
                            // The service record is used to get the
                            // account name to run the command in.
                            //
                            ServiceRecord->UseCount++;
                            SC_LOG2(USECOUNT, "CRunCommandContext: %ws increment "
                                    "USECOUNT=%lu\n", ServiceRecord->ServiceName,
                                    ServiceRecord->UseCount);
                        }

               ~CRunCommandContext()
                        {
                            LocalFree(_FailureCommand);
                            CServiceRecordExclusiveLock RLock;
                            ScDecrementUseCountAndDelete(_ServiceRecord);
                        }

private:
    LPSERVICE_RECORD    _ServiceRecord;
    LPWSTR              _FailureCommand;
};



/****************************************************************************/

VOID
ScQueueRecoveryAction(
    IN LPSERVICE_RECORD     ServiceRecord
    )

/*++

Routine Description:


Arguments:


Return Value:

    none.

--*/
{
    SC_ACTION_TYPE  ActionType  = SC_ACTION_NONE;
    DWORD           ActionDelay = 0;
    DWORD           FailNum     = 1;
    NTSTATUS        ntStatus;

    //
    // See if there is any recovery action configured for this service.
    //
    HKEY  Key = NULL;
    {
        DWORD   ResetPeriod = INFINITE;
        LPSERVICE_FAILURE_ACTIONS_WOW64 psfa = NULL;

        DWORD Error = ScOpenServiceConfigKey(
                            ServiceRecord->ServiceName,
                            KEY_READ,
                            FALSE,              // don't create if missing
                            &Key
                            );

        if (Error == ERROR_SUCCESS)
        {
            Error = ScReadFailureActions(Key, &psfa);
        }

        if (Error != ERROR_SUCCESS)
        {
            SC_LOG(ERROR, "Couldn't read service's failure actions, %lu\n", Error);
        }
        else if (psfa != NULL && psfa->cActions > 0)
        {
            ResetPeriod = psfa->dwResetPeriod;
        }

        //
        // Allocate a crash record for the service.
        // Increment the service's crash count, subject to the reset period
        // we just read from the registry (INFINITE if we read none).
        //
        if (ServiceRecord->CrashRecord == NULL)
        {
            ServiceRecord->CrashRecord = new CCrashRecord;
        }

        if (ServiceRecord->CrashRecord == NULL)
        {
            SC_LOG0(ERROR, "Couldn't allocate service's crash record\n");
            //
            // NOTE: We still continue, taking the failure count to be 1.
            // (The crash record is used only in the "else" clause.)
            //
        }
        else
        {
            FailNum = ServiceRecord->CrashRecord->IncrementCount(ResetPeriod);
        }

        //
        // Figure out which recovery action we're going to take.
        //
        if (psfa != NULL && psfa->cActions > 0)
        {
            SC_ACTION * lpsaActions = (SC_ACTION *) ((LPBYTE) psfa + psfa->dwsaActionsOffset);
            DWORD i                 = min(FailNum, psfa->cActions);

            ActionType  = lpsaActions[i - 1].Type;
            ActionDelay = lpsaActions[i - 1].Delay;

            if (ACTION_TYPE_INVALID(ActionType))
            {
                SC_LOG(ERROR, "Service has invalid action type %lu\n", ActionType);
                ActionType = SC_ACTION_NONE;
            }
        }

        LocalFree(psfa);
    }

    //
    // Log an event about this service failing, and about the proposed
    // recovery action.
    //
    
    if (ActionType != SC_ACTION_NONE)
    {
        WCHAR wszActionString[50];
        if (!LoadString(GetModuleHandle(NULL),
                        IDS_SC_ACTION_BASE + ActionType,
                        wszActionString,
                        LENGTH(wszActionString)))
        {
            SC_LOG(ERROR, "LoadString failed %lu\n", GetLastError());
            wszActionString[0] = L'\0';
        }

        SC_LOG2(ERROR, "The following recovery action will be taken in %d ms: %ws.\n",
                    ActionDelay, wszActionString);

        ScLogEvent(NEVENT_SERVICE_CRASH,
                   ServiceRecord->DisplayName,
                   FailNum,
                   ActionDelay,
                   ActionType,
                   wszActionString);
    }
    else
    {
        ScLogEvent(NEVENT_SERVICE_CRASH_NO_ACTION,
                   ServiceRecord->DisplayName,
                   FailNum);
    }

    //
    // Queue a work item that will actually carry out the action after the
    // delay has elapsed.
    //
    switch (ActionType)
    {
    case SC_ACTION_NONE:
        break;

    case SC_ACTION_RESTART:
        {
            CRestartContext * pCtx = new CRestartContext(ServiceRecord);
            if (pCtx == NULL)
            {
                SC_LOG0(ERROR, "Couldn't allocate restart context\n");
                break;
            }

            ntStatus = pCtx->AddDelayedWorkItem(ActionDelay,
                                                WT_EXECUTEONLYONCE);

            if (!NT_SUCCESS(ntStatus))
            {
                SC_LOG(ERROR, "Couldn't add restart work item 0x%x\n", ntStatus);
                delete pCtx;
            }

            break;
        }

    case SC_ACTION_REBOOT:
        {
            //
            // Get the reboot message for the service, if any
            //
            LPWSTR RebootMessage = NULL;
            ScReadRebootMessage(Key, &RebootMessage);
            if (RebootMessage != NULL)
            {
                //
                // Broadcast the message to all users.  Do this in a separate
                // thread so that we can release our exclusive lock on the
                // service database quickly.
                //
                CRebootMessageContext * pCtx = new CRebootMessageContext(
                                                    RebootMessage,
                                                    ActionDelay,
                                                    ServiceRecord->DisplayName
                                                    );
                if (pCtx == NULL)
                {
                    SC_LOG0(ERROR, "Couldn't allocate restart context\n");
                    LocalFree(RebootMessage);
                    break;
                }

                ntStatus = pCtx->AddWorkItem(WT_EXECUTEONLYONCE);

                if (!NT_SUCCESS(ntStatus))
                {
                    SC_LOG(ERROR, "Couldn't add restart work item 0x%x\n", ntStatus);
                    delete pCtx;
                }
            }
            else
            {
                //
                // Queue a work item to perform the reboot after the delay has
                // elapsed.
                // (CODEWORK Share this code with CRebootMessageContext::Perform)
                //
                LPWSTR DisplayNameCopy = LocalDup(ServiceRecord->DisplayName);
                CRebootContext * pCtx = new CRebootContext(
                                             ActionDelay,
                                             DisplayNameCopy
                                             );
                if (pCtx == NULL)
                {
                    SC_LOG0(ERROR, "Couldn't allocate reboot context\n");
                    LocalFree(DisplayNameCopy);
                }
                else
                {
                    ntStatus = pCtx->AddWorkItem(WT_EXECUTEONLYONCE);

                    if (!NT_SUCCESS(ntStatus))
                    {
                        SC_LOG(ERROR, "Couldn't add reboot work item 0x%x\n", ntStatus);
                        delete pCtx;
                    }
                }
            }
        }

        break;

    case SC_ACTION_RUN_COMMAND:
        {
            //
            // Get the failure command for the service, if any
            //
            CHeapPtr<LPWSTR> FailureCommand;
            ScReadFailureCommand(Key, &FailureCommand);
            if (FailureCommand == NULL)
            {
                SC_LOG0(ERROR, "Asked to run a failure command, but found "
                               "none for this service\n");
                ScLogRecoveryFailure(
                        SC_ACTION_RUN_COMMAND,
                        ServiceRecord->DisplayName,
                        ERROR_NO_RECOVERY_PROGRAM
                        );
                break;
            }

            //
            // Replace %1% in the failure command with the failure count.
            // (FormatMessage is *useless* for this purpose because it AV's
            // if the failure command contains a %2, %3 etc.!)
            //
            UNICODE_STRING Formatted;
            {
                UNICODE_STRING Unformatted;
                RtlInitUnicodeString(&Unformatted, FailureCommand);

                Formatted.Length = 0;
                Formatted.MaximumLength = Unformatted.MaximumLength + 200;
                Formatted.Buffer =
                            (LPWSTR) LocalAlloc(0, Formatted.MaximumLength);
                if (Formatted.Buffer == NULL)
                {
                    SC_LOG(ERROR, "Couldn't allocate formatted string, %lu\n", GetLastError());
                    break;
                }

                WCHAR Environment[30];
                wsprintf(Environment, L"1=%lu%c", FailNum, L'\0');

                NTSTATUS ntstatus = RtlExpandEnvironmentStrings_U(
                                        Environment,
                                        &Unformatted,
                                        &Formatted,
                                        NULL);

                if (!NT_SUCCESS(ntstatus))
                {
                    SC_LOG(ERROR, "RtlExpandEnvironmentStrings_U failed %#lx\n", ntstatus);
                    wcscpy(Formatted.Buffer, FailureCommand);
                }
            }

            CRunCommandContext * pCtx =
                new CRunCommandContext(ServiceRecord, Formatted.Buffer);
            if (pCtx == NULL)
            {
                SC_LOG0(ERROR, "Couldn't allocate RunCommand context\n");
                LocalFree(Formatted.Buffer);
                break;
            }

            ntStatus = pCtx->AddDelayedWorkItem(ActionDelay,
                                                WT_EXECUTEONLYONCE);

            if (!NT_SUCCESS(ntStatus))
            {
                SC_LOG(ERROR, "Couldn't add RunCommand work item 0x%x\n", ntStatus);
                delete pCtx;
            }
        }
        break;

    default:
        SC_ASSERT(0);
    }

    if (Key != NULL)
    {
        ScRegCloseKey(Key);
    }
}



DWORD
CCrashRecord::IncrementCount(
    DWORD       ResetSeconds
    )
/*++

Routine Description:

    Increments a service's crash count.

Arguments:

    ResetSeconds - Length, in seconds, of a period of no crashes after which
        the crash count should be reset to zero.

Return Value:

    The service's new crash count.

--*/
{
    __int64 SecondLastCrashTime = _LastCrashTime;
    GetSystemTimeAsFileTime((FILETIME *) &_LastCrashTime);

    if (ResetSeconds == INFINITE ||
        SecondLastCrashTime + ResetSeconds * FILETIMES_PER_SEC > _LastCrashTime)
    {
        _Count++;
    }
    else
    {
        SC_LOG(CONFIG_API, "More than %lu seconds have elapsed since last "
                           "crash, resetting crash count.\n",
                           ResetSeconds);
        _Count = 1;
    }

    SC_LOG(CONFIG_API, "Service's crash count is now %lu\n", _Count);
    return _Count;
}



VOID
CRestartContext::Perform(
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

--*/
{
    //
    // Make sure we were called because of a timeout
    //
    SC_ASSERT(fWaitStatus == TRUE);

    SC_LOG(CONFIG_API, "Restarting %ws service...\n", _ServiceRecord->ServiceName);

    RemoveDelayedWorkItem();

    //
    // CODEWORK  Allow arguments to the service.
    //
    DWORD status = ScStartServiceAndDependencies(_ServiceRecord, 0, NULL, FALSE);

    if (status == NO_ERROR)
    {
        status = _ServiceRecord->StartError;
        SC_LOG(CONFIG_API, "ScStartServiceAndDependencies succeeded, StartError = %lu\n",
               status);
    }
    else
    {
        SC_LOG(CONFIG_API, "ScStartServiceAndDependencies failed, %lu\n", status);
        //
        // Should we treat ERROR_SERVICE_ALREADY_RUNNING as a success?
        // No, because it could alert the administrator to a less-than-
        // optimal system configuration wherein something else is
        // restarting the service.
        //
        ScLogRecoveryFailure(
                SC_ACTION_RESTART,
                _ServiceRecord->DisplayName,
                status
                );
    }

    delete this;
}



VOID
CRebootMessageContext::Perform(
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

--*/
{
    //
    // Broadcast the reboot message to all users
    //
    SESSION_INFO_0 * Buffer = NULL;
    DWORD    EntriesRead = 0, TotalEntries = 0;
    NTSTATUS ntStatus;

    NET_API_STATUS Status = NetSessionEnum(
        NULL,           // servername 	
        NULL,           // UncClientName 	
        NULL,           // username 	
        0,              // level 	
        (LPBYTE *) &Buffer,
        0xFFFFFFFF,     // prefmaxlen 	
        &EntriesRead,
        &TotalEntries,
        NULL            // resume_handle 	
        );

    if (EntriesRead > 0)
    {
        SC_ASSERT(EntriesRead == TotalEntries);
        SC_ASSERT(Status == NERR_Success);
        WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD nSize = LENGTH(ComputerName);
        if (!GetComputerName(ComputerName, &nSize))
        {
            SC_LOG(ERROR, "GetComputerName failed! %lu\n", GetLastError());
        }
        else
        {
            DWORD MsgLen = (DWORD) WCSSIZE(_RebootMessage);
            for (DWORD i = 0; i < EntriesRead; i++)
            {
                Status = NetMessageBufferSend(
                    NULL,                   // servername
                    Buffer[i].sesi0_cname,  // msgname
                    ComputerName,           // fromname
                    (LPBYTE) _RebootMessage,// buf
                    MsgLen                  // buflen	
                    );	
                if (Status != NERR_Success)
                {
                    SC_LOG2(ERROR, "NetMessageBufferSend to %ws failed %lu\n",
                                   Buffer[i].sesi0_cname, Status);
                }
            }
        }
    }
    else if (Status != NERR_Success)
    {
        SC_LOG(ERROR, "NetSessionEnum failed %lu\n", Status);
    }

    if (Buffer != NULL)
    {
        NetApiBufferFree(Buffer);
    }

    //
    // Queue a work item to perform the reboot after the delay has elapsed.
    // Note: We're counting the delay from the time that the broadcast finished.
    //
    CRebootContext * pCtx = new CRebootContext(_Delay, _DisplayName);
    if (pCtx == NULL)
    {
        SC_LOG0(ERROR, "Couldn't allocate reboot context\n");
    }
    else
    {
        _DisplayName = NULL;    // pCtx will free it

        ntStatus = pCtx->AddWorkItem(WT_EXECUTEONLYONCE);

        if (!NT_SUCCESS(ntStatus))
        {
            SC_LOG(ERROR, "Couldn't add reboot work item 0x%x\n", ntStatus);
            delete pCtx;
        }
    }

    delete this;
}



VOID
CRebootContext::Perform(
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

--*/
{
    SC_LOG0(CONFIG_API, "Rebooting machine...\n");
    // Write an event log entry?

    //
    // Enable our shutdown privilege.  Since we are shutting down, don't
    // bother doing it for only the current thread and don't bother
    // disabling it afterwards.
    //
    BOOLEAN WasEnabled;
    NTSTATUS Status = RtlAdjustPrivilege(
                            SE_SHUTDOWN_PRIVILEGE,
                            TRUE,           // enable
                            FALSE,          // this thread only? - No
                            &WasEnabled);

    if (!NT_SUCCESS(Status))
    {
        SC_LOG(ERROR, "RtlAdjustPrivilege failed! %#lx\n", Status);
        SC_ASSERT(0);
    }
    else
    {
        WCHAR   wszShutdownText[128];
        WCHAR   wszPrintableText[128 + MAX_SERVICE_NAME_LENGTH];

        if (LoadString(GetModuleHandle(NULL),
                       IDS_SC_REBOOT_MESSAGE,
                       wszShutdownText,
                       LENGTH(wszShutdownText)))
        {
            wsprintf(wszPrintableText, wszShutdownText, _DisplayName);
        }
        else
        {
            //
            // If LoadString failed, it probably means the buffer
            // is too small to hold the localized string
            //
            SC_LOG(ERROR, "LoadString failed! %lu\n", GetLastError());
            SC_ASSERT(FALSE);

            wszShutdownText[0] = L'\0';
        }
                          

        if (!InitiateSystemShutdownEx(NULL,                // machine name
                                      wszPrintableText,    // reboot message
                                      _Delay / 1000,       // timeout in seconds
                                      TRUE,                // force apps closed
                                      TRUE,                // reboot
                                      SHTDN_REASON_MAJOR_SOFTWARE |
                                        SHTDN_REASON_MINOR_UNSTABLE))
        {
            DWORD  dwError = GetLastError();

            //
            // If two services fail simultaneously and both are configured
            // to reboot the machine, InitiateSystemShutdown will fail all
            // calls past the first with ERROR_SHUTDOWN_IN_PROGRESS.  We
            // don't want to log an event in this case.
            //
            if (dwError != ERROR_SHUTDOWN_IN_PROGRESS) {

                SC_LOG(ERROR, "InitiateSystemShutdown failed! %lu\n", dwError);
                ScLogRecoveryFailure(
                        SC_ACTION_REBOOT,
                        _DisplayName,
                        dwError
                        );
            }
        }
    }

    delete this;
}



VOID
CRunCommandContext::Perform(
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

    CODEWORK Share this code with ScLogonAndStartImage

--*/
{
    //
    // Make sure we were called because of a timeout
    //
    SC_ASSERT(fWaitStatus == TRUE);

    DWORD status = NO_ERROR;

    HANDLE Token = NULL;
    PSID   ServiceSid = NULL;       // SID is returned only if not LocalSystem
    LPWSTR AccountName = NULL;
    SECURITY_ATTRIBUTES SaProcess;  // Process security info (used only if not LocalSystem)
    STARTUPINFOW StartupInfo;
    PROCESS_INFORMATION ProcessInfo;

    RemoveDelayedWorkItem();

    //
    // Get the Account Name for the service.  A NULL Account Name means the
    // service is configured to run in the LocalSystem account.
    //
    status = ScLookupServiceAccount(
                _ServiceRecord->ServiceName,
                &AccountName
                );

    // We only need to log on if it's not the LocalSystem account
    if (AccountName != NULL)
    {
        //
        // CODEWORK:  Keep track of recovery EXEs spawned so we can
        //            load/unload the user profile for the process.
        //
        status = ScLogonService(
                    _ServiceRecord->ServiceName,
                    AccountName,
                    &Token,
                    NULL,
                    &ServiceSid
                    );

        if (status != NO_ERROR)
        {
            SC_LOG(ERROR, "CRunCommandContext: ScLogonService failed, %lu\n", status);
            goto Clean0;
        }

        SaProcess.nLength = sizeof(SECURITY_ATTRIBUTES);
        SaProcess.bInheritHandle = FALSE;

        SC_ACE_DATA AceData[] =
            {
                {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                       PROCESS_ALL_ACCESS,           &ServiceSid},

                {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                       PROCESS_SET_INFORMATION |
                           PROCESS_TERMINATE |
                           SYNCHRONIZE,              &LocalSystemSid}
            };

        NTSTATUS ntstatus = ScCreateAndSetSD(
                               AceData,                 // AceData
                               LENGTH(AceData),         // AceCount
                               NULL,                    // OwnerSid (optional)
                               NULL,                    // GroupSid (optional)
                               &SaProcess.lpSecurityDescriptor
                                                        // pNewDescriptor
                               );

        LocalFree(ServiceSid);

        if (! NT_SUCCESS(ntstatus))
        {
            SC_LOG(ERROR, "CRunCommandContext: ScCreateAndSetSD failed %#lx\n", ntstatus);
            status = RtlNtStatusToDosError(ntstatus);
            goto Clean1;
        }

        SC_LOG2(CONFIG_API,"CRunCommandContext: about to spawn recovery program in account %ws: %ws\n",
                 AccountName, _FailureCommand);

        //
        // Impersonate the user so we don't give access to
        // EXEs that have been locked down for the account.
        //
        if (!ImpersonateLoggedOnUser(Token))
        {
            status = GetLastError();

            SC_LOG1(ERROR,
                    "ScLogonAndStartImage:  ImpersonateLoggedOnUser failed %d\n",
                    status);

            goto Clean2;
        }


        //
        // Spawn the Image Process
        //

        ScInitStartupInfo(&StartupInfo, FALSE);

        if (!CreateProcessAsUserW(
                 Token,              // logon token
                 NULL,               // lpApplicationName
                 _FailureCommand,    // lpCommandLine
                 &SaProcess,         // process' security attributes
                 NULL,               // first thread's security attributes
                 FALSE,              // whether new process inherits handles
                 CREATE_NEW_CONSOLE, // creation flags
                 NULL,               // environment block
                 NULL,               // current directory
                 &StartupInfo,       // startup info
                 &ProcessInfo        // process info
                 ))
         {
             status = GetLastError();
             SC_LOG(ERROR, "CRunCommandContext: CreateProcessAsUser failed %lu\n", status);
             RevertToSelf();
             goto Clean2;
         }

         RevertToSelf();
    }
    else
    {
       //
       // It's the LocalSystem account
       //

       //
       // If the process is to be interactive, set the appropriate flags.
       //

       BOOL bInteractive = FALSE;

       if (AccountName == NULL &&
          _ServiceRecord->ServiceStatus.dwServiceType & SERVICE_INTERACTIVE_PROCESS)
       {
          bInteractive = ScAllowInteractiveServices();

          if (!bInteractive)
          {
              //
              // Write an event to indicate that an interactive service
              // was started, but the system is configured to not allow
              // services to be interactive.
              //

              ScLogEvent(NEVENT_SERVICE_NOT_INTERACTIVE,
                      _ServiceRecord->DisplayName);
          }
       }

       ScInitStartupInfo(&StartupInfo, bInteractive);

       SC_LOG1(CONFIG_API,"CRunCommandContext: about to spawn recovery program in "
                 "the LocalSystem account: %ws\n", _FailureCommand);

       //
       // Spawn the Image Process
       //

       if (!CreateProcessW(
               NULL,               // lpApplicationName
               _FailureCommand,    // lpCommandLine
               NULL,               // process' security attributes
               NULL,               // first thread's security attributes
               FALSE,              // whether new process inherits handles
               CREATE_NEW_CONSOLE, // creation flags
               NULL,               // environment block
               NULL,               // current directory
               &StartupInfo,       // startup info
               &ProcessInfo        // process info
               ))
       {
           status = GetLastError();
           SC_LOG(ERROR, "CRunCommandContext: CreateProcess failed %lu\n", status);
           goto Clean2;
       }
    }

    SC_LOG0(CONFIG_API, "Recovery program spawned successfully.\n");

    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);

Clean2:
    if (AccountName != NULL)
    {
        RtlDeleteSecurityObject(&SaProcess.lpSecurityDescriptor);
    }

Clean1:
    if (AccountName != NULL)
    {
        CloseHandle(Token);
    }

Clean0:
    if (status != NO_ERROR)
    {
        ScLogRecoveryFailure(
                SC_ACTION_RUN_COMMAND,
                _ServiceRecord->DisplayName,
                status
                );
    }

    delete this;
}



VOID
ScLogRecoveryFailure(
    IN  SC_ACTION_TYPE  ActionType,
    IN  LPCWSTR         ServiceDisplayName,
    IN  DWORD           Error
    )

/*++

Routine Description:

--*/
{
    WCHAR wszActionString[50];
    if (!LoadString(GetModuleHandle(NULL),
                    IDS_SC_ACTION_BASE + ActionType,
                    wszActionString,
                    LENGTH(wszActionString)))
    {
        SC_LOG(ERROR, "LoadString failed %lu\n", GetLastError());
        wszActionString[0] = L'\0';
    }

    ScLogEvent(
            NEVENT_SERVICE_RECOVERY_FAILED,
            ActionType,
            wszActionString,
            (LPWSTR) ServiceDisplayName,
            Error
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\dataman.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dataman.cxx

Abstract:

    Contains code for the Service Control Database manager.  This includes
    all the linked list routines.  This file contains the following
    functions:
        ScGetOrderGroupList
        ScGetStandaloneGroupList
        ScGetServiceDatabase
        ScGetUnresolvedDependList

        ScActivateServiceRecord
        ScCreateImageRecord
        ScCreateServiceRecord
        ScFreeServiceRecord
        ScAddConfigInfoServiceRecord
        ScDecrementUseCountAndDelete
        ScProcessDeferredList
        ScFindEnumStart
        ScGetNamedImageRecord
        ScGetNamedServiceRecord
        ScGetDisplayNamedServiceRecord
        ScGetTotalNumberOfRecords
        ScInitDatabase
        ScProcessCleanup
        ScDeleteMarkedServices

        ScRemoveService
        ScDeleteImageRecord         (internal only)
        ScDeactivateServiceRecord
        ScTerminateServiceProcess   (internal only)
        ScUpdateServiceRecordConfig

        ScNotifyServiceObject

Author:

    Dan Lafferty (danl)     04-Feb-1992

Environment:

    User Mode -Win32

Revision History:

    22-Oct-1998     jschwart
        Convert SCM to use NT thread pool APIs
    22-Oct-1997     JSchwart  (after AnirudhS in _CAIRO_ 12-Apr-1995)
        Enabled changes made in ifdef _CAIRO_ on 12-Apr-1995.
        Removed ScNotifyServiceObject.
    08-Jan-1997     AnirudhS
        Replaced ScDatabaseLockFcn and ScGroupListLock with the new
        locking scheme in lock.cxx.  Rewrote ScDeferredList processing.
    04-Dec-1996     AnirudhS
        Added calls to service crash recovery code.
    12-Jul-1996     AnirudhS
        ScDecrementUseCountAndDelete: Don't actually process the deferred
        list in this routine, because a number of calling routines assume
        that the service record does NOT go away when they call this routine.
        Instead, process it when a database lock is released.
    25-Jun-1996     AnirudhS
        ScProcessCleanup: Fix the use of a freed service record.  Don't
        try to upgrade shared lock to exclusive, as it can deadlock.
    25-Oct-1995     AnirudhS
        ScAddConfigInfoServiceRecord: Fix heap corruption bug caused by
        security descriptor being freed twice, the second time by
        ScProcessDeferredList.
    20-Sep-1995     AnirudhS
        ScDeleteMarkedServices: Fix heap corruption bug caused by service
        record being deleted using LocalFree instead of HeapFree.
    26-Jun-1995     AnirudhS
        Added ScNotifyServiceObject.
    12-Apr-1995     AnirudhS
        Added AccountName field to image record.
    21-Jan-1994     Danl
        ScAddConfigInfoServiceRecord: If no DisplayName, or the DisplayName
        is an empty string, or the DisplayName is the same as the
        ServiceName, then just point to the ServiceName for the DisplayName.
    22-Oct-1993     Danl
        Moved Group and Dependency function into groupman.c.
    16-Sept-1993    Danl
        ScProcessCleanup: Get the shared lock prior to walking through the
        database looking for the one to cleanup.  Then get the exclusive
        lock to modify it.  Remove assert.
    12-Feb-1993     Danl
        ScActivateServiceRecord now increments the UseCount.  This is to
        balance the fact that we decrement the UseCount when we
        deactivate the service record.
    28-Aug-1992     Danl
        Re-Added ScGetTotalNumberOfRecords  function.  This is needed
        by the ScShutdownAllServices function.
    14-Apr-1992     JohnRo
        Use SC_ASSERT() macro.
        Made changes suggested by PC-LINT.
    10-Apr-1992     JohnRo
        Use ScImagePathsMatch() to allow mixed-case image names.
        Make sure DeleteFlag gets a value when service record is created.
        Added some assertion checks.
    04-Feb-1992     Danl
        created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <userenv.h>    // UnloadUserProfile
#include <stdlib.h>     // wide character c runtimes.
#include <ntrpcp.h>     // MIDL_user_allocate
#include <control.h>    // SendControl
#include "scconfig.h"   // ScGenerateServiceDB,ScInitSecurityProcess
#include "scsec.h"      // ScCreateScServiceObject
#include "account.h"    // ScRemoveAccount
#include <sclib.h>      // ScImagePathsMatch().
#include "bootcfg.h"    // ScDeleteRegTree().
#include <strarray.h>   // ScWStrArraySize

extern "C" {

#include <cfgmgr32.h>
#include "cfgmgrp.h"    // RegisterServiceNotification

}

//
// Macros
//

// for every service record in the database...
// (a slightly more efficient definition of this macro for use within
// this file)
//
#undef  FOR_ALL_SERVICES
#define FOR_ALL_SERVICES(SR)                                    \
             SC_ASSERT(ScServiceListLock.Have());               \
             for (LPSERVICE_RECORD SR = ServiceDatabase.Next;   \
                  SR != NULL;                                   \
                  SR = SR->Next)


//
// Defines and Typedefs
//
class DEFER_LIST
{
public:
    VOID                Add    (LPSERVICE_RECORD    ServiceRecord);
    VOID                Process();

private:
    DWORD               TotalElements;      // size of ServiceRecPtr array
    DWORD               NumElements;        // numElements in array
    LPSERVICE_RECORD *  ServiceRecordPtr;   // pointer to array
};




//
//  Globals
//
    //
    // These are the linked list heads for each of the databases
    // that are maintained.
    //

    IMAGE_RECORD      ImageDatabase;
    SERVICE_RECORD    ServiceDatabase;

    DWORD             ScTotalNumServiceRecs;// number of services

    //
    // Service Record index number.  This allows enumeration to be broken
    // up into several calls.
    //
    DWORD             ResumeNumber;

    //
    // The ScGlobalDeferredList points to a structure that contains an
    // array of pointers to service records. The first two elements in
    // the structure contain the size and number of element information
    // about the array.
    // Access to the list is guarded by ScServiceRecordLock.
    //
    DEFER_LIST        ScDeferredList;

    //
    // ServiceRecord Heap Information
    //
    // ServiceRecord Heap -  is where all the service records are allocated
    //  from.
    // OrderedHash Heap - Service Names can be found via a (very simple) hash
    //  table.  There is an array of pointers (one for each letter of
    //  alphabet), where each pointer points to the top of an array of
    //  pointers to service records.   All the service records in that array
    //  will have names beginning with the same letter.  The service record
    //  pointers will be ordered as to the frequency of access.
    //
    HANDLE      ServiceRecordHeap = NULL;
    HANDLE      OrderedHashHeap = NULL;


//
// Local Function Prototypes
//

VOID
ScDeferredListWorkItem(
    IN PVOID    pContext
    );


//****************************************************************************/
// Miscellaneous Short Functions
//****************************************************************************/

LPSERVICE_RECORD
ScGetServiceDatabase(
    VOID
    )
{
    return ServiceDatabase.Next;
}


/****************************************************************************/
VOID
ScActivateServiceRecord (
    IN LPSERVICE_RECORD     ServiceRecord,
    IN LPIMAGE_RECORD       ImageRecord
    )

/*++

Routine Description:

    This function can be called with or without a pointer to an ImageRecord.

    If it is called without the pointer to the ImageRecord, just the
    ServiceRecord is initialized to the START_PENDING state, and the UseCount
    is incremented.

    If it is called with the pointer to the ImageRecord, then the ImageRecord
    pointer is added to the ServiceRecord, and the ImageUseCount
    is incremented.

Arguments:

    ServiceRecord - This is a pointer to the ServiceRecord that is to be
        activated.

    ImageRecord - This is a pointer to the ImageRecord that the service
        record will point to.

Notes:

    This routine assumes that the Exclusive database lock has already
    been obtained.

Return Value:

    returns 0.  (It used to return a service count - but it wasn't used
    anywhere).

--*/
{
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ImageRecord == NULL)
    {
        ServiceRecord->ImageRecord = NULL;
        ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
        ServiceRecord->ServiceStatus.dwControlsAccepted = 0;
        ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
        ServiceRecord->ServiceStatus.dwServiceSpecificExitCode = 0;
        ServiceRecord->ServiceStatus.dwCheckPoint = 0;
        ServiceRecord->ServiceStatus.dwWaitHint = 2000;
        ServiceRecord->UseCount++;
        SC_LOG2(USECOUNT, "ScActivateServiceRecord: " FORMAT_LPWSTR
            " increment USECOUNT=%lu\n",
            ServiceRecord->ServiceName,
            ServiceRecord->UseCount);
    }
    else
    {
        //
        // Increment the service count in the image record.
        //
        ServiceRecord->ImageRecord = ImageRecord;
        ServiceRecord->ImageRecord->ServiceCount++;
    }

    return;
}

/****************************************************************************/
DWORD
ScCreateImageRecord (
    OUT     LPIMAGE_RECORD      *ImageRecordPtr,
    IN      LPWSTR              ImageName,
    IN      LPWSTR              AccountName,
    IN      DWORD               Pid,
    IN      HANDLE              PipeHandle,
    IN      HANDLE              ProcessHandle,
    IN      HANDLE              TokenHandle,
    IN      HANDLE              ProfileHandle,
    IN      DWORD               ImageFlags
    )

/*++

Routine Description:

    This function allocates storage for a new Image Record, and links
    it into the Image Record Database.  It also initializes all fields
    in the record with the passed in information.

Arguments:

    ImageRecordPtr - This is a pointer to where the image record pointer
        is to be placed.

    ImageName - This is a pointer to a NUL terminated string containing
        the name of the image file.

    AccountName - This is either NULL (to represent the LocalSystem account)
        or a pointer to a NUL terminated string containing the name of the
        account under which the image was started.

    Pid - This is the Process ID for that the image is running in.

    PipeHandle - This is a handle to the pipe that is used to communicat
        with the image process.

    ProcessHandle - This is a handle to the image process object.

    TokenHandle - This is a handle to the process's logon token.  It
        is NULL if the process runs in the LocalSystem context.

    ProfileHandle -

    ImageFlags -

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate buffer for the image
        record.

    ERROR_LOCKED - Exclusive access to the database could
        not be obtained.

Note:

    This routine temporarily acquires the exclusive database lock.

--*/
{
    LPIMAGE_RECORD      imageRecord;    // The new image record pointer
    LPIMAGE_RECORD      record ;        // Temporary pointer
    LPWSTR              stringArea;     // String area in allocated buffer.

    TOKEN_STATISTICS    TokenStats;
    DWORD               dwError;

    //
    // Allocate space for the new record (including the string)
    //

    imageRecord = (LPIMAGE_RECORD)LocalAlloc(LMEM_ZEROINIT,
                    sizeof(IMAGE_RECORD)
                    + WCSSIZE(ImageName)
                    + (AccountName ? WCSSIZE(AccountName) : 0)
                   );

    if (imageRecord == NULL)
    {
        SC_LOG(TRACE,"CreateImageRecord: Local Alloc failure rc=%ld\n",
            GetLastError());
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Copy the strings into the new buffer space.
    //

    stringArea = (LPWSTR)(imageRecord + 1);
    (VOID) wcscpy (stringArea, ImageName);
    imageRecord->ImageName = stringArea;

    if (AccountName)
    {
        stringArea += (wcslen(stringArea) + 1);
        (VOID) wcscpy (stringArea, AccountName);
        imageRecord->AccountName = stringArea;
    }
    else
    {
        imageRecord->AccountName = NULL;
    }

    //
    // Update the rest of the fields in the Image Record
    //

    imageRecord->Next = NULL;
    imageRecord->Pid = Pid;
    imageRecord->PipeHandle = PipeHandle;
    imageRecord->ProcessHandle = ProcessHandle;
    imageRecord->ServiceCount = 0;
    imageRecord->TokenHandle = TokenHandle;
    imageRecord->ProfileHandle = ProfileHandle;
    imageRecord->ObjectWaitHandle = NULL;
    imageRecord->ImageFlags = ImageFlags;

    if (TokenHandle == NULL)
    {
        LUID SystemLuid = SYSTEM_LUID;

        RtlCopyLuid(&imageRecord->AccountLuid, &SystemLuid);
    }
    else
    {
        //
        // Get the unique session ID for this process
        //
        if (!GetTokenInformation(TokenHandle,
                                 TokenStatistics,        // Information wanted
                                 &TokenStats,
                                 sizeof(TokenStats),     // Buffer size
                                 &dwError))              // Size required
        {
            dwError = GetLastError();

            SC_LOG1(ERROR,
                    "ScCreateImageRecord: GetTokenInformation FAILED %d\n",
                    dwError);

            LocalFree(imageRecord);
            return dwError;
        }

        imageRecord->AccountLuid.LowPart  = TokenStats.AuthenticationId.LowPart;
        imageRecord->AccountLuid.HighPart = TokenStats.AuthenticationId.HighPart;
    }

    //
    //  Add record to the Image Database linked list.
    //

    CServiceRecordExclusiveLock Lock;

    record = &ImageDatabase;
    ADD_TO_LIST(record, imageRecord);

    *ImageRecordPtr = imageRecord;

    return(NO_ERROR);
}

/****************************************************************************/
DWORD
ScCreateServiceRecord(
    IN  LPWSTR              ServiceName,
    OUT LPSERVICE_RECORD   *ServiceRecord
    )

/*++

Routine Description:

    This function creates a new "inactive" service record and adds it to
    the service record list.  A resume number is assigned so that it
    can be used as a key in enumeration searches.

    To initialize the service record with the fields from the registry,
    call ScAddConfigInfoServiceRecord.


Arguments:

    ServiceName - This is a pointer to the NUL terminated service name
        string.

    ServiceRecord - Receives a pointer to the service record created and
        inserted into the service record list.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a new
        service record failed.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.

--*/

{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    record;         // Temporary pointer
    LPWSTR              nameArea;       // NameString area in allocated buffer.
    DWORD               nameSize;       // num bytes in service name.

    SC_ASSERT(ScServiceListLock.HaveExclusive());

    // (The service record lock is not needed here since we don't touch
    // the service record after adding it to the service list)

    //
    // Allocate the new service record.
    //
    nameSize = (DWORD) WCSSIZE(ServiceName);

    (*ServiceRecord) = (LPSERVICE_RECORD)HeapAlloc(
                           ServiceRecordHeap,
                           HEAP_ZERO_MEMORY,
                           nameSize + sizeof(SERVICE_RECORD)
                           );

    if ((*ServiceRecord) == NULL)
    {
        SC_LOG0(ERROR,"CreateServiceRecord: HeapAlloc failure\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the ServiceName into the new buffer space.
    //

    nameArea = (LPWSTR)((LPBYTE)(*ServiceRecord) + sizeof(SERVICE_RECORD));
    (VOID) wcscpy (nameArea, ServiceName);

    //
    // At this point we have the space for a service record, and it
    // contains the name of the service.
    //

    //
    //  Fill in all the fields that need to be non-zero.
    //  Note:  The display name is initialized to point to the service name.
    //

    (*ServiceRecord)->ServiceName    = nameArea;
    (*ServiceRecord)->DisplayName    = nameArea;
    (*ServiceRecord)->ResumeNum      = ResumeNumber++;
    (*ServiceRecord)->Signature      = SERVICE_SIGNATURE;
    (*ServiceRecord)->ImageRecord    = NULL;
    (*ServiceRecord)->StartDepend    = NULL;
    (*ServiceRecord)->StopDepend     = NULL;
    (*ServiceRecord)->ErrorControl   = SERVICE_ERROR_NORMAL;
    (*ServiceRecord)->StatusFlag     = 0;
    (*ServiceRecord)->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    (*ServiceRecord)->ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_NEVER_STARTED;
    (*ServiceRecord)->StartState     = SC_NEVER_STARTED;


    //
    // Add the service to the service record linked list.
    //

    record = &ServiceDatabase;

    ADD_TO_LIST(record, (*ServiceRecord));

    ScTotalNumServiceRecs++;

    return(status);
}


/****************************************************************************/
VOID
ScFreeServiceRecord(
    IN  LPSERVICE_RECORD   ServiceRecord
    )

/*++

Routine Description:

    This function frees up a service record that has already been removed
    from the service record list.

Arguments:

    ServiceRecord - Receives a pointer to the service record to free.

--*/
{
    if (!HeapFree(ServiceRecordHeap, 0, ServiceRecord))
    {
        SC_LOG2(ERROR,
                "ScFreeServiceRecord: HeapFree for %ws service failed %d\n",
                ServiceRecord->ServiceName,
                GetLastError());
    }

    return;
}


/****************************************************************************/
DWORD
ScAddConfigInfoServiceRecord(
    IN  LPSERVICE_RECORD     ServiceRecord,
    IN  DWORD                ServiceType,
    IN  DWORD                StartType,
    IN  DWORD                ErrorControl,
    IN  LPWSTR               Group OPTIONAL,
    IN  DWORD                Tag,
    IN  LPWSTR               Dependencies OPTIONAL,
    IN  LPWSTR               DisplayName OPTIONAL,
    IN  PSECURITY_DESCRIPTOR Sd OPTIONAL
    )

/*++

Routine Description:

    This function adds the configuration information to the service
    record.

    NOTE: This function is called when the service controller is
    reading service entries from the registry at startup, as well as
    from RCreateServiceW.

Arguments:

    ServiceRecord - Pointer to the service record to modify.

    DisplayName - A string that is the displayable name for the service.

    ServiceType - Indicates whether the ServiceRecord is for a win32 service
        or a device driver.

    StartType - Specifies when to start the service: automatically at boot or
        on demand.

    ErrorControl - Specifies the severity of the error if the service fails
        to start.

    Tag - DWORD identifier for the service.  0 means no tag.

    Group - Name of the load order group this service is a member of.

    Dependencies - Names of services separated by colon which this service
        require to be started before it can run.

    Sd - Security descriptor for the service object.  If NULL, i.e. could
        not read from registry, create a default one.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a new
        service record or display name failed.

Note:

    This routine assumes that the caller has exclusively acquired both the
    database lock and the GroupListLock.

    If this call is successful, do the following before freeing the memory
    of the service record in ScDecrementUseCountAndDelete:

        ScDeleteStartDependencies(ServiceRecord);
        ScDeleteGroupMembership(ServiceRecord);
        ScDeleteRegistryGroupPointer(ServiceRecord);


--*/
{
    DWORD status;

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    //  Fill in the service record.
    //
    ServiceRecord->StartType = StartType;
    ServiceRecord->ServiceStatus.dwServiceType = ServiceType;
    ServiceRecord->ErrorControl = ErrorControl;
    ServiceRecord->Tag = Tag;

    //
    // The display name in the service record already points to the
    // ServiceName string.  If the DisplayName is present and different
    // from the ServiceName, then allocate storage for it and copy the
    // string there.
    //
    SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: Allocate for display name\n");

    if ((DisplayName != NULL) && (*DisplayName != L'\0') &&
        (_wcsicmp(DisplayName,ServiceRecord->ServiceName) != 0))
    {
        ServiceRecord->DisplayName = (LPWSTR)LocalAlloc(
                                            LMEM_FIXED,
                                            WCSSIZE(DisplayName));

        if (ServiceRecord->DisplayName == NULL)
        {
            SC_LOG(TRACE,"ScAddConfigInfoServiceRecord: LocalAlloc failure rc=%ld\n",
                GetLastError());

            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(ServiceRecord->DisplayName,DisplayName);
    }

    //
    // Create a default security descriptor for the service.
    //
    if (! ARGUMENT_PRESENT(Sd))
    {
        SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: create service obj\n");

        if ((status = ScCreateScServiceObject(
                          &ServiceRecord->ServiceSd
                          )) != NO_ERROR)
        {
            goto ErrorExit;
        }
    }
    else
    {
        SC_LOG1(SECURITY,
                "ScAddConfigInfoServiceRecord: Using " FORMAT_LPWSTR
                " descriptor from registry\n", ServiceRecord->ServiceName);
        ServiceRecord->ServiceSd = Sd;
    }

    SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: Get Group List Lock\n");

    //
    // Save the group membership information.
    //
    SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: create group memebership\n");
    if ((status = ScCreateGroupMembership(
                      ServiceRecord,
                      Group
                      )) != NO_ERROR)
    {
        goto ErrorExit;
    }

    SC_LOG0(SECURITY,"ScAddConfigInfoServiceRecord: create Reg Grp Ptr\n");
    if ((status = ScCreateRegistryGroupPointer(
                      ServiceRecord,
                      Group
                      )) != NO_ERROR)
    {
        ScDeleteGroupMembership(ServiceRecord);
        goto ErrorExit;
    }


    //
    // Don't create dependencies list yet.  Just save the string in
    // the service record.
    //
    if ((Dependencies != NULL) && (*Dependencies != 0))
    {
        //
        // If StartType is BOOT_START or SYSTEM_START, it is invalid
        // for the service to be dependent on another service.  It can
        // only be dependent on a group.
        //
        // N.B. This check has been removed. There doesn't seem to be
        //      any point in enforcing it, and remote boot needs to
        //      allow NetBT to be dependent Tcpip.
        //

        DWORD DependenciesSize = 0;
        DWORD EntryByteCount;
        LPWSTR Entry = Dependencies;


        while (*Entry != 0)
        {
#if 0
            if (StartType == SERVICE_BOOT_START ||
                StartType == SERVICE_SYSTEM_START)
            {
                if (*Entry != SC_GROUP_IDENTIFIERW)
                {
                    SC_LOG1(ERROR, "ScAddConfigInfoServiceRecord: Boot or System "
                            "start driver " FORMAT_LPWSTR " must depend on a group\n",
                            ServiceRecord->DisplayName);

                    ScEvent(
                        EVENT_INVALID_DRIVER_DEPENDENCY,
                        ServiceRecord->DisplayName
                        );

                    status = ERROR_INVALID_PARAMETER;

                    ScDeleteGroupMembership(ServiceRecord);
                    ScDeleteRegistryGroupPointer(ServiceRecord);

                    goto ErrorExit;
                }
            }
#endif

            EntryByteCount = (DWORD) WCSSIZE(Entry);  // This entry and its null.
            DependenciesSize += EntryByteCount;

            Entry = (LPWSTR) ((DWORD_PTR) Entry + EntryByteCount);
        }

        DependenciesSize += sizeof(WCHAR);

        ServiceRecord->Dependencies = (LPWSTR)LocalAlloc(
                                          0,
                                          DependenciesSize
                                          );

        if (ServiceRecord->Dependencies == NULL)
        {
            ScDeleteGroupMembership(ServiceRecord);
            ScDeleteRegistryGroupPointer(ServiceRecord);
            goto ErrorExit;
        }

        RtlCopyMemory(ServiceRecord->Dependencies, Dependencies, DependenciesSize);
    }

    return NO_ERROR;

ErrorExit:

    if (DisplayName != NULL)
    {
        //
        // Prevent ScProcessDeferredList from trying to free the same heap block
        // again later
        //

        LocalFree(ServiceRecord->DisplayName);
        ServiceRecord->DisplayName = NULL;
    }

    RtlDeleteSecurityObject(&ServiceRecord->ServiceSd);

    //
    // Prevent ScProcessDeferredList from trying to free the same heap block
    // again later
    //
    ServiceRecord->ServiceSd = NULL;

    return status;
}

/****************************************************************************/
VOID
ScDecrementUseCountAndDelete(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function decrements the UseCount for a service, and it the
    UseCount reaches zero and the service is marked for deletion,
    it puts a pointer to the service record into an array of
    such pointers that is stored in a deferred list structure.  The
    pointer to this structure is stored at the global location called
    ScDeferredList.  Access to this list is synchronized by use of the
    ScServiceRecordLock.

    A large number of routines in the service controller walk the
    service database and sometimes call this function, either directly
    or indirectly.  It would complicate the programming of all those
    routines if they all had to assume that service records could get
    deleted under them.  Therefore, this function never actually deletes
    any service record.  Instead, it starts a separate thread that first
    acquires all three locks exclusively and then processes the deferred
    list.

    Note:  By jumping through hoops, it is possible to avoid creating
    that thread in certain cases, but since service deletion is a rather
    rare operation, it was not considered worthwhile to create very-
    difficult-to-maintain code to optimize it.


    NOTE:  The caller is expected to hold the Exclusive DatabaseLock
    prior to calling this function.

    The following functions call this routine:
        ScDeactivateServiceRecord
        RCloseServiceHandle
        ScGetDriverStatus
        ScStartServiceAndDependencies

Arguments:

    ServiceRecord - This is a pointer to the service record that is having
        its use count deleted.

Return Value:

    none.

--*/
{
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ServiceRecord->UseCount == 0)
    {
        //
        // The use count should not ever be zero when we enter this routine.
        //
        SC_LOG1(ERROR,"ScDecrementUseCountAndDelete: Attempt to decrement UseCount beyond zero.\n"
        "\t"FORMAT_LPWSTR" \n", ServiceRecord->ServiceName);
        SC_ASSERT(FALSE);
    }
    else
    {
        if ((ServiceRecord->UseCount == 1) &&
            (DELETE_FLAG_IS_SET(ServiceRecord)))
        {
            //
            // If the use count is one, we have a special case.  We want
            // to postpone decrementing this last time until we have the
            // group list lock.
            //

            //
            // Put the service record pointer in the list, and start a
            // separate thread to process the list.
            //
            ScDeferredList.Add(ServiceRecord);
        }
        else
        {
            //
            // If the use count is greater than one, or the service is
            // NOT marked for delete, then we want to decrement the use
            // count and that is all.
            //
            ServiceRecord->UseCount--;
            SC_LOG2(USECOUNT, "ScDecrementUseCountAndDelete: " FORMAT_LPWSTR
                " decrement USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);
        }
    }
    return;
}

/****************************************************************************/
VOID
DEFER_LIST::Add(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function adds a service record to the list of service records to
    be deleted.  It then starts a thread that will acquire all the locks
    and perform the actual deletion, if such a thread hasn't already been
    started.

    ScServiceRecordLock is used to ensure that only one thread accesses
    the deferred list at a time.

    The following functions call this routine:
        ScDecrementUseCountAndDelete

--*/
{
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (NumElements + 1 > TotalElements)
    {
        //
        // Reallocate the array with a bit more room
        //
        DWORD NewTotalElements = TotalElements + 4;
        LPSERVICE_RECORD * NewArray = (LPSERVICE_RECORD *)
            LocalAlloc(0, NewTotalElements * sizeof(LPSERVICE_RECORD));
        if (NewArray == NULL)
        {
            SC_LOG(ERROR, "DEFER_LIST::Add: LocalAlloc FAILED %lu\n", GetLastError());
            return;
        }

        if (ServiceRecordPtr != NULL)
        {
            RtlCopyMemory(NewArray, ServiceRecordPtr,
                          NumElements * sizeof(LPSERVICE_RECORD));
            LocalFree(ServiceRecordPtr);
        }

        TotalElements = NewTotalElements;
        ServiceRecordPtr = NewArray;
    }

    //
    // At this point we have a deferred list that can hold the new element.
    //

    ServiceRecordPtr[NumElements] = ServiceRecord;
    NumElements++;
    SC_LOG(LOCKS, "Added %ws service to deferred list\n",
                  ServiceRecord->ServiceName);

    //
    // If we created the deferred list, queue a workitem (start a
    // thread) to process it.
    //
    if (NumElements == 1)
    {
        NTSTATUS ntStatus;

        ntStatus = RtlQueueWorkItem(ScDeferredListWorkItem, // callback function
                                    NULL,                   // context
                                    WT_EXECUTEONLYONCE);  // flags

        if (!NT_SUCCESS(ntStatus))
        {
            SC_LOG(ERROR,"Couldn't add DeferredListWorkItem, 0x%x\n",
                    ntStatus);
        }
        else
        {
            SC_LOG0(LOCKS,"Work item will process deferred list\n");
        }
    }
}

/****************************************************************************/
VOID
DEFER_LIST::Process(
    VOID
    )

/*++

Routine Description:

    This function loops through each service record pointer in the
    ScDeferredList, and decrements the UseCount for that ServiceRecord.
    If that count becomes zero, and if the ServiceRecord is marked
    for deletion, This routine will delete the service record and
    the registry entry for that service.

    This function frees the memory pointed to by ScDeferredList, when
    it is done processing the list.

    This routine acquires all 3 database locks.
    The following functions call this routine:
        CGroupListLock::Release

Arguments:

    none.

Return Value:

    none.

--*/
{
    //
    // Wait until we have acquired all 3 locks in the proper order
    //
    SC_LOG0(LOCKS, "In ScProcessDeferredList, waiting for locks\n");
    CGroupListExclusiveLock GLock;
    CServiceListExclusiveLock LLock;
    CServiceRecordExclusiveLock RLock;

    //
    // For each element in the list, delete the service information, and
    // free up its associated resources.
    //
    for (DWORD i=0; i<NumElements; i++)
    {
        LPSERVICE_RECORD ServiceRecord = ServiceRecordPtr[i];

        if (ServiceRecord->UseCount == 0)
        {
            SC_LOG1(ERROR,"ScProcessDeferredList: Attempt to decrement UseCount beyond zero.\n"
            "\t"FORMAT_LPWSTR" \n", ServiceRecord->ServiceName);
            SC_ASSERT(FALSE);
        }
        else
        {
            //
            // The use count is not zero, so we want to decrement it.
            // NOTE that even though the count was 1 when we put it in
            // the deferred list, it may have been incremented in the
            // mean-time.
            // CODEWORK: Why doesn't ScDecrementUseCountAndDelete just
            // decrement the UseCount to zero itself?  If it did, we
            // wouldn't need RLock at all here, just LLock.
            //
            ServiceRecord->UseCount--;
            SC_LOG2(USECOUNT, "ScProcessDeferredList: " FORMAT_LPWSTR
                " decrement USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);
        }

        if ((ServiceRecord->UseCount == 0)      &&
            (DELETE_FLAG_IS_SET(ServiceRecord)))
        {
            SC_LOG1(USECOUNT,"ScProcessDeferredList:DELETING THE ("FORMAT_LPWSTR") SERVICE\n",
            ServiceRecord->ServiceName);

            //
            // Check to see if there is an LSA secret object to delete
            //
            if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32_OWN_PROCESS)
            {
                HKEY ServiceNameKey;
                LPWSTR AccountName;

                //
                // Open the service name key.
                //
                if (ScOpenServiceConfigKey(
                        ServiceRecord->ServiceName,
                        KEY_READ,
                        FALSE,               // Create if missing
                        &ServiceNameKey
                        ) == NO_ERROR)
                {
                    //
                    // Read the account name from the registry.
                    //
                    if (ScReadStartName(
                            ServiceNameKey,
                            &AccountName
                            ) == NO_ERROR)
                    {
                        if (AccountName != NULL
                             &&
                            _wcsicmp(AccountName, SC_LOCAL_SYSTEM_USER_NAME) != 0)
                        {
                            ScRemoveAccount(ServiceRecord->ServiceName);
                        }

                        LocalFree(AccountName);

                    } // Got the StartName

                    ScRegCloseKey(ServiceNameKey);
                }
            } // endif SERVICE_WIN32_OWN_PROCESS

            LocalFree(ServiceRecord->Dependencies);

            //
            // Free up the DisplayName space.
            //
            if (ServiceRecord->DisplayName != ServiceRecord->ServiceName)
            {
                LocalFree(ServiceRecord->DisplayName);
            }

            ScDeleteGroupMembership(ServiceRecord);
            ScDeleteRegistryGroupPointer(ServiceRecord);

            ScDeleteStartDependencies(ServiceRecord);
            ScDeleteStopDependencies(ServiceRecord);

            if (ServiceRecord->ServiceSd != NULL)
            {
                RtlDeleteSecurityObject(&ServiceRecord->ServiceSd);
            }

            delete ServiceRecord->CrashRecord;

            //*******************************
            //  Delete the registry node for
            //  This service.
            //*******************************
            DeleteServicePlugPlayRegKeys(ServiceRecord->ServiceName);
            ScDeleteRegServiceEntry(ServiceRecord->ServiceName);

            REMOVE_FROM_LIST(ServiceRecord);

            ScFreeServiceRecord(ServiceRecord);

        } // End If service can be deleted.

    } // End for each element in the list.

    //
    // The deferred list is no longer needed free it.
    //
    LocalFree(ServiceRecordPtr);
    ServiceRecordPtr = NULL;
    TotalElements = 0;
    NumElements = 0;

    SC_LOG0(LOCKS, "Returning from ScProcessDeferredList\n");
}

/****************************************************************************/
BOOL
ScFindEnumStart(
    IN  DWORD               ResumeIndex,
    OUT LPSERVICE_RECORD    *ServiceRecordPtr
    )

/*++

Routine Description:

    This function finds the first service record to begin the enumeration
    search with by finding the next service record folloing the resumeIndex.

    Service records are indexed by a ResumeNum value that is stored in
    each service record.  The numbers increment as the linked list is
    walked.

Arguments:

    ResumeIndex - This index is compared against the ResumeNum in the
        services records.  The pointer to the next service record beyond
        the ResumeIndex is returned.

    ServiceRecordPtr - This is a pointer to a location where the pointer
        to the returned service record is to be placed.

Return Value:

    TRUE - Indicates that there are service records beyond the resume index.

    FALSE - Indicates that there are no service records beyond the resume
        index.

Note:


--*/
{
    FOR_SERVICES_THAT(serviceRecord, serviceRecord->ResumeNum > ResumeIndex)
    {
        *ServiceRecordPtr = serviceRecord;
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************/
BOOL
ScGetNamedImageRecord (
    IN      LPWSTR              ImageName,
    OUT     LPIMAGE_RECORD      *ImageRecordPtr
    )

/*++

Routine Description:

    This function searches for an Image Record that has a name matching
    that which is passed in.

    NOTE:  If this function is called, it is to find a shareable Image Record
    of the given name.

Arguments:

    ImageName - This is a pointer to a NUL terminated image name string.
        This may be in mixed case.

    ImageRecordPtr - This is a pointer to a location where the pointer to
        the Image Record is to be placed.

Note:
    The Database Lock must be held with at least shared access prior to
    calling this routine.

Return Value:

    TRUE - if the record was found.

    FALSE - if the record was not found.

--*/
{
    if (ImageName == NULL)
    {
        SC_LOG(TRACE,"GetNamedImageRecord: Name was NULL\n",0);
        return (FALSE);
    }

    SC_ASSERT(ScServiceRecordLock.Have());

    //
    // Check the database of running images
    //
    for (PIMAGE_RECORD imageRecord = ImageDatabase.Next;
         imageRecord != NULL;
         imageRecord = imageRecord->Next)
    {
        //
        // We need a shareable Image Record, so check the ImageFlags
        //
        if (ScImagePathsMatch(imageRecord->ImageName, ImageName) &&
                (imageRecord->ImageFlags & CANSHARE_FLAG))
        {
            *ImageRecordPtr = imageRecord;
            return TRUE;
        }
    }

    return FALSE;
}

/****************************************************************************/
DWORD
ScGetNamedServiceRecord (
    IN      LPWSTR              ServiceName,
    OUT     LPSERVICE_RECORD    *ServiceRecordPtr
    )

/*++

Routine Description:

    Uses the service name to look through the service and device linked
    lists until it finds a match.  Inactive services can be identified by
    finding CurrentState = SERVICE_STOPPED.

Arguments:

    ServiceName - This is a pointer to a NUL terminated service name string.

    ServiceRecordPtr - This is a pointer to a location where the pointer to
        the Service Record is to be placed.

Return Value:

    NO_ERROR - if the record was found.

    ERROR_SERVICE_DOES_NOT_EXIST - if the service record was not found in
        the linked list.

    ERROR_INVALID_NAME - if the service name was NULL.

Note:
    The caller is expected to grab the lock before calling this routine.

--*/
{
    if (ServiceName == NULL)
    {
        SC_LOG0(TRACE,"GetNamedServiceRecord: Name was NULL\n");
        return ERROR_INVALID_NAME;
    }

    //
    // Check the database of running services
    //
    FOR_SERVICES_THAT(serviceRecord,
                      _wcsicmp(serviceRecord->ServiceName, ServiceName)== 0)
    {
        *ServiceRecordPtr = serviceRecord;
        return NO_ERROR;
    }

    return ERROR_SERVICE_DOES_NOT_EXIST;
}

/****************************************************************************/
DWORD
ScGetDisplayNamedServiceRecord (
    IN      LPWSTR              ServiceDisplayName,
    OUT     LPSERVICE_RECORD    *ServiceRecordPtr
    )

/*++

Routine Description:

    Uses the service display name to look through the service and device
    linked lists until it finds a match.

Arguments:

    ServiceDisplayName - This is a pointer to a NUL terminated service
        display name string.

    ServiceRecordPtr - This is a pointer to a location where the pointer to
        the Service Record is to be placed.

Return Value:

    NO_ERROR - if the record was found.

    ERROR_SERVICE_DOES_NOT_EXIST - if the service record was not found in
        the linked list.

    ERROR_INVALID_NAME - if the service display name was NULL.

Note:
    The caller is expected to grab the lock before calling this routine.

--*/
{
    if (ServiceDisplayName == NULL)
    {
        SC_LOG0(TRACE,"GetDisplayNamedServiceRecord: Name was NULL\n");
        return ERROR_INVALID_NAME;
    }

    //
    // Check the database of running services
    //
    SC_ASSERT(ScServiceRecordLock.Have());
    FOR_SERVICES_THAT(serviceRecord,
                      _wcsicmp(serviceRecord->DisplayName, ServiceDisplayName)== 0)
    {
        *ServiceRecordPtr = serviceRecord;
        return NO_ERROR;
    }

    return ERROR_SERVICE_DOES_NOT_EXIST;
}

/****************************************************************************/
DWORD
ScGetTotalNumberOfRecords (VOID)

/*++

Routine Description:

    Finds the total number of installed Service Records in the database.
    This is used in the Enum case where only the installed services are
    enumerated.

Arguments:

    none

Return Value:

    TotalNumberOfRecords

--*/
{
    return(ScTotalNumServiceRecs);
}

/****************************************************************************/
BOOL
ScInitDatabase (VOID)

/*++

Routine Description:

    This function initializes the Service Controllers database.

Arguments:

    none

Return Value:

    TRUE - Initialization was successful

    FALSE - Initialization failed

--*/
{
    ScTotalNumServiceRecs = 0;

    ImageDatabase.Next = NULL;
    ImageDatabase.Prev = NULL;

    ServiceDatabase.Next = NULL;
    ServiceDatabase.Prev = NULL;

    ScInitGroupDatabase();

    ResumeNumber = 1;

    //
    // Create the database lock.
    // NOTE:  This is never deleted.  It is assumed it will be deleted
    // when the process goes away.
    //

    ScServiceRecordLock.Initialize("  R", "ServiceRecord");
    ScServiceListLock.Initialize(" L ", "ServiceList");


    //
    // Initialize the group list lock used for protecting the
    // OrderGroupList and StandaloneGroupList
    //
    ScGroupListLock.Initialize("G  ", "GroupList");

    //
    // This routine does the following:
    //   - Read the load order group information from the registry.
    //   - Generate the database of service records from the information
    //         stored in the registry.
    //

    if (!ScGenerateServiceDB())
    {
        return(FALSE);
    }

    return(TRUE);
}


/****************************************************************************/
VOID
ScProcessCleanup(
    HANDLE  ProcessHandle
    )

/*++

Routine Description:

    This function is called when a process has died, and the service
    record in the database needs cleaning up.  This function will
    use the ProcessHandle as a key when scanning the ServiceRecord
    database.  All of the service records referencing that handle
    are cleaned up, and then the image record that they reference
    is deleted.

    In cleaning up a service record, CurrentState is set to
    SERVICE_STOPPED, and the ExitCode is set to a unique value that
    indicates that the service died unexpectedly and without warning.

Arguments:

    ProcessHandle - This is the handle of the process that died
        unexpectedly.

Return Value:

    none.

--*/
{
    PIMAGE_RECORD imageRecord;

    {
        //
        // Get exclusive use of database so that it can be modified.
        //
        // If the service record's update flag is set, we may have to
        // modify the group list (within ScDeactivateServiceRecord),
        // so lock the group list too.
        //

        CGroupListExclusiveLock GLock;
        CServiceListSharedLock LLock;
        CServiceRecordExclusiveLock RLock;

        //
        // Find the image record that has this ProcessHandle.
        //

        for (imageRecord = ImageDatabase.Next;
             imageRecord != NULL;
             imageRecord = imageRecord->Next)
        {
            if (ProcessHandle == imageRecord->ProcessHandle)
            {
                break;
            }
        }

        if (imageRecord == NULL)
        {
            SC_LOG(ERROR, "ScProcessCleanup: No image record has handle %#lx!\n",
                           ProcessHandle);
            return;
        }

        SC_LOG2(ERROR, "Service process %ld (%ws) died\n", imageRecord->Pid,
                        imageRecord->ImageName);

        //
        // Deregister the wait.  Note that this must be done
        // even if the WT_EXECUTEONLYONCE flag was specified)
        //

        if (imageRecord->ObjectWaitHandle != NULL)
        {
            NTSTATUS  ntStatus = RtlDeregisterWait(imageRecord->ObjectWaitHandle);

            if (!NT_SUCCESS(ntStatus))
            {
                SC_LOG1(ERROR,
                        "ScProcessCleanup: RtlDeregisterWait FAILED %#x\n",
                        ntStatus);
            }
        }

        DWORD serviceCount = imageRecord->ServiceCount;

        //
        // The image record's service count must include at least this service
        //

        if (serviceCount == 0)
        {
            SC_ASSERT(0);
            // Do something sensible if this ever does happen
            serviceCount = imageRecord->ServiceCount = 1;
        }

        //
        // The Image may have several services running in it.
        // Find the service records for all running services in this
        // image.
        //
        // NOTE:  If the service is typed as a SERVICE_WIN32_OWN_PROCESS, this
        //        means that only one service can exist in the process that
        //        went down.  However, the serviceCount should correctly
        //        indicate as such in that case.
        //

        FOR_SERVICES_THAT(serviceRecord,
            (serviceRecord->ImageRecord == imageRecord)
                &&
            (serviceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED))
        {
            SC_LOG2(ERROR, "Dead process contained %ws service in state %#lx\n",
                            serviceRecord->ServiceName,
                            serviceRecord->ServiceStatus.dwCurrentState);

            //
            // Don't bother notifying PnP if the system is shutting down.  This
            // prevents a deadlock where we can get stuck calling PnP, which is
            // stuck calling into the Eventlog, which is stuck calling into us.
            // 

            if (!ScShutdownInProgress)
            {
                if (serviceRecord->ServiceStatus.dwControlsAccepted
                     &
                    (SERVICE_ACCEPT_POWEREVENT | SERVICE_ACCEPT_HARDWAREPROFILECHANGE))
                {
                    //
                    // Tell PnP not to send controls to this service any more
                    //
                    RegisterServiceNotification((SERVICE_STATUS_HANDLE)serviceRecord,
                                                serviceRecord->ServiceName,
                                                0,
                                                TRUE);
                }

                //
                // Increment the service's crash count and perform the configured
                // recovery action.  Don't bother if the system is shutting down.
                //

                ScQueueRecoveryAction(serviceRecord);
            }

            serviceRecord->StartError = ERROR_PROCESS_ABORTED;
            serviceRecord->StartState = SC_START_FAIL;
            serviceRecord->ServiceStatus.dwWin32ExitCode = ERROR_PROCESS_ABORTED;

            //
            // Clear the server announcement bits in the global location
            // for this service.
            //

            ScRemoveServiceBits(serviceRecord);

            serviceCount = ScDeactivateServiceRecord(serviceRecord);
            if (serviceCount == 0)
            {
                // No need to continue
                break;
            }
        }

        // (If we hit this assert it means that the service database was corrupt:
        // the number of service records pointing to this image record was less
        // than the service count in the image record.  Not much we can do now.)
        SC_ASSERT(serviceCount == 0);

        //
        // Remove the ImageRecord from the list and delete it
        //
        REMOVE_FROM_LIST(imageRecord);
    }

    ScDeleteImageRecord(imageRecord);

    return;
}

VOID
ScDeleteMarkedServices(
    VOID
    )

/*++

Routine Description:

    This function looks through the service record database for any entries
    marked for deletion.  If one is found, it is removed from the registry
    and its entry is deleted from the service record database.

    WARNING:
    This function is to be called during initialization only.  It
    is assumed that no services are running when this function is called.
    Therefore, no locks are held during this operation.

Arguments:

    none

Return Value:

    none

--*/
{
    HKEY                ServiceNameKey;
    LPWSTR              AccountName;

    FOR_SERVICES_THAT(serviceRecord, DELETE_FLAG_IS_SET(serviceRecord))
    {
        SC_LOG(TRACE,"ScDeleteMarkedServices: %ws is being deleted\n",
            serviceRecord->ServiceName);
        //
        // Open the service name key.
        //
        if (ScOpenServiceConfigKey(
                serviceRecord->ServiceName,
                KEY_READ,
                FALSE,               // Create if missing
                &ServiceNameKey) == NO_ERROR)
        {
            //
            // Read the account name from the registry.
            // If this fails, we still want to delete the registry entry.
            //
            if (ScReadStartName(ServiceNameKey, &AccountName) == NO_ERROR
                 &&
                AccountName != NULL)
            {
                if (_wcsicmp(AccountName, SC_LOCAL_SYSTEM_USER_NAME) != 0)
                {
                    ScRemoveAccount(serviceRecord->ServiceName);
                }

                LocalFree(AccountName);

            } // Got the StartName

            ScRegCloseKey(ServiceNameKey);

            //
            // Delete the entry from the registry
            //
            ScDeleteRegServiceEntry(serviceRecord->ServiceName);

            //
            // Free memory for the DisplayName.
            //
            if (serviceRecord->DisplayName != serviceRecord->ServiceName)
            {
                LocalFree(serviceRecord->DisplayName);
            }

            //
            // Remove the service record from the database
            //
            LPSERVICE_RECORD saveRecord = serviceRecord->Prev;
            REMOVE_FROM_LIST(serviceRecord);

            ScFreeServiceRecord(serviceRecord);

            serviceRecord = saveRecord;
        }
    }
}


/****************************************************************************/
DWORD
ScRemoveService (
    IN      LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

        This should be used to deactivate a service record and shut down
        the process only if it is the last service in the process.  It
        will be used for polite shut-down when a service terminates as
        normal.  It will always be called by the status routine.  If the
        service controller believes that no other services are running in
        the process, it can force termination of the process if it does
        not respond to the process shutdown request.

    This function deactivates the service record (ScDeactivateServiceRecord)
    and checks to see if the ServiceCount in the image record has gone to
    zero.  If it has, then it terminates the service process.  When that
    is complete, it calls ScDeleteImageRecord to remove the remaining
    evidence.

    Even if an error occurs, and we are unable to terminate the process,
    we delete the image record any - just as we would in the case
    where it goes away.

Arguments:

    ServiceRecord - This is a pointer to the service record that is to
        be removed.

Return Value:

    NO_ERROR - The operation was successful.

    NERR_ServiceKillProc - The service process had to be killed because
        it wouldn't terminate when requested.  If the process did not
        go away - even after being killed (TerminateProcess), this error
        message is still returned.

Note:

    Uses Exclusive Locks.

--*/
{
    DWORD           serviceCount = 0;
    LPIMAGE_RECORD  ImageRecord;

    {
        //
        // Get exclusive use of database so that it can be modified.
        // If the service record's update flag is set, we may have to
        // modify the group list, so lock the group list too.
        //
        CGroupListExclusiveLock GLock;
        CServiceListSharedLock LLock; // (needed if update flag set and service has dependencies)
        CServiceRecordExclusiveLock RLock;

        ImageRecord = ServiceRecord->ImageRecord;

        //
        // ImageRecord may be NULL if it had been cleaned up earlier
        //
        if (ImageRecord != NULL)
        {
            //
            // Deactivate the service record.
            //
            serviceCount = ScDeactivateServiceRecord(ServiceRecord);

            //
            // Do as little as possible while holding the locks.
            // Otherwise, we can cause a deadlock or a bottleneck
            // on system shutdown due to contention for the
            // exclusive locks
            //

            if (serviceCount == 0)
            {
                //
                //  Remove the Image record from linked list.
                //
                REMOVE_FROM_LIST(ImageRecord);
            }
        }
    }

    //
    // Done with modifications - now allow other threads database access.
    //

    if (ImageRecord != NULL && serviceCount == 0)
    {
        //
        // Now we must terminate the Service Process.  The return status
        // from this call is not very interesting.  The calling application
        // probably doesn't care how the process died.  (whether it died
        // cleanly, or had to be killed).
        //
        ScTerminateServiceProcess(ImageRecord);

        ScDeleteImageRecord (ImageRecord);
    }

    return(NO_ERROR);
}

/****************************************************************************/
VOID
ScDeleteImageRecord (
    IN LPIMAGE_RECORD       ImageRecord
    )

/*++

Routine Description:

    This function deletes an ImageRecord from the database by removing it
    from the linked list, and freeing its associated memory.  Prior to
    doing this however, it closes the PipeHandle and the ProcessHandle
    in the record.

Arguments:

    ImageRecord - This is a pointer to the ImageRecord that is being deleted.

Return Value:

    nothing

Notes:

    This routine assumes that the image record has already been removed
    from the list before it is called via the REMOVE_FROM_LIST macro.  This
    is to allow us to call ScDeleteImageRecord without holding any exclusive
    locks

--*/
{
    HANDLE  status;         // return status from LocalFree

    SC_ASSERT( ImageRecord != NULL );

    //
    // What else can we do except note the errors in debug mode?
    //
    if (CloseHandle(ImageRecord->PipeHandle) == FALSE)
    {
        SC_LOG(TRACE,"DeleteImageRecord: ClosePipeHandle Failed %lu\n",
               GetLastError());
    }

    if (CloseHandle(ImageRecord->ProcessHandle) == FALSE)
    {
        SC_LOG(TRACE,"DeleteImageRecord: CloseProcessHandle Failed %lu\n",
               GetLastError());
    }

    if (ImageRecord->ProfileHandle != (HANDLE) NULL)
    {
        if (UnloadUserProfile(ImageRecord->TokenHandle,
                              ImageRecord->ProfileHandle) == FALSE)
        {
            SC_LOG1(ERROR,"DeleteImageRecord: UnloadUserProfile Failed %lu\n",
                    GetLastError());
        }
    }

    if (ImageRecord->TokenHandle != (HANDLE) NULL)
    {
        if (CloseHandle(ImageRecord->TokenHandle) == FALSE)
        {
            SC_LOG1(TRACE,"DeleteImageRecord: CloseTokenHandle Failed %lu\n",
                    GetLastError());
        }
    }

    status = LocalFree(ImageRecord);

    if (status != NULL)
    {
        SC_LOG(TRACE,"DeleteImageRecord: LocalFree Failed, rc = %d\n",
               GetLastError());
    }

    return;
}


DWORD
ScDeactivateServiceRecord (
    IN LPSERVICE_RECORD     ServiceRecord
    )

/*++

Routine Description:

    This function deactivates a service record by updating the proper
    GlobalCount data structure.

    NOTE:  Although the ServiceRecord does not go away, the pointer to
           the ImageRecord is destroyed.

Arguments:

    ServiceRecord - This is a pointer to the ServiceRecord that is to be
        deleted (moved to uninstalled database).

Notes:

    This routine assumes that the Exclusive database lock has already
    been obtained.  (ScRemoveService & ScProcessCleanup call this function).
    If the service's update flag is set (its configuration was changed
    while it was running), the exclusive group list lock must also have
    been obtained.

Return Value:

    ServiceCount - This indicates how many services in this service process
        are actually installed.

--*/
{
    DWORD       serviceCount = 0;
    DWORD       status;
    DWORD       dwServiceType;
    DWORD       dwStartType;
    DWORD       dwErrorControl;
    DWORD       dwTagId;
    LPWSTR      lpLoadOrderGroup = NULL;

    SC_LOG(TRACE,"In DeactivateServiceRecord\n",0);
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());
    //
    // Decrement the service count in the image record.
    //
    if (ServiceRecord->ImageRecord != NULL)
    {
        serviceCount = --(ServiceRecord->ImageRecord->ServiceCount);
    }

    ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ServiceRecord->ServiceStatus.dwControlsAccepted = 0;
    ServiceRecord->ServiceStatus.dwCheckPoint = 0;
    ServiceRecord->ServiceStatus.dwWaitHint = 0;
    ServiceRecord->ImageRecord = NULL;

    //
    // If the Update bit is set in the services status flag, we need
    // to read the latest registry configuration information into the
    // service record.  If this fails, all we can do is log the error
    // and press on with the existing data in the service record.
    //

    if (UPDATE_FLAG_IS_SET(ServiceRecord))
    {
        SC_ASSERT(ScGroupListLock.HaveExclusive());
        status = ScReadConfigFromReg(
                    ServiceRecord,
                    &dwServiceType,
                    &dwStartType,
                    &dwErrorControl,
                    &dwTagId,
                    NULL,              // Don't need dependencies -- they're updated dynamically
                    &lpLoadOrderGroup,
                    NULL);             // Don't need display name -- it's updated dynamically

        if (status == NO_ERROR)
        {

            //
            // Dependencies are NULL since they're updated dynamically
            //
            status = ScUpdateServiceRecordConfig(
                        ServiceRecord,
                        dwServiceType,
                        dwStartType,
                        dwErrorControl,
                        lpLoadOrderGroup,
                        NULL);
        }
        if (status != NO_ERROR)
        {
            SC_LOG1(ERROR,"ScDeactivateServiceRecord:Attempt to update "
            "configuration for stopped service failed\n",status);
            //
            // ERROR_LOG ErrorLog
            //
        }

        LocalFree(lpLoadOrderGroup);

        CLEAR_UPDATE_FLAG(ServiceRecord);
    }
    //
    // Since the service is no longer running, and no longer has a handle
    // to the service, we need to decrement the use count.  If the
    // count is decremented to zero, and the service is marked for
    // deletion, it will get deleted.
    //

    ScDecrementUseCountAndDelete(ServiceRecord);

    return(serviceCount);
}




/****************************************************************************/
DWORD
ScTerminateServiceProcess (
    IN  PIMAGE_RECORD   ImageRecord
    )

/*++

Routine Description:

    This function sends an SERVICE_STOP control message to the target
    ControlDispatcher.  Then it uses the process handle to wait for the
    service process to terminate.

    If the service process fails to terminate with the polite request, it
    will be abruptly killed.  After killing the process, this routine will
    wait on the process handle to make sure it enters the signaled state.
    If it doesn't, and the wait times out, we return anyway having given
    it our best shot.

Arguments:

    ImageRecord - This is a pointer to the Image Record that stores
        information about the service that is to be terminated.

Return Value:

    NO_ERROR - The operation was successful.

    NERR_ServiceKillProc - The service process had to be killed because
        it wouldn't terminate when requested.  If the process did not
        go away - even after being killed (TerminateProcess), this error
        message is still returned.

Note:
    LOCKS:
    This function always operates within an exclusive database lock.
    It DOES NOT give up this lock when sending the control to the service
    process.  We would like all these operations to be atomic.

    It must give this up temporarily when it does the pipe transact.

--*/

{
    DWORD  returnStatus;
    DWORD  status;
    DWORD  waitStatus;

    returnStatus = NO_ERROR;

    //
    // Check vs. NULL in case the register failed or the work item
    // was already deregistered in RSetServiceStatus
    //
    if (ImageRecord->ObjectWaitHandle != NULL) {

        status = RtlDeregisterWait(ImageRecord->ObjectWaitHandle);

        if (NT_SUCCESS(status)) {
            ImageRecord->ObjectWaitHandle = NULL;
        }
        else {

            SC_LOG1(ERROR,
                    "ScTerminateServiceProcess: RtlDeregisterWait failed 0x%x\n",
                    status);
        }
    }

    //
    // Send Uninstall message to the Service Process
    // Note that the ServiceName is NULL when addressing
    // the Service Process.
    //

    SC_LOG(TRACE,"TerminateServiceProcess, sending Control...\n",0);

    //
    // Stop the service's control dispatcher
    //

    status = ScSendControl(
            L"",                        // no service name.
            L"",                        // no display name.
            ImageRecord->PipeHandle,    // PipeHandle
            SERVICE_STOP,               // Opcode
            NULL,                       // CmdArgs (pointer to vectors).
            0L,                         // NumArgs
            NULL);                      // Ignore handler return value


    if (status == NO_ERROR)
    {
        //
        //  Control Dispatcher accepted the request - now
        //  wait for it to shut down.
        //
        SC_LOG(TRACE,
            "TerminateServiceProcess, waiting for process to terminate...\n",0);

        waitStatus = WaitForSingleObject (
                        ImageRecord->ProcessHandle,
                        TERMINATE_TIMEOUT);

        if (waitStatus == WAIT_TIMEOUT)
        {
            SC_LOG3(ERROR,"TerminateServiceProcess: Process %#lx (%ws) did not exit because of timeout: %#ld\n",
                    ImageRecord->Pid, ImageRecord->ImageName, WAIT_TIMEOUT);

            //
            // Process didn't terminate. So Now I have to kill it.
            //
            TerminateProcess(ImageRecord->ProcessHandle, 0);

            waitStatus = WaitForSingleObject (
                            ImageRecord->ProcessHandle,
                            TERMINATE_TIMEOUT);

            if (waitStatus == WAIT_TIMEOUT)
            {
                SC_LOG2(ERROR,"TerminateServiceProcess: Couldn't kill process %#lx because of timeout: %#ld\n",
                        ImageRecord->Pid, WAIT_TIMEOUT);
            }
            returnStatus = NO_ERROR;
        }
    }
    else
    {
        //
        // ScSendControl failed -- this can occur if the service calls ExitProcess
        // while handling SERVICE_CONTROL_STOP or SERVICE_CONTROL_SHUTDOWN since
        // the pipe for the image record is now broken (ERROR_BROKEN_PIPE).
        //
        SC_LOG3(ERROR,
            "TerminateServiceProcess:SendControl to stop process %#lx (%ws) failed, %ld\n",
            ImageRecord->Pid, ImageRecord->ImageName, status);

        TerminateProcess(ImageRecord->ProcessHandle, 0);

        waitStatus = WaitForSingleObject (
                        ImageRecord->ProcessHandle,
                        TERMINATE_TIMEOUT);

        if (waitStatus == WAIT_TIMEOUT)
        {
            SC_LOG2(ERROR,"TerminateServiceProcess: Couldn't kill process because of timeout: %ld\n",
                    0, WAIT_TIMEOUT);
        }
        returnStatus = NO_ERROR;

    }
    SC_LOG(TRACE,"TerminateServiceProcess, Done terminating Process!\n",0);
    return(returnStatus);
}


VOID
ScDeferredListWorkItem(
    IN PVOID    pContext
    )
/*++

Routine Description:

    This function acquires all the database locks, and allows
    the group list lock routine to process the deferred list.

--*/
{
    ScDeferredList.Process();
}


DWORD
ScUpdateServiceRecordConfig(
    IN  LPSERVICE_RECORD    ServiceRecord,
    IN  DWORD               dwServiceType,
    IN  DWORD               dwStartType,
    IN  DWORD               dwErrorControl,
    IN  LPWSTR              lpLoadOrderGroup,
    IN  LPBYTE              lpDependencies
    )

/*++

Routine Description:

    This function updates the service record with the latest config
    information (passed in).

    It assumed that exclusive locks are held before calling this function.

Arguments:


Return Value:


Note:


--*/
#define SERVICE_TYPE_CHANGED            0x00000001
#define START_TYPE_CHANGED              0x00000002
#define ERROR_CONTROL_CHANGED           0x00000004
#define BINARY_PATH_CHANGED             0x00000008
#define LOAD_ORDER_CHANGED              0x00000010
#define TAG_ID_CHANGED                  0x00000020
#define DEPENDENCIES_CHANGED            0x00000040
#define START_NAME_CHANGED              0x00000080

{
    DWORD               status;
    DWORD               backoutStatus;
    LPWSTR              OldLoadOrderGroup = NULL;
    LPWSTR              OldDependencies = NULL;

    DWORD               OldServiceType;
    DWORD               OldStartType;
    DWORD               OldErrorControl;
    DWORD               Progress = 0;
    DWORD               bufSize;
    DWORD               MaxDependSize = 0;

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    OldServiceType = ServiceRecord->ServiceStatus.dwServiceType;
    OldStartType   = ServiceRecord->StartType;
    OldErrorControl= ServiceRecord->ErrorControl;


    //==============================
    // UPDATE DWORDs
    //==============================
    if (dwServiceType != SERVICE_NO_CHANGE)
    {
        ServiceRecord->ServiceStatus.dwServiceType = dwServiceType;
    }
    if (dwStartType != SERVICE_NO_CHANGE)
    {
        ServiceRecord->StartType = dwStartType;
    }
    if (dwErrorControl != SERVICE_NO_CHANGE)
    {
        ServiceRecord->ErrorControl = dwErrorControl;
    }

    Progress |= (SERVICE_TYPE_CHANGED   |
                 START_TYPE_CHANGED     |
                 ERROR_CONTROL_CHANGED  );


    //==============================
    // UPDATE Dependencies
    //==============================

    if (lpDependencies != NULL)
    {
        //
        // Generate the current (old) list of dependency strings.
        //
        ScGetDependencySize(ServiceRecord,&bufSize, &MaxDependSize);
        if (bufSize > 0)
        {
            OldDependencies = (LPWSTR)LocalAlloc(LMEM_FIXED, bufSize);
            if (OldDependencies == NULL)
            {
                status = GetLastError();
                goto Cleanup;
            }
            status = ScGetDependencyString(
                            ServiceRecord,
                            MaxDependSize,
                            bufSize,
                            OldDependencies);
            if (status != NO_ERROR)
            {
                goto Cleanup;
            }
        }

        ScDeleteStartDependencies(ServiceRecord);

        status = ScCreateDependencies(ServiceRecord, (LPWSTR) lpDependencies);
        if (status != NO_ERROR)
        {
            goto Cleanup;
        }
        Progress |= DEPENDENCIES_CHANGED;
    }
    //==============================
    // UPDATE LoadOrderGroup
    //==============================

    if (lpLoadOrderGroup != NULL)
    {
        if (*lpLoadOrderGroup != 0)
        {
            //
            // The string in lpLoadOrderGroup should match that in the RegistryGroup
            // in the service record.  If a service monkeyed directly with its registry
            // values, it's possible that the RegistryGroup pointer we have now is NULL.
            //

            if (ServiceRecord->RegistryGroup == NULL ||
                _wcsicmp(lpLoadOrderGroup, ServiceRecord->RegistryGroup->GroupName) != 0)
            {
                SC_LOG2(ERROR,
                        "ScUpdateServiceRecordConfig:  New group [%ws] doesn't match that stored "
                            "in the service database [%ws]\n",
                        lpLoadOrderGroup,
                        ServiceRecord->RegistryGroup ? ServiceRecord->RegistryGroup->GroupName : L"<null>");

                status = ERROR_GEN_FAILURE;
                goto Cleanup;
            }
        }
        //
        // Save Old MemberOfGroup name for error recovery
        //
        if (ServiceRecord->MemberOfGroup != NULL)
        {
            OldLoadOrderGroup = (LPWSTR)LocalAlloc(
                    LMEM_FIXED,
                    WCSSIZE(ServiceRecord->MemberOfGroup->GroupName));
            //
            // If this allocation fails, just pretend that it doesn't exist.
            //
            if (OldLoadOrderGroup != NULL)
            {
                wcscpy(OldLoadOrderGroup, ServiceRecord->MemberOfGroup->GroupName);
            }
        }
        //
        // Delete MemberOfGroup & Add RegistryGroup to MemberOfGroup so that
        // they are the same.
        // REMEMBER that RegistryGroup and lpLoadOrderGroup are the same!
        //
        ScDeleteGroupMembership(ServiceRecord);
        status = ScCreateGroupMembership(ServiceRecord, lpLoadOrderGroup);

        if (status != NO_ERROR)
        {
            ScDeleteGroupMembership(ServiceRecord);

            if ((OldLoadOrderGroup != NULL) && (*OldLoadOrderGroup))
            {
                backoutStatus = ScCreateGroupMembership(
                                ServiceRecord,
                                OldLoadOrderGroup);
                if (backoutStatus != NO_ERROR)
                {
                    // Do what? - we may want to write to ERROR LOG?
                }

            }
            goto Cleanup;
        }
    }
    status = NO_ERROR;

Cleanup:

    if (status != NO_ERROR)
    {
        ServiceRecord->ServiceStatus.dwServiceType = OldServiceType;
        ServiceRecord->StartType = OldStartType;
        ServiceRecord->ErrorControl = OldErrorControl;

        if (Progress & DEPENDENCIES_CHANGED)
        {
            ScDeleteStartDependencies(ServiceRecord);

            if ((OldDependencies != NULL) && (*OldDependencies != 0))
            {
                backoutStatus = ScCreateDependencies(
                                    ServiceRecord,
                                    OldDependencies);
                if (backoutStatus != NO_ERROR)
                {
                    // Do what? - we may want to write to ERROR LOG?
                }
            }
        }

    }

    LocalFree(OldDependencies);
    LocalFree(OldLoadOrderGroup);

    return(status);
}

BOOL
ScAllocateSRHeap(
    DWORD   HeapSize
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    ServiceRecordHeap = HeapCreate(0,HeapSize,0);
    if (ServiceRecordHeap == NULL)
    {
        SC_LOG0(ERROR,"Could not allocate Heap for Service Database\n");
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\depend.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    depend.h

Abstract:

    Service dependencies related function prototypes.

Author:

    Rita Wong (ritaw)     03-Apr-1992

Revision History:

--*/

#ifndef SCDEPEND_INCLUDED
#define SCDEPEND_INCLUDED

#include <scwow.h>

//
// Function Prototypes
//

BOOL
ScInitAutoStart(
    VOID
    );

DWORD
ScAutoStartServices(
    IN OUT   LPSC_RPC_LOCK lpLock
    );

DWORD
ScStartServiceAndDependencies(
    IN LPSERVICE_RECORD ServiceToStart OPTIONAL,
    IN DWORD NumArgs,
    IN LPSTRING_PTRSW CmdArgs,
    IN BOOL fIsOOBE
    );

BOOL
ScDependentsStopped(
    IN LPSERVICE_RECORD ServiceToStop
    );

VOID
ScNotifyChangeState(
    VOID
    );

VOID
ScEnumDependents(
    IN     LPSERVICE_RECORD ServiceRecord,
    IN     LPENUM_SERVICE_STATUS_WOW64 EnumBuffer,
    IN     DWORD RequestedState,
    IN OUT LPDWORD EntriesRead,
    IN OUT LPDWORD BytesNeeded,
    IN OUT LPENUM_SERVICE_STATUS_WOW64 *EnumRecord,
    IN OUT LPWSTR *EndOfVariableData,
    IN OUT LPDWORD Status
    );

BOOL
ScInHardwareProfile(
    IN  LPCWSTR ServiceName,
    IN  ULONG   GetDeviceListFlags
    );

#endif // #ifndef SCDEPEND_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\driver.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    DRIVER.CXX

Abstract:

    Functions for Loading, Maintaining, and Unloading Device Drivers.
        ScLoadDeviceDriver
        ScControlDriver
        ScGetDriverStatus
        ScGetObjectName
        ScUnloadDriver
        ScIsPnPDriver

Author:

    Dan Lafferty (danl)     27-Apr-1991

Environment:

    User Mode -Win32

Notes:

Revision History:

    22-Feb-1999 jschwart
        Prevent stopping of PnP drivers via ControlService (since it bluescreens
        the machine and is easier to fix here than the REAL fix in NtUnloadDriver)
    02-Oct-1997 AnirudhS
        Removed IOCTL to NDIS for NDIS driver arrivals.
    08-Jan-1997 AnirudhS
        ScGetDriverStatus, ScGetObjectName, etc: Instead of expecting a
        shared lock on the service database and upgrading it to exclusive,
        which is broken, just expect an exclusive lock.
    03-Jan-1997 AnirudhS
        Temporary fix for QFE bug 66887: When a driver stops, don't free its
        object name.  Free it only when the driver is reconfigured or deleted.
        The changes are marked by "QFE 66887" comments.
    19-Jan-1996 AnirudhS
        Add IOCTLs to NDIS for TDI and NDIS driver arrivals.
    30-Oct-1995 AnirudhS
        ScLoadDeviceDriver: Turn STATUS_IMAGE_ALREADY_LOADED into
        ERROR_SERVICE_ALREADY_RUNNING.
    05-Aug-1993 Danl
        ScGetObjectName:  It is possible to read an empty-string object
        name from the registry.  If we do, we need to treat this the same
        as if the ObjectName value were not in the registry.
    01-Jun-1993 Danl
        GetDriverStatus: When state moves from STOPPED to RUNNING,
        then the service record is updated so that STOP is accepted as
        a control.
    10-Jul-1992 Danl
        Changed RegCloseKey to ScRegCloseKey
    27-Apr-1991     danl
        created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <ntddndis.h>   // NDIS IOCTL codes
#include <stdlib.h>     // wide character c runtimes.
#include <cfgmgr32.h>   // PNP manager functions
#include <pnp.h>        // PNP manager functions, server side
#include "scconfig.h"   // ScReadStartName
#include "driver.h"     // ScGetDriverStatus()
#include "depend.h"     // ScGetDependentsStopped()
#include "scsec.h"      // ScGetPrivilege, ScReleasePrivilege
#include <debugfmt.h>   // FORMAT_LPWSTR

//
// DEFINES
//

#define OBJ_DIR_INFO_SIZE       4096L

#define SERVICE_PATH            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

#define FILE_SYSTEM_OBJ_NAME    L"\\FileSystem\\"

#define DRIVER_OBJ_NAME         L"\\Driver\\"

//
// This is a string version of GUID_DEVCLASS_LEGACYDRIVER in devguid.h
//
#define LEGACYDRIVER_STRING     L"{8ECC055D-047F-11D1-A537-0000F8753ED1}"

//
// LOCAL FUNCTION PROTOTYPES
//

DWORD
ScGetObjectName(
    LPSERVICE_RECORD    ServiceRecord
    );


BOOL
ScIsPnPDriver(
    IN  LPSERVICE_RECORD Service
    );


DWORD
ScLoadDeviceDriver(
    LPSERVICE_RECORD    ServiceRecord
    )
/*++

Routine Description:

    This function attempts to load a device driver.  If the NtLoadDriver
    call is successful, we know that the driver is running (since this
    is a synchronous operation).  If the call fails, the appropriate
    windows error code is returned.

    NOTE:  It is expected that the Database Lock will be held with
    exclusive access upon entry to this routine.

    WARNING:  This routine releases and acquires the Database Lock.

Arguments:

    ServiceRecord - This is pointer to a service record for the Device
        Driver that is being started.

Return Value:



--*/

{
    DWORD               status = NO_ERROR;
    NTSTATUS            ntStatus;
    LPWSTR              regKeyPath;
    UNICODE_STRING      regKeyPathString;
    ULONG               privileges[1];

#if DBG
    DWORD               dwLoadTime;
#endif

    SC_LOG1(TRACE,"In ScLoadDeviceDriver for "FORMAT_LPWSTR" Driver\n",
        ServiceRecord->ServiceName);

    SC_ASSERT(ScServiceListLock.Have());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    // If the ObjectName does not exist yet, create one.
    //
    if (ServiceRecord->ObjectName == NULL) {
        status = ScGetObjectName(ServiceRecord);
        if (status != NO_ERROR) {
            goto CleanExit;
        }
    }

    //
    // Create the Registry Key Path for this driver name.
    //
    regKeyPath = (LPWSTR)LocalAlloc(
                    LMEM_FIXED,
                    sizeof(SERVICE_PATH) +
                    WCSSIZE(ServiceRecord->ServiceName));

    if (regKeyPath == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }
    wcscpy(regKeyPath, SERVICE_PATH);
    wcscat(regKeyPath, ServiceRecord->ServiceName);

    //
    // Load the Driver
    // (but first get SeLoadDriverPrivilege)
    //
    RtlInitUnicodeString(&regKeyPathString, regKeyPath);

    privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;
    status = ScGetPrivilege(1,privileges);
    if (status != NO_ERROR) {
        goto CleanExit;
    }

    SC_ASSERT(ServiceRecord->ServiceStatus.dwCurrentState == SERVICE_STOPPED);

    //
    // Release and reacquire the lock around the NtLoadDriver call so that
    // a driver can generate a PnP event during its load routine (in NT5,
    // the ClusDisk driver can synchronously generate a dismount event while
    // it's loading)
    //
    ScServiceRecordLock.Release();

#if DBG
    dwLoadTime = GetTickCount();
#endif

    ntStatus = NtLoadDriver(&regKeyPathString);

#if DBG
    dwLoadTime = GetTickCount() - dwLoadTime;
    if (dwLoadTime > 5000)
    {
        SC_LOG2(ERROR,
                " **** NtLoadDriver(%ws) took %lu ms!\n",
                ServiceRecord->ServiceName,
                dwLoadTime);
    }
#endif

    ScServiceRecordLock.GetExclusive();

    ScReleasePrivilege();

    LocalFree(regKeyPath);

    if (NT_SUCCESS(ntStatus)) {
        SC_LOG1(TRACE,"ScLoadDeviceDriver: NtLoadDriver Success for "
            FORMAT_LPWSTR " \n",ServiceRecord->ServiceName);
    }
    else if (ntStatus == STATUS_IMAGE_ALREADY_LOADED) {
        SC_LOG1(TRACE,"ScLoadDeviceDriver: Driver " FORMAT_LPWSTR
            " is already running\n",ServiceRecord->ServiceName);

        status = ERROR_SERVICE_ALREADY_RUNNING;
    }
    else {
        SC_LOG2(WARNING,"ScLoadDeviceDriver: NtLoadDriver(%ws) Failed 0x%lx\n",
            ServiceRecord->ServiceName,
            ntStatus);

        if (ntStatus == STATUS_NO_SUCH_DEVICE) {
            status = ERROR_BAD_UNIT;
        }
        else {
            status = RtlNtStatusToDosError(ntStatus);
        }
        goto CleanExit;
    }

    //
    // Update the Service Record with this driver's start information.
    //

    ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    ServiceRecord->ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
    ServiceRecord->ServiceStatus.dwServiceSpecificExitCode = 0;
    ServiceRecord->ServiceStatus.dwCheckPoint = 0;
    ServiceRecord->ServiceStatus.dwWaitHint = 0;
    ServiceRecord->UseCount++;
    SC_LOG2(USECOUNT, "ScLoadDeviceDriver: " FORMAT_LPWSTR
         " increment USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);


    //
    // Tell NDIS to issue the PNP notifications about this driver's arrival,
    // if necessary
    //
    ScNotifyNdis(ServiceRecord);

CleanExit:
    return(status);
}


VOID
ScNotifyNdis(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function issues Plug-and-Play notifications to NDIS about the
    arrival of certain types of drivers and services.

Arguments:

    ServiceRecord - Service or driver that just started successfully.

Return Value:

    None.  Errors are written to the event log.

--*/

{
    HANDLE hDevice;
    BOOL fResult;
    DWORD cb;
    DWORD IoControlCode;


    //
    // TDI GROUP SPECIAL:  Drivers in group TDI are assumed to be PNP-unaware
    // network transport drivers.  Win32 services in group TDI are assumed to
    // be in that group because they start PNP-unaware transport drivers.
    // (PNP-aware transports are in group PNP_TDI.)
    // Such a transport doesn't notify the higher-level network components
    // (TDI clients) that it has arrived.  So we issue an IOCTL to NDIS to ask
    // it to read the transport's bindings from the registry and notify the
    // clients on this transport's behalf.
    //
    if (ServiceRecord->MemberOfGroup == ScGlobalTDIGroup)
    {
        IoControlCode = IOCTL_NDIS_ADD_TDI_DEVICE;
    }
    else
    {
        return;
    }

    hDevice = CreateFile(
                    L"\\\\.\\NDIS",
                    GENERIC_READ | GENERIC_WRITE,
                    0,                      // sharing mode - not significant
                    NULL,                   // security attributes
                    OPEN_EXISTING,
                    0,                      // file attributes and flags
                    NULL                    // handle to template file
                    );

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        SC_LOG(WARNING, "Couldn't open handle to NDIS for IOCTL, error %lu\n",
                    GetLastError());
        return;
    }

    fResult = DeviceIoControl(
                    hDevice,
                    IoControlCode,
                    ServiceRecord->ServiceName,                     // input buffer
                    (DWORD) WCSSIZE(ServiceRecord->ServiceName),    // input buffer size
                    NULL,                                           // output buffer
                    0,                                              // output buffer size
                    &cb,                                            // bytes returned
                    NULL);                                          // OVERLAPPED structure

    CloseHandle(hDevice);

    if (!fResult)
    {
        SC_LOG3(WARNING, "IOCTL %#lx to NDIS for %ws failed, error %lu\n",
                IoControlCode, ServiceRecord->ServiceName, GetLastError());
    }
}


DWORD
ScControlDriver(
    DWORD               ControlCode,
    LPSERVICE_RECORD    ServiceRecord,
    LPSERVICE_STATUS    lpServiceStatus
    )

/*++

Routine Description:

    This function checks controls that are passed to device drivers.  Only
    two controls are accepted.
        stop -  This function attemps to unload the driver.  The driver
                state is set to STOP_PENDING since unload is an
                asynchronous operation.  We have to wait until another
                call is made that will return the status of this driver
                before we can query the driver object to see if it is
                still there.

        interrogate - This function attempts to query the driver object
                to see if it is still there.

    WARNING:  This function should only be called with a pointer to
        a ServiceRecord that belongs to a DRIVER.

Arguments:

    ControlCode - This is the control request that is being sent to
        control the driver.

    ServiceRecord - This is a pointer to the service record for the
        driver that is to be controlled.

    lpServiceStatus - This is a pointer to a buffer that upon exit will
        contain the latest service status.

Return Value:



--*/

{
    DWORD status;

    SC_LOG1(TRACE,"In ScControlDriver for "FORMAT_LPWSTR" Driver\n",
        ServiceRecord->ServiceName);

    if (ControlCode != SERVICE_CONTROL_INTERROGATE &&
        ControlCode != SERVICE_CONTROL_STOP)
    {
        return ERROR_INVALID_SERVICE_CONTROL;
    }

    CServiceRecordExclusiveLock Lock;

    if (ControlCode == SERVICE_CONTROL_INTERROGATE)
    {
        //
        // On interrogate, we need to see if the service is still there.
        // Then we update the status accordingly.
        //
        status = ScGetDriverStatus(ServiceRecord, lpServiceStatus);

        if (status == NO_ERROR)
        {
            //
            // Based on the state, return the appropriate error code
            // so driver return codes match with those of services
            //
            switch(lpServiceStatus->dwCurrentState)
            {
                case SERVICE_STOPPED:
                    status = ERROR_SERVICE_NOT_ACTIVE;
                    break;

                case SERVICE_STOP_PENDING:
                    status = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
                    break;
            }
        }
    }
    else
    {
        //
        // This operation is invalid on PnP drivers
        //

        if (ScIsPnPDriver(ServiceRecord))
        {
            status = ERROR_INVALID_SERVICE_CONTROL;
            goto CleanExit;
        }

        //
        // Find out if the driver is still running.
        //

        status = ScGetDriverStatus(ServiceRecord, lpServiceStatus);

        if (status != NO_ERROR)
        {
            goto CleanExit;
        }

        if (ServiceRecord->ServiceStatus.dwCurrentState != SERVICE_RUNNING) {

            //
            // If the driver is not running, then it cannot accept the
            // STOP control request.  Drivers do not accept STOP requests
            // when in the START_PENDING state.  Make these return codes
            // match with those of services based on the driver's state
            //

            switch(lpServiceStatus->dwCurrentState)
            {
                case SERVICE_STOPPED:
                    status = ERROR_SERVICE_NOT_ACTIVE;
                    break;

                case SERVICE_STOP_PENDING:
                    status = ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
                    break;

                default:
                    status = ERROR_INVALID_SERVICE_CONTROL;
                    break;
            }

            goto CleanExit;
        }

        //
        // Check for dependent services still running
        //

        if (!ScDependentsStopped(ServiceRecord))
        {
            status = ERROR_DEPENDENT_SERVICES_RUNNING;
            goto CleanExit;
        }

        status = ScUnloadDriver(ServiceRecord);

        if (status == ERROR_INVALID_SERVICE_CONTROL)
        {
            //
            // If the driver fails to unload with this error,
            // then it must be one that cannot be stopped.
            // We want to mark it as such, and return an error.
            //
            SC_LOG0(TRACE,"ScControlDriver: Marking driver as non-stoppable\n");

            ServiceRecord->ServiceStatus.dwControlsAccepted = 0L;

            goto CleanExit;
        }

        //
        // Set the Current State to STOP_PENDING, and get the
        // current status (again);
        //

        ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        status = ScGetDriverStatus(ServiceRecord, lpServiceStatus);
    }

CleanExit:
    return status;
}


DWORD
ScGetDriverStatus(
    IN OUT LPSERVICE_RECORD    ServiceRecord,
    OUT    LPSERVICE_STATUS    lpServiceStatus OPTIONAL
    )

/*++

Routine Description:

    This function determines the correct current status for a device driver.
    The updated status is only returned if NO_ERROR is returned.

    WARNING:  This function expects the EXCLUSIVE database lock to be held.
    CODEWORK: For greater parallelism while enumerating driver status, get
        the exclusive lock only if the driver status has changed.

    NOTE:  The ServiceRecord passed in MUST be for a DeviceDriver.



Arguments:

    ServiceRecord - This is a pointer to the Service Record for the
        Device Driver for which the status is desired.

    lpServiceStatus - This is a pointer to a buffer that upon exit will
        contain the latest service status.

Return Value:

    NO_ERROR - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - If the local alloc failed.

    Or any unexpected errors from the NtOpenDirectoryObject or
    NtQueryDirectoryObject.

--*/
{

    NTSTATUS                        ntStatus;
    DWORD                           status;
    HANDLE                          DirectoryHandle;
    OBJECT_ATTRIBUTES               Obja;
    ULONG                           Context;
    ULONG                           ReturnLength;
    BOOLEAN                         restartScan;
    UNICODE_STRING                  ObjectPathString;
    UNICODE_STRING                  ObjectNameString;

    LPBYTE      lpBuffer;
    LPWSTR      pObjectPath;
    LPWSTR      pDeviceName;
    BOOL        found = FALSE;


    SC_LOG1(TRACE, "In ScGetDriverStatus for "FORMAT_LPWSTR" Driver\n", ServiceRecord->ServiceName);

    SC_ASSERT(ScServiceRecordLock.HaveExclusive());
    SC_ASSERT(ServiceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER);

    //
    // If the ObjectName does not exist yet, create one.
    //

    if (ServiceRecord->ObjectName == NULL)
    {
        status = ScGetObjectName(ServiceRecord);

        if (status != NO_ERROR)
        {
            return status;
        }
    }


    //
    // Take the ObjectPathName apart such that the path is in one
    // string, and the device name is in another string.

    //
    // First copy the Object Path string into a new buffer.  Allocate extra space
    // that we'll need for the query call below.
    //

    lpBuffer = (LPBYTE) LocalAlloc(LMEM_FIXED,
                                   WCSSIZE(ServiceRecord->ObjectName) + OBJ_DIR_INFO_SIZE);

    if (lpBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pObjectPath = (LPWSTR) (lpBuffer + OBJ_DIR_INFO_SIZE);

    wcscpy(pObjectPath, ServiceRecord->ObjectName);

    //
    // Find the last occurrence of '\'.  The Device name follows that.
    // replace the '\' with a NULL terminator.  Now we have two strings.
    //

    pDeviceName = wcsrchr(pObjectPath, L'\\');

    if (pDeviceName == NULL)
    {
        SC_LOG0(ERROR,"ScGetDriverStatus: DeviceName not in object path name\n");

        LocalFree(lpBuffer);
        return ERROR_PATH_NOT_FOUND;
    }

    *pDeviceName = L'\0';
    pDeviceName++;


    //
    // Open the directory object by name
    //

    RtlInitUnicodeString(&ObjectPathString, pObjectPath);

    InitializeObjectAttributes(&Obja, &ObjectPathString, 0, NULL, NULL);

    ntStatus = NtOpenDirectoryObject(&DirectoryHandle,
                                     DIRECTORY_TRAVERSE | DIRECTORY_QUERY,
                                     &Obja);

    if (!NT_SUCCESS(ntStatus))
    {
        LocalFree(lpBuffer);

        if (ntStatus == STATUS_OBJECT_PATH_NOT_FOUND)
        {
            //
            // If a driver uses a non-standard object path, the path may
            // not exist if the driver is not running.  We want to treat
            // this as if the driver is not running.
            //
            goto CleanExit;
        }

        SC_LOG1(ERROR, "ScGetDriverStatus: NtOpenDirectoryObject failed 0x%lx\n", ntStatus);

        return RtlNtStatusToDosError(ntStatus);
    }

    RtlInitUnicodeString(&ObjectNameString, pDeviceName);

    restartScan = TRUE;

    do
    {
        POBJECT_DIRECTORY_INFORMATION   pObjInfo;

        //
        // Query the Directory Object to enumerate all object names
        // in that object directory.
        //

        ntStatus = NtQueryDirectoryObject(DirectoryHandle,
                                          lpBuffer,
                                          OBJ_DIR_INFO_SIZE,
                                          FALSE,
                                          restartScan,
                                          &Context,
                                          &ReturnLength);

        if (!NT_SUCCESS(ntStatus))
        {
            SC_LOG1(ERROR, "ScGetDriverStatus:NtQueryDirectoryObject Failed 0x%lx\n", ntStatus);

            LocalFree(lpBuffer);
            NtClose(DirectoryHandle);

            return RtlNtStatusToDosError(ntStatus);
        }

        //
        // Now check to see if the device name that we are interested in is
        // in the enumerated data.
        //

        for (pObjInfo = (POBJECT_DIRECTORY_INFORMATION) lpBuffer;
             pObjInfo->Name.Length != 0;
             pObjInfo++)
        {
            if (RtlCompareUnicodeString( &(pObjInfo->Name), &ObjectNameString, TRUE) == 0)
            {
                found = TRUE;
                break;
            }
        }

        restartScan = FALSE;
    }
    while ((ntStatus == STATUS_MORE_ENTRIES) && (found == FALSE));

    NtClose(DirectoryHandle);
    LocalFree(lpBuffer);

CleanExit:

    if (found)
    {
        DWORD PreviousState;

        PreviousState = ServiceRecord->ServiceStatus.dwCurrentState;

        if (PreviousState != SERVICE_STOP_PENDING)
        {
            //
            // The driver IS running.
            //

            ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_RUNNING;

            if (PreviousState == SERVICE_STOPPED)
            {
                //
                // It used to be stopped but now it is running.
                //
                ServiceRecord->ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
                ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
                ServiceRecord->ServiceStatus.dwServiceSpecificExitCode = 0;
                ServiceRecord->ServiceStatus.dwCheckPoint = 0;
                ServiceRecord->ServiceStatus.dwWaitHint = 0;
                ServiceRecord->UseCount++;
                SC_LOG2(USECOUNT, "ScGetDriverStatus: " FORMAT_LPWSTR
                    " increment USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);
            }

            if (ServiceRecord->ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED)
            {
                ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
            }

            SC_LOG1(TRACE,
                    "ScGetDriverStatus: "FORMAT_LPWSTR" Driver is RUNNING\n",
                    ServiceRecord->ServiceName);
        }
    }
    else
    {
        //
        // The driver is NOT running.
        //

        SC_LOG1(TRACE,
                "ScGetDriverStatus: "FORMAT_LPWSTR" Driver is NOT RUNNING\n",
                ServiceRecord->ServiceName);

        switch(ServiceRecord->ServiceStatus.dwCurrentState) {
        case SERVICE_STOP_PENDING:
            //
            // If the old state was STOP_PENDING, then we can consider
            // it stopped.
            //
            LocalFree(ServiceRecord->ObjectName);

            ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
            ServiceRecord->ServiceStatus.dwControlsAccepted = 0;
            ServiceRecord->ServiceStatus.dwCheckPoint = 0;
            ServiceRecord->ServiceStatus.dwWaitHint = 0;
            ServiceRecord->ServiceStatus.dwWin32ExitCode = NO_ERROR;
            ServiceRecord->ObjectName = NULL;

            //
            // Since the service is no longer running, we need to decrement
            // the use count.  If the count is decremented to zero, and
            // the service is marked for deletion, it will get deleted.
            //
            ScDecrementUseCountAndDelete(ServiceRecord);

            break;

        case SERVICE_STOPPED:
            //
            // We are not likely to query this driver's status again soon,
            // so free its object name.
            //
            LocalFree(ServiceRecord->ObjectName);
            ServiceRecord->ObjectName = NULL;
            break;

        default:
            //
            // The driver stopped without being requested to do so.
            //
            LocalFree(ServiceRecord->ObjectName);

            ServiceRecord->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
            ServiceRecord->ServiceStatus.dwControlsAccepted = 0;
            ServiceRecord->ServiceStatus.dwCheckPoint = 0;
            ServiceRecord->ServiceStatus.dwWaitHint = 0;
            ServiceRecord->ServiceStatus.dwWin32ExitCode = ERROR_GEN_FAILURE;
            ServiceRecord->ObjectName = NULL;

            //
            // Since the service is no longer running, we need to decrement
            // the use count.  If the count is decremented to zero, and
            // the service is marked for deletion, it will get deleted.
            //
            ScDecrementUseCountAndDelete(ServiceRecord);

            break;
        }
    }

    if (ARGUMENT_PRESENT(lpServiceStatus))
    {
        RtlCopyMemory(
            lpServiceStatus,
            &(ServiceRecord->ServiceStatus),
            sizeof(SERVICE_STATUS));
    }

    return NO_ERROR;
}


DWORD
ScGetObjectName(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function gets a directory object path name for a driver by looking
    it up in the registry, or, if it isn't specified in the registry, by
    computing it from the driver name and type.  It allocates storage
    for this name, and passes back the pointer to it.  The Pointer to
    the object name string is stored in the ServiceRecord->ObjectName
    location.

    WARNING:  This function expects the EXCLUSIVE database lock to be held.


Arguments:

    ServiceRecord - This is a pointer to the ServiceRecord for the Driver.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - If there wasn't enough memory available for
        the ObjectName.

    or any error from ScOpenServiceConfigKey.

--*/
{
    DWORD   status;
    DWORD   bufferSize;
    LPWSTR  objectNamePath;
    HKEY    serviceKey;
    LPWSTR  pObjectName;

    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ServiceRecord->ObjectName != NULL) {
        //
        // Some other thread beat us to it
        //
        return(NO_ERROR);
    }

    //
    // Open the Registry Key for this driver name.
    //
    status = ScOpenServiceConfigKey(
                ServiceRecord->ServiceName,
                KEY_READ,
                FALSE,
                &serviceKey);

    if (status != NO_ERROR) {
        SC_LOG1(ERROR,"ScGetObjectName: ScOpenServiceConfigKey Failed %d\n",
            status);
        return(status);
    }

    //
    // Get the NT Object Name from the registry.
    //
    status = ScReadStartName(
                serviceKey,
                &pObjectName);


    ScRegCloseKey(serviceKey);

    //
    // Make sure we read a value with length greater than 0
    //
    if (status == NO_ERROR && pObjectName != NULL)
    {
        if (*pObjectName != '\0') {
            ServiceRecord->ObjectName = pObjectName;
            return(NO_ERROR);
        }
        else {
            LocalFree(pObjectName);
        }
    }

    //
    // There must not be a name in the ObjectName value field.
    // In this case, we must build the name from the type info and
    // the ServiceName.  Names will take the following form:
    //    "\\FileSystem\\Rdr"   example of a file system driver
    //    "\\Driver\\Parallel"   example of a kernel driver
    //
    //
    SC_LOG1(TRACE,"ScGetObjectName: ScReadStartName Failed(%d). Build the"
        "name instead\n",status);

    if (ServiceRecord->ServiceStatus.dwServiceType == SERVICE_FILE_SYSTEM_DRIVER) {

        bufferSize = sizeof(FILE_SYSTEM_OBJ_NAME);
        objectNamePath = FILE_SYSTEM_OBJ_NAME;
    }
    else {

        bufferSize = sizeof(DRIVER_OBJ_NAME);
        objectNamePath = DRIVER_OBJ_NAME;

    }

    bufferSize += (DWORD) WCSSIZE(ServiceRecord->ServiceName);

    pObjectName = (LPWSTR)LocalAlloc(LMEM_FIXED, (UINT) bufferSize);
    if (pObjectName == NULL) {
        SC_LOG0(ERROR,"ScGetObjectName: LocalAlloc Failed\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wcscpy(pObjectName, objectNamePath);
    wcscat(pObjectName, ServiceRecord->ServiceName);

    ServiceRecord->ObjectName = pObjectName;

    return(NO_ERROR);

}


DWORD
ScUnloadDriver(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function attempts to unload the driver whose service record
    is passed in.

    NOTE:  Make sure the ServiceRecord is for a driver and not a service
    before calling this routine.


Arguments:

    ServiceRecord - This is a pointer to the service record for a driver.
        This routine assumes that the service record is for a driver and
        not a service.

Return Value:

    NO_ERROR - if successful.

    ERROR_INVALID_SERVICE_CONTROL - This is returned if the driver is
        not unloadable.

    otherwise, an error code is returned.

Note:


--*/
{
    NTSTATUS        ntStatus = STATUS_SUCCESS;
    DWORD           status;
    LPWSTR          regKeyPath;
    UNICODE_STRING  regKeyPathString;
    ULONG           privileges[1];

    //
    // Create the Registry Key Path for this driver name.
    //
    regKeyPath = (LPWSTR)LocalAlloc(
                    LMEM_FIXED,
                    sizeof(SERVICE_PATH) +
                    WCSSIZE(ServiceRecord->ServiceName));

    if (regKeyPath == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        return(status);
    }
    wcscpy(regKeyPath, SERVICE_PATH);
    wcscat(regKeyPath, ServiceRecord->ServiceName);


    //
    // Unload the Driver
    // (but first get SeLoadDriverPrivilege)
    //

    RtlInitUnicodeString(&regKeyPathString, regKeyPath);

    privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;
    status = ScGetPrivilege(1,privileges);
    if (status != NO_ERROR) {
        LocalFree(regKeyPath);
        return(status);
    }

    ntStatus = NtUnloadDriver (&regKeyPathString);

    (VOID)ScReleasePrivilege();

    LocalFree(regKeyPath);

    if (!NT_SUCCESS(ntStatus)) {

        if (ntStatus == STATUS_INVALID_DEVICE_REQUEST) {

            status = ERROR_INVALID_SERVICE_CONTROL;
            return(status);
        }

        SC_LOG1(ERROR,"ScControlDriver: NtUnloadDriver Failed 0x%lx\n",ntStatus);

        status = RtlNtStatusToDosError(ntStatus);
        return(status);
    }

    SC_LOG1(TRACE,"ScLoadDeviceDriver: NtUnloadDriver Success for "
        ""FORMAT_LPWSTR "\n",ServiceRecord->ServiceName);

    return(NO_ERROR);

}


BOOL
ScIsPnPDriver(
    IN  LPSERVICE_RECORD Service
    )
/*++

Routine Description:

    This function checks whether a specified driver is a PnP driver

Arguments:

    Service - Specifies the driver of interest.

Return Value:

    TRUE - if the driver is a PnP driver or if this cannot be determined.

    FALSE - if the service is not a PnP driver.

--*/
{
    CONFIGRET   Status;
    BOOL        fRetStatus = TRUE;
    WCHAR *     pBuffer;
    ULONG       cchLen, cchTransferLen, ulRegDataType;
    WCHAR       szClassGuid[MAX_GUID_STRING_LEN];

    //
    // Allocate a buffer for the list of device instances associated with
    // this service
    //
    Status = PNP_GetDeviceListSize(
                    NULL,                           // hBinding
                    Service->ServiceName,           // pszFilter
                    &cchLen,                        // list length in wchars
                    CM_GETIDLIST_FILTER_SERVICE);   // filter is a service name

    if (Status != CR_SUCCESS)
    {
        SC_LOG2(WARNING, "PNP_GetDeviceListSize failed %#lx for service %ws\n",
                       Status, Service->ServiceName);
        return TRUE;
    }

    pBuffer = (WCHAR *) LocalAlloc(0, cchLen * sizeof(WCHAR));
    if (pBuffer == NULL)
    {
        SC_LOG(ERROR, "Couldn't allocate buffer for device list, error %lu\n",
                      GetLastError());
        return TRUE;
    }

    //
    // Initialize parameters for PNP_GetDeviceList, the same way as is
    // normally done in the client side of the API
    //
    pBuffer[0] = L'\0';

    //
    // Get the list of device instances that are associated with this service
    //
    // (For legacy and PNP-aware services, we could get an empty device list.)
    //
    Status = PNP_GetDeviceList(
                    NULL,                           // binding handle
                    Service->ServiceName,           // pszFilter
                    pBuffer,                        // buffer for device list
                    &cchLen,                        // buffer length in wchars
                    CM_GETIDLIST_FILTER_SERVICE |   // filter is a service name
                    CM_GETIDLIST_DONOTGENERATE      // do not generate an instance if none exists
                    );

    if (Status != CR_SUCCESS)
    {
        SC_LOG2(ERROR, "PNP_GetDeviceList failed %#lx for service %ws\n",
                       Status, Service->ServiceName);
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // If there are no devnodes, this is not a PnP driver
    //
    if (cchLen == 0 || pBuffer[0] == L'\0')
    {
        SC_LOG1(TRACE, "ScIsPnPDriver: %ws is not a PnP driver (no devnodes)\n",
                       Service->ServiceName);
        LocalFree(pBuffer);
        return FALSE;
    }

    //
    // If there's more than one devnode, this is a PnP driver
    //
    if (*(pBuffer + wcslen(pBuffer) + 1) != L'\0')
    {
        SC_LOG1(TRACE, "ScIsPnPDriver: %ws is a PnP driver (more than 1 devnode)\n",
                       Service->ServiceName);
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // Get the class GUID of this driver
    //
    cchLen = cchTransferLen = sizeof(szClassGuid);

    Status = PNP_GetDeviceRegProp(
                    NULL,                           // binding handle
                    pBuffer,                        // device instance
                    CM_DRP_CLASSGUID,               // property to get
                    &ulRegDataType,                 // pointer to REG_* type
                    (LPBYTE) szClassGuid,           // buffer for property
                    &cchTransferLen,                // transfer length
                    &cchLen,                        // buffer length in bytes
                    0);                             // flags

    if (Status != CR_SUCCESS)
    {
        SC_ASSERT(Status != CR_BUFFER_SMALL);

        SC_LOG2(ERROR, "PNP_GetDeviceRegProp failed %#lx for service %ws\n",
                       Status, Service->ServiceName);
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // If the single devnode's class is LegacyDriver,
    // this is not a PnP driver
    //

    fRetStatus = (_wcsicmp(szClassGuid, LEGACYDRIVER_STRING) != 0);

    SC_LOG2(TRACE, "ScIsPnPDriver: %ws %ws a PnP driver\n",
                   Service->ServiceName, fRetStatus ? L"is" : L"is not");

    LocalFree(pBuffer);
    return fRetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\dataman.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dataman.h

Abstract:

    Contains data structures and function prototypes for the Service
    Controller Database Manager and the Group List Database Manager.
    (Dataman.c & Groupman.c)


Author:

    Dan Lafferty (danl)     22-Oct-1993

Environment:

    User Mode -Win32

Revision History:

    04-Dec-1996     AnirudhS
        Added CCrashRecord.

    17-Aug-1995     AnirudhS
        Removed State field from LOAD_ORDER_GROUP, since it is recomputed
        every time it is read.

    26-Jun-1995     AnirudhS
        Added ScNotifyServiceObject.

    12-Apr-1995     AnirudhS
        Added AccountName field to image record.

    06-Oct-1993     danl
        Re-arranged comments so that structures are easier to read.

    19-Jan-1992     danl
        Modified for use with the "real" service controller

    20-Mar-1991     danl
        created
--*/

#ifndef SCDATAMAN_INCLUDED
#define SCDATAMAN_INCLUDED

#define USE_GROUPS

//
// ImageFlag definitions
//
#define CANSHARE_FLAG        0x00000001 // service can run in a shared process
#define IS_SYSTEM_SERVICE    0x00000002 // service runs in this exe or the security process

//
// StatusFlag definitions
//
#define DELETE_FLAG          0x00000001 // service is marked for delete
#define UPDATE_FLAG          0x00000002 //
#define CURRENTSTART_FLAG    0x00000004 //

//
// StatusFlag Macros.  SR = ServiceRecord
//

#define SET_DELETE_FLAG(SR)     (((SR)->StatusFlag) |= DELETE_FLAG)
#define CLEAR_DELETE_FLAG(SR)   (((SR)->StatusFlag) &= (~DELETE_FLAG))
#define DELETE_FLAG_IS_SET(SR)  (((SR)->StatusFlag) &  DELETE_FLAG)

#define SET_UPDATE_FLAG(SR)     (((SR)->StatusFlag) |= UPDATE_FLAG)
#define CLEAR_UPDATE_FLAG(SR)   (((SR)->StatusFlag) &= (~UPDATE_FLAG))
#define UPDATE_FLAG_IS_SET(SR)  (((SR)->StatusFlag) &  UPDATE_FLAG)

//
// To get a demand start service to be started correctly in group
// order specified by the ServiceGroupOrder list, we need an additional
// flag to indicate that this service must be included in the same start
// request.
//
#define SET_CURRENTSTART_FLAG(SR)     (((SR)->StatusFlag) |= CURRENTSTART_FLAG)
#define CLEAR_CURRENTSTART_FLAG(SR)   (((SR)->StatusFlag) &= (~CURRENTSTART_FLAG))
#define CURRENTSTART_FLAG_IS_SET(SR)  (((SR)->StatusFlag) &  CURRENTSTART_FLAG)


//
// Data Structures
//

//
//==================
// LOAD_ORDER_GROUP
//==================
// NOTE:  This is an ordered linked list.  The Next group is loaded after
//  this group.
//
// Reference count which indicates the number of members in this
// group plus any dependency pointer that points to this group.
// This field is only used for standalone groups so that we know
// when to delete the group entry.  This value is always set to
// 0xffffffff if this entry represents an order group.
//
typedef struct _LOAD_ORDER_GROUP {
    struct _LOAD_ORDER_GROUP    *Next;
    struct _LOAD_ORDER_GROUP    *Prev;
    LPWSTR                      GroupName;
    DWORD                       RefCount;

} LOAD_ORDER_GROUP, *PLOAD_ORDER_GROUP, *LPLOAD_ORDER_GROUP;



//================
// IMAGE_RECORD
//================
typedef struct _IMAGE_RECORD {
    struct _IMAGE_RECORD    *Prev;              // linked list
    struct _IMAGE_RECORD    *Next;              // linked list
    LPWSTR                  ImageName;          // fully qualified .exe name
    DWORD                   Pid;                // Process ID
    DWORD                   ServiceCount;       // Num services running in process
    HANDLE                  PipeHandle;         // Handle to Service
    HANDLE                  ProcessHandle;      // Handle for process
    HANDLE                  ObjectWaitHandle;   // Handle for waiting on the process
    HANDLE                  TokenHandle;        // Logon token handle
    LUID                    AccountLuid;        // Unique LUID for this logon session
    HANDLE                  ProfileHandle;      // User profile handle
    LPWSTR                  AccountName;        // Account process was started under
    DWORD                   ImageFlags;         // Flags for the IMAGE_RECORD
}IMAGE_RECORD, *PIMAGE_RECORD, *LPIMAGE_RECORD;

typedef enum _DEPEND_TYPE {
    TypeNone = 0,
    TypeDependOnService = 128,
    TypeDependOnGroup,
    TypeDependOnUnresolved  // only for service
} DEPEND_TYPE, *PDEPEND_TYPE, *LPDEPEND_TYPE;

//================
// DEPEND_RECORD
//================
// A service record has a pointer to this structure if the service
// must be started after some services, or must be stopped after some
// services.
// NOTE:  This is an ordered linked list.  This service depends on the
//  "Next" service.  Question:  Does this service depend on all the services
//  in the Next chain?
//
// Depend union:
// Based on the DependType field, this pointer may point to a
// service or a group which the service depends on, or an
// unresolved dependency structure.
//
typedef struct _DEPEND_RECORD {
    struct _DEPEND_RECORD   *Next;
    DEPEND_TYPE             DependType;
    union {
        struct _SERVICE_RECORD *    DependService;
        struct _LOAD_ORDER_GROUP *  DependGroup;
        struct _UNRESOLVED_DEPEND * DependUnresolved;
        LPVOID                      Depend; // used when type doesn't matter
    };
} DEPEND_RECORD, *PDEPEND_RECORD, *LPDEPEND_RECORD;


//================
// CCrashRecord
//================
// This structure counts a service's crashes and remembers the time of the
// last crash.  It is allocated only for services that crash.
//
class CCrashRecord
{
public:
            CCrashRecord() :
                _LastCrashTime(0),
                _Count(0)
                    { }

    DWORD   IncrementCount(DWORD ResetSeconds);

private:

    __int64     _LastCrashTime; // FILETIME = __int64
    DWORD       _Count;
};



//================
// SERVICE_RECORD
//================
// Dependency information:
//    StartDepend is a linked list of services and groups that must be
//        started first before this service can start.
//    StopDepend is a linked list of services and groups that must be
//        stopped first before this service can stop.
//    Dependencies is a string read in from the registry.  Deleted when
//      the info has been converted to a StartDepend list.
//
// StartError:
// Error encountered by service controller when starting a service.
// This is distinguished from error posted by the service itself in
// the exitcode field.
//
// StartState:
// SC managed service state which is distinguished from the service
// current state to enable correct handling of start dependencies.
//
// Load order group information:
//
//     MemberOfGroup is a pointer to a load order group which this service
//         is currently a member of.  This value is set to NULL if this
//         service does not belong to a group.  A non-NULL pointer could
//         point to a group entry in either the order group or standalone
//         group list.
//
//     RegistryGroup is a pointer to a group which we have recorded in the
//         registry as the group this service belongs to.  This is not the
//         same as MemberOfGroup whenever the service is running and the
//         load order group of the service has been changed
//
typedef struct _SERVICE_RECORD {
    struct _SERVICE_RECORD  *Prev;          // linked list
    struct _SERVICE_RECORD  *Next;          // linked list
    LPWSTR                  ServiceName;    // points to service name
    LPWSTR                  DisplayName;    // points to display name
    DWORD                   ResumeNum;      // Ordered number for this rec
    DWORD                   ServerAnnounce; // Server announcement bit flags
    DWORD                   Signature;      // Identifies this as a service record.
    DWORD                   UseCount;       // How many open handles to service
    DWORD                   StatusFlag;     // status(delete,update...)
    union {
        LPIMAGE_RECORD      ImageRecord;    // Points to image record
        LPWSTR              ObjectName;     // Points to driver object name
    };
    SERVICE_STATUS          ServiceStatus;  // see winsvc.h
    DWORD                   StartType;      // AUTO, DEMAND, etc.
    DWORD                   ErrorControl;   // NORMAL, SEVERE, etc.
    DWORD                   Tag;            // DWORD Id for the service,0=none.
    LPDEPEND_RECORD         StartDepend;
    LPDEPEND_RECORD         StopDepend;
    LPWSTR                  Dependencies;
    PSECURITY_DESCRIPTOR    ServiceSd;
    DWORD                   StartError;
    DWORD                   StartState;
    LPLOAD_ORDER_GROUP      MemberOfGroup;
    LPLOAD_ORDER_GROUP      RegistryGroup;
    CCrashRecord *          CrashRecord;
}
SERVICE_RECORD, *PSERVICE_RECORD, *LPSERVICE_RECORD;


//===================
// UNRESOLVED_DEPEND
//===================
// Unresolved dependency record structure
//
// Unresolved dependency entries are linked together so that when a
// new service or group is created (installed) we can look it up in this
// list to see if the service or group is already depended on by some
// other service.
//
typedef struct _UNRESOLVED_DEPEND {
    struct _UNRESOLVED_DEPEND *Next;
    struct _UNRESOLVED_DEPEND *Prev;
    LPWSTR                    Name;     // Service or group name
    DWORD                     RefCount;
} UNRESOLVED_DEPEND, *PUNRESOLVED_DEPEND, *LPUNRESOLVED_DEPEND;


//
// Macros & Constants
//

//
// for every service record in the database...
//
#define FOR_ALL_SERVICES(SR)                                            \
                     SC_ASSERT(ScServiceListLock.Have());               \
                     for (LPSERVICE_RECORD SR = ScGetServiceDatabase(); \
                          SR != NULL;                                   \
                          SR = SR->Next)

//
// for every service record in the database that meets this condition...
//
#define FOR_SERVICES_THAT(SR, condition)                                \
                                    FOR_ALL_SERVICES(SR)                \
                                        if (!(condition))               \
                                            continue;                   \
                                        else

#define FIND_END_OF_LIST(record)    while((record)->Next != NULL) {     \
                                        (record)=(record)->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    (record)->Prev->Next = (record)->Next;      \
                                    if ((record)->Next != NULL) {               \
                                        (record)->Next->Prev = (record)->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST((record))      \
                                    (record)->Next = (newRec);      \
                                    (newRec)->Prev = (record);      \
                                    (newRec)->Next = NULL;


//
// Service controller maintains the state of a service when
// starting up a service and its dependencies in the StartState
// field of the service record.
//
#define SC_NEVER_STARTED         0x00000000
#define SC_START_NOW             0x00000001
#define SC_START_PENDING         0x00000002
#define SC_START_SUCCESS         0x00000003
#define SC_START_FAIL            0x00000004


#define TERMINATE_TIMEOUT       20000       // wait response to terminate req.


//
// External Globals
//

extern  LPLOAD_ORDER_GROUP  ScGlobalTDIGroup;
extern  LPLOAD_ORDER_GROUP  ScGlobalPNP_TDIGroup;


//
// Function Prototypes
//

LPLOAD_ORDER_GROUP
ScGetOrderGroupList(
    VOID
    );

LPLOAD_ORDER_GROUP
ScGetStandaloneGroupList(
    VOID
    );

LPSERVICE_RECORD
ScGetServiceDatabase(
    VOID
    );

LPUNRESOLVED_DEPEND
ScGetUnresolvedDependList(
    VOID
    );

BOOL
ScInitDatabase(
    VOID
    );

VOID
ScInitGroupDatabase(VOID);

VOID
ScEndGroupDatabase(VOID);

DWORD
ScCreateDependRecord(
    IN  BOOL IsStartList,
    IN  OUT PSERVICE_RECORD ServiceRecord,
    OUT PDEPEND_RECORD *DependRecord
    );

DWORD
ScCreateImageRecord (
    OUT     LPIMAGE_RECORD      *ImageRecordPtr,
    IN      LPWSTR              ImageName,
    IN      LPWSTR              AccountName,
    IN      DWORD               Pid,
    IN      HANDLE              PipeHandle,
    IN      HANDLE              ProcessHandle,
    IN      HANDLE              TokenHandle,
    IN      HANDLE              ProfileHandle,
    IN      DWORD               ImageFlags
    );

DWORD
ScCreateServiceRecord(
    IN  LPWSTR              ServiceName,
    OUT LPSERVICE_RECORD   *ServiceRecord
    );

VOID
ScFreeServiceRecord(
    IN  LPSERVICE_RECORD   ServiceRecord
    );

VOID
ScDecrementUseCountAndDelete(
    LPSERVICE_RECORD    ServiceRecord
    );

BOOL
ScFindEnumStart(
    IN  DWORD               ResumeIndex,
    OUT LPSERVICE_RECORD    *ServiceRecordPtr
    );

BOOL
ScGetNamedImageRecord (
    IN      LPWSTR              ImageName,
    OUT     LPIMAGE_RECORD      *ImageRecordPtr
    );

DWORD
ScGetNamedServiceRecord (
    IN      LPWSTR              ServiceName,
    OUT     LPSERVICE_RECORD    *ServiceRecordPtr
    );

LPLOAD_ORDER_GROUP
ScGetNamedGroupRecord(
    IN      LPCWSTR             GroupName
    );

DWORD
ScGetDisplayNamedServiceRecord (
    IN      LPWSTR              ServiceDisplayName,
    OUT     LPSERVICE_RECORD    *ServiceRecordPtr
    );

DWORD
ScGetTotalNumberOfRecords(
    VOID
    );

VOID
ScProcessCleanup(
    HANDLE  ProcessHandle
    );

VOID
ScQueueRecoveryAction(
    IN LPSERVICE_RECORD     ServiceRecord
    );

VOID
ScDeleteMarkedServices(
    VOID
    );

DWORD
ScUpdateServiceRecord (
    IN      LPSERVICE_STATUS    ServiceStatus,
    IN      LPSERVICE_RECORD    ServiceRecord
    );

DWORD
ScRemoveService (
    IN      LPSERVICE_RECORD    ServiceRecord
    );

DWORD
ScTerminateServiceProcess (
    IN  PIMAGE_RECORD   ImageRecord
    );

VOID
ScDeleteImageRecord (
    IN LPIMAGE_RECORD   ImageRecord
    );

VOID
ScActivateServiceRecord (
    IN LPSERVICE_RECORD     ServiceRecord,
    IN LPIMAGE_RECORD       ImageRecord
    );

DWORD
ScDeactivateServiceRecord (
    IN LPSERVICE_RECORD     ServiceRecord
    );

DWORD
ScCreateOrderGroupEntry(
    IN  LPWSTR GroupName
    );

DWORD
ScAddConfigInfoServiceRecord(
    IN  LPSERVICE_RECORD     ServiceRecord,
    IN  DWORD                ServiceType,
    IN  DWORD                StartType,
    IN  DWORD                ErrorControl,
    IN  LPWSTR               Group OPTIONAL,
    IN  DWORD                Tag,
    IN  LPWSTR               Dependencies OPTIONAL,
    IN  LPWSTR               DisplayName OPTIONAL,
    IN  PSECURITY_DESCRIPTOR Sd OPTIONAL
    );


VOID
ScGenerateDependencies(
    VOID
    );

DWORD
ScSetDependencyPointers(
    LPSERVICE_RECORD Service
    );

DWORD
ScResolveDependencyToService(
    LPSERVICE_RECORD Service
    );

VOID
ScUnresolveDependencyToService(
    LPSERVICE_RECORD Service
    );

DWORD
ScCreateDependencies(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Dependencies OPTIONAL
    );

VOID
ScDeleteStartDependencies(
    IN PSERVICE_RECORD ServiceRecord
    );

VOID
ScDeleteStopDependencies(
    IN PSERVICE_RECORD ServiceToBeDeleted
    );

DWORD
ScCreateGroupMembership(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Group OPTIONAL
    );

VOID
ScDeleteGroupMembership(
    IN OUT PSERVICE_RECORD ServiceRecord
    );

DWORD
ScCreateRegistryGroupPointer(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Group OPTIONAL
    );

VOID
ScDeleteRegistryGroupPointer(
    IN OUT PSERVICE_RECORD ServiceRecord
    );

VOID
ScGetUniqueTag(
    IN  LPWSTR GroupName,
    OUT LPDWORD Tag
    );

DWORD
ScUpdateServiceRecordConfig(
    LPSERVICE_RECORD    ServiceRecord,
    DWORD               dwServiceType,
    DWORD               dwStartType,
    DWORD               dwErrorControl,
    LPWSTR              lpLoadOrderGroup,
    LPBYTE              lpDependencies
    );

VOID
ScGetDependencySize(
    LPSERVICE_RECORD    ServiceRecord,
    LPDWORD             DependSize,
    LPDWORD             MaxDependSize
    );

DWORD
ScGetDependencyString(
    LPSERVICE_RECORD    ServiceRecord,
    DWORD               MaxDependSize,
    DWORD               DependSize,
    LPWSTR              lpDependencies
    );

BOOL
ScAllocateSRHeap(
    DWORD   HeapSize
    );

#if DBG
VOID
ScDumpGroups(
    VOID
    );

VOID
ScDumpServiceDependencies(
    VOID
    );
#endif  // if DBG

#endif // ifndef SCDATAMAN_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\depend.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    depend.cxx

Abstract:

    This module contains routines which handle service start and
    stop dependencies:
        ScInitAutoStart
        ScAutoStartServices
        ScStartServiceAndDependencies
        ScSetServiceStartRequest
        ScMarkGroupStartNow
        RI_ScGetCurrentGroupStateW
        ScStartMarkedServices
        ScHandleServiceFailure
        ScDependenciesStarted
        ScLookForHungServices
        ScHandleBadDependencies
        ScServiceToStartDependOn
        ScNotifyChangeState
        ScDependentsStopped
        ScEnumDependents
        ScFoundDuplicateDependent
        ScInHardwareProfile

Author:

    Rita Wong (ritaw)     03-Apr-1992

Environment:

    Win32

Revision History:

    11-Jun-2000     JSchwart
        Add no-reboot support for machine name change during OOBE
        setup and initial boot
    08-Jan-1997     AnirudhS
        Remove I_ScGetCurrentGroupStateW as it is no longer used.  In
        ScStartServiceAndDependencies, get an exclusive grouplist lock
        once more, instead of a shared one.
    11-Jun-1996     AnirudhS
        During setup/upgrade, don't event-log failure of a service to start
        due to a dependent service not starting.  (The most common case of
        this is a service that runs in a domain account, and hence has an
        implicit dependency on netlogon, which is disabled during setup.)
    03-Nov-1995     AnirudhS
        Don't try to start a service that isn't in the current hardware
        profile.
    30-Oct-1995     AnirudhS
        ScStartMarkedServices: If ScStartService says that a service is
        already running, treat this as a success.
    15-Aug-1995     AnirudhS
        Added I_ScGetCurrentGroupStateW.
        Changed while loops to for loops and if stmts to switch stmts for
        improved readability.
    16-Aug-1994     Danl
        ScLookForHungServices:  If a long waitHint was passed in, the sleep
        time would be set to a huge number (like 4.9 days).  This was
        changed so that if the waitHint is over 100 seconds, then the
        sleep time is limited to 10 seconds, but the number of iterations
        for the polling goes up.
    09-Jun-1994     Danl
        Begin working on making sure NetLogon is started if we are
        going to start a service that runs in an account.  This requires
        making a dependency on NetLogon.
    21-Apr-1992 JohnRo
        Use SC_LOG0(), FORMAT_ equates, etc
    03-Apr-1992     ritaw
        created

--*/

#include "precomp.hxx"
#include <string.h>     // memcpy
#include <stdlib.h>     // wcslen
#include <winerror.h>
#include <lmcons.h>     // NET_API_STATUS
#include <srvann.h>     // I_ScGetCurrentGroupStateW and related definitions
#include <cfgmgr32.h>   // PNP manager functions
#include <pnp.h>        // PNP manager functions, server side
#include <cfgmgrp.h>    // PNP manager functions, server side, internal (PNP_GET_HWPROFFLAGS)
#include <regstr.h>     // CSCONFIGFLAG_ constants
#include <tstr.h>       // WCSSIZE
#include <sclib.h>      // ScCopyStringToBufferW
#include <svcslib.h>    // SetupInProgress
#include <winsvcp.h>    // OOBE setup event names

#include "start.h"      // ScStartService
#include "depend.h"
#include "info.h"       // ScQueryServiceStatus
#include "bootcfg.h"    // ScRevertToLastKnownGood
#include "driver.h"     // ScGetDriverStatus
#include "lockapi.h"    // ScLockDatabase
#include "account.h"    // SC_LOCAL_SYSTEM_USER_NAME
#include "scconfig.h"   // ScRegCloseKey

#define SERVICE_START_TIMEOUT     80000                 // 80 seconds
#define LENGTH(array)   (sizeof(array)/sizeof((array)[0]))

#define GROUP_NOT_STARTED    0x00000000
#define GROUP_ONE_STARTED    0x00000001
#define GROUP_START_FAIL     0x00000002

#define REG_KEY_SETUP_ALLOW_START L"System\\Setup\\AllowStart"

//
// TDI GROUP SPECIAL:  The PNP_TDI group is treated as a subgroup of
// the TDI group for dependency purposes (though not for group start
// ordering purposes).  This is implemented via the following macros.
// A service BELONGS_TO a group either if it is a member of that group,
// or if the group is the TDI group and the service is a member of the
// PNP_TDI group.
// IS_SUBGROUP returns true if Group1 is equal to or a subgroup of Group2.
//
#define IS_SUBGROUP(Group1, Group2)                 \
    ((Group1) == (Group2) ||                        \
     (Group2) == ScGlobalTDIGroup && (Group1) == ScGlobalPNP_TDIGroup)

#define BELONGS_TO(Service, Group)                  \
    IS_SUBGROUP((Service)->MemberOfGroup, (Group))

//-------------------------------------------------------------------//
//                                                                   //
// Static global variables                                           //
//                                                                   //
//-------------------------------------------------------------------//

//
// For notifying us that a service has gone from start-pending state
// to running or stopped state.
//
/* static */ HANDLE ScServiceChangeStateEvent = NULL;

//
// For serializing start requests
//
/* static */ CRITICAL_SECTION ScServiceStartCriticalSection;

//
// For telling internal routines when auto-start is in progress
//
BOOL  ScAutoStartInProgress;

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

VOID
ScSetServiceStartRequest(
    IN  LPSERVICE_RECORD ServiceRecord,
    IN  BOOL DemandStarting
    );

BOOL
ScMarkGroupStartNow(
    IN LPLOAD_ORDER_GROUP Group
    );

DWORD
ScGetCurrentGroupState(
    LPLOAD_ORDER_GROUP Group
    );

DWORD
ScStartMarkedServices(
    IN LPSERVICE_RECORD ServiceToStart OPTIONAL,
    IN DWORD NumArgs,
    IN LPSTRING_PTRSW CmdArgs,
    IN BOOL WaitForAll
    );

VOID
ScHandleServiceFailure(
    IN LPSERVICE_RECORD Service
    );

BOOL
ScDependenciesStarted(
    IN  LPSERVICE_RECORD Service,
    OUT BOOL *IsBadDependencies,
    OUT BOOL *AllStarted,
    OUT BOOL *ExistsBlockedService
    );

BOOL
IsDependOnLaterGroup(
    IN LPLOAD_ORDER_GROUP ServiceGroup,
    IN LPLOAD_ORDER_GROUP DependOnGroup,
    IN DEPEND_TYPE DependType
    );

VOID
ScCleanupStartFailure(
    LPSERVICE_RECORD Service,
    DWORD StartError
    );

VOID
ScLookForHungServices(
    VOID
    );

VOID
ScHandleBadDependencies(
    VOID
    );

BOOL
ScServiceToStartDependOn(
    LPSERVICE_RECORD ServiceToStart OPTIONAL,
    LPSERVICE_RECORD StartPendingService
    );

BOOL
ScFoundDuplicateDependent(
    IN LPWSTR ServiceName,
    IN LPENUM_SERVICE_STATUS_WOW64 EnumBuffer,
    IN LPENUM_SERVICE_STATUS_WOW64 BufferEnd
    );

#ifndef _CAIRO_
VOID
ScCheckNetLogonDepend(
    LPSERVICE_RECORD    ServiceRecord,
    BOOL                DemandStarting
    );
#endif // _CAIRO_


BOOL
ScInitAutoStart(
    VOID
    )
/*++

Routine Description:

    This function creates the event for notifying the service controller
    that one of the automatically started service is running and creates
    the mutex for serializing start requests.

Arguments:

    None.

Return Value:

    TRUE - Event and mutex were created successfully.  FALSE otherwise.

--*/
{
    //
    // Create event which indicates that some service that has been
    // automatically started is now running or stopped.
    //
    if ((ScServiceChangeStateEvent =
             CreateEvent(
                 NULL,                // Event attributes
                 TRUE,                // Event must be manually reset
                 FALSE,               // Initial state not signalled
                 NULL
                 )) == (HANDLE) NULL) {

        return FALSE;
    }

    //
    // Create critical section which is used to serialize start requests:
    // if auto-starting services, and a user tries to demand start
    // a service, auto-starting has to complete before we process the
    // demand start.
    //
    InitializeCriticalSection(&ScServiceStartCriticalSection);

    return TRUE;
}


DWORD
ScAutoStartServices(
    IN OUT   LPSC_RPC_LOCK lpLock
    )
/*++

Routine Description:

    This function automatically starts all services that must be
    auto-started, in group order.

    This routine may not return because we may instigate a reboot to
    revert to last-known-good.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD dwOOBEMode;

    ScAutoStartInProgress = TRUE;

    //
    // Set current request flag of all auto-start services as well as
    // their dependencies
    //

    SetupInProgress(NULL, &dwOOBEMode);

    if (dwOOBEMode)
    {

#define   NUM_OOBE_SERVICES    2

        DWORD            dwError;
        DWORD            dwTries = 0;
        LPSERVICE_RECORD ServiceRecord = NULL;
        HANDLE           hPnPDone;
        HANDLE           hMachineNameDone;
        LPWSTR           lpServicesForOobe[NUM_OOBE_SERVICES] = { L"PlugPlay", L"AudioSrv" };
        UINT             i;

        SC_LOG0(TRACE,
                "ScAutoStartServices:  Is OOBE -- creating events\n");

        //
        // OOBE setup will wait on this event first.  We set it
        // once PnP is done starting to wake up OOBE setup (which
        // will then prompt the user for the new machine name)
        //
        hPnPDone = CreateEvent(
                        NULL,                 // Event Attributes
                        TRUE,                 // ManualReset
                        FALSE,                // Initial State (not-signaled)
                        SC_OOBE_PNP_DONE);    // Name

        if (!hPnPDone)
        {
            dwError = GetLastError();

            SC_LOG1(ERROR,
                    "ScAutoStartServices:  Creation of SC_OOBE_PNP_DONE event failed %d\n",
                    dwError);

            return dwError;
        }

        //
        // Once the machine name is set, OOBE setup will set this
        // event to tell us to finish auto-starting the services
        //
        hMachineNameDone = CreateEvent(
                                NULL,                         // Event Attributes
                                TRUE,                         // ManualReset
                                FALSE,                        // Initial State (not-signaled)
                                SC_OOBE_MACHINE_NAME_DONE);   // Name


        if (!hMachineNameDone)
        {
            dwError = GetLastError();

            SC_LOG1(ERROR,
                    "ScAutoStartServices:  Creation of SC_OOBE_PNP_DONE event failed %d\n",
                    dwError);

            CloseHandle(hPnPDone);
            return dwError;
        }


        SC_LOG0(TRACE,
                "ScAutoStartServices:  Starting services used by OOBE\n");

        //
        // Start both services for OOBE, start only PlugPlay for SP install
        //

        for (i = 0; i < (dwOOBEMode != 2 ? NUM_OOBE_SERVICES : (UINT) 1); i++)
        {
            //
            // Since a computer name change may require PnP to be running,
            // start it and only it and wait until signalled to start the rest.
            // Grab the service list lock since ScGetNamedServiceRecord uses
            // the FOR_ALL_SERVICES macro, which expects it.  Also start
            // AudioSrv, which is needed for audio for OOBE.
            //

            {
                CServiceListSharedLock LLock;

                dwError = ScGetNamedServiceRecord(lpServicesForOobe[i], &ServiceRecord);
            }

            if (dwError != NO_ERROR)
            {
                //
                // Ignore failure since ServiceRecord will now be NULL so
                // the call below will start all the auto-start services
                // instead of just PnP.  The machine name will be wrong in
                // some of the services until the next reboot, but there's
                // nothing we can do about it at this point.
                //

                SC_LOG2(ERROR,
                        "ScAutoStartServices: OOBE lookup of service %ws failed %d\n",
                        lpServicesForOobe[i],
                        dwError);
            }

            dwError = ScStartServiceAndDependencies(ServiceRecord, 0, NULL, TRUE);

            if (dwError != NO_ERROR)
            {
                //
                // Ignore failure -- it's possible PnP won't need to be
                // up and running (it's only necessary if the OEM setup
                // for the machine was done without a keyboard and PnP
                // is now needed to detect the hardware).  Audio failure
                // is definitely non-fatal.
                //

                SC_LOG2(ERROR,
                        "ScAutoStartServices: OOBE start of %ws failed %d\n",
                        lpServicesForOobe[i],
                        dwError);
            }
        }

        //
        // Drop the database lock since OOBE may invoke server-side PnP
        // installations and setupapi.dll will try to lock the database.
        // In addition, it may invoke 3rd-party class installers and we
        // have no idea what they may try to do with the lock.
        //

        ScUnlockDatabase(lpLock);

        //
        // Let setup proceed
        //

        if (!SetEvent(hPnPDone))
        {
            dwError = GetLastError();
            SC_LOG1(ERROR,
                    "ScAutoStartServices: Failed to set event (hPnPDone) %d\n",
                    dwError);
        }


        //
        // Wait for setup to let us proceed.
        //

        WaitForSingleObject(hMachineNameDone, INFINITE);

        dwError = NO_ERROR;

        //
        // Reacquire the database lock.  Wait 10 minutes at most.
        //

        do
        {
            if (dwError != NO_ERROR)
            {
                Sleep(2000);
            }

            dwError = ScLockDatabase(TRUE, SERVICES_ACTIVE_DATABASEW, lpLock);

            dwTries++;
        }
        while (dwError != NO_ERROR && dwTries != 300);

        CloseHandle(hPnPDone);
        CloseHandle(hMachineNameDone);

        if (dwError != NO_ERROR)
        {
            SC_LOG1(ERROR,
                    "ScAutoStartServices: Failed to reacquire database lock %d\n",
                    dwError);

            return dwError;
        }

#undef NUM_OOBE_SERVICES

    }


    //
    // Start services with start request flag set in group order
    //
    ScStartServiceAndDependencies(NULL, 0, NULL, FALSE);

    ScAutoStartInProgress = FALSE;

    return NO_ERROR;
}


DWORD
ScStartServiceAndDependencies(
    IN LPSERVICE_RECORD ServiceToStart OPTIONAL,
    IN DWORD NumArgs,
    IN LPSTRING_PTRSW CmdArgs,
    IN BOOL fIsOOBE
    )
/*++

Routine Description:

    This function marks a group or a service to be started now before
    calling ScStartMarkedServices to start them.

Arguments:

    ServiceToStart - Service to be started; or, NULL if autostarting
        services.

    NumArgs, CmdArgs - Arguments for the service to be started.

Return Value:

    NO_ERROR if successful; otherwise, the return value from the first
    unsuccessful call to ScStartMarkedServices.

--*/
{
    DWORD status;
    DWORD ApiStatus = NO_ERROR;
    PLOAD_ORDER_GROUP Group;
    SC_RPC_LOCK Lock;
    BOOL    databaseLocked = FALSE;

    //
    // Serialize start requests by allowing auto-starting of groups or
    // demand start of a service one at a time.
    //
    EnterCriticalSection(&ScServiceStartCriticalSection);

    //
    // Grab the SC Manager database lock.
    //
    if (!ScStillInitializing) {
        if ((status = ScLockDatabase(
                          TRUE,                     // called internally
                          SERVICES_ACTIVE_DATABASEW,
                          &Lock
                          )) != NO_ERROR) {

            LeaveCriticalSection(&ScServiceStartCriticalSection);
            return status;
        }
        databaseLocked = TRUE;
    }

    //
    // There is one (highly unlikely) condition in which we might need to
    // modify the group information here: if we call ScStartService and it
    // calls ScDeactivateSR on a service whose update flag is set (its
    // config was changed while it was running).
    // To prevent deadlocks, the grouplist lock is always acquired before
    // the service database lock, if both are needed.  So we get an
    // exclusive lock on the grouplist here.
    //
    {
        CGroupListExclusiveLock GLock;

        //
        // Get a shared lock on the service list as we shall walk it several
        // times.
        //
        CServiceListSharedLock LLock;

        //
        // Get the exclusive database lock so that we can increment the
        // use count of the service being started as well as their dependencies
        // because otherwise they could go away if deleted.
        //
        {
            CServiceRecordExclusiveLock RLock;

            if (ARGUMENT_PRESENT(ServiceToStart)) {

                //
                // Demand starting a service.
                //

                //
                // We can never start a disabled service
                //
                if (ServiceToStart->StartType == SERVICE_DISABLED ||
                    ! ScInHardwareProfile(ServiceToStart->ServiceName, 0)) {
                    ApiStatus = ERROR_SERVICE_DISABLED;
                    goto ReleaseLocks;
                }

                //
                // Cannot start a deleted service.
                //
                if (DELETE_FLAG_IS_SET(ServiceToStart)) {
                    ApiStatus = ERROR_SERVICE_MARKED_FOR_DELETE;
                    goto ReleaseLocks;
                }

                //
                // Get the current state of the service
                //
                if (ServiceToStart->ServiceStatus.dwServiceType & SERVICE_DRIVER) {
                    (void) ScGetDriverStatus(ServiceToStart, NULL);
                }

                if  (ServiceToStart->ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                    ApiStatus = ERROR_SERVICE_ALREADY_RUNNING;
                    goto ReleaseLocks;
                }

                //
                // Set the current-start flag on the service and all of
                // its dependencies.  Also increment their use counts so
                // that we know they won't go away, even when we release
                // the locks temporarily.
                //
                SC_LOG(DEPEND,"Setting start request for %ws and dependencies\n",
                        ServiceToStart->ServiceName);
                SC_LOG(WHY, " Will start %ws because of an explicit start request\n",
                        ServiceToStart->ServiceName);
                ScSetServiceStartRequest(ServiceToStart, TRUE);
            }
            else {

                //
                // Auto-starting services.
                //

                // If we are in GUI mode setup, we only start those auto-start
                // services that are allowed.  Allowed services are listed
                // under HKLM\System\Setup\AllowStart as registry keys.
                // If the subkey with the same name as the service exits,
                // it means we allow it to be autostarted during GUI mode.
                //
                HKEY hkeyAllowStart = NULL;
                BOOL InSetup = SetupInProgress(NULL, NULL);

                if (InSetup)
                {
                    status = ScRegOpenKeyExW(
                                HKEY_LOCAL_MACHINE,
                                REG_KEY_SETUP_ALLOW_START,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                &hkeyAllowStart);

                    if (NO_ERROR != status)
                    {
                        // This is not expected as the registry key is created
                        // by hivesys.inf.  We'll skip checking services in
                        // this case.
                        //
                        hkeyAllowStart = NULL;
                    }
                }

                // Set the CurrentStartRequest flag to TRUE for all services
                // of type AUTO_START that are enabled in this hardware profile,
                // and their dependencies.
                //
                SC_LOG0(DEPEND,"Setting start request for auto-started services and dependencies\n");
                FOR_SERVICES_THAT(Service, Service->StartType == SERVICE_AUTO_START &&
                                           ScInHardwareProfile(Service->ServiceName, 0))
                {
                    BOOL AllowStart = TRUE;

                    if (hkeyAllowStart)
                    {
                        HKEY hkey;

                        ASSERT(InSetup);

                        status = ScRegOpenKeyExW(
                                    hkeyAllowStart,
                                    Service->ServiceName,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ,
                                    &hkey);
                        if (NO_ERROR == status)
                        {
                            // The service name exists and is therefore
                            // allowed to start.  Don't forget to close the
                            // key.
                            ScRegCloseKey(hkey);

                            ASSERT(AllowStart);
                        }
                        else
                        {
                            AllowStart = FALSE;

                            SC_LOG(WHY, " Will NOT start %ws because it's not "
                                    "allowed to run during system setup\n",
                                    Service->ServiceName);
                        }
                    }

                    if (AllowStart)
                    {
                        SC_LOG(WHY, " Will start %ws because it's configured to autostart\n",
                                Service->ServiceName);
                        ScSetServiceStartRequest(Service, FALSE);
                    }
                }

                if (hkeyAllowStart)
                {
                    ScRegCloseKey(hkeyAllowStart);
                }
            }
        }   // Release RLock

        //
        // Always start services in group order.
        //
        for (Group = ScGetOrderGroupList();
             Group != NULL;
             Group = Group->Next)
        {
            //
            // Start each group in load group order
            //
            if (ScMarkGroupStartNow(Group)) {

                SC_LOG(DEPEND,"------ Starting services in group \"%ws\" -----\n", Group->GroupName);
                BOOL WaitForGroup;

                if (ARGUMENT_PRESENT(ServiceToStart) &&
                    ServiceToStart->MemberOfGroup == Group) {

                    //
                    // Don't have to wait for all marked members of the group
                    // to finish starting because the service which is demand
                    // started is polled by the UI.
                    //
                    WaitForGroup = FALSE;
                }
                else {
                    //
                    // Auto-starting (ServiceToStart == NULL) or demand-starting
                    // a service that is not within this group.  Wait for group
                    // all marked members finish starting.
                    //
                    WaitForGroup = TRUE;
                }

                status = ScStartMarkedServices(
                             ServiceToStart,
                             NumArgs,
                             CmdArgs,
                             (WaitForGroup || fIsOOBE)
                             );

                if (status != NO_ERROR && ApiStatus == NO_ERROR) {
                    //
                    // Save first error to be returned
                    //
                    ApiStatus = status;
                }
            }
        }

        //
        // Services that do not belong in any group are considered
        // in a group that starts last.
        //
        if (ScMarkGroupStartNow(NULL)) {

            SC_LOG0(DEPEND,"------ Starting services that aren't in ServiceGroupOrder -----\n");

            //
            // Wait only for auto-start services or for the service(s)
            // we explicitly demand-start during OOBE setup
            //
            status = ScStartMarkedServices(
                         ServiceToStart,
                         NumArgs,
                         CmdArgs,
                         (! ARGUMENT_PRESENT(ServiceToStart)  || fIsOOBE)
                         );

            if (status != NO_ERROR && ApiStatus == NO_ERROR) {
                //
                // Save first error to be returned
                //
                ApiStatus = status;
            }
        }

        SC_LOG(DEPEND,"------ Done %s-starting services -----\n",
                      ARGUMENT_PRESENT(ServiceToStart) ? "demand" : "auto");

        //
        // Clear the CurrentStartRequest flags when done starting service(s).
        //
        {
            CServiceRecordExclusiveLock RLock;

            FOR_SERVICES_THAT(Service, CURRENTSTART_FLAG_IS_SET(Service))
            {
                CLEAR_CURRENTSTART_FLAG(Service);

                ScDecrementUseCountAndDelete(Service);
            }
        }
    }   // Release LLock and GLock

ReleaseLocks:

    //
    // Release the SC Manager database lock.
    //
    if (databaseLocked) {
        ScUnlockDatabase(&Lock);
    }

    LeaveCriticalSection(&ScServiceStartCriticalSection);

    return ApiStatus;
}


VOID
ScSetServiceStartRequest(
    IN  LPSERVICE_RECORD ServiceRecord,
    IN  BOOL DemandStarting
    )
/*++

Routine Description:

    This function sets the CurrentStartRequest flag of the specified service
    to TRUE and recursively sets the flag of all the services this
    service depends on.  It also initializes the StartState and StartError
    of the services that are about to be started.

Arguments:

    ServiceRecord - Supplies a pointer to the service record of service
        to be started.

    DemandStarting - Supplies a flag that is set to TRUE if we are demand-
        starting a service, FALSE if we are auto-starting services.

Return Value:

    None.

Note:
    This function expects the caller to have held the exclusive service
    database lock.  This function is called by ScStartServiceAndDependencies.

--*/
{
    SC_ASSERT(ScServiceListLock.Have());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (CURRENTSTART_FLAG_IS_SET(ServiceRecord)) {
        return;
    }

    //
    // Set the CurrentStartRequest to TRUE
    //
    SET_CURRENTSTART_FLAG(ServiceRecord);

    //
    // Update the StartState and StartError
    //
    if (ServiceRecord->StartType == SERVICE_DISABLED ||
        ! ScInHardwareProfile(ServiceRecord->ServiceName, 0)) {

        ServiceRecord->StartState = SC_START_FAIL;
        ServiceRecord->StartError = ERROR_SERVICE_DISABLED;

    }
    else if (DELETE_FLAG_IS_SET(ServiceRecord)) {

        ServiceRecord->StartState = SC_START_FAIL;
        ServiceRecord->StartError = ERROR_SERVICE_MARKED_FOR_DELETE;
    }
    else {

        if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER) {
            (void) ScGetDriverStatus(ServiceRecord, NULL);
        }

        switch (ServiceRecord->ServiceStatus.dwCurrentState) {

            case SERVICE_STOPPED:

                if (DemandStarting) {
                    //
                    // Demand starting a service.  We want to retry
                    // eventhough we have failed once before.
                    //
                    ServiceRecord->StartState = SC_NEVER_STARTED;
                }
                else {
                    //
                    // Auto-starting bunch of services at boot.  If
                    // the service was ever started before and failed,
                    // we don't want to start it again.
                    //
                    if (ServiceRecord->ServiceStatus.dwWin32ExitCode !=
                        ERROR_SERVICE_NEVER_STARTED) {
                        ServiceRecord->StartState = SC_START_FAIL;
                    }
                    else {
                        ServiceRecord->StartState = SC_NEVER_STARTED;
                    }
                }
                break;

            case SERVICE_START_PENDING:
                ServiceRecord->StartState = SC_START_PENDING;
                break;

            case SERVICE_STOP_PENDING:
            case SERVICE_PAUSED:
            case SERVICE_CONTINUE_PENDING:
            case SERVICE_PAUSE_PENDING:
            case SERVICE_RUNNING:
                ServiceRecord->StartState = SC_START_SUCCESS;
                break;

            default:
                SC_LOG1(
                    ERROR,
                    "ScSetServiceStartRequest: Unexpected dwCurrentState %0lx\n",
                    ServiceRecord->ServiceStatus.dwCurrentState
                    );

                SC_ASSERT(FALSE);
                ServiceRecord->StartState = SC_START_FAIL;
                break;
        }
    }

    //
    // Increment the reference count so that the dependency service
    // never goes away while we are in the process of starting them.
    //
    ServiceRecord->UseCount++;

    SC_LOG2(USECOUNT, "ScSetServiceStartRequest: " FORMAT_LPWSTR
            " increment USECOUNT=%lu\n", ServiceRecord->ServiceName, ServiceRecord->UseCount);

    SC_LOG2(DEPEND_DUMP, "CSR=TRUE for "
            FORMAT_LPWSTR " USECOUNT=%lu\n", ServiceRecord->ServiceName,
            ServiceRecord->UseCount);

    //
    // For each of this service's dependencies
    //
    for (LPDEPEND_RECORD Depend = ServiceRecord->StartDepend;
         Depend != NULL;
         Depend = Depend->Next)
    {
        if (Depend->DependType == TypeDependOnService) {

            if (CURRENTSTART_FLAG_IS_SET(Depend->DependService)) {

                //
                // CurrentStartRequest of a dependency service is already
                // set to TRUE.  Just go on to next dependency.
                //
                SC_LOG2(WHY, " (Will start %ws because %ws depends on it too)\n",
                        Depend->DependService->ServiceName, ServiceRecord->ServiceName);
                SC_LOG2(DEPEND_DUMP, "DependService " FORMAT_LPWSTR
                        " CSR=TRUE already, USECOUNT=%lu\n",
                        Depend->DependService->ServiceName,
                        Depend->DependService->UseCount);
            }
            else {

                SC_LOG2(WHY, " Will start %ws because %ws depends on it\n",
                        Depend->DependService->ServiceName, ServiceRecord->ServiceName);
                ScSetServiceStartRequest(Depend->DependService, DemandStarting);
            }

        }
        else if (Depend->DependType == TypeDependOnGroup) {

            //
            // This service has a dependency on a group.
            // For each service in that group
            //
            FOR_SERVICES_THAT(Service, BELONGS_TO(Service, Depend->DependGroup))
            {
                if (CURRENTSTART_FLAG_IS_SET(Service)) {

                    //
                    // CurrentStartRequest of a dependency service is
                    // already set to TRUE.  Just go on to next dependency.
                    //
                    SC_LOG3(WHY, " (Will start %ws because %ws depends on its group %ws too)\n",
                            Service->ServiceName, ServiceRecord->ServiceName,
                            Depend->DependGroup->GroupName);
                    SC_LOG3(DEPEND_DUMP, "DependGroup " FORMAT_LPWSTR
                            ", Service " FORMAT_LPWSTR
                            " CSR=TRUE already, USECOUNT=%lu\n",
                            Depend->DependGroup->GroupName,
                            Service->ServiceName, Service->UseCount);
                }
                else {

                    SC_LOG3(WHY, " Will start %ws because %ws depends on its group %ws\n",
                            Service->ServiceName, ServiceRecord->ServiceName,
                            Depend->DependGroup->GroupName);
                    ScSetServiceStartRequest(
                        Service,
                        DemandStarting
                        );
                }
            }
        }
    }

#ifndef _CAIRO_
    //
    // We have now gone through all the dependencies that are listed.  Now
    // Determine if this service needs to depend on NetLogon.  If the service
    // runs in an account, it may require NetLogon.
    //
    ScCheckNetLogonDepend(ServiceRecord,DemandStarting);
#endif // _CAIRO_
}


BOOL
ScMarkGroupStartNow(
    IN LPLOAD_ORDER_GROUP Group
    )
/*++

Routine Description:

    This function go through all services that belong in the specified
    group and mark the services that have the CurrentStartRequest flag
    set to be started immediately.

Arguments:

    Group - Supplies a pointer to the load order group to mark for
        start.

Return Value:

    Returns TRUE if at least one member of the group is marked
        START_NOW or is START_PENDING.  FALSE otherwise.  This flag
        is to indicate whether ScStartMarkedServices should be called
        to handle starting a group.

--*/
{
    BOOL ReturnFlag = FALSE;

    //
    // Mark all the CurrentStartRequest (which includes all auto-start)
    // services to be started now
    //

    // A service is marked START_NOW if it is a member of the specified
    // group.  If the specified group is NULL, mark all services that
    // do not belong to any group as well as services that belong to
    // standalone groups.
    //
    FOR_SERVICES_THAT(Service,

        ((Service->MemberOfGroup == Group) ||
         (Group == NULL && (Service->MemberOfGroup != NULL) &&
                           (Service->MemberOfGroup->RefCount != MAXULONG) ))

        &&

        CURRENTSTART_FLAG_IS_SET(Service) )
    {
        if (Service->StartState == SC_NEVER_STARTED)
        {
            Service->StartState = SC_START_NOW;
            Service->StartError = NO_ERROR;
        }

        if (Service->StartState == SC_START_NOW ||
            Service->StartState == SC_START_PENDING)
        {
            ReturnFlag = TRUE;
        }
    }

    return ReturnFlag;
}


DWORD
RI_ScGetCurrentGroupStateW(
    IN  SC_RPC_HANDLE           hSCManager,
    IN  LPWSTR                  pszGroupName,
    OUT LPDWORD                 pdwCurrentState
    )

/*++

Routine Description:

    This is obsolete, but the RPC entry point still exists.

--*/
{
    return ERROR_NOT_SUPPORTED;
}


DWORD
ScGetCurrentGroupState(
    LPLOAD_ORDER_GROUP Group
    )
{
    BOOL OneStarted = FALSE;

    FOR_SERVICES_THAT(Service, BELONGS_TO(Service, Group))
    {
        switch (Service->StartState)
        {
            case SC_NEVER_STARTED:
                //
                // Ignore services that are disabled or marked for
                // deletion.
                // (This check is really needed only when this function is
                // called from RI_ScGetCurrentGroupState.  When called
                // from ScDependenciesStarted, such services will already
                // have had their StartState set to SC_START_FAIL.)
                //
                if (Service->StartType == SERVICE_DISABLED ||
                    DELETE_FLAG_IS_SET(Service) ||
                    ! ScInHardwareProfile(Service->ServiceName, 0))
                {
                    continue;
                }
                //
                // else fall through
                //
            case SC_START_NOW:
            case SC_START_PENDING:

                SC_LOG2(DEPEND, "Group " FORMAT_LPWSTR " NOT started "
                        "because of Service " FORMAT_LPWSTR "\n",
                        Group->GroupName, Service->ServiceName);

                return GROUP_NOT_STARTED;

            case SC_START_SUCCESS:

                OneStarted = TRUE;
                break; // out of switch, not out of loop
        }
    }

    if (OneStarted)
    {
        SC_LOG1(DEPEND, "Group " FORMAT_LPWSTR " ONE started\n",
                Group->GroupName);

        return GROUP_ONE_STARTED;
    }
    else
    {
        SC_LOG1(DEPEND, "Group " FORMAT_LPWSTR " FAILED to start\n",
                Group->GroupName);

        return GROUP_START_FAIL;
    }
}


DWORD
ScStartMarkedServices(
    IN LPSERVICE_RECORD ServiceToStart OPTIONAL,
    IN DWORD NumArgs,
    IN LPSTRING_PTRSW CmdArgs,
    IN BOOL WaitForAll
    )
/*++

Routine Description:

    This function starts the services that are marked as SERVICE_START_NOW
    in the service record list.  Once the service is running, or if the
    service failed to start, the SERVICE_START_NOW bit is removed.

    If a service marked as SERVICE_START_NOW depends on a service that is
    not marked, the dependency service will also be marked SERVICE_START_NOW.

Arguments:

    ServiceToStart - Supplies a pointer to the service which is to be demand
        started via the StartService API.  If this parameter is NULL, this
        routine is called by the service controller to auto-start services
        at boot.

    NumArgs - Supplies the number of command-line arguments for the demand
        started service.  If ServiceToStart is NULL, this parameter is ignored.

    CmdArgs - Supplies an array of command arguments to the demand started
        service.  If ServiceToStart is NULL, this parameter is ignored.

    WaitForAll - Supplies a flag which if TRUE tells this function to
        wait until all start-pending services that were marked START_NOW
        to get done.

Return Value:

    Returns error if failure to reset the ScServiceChangeStateEvent.

--*/
{
    DWORD Error;

    BOOL AllStarted;
    BOOL ExistsBlockedService;
    BOOL IsBadDependencies;
    BOOL IsStartPending;

    DWORD ServiceCurrentState;

#if DBG
    DWORD LoopCount = 0;
#endif

    //
    // Reset ScServiceChangeStateEvent to non-signalled state
    //
    if (! ResetEvent(ScServiceChangeStateEvent)) {

        Error = GetLastError();

        //
        // This is a serious error--we cannot proceed.
        //
        SC_LOG1(ERROR, "Error reseting ScServiceChangeStateEvent " FORMAT_DWORD
                "\n", Error);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RESET_EVENT,
            Error
            );

        return Error;
    }


    //
    // Start all services that are marked
    //
    do {    // while (! AllStarted)
        AllStarted = TRUE;
        IsStartPending = FALSE;
        ExistsBlockedService = FALSE;
        IsBadDependencies = FALSE;

        SC_LOG1(DEPEND, "BIG LOOP COUNT " FORMAT_DWORD "\n", LoopCount++);

        //
        // Loop through every service which is currently in the database
        //
        FOR_ALL_SERVICES(Service)
        {
            //
            // Check if the current service failed to start, and if we have
            // to revert to last-known-good.  Don't revert if demand start.
            //
            if (! ARGUMENT_PRESENT(ServiceToStart)) {
                ScHandleServiceFailure(Service);
            }

            if (Service->StartState == SC_START_NOW) {

                SC_LOG1(DEPEND, FORMAT_LPWSTR " is marked START NOW\n",
                        Service->ServiceName);

                //
                // Start the current service only if all its dependencies
                // have started successfully.
                //
                if (ScDependenciesStarted(
                        Service,
                        &IsBadDependencies,
                        &AllStarted,
                        &ExistsBlockedService
                        )) {


                    //
                    // Start the service and save the start error code
                    //
                    SC_LOG1(DEPEND, "ScStartMarkedServices: Starting "
                            FORMAT_LPWSTR "\n", Service->ServiceName);

                    if (Service == ServiceToStart)
                    {
                        Service->StartError = ScStartService(
                                                  Service,
                                                  NumArgs,
                                                  CmdArgs
                                                  );
                    }
                    else
                    {
                        Service->StartError = ScStartService(
                                                  Service,
                                                  0,
                                                  NULL
                                                  );
                        //
                        // We are starting a new service so remember to loop
                        // through again to process any service which are
                        // dependent on it.  Don't have to set AllStarted
                        // to FALSE if this service is ServiceToStart because
                        // nothing is dependent on it since it is demand
                        // started.
                        //
                        AllStarted = FALSE;
                    }

                    if (Service->StartError == NO_ERROR ||
                        Service->StartError == ERROR_SERVICE_ALREADY_RUNNING)
                    {
                        //
                        // Get the state of the just started service
                        //
                        {
                            CServiceRecordSharedLock RLock;

                            ServiceCurrentState =
                                    Service->ServiceStatus.dwCurrentState;
                        }

                        switch (ServiceCurrentState) {
                            case SERVICE_START_PENDING:
                                IsStartPending = TRUE;
                                Service->StartState = SC_START_PENDING;
                                break;

                            case SERVICE_STOP_PENDING:
                            case SERVICE_PAUSED:
                            case SERVICE_CONTINUE_PENDING:
                            case SERVICE_PAUSE_PENDING:
                            case SERVICE_RUNNING:
                                Service->StartState = SC_START_SUCCESS;
                                break;

                            case SERVICE_STOPPED:
                                Service->StartState = SC_START_FAIL;
                                break;

                            default:
                                SC_LOG1(ERROR, "Unexpected service state "
                                        FORMAT_HEX_DWORD "\n",
                                       ServiceCurrentState);
                                SC_ASSERT(FALSE);
                                Service->StartState = SC_START_FAIL;

                        }
                    }
                    else {

                        //
                        // Clear ERROR_SERVICE_NEVER_STARTED in the Win32ExitCode
                        // field if service failed to start.
                        //
                        {
                            CServiceRecordExclusiveLock RLock;

                            if (Service->ServiceStatus.dwWin32ExitCode ==
                                ERROR_SERVICE_NEVER_STARTED) {
                                Service->ServiceStatus.dwWin32ExitCode =
                                        Service->StartError;
                            }
                        }

                        Service->StartState = SC_START_FAIL;

                        //
                        // For popup after user has logged on to indicate that some
                        // service started at boot has failed.
                        // We don't log the error if it is ERROR_IGNORE or if
                        // we tried to start a non-Safeboot service in Safeboot.
                        //
                        if (Service->ErrorControl != SERVICE_ERROR_IGNORE
                             &&
                            Service->StartError != ERROR_NOT_SAFEBOOT_SERVICE)
                        {
                            ScLogEvent(
                                NEVENT_SERVICE_START_FAILED,
                                Service->DisplayName,
                                Service->StartError
                                );

                            ScPopupStartFail = TRUE;
                        }
                    }
                }
            }
            else if (Service->StartState == SC_START_PENDING) {
                //
                // We need to wait for this pending service to be completely
                // started if:
                //   1) We are auto-starting services in sequence;
                //          ServiceToStart == NULL
                //   2) We are demand starting ServiceToStart and
                //          it depends on services that are currently
                //          start-pending
                //
                // We don't wait if the pending service is started by demand
                // and is unrelated in the start sequence of ServiceToStart,
                // or it is ServiceToStart itself.
                //
                if ((Service != ServiceToStart) &&
                    ScServiceToStartDependOn(ServiceToStart, Service))
                {
                    SC_LOG3(DEPEND, FORMAT_LPWSTR " is still PENDING "
                                 "(chkpt %lu, wait hint %lu ms)\n",
                            Service->ServiceName,
                            Service->ServiceStatus.dwCheckPoint,
                            Service->ServiceStatus.dwWaitHint);

                    //
                    // If a service makes some hokey state changes, it will be
                    // stuck in the SC_START_PENDING state, which means that we'll
                    // loop/wait forever.  Correct things if the service is in a
                    // "confused" state.  Note that this can happen for a service
                    // that goes from SERVICE_START_PENDING to anything other
                    // than SERVICE_RUNNING, SERVICE_STOPPED, or SERVICE_STOP_PENDING
                    // (and can then change to one of those three states without
                    // causing the state-change event to be set)
                    //

                    //
                    // Get the state of the pending service
                    //
                    {
                        CServiceRecordSharedLock RLock;

                        ServiceCurrentState = Service->ServiceStatus.dwCurrentState;
                    }

                    switch (ServiceCurrentState)
                    {
                        case SERVICE_START_PENDING:
                            IsStartPending = TRUE;
                            ExistsBlockedService = TRUE;
                            AllStarted = FALSE;
                            break;

                        case SERVICE_STOP_PENDING:
                        case SERVICE_PAUSED:
                        case SERVICE_CONTINUE_PENDING:
                        case SERVICE_PAUSE_PENDING:
                        case SERVICE_RUNNING:
                            Service->StartState = SC_START_SUCCESS;
                            break;

                        case SERVICE_STOPPED:
                            Service->StartState = SC_START_FAIL;
                            break;

                        default:
                            SC_LOG1(ERROR,
                                    "Unexpected service state %x\n",
                                    ServiceCurrentState);
                            SC_ASSERT(FALSE);
                            Service->StartState = SC_START_FAIL;
                    }
                }
            }
        } // for every service


        //
        // Only wait for services to finish starting if:
        //    the services are auto-started at boot
        //    the services are required to be running before a service that
        //        is demand-started can run.
        //
        if (IsStartPending && (ExistsBlockedService || WaitForAll))
        {
            SC_LOG0(DEPEND, "About to wait on ScServiceChangeEvent\n");

            //
            // ScServiceChangeStateEvent is signalled by RSetServiceStatus whenever
            // a service changes its state from SERVICE_START_PENDING to
            // SERVICE_RUNNING or SERVICE_STOPPED.
            //
            Error = WaitForSingleObject(
                        ScServiceChangeStateEvent,
                        SERVICE_START_TIMEOUT
                        );

            if (Error == WAIT_TIMEOUT)
            {
                //
                // Go through all services and see if any one has hung
                // while starting.
                //
                ScLookForHungServices();

            }
            else if (Error == 0)
            {
                //
                // Reset ScServiceChangeStateEvent to non-signalled state
                //
                if (!ResetEvent(ScServiceChangeStateEvent))
                {
                    Error = GetLastError();
                    //
                    // This is a serious error--we cannot proceed.
                    //
                    SC_LOG1(ERROR, "Error reseting ScServiceChangeStateEvent "
                            FORMAT_DWORD "\n", Error);

                    ScLogEvent(
                        NEVENT_CALL_TO_FUNCTION_FAILED,
                        SC_RESET_EVENT,
                        Error
                        );

                    return Error;
                }
            }
            else if (Error == 0xffffffff)
            {
                //
                // An error has occurred
                //
                SC_LOG1(ERROR,
                        "Wait for ScServiceChangeStateEvent returned %d\n",
                        GetLastError());
                SC_ASSERT(FALSE);
            }
        }
        else if ((AllStarted && ExistsBlockedService) || IsBadDependencies)
        {
            //
            // Circular dependencies!
            //
            SC_LOG0(ERROR, "Detected circular dependencies!!\n");

            SC_LOG3(ERROR,
                    "AllStarted=" FORMAT_DWORD
                    ", ExistsBlockedService=" FORMAT_DWORD
                    ", IsBadDependencies=" FORMAT_DWORD "\n",
                    (DWORD) AllStarted, (DWORD) ExistsBlockedService,
                    (DWORD) IsBadDependencies);

            if (ARGUMENT_PRESENT(ServiceToStart))
            {
                SC_LOG1(ERROR, "    Demand starting " FORMAT_LPWSTR "\n",
                        ServiceToStart->DisplayName);

                ScLogEvent(
                    NEVENT_CIRCULAR_DEPENDENCY_DEMAND,
                    ServiceToStart->DisplayName
                    );
            }
            else
            {
                SC_LOG0(ERROR, "    Auto-starting services\n");

                ScLogEvent(NEVENT_CIRCULAR_DEPENDENCY_AUTO);

                ScHandleBadDependencies();
            }

            return ERROR_CIRCULAR_DEPENDENCY;
        }
    }
    while (! AllStarted);

    return NO_ERROR;
}


VOID
ScHandleServiceFailure(
    IN LPSERVICE_RECORD Service
    )
/*++

Routine Description:

    This function checks to see if the specified service failed to start.
    If so, it clears the SERVICE_START_NOW flag, and determine if we
    have to revert to last-known-good.

Arguments:

    Service - Supplies a pointer to the service record to examine if
        the service failed to start.

Return Value:

    None.

--*/
{

    if (Service->StartState == SC_START_FAIL) {

        //
        // Revert to last-known-good only if service is auto-start and
        // fail to start due to reasons other than failure to logon.
        //
        if ((Service->ErrorControl == SERVICE_ERROR_SEVERE ||
             Service->ErrorControl == SERVICE_ERROR_CRITICAL) &&
            CURRENTSTART_FLAG_IS_SET(Service) &&
            Service->StartError != ERROR_SERVICE_LOGON_FAILED) {

            SC_LOG1(DEPEND,
                    "ScHandleServiceFailure: "
                    "About to call ScRevertToLastKnownGood for " FORMAT_LPWSTR
                    "\n", Service->ServiceName);

            (void) ScRevertToLastKnownGood();
        }
    }
}


BOOL
ScDependenciesStarted(
    IN  LPSERVICE_RECORD Service,
    OUT BOOL *IsBadDependencies,
    OUT BOOL *AllStarted,
    OUT BOOL *ExistsBlockedService
    )
/*++

Routine Description:

    This function checks to see if the dependencies of the specified
    service are all started.  If any of the dependencies has failed to
    start, the specified service will be marked as failed to start.
    If any of the dependencies is not marked as starting now (because
    they are demand-start services), they are marked to be started now.

Arguments:

    Service - Supplies a pointer to the service which we want to check
        the start dependencies.

    IsBadDependencies - Receives the value of TRUE if the service we
        depend on belongs in a group that starts after the group we
        are in.   Otherwise, FALSE is returned.

    AllStarted - Receives the value of FALSE if we have marked
        a service as failed to be started because its dependent
        didn't start.  This means that our job of starting all services is
        not done and we have to loop through an additional time to resolve
        the state of any service that is dependent on it.

    ExistsBlockedService - Receives the value of TRUE if a dependent
        is not started or not failed to start.   This indicates that
        the specified service is still blocked from starting.

Return Value:

    TRUE - if all dependencies have already been started successfully.

    FALSE - if there exists one dependency that has not started or failed
        to start.

--*/
{

    BOOL AllDependenciesStarted = TRUE;
    LPDEPEND_RECORD DependEntry;
    LPSERVICE_RECORD DependService;
    LPLOAD_ORDER_GROUP DependGroup;
    DWORD GroupState;

    for (DependEntry = Service->StartDepend;
         DependEntry != NULL;
         DependEntry = DependEntry->Next)
    {
        switch (DependEntry->DependType)
        {

        case TypeDependOnUnresolved:

            //
            // Error with service setup because it depends on a group or
            // service which does not exists
            //

            SC_LOG2(ERROR, FORMAT_LPWSTR " depends on non-existing " FORMAT_LPWSTR
                    "\n", Service->DisplayName,
                    DependEntry->DependUnresolved->Name);

            if (Service->ErrorControl != SERVICE_ERROR_IGNORE)
            {
                ScLogEvent(
                    NEVENT_SERVICE_START_FAILED_NONE,
                    Service->DisplayName,
                    DependEntry->DependUnresolved->Name
                    );
            }

            ScCleanupStartFailure(Service, ERROR_SERVICE_DEPENDENCY_DELETED);

            *AllStarted = FALSE;

            return FALSE;


        case TypeDependOnService:

            //
            // Depend on a service
            //

            DependService = DependEntry->DependService;


            //
            // If dependency service already failed to start, the current service
            // is set as failed to start.
            //
            if (DependService->StartState == SC_START_FAIL)
            {
                DWORD  dwError;

                SC_LOG3(ERROR, FORMAT_LPWSTR " depends on " FORMAT_LPWSTR
                        " which failed to start because " FORMAT_DWORD "\n",
                        Service->DisplayName, DependService->DisplayName,
                        (DependService->StartError != NO_ERROR) ?
                         DependService->StartError :
                         DependService->ServiceStatus.dwWin32ExitCode);

                if (Service->ErrorControl != SERVICE_ERROR_IGNORE
                     &&
                    DependService->StartError != ERROR_NOT_SAFEBOOT_SERVICE
                     &&
                    !SetupInProgress(NULL, NULL))
                {
                    ScLogEvent(
                        NEVENT_SERVICE_START_FAILED_II,
                        Service->DisplayName,
                        DependService->DisplayName,
                        DependService->StartError != NO_ERROR ? 
                            DependService->StartError : DependService->ServiceStatus.dwWin32ExitCode
                        );
                }

                dwError = ERROR_NOT_SAFEBOOT_SERVICE;

                //
                // Walk through the list of service dependencies and pick
                // the more appropriate error code.  Do this to avoid
                // reporting ERROR_SERVICE_DEPENDENCY_FAIL on auto-start
                // and ERROR_NOT_SAFEBOOT_SERVICE on demand-start for the
                // same service.
                //
                for (DependEntry = Service->StartDepend;
                     DependEntry != NULL;
                     DependEntry = DependEntry->Next)
                {
                    if (DependEntry->DependType == TypeDependOnService
                         &&
                        DependEntry->DependService->StartError
                            != ERROR_NOT_SAFEBOOT_SERVICE)
                    {
                        //
                        // There was a "real" start failure
                        //
                        dwError = ERROR_SERVICE_DEPENDENCY_FAIL;
                        break;
                    }
                }

                ScCleanupStartFailure(Service, dwError);
                *AllStarted = FALSE;
                return FALSE;
            }

            if (DependService->StartState == SC_NEVER_STARTED)
            {
                *IsBadDependencies = IsDependOnLaterGroup(
                                         Service->MemberOfGroup,
                                         DependService->MemberOfGroup,
                                         TypeDependOnService
                                         );

                if (*IsBadDependencies) {
                    //
                    // Circular dependency!
                    //
                    SC_LOG1(ERROR, "Circular dependency!  " FORMAT_LPWSTR
                            " depends on service in a group which starts later\n",
                            Service->DisplayName);

                    if (Service->ErrorControl != SERVICE_ERROR_IGNORE)
                    {
                        ScLogEvent(
                            NEVENT_DEPEND_ON_LATER_SERVICE,
                            Service->DisplayName);
                    }

                    ScCleanupStartFailure(Service, ERROR_CIRCULAR_DEPENDENCY);

                    return FALSE;
                }

                //
                // No circular dependency.  Mark the dependency service
                // as START_NOW.
                //
                DependService->StartState = SC_START_NOW;
                DependService->StartError = NO_ERROR;

                *AllStarted = FALSE;
            }

            //
            // Get the current state of the dependency service
            //
            if (DependService->StartState != SC_START_SUCCESS)
            {
                AllDependenciesStarted = FALSE;

                if (DependService->StartState != SC_START_FAIL)
                {
                    //
                    // The current service is still blocked.
                    //
                    *ExistsBlockedService = TRUE;
                }
            }

            break;


        case TypeDependOnGroup:

            //
            // Depend on a group
            //

            DependGroup = DependEntry->DependGroup;

            GroupState = ScGetCurrentGroupState(DependGroup);

            switch (GroupState)
            {
            case GROUP_START_FAIL:

                SC_LOG2(ERROR, FORMAT_LPWSTR " depends on failed group "
                        FORMAT_LPWSTR "\n", Service->DisplayName,
                        DependGroup->GroupName);

                if (Service->ErrorControl != SERVICE_ERROR_IGNORE
                     &&
                    !g_SafeBootEnabled
                     &&
                    !SetupInProgress(NULL, NULL))
                {
                    ScLogEvent(
                        NEVENT_SERVICE_START_FAILED_GROUP,
                        Service->DisplayName,
                        DependGroup->GroupName
                        );
                }

                ScCleanupStartFailure(Service, ERROR_SERVICE_DEPENDENCY_FAIL);

                *AllStarted = FALSE;

                return FALSE;


            case GROUP_NOT_STARTED:

                *IsBadDependencies = IsDependOnLaterGroup(
                                         Service->MemberOfGroup,
                                         DependGroup,
                                         TypeDependOnGroup
                                         );

                if (*IsBadDependencies) {
                    //
                    // Circular dependency!
                    //
                    SC_LOG1(ERROR, "Circular dependency!  " FORMAT_LPWSTR
                            " depends on a group which starts later\n",
                            Service->DisplayName);

                    if (Service->ErrorControl != SERVICE_ERROR_IGNORE)
                    {
                        ScLogEvent(
                            NEVENT_DEPEND_ON_LATER_GROUP,
                            Service->DisplayName
                            );
                    }
                    ScCleanupStartFailure(Service, ERROR_CIRCULAR_DEPENDENCY);

                    return FALSE;
                }


                //
                // No circular dependency.  Mark the services in the
                // dependency group to START_NOW.
                //
                {
                    FOR_SERVICES_THAT(Svc,
                        BELONGS_TO(Svc, DependGroup) &&
                        Svc->StartState == SC_NEVER_STARTED)
                    {
                        Svc->StartState = SC_START_NOW;
                        Svc->StartError = NO_ERROR;
                    }
                }

                AllDependenciesStarted = FALSE;
                *ExistsBlockedService = TRUE;

                break;

            default:
                //
                // Otherwise group must be started.  Nothing to do.
                //
                SC_ASSERT(GroupState == GROUP_ONE_STARTED);
                break;

            }

            break;

        }
    }

    return AllDependenciesStarted;
}


BOOL
IsDependOnLaterGroup(
    IN LPLOAD_ORDER_GROUP ServiceGroup,
    IN LPLOAD_ORDER_GROUP DependOnGroup,
    IN DEPEND_TYPE DependType
    )
{
    LPLOAD_ORDER_GROUP Group;

    switch (DependType)
    {
        case TypeDependOnService:
            if (ServiceGroup == DependOnGroup) {
                //
                // It is OK for a service to depend on another service
                // in the same group.
                //
                return FALSE;
            }
            break;

        case TypeDependOnGroup:
            if (IS_SUBGROUP(ServiceGroup, DependOnGroup)) {
                //
                // It is circular dependency if a service depends on the
                // group it itself belongs to
                //
                return TRUE;
            }
            break;

        default:
            SC_LOG(ERROR, "IsDependOnLaterGroup: got invalid DependType %lu\n",
                   DependType);
            SC_ASSERT(FALSE);
            return FALSE;
    }

    if (ServiceGroup == NULL ||
        ServiceGroup->RefCount != MAXULONG ||
        DependOnGroup == NULL ||
        DependOnGroup->RefCount != MAXULONG) {

        //
        // Service we are starting belongs to a standalone group,
        // or service or group we depend on is standalone.
        //
        return FALSE;
    }

    //
    // Both the service's group and the depended on group are in the
    // load order group list.
    // The depended on group must not occur after the service's group.
    // TDI GROUP SPECIAL:  Also, if the depended on group is the TDI
    // group, then there is an implicit dependency on the PNP_TDI group,
    // so that must not occur after the service's group either.
    //
    for (Group = ServiceGroup->Next;
         Group != NULL;
         Group = Group->Next)
    {
        if (IS_SUBGROUP(Group, DependOnGroup)) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
ScCleanupStartFailure(
    LPSERVICE_RECORD Service,
    DWORD StartError
    )
{
    Service->StartState = SC_START_FAIL;
    Service->StartError = StartError;

    //
    // Clear ERROR_SERVICE_NEVER_STARTED in the Win32ExitCode field if
    // service failed to start.
    //
    CServiceRecordExclusiveLock RLock;

    if (Service->ServiceStatus.dwWin32ExitCode ==
        ERROR_SERVICE_NEVER_STARTED) {
        Service->ServiceStatus.dwWin32ExitCode = StartError;
    }

    //
    // For popup after user has logged on to indicate that some
    // service started at boot has failed.
    //
    if (Service->ErrorControl != SERVICE_ERROR_IGNORE) {
        ScPopupStartFail = TRUE;
    }

}


VOID
ScLookForHungServices(
    VOID
    )
/*++

Routine Description:

    This function loops through all services and queries the status
    of each service that is start pending.  It waits for the service to
    show signs of progress in starting by waiting for the wait-hint
    amount of time (in millisecs), and if the service is still start
    pending and checkpoint has not incremented, the service's exitcode
    is set to ERROR_SERVICE_START_HANG.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status;
    SERVICE_STATUS CurrentServiceStatus;
    STATUS_UNION   ServiceStatus;
    DWORD   OldCheckPoint;


    FOR_SERVICES_THAT(Service, Service->StartState == SC_START_PENDING)
    {
        ServiceStatus.Regular = &CurrentServiceStatus;

        status = ScQueryServiceStatus(
                     Service,
                     ServiceStatus,
                     FALSE
                     );

        if ((status == NO_ERROR) &&
            (CurrentServiceStatus.dwCurrentState == SERVICE_START_PENDING)) {

#define SC_POLL_FACTOR      10
#define SC_MAX_SLEEP_TIME   10000

            DWORD   SleepTime = 1;
            DWORD   i;
            DWORD   NumIterations;


            OldCheckPoint = CurrentServiceStatus.dwCheckPoint;

            //
            // Set up for the loop where we will poll the service status.
            // The maximum sleep time during this polling operation will
            // be 10 seconds.
            //

            //
            // If the wait hint is greater than 100 seconds, then
            // we want to modify the number of iterations through the
            // loop so that we only sleep for the MAX_SLEEP_TIME.
            //
            // If the wait hint is less than that, then we change the
            // sleep time to be less than 10 seconds, so that we go
            // through the loop a max of 10 times.
            //
            if (CurrentServiceStatus.dwWaitHint > 100000) {
                NumIterations = CurrentServiceStatus.dwWaitHint / SC_MAX_SLEEP_TIME;
                SleepTime = SC_MAX_SLEEP_TIME;
            }
            else {
                NumIterations = SC_POLL_FACTOR;
                if (CurrentServiceStatus.dwWaitHint > SC_POLL_FACTOR) {
                    SleepTime = CurrentServiceStatus.dwWaitHint / SC_POLL_FACTOR;
                }
            }

            for (i = 0; i < NumIterations; i++) {

                //
                // Wait a while for the checkpoint to increment, or
                // service to be out of start-pending state.
                //
                Sleep(SleepTime);

                status = ScQueryServiceStatus(
                             Service,
                             ServiceStatus,
                             FALSE
                             );

                if (status == NO_ERROR) {

                    if (CurrentServiceStatus.dwCurrentState != SERVICE_START_PENDING ||
                        (CurrentServiceStatus.dwCurrentState == SERVICE_START_PENDING &&
                         OldCheckPoint < CurrentServiceStatus.dwCheckPoint)) {

                        goto NextService;
                    }
                }

                SC_LOG2(DEPEND, "   Wait %ld on %ws for response\n", i + 1,
                        Service->ServiceName);
            }

            if ((status == NO_ERROR) &&
                (CurrentServiceStatus.dwCurrentState == SERVICE_START_PENDING) &&
                (OldCheckPoint == CurrentServiceStatus.dwCheckPoint)) {

                SC_LOG2(ERROR, "%ws hung on starting (wait hint %lu ms)\n",
                        Service->ServiceName,
                        CurrentServiceStatus.dwWaitHint);

                if (Service->ErrorControl != SERVICE_ERROR_IGNORE)
                {
                    ScLogEvent(
                        NEVENT_SERVICE_START_HUNG,
                        Service->DisplayName
                        );
                }

                ScCleanupStartFailure(Service, ERROR_SERVICE_START_HANG);

            }

        }

        if (status != NO_ERROR) {
            SC_LOG2(ERROR, "ScLookForHungService: ScQueryServiceStatus "
                    FORMAT_LPWSTR " failed " FORMAT_DWORD "\n",
                    Service->ServiceName, status);
            Service->StartState = SC_START_FAIL;
            Service->StartError = ERROR_GEN_FAILURE;
        }

NextService:
        ;
    }

}


VOID
ScHandleBadDependencies(
    VOID
    )
/*++

Routine Description:

    This function is called when a circular dependency is detected.

Arguments:

    None.

Return Value:

    None.

--*/
{

    FOR_SERVICES_THAT(Service,
        (Service->StartState == SC_START_NOW) &&
        (Service->ErrorControl == SERVICE_ERROR_SEVERE ||
         Service->ErrorControl == SERVICE_ERROR_CRITICAL) )
    {
        SC_LOG1(ERROR, "ScHandleBadDependencies: "
                "About to call ScRevertToLastKnownGood for "
                FORMAT_LPWSTR "\n", Service->DisplayName);

        ScLogEvent(
            NEVENT_SEVERE_SERVICE_FAILED,
            Service->DisplayName
            );

        ScRevertToLastKnownGood();
    }
}


BOOL
ScServiceToStartDependOn(
    LPSERVICE_RECORD ServiceToStart OPTIONAL,
    LPSERVICE_RECORD StartPendingService
    )
/*++

Routine Description:

    This function is called by ScStartMarkedServices (BIG LOOP) to determine
    if we have to wait for a pending service to complete.

    If ServiceToStart == NULL, we are auto-starting service and we always
    want to wait.

    If ServiceToStart is not NULL, we are demand starting a service.
    We have to wait if ServiceToStart depends on the StartPendingService.


Arguments:

    ServiceToStart - Supplies the service record pointer of the service
        being demand started.

    StartPendingService - Supplies the service record pointer of the
        service that is currently start pending.


Return Value:

    TRUE - If ServiceToStart depends on StartPendingService or
           ServiceToStart == NULL.

    FALSE - Otherwise.

--*/
{
    if (! ARGUMENT_PRESENT(ServiceToStart)) {
        return TRUE;
    }

    if (ServiceToStart->StartState == SC_START_FAIL) {
        return FALSE;
    }

    if (CURRENTSTART_FLAG_IS_SET(StartPendingService)) {
        SC_LOG2(DEPEND_DUMP, "Service %ws directly/indirectly depends on pending service %ws\n",
                ServiceToStart->ServiceName,
                StartPendingService->ServiceName);

        return TRUE;
    }

    SC_LOG(DEPEND_DUMP, "ScServiceToStartDependOn: Won't wait for pending "
           FORMAT_LPWSTR "\n", StartPendingService->ServiceName);

    return FALSE;
}


VOID
ScNotifyChangeState(
    VOID
    )
/*++

Routine Description:

    This function is called by RSetServiceStatus which a service state
    changes from start-pending to running or stopped.  This will
    notify the thread processing start dependencies that we can
    proceed with starting up services that depend on the one that
    called RSetServiceStatus.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (! SetEvent(ScServiceChangeStateEvent)) {

        SC_LOG1(ERROR, "ScNotifyChangeState: SetEvent error " FORMAT_DWORD "\n",
               GetLastError());
        SC_ASSERT(FALSE);
    }
}


BOOL
ScDependentsStopped(
    IN LPSERVICE_RECORD ServiceToStop
    )
/*++

Routine Description:

    This function checks to see if any service which depends on the
    specified service is active.  If so, it returns FALSE, otherwise
    if no service depends on the specified service, or all services
    which depend on the specified service is stopped, it returns
    TRUE.

    A service which is not in SERVICE_STOPPED is considered active.

Arguments:

    ServiceToStop - Supplies a pointer to the service to see if other
        active services depend on it.

Return Value:

    TRUE - if all services which depend on ServiceToStop are stopped,
        or there are no services which depend on ServiceToStop.

    FALSE - if one or more of the services which depend on ServiceToStop
        is active.

Note:
    The database lock must be acquired with share access before calling
    this routine.

--*/
{
    SC_ASSERT(ScServiceRecordLock.Have());

    LPDEPEND_RECORD StopDepend;

    for (StopDepend = ServiceToStop->StopDepend;
         StopDepend != NULL;
         StopDepend = StopDepend->Next)
    {
        if (StopDepend->DependService->ServiceStatus.dwCurrentState
            != SERVICE_STOPPED) {

            SC_LOG1(DEPEND, FORMAT_LPWSTR " is still ACTIVE\n",
                    StopDepend->DependService->ServiceName);

            return FALSE;
        }

        SC_LOG1(DEPEND, FORMAT_LPWSTR " is STOPPED\n",
                StopDepend->DependService->ServiceName);
    }

    return TRUE;
}


VOID
ScEnumDependents(
    IN     LPSERVICE_RECORD ServiceRecord,
    IN     LPENUM_SERVICE_STATUS_WOW64 EnumBuffer,
    IN     DWORD RequestedState,
    IN OUT LPDWORD EntriesRead,
    IN OUT LPDWORD BytesNeeded,
    IN OUT LPENUM_SERVICE_STATUS_WOW64 *EnumRecord,
    IN OUT LPWSTR *EndOfVariableData,
    IN OUT LPDWORD Status
    )
/*++

Routine Description:

    This function enumerates the stop depend list of the specified
    service in the order which the dependents should be stopped.

Arguments:

    ServiceRecord - Supplies a pointer to the service whose dependents
        are to be enumerated.

    EnumBuffer - Supplies a pointer to the first byte of the enum
        buffer we are writing to.  This is for duplicate entry checking.

    RequestedState - Supplies one or the bitwise or of SERVICE_ACTIVE
        and SERVICE_INACTIVE.

    BytesNeeded - Supplies a pointer to a variable to receive the
        running sum of bytes needed to enumerate all the entries.

    EnumRecord - Supplies a pointer into the next location in the
        output buffer to receive the next entry.  The pointer is
        updated on return.

    EndOfVariableData - Supplies a pointer past the last available
        byte in the output buffer so that variable length data
        can be written from the end of the buffer.  This pointer is
        updated on return.

    Status - Receives ERROR_MORE_DATA if dependent services does not
        entirely fit in the output buffer.  It should be initialized
        to NO_ERROR this function is called.


Return Value:

    None.

Note:
    The database lock must be acquired with share access before calling
    this routine.

--*/
{
    SC_ASSERT(ScServiceRecordLock.Have());

    LPDEPEND_RECORD StopDepend;

    for (StopDepend = ServiceRecord->StopDepend;
         StopDepend != NULL;
         StopDepend = StopDepend->Next)
    {
        if (StopDepend->DependService->StopDepend != NULL) {

            //
            // Stop dependent also have other services that depends on
            // it.  Recursively call this routine to enumerate its
            // dependents.
            //
            ScEnumDependents(
                StopDepend->DependService,
                EnumBuffer,
                RequestedState,
                EntriesRead,
                BytesNeeded,
                EnumRecord,
                EndOfVariableData,
                Status
                );

        }

        if (
            ((StopDepend->DependService->ServiceStatus.dwCurrentState
              != SERVICE_STOPPED) &&
             (RequestedState & SERVICE_ACTIVE))

              ||

            ((StopDepend->DependService->ServiceStatus.dwCurrentState
              == SERVICE_STOPPED) &&
             (RequestedState & SERVICE_INACTIVE))
           )   {

            SC_LOG1(DEPEND, "Enumerating dependent " FORMAT_LPWSTR "\n",
                    StopDepend->DependService->ServiceName);


            if (! ScFoundDuplicateDependent(
                       StopDepend->DependService->ServiceName,
                       EnumBuffer,
                       *EnumRecord
                       )) {

                *BytesNeeded += (sizeof(ENUM_SERVICE_STATUS_WOW64) +
                    (DWORD) WCSSIZE(StopDepend->DependService->ServiceName) +
                    (DWORD) WCSSIZE(StopDepend->DependService->DisplayName));

                if (*Status == NO_ERROR) {

                    if (((DWORD_PTR) *EnumRecord + sizeof(ENUM_SERVICE_STATUS_WOW64)) >=
                         (DWORD_PTR) *EndOfVariableData) {
                        *Status = ERROR_MORE_DATA;
                    }
                    else {

                        //
                        // Write the entry into output buffer
                        //
                        memcpy(
                            (PVOID) &((*EnumRecord)->ServiceStatus),
                            (PVOID) &(StopDepend->DependService->ServiceStatus),
                            sizeof(SERVICE_STATUS)
                            );

                        //
                        // Copy the ServiceName string data
                        //
                        if (! ScCopyStringToBufferW(
                                  StopDepend->DependService->ServiceName,
                                  (DWORD) wcslen(StopDepend->DependService->ServiceName),
                                  (LPWSTR) (*EnumRecord + 1),
                                  EndOfVariableData,
                                  (LPWSTR *) &((*EnumRecord)->dwServiceNameOffset),
                                  (LPBYTE) EnumBuffer))
                        {
                            *Status = ERROR_MORE_DATA;
                        }

                        //
                        // Copy the DisplayName string data
                        //
                        if (! ScCopyStringToBufferW(
                                  StopDepend->DependService->DisplayName,
                                  (DWORD) wcslen(StopDepend->DependService->DisplayName),
                                  (LPWSTR) ((*EnumRecord) + 1),
                                  EndOfVariableData,
                                  (LPWSTR *) &((*EnumRecord)->dwDisplayNameOffset),
                                  (LPBYTE) EnumBuffer))
                        {
                            *Status = ERROR_MORE_DATA;
                        }

                    }

                    if (*Status == NO_ERROR) {
                        (*EnumRecord)++;
                        (*EntriesRead)++;
                        SC_LOG0(DEPEND, "  Written into buffer successfully\n");
                    }
                    else {
                        SC_LOG0(DEPEND, "  Failed to fit into buffer\n");
                    }

                } // *Status is still NO_ERROR

            } // non-duplicate entry
        }
    }

}


BOOL
ScFoundDuplicateDependent(
    IN LPWSTR ServiceName,
    IN LPENUM_SERVICE_STATUS_WOW64 EnumBuffer,
    IN LPENUM_SERVICE_STATUS_WOW64 BufferEnd
    )
/*++

Routine Description:

    This function looks at service entries written to EnumBuffer for
    any service names that matches the specified ServiceName.

Arguments:

    ServiceName - Supplies the name of the service to look for.

    EnumBuffer - Supplies a pointer to the buffer to look for matching
        service name.

    BufferEnd - Supplies a pointer to the end of buffer.

Return Value:

    TRUE - if found a matching service name.

    FALSE - no matching service name found.

--*/
{
    LPENUM_SERVICE_STATUS_WOW64 EnumEntry;

    for (EnumEntry = EnumBuffer;
         EnumEntry < BufferEnd;
         EnumEntry++)
    {
        if (_wcsicmp((LPWSTR) ((LPBYTE) EnumBuffer + EnumEntry->dwServiceNameOffset),
                     ServiceName) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


#ifndef _CAIRO_

VOID
ScCheckNetLogonDepend(
    LPSERVICE_RECORD    ServiceRecord,
    BOOL                DemandStarting
    )

/*++

Routine Description:

    If the current service is running in a remote account or if we are
    running on an Advanced Server (NtProductLanManNt), then this routine
    makes a (soft) dependency on Netlogon.  This dependency is not stored
    in the registry.

    Note that all services with account names that are UPNs will require
    the dependency on Netlogon.

Arguments:

    ServiceRecord - Pointer to the service record that is to be checked.

    DemandStarting - boolean that indicates if we are demand starting or
        auto starting.

Return Value:

    none - If something fails within this function, we will just press on
        since there isn't much we can do about it.

--*/
{
    DWORD   status;
    HKEY    ServiceNameKey;
    LPWSTR  DomainName;
    BOOL    bRemoteAccount=TRUE;
    LPSERVICE_RECORD    pNetLogonSR;

    //
    // Open the service name key.
    //
    status = ScOpenServiceConfigKey(
                 ServiceRecord->ServiceName,
                 KEY_READ,
                 FALSE,               // Create if missing
                 &ServiceNameKey
                 );

    if (status != NO_ERROR)
    {
        return;
    }

    //
    // Read the account name from the registry.
    //
    status = ScReadStartName(
                 ServiceNameKey,
                 &DomainName
                 );

    if (status != NO_ERROR || DomainName == NULL)
    {
        ScRegCloseKey(ServiceNameKey);
        return;
    }

    ScRegCloseKey(ServiceNameKey);

    if (_wcsicmp(DomainName, SC_LOCAL_SYSTEM_USER_NAME) == 0)
    {
        //
        // LocalSystem account, we don't need netlogon.
        //
        SC_LOG1(TRACE,"ScCheckNetLogonDepend: %ws Service is LocalSystem!\n",
            ServiceRecord->ServiceName);
        LocalFree(DomainName);
        return;
    }
    else if (wcsncmp(DomainName, L".\\", 2) == 0)
    {
        bRemoteAccount = FALSE;
        SC_LOG1(TRACE,"ScCheckNetLogonDepend: %ws Service has a local domain name\n",
            ServiceRecord->ServiceName);
    }
    else
    {
        //
        // Check for local-only accounts (domain name of NT AUTHORITY).  Note
        // that the domain name may be quoted.
        //
        LPWSTR lpTempDomain = DomainName;

        if (*lpTempDomain == '"')
        {
            lpTempDomain++;
        }

        if (_wcsnicmp(lpTempDomain,
                      SC_LOCAL_NTAUTH_NAME,
                      sizeof(SC_LOCAL_NTAUTH_NAME) / sizeof (WCHAR) - 1) == 0)
        {
            SC_LOG1(TRACE,
                    "ScCheckNetLogonDepend: %ws service is LocalService/NetworkService\n",
                    ServiceRecord->ServiceName);
            LocalFree(DomainName);
            return;
        }
    }

    LocalFree(DomainName);


    //
    // We know if it runs in a remote account or not.
    // Now we should check the product type.  If it is an
    // advanced server, or runs in an remote account, then
    // we need to start NetLogon.
    //
    if ((ScGlobalProductType == NtProductLanManNt) || (bRemoteAccount)) {
        //
        // Get the service record for NetLogon.
        //
        status = ScGetNamedServiceRecord(L"NetLogon", &pNetLogonSR);
        if (status != NO_ERROR) {
            return;
        }

        //
        // If it is already marked to start, then we don't
        // have to do anything right now.  If it isn't then
        // we should SetServiceStartRequest and create a
        // dependency.
        //
        if (CURRENTSTART_FLAG_IS_SET(pNetLogonSR)) {

            //
            // CurrentStartRequest of a dependency service is already
            // set to TRUE.  Just go on to next dependency.
            //
            SC_LOG2(DEPEND_DUMP, "DependService " FORMAT_LPWSTR
                    " CSR=TRUE already, USECOUNT=%lu\n",
                    pNetLogonSR->ServiceName,
                    pNetLogonSR->UseCount);
        }
        else {
            LPDEPEND_RECORD pDependRecord;

            SC_LOG(WHY, " Will start NetLogon because %ws runs in a remote account, or this is a server\n",
                    ServiceRecord->ServiceName);

            ScSetServiceStartRequest(pNetLogonSR,DemandStarting);

            //
            // Add the dependency to the service record and mark it as
            // temporary.
            //
            status = ScCreateDependRecord(TRUE,ServiceRecord,&pDependRecord);
            if (status != NO_ERROR) {
                return;
            }
            pDependRecord->DependType = TypeDependOnService;
            pDependRecord->DependService = pNetLogonSR;
        }
    }
    return;
}
#endif // _CAIRO_


BOOL
ScInHardwareProfile(
    IN  LPCWSTR ServiceName,
    IN  ULONG   GetDeviceListFlags
    )
/*++

Routine Description:

    This function checks whether a specified service is enabled in the
    current hardware profile.

Arguments:

    Service - Specifies the service of interest.

    GetDeviceListFlags - Specifies any special flags to be passed to
                         PNP_GetDeviceList.  The CM_GETIDLIST_DONOTGENERATE
                         flag indicates that a legacy device instance should
                         not be generated for the service.

Return Value:

    TRUE - if the service is enabled in the current hardware profile, or
        if this cannot be determined.

    FALSE - if the service is disabled in the current hardware profile.

--*/
{
    CONFIGRET   Status;
    BOOL        RetStatus;
    WCHAR       Buffer[200]; // default buffer on stack
    WCHAR *     pBuffer = Buffer;
    ULONG       cchLen;
    LPCWSTR     pDeviceID;

    //
    // Allocate a buffer for the list of device instances associated with
    // this service
    //
    Status = PNP_GetDeviceListSize(
                    NULL,                           // hBinding
                    ServiceName,                    // pszFilter
                    &cchLen,                        // list length in wchars
                    CM_GETIDLIST_FILTER_SERVICE);   // filter is a service name

    if (Status != CR_SUCCESS)
    {
        SC_LOG2(WARNING, "PNP_GetDeviceListSize failed %#lx for service %ws\n",
                       Status, ServiceName);
        return TRUE;
    }

    if (cchLen > LENGTH(Buffer))
    {
        SC_LOG2(DEPEND, "PNP_GetDeviceListSize wants a %lu-character buffer for service %ws\n",
                        cchLen, ServiceName);

        pBuffer = (WCHAR *) LocalAlloc(0, cchLen * sizeof(WCHAR));
        if (pBuffer == NULL)
        {
            SC_LOG(ERROR, "Couldn't allocate buffer for device list, error %lu\n",
                          GetLastError());
            return TRUE;
        }
    }
    else
    {
        cchLen = LENGTH(Buffer);
    }

    //
    // Initialize parameters for PNP_GetDeviceList, the same way as is
    // normally done in the client side of the API
    //
    pBuffer[0] = L'\0';

    //
    // Get the list of device instances that are associated with this service
    //
    // (For legacy services, the PNP manager makes up an artificial device
    // instance; but for PNP-aware services, we could get an empty device list.)
    //
    Status = PNP_GetDeviceList(
                    NULL,                           // binding handle
                    ServiceName,                    // pszFilter
                    pBuffer,                        // buffer for device list
                    &cchLen,                        // buffer length in wchars
                    CM_GETIDLIST_FILTER_SERVICE |   // filter is a service name
                    GetDeviceListFlags              // OR with passed in flag
                    );

    if (Status != CR_SUCCESS)
    {
        SC_LOG2(ERROR, "PNP_GetDeviceList failed %#lx for service %ws\n",
                       Status, ServiceName);
        RetStatus = TRUE;
        goto CleanExit;
    }

    //
    // Get each device instance's config flags.  The service is enabled in
    // the current hardware profile if at least one of its devices is enabled.
    //
    for (pDeviceID = pBuffer;
         pDeviceID[0] != L'\0';
         pDeviceID += wcslen(pDeviceID) + 1)
    {
        ULONG ConfigFlags;

        Status = PNP_HwProfFlags(
                        NULL,                       // binding handle
                        PNP_GET_HWPROFFLAGS,        // action: get, not set
                        pDeviceID,
                        0,                          // which profile: current one
                        &ConfigFlags,
                        NULL,
                        NULL,
                        0,
                        0                           // flags, MBZ
                        );

        if (Status == CR_SUCCESS)
        {
            if (!(ConfigFlags & (CSCONFIGFLAG_DISABLED |
                                 CSCONFIGFLAG_DO_NOT_CREATE)))
            {
                //
                // The device is enabled, so the service is enabled
                //
                RetStatus = TRUE;
                goto CleanExit;
            }
        }
        else
        {
            SC_LOG2(ERROR, "PNP_HwProfFlags failed %#lx for device %ws\n",
                           Status, pDeviceID);
        }
    }

    RetStatus = FALSE;
    SC_LOG(DEPEND, "The %ws service has no enabled device instances\n"
                   "          in this hardware profile.  Attempts to start\n"
                   "          it will result in ERROR_SERVICE_DISABLED.\n",
                   ServiceName);

CleanExit:

    if (pBuffer != Buffer)
    {
        LocalFree(pBuffer);
    }

    return RetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\groupman.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    groupman.cxx

Abstract:

    Contains code for the Group List Database manager.  This includes
    all the linked list routines.  This file contains the following
    functions:
        ScGetOrderGroupList
        ScGetStandaloneGroupList
        ScGetUnresolvedDependList
        ScGetNamedGroupRecord

        ScCreateOrderGroupEntry
        ScAllocateGroupEntry
        ScCreateGroupMembership
        ScDeleteGroupMembership
        ScCreateRegistryGroupPointer
        ScDeleteRegistryGroupPointer
        ScCreateStandaloneGroup
        ScDeleteStandaloneGroup

        ScGenerateDependencies
        ScSetDependencyPointers
        ScResolveDependencyToService
        ScCreateDependencies
        ScCreateUnresolvedDepend
        ScDeleteUnresolvedDepend
        ScCreateDependRecord
        ScDeleteStartDependencies
        ScDeleteStopDependencies
        ScSetServiceDependList
        ScGetUniqueTag
        ScCompareVector

        ScGetDependencySize
        ScGetDependencyString

        ScDumpGroups
        ScDumpServiceDependencies

Author:

    Dan Lafferty (danl)     04-Feb-1992

Environment:

    User Mode -Win32

Revision History:

    22-Oct-1993     danl
        Created by splitting these functions out of dataman.c because it was
        getting too large.

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <stdlib.h>      // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <ntrpcp.h>     // MIDL_user_allocate
#include <control.h>    // SendControl
#include "scconfig.h"   // ScGenerateServiceDB,ScInitSecurityProcess
#include "scsec.h"      // ScCreateScServiceObject
#include "account.h"    // ScRemoveAccount
#include <sclib.h>      // ScImagePathsMatch().
#include "bootcfg.h"    // ScDeleteRegTree().
#include <strarray.h>   // ScWStrArraySize

//
// Defines
//

// Names of specially treated groups
#define SC_GROUPNAME_TDI        L"TDI"
#define SC_GROUPNAME_PNP_TDI    L"PNP_TDI"

// A value that will not match any real pointer to a load order group
#define SC_INVALID_GROUP    ((LPLOAD_ORDER_GROUP)(DWORD_PTR) 0xFFFFFFFF)


//
// External Globals
//

    //
    // TDI GROUP SPECIAL:  The groups named TDI and PNP_TDI are treated
    // specially during dependency handling.  This is done by remembering a
    // pointer to each of those groups, if it occurs in the group order list,
    // and checking against the remembered pointers during dependency
    // handling.
    //

    LPLOAD_ORDER_GROUP  ScGlobalTDIGroup     = SC_INVALID_GROUP;
    LPLOAD_ORDER_GROUP  ScGlobalPNP_TDIGroup = SC_INVALID_GROUP;

//
//  Static Globals
//

    //
    // These are the linked list heads for each of the databases
    // that are maintained.
    //

    LOAD_ORDER_GROUP  OrderGroupList;       // empty header for doubly linked
    LOAD_ORDER_GROUP  StandaloneGroupList;  // empty header for doubly linked

    UNRESOLVED_DEPEND UnresolvedDependList; // empty header for doubly linked

//
// Local Function Prototypes
//

DWORD
ScAllocateOrderGroupEntry(
    OUT LPLOAD_ORDER_GROUP *NewGroup,
    IN  LPWSTR GroupName
    );

DWORD
ScCreateStandaloneGroup(
    IN  LPWSTR GroupName,
    OUT LPLOAD_ORDER_GROUP *GroupPointer
    );

VOID
ScDeleteStandaloneGroup(
    IN LPLOAD_ORDER_GROUP Group
    );

VOID
ScRememberSpecialGroup(
    IN  LPLOAD_ORDER_GROUP Group
    );

VOID
ScForgetSpecialGroup(
    IN  LPLOAD_ORDER_GROUP Group
    );

DWORD
ScCreateUnresolvedDepend(
   IN  LPWSTR Name,
   OUT LPUNRESOLVED_DEPEND *Unresolved
   );

VOID
ScDeleteUnresolvedDepend(
    IN OUT LPUNRESOLVED_DEPEND *Unresolved
    );

DWORD
ScSetServiceDependList(
    LPDEPEND_RECORD Start,
    LPSERVICE_RECORD ServiceRecord,
    PVOID DependOnRecord,
    DEPEND_TYPE DependOnType
    );

VOID
ScCompareVector(
    IN     LPDWORD TagArray,
    IN     DWORD TagArrayLength,
    IN OUT LPDWORD ReturnTagPtr
    );



//****************************************************************************/
// Miscellaneous Short Functions
//****************************************************************************/
LPLOAD_ORDER_GROUP
ScGetOrderGroupList(
    VOID
    )
{
    SC_ASSERT(ScGroupListLock.Have());
    return OrderGroupList.Next;
}

LPLOAD_ORDER_GROUP
ScGetStandaloneGroupList(
    VOID
    )
{
    SC_ASSERT(ScGroupListLock.Have());
    return StandaloneGroupList.Next;
}

LPUNRESOLVED_DEPEND
ScGetUnresolvedDependList(
    VOID
    )
{
    SC_ASSERT(ScGroupListLock.Have());
    return UnresolvedDependList.Next;
}

VOID
ScInitGroupDatabase(VOID)

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    OrderGroupList.Next = NULL;
    OrderGroupList.Prev = NULL;

    StandaloneGroupList.Next = NULL;
    StandaloneGroupList.Prev = NULL;

    UnresolvedDependList.Next = NULL;
    UnresolvedDependList.Prev = NULL;

}

VOID
ScEndGroupDatabase(VOID)

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    LPLOAD_ORDER_GROUP Group;
    LPLOAD_ORDER_GROUP Grp;

    SC_ASSERT(ScGroupListLock.HaveExclusive());

    Group = OrderGroupList.Next;

    while (Group != NULL) {

        Grp = Group;
        Group = Group->Next;

        REMOVE_FROM_LIST(Grp);
        LocalFree(Grp);
    }


}


DWORD
ScCreateOrderGroupEntry(
    IN  LPWSTR GroupName
    )
/*++

Routine Description:

    This function adds a group entry into the end of the load order group
    list.

Arguments:

    GroupName - Supplies the name of the load group.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a new
        group entry failed.

Note:

    The GroupListLock must be held exclusively prior to calling this function.

--*/
{
    DWORD status;
    LPLOAD_ORDER_GROUP NewGroup;
    LPLOAD_ORDER_GROUP GroupListPointer;

    SC_ASSERT(ScGroupListLock.HaveExclusive());

    if ((status = ScAllocateOrderGroupEntry(
                      &NewGroup,
                      GroupName
                      )) != NO_ERROR) {
        return status;
    }

    GroupListPointer = &OrderGroupList;

    //
    // Add the group entry to the group list at the end.
    //
    ADD_TO_LIST(GroupListPointer, NewGroup);

    SC_LOG(CONFIG, "ScCreateOrderGroupEntry: Added %ws to GroupList\n", GroupName);

    return NO_ERROR;
}


DWORD
ScAllocateOrderGroupEntry(
    OUT LPLOAD_ORDER_GROUP *NewGroup,
    IN  LPWSTR GroupName
    )
{

    //
    // Allocate memory for the new group.
    //
    *NewGroup = (LPLOAD_ORDER_GROUP)LocalAlloc(
                    LMEM_ZEROINIT,
                    WCSSIZE(GroupName) + sizeof(LOAD_ORDER_GROUP)
                    );

    if (*NewGroup == NULL) {
        SC_LOG(ERROR,"ScAllocateOrderGroupEntry: LocalAlloc failure %ld\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Save away the GroupName
    //
    (*NewGroup)->GroupName = (LPWSTR) ((LPBYTE) (*NewGroup) + sizeof(LOAD_ORDER_GROUP));
    wcscpy((*NewGroup)->GroupName, GroupName);

    ScRememberSpecialGroup(*NewGroup);

    //
    // Set the RefCount field to 0xffffffff so that we can differentiate an
    // order group from a standalone group.  This field actually indicates
    // the number of members in a group and dependency references to it if
    // the group is standalone so that we can delete the standalone group
    // when it goes to 0.
    //
    (*NewGroup)->RefCount = MAXULONG;

    return NO_ERROR;
}


DWORD
ScCreateGroupMembership(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Group OPTIONAL
    )
/*++

Routine Description:

    This function assigns the load order group membership information
    of the service to its specified service record.  If the service
    belongs to a group in OrderGroupList, a pointer to the group in the load
    order group list is saved.  If the service belongs to a group which
    is not in the load order group list, the name of the group is saved
    in the service record in case the group gets added to the load order
    group list later.  If Group is not specified, no group membership
    information is saved.

Arguments:

    ServiceRecord - Receives the group membership information in this service
        record.

    Group - Supplies the string which contains the name of the group.  This
        is the raw string read from the registry which may contain blank,
        tab or newline characters which we should ignore.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a group name
        failed.

Note:

    This routine assumes that the database lock is already held.  It is
    called by ScAddConfigInfoServiceRecord.

    It also assumes that the caller has exclusive access to the group
    list lock.

--*/
{
    DWORD status;
    LPWSTR GroupPtr = Group;
    LPWSTR GroupName;
    PLOAD_ORDER_GROUP GroupEntry = ScGetOrderGroupList();

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    // Extract the group name from the string read in from the registry.
    //
    if ((! ARGUMENT_PRESENT(GroupPtr)) || (! ScGetToken(&GroupPtr, &GroupName))) {
        ServiceRecord->MemberOfGroup = (PLOAD_ORDER_GROUP) NULL;
        return NO_ERROR;
    }

    //
    // Search for matching group name in load order list
    //
    while (GroupEntry != NULL) {
        if (_wcsicmp(GroupEntry->GroupName, GroupName) == 0) {
            ServiceRecord->MemberOfGroup = GroupEntry;
            return NO_ERROR;
        }
        GroupEntry = GroupEntry->Next;
    }

    //
    // Group name not NULL, and not found in load order group list.
    // Group is a standalone group.
    //
    status = ScCreateStandaloneGroup(
                 GroupName,
                 &(ServiceRecord->MemberOfGroup)
                 );

    if (status != NO_ERROR) {
        return status;
    }

    return NO_ERROR;
}


VOID
ScDeleteGroupMembership(
    IN OUT PSERVICE_RECORD ServiceRecord
    )
/*++

Routine Description:

    This function deletes any memory allocated for group membership
    association.

Arguments:

    ServiceRecord - Supplies the group membership information in this
        service record.

Return Value:

    None.

Note:

    This routine assumes that the database lock is already held.  It is
    called by ScAddConfigInfoServiceRecord and ScDecrementUseCountAndDelete.

    It also assumes that the group list lock is held exclusively.

--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ServiceRecord->MemberOfGroup != NULL &&
        ServiceRecord->MemberOfGroup->RefCount != MAXULONG) {
        ScDeleteStandaloneGroup(ServiceRecord->MemberOfGroup);
    }

    ServiceRecord->MemberOfGroup = NULL;
}


DWORD
ScCreateRegistryGroupPointer(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Group OPTIONAL
    )
/*++

Routine Description:

    This function assigns the load order group RegistryGroup
    information in the service record to match the load order group
    stored in the registry, which is not the same as MemberOfGroup
    information if the load order group of the service is changed
    while the service is running.  However, we need to know what the
    resultant load order group of the service is when it stops so
    that when we can guarantee uniqueness of a tag based on all
    members the group.

    This function does exactly the same thing as the
    ScCreateGroupMembership function but alters the RegistryGroup
    pointer instead of the MemberOfGroup pointer in the service
    record.

Arguments:

    ServiceRecord - Receives the group membership information in this service
        record.

    Group - Supplies the string which contains the name of the group.  This
        is the raw string read from the registry which may contain blank,
        tab or newline characters which we should ignore.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a group name
        failed.

Note:

    This routine assumes that the database lock is already held.  It is
    called by ScAddConfigInfoServiceRecord.

    It also assumes that the caller has exclusive access to the group
    list lock.

--*/
{
    DWORD status;
    LPWSTR GroupPtr = Group;
    LPWSTR GroupName;
    PLOAD_ORDER_GROUP GroupEntry = ScGetOrderGroupList();

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());


    //
    // Extract the group name from the string read in from the registry.
    //
    if ((! ARGUMENT_PRESENT(GroupPtr)) || (! ScGetToken(&GroupPtr, &GroupName))) {
        ServiceRecord->RegistryGroup = (PLOAD_ORDER_GROUP) NULL;
        return NO_ERROR;
    }

    //
    // Search for matching group name in load order list
    //
    while (GroupEntry != NULL) {
        if (_wcsicmp(GroupEntry->GroupName, GroupName) == 0) {
            ServiceRecord->RegistryGroup = GroupEntry;
            return NO_ERROR;
        }
        GroupEntry = GroupEntry->Next;
    }

    //
    // Group name not NULL, and not found in load order group list.
    // Group is a standalone group.
    //
    status = ScCreateStandaloneGroup(
                 GroupName,
                 &(ServiceRecord->RegistryGroup)
                 );

    if (status != NO_ERROR) {
        return status;
    }

    return NO_ERROR;
}


VOID
ScDeleteRegistryGroupPointer(
    IN OUT PSERVICE_RECORD ServiceRecord
    )
/*++

Routine Description:

    This function deletes any memory allocated for registry group
    association.

Arguments:

    ServiceRecord - Supplies the registry group information in this
        service record.

Return Value:

    None.

Note:

    This routine assumes that the database lock is already held.  It is
    called by ScAddConfigInfoServiceRecord and ScDecrementUseCountAndDelete.

    It also assumes that the group list lock is held exclusively.

--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (ServiceRecord->RegistryGroup != NULL &&
        ServiceRecord->RegistryGroup->RefCount != MAXULONG) {
        ScDeleteStandaloneGroup(ServiceRecord->RegistryGroup);
    }

    ServiceRecord->RegistryGroup = NULL;
}


DWORD
ScCreateStandaloneGroup(
    IN LPWSTR GroupName,
    OUT LPLOAD_ORDER_GROUP *GroupPointer
    )
/*++

Routine Description:

    This function looks for a matching standalone group entry in the
    standalone group list.  If a match is found, the reference count is
    incremented and the pointer to the matching entry is returned.

    If no matching entry is found, this function creates a new standalone
    group entry, insert it into the end of the standalone group list, and
    return a pointer to the new entry.


Arguments:

    Name - Supplies the name of the group which is not in the
        ServiceOrderList.

    GroupPointer - Receives a pointer to the unresolved entry.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Allocation of memory failed.

Note:

    This routine assumes that the caller has exclusively acquired the
    group list lock.  It is called by ScCreateGroupMembership.

--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    LPLOAD_ORDER_GROUP Group = ScGetStandaloneGroupList();

    BOOL Found = FALSE;


    //
    // Search the existing standalone group list for the matching
    // standalone group entry.
    //
    while (Group != NULL) {

        if (_wcsicmp(Group->GroupName, GroupName) == 0) {
            Found = TRUE;
            break;
        }

        Group = Group->Next;
    }

    if (Found) {

        Group->RefCount++;

        SC_LOG2(DEPEND_DUMP,
            "Found existing group entry for " FORMAT_LPWSTR
            ", just increment refcount to %lu\n", Group->GroupName,
            Group->RefCount);

        *GroupPointer = Group;

        return NO_ERROR;
    }

    //
    // Not found.  Allocate a new group entry.
    //
    if ((*GroupPointer = (LPLOAD_ORDER_GROUP)LocalAlloc(
                             LMEM_ZEROINIT,
                             sizeof(LOAD_ORDER_GROUP) + WCSSIZE(GroupName)
                             )) == NULL) {
        SC_LOG(ERROR,"ScCreateStandaloneGroup: LocalAlloc failure %lu\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    (*GroupPointer)->GroupName = (LPWSTR) ((DWORD_PTR) *GroupPointer +
                                    sizeof(LOAD_ORDER_GROUP));
    wcscpy((*GroupPointer)->GroupName, GroupName);

    (*GroupPointer)->RefCount = 1;

    SC_LOG1(DEPEND_DUMP, "Created new standalone group entry "
            FORMAT_LPWSTR "\n", (*GroupPointer)->GroupName);

    ScRememberSpecialGroup(*GroupPointer);

    Group = &StandaloneGroupList;

    //
    // Add the new group entry to the standalone group list at the end.
    //
    ADD_TO_LIST(Group, *GroupPointer);

    return NO_ERROR;
}


VOID
ScDeleteStandaloneGroup(
    IN LPLOAD_ORDER_GROUP Group
    )
{
    if (Group->RefCount) {
        Group->RefCount--;

        SC_LOG1(DEPEND, "DeleteStandaloneGroup: Subtracted RefCount is "
                FORMAT_DWORD "\n", Group->RefCount);
    }
    else {
        SC_LOG0(ERROR, "ScDeleteStandaloneGroup: Before delete, refcount is 0!\n");
        SC_ASSERT(FALSE);
    }

    if (Group->RefCount == 0) {

        SC_LOG1(DEPEND, "Deleting standalone group " FORMAT_LPWSTR "\n",
                Group->GroupName);

        REMOVE_FROM_LIST(Group);

        ScForgetSpecialGroup(Group);

        LocalFree(Group);
    }
}



VOID
ScRememberSpecialGroup(
    IN  LPLOAD_ORDER_GROUP Group
    )

/*++

Routine Description:

    Compares the group name against a set of known group names to see if it
    is a group that requires special handling, and if so, saves the pointer
    to the group in a global variable.


Arguments:


Return Value:


--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    // CODEWORK:  If the number of special groups keeps growing, do this
    // in a table-driven way!

    if (_wcsicmp(Group->GroupName, SC_GROUPNAME_TDI) == 0)
    {
        if (ScGlobalTDIGroup != SC_INVALID_GROUP)
        {
            SC_LOG0(ERROR, "Warning: TDI group occurs more than once in load order group list\n");
        }
        ScGlobalTDIGroup = Group;
    }
    else if (_wcsicmp(Group->GroupName, SC_GROUPNAME_PNP_TDI) == 0)
    {
        if (ScGlobalPNP_TDIGroup != SC_INVALID_GROUP)
        {
            SC_LOG0(ERROR, "Warning: PNP_TDI group occurs more than once in load order group list\n");
        }
        ScGlobalPNP_TDIGroup = Group;
    }
}


VOID
ScForgetSpecialGroup(
    IN  LPLOAD_ORDER_GROUP Group
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    if (Group == ScGlobalTDIGroup)
    {
        ScGlobalTDIGroup = SC_INVALID_GROUP;
    }
    else if (Group == ScGlobalPNP_TDIGroup)
    {
        ScGlobalPNP_TDIGroup = SC_INVALID_GROUP;
    }
}



VOID
ScGenerateDependencies(
    VOID
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

    The GroupListLock must be held exclusively prior to calling this routine.


--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    FOR_ALL_SERVICES(Service)
    {
        (void) ScSetDependencyPointers(Service);
    }
}


DWORD
ScSetDependencyPointers(
    IN LPSERVICE_RECORD Service
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:

    The GroupListLock must be held exclusively prior to calling this routine.


--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());

    DWORD status;

    if (Service->Dependencies != NULL) {

        status = ScCreateDependencies(
                     Service,
                     Service->Dependencies
                     );

        if (status == NO_ERROR) {
            LocalFree(Service->Dependencies);
            Service->Dependencies = NULL;
        }

        return status;
    }

    return NO_ERROR;
}


DWORD
ScResolveDependencyToService(
    LPSERVICE_RECORD DependOnService
    )
/*++

Routine Description:

    This function resolves all dependencies to the service we are
    currently installing via CreateService.  The start depend entry
    of these services will point to the service record of the service
    we are installing instead of the unresolved depend record.  A
    stop depend entry is created for the service we are installing to
    point back to every service that depends on it.

Arguments:

    DependOnService - Supplies a pointer to the service we are installing
        via CreateService which other services may depend on.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Fail to allocate memory for required data
        structures.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by RCreateServiceW.

--*/
{
    SC_ASSERT(ScGroupListLock.Have());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    DWORD status;
    LPUNRESOLVED_DEPEND UnresolvedEntry = ScGetUnresolvedDependList();


    //
    // Search the unresolved depend list for a matching entry
    //
    while (UnresolvedEntry != NULL) {

        if (_wcsicmp(UnresolvedEntry->Name, DependOnService->ServiceName) == 0) {
            SC_LOG1(DEPEND, "Found unresolved entry for " FORMAT_LPWSTR "\n",
                    DependOnService->ServiceName);
            break;
        }

        UnresolvedEntry = UnresolvedEntry->Next;
    }

    if (UnresolvedEntry == NULL) {
        //
        // There are no service which depends on the service we are
        // installing; hence, no unresolved dependency to resolve.
        //
        SC_LOG1(DEPEND, "No service depends on " FORMAT_LPWSTR "\n",
                DependOnService->ServiceName);
        return NO_ERROR;
    }


    //
    // Loop through all services to see if any of them has a start depend
    // entry that points to UnresolvedEntry.
    //
    FOR_ALL_SERVICES(Service)
    {
        if (UnresolvedEntry == NULL)
        {
            break;
        }

        for (LPDEPEND_RECORD Start = Service->StartDepend;
             Start != NULL;
             Start = Start->Next)
        {
            if (Start->DependUnresolved == UnresolvedEntry)
            {
                status = ScSetServiceDependList(
                             Start,
                             Service,
                             (PVOID)DependOnService,
                             TypeDependOnService
                             );

                if (status != NO_ERROR)
                {
                    //
                    // Error with creating the stop depend entry for
                    // DependOnService.  Back out changes set for the
                    // current start depend entry.
                    //
                    Start->DependType = TypeDependOnUnresolved;
                    Start->DependUnresolved = UnresolvedEntry;

                    //
                    // Back out of all other resolved dependencies to
                    // DependOnService will be done in ScDecrementUseCountAndDelete.
                    //
                    SC_LOG2(ERROR, "ScResolvedDependencyToService " FORMAT_LPWSTR
                            " failed " FORMAT_DWORD "\n",
                            DependOnService->ServiceName, status);
                    return status;
                }

                SC_LOG2(DEPEND, FORMAT_LPWSTR " depends on " FORMAT_LPWSTR
                        ".  Dependency resolved!\n", Service->ServiceName,
                        UnresolvedEntry->Name);

                ScDeleteUnresolvedDepend(&UnresolvedEntry);
            }
        }
    }

    return NO_ERROR;
}


DWORD
ScCreateDependencies(
    OUT PSERVICE_RECORD ServiceRecord,
    IN  LPWSTR Dependencies OPTIONAL
    )
/*++

Routine Description:

    This function creates the start dependencies list of a service.
    If the service specified by ServiceRecord depends on a service that
    has not been inserted into the service list yet, that service entry
    will be created and inserted into the service list so that the depend
    record can point to it.  The service this one points to in its start
    dependency list will get a new entry in its stop dependency list because
    this one must be stopped before it can stop.

    The dependencies list is not ordered.

    NOTE: This function is for call from RChangeServiceConfig.

Arguments:

    ServiceRecord - Receives the start dependencies information in this
        service record.

    Dependencies - Supplies the string which contains the names this service
        depend on to be started first.  This is a multi-sz string of
        service or group names.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Fail to allocate memory for required data
        structures.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScSetDependencyPointers.

    It also assumes that the caller has exclusively acquired the group
    list lock.

--*/
{
    DWORD status;

    LPWSTR DependPtr = Dependencies;
    LPWSTR DependOnName;
    PVOID DependOnRecord = NULL;
    DEPEND_TYPE Type;

    PDEPEND_RECORD Start;

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if (! ARGUMENT_PRESENT(DependPtr)) {
        return NO_ERROR;
    }

    while (*DependPtr != 0) {

        if (ScGetToken(&DependPtr, &DependOnName)) {

            //
            // Initialize flag for noting that a new service record is
            // created for resolving the dependency chain.
            //
            Type = TypeNone;

            if (*DependOnName != SC_GROUP_IDENTIFIERW) {

                //
                // Depend on a service
                //

                //
                // Look for the service we depend on in the service record list
                //
                status = ScGetNamedServiceRecord(
                             DependOnName,
                             (LPSERVICE_RECORD *) &DependOnRecord
                             );

                if (status == ERROR_SERVICE_DOES_NOT_EXIST) {

                    //
                    // Could not find the service we depend on.  Create an
                    // unresolved dependency entry.
                    //
                    status = ScCreateUnresolvedDepend(
                                DependOnName,
                                (PUNRESOLVED_DEPEND *) &DependOnRecord
                                );

                    if (status != NO_ERROR) {
                        goto ErrorExit;
                    }

                    //
                    // New unresolved depend entry created.  We have to remove
                    // it if any error occurs later.
                    //
                    Type = TypeDependOnUnresolved;

                }
                else {

                    Type = TypeDependOnService;
                }

                if (status != NO_ERROR) {
                    goto ErrorExit;
                }
            }
            else {

                //
                // Depend on a group
                //

                PLOAD_ORDER_GROUP GroupEntry = ScGetOrderGroupList();

                DependOnName++;

                //
                // Search for matching group name in load order list
                //
                while (GroupEntry != NULL) {
                    if (_wcsicmp(GroupEntry->GroupName, DependOnName) == 0) {
                        DependOnRecord = (PVOID) GroupEntry;
                        Type = TypeDependOnGroup;
                        break;
                    }
                    GroupEntry = GroupEntry->Next;
                }

                if (GroupEntry == NULL) {
                    //
                    // Could not find group in the OrderGroup list.  Must
                    // depend on a standalone group.
                    //
                    status = ScCreateStandaloneGroup(
                                 DependOnName,
                                 (LPLOAD_ORDER_GROUP *) &DependOnRecord
                                 );

                    if (status != NO_ERROR) {
                        goto ErrorExit;
                    }

                    Type = TypeDependOnGroup;
                }
            }

            //
            // Allocate memory for start depend record and insert it in the
            // front of the start depend list of the service we are processing.
            //
            if ((status = ScCreateDependRecord(
                              TRUE,              // For start list
                              ServiceRecord,
                              &Start
                              )) != NO_ERROR) {

                goto ErrorExit;
            }

            //
            // Start depend record created OK, set fields.  Set stop
            // depend if appropriate (Type == TypeDependOnService).
            //
            status = ScSetServiceDependList(
                         Start,
                         ServiceRecord,
                         DependOnRecord,
                         Type
                         );

            if (status != NO_ERROR) {

                //
                // Remove the start depend record just created in the front of
                // the start depend list and delete it.
                //
                ServiceRecord->StartDepend = Start->Next;
                LocalFree(Start);

                goto ErrorExit;
            }

        } // if got token

    }  // while there is a dependency

    return NO_ERROR;

ErrorExit:

    //
    // Remove newly created service record because of errors and we cannot
    // proceed.
    //
    if (Type == TypeDependOnUnresolved) {

        ScDeleteUnresolvedDepend((PUNRESOLVED_DEPEND *) &DependOnRecord);
    }

    //
    // Clean up dependencies created up to the point of failure
    //
    ScDeleteStartDependencies(ServiceRecord);

    return status;
}


DWORD
ScCreateUnresolvedDepend(
   IN LPWSTR Name,
   OUT LPUNRESOLVED_DEPEND *Unresolved
   )
/*++

Routine Description:

    This function looks for a matching unresolved entry in the unresolved
    depend list.  If a match is found, the reference count is incremented
    and the pointer to the matching entry is returned.

    If no matching entry is found, this function creates a new unresolved
    entry, insert it into the end of the unresolved depend list, and
    return a pointer to the new entry.


Arguments:

    Name - Supplies the name of the service or group which has not been
        installed yet, and thus needing this unresolved depend entry.

    Unresolved - Receives a pointer to the unresolved entry.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Allocation of memory failed.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScCreateDependencies.

--*/
{
    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    LPUNRESOLVED_DEPEND UnresolvedList = ScGetUnresolvedDependList();

    BOOL Found = FALSE;


    //
    // Search the existing unresolved depend list for the matching
    // unresolved depend entry.
    //
    while (UnresolvedList != NULL) {

        if (_wcsicmp(UnresolvedList->Name, Name) == 0) {
            Found = TRUE;
            break;
        }

        UnresolvedList = UnresolvedList->Next;
    }

    if (Found) {

        UnresolvedList->RefCount++;

        SC_LOG2(DEPEND,
            "Found existing unresolved entry for " FORMAT_LPWSTR
            ", just increment refcount to %lu\n", UnresolvedList->Name,
            UnresolvedList->RefCount);

        *Unresolved = UnresolvedList;

        return NO_ERROR;
    }

    //
    // Not found.  Allocate a new unresolved entry.
    //
    if ((*Unresolved = (LPUNRESOLVED_DEPEND)LocalAlloc(
                             LMEM_ZEROINIT,
                             sizeof(UNRESOLVED_DEPEND) + WCSSIZE(Name)
                             )) == NULL) {
        SC_LOG1(ERROR,"ScCreateUnresolvedDepend: LocalAlloc failure %lu\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    (*Unresolved)->Name = (LPWSTR) ((DWORD_PTR) *Unresolved +
                                    sizeof(UNRESOLVED_DEPEND));
    wcscpy((*Unresolved)->Name, Name);

    (*Unresolved)->RefCount = 1;

    SC_LOG1(DEPEND, "Created new unresolved depend entry "
            FORMAT_LPWSTR "\n", (*Unresolved)->Name);

    UnresolvedList = &UnresolvedDependList;

    //
    // Add the new unresolved entry to the unresolved list at the end.
    //
    ADD_TO_LIST(UnresolvedList, *Unresolved);

    return NO_ERROR;
}


VOID
ScDeleteUnresolvedDepend(
    IN OUT LPUNRESOLVED_DEPEND *Unresolved
    )
{

    if ((*Unresolved)->RefCount) {
        (*Unresolved)->RefCount--;
        SC_LOG1(DEPEND, "ScDeleteUnresolvedDepend: Subtracted RefCount is "
                FORMAT_DWORD "\n", (*Unresolved)->RefCount);
    }
    else {
        //
        // The reference count better not be 0.
        //
        SC_LOG0(ERROR, "ScDeleteUnresolvedDepend: Before delete, refcount is 0!\n");
        SC_ASSERT(FALSE);
    }

    if ((*Unresolved)->RefCount == 0) {
        REMOVE_FROM_LIST(*Unresolved);
        LocalFree(*Unresolved);
        *Unresolved = NULL;
    }
}


DWORD
ScCreateDependRecord(
    IN  BOOL IsStartList,
    IN  OUT PSERVICE_RECORD ServiceRecord,
    OUT PDEPEND_RECORD *DependRecord
    )
/*++

Routine Description:

    This function allocates the memory for a depend record, and insert
    it into the front of the specific depend list.  If IsStartList is
    TRUE, the depend record goes into the start depend list of
    ServiceRecord, otherwise the depend record goes into the stop
    depend list of the ServiceRecord.

Arguments:

    IsStartList - TRUE indicates to insert into start list, FALSE indicates
        to insert into stop list.

    ServiceRecord - Receives the start/stop depend record in its dependency
        list.

    DependRecord - Receives a pointer to the new depend record created.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - The call to allocate memory for a depend
        record failed.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScCreateDependencies.

--*/
{
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    if ((*DependRecord = (PDEPEND_RECORD)LocalAlloc(
                             LMEM_ZEROINIT,
                             sizeof(DEPEND_RECORD)
                             )) == NULL) {
        SC_LOG(ERROR,"ScCreateDependRecord: LocalAlloc failure %ld\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Insert the depend record into the front of the list
    //
    if (IsStartList) {
        //
        // Start depend
        //
        (*DependRecord)->Next = ServiceRecord->StartDepend;
        ServiceRecord->StartDepend = *DependRecord;
    }
    else {
        //
        // Stop depend
        //
        (*DependRecord)->Next = ServiceRecord->StopDepend;
        ServiceRecord->StopDepend = *DependRecord;
    }

    return NO_ERROR;
}


VOID
ScDeleteStartDependencies(
    IN PSERVICE_RECORD ServiceRecord
    )
/*++

Routine Description:

    This function deletes the start dependencies list of a service.  It also
    deletes the the stop dependencies of other services which need this
    service to be stopped first.

    NOTE: This function is for call from RChangeServiceConfig.

Arguments:

    ServiceRecord - Supplies the start dependencies information in this
        service record.

Return Value:

    None.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScAddConfigInfoServiceRecord and
    ScDecrementUseCountAndDelete.

    It also assumes that the caller has exclusively acquired the group
    list lock.

--*/
{
    PDEPEND_RECORD StartEntry;
    PDEPEND_RECORD StopEntry;
    PDEPEND_RECORD StopBackPointer;

    SC_ASSERT(ScGroupListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    StartEntry = ServiceRecord->StartDepend;

    while (StartEntry != NULL) {

        if (StartEntry->DependType == TypeDependOnService) {

            LPSERVICE_RECORD DependencyService = StartEntry->DependService;


            //
            // Find the stop depend record for the service which depends on this
            // service to be stopped first, and delete it.
            //
            StopEntry = DependencyService->StopDepend;
            StopBackPointer = StopEntry;

            while ((StopEntry != NULL) &&
                   (StopEntry->DependService != ServiceRecord)) {

                StopBackPointer = StopEntry;
                StopEntry = StopEntry->Next;
            }

            if (StopEntry == NULL) {
#ifndef _CAIRO_
                //
                // We allow Netlogon to appear in the start dependency list, but
                // not in the stop dependency list.  This is for the case where
                // we add a "soft" dependency on netlogon because the service runs
                // in a remove account.
                //
                if (_wcsicmp(DependencyService->ServiceName,L"Netlogon") != 0) {
#endif // _CAIRO_
                    SC_LOG1(ERROR,
                            "ScDeleteStartDependencies: Failed to find matching stop depend node for "
                            FORMAT_LPWSTR "\n",
                            DependencyService->ServiceName);
                    SC_ASSERT(FALSE);
                    return;
#ifndef _CAIRO_
                }
#endif // _CAIRO_
            }
            else {

                if (StopEntry->DependService == ServiceRecord) {

                    if ((PVOID) StopBackPointer == StopEntry) {
                        //
                        // Unchaining from the front of the list
                        //
                        DependencyService->StopDepend = StopEntry->Next;
                    }
                    else {
                        //
                        // Unchaining from the middle or end of the list
                        //
                        StopBackPointer->Next = StopEntry->Next;
                    }

                    LocalFree(StopEntry);
                }
            }
        }
        else if (StartEntry->DependType == TypeDependOnGroup) {

            //
            // Decrement the reference count on the standalone group
            // entry and deletes it if 0.
            //
            if (StartEntry->DependGroup->RefCount != MAXULONG) {
                ScDeleteStandaloneGroup(StartEntry->DependGroup);
            }

        }
        else {

            //
            // Dependency type is unresolved.
            //
            ScDeleteUnresolvedDepend(&StartEntry->DependUnresolved);
        }

        //
        // Now delete the start depend record.
        //
        ServiceRecord->StartDepend = StartEntry->Next;
        LocalFree(StartEntry);
        StartEntry = ServiceRecord->StartDepend;
    }
}


VOID
ScDeleteStopDependencies(
    IN PSERVICE_RECORD ServiceToBeDeleted
    )
/*++

Routine Description:

    This function deletes the stop dependencies list of a service.  For
    every stop depend service, it makes the start depend pointer of that
    service to point to an unresolved depend entry.

    This function is called when the service is to be deleted.

Arguments:

    ServiceToBeDeleted - Supplies the pointer to the service that will
        be deleted.

Return Value:

    None.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScDecrementUseCountAndDelete.

--*/
{

    DWORD status;
    PDEPEND_RECORD StartEntry;
    PDEPEND_RECORD StopEntry;
    LPUNRESOLVED_DEPEND Unresolved;

    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    StopEntry = ServiceToBeDeleted->StopDepend;

    while (StopEntry != NULL) {

        LPSERVICE_RECORD DependencyService = StopEntry->DependService;

        //
        // Loop through the start depend entries of the service which
        // depends on ServiceToBeDeleted.
        //
        StartEntry = DependencyService->StartDepend;

        while (StartEntry != NULL) {

            if (StartEntry->DependService == ServiceToBeDeleted) {
                break;
            }

            StartEntry = StartEntry->Next;
        }

        if (StartEntry != NULL) {

            //
            // Found a start depend entry that points to the service to be.
            // deleted.  Make it point to an unresolved depend entry that
            // represents that service.
            //
            status = ScCreateUnresolvedDepend(
                         ServiceToBeDeleted->ServiceName,
                         &Unresolved
                         );

            if (status == NO_ERROR) {
                StartEntry->DependType = TypeDependOnUnresolved;
                StartEntry->DependUnresolved = Unresolved;
            }
        }

        //
        // Now delete the start depend record.
        //
        ServiceToBeDeleted->StopDepend = StopEntry->Next;
        LocalFree(StopEntry);
        StopEntry = ServiceToBeDeleted->StopDepend;
    }
}


DWORD
ScSetServiceDependList(
    LPDEPEND_RECORD Start,
    LPSERVICE_RECORD ServiceRecord,
    PVOID DependOnRecord,
    DEPEND_TYPE DependOnType
    )
/*++

Routine Description:

    This function

Arguments:

Return Value:

    None.

Note:

    This routine assumes that the caller has exclusively acquired the
    database lock.  It is called by ScResolveDependencyToService and
    ScCreateDependencies.

--*/
{
    DWORD status;
    LPDEPEND_RECORD Stop;

    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    // Set fields for start depend entry.
    //
    Start->DependType = DependOnType;
    Start->Depend = DependOnRecord;

    if (DependOnType == TypeDependOnService) {

        //
        // Allocate memory for stop depend record and insert it in the
        // front of the stop depend list of the service we depend on.
        //
        if ((status = ScCreateDependRecord(
                          FALSE,             // For stop list
                          (LPSERVICE_RECORD) DependOnRecord,
                          &Stop
                          )) != NO_ERROR) {

            return status;
        }

        Stop->DependType = TypeDependOnService;
        Stop->DependService = ServiceRecord;
    }

    return NO_ERROR;
}


LPLOAD_ORDER_GROUP
ScGetNamedGroupRecord(
    IN LPCWSTR GroupName
    )
/*++

Routine Description:

    This function searches for a named group, first in the order group
    list and next in the standalone group list.

Arguments:

    GroupName - Supplies the name of the group to look for.

Return Value:

    Returns the pointer to group found.  If not found, this value is
        NULL.

Note:

    This routine assumes that the caller has exclusively acquired the
    group list lock.

--*/
{
    LPLOAD_ORDER_GROUP Group;

    for (Group = ScGetOrderGroupList();
         Group != NULL;
         Group = Group->Next)
    {
        if (_wcsicmp(Group->GroupName, GroupName) == 0)
        {
            break;
        }
    }

    if (Group == NULL)
    {
        for (Group = ScGetStandaloneGroupList();
             Group != NULL;
             Group = Group->Next)
        {
            if (_wcsicmp(Group->GroupName, GroupName) == 0)
            {
                break;
            }
        }
    }

    return Group;
}


VOID
ScGetUniqueTag(
    IN  LPWSTR GroupName,
    OUT LPDWORD Tag
    )
/*++

Routine Description:

    This function looks for a unique tag value within the specified
    group.

Arguments:

    GroupName - Specifies the group name within which the value tag
        returned must be unique.

    Tag - Receives the unique tag value.

Return Value:

    None.

Note:

    This function acquires share access to the group list lock.

    It assumes that the exclusive service database lock is already
    acquired so that no other caller can execute this code until
    the returned tag is fully assigned to the service, and that the
    service entries in the database list don't change.

    The GroupListLock must be held exclusively prior to calling this
    function.

--*/
{
    LPDWORD TagArray;
    DWORD TagArrayLength;

    DWORD ReturnTag = 1;

    LPLOAD_ORDER_GROUP Group;

    SC_ASSERT(ScGroupListLock.Have());
    SC_ASSERT(ScServiceRecordLock.Have());

    if (ScGetGroupVector(
            GroupName,
            (LPBYTE *) &TagArray,
            &TagArrayLength
            ) == NO_ERROR) {

        if (TagArray != NULL) {
            //
            // The returned values is actually the number of bytes.  Divide it
            // by size of DWORD to make it the number of array entries.
            //
            TagArrayLength = TagArrayLength / sizeof(DWORD);

            SC_ASSERT((TagArrayLength - 1) == TagArray[0]);

            ScCompareVector(
                TagArray,
                TagArrayLength,
                &ReturnTag
                );
        }
    }
    else {

        TagArray = NULL;
    }

    Group = ScGetNamedGroupRecord(GroupName);

    if (Group != NULL) {

GroupAgain:
        FOR_ALL_SERVICES(Service) {

            if ((Service->RegistryGroup == Group) &&
                (Service->Tag == ReturnTag)) {

                ReturnTag++;

                if (TagArray != NULL) {

                    ScCompareVector(
                        TagArray,
                        TagArrayLength,
                        &ReturnTag
                        );
                }

                goto GroupAgain;
            }
        } // while all services
    }


    *Tag = ReturnTag;

    SC_LOG(DEPEND, "ScGetUniqueTag: Tag=" FORMAT_DWORD "\n", *Tag);

}


VOID
ScCompareVector(
    IN     LPDWORD TagArray,
    IN     DWORD TagArrayLength,
    IN OUT LPDWORD ReturnTagPtr
    )
{
    DWORD i;

VectorAgain:
    for (i = 1; i < TagArrayLength; i++) {

        if (TagArray[i] == (*ReturnTagPtr)) {

            SC_LOG(DEPEND_DUMP, "Tag " FORMAT_DWORD " is not unique\n",
                   *ReturnTagPtr);

            (*ReturnTagPtr)++;
            goto VectorAgain;
        }
    }
}

VOID
ScGetDependencySize(
    LPSERVICE_RECORD    ServiceRecord,
    LPDWORD             DependSize,
    LPDWORD             MaxDependSize
    )

/*++

Routine Description:



Arguments:

    ServiceRecord -

    DependSize - This points to a location that will contain the number
        of bytes required for the list of dependency strings.

    MaxDependSize - This points to a location that will contain the
        number of bytes in the longest dependency string in the set.

Return Value:



--*/
{
    LPDEPEND_RECORD     dependRecord;
    DWORD               bytesNeeded = 0;
    DWORD               StrSize=0;

    dependRecord = ServiceRecord->StartDepend;

    //
    // NOTE: Dependencies are expected to be a double NULL terminated
    //       terminated set of strings.
    //
    bytesNeeded += sizeof(WCHAR);

    if (dependRecord == NULL) {
        bytesNeeded += sizeof(WCHAR);
    }
    while (dependRecord != NULL) {

        SC_ASSERT( dependRecord->Depend != NULL );

        // Add room.  WCSSIZE adds 1 char.  For final entry,  we'll
        // use null char.  In between, we'll put some separator.

        if (dependRecord->DependType == TypeDependOnService) {
            StrSize =
                (DWORD) WCSSIZE(dependRecord->DependService->ServiceName); // sizes...

        }
        else if (dependRecord->DependType == TypeDependOnGroup) {
            StrSize =
               (DWORD) WCSSIZE(dependRecord->DependGroup->GroupName) +
               sizeof(WCHAR); // name size plus SC_GROUP_IDENTIFIERW
        }
        else {
            //
            // Unresolved service dependency
            //
            StrSize = (DWORD) WCSSIZE(dependRecord->DependUnresolved->Name);
        }

        bytesNeeded += StrSize;

        if (StrSize > *MaxDependSize) {
            *MaxDependSize = StrSize;
        }

        dependRecord = dependRecord->Next;
    }
    *DependSize = bytesNeeded;
}

DWORD
ScGetDependencyString(
    LPSERVICE_RECORD    ServiceRecord,
    DWORD               MaxDependSize,
    DWORD               DependSize,
    LPWSTR              lpDependencies
    )

/*++

Routine Description:



Arguments:

    ServiceRecord -

    MaxDependSize - This is the size of the largest string in the
        dependency list.

    lpDependencies - This is a pointer to the location where the
        list of dependency strings is to be stored.

Return Value:



--*/
{
    LPWSTR          endOfVariableData;
    LPWSTR          fixedDataEnd;
    LPDEPEND_RECORD dependRecord;
    DWORD           bufSize;
    DWORD           ApiStatus = NO_ERROR;

    //
    // Put dependencies in the return buffer.  Since it is a NULL-NULL
    // string, put an extra NULL at the end to begin with.
    //
    endOfVariableData = (LPWSTR) (((LPBYTE)lpDependencies) + DependSize);

    endOfVariableData = endOfVariableData - 1;
    * endOfVariableData = L'\0';

    fixedDataEnd = lpDependencies;

    dependRecord = ServiceRecord->StartDepend;

    if (dependRecord == NULL) {
        //
        // If there are no dependencies, then we need to add a separator
        // that will be followed by the NULL (immediately above).
        // This separator is used to get us across the RPC interface.
        // Then on the client side, it is changed to a NULL.  So we end
        // up with an empty-double-NULL-terminated-string.
        //
        endOfVariableData = endOfVariableData - 1;
        * endOfVariableData = L'/';
        lpDependencies = endOfVariableData;
    }
    else {

        LPWSTR DependName;


        DependName = (LPWSTR)LocalAlloc(0, (UINT) MaxDependSize);

        if (DependName == NULL) {
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        lpDependencies = endOfVariableData;
        while (dependRecord != NULL) {

            SC_ASSERT( dependRecord->Depend != NULL );


            if (dependRecord->DependType == TypeDependOnService) {

                wcscpy(DependName, dependRecord->DependService->ServiceName);

            }
            else if (dependRecord->DependType == TypeDependOnGroup) {

                *DependName = SC_GROUP_IDENTIFIERW;

                wcscpy(DependName + 1, dependRecord->DependGroup->GroupName);
            }
            else {
                //
                // Unresolved service dependency
                //
                wcscpy(DependName, dependRecord->DependUnresolved->Name);
            }

            bufSize = (DWORD) wcslen(DependName);

            if ( !ScCopyStringToBufferW (
                    DependName,
                    bufSize,
                    fixedDataEnd,
                    &endOfVariableData,
                    &lpDependencies,
                    NULL
                    ) ) {

                SC_LOG0(ERROR,
                    "RQueryServiceConfigW:ScCopyStringtoBufferW (Dependencies)Failed\n");

                SC_ASSERT( FALSE );
                ApiStatus = ERROR_INSUFFICIENT_BUFFER;
                LocalFree(DependName);
                goto Cleanup;
            }
            else {
                //
                // Add separator character.
                //

                lpDependencies[bufSize] = L'/';
            }

            dependRecord = dependRecord->Next;
        }

        LocalFree(DependName);
    }
Cleanup:
    return(ApiStatus);
}


#if DBG
VOID
ScDumpGroups(
    VOID
    )
/*++

Routine Description:

    This function walks group list prints out each entry.

Arguments:

    None.

Return Value:

    None.

Note:

    Calls to this routine must be enclosed within #if DBG.

--*/
{
    PLOAD_ORDER_GROUP GroupEntry = ScGetOrderGroupList();


    while (GroupEntry != NULL) {
        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "\nOrdered Groups:\n"));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "Group: Handle=%08lx Name=%ws RefCount=x%lx\n",
                   GroupEntry,
                   GroupEntry->GroupName,
                   GroupEntry->RefCount));

        GroupEntry = GroupEntry->Next;
    }

    GroupEntry = ScGetStandaloneGroupList();

    while (GroupEntry != NULL) {
        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "Standalone Groups:\n"));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "Group: Handle=%08lx Name=%ws RefCount=x%lx\n",
                   GroupEntry,
                   GroupEntry->GroupName,
                   GroupEntry->RefCount));

        GroupEntry = GroupEntry->Next;
    }

    KdPrintEx((DPFLTR_SCSERVER_ID,
               DEBUG_DEPEND_DUMP,
               "\nTDI     group is at %08lx" "\nPNP_TDI group is at %08lx\n",
               ScGlobalTDIGroup,
               ScGlobalPNP_TDIGroup));
}

VOID
ScDumpServiceDependencies(
    VOID
    )
/*++

Routine Description:

    This function walks the start and stop dependencies lists of every
    service in the service record list.

Arguments:

    None.

Return Value:

    None.

Note:

    Calls to this routine must be enclosed within #if DBG.

--*/
{
    PDEPEND_RECORD DependList;

    FOR_ALL_SERVICES(ServiceRecord)
    {
        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   "Service: %-20ws UseCount=%lu",
                   ServiceRecord->ServiceName,
                   ServiceRecord->UseCount));

        KdPrintEx((DPFLTR_SCSERVER_ID,
                   DEBUG_DEPEND_DUMP,
                   " MemberOfGroup=%08lx ",
                   ServiceRecord->MemberOfGroup));

        if (ServiceRecord->MemberOfGroup != NULL) {
            if (ServiceRecord->MemberOfGroup->RefCount != MAXULONG) {
                KdPrintEx((DPFLTR_SCSERVER_ID,
                           DEBUG_DEPEND_DUMP,
                           "SG=%ws\n",
                           ServiceRecord->MemberOfGroup->GroupName));
            }
            else if (ServiceRecord->MemberOfGroup->RefCount == MAXULONG) {
                KdPrintEx((DPFLTR_SCSERVER_ID,
                           DEBUG_DEPEND_DUMP,
                           "OG=%ws\n",
                           ServiceRecord->MemberOfGroup->GroupName));
            }
        }
        else {
            KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_DEPEND_DUMP, "\n"));
        }

        if (ServiceRecord->RegistryGroup != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_DEPEND_DUMP,
                       "                    RG=%ws\n",
                       ServiceRecord->RegistryGroup->GroupName));
        }

        //
        // Dump start depend
        //
        DependList = ServiceRecord->StartDepend;

        if (DependList != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_DEPEND_DUMP, "    StartDepend:\n"));
        }

        while (DependList != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_DEPEND_DUMP,
                       "        %ws\n",
                       DependList->DependService->ServiceName));

            DependList = DependList->Next;
        }

        //
        // Dump stop depend
        //
        DependList = ServiceRecord->StopDepend;
        if (DependList != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_DEPEND_DUMP, "    StopDepend:\n"));
        }

        while (DependList != NULL) {
            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_DEPEND_DUMP,
                       "        %ws\n",
                       DependList->DependService->ServiceName));

            DependList = DependList->Next;
        }
    }
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\driver.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DRIVER.H

Abstract:

    Prototypes for functions that control and get status from drivers.

Author:

    Dan Lafferty (danl)     28-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    28-Apr-1991     danl
        created

--*/
DWORD
ScLoadDeviceDriver(
    LPSERVICE_RECORD    ServiceRecord
    );

DWORD
ScControlDriver(
    DWORD               ControlCode,
    LPSERVICE_RECORD    ServiceRecord,
    LPSERVICE_STATUS    lpServiceStatus
    );

DWORD
ScGetDriverStatus(
    IN OUT LPSERVICE_RECORD    ServiceRecord,
    OUT    LPSERVICE_STATUS    lpServiceStatus OPTIONAL
    );

DWORD
ScUnloadDriver(
    LPSERVICE_RECORD    ServiceRecord
    );

VOID
ScNotifyNdis(
    LPSERVICE_RECORD    ServiceRecord
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\info.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    info.h

Abstract:

    Service query and enum info related function prototypes.

Author:

    Rita Wong (ritaw)     06-Apr-1992

Revision History:

--*/

#ifndef SCINFO_INCLUDED
#define SCINFO_INCLUDED

//
// Service status structures union
//
typedef union
{
    LPSERVICE_STATUS           Regular;
    LPSERVICE_STATUS_PROCESS   Ex;
}
STATUS_UNION, *LPSTATUS_UNION;


//
// Function Prototypes
//

DWORD
ScQueryServiceStatus(
    IN  LPSERVICE_RECORD ServiceRecord,
    OUT STATUS_UNION     ServiceStatus,
    IN  BOOL             fExtendedStatus
    );

VOID
ScGetBootAndSystemDriverState(
    VOID
    );

#endif // #ifndef SCINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\info.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    info.cxx

Abstract:

    Contains entry points for REnumServicesStatusW and RQueryServiceStatus as
    well as support routines.  This file contains the following external
    functions:
        REnumServicesStatusW
        REnumServicesStatusExW
        REnumServiceGroupW
        RQueryServiceStatus
        RQueryServiceStatusEx
        REnumDependentServicesW

Author:

    Dan Lafferty (danl)     25-Jan-1992

Environment:

    User Mode -Win32

Revision History:
    25-Apr-1996     AnirudhS
        Don't popup messages or log events for boot start and system start
        drivers that are disabled in the current hardware profile.
    14-Feb-1996     AnirudhS
        Add REnumServiceGroupW.
    10-Feb-1993     Danl
        Use ROUND_DOWN_COUNT to properly align the enumeration buffer.
    10-Apr-1992     JohnRo
        Use ScImagePathsMatch() to allow mixed-case image names.
        Changed names of some <valid.h> macros.
    25-Jan-1992     danl
        Created.

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <stdlib.h>     // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <align.h>      // ROUND_DOWN_COUNT
#include <sclib.h>      // ScCopyStringToBufferW(), etc.
#include <valid.h>      // ENUM_STATE_INVALID
#include "info.h"       // ScQueryServiceStatus
#include "depend.h"     // ScEnumDependents, ScInHardwareProfile
#include "driver.h"     // ScGetDriverStatus
#include <cfgmgr32.h>   // PNP manager functions
#include <scwow.h>      // 32/64-bit interop structures


//
// DEFINITIONS
//

#define  IS_NOGROUP_STRING(string)      (string[0] == L'\0')


//
// Local function declarations
//

DWORD
REnumServiceGroupHelp (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCWSTR         lpLoadOrderGroup OPTIONAL,
    IN      BOOL            fExtended
    );


//
// Function implementations
//

DWORD
REnumServicesStatusW (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL
    )

/*++

Routine Description:

    This function lists the services installed in the Service Controller's
    database.  The status of each service is returned with the name of
    the service.

Arguments:

    hSCManager - This is a handle to the service controller.  It must
        have been opened with SC_MANAGER_ENUMERATE_SERVICE access.

    dwServiceType - Value to select the type of services to enumerate.
        It must be one of the bitwise OR of the following values:
        SERVICE_WIN32 - enumerate Win32 services only.
        SERVICE_DRIVER - enumerate Driver services only.

    dwServiceState - Value so select the services to enumerate based on the
        running state.  It must be one or the bitwise OR of the following
        values:
        SERVICE_ACTIVE - enumerate services that have started.
        SERVICE_INACTIVE - enumerate services that are stopped.

    lpBuffer - A pointer to a buffer to receive an array of enum status
        (or service) entries.

    cbBufSize - Size of the buffer in bytes pointed to by lpBuffer.

    pcbBytesNeeded - A pointer to a location where the number of bytes
        left (to be enumerated) is to be placed.  This indicates to the
        caller how large the buffer must be in order to complete the
        enumeration with the next call.

    lpServicesReturned - A pointer to a variable to receive the number of
        of service entries returned.

    lpResumeIndex - A pointer to a variable which on input specifies the
        index of a service entry to begin enumeration.  An index of 0
        indicates to start at the beginning.  On output, if this function
        returns ERROR_MORE_DATA, the index returned is the next service
        entry to resume the enumeration.  The returned index is 0 if this
        function returns a NO_ERROR.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in.
        (such as dwServiceType).

    ERROR_INVALID_HANDLE - The specified handle was invalid.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpBuffer, pcbReturned, pcbBytesNeeded,
        lpBuffer, ReturnedServerName, and lpResumeIndex.


--*/
{
    return REnumServiceGroupHelp(hSCManager,
                                 dwServiceType,
                                 dwServiceState,
                                 lpBuffer,
                                 cbBufSize,
                                 pcbBytesNeeded,
                                 lpServicesReturned,
                                 lpResumeIndex,
                                 NULL,          // Enumerate everything
                                 FALSE);        // Regular (non-Ex) enumeration
}


DWORD
REnumServicesStatusExW (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      SC_ENUM_TYPE    InfoLevel,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCWSTR         lpLoadOrderGroup
    )
/*++

Routine Description:

    This function is analogous to REnumServicesStatusW, with the data
    being enumerated being dependent upon the InfoLevel parameter

Arguments:

    InfoLevel - An enumerated type that determines what service attributes
        are enumerated:

            SC_ENUM_PROCESS_INFO - Enumerates all the service information from
                REnumServicesStatusW plus the service's PID and flags

    lpLoadOrderGroup - Only enumerate services belonging to the given group.
        If this parameter is the empty string, services not belonging to
        a group are enumerated.  If this parameter is NULL, no attention
        is paid to group.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in.
        (such as dwServiceType).

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_INVALID_LEVEL - The specified InfoLevel is invalid

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpBuffer, pcbReturned, pcbBytesNeeded,
        lpBuffer, ReturnedServerName, and lpResumeIndex.


--*/
{
    switch (InfoLevel) {

        case SC_ENUM_PROCESS_INFO:

            return REnumServiceGroupHelp(hSCManager,
                                         dwServiceType,
                                         dwServiceState,
                                         lpBuffer,
                                         cbBufSize,
                                         pcbBytesNeeded,
                                         lpServicesReturned,
                                         lpResumeIndex,
                                         lpLoadOrderGroup,
                                         TRUE);     // Extended enumeration

        default:
            
            return ERROR_INVALID_LEVEL;
    }
}


DWORD
REnumServiceGroupW (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCWSTR         lpLoadOrderGroup OPTIONAL
    )
/*++

Routine Description:

    This function lists the services installed in the Service Controllers
    database that belong to a specified group.  The status of each service
    is returned with the name of the service.

Arguments:

    Same as REnumServicesStatusW and one additional argument:

    lpLoadOrderGroup - Only services belonging to this group are included in
        the enumeration.  If this is NULL services are enumerated
        regardless of their group membership.

Return Value:

    Same as REnumServicesStatusW plus one more:

    ERROR_SERVICE_DOES_NOT_EXIST - the group specified by lpLoadOrderGroup
        does not exist.

--*/
{
    return REnumServiceGroupHelp(hSCManager,
                                 dwServiceType,
                                 dwServiceState,
                                 lpBuffer,
                                 cbBufSize,
                                 pcbBytesNeeded,
                                 lpServicesReturned,
                                 lpResumeIndex,
                                 lpLoadOrderGroup,
                                 FALSE);    // Regular (non-Ex) enumeration
}


DWORD
REnumServiceGroupHelp (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCWSTR         lpLoadOrderGroup OPTIONAL,
    IN      BOOL            fExtended
    )
/*++

Routine Description:

    Helper function that does the work for REnumServiceGroup,
    REnumServicesStatusW, and REnumServicesStatusExW

Arguments:

    Same as REnumServiceGroup and one additional argument

    fExtended -- TRUE if this function was called from the extended version
                 of REnumServicesStatus, FALSE if not

Return Value:

    Same as REnumServiceGroupW

--*/
{
    DWORD                         status = NO_ERROR;
    BOOL                          copyStatus;
    LPSERVICE_RECORD              serviceRecord;
    LPLOAD_ORDER_GROUP            Group = NULL;      // group being enumerated, if any
    DWORD                         resumeIndex = 0;   // resume handle value
    LPENUM_SERVICE_STATUS_WOW64   pNextEnumRec;      // next enum record
    LPENUM_SERVICE_STATUS_WOW64   pEnumRec;          // current regular enum record
    LPWSTR                        pStringBuf;        // works backwards in enum buf
    DWORD                         serviceState;      // temp state holder
    BOOL                          exitEarly = FALSE; // buffer is full - enum not done.
    BOOL                          fNoGroup  = FALSE; // enumerate services not in a group

#ifdef TIMING_TEST
    DWORD       TickCount1;
    DWORD       TickCount2;

    TickCount1 = GetTickCount();
#endif // TIMING_TEST

    SC_LOG(TRACE," Inside REnumServicesStatusW\n",0);

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //

    if (!ScIsValidScManagerHandle(hSCManager))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Check for invalid parameters. The ServiceType and Service State are
    // invalid if neither of the bit masks are set, or if any bit outside
    // of the bitmask range is set.
    //
    if (SERVICE_TYPE_MASK_INVALID(dwServiceType)) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (ENUM_STATE_MASK_INVALID(dwServiceState)) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Was the handle opened with SC_MANAGER_ENUMERATE_SERVICE access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hSCManager)->AccessGranted,
              SC_MANAGER_ENUMERATE_SERVICE
              )) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // Initialize some of the return parameters.
    //
    *lpServicesReturned = 0;
    *pcbBytesNeeded     = 0;

    if (ARGUMENT_PRESENT(lpResumeIndex)) {
        resumeIndex = *lpResumeIndex;
    }


    //
    // If a group name was specified, find the group record.
    //

    if (ARGUMENT_PRESENT(lpLoadOrderGroup)) {

        if (!IS_NOGROUP_STRING(lpLoadOrderGroup)) {

            ScGroupListLock.GetShared();
            Group = ScGetNamedGroupRecord(lpLoadOrderGroup);
            if (Group == NULL) {
                ScGroupListLock.Release();
                return(ERROR_SERVICE_DOES_NOT_EXIST);
            }
        }
        else {

            //
            // Enumerate services not in a group
            //
            fNoGroup = TRUE;
        }
    }

    //
    // Get a shared (read) lock on the database so that it cannot be changed
    // while we're gathering up data.
    //
    {
        CServiceListSharedLock LLock;
        CServiceRecordSharedLock RLock;

        //
        // Point to the start of the database.
        //

        if (!ScFindEnumStart(resumeIndex, &serviceRecord))
        {
            //
            // There are no service records beyond the resume index.
            //
            goto CleanExit;
        }

        //
        // Set up a pointer for EnumStatus Structures at the top of the
        // buffer, and Strings at the bottom of the buffer.
        //
        cbBufSize  = ROUND_DOWN_COUNT(cbBufSize, ALIGN_WCHAR);
        pEnumRec   = (LPENUM_SERVICE_STATUS_WOW64) lpBuffer;
        pStringBuf = (LPWSTR)((LPBYTE)lpBuffer + cbBufSize);

        //
        // Loop through, gathering Enum Status into the return buffer.
        //

        do
        {
            //
            // Examine the data in the service record to see if it meets the
            // criteria of the passed in keys.
            //

            //
            // Since driver state can be modified through other means than the
            // SCM, make sure we've got the most recent state information if we're
            // enumerating drivers.
            //

            if (serviceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER)
            {
                //
                // It's OK to use CServiceRecordTEMPORARYEXCLUSIVELOCK
                // because the only field of the service record that we
                // are relying on here is the SERVICE_DRIVER bits, and
                // those are never changed.
                //

                CServiceRecordTEMPORARYEXCLUSIVELOCK Lock;

                //
                // Ignore the error and don't ask for the updated info since we'll
                // use the fields in the serviceRecord below anyhow for comparisons
                // and copying.  If the call succeeded, they'll be updated already.
                // If not, we'll end up using the most recent state info we have.
                //

                ScGetDriverStatus(serviceRecord, NULL);
            }


            serviceState = SERVICE_INACTIVE;
            if (serviceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED)
            {
                serviceState = SERVICE_ACTIVE;
            }

            //
            // If the service record meets the criteria of the passed in key,
            // put its information into the return buffer.  The three checks
            // below are:
            //
            //  1.  Enumerate everything
            //  2.  Enumerate members of a certain group only, so check to see
            //      if the current service is a member of that group
            //  3.  Enumerate only services that aren't in a group, so check to
            //      see if the current service qualifies (NULL MemberOfGroup
            //      field)
            //
            if ((Group == NULL && !fNoGroup
                    || Group && Group == serviceRecord->MemberOfGroup
                    || fNoGroup && !serviceRecord->MemberOfGroup)
                &&
                ((dwServiceType & serviceRecord->ServiceStatus.dwServiceType) != 0)
                &&
                ((dwServiceState & serviceState) != 0))
            {
                //
                // Determine if there is room for any string data in the buffer.
                //

                if (fExtended)
                {
                    pNextEnumRec =
                        (LPENUM_SERVICE_STATUS_WOW64)
                            ((LPENUM_SERVICE_STATUS_PROCESS_WOW64) pEnumRec + 1);
                }
                else
                {
                    pNextEnumRec = pEnumRec + 1;
                }

                if ((LPWSTR) pNextEnumRec >= pStringBuf)
                {
                    exitEarly = TRUE;
                    break;
                }

                //
                // Copy the ServiceName string data.
                //
                copyStatus = ScCopyStringToBufferW(
                                serviceRecord->ServiceName,
                                (DWORD) wcslen(serviceRecord->ServiceName),
                                (LPWSTR) pNextEnumRec,
                                &pStringBuf,
                                (LPWSTR *) &(pEnumRec->dwServiceNameOffset),
                                lpBuffer);

                if (copyStatus == FALSE)
                {
                    SC_LOG(TRACE,
                        "REnumServicesStatusW:NetpCopyStringToBuf not enough room\n",0);
                    exitEarly = TRUE;
                    break;
                }

                //
                // Copy the DisplayName string data.
                //
                copyStatus = ScCopyStringToBufferW(
                                serviceRecord->DisplayName,
                                (DWORD) wcslen(serviceRecord->DisplayName),
                                (LPWSTR) pNextEnumRec,
                                &pStringBuf,
                                (LPWSTR *) &(pEnumRec->dwDisplayNameOffset),
                                lpBuffer);

                if (copyStatus == FALSE)
                {
                    SC_LOG(TRACE,
                        "REnumServicesStatusW:NetpCopyStringToBuf not enough room\n",0);
                    exitEarly = TRUE;
                    break;
                }
                else
                {
                    //
                    // Copy the rest of the status information.
                    //

                    LPSERVICE_STATUS_PROCESS   lpStatusEx = NULL;

                    //
                    // If we're enumerating the extended status, assign the
                    // "helper variable" and initialize the extra fields
                    //

                    if (fExtended)
                    {
                        lpStatusEx = 
                            &((LPENUM_SERVICE_STATUS_PROCESS_WOW64)pEnumRec)->ServiceStatusProcess;

                        lpStatusEx->dwProcessId    = 0;
                        lpStatusEx->dwServiceFlags = 0;
                    }

                    if (serviceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER)
                    {
                        RtlCopyMemory(&(pEnumRec->ServiceStatus),
                                      &(serviceRecord->ServiceStatus),
                                      sizeof(SERVICE_STATUS));
                    }
                    else
                    {
                        //
                        // Otherwise, just copy what is already in the service
                        // record.
                        //

                        RtlCopyMemory(
                            &(pEnumRec->ServiceStatus),
                            &(serviceRecord->ServiceStatus),
                            sizeof(SERVICE_STATUS));

                        if (fExtended)
                        {
                            //
                            // Only assign the PID and flags if there's an
                            // image record for the service.  If there's no
                            // image record, the service isn't running.
                            //
                            if (serviceRecord->ImageRecord)
                            {
                                lpStatusEx->dwProcessId = serviceRecord->ImageRecord->Pid;

                                if (serviceRecord->ImageRecord->ImageFlags 
                                    &
                                    IS_SYSTEM_SERVICE)
                                {
                                    lpStatusEx->dwServiceFlags |=
                                        SERVICE_RUNS_IN_SYSTEM_PROCESS;
                                }
                            }
                        }
                    }

                    (*lpServicesReturned)++;
                    resumeIndex = serviceRecord->ResumeNum;

                    //
                    // Get Location for next Enum Record in the return buffer.
                    // Note that since we dealt with the pointer addition on
                    // pNextEnumRec above, it doesn't matter that this is
                    // being cast to an LPENUM_SERVICE_STATUS_WOW64, even if
                    // we're returning the extended status.
                    //
                    pEnumRec = (LPENUM_SERVICE_STATUS_WOW64) pNextEnumRec;

                    //
                    // TODO:  Determine how many bytes are being marshalled.
                    //        This is only worthwhile if RPC will pack the
                    //        buffer tighter than this code does.
                    //        Since packstr loads strings from the end of
                    //        the buffer,  we end up using the whole width of
                    //        it - even if the middle is basically empty.
                    //
                }

            }

            //
            // Go to the next service record.
            //
            serviceRecord = serviceRecord->Next;
        }
        while (serviceRecord != NULL);

        //
        // If we did not enum the whole database, then
        // determine how large a buffer is needed to complete the database on
        // the next call.
        //
        if (exitEarly) {

            do {
                //
                // Examine the data in the service record to see if it meets the
                // criteria of the passed in keys.
                //

                serviceState = SERVICE_INACTIVE;
                if (serviceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                    serviceState = SERVICE_ACTIVE;
                }

                //
                // If the service record meets the criteria of the passed in key,
                // add the number of bytes to the running sum.  Note that this
                // check (and the associated rules) are the same as the one above.
                //
                if ((Group == NULL && !fNoGroup
                        || Group && Group == serviceRecord->MemberOfGroup
                        || fNoGroup && !serviceRecord->MemberOfGroup)
                    &&
                    ((dwServiceType & serviceRecord->ServiceStatus.dwServiceType) != 0)
                    &&
                    ((dwServiceState & serviceState) != 0))
                {
                    *pcbBytesNeeded += (DWORD)((fExtended ? sizeof(ENUM_SERVICE_STATUS_PROCESS_WOW64) :
                                                     sizeof(ENUM_SERVICE_STATUS_WOW64)) +
                                        WCSSIZE(serviceRecord->ServiceName) +
                                        WCSSIZE(serviceRecord->DisplayName));

                }

                //
                // Go to the next service record.
                //
                serviceRecord = serviceRecord->Next;
            }
            while (serviceRecord != NULL);

        } // exitEarly

        else {

            //
            // exitEarly == FALSE (we went through the whole database)
            //
            // If no records were read, return a successful status.
            //
            if (*lpServicesReturned == 0) {
                goto CleanExit;
            }
        }
    } // Release RLock and LLock


    //
    // Determine the proper return status.  Indicate if there is more data
    // to enumerate than would fit in the buffer.
    //
    if(*pcbBytesNeeded != 0) {
        status = ERROR_MORE_DATA;
    }

    //
    // update the ResumeHandle
    //
    if (ARGUMENT_PRESENT(lpResumeIndex)) {
        if (status == NO_ERROR) {
            *lpResumeIndex = 0;
        }
        else {
            *lpResumeIndex = resumeIndex;
        }
    }

CleanExit:

    if (ARGUMENT_PRESENT(lpLoadOrderGroup) && !IS_NOGROUP_STRING(lpLoadOrderGroup)) {
        ScGroupListLock.Release();
    }

#ifdef TIMING_TEST
    TickCount2 = GetTickCount();
    DbgPrint("\n[SC_TIMING] Time for Enum = %d\n",TickCount2-TickCount1);
#endif // TIMING_TEST

    return (status);
}


DWORD
RQueryServiceStatus(
    IN  SC_RPC_HANDLE     hService,
    OUT LPSERVICE_STATUS  lpServiceStatus
    )

/*++

Routine Description:

    This function returns the service status information maintained by
    the Service Controller.  The status information will be the last status
    information that the service reported to the Service Controller.
    The service may have just changed its status and may not have updated
    the Service Controller yet.

Arguments:

    hService - Handle obtained from a previous CreateService or OpenService
        call.

    lpServiceStatus - A pointer to a buffer to receive a SERVICE_STATUS
        information structure.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_QUERY_STATUS access.

    ERROR_INSUFFICIENT_BUFFER - The supplied output buffer is too small
        for the SERVICE_STATUS information structure.  Nothing is written
        to the supplied output buffer.

--*/
{
    LPSERVICE_RECORD    serviceRecord;
    STATUS_UNION        ServiceStatus;

    if (ScShutdownInProgress)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Was the handle opened with SERVICE_QUERY_STATUS access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              SERVICE_QUERY_STATUS
              )) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Get the Service Status from the database.
    //
    serviceRecord = ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    ServiceStatus.Regular = lpServiceStatus;

    return ScQueryServiceStatus(serviceRecord, ServiceStatus, FALSE);
}


DWORD
RQueryServiceStatusEx(
    IN      SC_RPC_HANDLE        hService,
    IN      SC_STATUS_TYPE       InfoLevel,
    OUT     LPBYTE               lpBuffer,
    IN      DWORD                cbBufSize,
    OUT     LPDWORD              pcbBytesNeeded
    )

/*++

Routine Description:

    This function is analogous to RQueryServiceStatus, but may return
    different status information about the service based on the InfoLevel
    
Arguments:

    hService       - Handle obtained from a previous CreateService or OpenService
                     call.

    InfoLevel      - An enumerated type that determines what service attributes
                     are returned:

                         SC_STATUS_PROCESS_INFO - Returns all the service information
                             from RQueryServiceStatus plus the service's PID and flags

    lpBuffer       - Buffer in which to put the status information.

    cbBufSize      - Size of the buffer, in bytes

    pcbBytesNeeded - Number of bytes needed to hold all the status information.
                     Filled in on both success and failure.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_QUERY_STATUS access.

    ERROR_INSUFFICIENT_BUFFER - The supplied output buffer is too small
        for the SERVICE_STATUS information structure.  Nothing is written
        to the supplied output buffer.

    ERROR_INVALID_PARAMETER - The cbSize field in the lpServiceStatusEx
        structure is not valid

    ERROR_INVALID_LEVEL - InfoLevel contains an unsupported value.  Note that
        this can only happen if there is a bug in RPC

--*/
{
    LPSERVICE_RECORD    serviceRecord;

    if (ScShutdownInProgress)
    {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Was the handle opened with SERVICE_QUERY_STATUS access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              SERVICE_QUERY_STATUS
              )) {

        return ERROR_ACCESS_DENIED;
    }

    //
    // Get the Service Status from the database.
    //
    serviceRecord = ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    switch (InfoLevel) {

        case SC_STATUS_PROCESS_INFO:
        {
            STATUS_UNION    ServiceStatus;

            *pcbBytesNeeded = sizeof(SERVICE_STATUS_PROCESS);

            if (cbBufSize < sizeof(SERVICE_STATUS_PROCESS)) {
                return ERROR_INSUFFICIENT_BUFFER;
            }

            ServiceStatus.Ex = (LPSERVICE_STATUS_PROCESS) lpBuffer;

            return ScQueryServiceStatus(serviceRecord, ServiceStatus, TRUE);
        }

        default:
            return ERROR_INVALID_LEVEL;
    }
}


DWORD
ScQueryServiceStatus(
    IN  LPSERVICE_RECORD ServiceRecord,
    OUT STATUS_UNION     ServiceStatus,
    IN  BOOL             fExtendedStatus
    )
/*++

Routine Description:

    This function copies the service status structure to the output
    pointer after having acquired a shared lock.

Arguments:

    ServiceRecord - Supplies a pointer to the service record.

    ServiceStatus - Receives the service status structure.

    fExtendedStatus - TRUE if the function was called from
        RQueryServiceStatusEx, FALSE otherwise

Return Value:

    None.

--*/
{
    SC_ASSERT(! ScServiceRecordLock.Have());

    //
    // Sanity check that the contents of the union are stored
    // in the same set of 4 bytes since they're both pointers
    //
    SC_ASSERT((LPBYTE)ServiceStatus.Ex == (LPBYTE)ServiceStatus.Regular);

    if (fExtendedStatus) {

        ServiceStatus.Ex->dwProcessId    = 0;
        ServiceStatus.Ex->dwServiceFlags = 0;
    }

    //
    // If this request is for a driver, call ScGetDriverStatus and return.
    //
    if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER) {

        CServiceRecordExclusiveLock RLock;

        return ScGetDriverStatus(ServiceRecord,
                                 ServiceStatus.Regular);
    }
    else {

        CServiceRecordSharedLock RLock;

        //
        // Copy the latest status into the return buffer.
        //
        RtlCopyMemory(
            ServiceStatus.Regular,
            &(ServiceRecord->ServiceStatus),
            sizeof(SERVICE_STATUS));

        if (fExtendedStatus) {

            //
            // Copy the PID and flags into the structure -- if the service
            // hasn't started yet (i.e., there's no ImageRecord), the the PID
            // and the flags will be 0
            //
            if (ServiceRecord->ImageRecord) {

                ServiceStatus.Ex->dwProcessId = ServiceRecord->ImageRecord->Pid;

                if (ServiceRecord->ImageRecord->ImageFlags & IS_SYSTEM_SERVICE) {

                    ServiceStatus.Ex->dwServiceFlags |= SERVICE_RUNS_IN_SYSTEM_PROCESS;
                }
            }
        }
    }

    return NO_ERROR;
}


DWORD
REnumDependentServicesW(
    IN      SC_RPC_HANDLE   hService,
    IN      DWORD           dwServiceState,
    OUT     LPBYTE          lpServices,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned
    )
/*++

Routine Description:

    This function enumerates the services which are dependent on the
    specified service.  The list returned is an ordered list of services
    to be stopped before the specified service can be stopped.  This
    list has to be ordered because there may be dependencies between
    the services that depend on the specified service.

Arguments:

    dwServiceState - Value so select the services to enumerate based on the
        running state.  It must be one or the bitwise OR of the following
        values:
        SERVICE_ACTIVE - enumerate services that have started.
        SERVICE_INACTIVE - enumerate services that are stopped.

    lpServices - A pointer to a buffer to receive an array of enum status
        (or service) entries.

    cbBufSize - Size of the buffer in bytes pointed to by lpBuffer.

    pcbBytesNeeded - A pointer to a location where the number of bytes
        left (to be enumerated) is to be placed.  This indicates to the
        caller how large the buffer must be in order to complete the
        enumeration with the next call.

    lpServicesReturned - A pointer to a variable to receive the number of
        of service entries returned.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in
        for the service state.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpServices, pcbServicesReturned, and
        pcbBytesNeeded.

--*/
{
    DWORD            status;
    LPSERVICE_RECORD Service;

    LPENUM_SERVICE_STATUS_WOW64 EnumRecord = (LPENUM_SERVICE_STATUS_WOW64) lpServices;
    LPWSTR                      EndOfVariableData;

    cbBufSize         = ROUND_DOWN_COUNT(cbBufSize, ALIGN_WCHAR);
    EndOfVariableData = (LPWSTR) ((DWORD_PTR) EnumRecord + cbBufSize);

    SC_LOG(TRACE," Inside REnumDependentServicesW\n",0);

    if (ScShutdownInProgress)
    {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    Service = ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    //
    // Service State is invalid if neither of the bit masks is set, or if any bit
    // outside of the bitmask range is set.
    //
    if (ENUM_STATE_MASK_INVALID(dwServiceState)) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Was the handle opened with SERVICE_ENUMERATE_DEPENDENTS access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              SERVICE_ENUMERATE_DEPENDENTS
              )) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Initialize returned values
    //
    *lpServicesReturned = 0;
    *pcbBytesNeeded = 0;

    status = NO_ERROR;

    //
    // Get a shared (read) lock on the database so that it cannot be changed
    // while we're gathering up data.
    //
    {
        CServiceRecordSharedLock RLock;

        ScEnumDependents(
            Service,
            EnumRecord,
            dwServiceState,
            lpServicesReturned,
            pcbBytesNeeded,
            &EnumRecord,
            &EndOfVariableData,
            &status
            );
    }

    if (status == NO_ERROR)
    {
        *pcbBytesNeeded = 0;
    }

    return status;
}

VOID
ScGetBootAndSystemDriverState(
    VOID
    )
/*++

Routine Description:

    This function is called once at service controller init time to get
    the latest state of boot and system drivers.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status;
    CServiceListSharedLock LLock;   // to avoid assertions

    //
    // ScGetDriverStatus assumes that the exclusive database lock is claimed.
    //
    CServiceRecordExclusiveLock RLock;

    FOR_ALL_SERVICES(Service)
    {
        if ((Service->StartType == SERVICE_BOOT_START ||
             Service->StartType == SERVICE_SYSTEM_START)

             &&

            (Service->ServiceStatus.dwServiceType == SERVICE_KERNEL_DRIVER ||
             Service->ServiceStatus.dwServiceType == SERVICE_FILE_SYSTEM_DRIVER))
        {
            status = ScGetDriverStatus(
                         Service,
                         NULL
                         );

            if (status == NO_ERROR)
            {
                if (Service->ServiceStatus.dwCurrentState == SERVICE_STOPPED
                     &&
                    ScInHardwareProfile(Service->ServiceName, CM_GETIDLIST_DONOTGENERATE))
                {
                    Service->ServiceStatus.dwControlsAccepted = 0;
                    Service->ServiceStatus.dwWin32ExitCode = ERROR_GEN_FAILURE;

                    //
                    // For popup after user has logged on to indicate that some
                    // service started at boot has failed.
                    //
                    if (Service->ErrorControl == SERVICE_ERROR_NORMAL ||
                        Service->ErrorControl == SERVICE_ERROR_SEVERE ||
                        Service->ErrorControl == SERVICE_ERROR_CRITICAL)
                    {
                        (void) ScAddFailedDriver(Service->ServiceName);
                        ScPopupStartFail = TRUE;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\lock.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lock.cxx

Abstract:

    Contains code for the Service Control Database manager.  This includes
    all the database lock routines.  This file contains the following
    classes:
        CCountingResource
        CServiceListLock
        CGroupListLock

Author:

    Anirudh Sahni (anirudhs)    09-Jan-1997

Environment:

    User Mode -Win32

Revision History:

    09-Jan-1997     AnirudhS
        Created, replacing the old locking functions in dataman.cxx.

--*/

//
// INCLUDES
//

#include "precomp.hxx"

//
// Macros
//
#define LOCK_LOG(string)    SC_LOG3(LOCKS, " %s" string " level = %ld\n", \
                                       _ShortName, _Name, CurrentLevel())

//
// Globals
//
CServiceRecordLock  ScServiceRecordLock;
CServiceListLock    ScServiceListLock;
CGroupListLock      ScGroupListLock;


/*************************************************************************/
/* CCountingResource methods                                             */
/*************************************************************************/

#if DBG
void
CCountingResource::GetShared()
{
    LOCK_LOG(" Asking for %s lock shared...");
    SC_ASSERT(!HaveExclusive());
    RtlAcquireResourceShared(&_Lock, TRUE);
    SetCurrentLevel(CurrentLevel() + 1);
    LOCK_LOG("+Acquired %s lock shared,");
}

void
CCountingResource::GetExclusive()
{
    LOCK_LOG(" Asking for %s lock exclusive...");
    SC_ASSERT(!Have() || HaveExclusive());
    RtlAcquireResourceExclusive(&_Lock, TRUE);
    SetCurrentLevel(CurrentLevel() - 1);
    LOCK_LOG("+Acquired %s lock exclusive,");
}

void
CCountingResource::MakeShared()
{
    LOCK_LOG("vConverting %s lock to shared...");
    SC_ASSERT(CurrentLevel() == -1);
    RtlConvertExclusiveToShared(&_Lock);
    SetCurrentLevel(1);
    LOCK_LOG(" Converted %s lock to shared,");
}

void
CCountingResource::MakeExclusive()
{
    // WARNING: This option is easily misused.
    LOCK_LOG(" Converting %s lock to exclusive...");
    SC_ASSERT(CurrentLevel() == 1);
    RtlConvertSharedToExclusive(&_Lock);
    SetCurrentLevel(-1);
    LOCK_LOG("^Converted %s lock to exclusive,");
}

void
CCountingResource::Release()
{
    LOCK_LOG("-Releasing %s lock...");
    SC_ASSERT(Have());
    RtlReleaseResource( &_Lock );
    if (CurrentLevel() > 0)
    {
        SetCurrentLevel(CurrentLevel() - 1);
    }
    else
    {
        SetCurrentLevel(CurrentLevel() + 1);
    }
    LOCK_LOG(" Released %s lock,");
}
#endif // DBG


/*************************************************************************/
/* CServiceListLock methods                                              */
/*************************************************************************/

#if DBG
void
CServiceListLock::GetShared()
{
    // The record lock mustn't be acquired before the list lock
    if (!Have())
    {
        SC_ASSERT(! ScServiceRecordLock.Have());
    }

    CCountingResource::GetShared();
}

void
CServiceListLock::GetExclusive()
{
    // The record lock mustn't be acquired before the list lock
    if (!Have())
    {
        SC_ASSERT(! ScServiceRecordLock.Have());
    }

    CCountingResource::GetExclusive();
}

void
CServiceListLock::Release()
{
    // We mustn't release this if we still have the record lock
    if (CurrentLevel() == 1 || CurrentLevel() == -1)
    {
        SC_ASSERT(! ScServiceRecordLock.Have());
    }

    CCountingResource::Release();
}
#endif // DBG


/*************************************************************************/
/* CGroupListLock methods                                                */
/*************************************************************************/

#if DBG
void
CGroupListLock::GetShared()
{
    // The service list lock mustn't be acquired before the group list lock
    if (!Have())
    {
        SC_ASSERT(! ScServiceListLock.Have());
    }

    CCountingResource::GetShared();
}

void
CGroupListLock::GetExclusive()
{
    // The service list lock mustn't be acquired before the group list lock
    if (!Have())
    {
        SC_ASSERT(! ScServiceListLock.Have());
    }

    CCountingResource::GetExclusive();
}

void
CGroupListLock::Release()
{
    // We mustn't release this if we still have the service list lock or
    // service record lock
    if (CurrentLevel() == 1 || CurrentLevel() == -1)
    {
        SC_ASSERT(! ScServiceRecordLock.Have());
        SC_ASSERT(! ScServiceListLock.Have());
    }

    CCountingResource::Release();
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\lock.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lock.h

Abstract:

    Contains data structures and function prototypes for the Service
    Controller's database locking functions (lock.cxx).
    This file defines the following classes:
        CCountingResource
        CServiceRecordLock
        CServiceListLock
        CGroupListLock

        CServiceRecordExclusiveLock
        CServiceRecordSharedLock
        CServiceRecordTEMPORARYEXCLUSIVELOCK
        CServiceListExclusiveLock
        CServiceListSharedLock
        CGroupListExclusiveLock
        CGroupListSharedLock

Author:

    Anirudh Sahni (anirudhs)    09-Jan-1997

Environment:

    User Mode -Win32

Revision History:

    09-Jan-1997     AnirudhS
        Created, replacing the old locking functions in dataman.h.

--*/

#ifndef _LOCK_INCLUDED_
#define _LOCK_INCLUDED_

//+-------------------------------------------------------------------------
//
//  Class:      CCountingResource
//
//  Purpose:    This is an RTL_RESOURCE that, in the checked build, knows
//              its locking level for the current thread.  The locking
//              level is stored in a TLS (thread local storage) slot.  A
//              positive value indicates a shared lock on the resource and
//              a negative value indicates an exclusive lock, with the
//              absolute value indicating the number of recursive
//              acquisitions of the lock.
//
//  History:    09-Jan-97 AnirudhS  Created.
//
//--------------------------------------------------------------------------

class CCountingResource
{
public:

    void Initialize(LPCSTR ShortName, LPCSTR Name)
                        {
                            RtlInitializeResource(&_Lock);
                            #if DBG
                                _TlsIndex = TlsAlloc();
                                SC_ASSERT(_TlsIndex != 0xFFFFFFFF);
                                _ShortName = ShortName;
                                _Name = Name;
                            #endif
                        }
    void Delete()       { RtlDeleteResource(&_Lock); }

#if DBG
    void GetShared();
    void GetExclusive();
    void MakeShared();
    void Release();

    BOOL Have() const   { return (CurrentLevel() != 0); }
    BOOL HaveExclusive() const
                        { return (CurrentLevel() < 0); }
#else
    void GetShared()    { RtlAcquireResourceShared(&_Lock, TRUE); }
    void GetExclusive() { RtlAcquireResourceExclusive(&_Lock, TRUE); }
    void MakeShared()   { RtlConvertExclusiveToShared(&_Lock); }
    void Release()      { RtlReleaseResource(&_Lock); }
#endif

protected:

#if DBG
    void MakeExclusive();

    LONG CurrentLevel() const
                        { return (LONG)(LONG_PTR)(TlsGetValue(_TlsIndex)); }
    void SetCurrentLevel(LONG Level)
                        { SC_ASSERT(TlsSetValue(_TlsIndex, (PVOID)(LONG_PTR) Level) != 0); }
#else
    void MakeExclusive()
                        { RtlConvertSharedToExclusive(&_Lock); }
#endif

private:

#if DBG
    DWORD        _TlsIndex;
    LPCSTR       _ShortName;
    LPCSTR       _Name;
#endif

    RTL_RESOURCE _Lock;
};


//+-------------------------------------------------------------------------
//
//  Class:      CServiceRecordLock, CServiceListLock, CGroupListLock
//
//  Purpose:    These three locks are used to synchronize multithreaded
//              access to the service controller's database.  Each lock
//              allows single-writer/multiple-reader access to a particular
//              aspect of the database.
//
//              These are implemented as three separate classes with one
//              instance each, rather than three instances of one class,
//              because their implementations in the debug build differ
//              substantially from one another.
//
//              The Service List lock is used to synchronize access to the
//              linked list pointers (Prev and Next fields) of the
//              SERVICE_RECORDs in the database.  While a thread holds this
//              lock, no other thread can add or delete SERVICE_RECORDs.
//
//              The Service Record lock is used to synchronize access to
//              the "contents" (other fields) of the SERVICE_RECORDs.
//
//              In order to delete a service record, both the service list
//              lock and the service record lock must be held exclusively.
//              Consequently if a thread is only working with a particular
//              service record (not walking the list of service records),
//              it is sufficient for that thread to hold the service record
//              lock in order to be assured that no other thread will
//              delete that service record.
//
//              The Group List lock is used to synchronize access to the
//              LOAD_ORDER_GROUPs in the database (both contents and
//              pointers).
//
//              To avoid deadlocks, the locks are always acquired in the
//              following order, if more than one is needed:
//              1. Group List lock (if needed)
//              2. Service List lock (if needed)
//              3. Service Record lock (if needed)
//
//  History:    09-Jan-97 AnirudhS  Created.
//
//--------------------------------------------------------------------------

class CServiceRecordLock : public CCountingResource
{
public:

    //
    // This method's name is capitalized to draw attention to its use,
    // because it is easily misunderstood and misused.  It does not hold
    // on to the shared lock while converting it to exclusive.  Instead,
    // it first releases the shared lock and then acquires the exclusive
    // lock.
    //
    void MAKEEXCLUSIVE() { CCountingResource::MakeExclusive(); }
};


class CServiceListLock : public CCountingResource
{
public:

#if DBG
    void GetShared();
    void GetExclusive();
    void Release();
#endif
};


class CGroupListLock : public CCountingResource
{
public:

#if DBG
    void GetShared();
    void GetExclusive();
    void Release();
#endif
};


//
// Globals
//
extern CServiceRecordLock   ScServiceRecordLock;
extern CServiceListLock     ScServiceListLock;
extern CGroupListLock       ScGroupListLock;


//+-------------------------------------------------------------------------
//
// Safe wrapper classes that ensure that the Release method is called
//
// Use of these classes ensures proper, disciplined access to the locks.
// In general, the locks should be acquired and released through these
// safe classes only.  Any direct access to the locks should be viewed
// with suspicion.
//
//--------------------------------------------------------------------------

class CServiceRecordExclusiveLock
{
public:
    CServiceRecordExclusiveLock()   { ScServiceRecordLock.GetExclusive(); }
   ~CServiceRecordExclusiveLock()   { ScServiceRecordLock.Release(); }
};

class CServiceRecordSharedLock
{
public:
    CServiceRecordSharedLock()      { ScServiceRecordLock.GetShared(); }
   ~CServiceRecordSharedLock()      { ScServiceRecordLock.Release(); }
};


//
// Use this one with caution -- see the note above about MAKEEXCLUSIVE.
//
class CServiceRecordTEMPORARYEXCLUSIVELOCK
{
public:
    CServiceRecordTEMPORARYEXCLUSIVELOCK()
                                    { ScServiceRecordLock.MAKEEXCLUSIVE(); }
   ~CServiceRecordTEMPORARYEXCLUSIVELOCK()
                                    { ScServiceRecordLock.MakeShared(); }
};


class CServiceListExclusiveLock
{
public:
    CServiceListExclusiveLock()     { ScServiceListLock.GetExclusive(); }
   ~CServiceListExclusiveLock()     { ScServiceListLock.Release(); }
};

class CServiceListSharedLock
{
public:
    CServiceListSharedLock()        { ScServiceListLock.GetShared(); }
   ~CServiceListSharedLock()        { ScServiceListLock.Release(); }
};


class CGroupListExclusiveLock
{
public:
    CGroupListExclusiveLock()       { ScGroupListLock.GetExclusive(); }
   ~CGroupListExclusiveLock()       { ScGroupListLock.Release(); }
};

class CGroupListSharedLock
{
public:
    CGroupListSharedLock()          { ScGroupListLock.GetShared(); }
   ~CGroupListSharedLock()          { ScGroupListLock.Release(); }
};


#endif // ifndef _LOCK_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\lockapi.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    LockAPI.cxx

Abstract:

    This file contains the Service Controller's lock APIs:

        RLockServiceDatabase
        RQueryServiceLockStatusW
        RUnlockServiceDatabase
        SC_RPC_LOCK_rundown

Author:

    John Rogers (JohnRo) 14-Apr-1992

Environment:

    User Mode - Win32

Revision History:

    26-Mar-1992 danl
        Created the stubbed out version for RPC.
    17-Apr-1992 JohnRo
        Split lock APIs out from config API stubs in CfgAPI.c.
        Did initial coding of all lock APIs.
    22-Apr-1992 JohnRo
        Made changes suggested by PC-LINT.
        Use SC_LOG0(), etc.
    06-Aug-1992 ritaw
        Completed the code.

--*/


//
// INCLUDES
//

#include "precomp.hxx"
extern "C" {
#include <ntlsa.h>      // LsaLookupSids
}
#include <stdlib.h>     // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <sclib.h>      // ScCopyStringToBufferW().
#include <time.h>       // time().
#include "account.h"    // SCDOMAIN_USERNAME_SEPARATOR
#include "lockapi.h"    // ScLockDatabase
#include "scsec.h"      // ScGetClientSid

#define SC_MANAGER_USERNAME    L".\\NT Service Control Manager"


#define ScDatabaseNamesMatch(a,b)  (_wcsicmp( (a), (b) ) == 0)


// Macros to lock and unlock the lock list:


#define LOCK_API_LOCK_LIST_SHARED( comment ) \
    { \
        ScServiceRecordLock.GetShared(); \
    }

#define LOCK_API_LOCK_LIST_EXCLUSIVE( comment ) \
    { \
        ScServiceRecordLock.GetExclusive(); \
    }

#define UNLOCK_API_LOCK_LIST( comment ) \
    { \
        ScServiceRecordLock.Release(); \
    }


typedef struct _API_LOCK {
    struct _API_LOCK    *Prev;
    struct _API_LOCK    *Next;
    DWORD               Signature;         // Must be API_LOCK_SIGNATURE.
    LPWSTR              DatabaseName;
    time_t              TimeWhenLocked;    // seconds since 1970.
    PSID                LockOwnerSid;      // SID.  It is NULL if SC
                                           //     Manager grabbed the lock
} API_LOCK, *PAPI_LOCK, *LPAPI_LOCK;

#define API_LOCK_SIGNATURE      0x4C697041 // "ApiL" in ASCII.

//
// List of API_LOCK structures.  This list is locked by the macros above.
//
LPAPI_LOCK ScGlobalApiLockList = NULL;


DWORD
ScCreateLock(
    IN  BOOL IsServiceController,
    IN  LPWSTR DatabaseName,
    IN  PSID UserSid OPTIONAL,
    OUT LPSC_RPC_LOCK lpLock
    );


#if DBG
VOID
ScDumpLockList(
    VOID
    );
#endif


LPAPI_LOCK
ScFindApiLockForDatabase(
    IN      LPWSTR          DatabaseName
    )
/*++

Routine Description:


Arguments:


Return Value:

    Pointer to entry in the list (or NULL if not found).

Note:

    The caller must have a lock (shared or exclusive) for the api lock list.

--*/
{
    LPAPI_LOCK          apiLockEntry;

    apiLockEntry = ScGlobalApiLockList;
    while (apiLockEntry != NULL) {
        SC_ASSERT( apiLockEntry->Signature == API_LOCK_SIGNATURE );
        if (ScDatabaseNamesMatch( DatabaseName, apiLockEntry->DatabaseName) ) {
            return (apiLockEntry);
        }
        apiLockEntry = apiLockEntry->Next;
    }

    return (NULL);
}


DWORD
RLockServiceDatabase(
    IN      SC_RPC_HANDLE   hSCManager,
    OUT     LPSC_RPC_LOCK   lpLock
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD               status;
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hSCManager;


    SC_ASSERT( lpLock != NULL );

    *lpLock = NULL;
    if ( !ScIsValidScManagerHandle( hSCManager ) ) {
        return (ERROR_INVALID_HANDLE);
    }

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              SC_MANAGER_LOCK
              )) {
        return (ERROR_ACCESS_DENIED);
    }

    status = ScLockDatabase(
                 FALSE,
                 serviceHandleStruct->Type.ScManagerObject.DatabaseName,
                 lpLock
                 );

    SC_LOG0( LOCK_API, "Database Lock is ON (from API)\n");

    return status;
}


DWORD
RQueryServiceLockStatusW(
    IN  SC_RPC_HANDLE                   hSCManager,
    OUT LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    IN  DWORD                           cbBufSize,
    OUT LPDWORD                         pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD status;

    LPAPI_LOCK          apiLockEntry;
    DWORD               allocSize;
    LPWSTR              databaseName;

    LPWSTR              endOfVariableData;
    LPWSTR              fixedDataEnd;

    LPWSTR              lockOwner;
    DWORD               lockOwnerSize;

    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hSCManager;


    if ( !ScIsValidScManagerHandle( hSCManager ) ) {
        return (ERROR_INVALID_HANDLE);
    } else if (lpLockStatus == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (pcbBytesNeeded == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Do we have permission to do this?
    //
    if ( !RtlAreAllAccessesGranted(
              serviceHandleStruct->AccessGranted,
              SC_MANAGER_QUERY_LOCK_STATUS
              )) {
        return (ERROR_ACCESS_DENIED);
    }

    LOCK_API_LOCK_LIST_SHARED( "RQueryServiceLockStatusW start" );

    databaseName = serviceHandleStruct->Type.ScManagerObject.DatabaseName;
    SC_ASSERT( databaseName != NULL );


    apiLockEntry = ScFindApiLockForDatabase( databaseName );


    if (apiLockEntry == NULL) {

        allocSize = sizeof(QUERY_SERVICE_LOCK_STATUSW) + sizeof(WCHAR);

        *pcbBytesNeeded = allocSize;

        if (cbBufSize < allocSize) {
            UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW too small" );
            return (ERROR_INSUFFICIENT_BUFFER);
        }

        lpLockStatus->fIsLocked = FALSE;

        fixedDataEnd = (LPWSTR) (lpLockStatus + 1);

        endOfVariableData = (LPWSTR) ((LPBYTE)lpLockStatus + allocSize);

        if (! ScCopyStringToBufferW (
                NULL,
                0,
                fixedDataEnd,
                &endOfVariableData,
                &lpLockStatus->lpLockOwner,
                NULL
                )) {

            SC_ASSERT( FALSE );
        }

        lpLockStatus->dwLockDuration = 0;

        UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW not found" );
        return (NO_ERROR);
    }


    SC_ASSERT( apiLockEntry->Signature == API_LOCK_SIGNATURE );

    status = ScGetLockOwner(
                 apiLockEntry->LockOwnerSid,
                 &lockOwner
                 );

    if (status != NO_ERROR) {
        UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW failed get owner" );
        return status;
    }

    lockOwnerSize = (DWORD) WCSSIZE(lockOwner);

    SC_ASSERT( lockOwnerSize > 2 );        //  min is ".\x" (domain\user).

    allocSize = sizeof(QUERY_SERVICE_LOCK_STATUSW) + lockOwnerSize;

    *pcbBytesNeeded = allocSize;

    if (allocSize > cbBufSize) {

        LocalFree(lockOwner);
        UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW too small" );
        return (ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // Build the QUERY_SERVICE_LOCK_STATUS structure.
    //
    lpLockStatus->fIsLocked = TRUE;

    lpLockStatus->dwLockDuration =
            (DWORD)(time(NULL) - apiLockEntry->TimeWhenLocked);

    fixedDataEnd = (LPWSTR) (lpLockStatus + 1);

    endOfVariableData = (LPWSTR) ((LPBYTE)lpLockStatus + allocSize);

    if (! ScCopyStringToBufferW (
             lockOwner,
             (DWORD) wcslen(lockOwner),
             fixedDataEnd,
             &endOfVariableData,
             &lpLockStatus->lpLockOwner,
             NULL
             )) {

        SC_ASSERT( FALSE );
    }

    LocalFree(lockOwner);

    UNLOCK_API_LOCK_LIST( "RQueryServiceLockStatusW done" );

    return (NO_ERROR);
}


DWORD
RUnlockServiceDatabase(
    IN OUT  LPSC_RPC_LOCK   lpLock
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    LPAPI_LOCK apiLockEntry;

    if (lpLock == NULL) {
        return (ERROR_INVALID_SERVICE_LOCK);
    }
    apiLockEntry = * (LPAPI_LOCK *) (LPVOID) lpLock;
    if (apiLockEntry->Signature != API_LOCK_SIGNATURE) {
        SC_LOG1( ERROR, "RUnlockServiceDatabase: lock w/o signature at "
                FORMAT_LPVOID "\n", (LPVOID) lpLock );
        return (ERROR_INVALID_SERVICE_LOCK);
    }

    //
    // We're going to update the linked list, so keep other threads out.
    //
    LOCK_API_LOCK_LIST_EXCLUSIVE( "RUnlockServiceDatabase start" );

    //
    // Remove the entry from the lock list.  This has the effect of
    // unlocking this database.
    //
    if (apiLockEntry->Prev != NULL) {
        apiLockEntry->Prev->Next = apiLockEntry->Next;
    }
    if (apiLockEntry->Next != NULL) {
        apiLockEntry->Next->Prev = apiLockEntry->Prev;
    }
    if ( (apiLockEntry->Next == NULL) && (apiLockEntry->Prev == NULL) ) {
        ScGlobalApiLockList = NULL;
    }

    //
    // Free the storage we allocated for this entry.
    //
    LocalFree( apiLockEntry );
    *lpLock = NULL;

#if DBG
    ScDumpLockList();
#endif

    //
    // OK, it's safe for other threads to muck with the lock list.
    //
    UNLOCK_API_LOCK_LIST( "RUnlockServiceDatabase done" );

    SC_LOG0( LOCK_API,"Database Lock is OFF (from API)\n");

    return(NO_ERROR);
}


VOID
SC_RPC_LOCK_rundown(
    SC_RPC_LOCK     lock
    )

/*++

Routine Description:

    This function is called by RPC when a connection is broken that had
    an outstanding context handle.  The value of the context handle is
    passed in here so that we have an opportunity to clean up.

Arguments:

    lock - This is the handle value of the context handle that is broken.

Return Value:

    none.

--*/
{
    RUnlockServiceDatabase(&lock);
}


VOID
ScUnlockDatabase(
    IN OUT LPSC_RPC_LOCK lpLock
    )
/*++

Routine Description:

    This function is called by internally by ScStartServiceAndDependencies
    to unlock the SC Manager database lock when it is done starting
    services.

Arguments:

    lpLock - Supplies the address of the pointer to the lock structure.
        On output, the pointer is set to NULL.

Return Value:

    None.

--*/
{
    RUnlockServiceDatabase(lpLock);
}


DWORD
ScLockDatabase(
    IN  BOOL IsServiceController,
    IN  LPWSTR DatabaseName,
    OUT LPSC_RPC_LOCK lpLock
    )
/*++

Routine Description:

    This function grabs the external database lock which is used
    by setup programs to ensure serialization to the services'
    configuration.

    It is also called by the service controller itself from
    ScStartServiceAndDependencies.  We need to grab the database lock
    internally when starting services so that setup programs know
    that when is an unsafe time to modify service configuration.

    When called by the service controller itself, the SID is not
    looked up.

Arguments:

    IsServiceController - Supplies a flag which is TRUE if this routine
        is called by the service controller; FALSE all other times.

    DatabaseName - Supplies the name of the database which the lock
        is to be acquired.

    lpLock - Receives a pointer to the lock entry created.


Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD               status;
    LPAPI_LOCK          apiLockEntry;
    PTOKEN_USER         UserInfo = NULL;


    SC_ASSERT(DatabaseName != NULL);

    LOCK_API_LOCK_LIST_EXCLUSIVE( "ScLockDatabase start" );

    //
    // Check for another lock.
    //
    apiLockEntry = ScFindApiLockForDatabase(DatabaseName);

    if (apiLockEntry != NULL) {
        UNLOCK_API_LOCK_LIST( "ScLockDatabase already locked" );
        SC_LOG0(LOCK_API, "ScLockDatabase: Database is already locked\n");
        return ERROR_SERVICE_DATABASE_LOCKED;
    }

    if (! IsServiceController) {
        //
        // Get the caller's SID
        //
        if ((status = ScGetClientSid(
                          &UserInfo
                          )) != NO_ERROR) {
            UNLOCK_API_LOCK_LIST( "ScLockDatabase ScGetClientSid failed" );
            return status;
        }

        status = ScCreateLock(
                     FALSE,                // Non-ScManager caller to grab lock
                     DatabaseName,
                     UserInfo->User.Sid,
                     lpLock
                     );

        LocalFree(UserInfo);
    }
    else {
        status = ScCreateLock(
                     TRUE,                 // ScManager caller to grab lock
                     DatabaseName,
                     NULL,
                     lpLock
                     );
    }

#if DBG
    ScDumpLockList();
#endif

    UNLOCK_API_LOCK_LIST("ScLockDatabase done");

    return status;
}


DWORD
ScCreateLock(
    IN  BOOL IsServiceController,
    IN  LPWSTR DatabaseName,
    IN  PSID UserSid OPTIONAL,
    OUT LPSC_RPC_LOCK lpLock
    )
/*++

Routine Description:

    This function is creates a lock entry, fills in the information about
    the nature of the lock and insert it into the lock list.

Arguments:

    IsServiceController - Supplies a flag which is TRUE if this routine
        is called by the service controller; FALSE all other times.

    DatabaseName - Supplies the name of the database which the lock
        is to be acquired.

    UserSid - Supplies the SID of the caller to claim the lock.  This
        is NULL if IsServiceController is TRUE.

    lpLock - Receives a pointer to the lock entry created.


Return Value:

    NO_ERROR or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    DWORD allocSize;
    LPAPI_LOCK newLockEntry;
    LPAPI_LOCK apiLockEntry;


    //
    // Build a structure to describe this lock.
    //
    if (IsServiceController) {
        allocSize = sizeof(API_LOCK) + (DWORD) WCSSIZE(DatabaseName);
    }
    else {
        if (! ARGUMENT_PRESENT(UserSid)) {
            SC_LOG0(ERROR, "ScCreateLock: UserSid is NULL!\n");
            SC_ASSERT(FALSE);
            return ERROR_GEN_FAILURE;
        }

        allocSize = sizeof(API_LOCK) + (DWORD) WCSSIZE(DatabaseName)
                    + RtlLengthSid(UserSid);
    }

    newLockEntry = (LPAPI_LOCK) LocalAlloc( LMEM_ZEROINIT, (UINT) allocSize );

    if (newLockEntry == NULL) {
        SC_LOG1(ERROR,"ScCreateLock: Local Alloc FAILED "
                FORMAT_DWORD "\n", GetLastError());
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    SC_LOG3(LOCK_API,"ScCreateLock: alloc'ed " FORMAT_DWORD
            " bytes at " FORMAT_LPVOID "  Sid-size " FORMAT_DWORD ".\n",
            allocSize, (LPVOID) newLockEntry,
            (UserSid) ? RtlLengthSid(UserSid) : 0);


    //
    // Fill in fields of new lock entry
    //
    newLockEntry->Signature = API_LOCK_SIGNATURE;

    newLockEntry->DatabaseName = (LPWSTR) (newLockEntry + 1);
    wcscpy(newLockEntry->DatabaseName, DatabaseName);


    if (ARGUMENT_PRESENT(UserSid)) {
        newLockEntry->LockOwnerSid = (PSID) ((DWORD_PTR) newLockEntry->DatabaseName +
                                             WCSSIZE(DatabaseName));


        SC_LOG1(LOCK_API, "ScCreateLock: Before RtlCopySid, bytes left "
                FORMAT_DWORD "\n", ((DWORD_PTR) newLockEntry + allocSize) -
                (DWORD_PTR) newLockEntry->LockOwnerSid);

        ntstatus = RtlCopySid(
                       (ULONG)(((DWORD_PTR) newLockEntry + allocSize) - (DWORD_PTR) newLockEntry->LockOwnerSid),
                       newLockEntry->LockOwnerSid,
                       UserSid
                       );

        if (! NT_SUCCESS(ntstatus)) {
            SC_LOG1(ERROR, "ScCreateLock: RtlCopySid failed " FORMAT_NTSTATUS
                    "\n", ntstatus);

            LocalFree(newLockEntry);
            return RtlNtStatusToDosError(ntstatus);
        }
    }
    else {
        newLockEntry->LockOwnerSid = (PSID) NULL;
    }

    newLockEntry->TimeWhenLocked = (DWORD) time( NULL );

    //
    // Record this lock.
    //
    if (ScGlobalApiLockList != NULL) {

        //
        // List is not empty, so just add to end.
        //
        apiLockEntry = ScGlobalApiLockList;
        ADD_TO_LIST( apiLockEntry, newLockEntry );

    } else {

        //
        // List is empty, so start with this (new) entry.
        //
        ScGlobalApiLockList = newLockEntry;
        newLockEntry->Next = NULL;
        newLockEntry->Prev = NULL;
    }

    *lpLock = newLockEntry;

    return NO_ERROR;
}




DWORD
ScGetLockOwner(
    IN  PSID UserSid OPTIONAL,
    OUT LPWSTR *LockOwnerName
    )
{

    DWORD status = NO_ERROR;
    NTSTATUS ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;
    LSA_HANDLE PolicyHandle;

    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomain = NULL;
    PLSA_TRANSLATED_NAME Name = NULL;

    NT_PRODUCT_TYPE ProductType;


    if (! ARGUMENT_PRESENT(UserSid)) {

        *LockOwnerName = (LPWSTR)LocalAlloc(
                             LMEM_ZEROINIT,
                             WCSSIZE(SC_MANAGER_USERNAME)
                             );

        if (*LockOwnerName == NULL) {
            SC_LOG1(ERROR, "ScGetLockOwner: LocalAlloc failed " FORMAT_DWORD
                    "\n", GetLastError());

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*LockOwnerName, SC_MANAGER_USERNAME);

        return NO_ERROR;
    }

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    ntstatus = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   POLICY_LOOKUP_NAMES,
                   &PolicyHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG(ERROR, "ScGetLockOwner: LsaOpenPolicy returned " FORMAT_NTSTATUS
                     "\n", ntstatus);
        return RtlNtStatusToDosError(ntstatus);
    }

    //
    // Get the name of the specified SID
    //
    ntstatus = LsaLookupSids(
                   PolicyHandle,
                   1,
                   &UserSid,
                   &ReferencedDomain,
                   &Name
                   );

    if (! NT_SUCCESS(ntstatus))
    {
        SC_LOG(ERROR, "ScGetLockOwner: LsaLookupNames returned " FORMAT_NTSTATUS
                     "\n", ntstatus);

        status = RtlNtStatusToDosError(ntstatus);
        goto CleanExit;
    }

    if (ReferencedDomain == NULL || Name == NULL)
    {
        SC_LOG2(ERROR, "ScGetLockOwner: ReferencedDomain=%08lx, Name=%08lx\n",
                ReferencedDomain, Name);

        status = ERROR_GEN_FAILURE;
        goto CleanExit;
    }
    else
    {
        LPWSTR Ptr;


        if (Name->Use == SidTypeUnknown || Name->Use == SidTypeInvalid) {
            SC_LOG0(ERROR, "ScGetLockOwner: Sid is unknown or invalid\n");
            status = ERROR_GEN_FAILURE;
            goto CleanExit;
        }

        if (Name->DomainIndex < 0) {
            SC_LOG1(ERROR, "ScGetLockOwner: DomainIndex is negative %ld\n",
                    Name->DomainIndex);
            status = ERROR_GEN_FAILURE;
            goto CleanExit;
        }

        if (ReferencedDomain->Entries == 0) {
            SC_LOG0(ERROR, "ScGetLockOwner: No ReferencedDomain entry\n");
            status = ERROR_GEN_FAILURE;
            goto CleanExit;
        }

        *LockOwnerName = (LPWSTR)LocalAlloc(
                             LMEM_ZEROINIT,
                             Name->Name.Length +
                             ReferencedDomain->Domains[Name->DomainIndex].Name.Length +
                             2 * sizeof(WCHAR)
                             );

        if (*LockOwnerName == NULL) {
            SC_LOG1(ERROR, "ScGetLockOwner: LocalAlloc failed " FORMAT_DWORD
                    "\n", GetLastError());

            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }

        if (! RtlGetNtProductType(&ProductType)) {
            status = GetLastError();
            SC_LOG1(ERROR, "ScGetLockOwner: RtlGetNtProductType failed "
                    FORMAT_DWORD "\n", status);
            LocalFree(*LockOwnerName);
            goto CleanExit;
        }

        if (ProductType != NtProductLanManNt) {

            status = ScGetAccountDomainInfo();

            if (status != NO_ERROR) {
                LocalFree(*LockOwnerName);
                goto CleanExit;
            }

            if (RtlEqualUnicodeString(
                    &(ReferencedDomain->Domains[Name->DomainIndex].Name),
                    &ScAccountDomain,
                    TRUE
                    )
                ||

                RtlEqualUnicodeString(
                    &(ReferencedDomain->Domains[Name->DomainIndex].Name),
                    &ScComputerName,
                    TRUE
                    )

                ) {

               //
               // We are WinNT and the user who has the lock is logged on to
               // a local account.  Convert the local domain name to "."
               //
               wcscpy(*LockOwnerName, SC_LOCAL_DOMAIN_NAME);
            }
            else {
                goto ReturnRefDomain;
            }

        }
        else {

ReturnRefDomain:
            memcpy(
                *LockOwnerName,
                ReferencedDomain->Domains[Name->DomainIndex].Name.Buffer,
                ReferencedDomain->Domains[Name->DomainIndex].Name.Length
                );

        }

        Ptr = *LockOwnerName + wcslen(*LockOwnerName);

        *Ptr = SCDOMAIN_USERNAME_SEPARATOR;

        Ptr++;

        memcpy(
            Ptr,
            Name->Name.Buffer,
            Name->Name.Length
            );
    }

CleanExit:

    if (ReferencedDomain != NULL) {
        LsaFreeMemory(ReferencedDomain);
    }

    if (Name != NULL) {
        LsaFreeMemory(Name);
    }

    LsaClose(PolicyHandle);

    return status;
}

#if DBG
VOID
ScDumpLockList(
    VOID
    )
{

    LPAPI_LOCK LockEntry = ScGlobalApiLockList;
    LPWSTR LockOwner;


    if (LockEntry == NULL) {
        KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_LOCK_API, "\nLock list is NULL\n"));

        return;
    }

    KdPrintEx((DPFLTR_SCSERVER_ID, DEBUG_LOCK_API, "\nScDumpLockList:\n"));

    while (LockEntry != NULL) {

        if (ScGetLockOwner(LockEntry->LockOwnerSid, &LockOwner) == NO_ERROR) {

            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_LOCK_API,
                       "LockOwner:    " FORMAT_LPWSTR "\n",
                       LockOwner));

            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_LOCK_API,
                       "LockDuration: " FORMAT_DWORD "\n",
                       ((DWORD)time(NULL)) - LockEntry->TimeWhenLocked));

            KdPrintEx((DPFLTR_SCSERVER_ID,
                       DEBUG_LOCK_API,
                       "LockDatabase: " FORMAT_LPWSTR "\n",
                       LockEntry->DatabaseName));

            LocalFree(LockOwner);
        }

        LockEntry = LockEntry->Next;
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\lockapi.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    lockapi.h

Abstract:

    SC Manager database lock worker routines.

Author:

    Rita Wong (ritaw)     06-Aug-1992

Revision History:

--*/

#ifndef SCLOCKAPI_INCLUDED
#define SCLOCKAPI_INCLUDED

//
// Function Prototypes
//

DWORD
ScLockDatabase(
    IN  BOOL LockedByScManager,
    IN  LPWSTR DatabaseName,
    OUT LPSC_RPC_LOCK lpLock
    );

VOID
ScUnlockDatabase(
    IN OUT LPSC_RPC_LOCK lpLock
    );

DWORD
ScGetLockOwner(
    IN  PSID UserSid OPTIONAL,
    OUT LPWSTR *LockOwnerName
    );

#endif // #ifndef SCLOCKAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\ncevents.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
// NCEvents.h
//
// This file is the interface to using non-COM events within ESS.
//

#pragma once

/*
#ifdef __cplusplus
extern "C" {
#endif
*/

BOOL InitNCEvents();
void DeinitNCEvents();
BOOL WINAPI NCFireEvent(DWORD dwIndex, ...);
BOOL WINAPI NCIsEventActive(DWORD dwIndex);


/*
#ifdef __cplusplus
}
#endif
*/

// Use this index with g_hNCEvents
enum NCE_INDEX
{
    NEVENT_BAD_ACCOUNT_NAME,
    NEVENT_CALL_TO_FUNCTION_FAILED,
    NEVENT_CALL_TO_FUNCTION_FAILED_II,
    NEVENT_FIRST_LOGON_FAILED,
    NEVENT_REVERTED_TO_LASTKNOWNGOOD,
    NEVENT_CONNECTION_TIMEOUT,
    NEVENT_READFILE_TIMEOUT,
    NEVENT_TRANSACT_TIMEOUT,
    NEVENT_TRANSACT_INVALID,
    NEVENT_SERVICE_CRASH,
    NEVENT_SERVICE_CRASH_NO_ACTION,
    NEVENT_SERVICE_NOT_INTERACTIVE,
    NEVENT_SERVICE_RECOVERY_FAILED,
    NEVENT_INVALID_DRIVER_DEPENDENCY,
    NEVENT_SERVICE_START_FAILED,
    NEVENT_CIRCULAR_DEPENDENCY_DEMAND,
    NEVENT_CIRCULAR_DEPENDENCY_AUTO,
    NEVENT_SERVICE_START_FAILED_NONE,
    NEVENT_SERVICE_START_FAILED_II,
    NEVENT_DEPEND_ON_LATER_SERVICE,
    NEVENT_SERVICE_START_FAILED_GROUP,
    NEVENT_DEPEND_ON_LATER_GROUP,
    NEVENT_SERVICE_START_HUNG,
    NEVENT_SEVERE_SERVICE_FAILED,
    NEVENT_TAKE_OWNERSHIP,
    NEVENT_BAD_SERVICE_STATE,
    NEVENT_SERVICE_EXIT_FAILED,
    NEVENT_SERVICE_EXIT_FAILED_SPECIFIC,
    NEVENT_BOOT_SYSTEM_DRIVERS_FAILED,
    NEVENT_SERVICE_CONTROL_SUCCESS,
    NEVENT_SERVICE_STATUS_SUCCESS,
    NEVENT_SERVICE_CONFIG_BACKOUT_FAILED,
    NEVENT_FIRST_LOGON_FAILED_II,
    NEVENT_SERVICE_DIFFERENT_PID_CONNECTED,

    NCE_InvalidIndex // This should always be the last one.
};


#define ScLogEvent  NCFireEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\ncevents.cxx ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
// NCEvents.h
//
// This file is the interface to using non-COM events.
//

#include "precomp.hxx"
#include "NCObjAPI.h"
#include "NCEvents.h"

#define NUM_NC_EVENTS       NCE_InvalidIndex
#define MAX_BUFFER_SIZE     32000
#define SEND_LATENCY        100

static HANDLE g_hConnection;
HANDLE g_hNCEvents[NUM_NC_EVENTS];

LPCWSTR szEventSetup[NUM_NC_EVENTS * 2] =
{
    L"MSFT_NetBadAccount",
    L"",

    L"MSFT_NetCallToFunctionFailed",
    L"FunctionName!s! Error!u!",

    L"MSFT_NetCallToFunctionFailedII",
    L"FunctionName!s! Argument!s! Error!u!",

    L"MSFT_NetFirstLogonFailed",
    L"Error!u!",

    L"MSFT_NetRevertedToLastKnownGood",
    L"",

    L"MSFT_NetConnectionTimeout",
    L"Milliseconds!u! Service!s!",

    L"MSFT_NetReadfileTimeout",
    L"Milliseconds!u!",

    L"MSFT_NetTransactTimeout",
    L"Milliseconds!u! Service!s!",

    L"MSFT_NetTransactInvalid",
    L"",

    L"MSFT_NetServiceCrash",
    L"Service!s! TimesFailed!u! ActionDelay!u! ActionType!u! Action!s!",

    L"MSFT_NetServiceCrashNoAction",
    L"Service!s! TimesFailed!u!",

    L"MSFT_NetServiceNotInteractive",
    L"Service!s!",

    L"MSFT_NetServiceRecoveryFailed",
    L"ActionType!u! Action!s! Service!s! Error!u!",

    L"MSFT_NetInvalidDriverDependency",
    L"Driver!s!",

    L"MSFT_NetServiceStartFailed",
    L"Service!s! Error!u!",

    L"MSFT_NetCircularDependencyDemand",
    L"Service!s!",

    L"MSFT_NetCircularDependencyAuto",
    L"",

    L"MSFT_NetServiceStartFailedNone",
    L"Service!s! NonExistingService!s!",

    L"MSFT_NetServiceStartFailedII",
    L"Service!s! DependedOnService!s! Error!u!",

    L"MSFT_NetDependOnLaterService",
    L"Service!s!",

    L"MSFT_NetServiceStartFailedGroup",
    L"Service!s! Group!s!",

    L"MSFT_NetDependOnLaterGroup",
    L"Service!s!",

    L"MSFT_NetServiceStartHung",
    L"Service!s!",

    L"MSFT_NetSevereServiceFailed",
    L"Service!s!",

    L"MSFT_NetTakeOwnership",
    L"RegistryKey!s!",

    L"MSFT_NetBadServiceState",
    L"Service!s! State!u!",

    L"MSFT_NetServiceExitFailed",
    L"Service!s! Error!u!",

    L"MSFT_NetServiceExitFailedSpecific",
    L"Service!s! Error!u!",

    L"MSFT_NetBootSystemDriversFailed",
    L"DriverList!s!",

    L"MSFT_NetServiceControlSuccess",
    L"Service!s! Control!s! sid!s!",

    L"MSFT_NetServiceStatusSuccess",
    L"Service!s! Control!s!",

    L"MSFT_NetServiceConfigBackoutFailed",
    L"Service!s! ConfigField!s!",

    L"MSFT_NetFirstLogonFailedII",
    L"Service!s! Account!s! Error!u!",

    L"MSFT_NetServiceDifferentPIDConnected",
    L"Service!s! ExpectedPID!u! ActualPID!u!"
};

#define SCM_PROV_NAME   L"SCM Event Provider"


BOOL InitNCEvents()
{
    BOOL bRet;

    g_hConnection =
        WmiEventSourceConnect(
            L"root\\cimv2",
            SCM_PROV_NAME,
            TRUE,
            MAX_BUFFER_SIZE,
            SEND_LATENCY,
            NULL,
            NULL);

    if (g_hConnection)
    {
        for (int i = 0; i < NUM_NC_EVENTS; i++)
        {
            g_hNCEvents[i] = 
                WmiCreateObjectWithFormat(
                    g_hConnection,
                    szEventSetup[i * 2],
                    WMI_CREATEOBJ_LOCKABLE,
                    szEventSetup[i * 2 + 1]);

            if (!g_hNCEvents[i])
                break;
        }

        bRet = i == NUM_NC_EVENTS;
    }
    else
        bRet = FALSE;

    return bRet;
}


void DeinitNCEvents()
{
    for (int i = 0; i < NUM_NC_EVENTS; i++)
    {
        if (g_hNCEvents[i])
            WmiDestroyObject(g_hNCEvents[i]);
    }

    if (g_hConnection)
        WmiEventSourceDisconnect(g_hConnection);
}


BOOL WINAPI NCFireEvent(DWORD dwIndex, ...)
{
    va_list list;
    BOOL    bRet;

    va_start(list, dwIndex);

    bRet =
        WmiSetAndCommitObject(
            g_hNCEvents[dwIndex], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED | WMI_USE_VA_LIST,
            &list);

    return bRet;
}


BOOL WINAPI NCIsEventActive(DWORD dwIndex)
{
    return WmiIsObjectActive(g_hNCEvents[dwIndex]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scaudit.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scaudit.cxx

Abstract:

    Auditing related functions.

Author:

    16-May-2001  kumarp

*/

#include "precomp.hxx"
#pragma hdrstop

#include "scaudit.h"
#include "authz.h"
#include "authzi.h"
#include "msaudite.h"
#include "account.h"

DWORD
ScGenerateServiceInstallAudit(
    IN PCWSTR pszServiceName,
    IN PCWSTR pszServiceImageName,
    IN DWORD  dwServiceType,
    IN DWORD  dwStartType,
    IN PCWSTR pszServiceAccount
    )
/*++

Routine Description:

    Generate SE_AUDITID_SERVICE_INSTALL audit event.

Arguments:

    pszServiceName      - name of the service installed

    pszServiceImageName - name of the service binary

    dwServiceType       - type of the service

    dwStartType         - start type of the service

    pszServiceAccount   - user account under which the service will run

Return Value:

    Win32 error code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwError = NO_ERROR;
    BOOL fResult = FALSE;
    BOOL fImpersonated = FALSE;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUDIT_PARAMS AuditParams = {0};
#define NUM_AUDIT_PARAMS 8
    AUDIT_PARAM ParamArray[NUM_AUDIT_PARAMS];
    PSID pUserSid = NULL;

    ASSERT( pszServiceName && *pszServiceName );
    ASSERT( pszServiceImageName && *pszServiceImageName );
    ASSERT( pszServiceAccount ? *pszServiceAccount : TRUE );
    ASSERT( (dwStartType == SERVICE_BOOT_START) ||
            (dwStartType <= SERVICE_DISABLED) );
    ASSERT( !(dwServiceType & ~SERVICE_TYPE_ALL) );
    
    RtlZeroMemory( ParamArray, sizeof(AUDIT_PARAM)*NUM_AUDIT_PARAMS );

    if ( pszServiceAccount == NULL )
    {
        pszServiceAccount = SC_LOCAL_SYSTEM_USER_NAME;
    }

    //
    // initialize the event of type SE_AUDITID_SERVICE_INSTALL
    //

    fResult = AuthziInitializeAuditEventType(
                  0,
                  SE_CATEGID_DETAILED_TRACKING, 
                  SE_AUDITID_SERVICE_INSTALL,
                  6,
                  &hAuditEventType
                  );

    if ( !fResult )
    {
        goto Error;
    }

    //
    // impersonate the client so that AuthziInitializeAuditParams can
    // get the client context from the thread token
    //

    Status = I_RpcMapWin32Status(RpcImpersonateClient( NULL ));

    if ( !NT_SUCCESS( Status ))
    {
        dwError = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }

    fImpersonated = TRUE;

    AuditParams.Parameters = ParamArray;
    
    //
    // add parameter values to the event
    //

    fResult = AuthziInitializeAuditParams(
                  APF_AuditSuccess,
                  &AuditParams,
                  &pUserSid,
                  L"Security",
                  6,
                  APT_String,     pszServiceName,
                  APT_String,     pszServiceImageName,
                  APT_Ulong,      dwServiceType,
                  APT_Ulong,      dwStartType,
                  APT_String,     pszServiceAccount,
                  APT_LogonId | AP_ClientLogonId
                  );
    
    if ( !fResult )
    {
        goto Error;
    }

    //
    // some more initialization
    //

    fResult = AuthziInitializeAuditEvent(
                  0,            // flags
                  NULL,         // resource manager
                  hAuditEventType,
                  &AuditParams,
                  NULL,         // hAuditQueue
                  INFINITE,     // time out
                  L"", L"", L"", L"", // obj access strings
                  &hAuditEvent);
    
    if ( !fResult )
    {
        goto Error;
    }

    if ( fImpersonated )
    {
        fImpersonated = FALSE;
        (void) I_RpcMapWin32Status(RpcRevertToSelf());
    }

    //
    // finally, send the event to auditing module
    //

    fResult = AuthziLogAuditEvent(
                  0,            // flags
                  hAuditEvent,
                  NULL);        // reserved
                  
    if ( !fResult )
    {
        goto Error;
    }

                  
 Cleanup:

    if ( fImpersonated )
    {
        Status = I_RpcMapWin32Status(RpcRevertToSelf());

        if ( !NT_SUCCESS( Status ))
        {
            dwError = RtlNtStatusToDosError( Status );
        }
    }

    if ( hAuditEvent )
    {
        AuthzFreeAuditEvent( hAuditEvent );
    }
    
    if ( hAuditEventType )
    {
        AuthziFreeAuditEventType( hAuditEventType );
    }

    if ( pUserSid )
    {
        LocalFree( pUserSid );
    }

#if DBG
    if ( dwError != NO_ERROR )
    {
        SC_LOG1(ERROR, "ScGenerateServiceInstallAudit failed: %lx\n", dwError);
    }
#endif
    
    return dwError;

 Error:
    dwError = GetLastError();
    goto Cleanup;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scaudit.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scaudit.h

Abstract:

    Auditing related functions.

Author:

    16-May-2001  kumarp

*/

#ifndef _AUDIT_H_
#define _AUDIT_H_

DWORD
ScGenerateServiceInstallAudit(
    IN PCWSTR pszServiceName,
    IN PCWSTR pszServiceImageName,
    IN DWORD  dwServiceType,
    IN DWORD  dwStartType,
    IN PCWSTR pszServiceAccount
    );



#endif // _AUDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\resource.h ===
//
// Resource IDs for services.exe
//

//
// String IDs for the string representations of the SC_ACTION enumeration
// start at this number.
//
#define IDS_SC_ACTION_BASE      0

//
// ID of the string the Service Controller will display on a reboot
// due to a service crash.
//
#define IDS_SC_REBOOT_MESSAGE   10

//
// String IDs for the string representations of service
// controls and states.
//
#define IDS_SC_CONTROL_BASE     20
#define IDS_SC_STATUS_BASE      50


//
// String IDs for the string representations of service config fields
//
#define IDS_SC_CONFIG_SERVICE_TYPE      80
#define IDS_SC_CONFIG_START_TYPE        81
#define IDS_SC_CONFIG_ERROR_CONTROL     82
#define IDS_SC_CONFIG_DISPLAY_NAME      83
#define IDS_SC_CONFIG_BINARY_PATH       84
#define IDS_SC_CONFIG_DEPENDENCIES      85
#define IDS_SC_CONFIG_GROUP             86
#define IDS_SC_CONFIG_TAG               87
#define IDS_SC_CONFIG_ACCOUNT           88
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scbsm.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scbsm.h

Abstract:

    Network drive BroadcastSystemMessage related function prototypes.

Author:

    Anirudh Sahni (anirudhs)    05-Jun-1996

Revision History:

    05-Jun-1996 AnirudhS
        Created.

--*/

#ifndef SCBSM_INCLUDED
#define SCBSM_INCLUDED


//
// Function Prototypes
//

VOID
ScInitBSM(
    );

#endif // #ifndef SCBSM_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scansi.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    SCANSI.CXX

Abstract:

    This file contains ansi wrappers for the Service Controller API
    functions.

Author:

    Dan Lafferty (danl) 04-Feb-1992

Environment:

    User Mode - Win32

Revision History:

    05-Nov-1992 Danl
        Added DisplayName Changes & new API.
    28-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.
    14-Apr-1992 JohnRo
        We should not return password from any of our APIs.
    04-Feb-1992 danl
        Created

--*/

#include "precomp.hxx"
#include <sclib.h>      // ScConvertToUnicode, ScConvertToAnsi
#include <scwow.h>      // 32/64-bit interop structures


DWORD
ROpenSCManagerA(
    IN  LPSTR           lpMachineName,
    IN  LPSTR           lpDatabaseName OPTIONAL,
    IN  DWORD           dwDesiredAccess,
    OUT LPSC_RPC_HANDLE lpScHandle
    )
/*++

Routine Description:


Arguments:

    lpMachineName -

    lpDatabaseName -

    dwDesiredAccess -

    lpScHandle -

Return Value:


Note:


--*/
{
    DWORD       status;
    LPWSTR      lpDatabaseNameW = NULL;

    //
    // This parameter got us to the server side and is uninteresting
    // once we get here.
    //
    UNREFERENCED_PARAMETER(lpMachineName);

    //
    // Create a unicode version of lpDatabaseName
    //
    if (ARGUMENT_PRESENT(lpDatabaseName)) {

        if(!ScConvertToUnicode(&lpDatabaseNameW, lpDatabaseName)) {
            SC_LOG(ERROR,"ROpenSCManagerA:ScConvertToUnicode failed\n",0);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    status = ROpenSCManagerW (
                NULL,
                lpDatabaseNameW,
                dwDesiredAccess,
                lpScHandle);


    if (ARGUMENT_PRESENT(lpDatabaseName)) {
        LocalFree(lpDatabaseNameW);
    }
    return(status);
}


DWORD
ROpenServiceA(
    IN  SC_RPC_HANDLE   hSCManager,
    IN  LPSTR           lpServiceName,
    IN  DWORD           dwDesiredAccess,
    OUT LPSC_RPC_HANDLE phService
    )

/*++

Routine Description:

    Returns a handle to the service.  This handle is actually a pointer
    to a data structure that contains a pointer to the service record.

Arguments:

    hSCManager - This is a handle to this service controller.  It is an
        RPC context handle, and has allowed the request to get this far.

    lpServiceName - This is a pointer to a string containing the name of
        the service

    dwDesiredAccess - This is an access mask that contains a description
        of the access that is desired for this service.

    phService - This is a pointer to the location where the handle to the
        service is to be placed.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle is invalid.

    ERROR_SERVICE_DOES_NOT_EXIST - The specified service does not exist
        in the database.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation for the handle structure
        failed.

Note:


--*/
{
    DWORD       status;
    LPWSTR      lpServiceNameW;

    //
    // Create a unicode version of lpServiceName
    //
    if(!ScConvertToUnicode(&lpServiceNameW, lpServiceName)) {
        SC_LOG(ERROR,"ROpenServiceA:ScConvertToUnicode failed\n",0);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    status = ROpenServiceW (
                hSCManager,
                lpServiceNameW,
                dwDesiredAccess,
                phService);

    LocalFree(lpServiceNameW);

    return(status);
}


DWORD
RStartServiceA(
    IN  SC_RPC_HANDLE       hService,
    IN  DWORD               NumArgs,
    IN  LPSTRING_PTRSA      CmdArgs
    )

/*++

Routine Description:

    This function begins the execution of a service.

Arguments:

    hService - A handle which is a pointer to a service handle structure.

    dwNumServiceArgs - This indicates the number of argument vectors.

    lpServiceArgVectors - This is a pointer to an array of string pointers.

Return Value:

    NO_ERROR - The operation was completely successful.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_START access.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_SERVICE_WAS_STARTED - An instance of the service is already running.

    ERROR_SERVICE_REQUEST_TIMEOUT - The service did not respond to the start
        request in a timely fashion.

    ERROR_SERVICE_NO_THREAD - A thread could not be created for the Win32
        service.

    ERROR_PATH_NOT_FOUND - The image file name could not be found in
        the configuration database (registry), or the image file name
        failed in a unicode/ansi conversion.



--*/
{
    DWORD       status = NO_ERROR;
    LPWSTR      *CmdArgsW = NULL;
    DWORD       bufferSize=0;
    DWORD       i;
    LPSTR       *cmdArgs;

    if (NumArgs > 0)
    {
        //
        // If there are command args, create a unicode version of them.
        //

        if (CmdArgs == NULL)
        {
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Allocate a buffer for the unicode command arg pointers.
        //

        bufferSize = NumArgs * sizeof(LPWSTR);

        CmdArgsW = (LPWSTR *)LocalAlloc(LMEM_ZEROINIT, (UINT) bufferSize);

        if (CmdArgsW == NULL)
        {
            SC_LOG(ERROR,"RStartServicesA: LocalAlloc Failed\n",0);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        __try {

            //
            // For each command Arg, allocate a string and convert the
            // unicode version of the string into it.
            //
            cmdArgs = (LPSTR *)CmdArgs;

            for (i=0; i<NumArgs; i++)
            {
                if (cmdArgs[i] == NULL)
                {
                    SC_LOG1(ERROR, "RStartServicesA: cmdArgs[%d] NULL!\n", i);

                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                if(!ScConvertToUnicode(&(CmdArgsW[i]), cmdArgs[i])) {
                    SC_LOG(ERROR,
                        "RStartServicesA: LocalAlloc (convert) Failed\n",0);
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
            if (status != EXCEPTION_ACCESS_VIOLATION) {
                SC_LOG(ERROR,
                    "RStartServicesA: Unexpected Exception 0x%lx\n",status);
            }
        }

        //
        // If any errors occured in the conversion process.  Abort and
        // return the error to the caller.
        //
        if (status != NO_ERROR) {
            goto CleanExit;
        }
    }

    status = RStartServiceW(
                hService,
                NumArgs,
                (LPSTRING_PTRSW)CmdArgsW);

CleanExit:
    if (NumArgs > 0) {
        //
        // If there were unicode versions of the arguments created for
        // this function, release the memory that was allocated.
        //
        for(i = 0; i < NumArgs; i++) {
            if (CmdArgsW[i] != NULL) {
                LocalFree(CmdArgsW[i]);
            }
        }
        LocalFree(CmdArgsW);
    }

    return(status);
}

DWORD
REnumServicesStatusA (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL
    )

/*++

Routine Description:

    This function lists the services installed in the Service Controllers
    database.  The status of each service is returned with the name of
    the service.

Arguments:

    hSCManager - This is a handle to the service controller.

    dwServiceType - Value to select the type of services to enumerate.
        It must be one of the bitwise OR of the following values:
        SERVICE_WIN32 - enumerate Win32 services only.
        SERVICE_DRIVER - enumerate Driver services only.

    dwServiceState - Value so select the services to enumerate based on the
        running state.  It must be one or the bitwise OR of the following
        values:
        SERVICE_ACTIVE - enumerate services that have started.
        SERVICE_INACTIVE - enumerate services that are stopped.

    lpBuffer - A pointer to a buffer to receive an array of enum status
        (or service) entries.

    cbBufSize - Size of the buffer in bytes pointed to by lpBuffer.

    pcbBytesNeeded - A pointer to a location where the number of bytes
        left (to be enumerated) is to be placed.  This indicates to the
        caller how large the buffer must be in order to complete the
        enumeration with the next call.

    lpServicesReturned - A pointer to a variable to receive the number of
        of service entries returned.

    lpResumeIndex - A pointer to a variable which on input specifies the
        index of a service entry to begin enumeration.  An index of 0
        indicates to start at the beginning.  On output, if this function
        returns ERROR_MORE_DATA, the index returned is the next service
        entry to resume the enumeration.  The returned index is 0 if this
        function returns a NO_ERROR.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in.
        (such as dwServiceType).

    ERROR_INVALID_HANDLE - The specified handle was invalid.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpBuffer, pcbReturned, pcbBytesNeeded,
        lpBuffer, ReturnedServerName, and lpResumeIndex.

--*/
{
    DWORD                        status;
    LPENUM_SERVICE_STATUS_WOW64  pEnumRec;
    LPWSTR                       pServiceName;
    LPWSTR                       pDisplayName;
    DWORD                        i;


    //
    // Initialize entries returned because we convert the buffer on
    // output based on the number of returned entries.
    //
    *lpServicesReturned = 0;

    status = REnumServicesStatusW (
                hSCManager,
                dwServiceType,
                dwServiceState,
                lpBuffer,
                cbBufSize,
                pcbBytesNeeded,
                lpServicesReturned,
                lpResumeIndex);

    if (*lpServicesReturned > 0)
    {
        //
        // Convert the returned unicode structures to Ansi.
        //
        pEnumRec = (LPENUM_SERVICE_STATUS_WOW64) lpBuffer;

        for (i = 0; i < *lpServicesReturned; i++)
        {
            //
            // Note: in these conversions, the pointers to the names are
            // stored as offsets at this point.
            //
            pServiceName = (LPWSTR) (lpBuffer + pEnumRec[i].dwServiceNameOffset);
            pDisplayName = (LPWSTR) (lpBuffer + pEnumRec[i].dwDisplayNameOffset);

            if (!ScConvertToAnsi((LPSTR) pServiceName, pServiceName))
            {
                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }

            //
            // Convert the Display Name.
            //
            if (!ScConvertToAnsi((LPSTR)pDisplayName, pDisplayName)) {

                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }
        }
    }

    return(status);
}


DWORD
REnumServicesStatusExA (
    IN      SC_RPC_HANDLE   hSCManager,
    IN      SC_ENUM_TYPE    InfoLevel,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwServiceState,
    OUT     PBYTE           lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned,
    IN OUT  LPDWORD         lpResumeIndex OPTIONAL,
    IN      LPCSTR          pszGroupNameAnsi
    )

/*++

Routine Description:

    This function is analogous to REnumServicesStatusA, with the data
    being enumerated being dependent upon the InfoLevel parameter

Arguments:

    InfoLevel - An enumerated type that determines what service attributes
        are enumerated:

            SC_ENUM_ALL_INFO - Enumerates all the service information from
                REnumServicesStatusW plus the service's PID and flags

    pszGroupName - Only enumerate services belonging to the given group.
        If this parameter is the empty string, services not belonging to
        a group are enumerated.  If this parameter is NULL, no attention
        is paid to group.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned due to the size of the user's buffer.  pcbBytesNeeded
        contains the number of bytes required to  get the remaining
        entries.

    ERROR_INVALID_PARAMETER - An illegal parameter value was passed in.
        (such as dwServiceType).

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_INVALID_LEVEL - The specified InfoLevel is invalid

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpBuffer, pcbReturned, pcbBytesNeeded,
        lpBuffer, ReturnedServerName, and lpResumeIndex.


--*/
{
    DWORD                                status;
    LPENUM_SERVICE_STATUS_PROCESS_WOW64  pEnumRec;
    LPWSTR                               pServiceName;
    LPWSTR                               pDisplayName;
    LPWSTR                               pszGroupName = NULL;
    DWORD                                i;


    //
    // Initialize entries returned because we convert the buffer on
    // output based on the number of returned entries.
    //
    *lpServicesReturned = 0;

    if (ARGUMENT_PRESENT(pszGroupNameAnsi)) {

        if (!ScConvertToUnicode(&pszGroupName, pszGroupNameAnsi)) {
            SC_LOG(ERROR,"EnumServicesStatusExA: ScConvertToUnicode failed\n",0);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    status = REnumServicesStatusExW (
                hSCManager,
                InfoLevel,
                dwServiceType,
                dwServiceState,
                lpBuffer,
                cbBufSize,
                pcbBytesNeeded,
                lpServicesReturned,
                lpResumeIndex,
                (LPCWSTR)pszGroupName);

    if (*lpServicesReturned > 0)
    {
        //
        // Convert the returned unicode structures to Ansi.
        //
        pEnumRec = (LPENUM_SERVICE_STATUS_PROCESS_WOW64) lpBuffer;

        for (i = 0; i < *lpServicesReturned; i++) {

            //
            // Note: in these conversions, the pointers to the names are
            // stored as offsets at this point.
            //
            pServiceName = (LPWSTR) (lpBuffer + pEnumRec[i].dwServiceNameOffset);
            pDisplayName = (LPWSTR) (lpBuffer + pEnumRec[i].dwDisplayNameOffset);

            if (!ScConvertToAnsi((LPSTR)pServiceName, pServiceName)) {

                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }

            //
            // Convert the Display Name.
            //
            if (!ScConvertToAnsi((LPSTR)pDisplayName, pDisplayName)) {

                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }
        }
    }

    LocalFree(pszGroupName);

    return(status);
}


DWORD
RChangeServiceConfigA(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwServiceType,
    IN  DWORD           dwStartType,
    IN  DWORD           dwErrorControl,
    IN  LPSTR           lpBinaryPathName,
    IN  LPSTR           lpLoadOrderGroup,
    OUT LPDWORD         lpdwTagId,
    IN  LPBYTE          lpDependencies,
    IN  DWORD           dwDependSize,
    IN  LPSTR           lpServiceStartName,
    IN  LPBYTE          EncryptedPassword,
    IN  DWORD           PasswordSize,
    IN  LPSTR           lpDisplayName
    )

/*++

Routine Description:


Arguments:

    lpDependencies - A buffer of size dwDependSize which already contains
        Unicode strings.

Return Value:


Note:


--*/
{
    DWORD       status;
    LPWSTR      lpDisplayNameW      = NULL;
    LPWSTR      lpBinaryPathNameW   = NULL;
    LPWSTR      lpLoadOrderGroupW   = NULL;
    LPWSTR      lpServiceStartNameW = NULL;

    //
    // Create a unicode version of lpBinaryPathName
    //
    if (ARGUMENT_PRESENT(lpBinaryPathName)) {

        if(!ScConvertToUnicode(&lpBinaryPathNameW, lpBinaryPathName)) {
            SC_LOG(ERROR,"ChangeServiceConfigA:ScConvertToUnicode failed\n",0);

            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpLoadOrderGroup
    //
    if (ARGUMENT_PRESENT(lpLoadOrderGroup)) {

        if(!ScConvertToUnicode(&lpLoadOrderGroupW, lpLoadOrderGroup)) {
            SC_LOG(ERROR,"ChangeServiceConfigA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpServiceStartName
    //
    if (ARGUMENT_PRESENT(lpServiceStartName)) {

        if(!ScConvertToUnicode(&lpServiceStartNameW, lpServiceStartName)) {
            SC_LOG(ERROR,"ChangeServiceConfigA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpDisplayName
    //
    if (ARGUMENT_PRESENT(lpDisplayName)) {

        if(!ScConvertToUnicode(&lpDisplayNameW, lpDisplayName)) {
            SC_LOG(ERROR,"ChangeServiceConfigA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Make the Unicode API Call
    //

    status = RChangeServiceConfigW(
                (SC_RPC_HANDLE)hService,
                dwServiceType,
                dwStartType,
                dwErrorControl,
                lpBinaryPathNameW,
                lpLoadOrderGroupW,
                lpdwTagId,
                lpDependencies,
                dwDependSize,
                lpServiceStartNameW,
                EncryptedPassword,
                PasswordSize,
                lpDisplayNameW);

CleanExit:

    LocalFree(lpBinaryPathNameW);
    LocalFree(lpLoadOrderGroupW);
    LocalFree(lpServiceStartNameW);
    LocalFree(lpDisplayNameW);

    return(status);
}


DWORD
RChangeServiceConfig2A(
    IN  SC_RPC_HANDLE       hService,
    IN  SC_RPC_CONFIG_INFOA Info
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   status = NO_ERROR;

    //
    // Make a Unicode version of the arguments to pass to the Unicode function
    //
    union
    {
        SERVICE_DESCRIPTIONW        sd;
        SERVICE_FAILURE_ACTIONSW    sfa;
    }                       Buffer;

    SC_RPC_CONFIG_INFOW     InfoW = { Info.dwInfoLevel, &Buffer.sd };

    switch (Info.dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        Buffer.sd.lpDescription = NULL;

        if (Info.psd == NULL)
        {
            InfoW.psd = NULL;
            break;
        }

        if (Info.psd->lpDescription != NULL)
        {
            if (!ScConvertToUnicode(&Buffer.sd.lpDescription,
                                    Info.psd->lpDescription))
            {
                SC_LOG0(ERROR, "RChangeServiceConfig2A: ScConvertToUnicode failed\n");
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        }
        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        RtlCopyMemory(&Buffer.sfa, Info.psfa, sizeof(SERVICE_FAILURE_ACTIONS));
        Buffer.sfa.lpRebootMsg = NULL;
        Buffer.sfa.lpCommand = NULL;

        if (Info.psfa == NULL)
        {
            InfoW.psfa = NULL;
            break;
        }

        if (Info.psfa->lpRebootMsg != NULL)
        {
            if (!ScConvertToUnicode(&Buffer.sfa.lpRebootMsg,
                                    Info.psfa->lpRebootMsg))
            {
                SC_LOG0(ERROR, "RChangeServiceConfig2A: ScConvertToUnicode failed\n");
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        }

        if (Info.psfa->lpCommand != NULL)
        {
            if (!ScConvertToUnicode(&Buffer.sfa.lpCommand,
                                    Info.psfa->lpCommand))
            {
                SC_LOG0(ERROR, "RChangeServiceConfig2A: ScConvertToUnicode failed\n");
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        }
        break;
    }

    //
    // Call the Unicode function
    //
    status = RChangeServiceConfig2W(hService,
                                    InfoW);

CleanExit:

    //
    // Free the temporary Unicode strings
    //
    switch (Info.dwInfoLevel)
    {
    case SERVICE_CONFIG_DESCRIPTION:
        LocalFree(Buffer.sd.lpDescription);
        break;

    case SERVICE_CONFIG_FAILURE_ACTIONS:
        LocalFree(Buffer.sfa.lpRebootMsg);
        LocalFree(Buffer.sfa.lpCommand);
        break;
    }

    return status;
}


DWORD
RCreateServiceA(
    IN      SC_RPC_HANDLE   hSCManager,
    IN      LPSTR           lpServiceName,
    IN      LPSTR           lpDisplayName,
    IN      DWORD           dwDesiredAccess,
    IN      DWORD           dwServiceType,
    IN      DWORD           dwStartType,
    IN      DWORD           dwErrorControl,
    IN      LPSTR           lpBinaryPathName,
    IN      LPSTR           lpLoadOrderGroup,
    OUT     LPDWORD         lpdwTagId,
    IN      LPBYTE          lpDependencies,
    IN      DWORD           dwDependSize,
    IN      LPSTR           lpServiceStartName,
    IN      LPBYTE          EncryptedPassword,
    IN      DWORD           PasswordSize,
    IN OUT  LPSC_RPC_HANDLE lpServiceHandle
    )

/*++

Routine Description:


Arguments:

    lpDependencies - A buffer of size dwDependSize which already contains
        Unicode strings.

Return Value:


Note:


--*/
{
    DWORD       status;
    LPWSTR      lpServiceNameW      = NULL;
    LPWSTR      lpDisplayNameW      = NULL;
    LPWSTR      lpBinaryPathNameW   = NULL;
    LPWSTR      lpLoadOrderGroupW   = NULL;
    LPWSTR      lpServiceStartNameW = NULL;

    //
    // Create a unicode version of lpServiceName
    //
    if (ARGUMENT_PRESENT(lpServiceName)) {

        if(!ScConvertToUnicode(&lpServiceNameW, lpServiceName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }
    //
    // Create a unicode version of lpDisplayName
    //
    if (ARGUMENT_PRESENT(lpDisplayName)) {

        if(!ScConvertToUnicode(&lpDisplayNameW, lpDisplayName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }
    //
    // Create a unicode version of lpBinaryPathName
    //
    if (ARGUMENT_PRESENT(lpBinaryPathName)) {

        if(!ScConvertToUnicode(&lpBinaryPathNameW, lpBinaryPathName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpLoadOrderGroup
    //
    if (ARGUMENT_PRESENT(lpLoadOrderGroup)) {

        if(!ScConvertToUnicode(&lpLoadOrderGroupW, lpLoadOrderGroup)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Create a unicode version of lpServiceStartName
    //
    if (ARGUMENT_PRESENT(lpServiceStartName)) {

        if(!ScConvertToUnicode(&lpServiceStartNameW, lpServiceStartName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Make the Unicode API Call
    //

    status = RCreateServiceW (
                (SC_RPC_HANDLE)hSCManager,
                lpServiceNameW,
                lpDisplayNameW,
                dwDesiredAccess,
                dwServiceType,
                dwStartType,
                dwErrorControl,
                lpBinaryPathNameW,
                lpLoadOrderGroupW,
                lpdwTagId,
                lpDependencies,
                dwDependSize,
                lpServiceStartNameW,
                EncryptedPassword,
                PasswordSize,
                lpServiceHandle);
CleanExit:

    LocalFree(lpServiceNameW);
    LocalFree(lpDisplayNameW);
    LocalFree(lpBinaryPathNameW);
    LocalFree(lpLoadOrderGroupW);
    LocalFree(lpServiceStartNameW);

    return(status);
}


DWORD
REnumDependentServicesA(
    IN      SC_RPC_HANDLE   hService,
    IN      DWORD           dwServiceState,
    OUT     LPBYTE          lpBuffer,
    IN      DWORD           cbBufSize,
    OUT     LPDWORD         pcbBytesNeeded,
    OUT     LPDWORD         lpServicesReturned
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                        status;
    LPENUM_SERVICE_STATUS_WOW64  pEnumRec;
    LPWSTR                  pServiceName;
    LPWSTR                  pDisplayName;
    DWORD                   i;

    //
    // Initialize entries returned because we convert the buffer on
    // output based on the number of returned entries.
    //
    *lpServicesReturned = 0;

    status = REnumDependentServicesW(
                hService,
                dwServiceState,
                lpBuffer,
                cbBufSize,
                pcbBytesNeeded,
                lpServicesReturned);

    if (*lpServicesReturned > 0) {
        //
        // Convert the returned unicode structures to Ansi.
        //
        pEnumRec = (LPENUM_SERVICE_STATUS_WOW64) lpBuffer;

        for (i=0; i<*lpServicesReturned; i++) {
            //
            // Note: in these conversions, the pointers to the names are
            // stored as offsets at this point.
            //
            pServiceName = (LPWSTR) (lpBuffer + (DWORD_PTR)(pEnumRec[i].dwServiceNameOffset));
            pDisplayName = (LPWSTR) (lpBuffer + (DWORD_PTR)(pEnumRec[i].dwDisplayNameOffset));

            if (!ScConvertToAnsi((LPSTR)pServiceName, pServiceName)) {

                SC_LOG(ERROR,"REnumDependendServicesA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }
            //
            // Convert the Display Name.
            //

            if (!ScConvertToAnsi((LPSTR)pDisplayName, pDisplayName)) {

                SC_LOG(ERROR,"REnumServicesStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
                *lpServicesReturned = 0;
                break;
            }
        }
    }

    return(status);
}


DWORD
RQueryServiceConfigA(
    IN  SC_RPC_HANDLE           hService,
    OUT LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    IN  DWORD                   cbBufSize,
    OUT LPDWORD                 pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                   status;

    //
    // Call the Unicode version of the API.
    //

    status = RQueryServiceConfigW(
                (SC_RPC_HANDLE)hService,
                (LPQUERY_SERVICE_CONFIGW)lpServiceConfig,
                cbBufSize,
                pcbBytesNeeded);

    //
    // If successful, convert the QUERY_SERVICE_CONFIG structure to
    // ansi.
    //
    if (status == NO_ERROR) {

        //
        // Convert lpBinaryPathName to Ansi
        //
        if (lpServiceConfig->lpBinaryPathName != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpBinaryPathName,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpBinaryPathName)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        //
        // Convert lpDisplayName to Ansi
        //
        if (lpServiceConfig->lpDisplayName != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpDisplayName,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpDisplayName)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        //
        // Convert lpLoadOrderGroup to Ansi
        //
        if (lpServiceConfig->lpLoadOrderGroup != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpLoadOrderGroup,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpLoadOrderGroup)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        //
        // Convert lpDependencies to Ansi
        //
        if (lpServiceConfig->lpDependencies != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpDependencies,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpDependencies)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        //
        // Convert lpServiceStartName to Ansi
        //
        if (lpServiceConfig->lpServiceStartName != NULL) {
            if(!ScConvertToAnsi(
                lpServiceConfig->lpServiceStartName,
                ((LPQUERY_SERVICE_CONFIGW)lpServiceConfig)->lpServiceStartName)) {

                SC_LOG(ERROR,"RQueryServiceConfigA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    return(status);
}

DWORD
RQueryServiceConfig2A(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwInfoLevel,
    OUT LPBYTE          lpBuffer,
    IN  DWORD           cbBufSize,
    OUT LPDWORD         pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   status;
    DWORD   StringOffset;

    //
    // Call the Unicode version of the API, using the same buffer.
    // Then convert the strings in the buffer to Ansi.
    //
    status = RQueryServiceConfig2W(
                hService,
                dwInfoLevel,
                lpBuffer,
                cbBufSize,
                pcbBytesNeeded
                );

    if (status == NO_ERROR)
    {
        switch (dwInfoLevel)
        {
        case SERVICE_CONFIG_DESCRIPTION:
            {
                StringOffset = ((LPSERVICE_DESCRIPTION_WOW64) lpBuffer)->dwDescriptionOffset;

                if (StringOffset != 0)
                {
                    if(!ScConvertToAnsi(
                            (LPSTR)  (lpBuffer + StringOffset),
                            (LPWSTR) (lpBuffer + StringOffset)
                            ))
                    {
                        SC_LOG0(ERROR,"RQueryServiceConfig2A:ScConvertToAnsi failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
            break;

        case SERVICE_CONFIG_FAILURE_ACTIONS:
            {
                StringOffset = ((LPSERVICE_FAILURE_ACTIONS_WOW64) lpBuffer)->dwRebootMsgOffset;

                if (StringOffset != 0)
                {
                    if(!ScConvertToAnsi(
                            (LPSTR)  (lpBuffer + StringOffset),
                            (LPWSTR) (lpBuffer + StringOffset)
                            ))
                    {
                        SC_LOG0(ERROR,"RQueryServiceConfig2A:ScConvertToAnsi failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                }

                StringOffset = ((LPSERVICE_FAILURE_ACTIONS_WOW64) lpBuffer)->dwCommandOffset;

                if (StringOffset != 0)
                {
                    if(!ScConvertToAnsi(
                            (LPSTR)  (lpBuffer + StringOffset),
                            (LPWSTR) (lpBuffer + StringOffset)
                            ))
                    {
                        SC_LOG0(ERROR,"RQueryServiceConfig2A:ScConvertToAnsi failed\n");
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
            break;

        default:
            SC_ASSERT(0);
            break;
        }
    }

    return status;
}

DWORD
RQueryServiceLockStatusA(
    IN  SC_RPC_HANDLE                   hSCManager,
    OUT LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    IN  DWORD                           cbBufSize,
    OUT LPDWORD                         pcbBytesNeeded
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   status;

    //
    // Call the Unicode version of the API
    //

    status = RQueryServiceLockStatusW(
                (SC_RPC_HANDLE)hSCManager,
                (LPQUERY_SERVICE_LOCK_STATUSW)lpLockStatus,
                cbBufSize,
                pcbBytesNeeded
                );

    //
    // If successful, convert the QUERY_SERVICE_LOCK_STATUS structure to
    // ansi.
    //
    if (status == NO_ERROR) {

        //
        // Convert lpLockOwner to Ansi
        //
        if (lpLockStatus->lpLockOwner != NULL) {
            if(!ScConvertToAnsi(
                lpLockStatus->lpLockOwner,
                ((LPQUERY_SERVICE_LOCK_STATUSW)lpLockStatus)->lpLockOwner)) {

                SC_LOG(ERROR,"RQueryServiceLockStatusA:ScConvertToAnsi failed\n",0);

                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return(status);
}

DWORD
RGetServiceDisplayNameA(
    SC_RPC_HANDLE   hSCManager,
    LPSTR           lpServiceName,
    LPSTR           lpDisplayName,
    LPDWORD         lpcchBuffer
    )

/*++

Routine Description:

    This function returns the display name for a service that is identified
    by its key name (ServiceName).

Arguments:

    hSCManager - This is the handle to the Service Controller Manager that
        is expected to return the display name.

    lpServiceName -  This is the ServiceName (which is actually a key
        name) that identifies the service.

    lpDisplayName - This is a pointer to a buffer that is to receive the
        DisplayName string.

    lpcchBuffer - This is a pointer to the size (in characters) of the
        buffer that is to receive the DisplayName string.  If the buffer
        is not large enough to receive the entire string, then the required
        buffer size is returned in this location.  (NOTE:  Ansi Characters,
        including DBCS, are assumed to be 8 bits).

Return Value:



--*/
{
    DWORD       status;
    LPWSTR      lpServiceNameW = NULL;
    DWORD       numChars = 0;
    DWORD       numBytes = 0;
    LPSTR       tempBuffer=NULL;

    //
    // Create a unicode version of lpServiceName
    //
    if (ARGUMENT_PRESENT(lpServiceName)) {

        if(!ScConvertToUnicode(&lpServiceNameW, lpServiceName)) {
            SC_LOG(ERROR,"RCreateServiceA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Because of DBCS, we can't predict what the proper buffer size should
    // be.  So we allocate a temporary buffer that will hold as many
    // unicode characters as the original buffer would hold single byte
    // characters.
    //
    numChars = *lpcchBuffer;

    numBytes = (*lpcchBuffer) * sizeof(WCHAR);

    tempBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, numBytes);

    if (tempBuffer == NULL)
    {
        status = GetLastError();
        goto CleanExit;
    }

    //
    // Make the Unicode API Call
    //

    status = RGetServiceDisplayNameW (
                hSCManager,
                lpServiceNameW,
                (LPWSTR) tempBuffer,
                &numChars);

    if (status == NO_ERROR)
    {
        //
        // Convert the returned Unicode string and string size back to
        // ansi.
        //

        if (!ScConvertToAnsi(tempBuffer, (LPWSTR) tempBuffer)) {
            SC_LOG0(ERROR, "RGetServiceDisplayNameA: ConvertToAnsi Failed\n");
        }

        numBytes = (DWORD) strlen(tempBuffer);

        if ((numBytes+1) > *lpcchBuffer)
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            *lpcchBuffer = numBytes;
        }
        else
        {
            strcpy (lpDisplayName, tempBuffer);
        }
    }
    else if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        //
        // Adjust the required buffer size for ansi.
        //
        *lpcchBuffer = numChars * sizeof(WCHAR);
    }

CleanExit:
    //
    // Free up any resources that were allocated by this function.
    //

    LocalFree(tempBuffer);
    LocalFree(lpServiceNameW);

    return(status);
}

DWORD
RGetServiceKeyNameA(
    SC_RPC_HANDLE   hSCManager,
    LPSTR           lpDisplayName,
    LPSTR           lpServiceName,
    LPDWORD         lpcchBuffer
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD       status;
    LPWSTR      lpDisplayNameW      = NULL;
    DWORD       numChars = 0;
    DWORD       numBytes = 0;
    LPSTR       tempBuffer=NULL;

    //
    // Create a unicode version of lpDisplayName
    //
    if (ARGUMENT_PRESENT(lpDisplayName))
    {
        if(!ScConvertToUnicode(&lpDisplayNameW, lpDisplayName))
        {
            SC_LOG(ERROR,"RGetServiceKeyNameA:ScConvertToUnicode failed\n",0);
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }
    }

    //
    // Because of DBCS, we can't predict what the proper buffer size should
    // be.  So we allocate a temporary buffer that will hold as many
    // unicode characters as the original buffer would hold single byte
    // characters.
    //
    numChars = *lpcchBuffer;

    numBytes = (*lpcchBuffer) * sizeof(WCHAR);

    tempBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, numBytes);

    if (tempBuffer == NULL)
    {
        status = GetLastError();
        goto CleanExit;
    }

    //
    // Make the Unicode API Call
    //

    status = RGetServiceKeyNameW (
                hSCManager,
                lpDisplayNameW,
                (LPWSTR)tempBuffer,
                &numChars);

    if (status == NO_ERROR)
    {
        //
        // Convert the returned Unicode string and string size back to
        // ansi.
        //

        if (!ScConvertToAnsi(tempBuffer, (LPWSTR)tempBuffer))
        {
            SC_LOG0(ERROR, "RGetServiceKeyNameA: ConvertToAnsi Failed\n");
        }

        numBytes = (DWORD) strlen(tempBuffer);

        if ((numBytes+1) > *lpcchBuffer)
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            *lpcchBuffer = numBytes;
        }
        else
        {
            strcpy (lpServiceName, tempBuffer);
        }
    }
    else if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        //
        // Adjust the required buffer size for ansi.
        //
        *lpcchBuffer = numChars * sizeof(WCHAR);
    }

CleanExit:
    //
    // Free up any resources that were allocated by this function.
    //

    LocalFree(tempBuffer);
    LocalFree(lpDisplayNameW);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scbsm.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    scbsm.cxx

Abstract:

    This module implements a simplistic scheme to have a trusted system
    component issue a BroadcastSystemMessage when a network drive is added
    or deleted through the WNet APIs.  This scheme guarantees that a spurious
    message is never sent; however, there are some situations in which a
    bona fide message can get lost or delayed.  The real solution requires
    Plug and Play support from network providers.

    The following functions are in this file:
        ScInitBSM
        ScHandleBSMRequest
        ScGetNetworkDrives
        ScCreateBSMEventSD

Author:

    Anirudh Sahni (anirudhs)    05-Jun-1996

Environment:

    User Mode - Win32

Notes:

    There is no architectural reason for this to be in the service controller.
    A more appropriate place would be the Plug and Play service.

Revision History:

    22-Oct-1998     jschwart
        Converted SCM to use NT thread pool APIs

    05-Jun-1996     AnirudhS
        Created.

--*/

#include "precomp.hxx"
#include <dbt.h>        // BroadcastSystemMessage structures
#include <winsvcp.h>    // SC_BSM_EVENT_NAME
#include <scseclib.h>   // well-known SIDs
#include "scbsm.h"

//-------------------------------------------------------------------//
//                                                                   //
// Constants and Macros                                              //
//                                                                   //
//-------------------------------------------------------------------//


//-------------------------------------------------------------------//
//                                                                   //
// Static global variables                                           //
//                                                                   //
//-------------------------------------------------------------------//

//
// Event that will be pulsed by the WNet APIs when they want a message
// broadcast
//
HANDLE hBSMEvent;

//
// What the net drive bitmask was when we last broadcast (initially 0)
//
DWORD LastNetDrives;

//
// Work item handle
//
HANDLE g_hWorkitem;

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

BOOL
ScCreateBSMEventSD(
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    );

VOID
ScHandleBSMRequest(
    PVOID   pContext,
    BOOLEAN dwWaitStatus
    );

DWORD
ScGetNetworkDrives(
    );


//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//


VOID
ScInitBSM(
    )
/*++

Routine Description:

    This function performs initialization related to network drive arrival
    broadcasts.

    CODEWORK  Should we fail service controller initialization if this fails?
    Event log the cause?

Arguments:

    None

Return Value:

    None

--*/
{
    NTSTATUS ntStatus;
    SECURITY_ATTRIBUTES EventAttrs = { sizeof(SECURITY_ATTRIBUTES), NULL, FALSE };

    //
    // Create the security descriptor for the event.
    // No-one else can wait for the event, but anyone can set it.
    //
    if (! ScCreateBSMEventSD(&EventAttrs.lpSecurityDescriptor))
    {
        SC_LOG(ERROR, "Couldn't create BSM event security descriptor, %lu\n",
                      GetLastError());
        return;
    }

    //
    // Create the event that will be pulsed by the WNet APIs when they
    // want a message broadcast.
    //
    hBSMEvent = CreateEvent(
                    &EventAttrs,        // security attrs
                    FALSE,              // make this an auto-reset event
                    FALSE,              // initial state is nonsignaled
                    SC_BSM_EVENT_NAME   // name
                    );

    if (hBSMEvent == NULL)
    {
        SC_LOG(ERROR, "Couldn't create BSM event, %lu\n", GetLastError());
    }

    LocalFree(EventAttrs.lpSecurityDescriptor);

    if (hBSMEvent == NULL)
    {
        return;
    }

    //
    // Add the work item that will be executed when this event is signaled.
    //
    ntStatus = RtlRegisterWait(&g_hWorkitem,          // work item handle
                               hBSMEvent,             // waitable object handle
                               ScHandleBSMRequest,    // callback function
                               0,                     // parameter for callback function
                               INFINITE,              // infinite wait
                               WT_EXECUTEONLYONCE); // one-time work item

    if (!NT_SUCCESS(ntStatus))
    {
        SC_LOG1(ERROR, "ScInitBSM: RtlRegisterWait failed 0x%x\n", ntStatus);
        CloseHandle(hBSMEvent);
        hBSMEvent = NULL;
    }
}



VOID
ScHandleBSMRequest(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    )
/*++

Routine Description:

    This is the callback function executed when some process sets the BSM
    Request event.

Arguments:

Return Value:

--*/
{
    DWORD    NetDrives;
    NTSTATUS ntStatus;

    DEV_BROADCAST_VOLUME dbv;
    LONG status;

    //
    // If fWaitStatus if TRUE, we're being signalled because of a timeout.
    // Since we registered with an infinite wait, this should NEVER happen
    //
    ASSERT(fWaitStatus == FALSE);

    SC_LOG0(BSM, "Handling a BSM request\n");

    //
    // Deregister the work item (we have to do this even if the
    // WT_EXECUTEONLYONCE flag is specified)
    //
    ntStatus = RtlDeregisterWait(g_hWorkitem);

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG1(ERROR,
                "ScHandleBSMRequest: RtlDeregisterWait FAILED %#x\n",
                ntStatus);
    }

    //
    // Keep broadcasting until the set of net drives stops changing
    //
    for (;;)
    {
        //
        // If we're shutting down, do nothing
        //
        if (ScShutdownInProgress)
        {
            return;
        }

        //
        // Get the current net drive bitmask and compare against the net
        // drive bitmask when we last broadcast
        //
        NetDrives = ScGetNetworkDrives();

        SC_LOG2(BSM, "Previous net drives: %#lx   Now: %#lx\n",
                LastNetDrives, NetDrives);

        if (NetDrives == LastNetDrives)
        {
            break;
        }

        //
        // Broadcast about deleted volumes
        //
        dbv.dbcv_size       = sizeof(dbv);
        dbv.dbcv_devicetype = DBT_DEVTYP_VOLUME;
        dbv.dbcv_reserved   = 0;
        dbv.dbcv_unitmask   = LastNetDrives & ~NetDrives;
        dbv.dbcv_flags      = DBTF_NET;
        if (dbv.dbcv_unitmask != 0)
        {
            DWORD dwRec = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
            SC_LOG0(BSM, "Calling BroadcastSystemMessage...\n");
            status = BroadcastSystemMessage(
                        BSF_FORCEIFHUNG | BSF_NOHANG | BSF_NOTIMEOUTIFNOTHUNG,
                        &dwRec,
                        WM_DEVICECHANGE,
                        (WPARAM) DBT_DEVICEREMOVECOMPLETE,
                        (LPARAM)(DEV_BROADCAST_HDR*)(&dbv)
                        );
            SC_LOG0(BSM, "... returned\n");

            if (status <= 0)
            {
                SC_LOG2(ERROR, "BSM for deleted volumes %#lx FAILED, returned %ld\n",
                        dbv.dbcv_unitmask, status);
            }
        }

        //
        // Broadcast about added volumes
        //
        dbv.dbcv_unitmask   = NetDrives & ~LastNetDrives;
        if (dbv.dbcv_unitmask != 0)
        {
            DWORD dwRec = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
            SC_LOG0(BSM, "Calling BroadcastSystemMessage...\n");

            status = BroadcastSystemMessage(
                        BSF_FORCEIFHUNG | BSF_NOHANG | BSF_NOTIMEOUTIFNOTHUNG,
                        &dwRec,
                        WM_DEVICECHANGE,
                        (WPARAM) DBT_DEVICEARRIVAL,
                        (LPARAM)(DEV_BROADCAST_HDR*)(&dbv)
                        );

            SC_LOG0(BSM, "... returned\n");

            if (status <= 0)
            {
                SC_LOG2(ERROR, "BSM for added volumes %#lx FAILED, returned %ld\n",
                        dbv.dbcv_unitmask, status);
            }
        }

        //
        // Remember the drive set that we last broadcast about
        //
        LastNetDrives = NetDrives;

        //
        // Go around the loop again to detect changes that may have occurred
        // while we were broadcasting
        //
    }

    //
    // Add this work item back to the queue
    //
    SC_LOG0(BSM, "Re-waiting on BSM event\n");

    ntStatus = RtlRegisterWait(&g_hWorkitem,          // work item handle
                               hBSMEvent,             // waitable object handle
                               ScHandleBSMRequest,    // callback function
                               0,                     // parameter for callback function
                               INFINITE,              // infinite wait
                               WT_EXECUTEONLYONCE); // one-time work item

    if (!NT_SUCCESS(ntStatus))
    {
        SC_LOG1(ERROR, "ScInitBSM: RtlRegisterWait failed 0x%x\n", ntStatus);
        // CloseHandle(hBSMRequest);
        // hBSMRequest = NULL;
        // BUGBUG  No more events will be processed.  Event log this?
    }

    return;
}



DWORD
ScGetNetworkDrives(
    )
/*++

Routine Description:

    Returns a drive bitmask similar to GetLogicalDrives, but including
    only the network drives.

Arguments:

Return Value:


--*/
{

    WCHAR wszDrive[] = L" :\\";
    DWORD dwMask = 0;
    DWORD dwCurrDrive = 1;

    // For all the drives
    for (wszDrive[0] = L'A'; wszDrive[0] <= L'Z'; wszDrive[0]++, dwCurrDrive <<= 1)
    {
        if (GetDriveType(wszDrive) == DRIVE_REMOTE)
        {
            dwMask |= dwCurrDrive;
        }
    }

    return dwMask;
}



BOOL
ScCreateBSMEventSD(
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    )
/*++

Routine Description:

    This function creates a security descriptor for the BSM request event.
    It grants EVENT_ALL_ACCESS to local system and EVENT_MODIFY_STATE access
    to the rest of the world.  This prevents principals other than local
    system from waiting for the event.

Arguments:

    SecurityDescriptor - Receives a pointer to the new security descriptor.
        Should be freed with LocalFree.

Return Value:

    TRUE - success

    FALSE - failure, use GetLastError

History:

    AnirudhS  06-Jun-1996   Adapted from LsapAuCreatePortSD in auloop.c

--*/
{
    NTSTATUS    Status;
    ULONG       AclLength;
    PACL        EventDacl;


    //
    // Allocate a buffer to contain the SD followed by the DACL
    // Note, the well-known SIDs are expected to have been created
    // by this time
    //

    AclLength = (ULONG) sizeof(ACL) +
                   (2 * ((ULONG)sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
                   RtlLengthSid( LocalSystemSid ) +
                   RtlLengthSid( WorldSid );

    *SecurityDescriptor = (PSECURITY_DESCRIPTOR)
        LocalAlloc( 0, SECURITY_DESCRIPTOR_MIN_LENGTH + AclLength );

    if (*SecurityDescriptor == NULL) {
        return FALSE;
    }

    EventDacl = (PACL) ((BYTE*)(*SecurityDescriptor) + SECURITY_DESCRIPTOR_MIN_LENGTH);


    //
    // Set up a default ACL
    //
    //    Public: WORLD:EVENT_MODIFY_STATE, SYSTEM:all

    Status = RtlCreateAcl( EventDacl, AclLength, ACL_REVISION2);

    //
    // WORLD access
    //

    Status = RtlAddAccessAllowedAce (
                 EventDacl,
                 ACL_REVISION2,
                 EVENT_MODIFY_STATE,
                 WorldSid
                 );
    SC_ASSERT( NT_SUCCESS(Status) );


    //
    // SYSTEM access
    //

    Status = RtlAddAccessAllowedAce (
                 EventDacl,
                 ACL_REVISION2,
                 EVENT_ALL_ACCESS,
                 LocalSystemSid
                 );
    SC_ASSERT( NT_SUCCESS(Status) );



    //
    // Now initialize security descriptors
    // that export this protection
    //

    Status = RtlCreateSecurityDescriptor(
                 *SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    SC_ASSERT( NT_SUCCESS(Status) );
    Status = RtlSetDaclSecurityDescriptor(
                 *SecurityDescriptor,
                 TRUE,                       // DaclPresent
                 EventDacl,
                 FALSE                       // DaclDefaulted
                 );
    SC_ASSERT( NT_SUCCESS(Status) );


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scconfig.cxx ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    scconfig.cxx

Abstract:

    This module contains routines for manipulating configuration
    information.

    Configuration information is kept in the registry.
    This file contains the following functions:


        ScGetImageFileName
        ScInitSecurityProcess
        ScCreateLoadOrderGroupList
        ScGenerateServiceDB
        ScOpenServiceConfigKey
        ScReadServiceType
        ScReadStartName
        ScReadFailureActions
        ScWriteDependencies
        ScWriteErrorControl
        ScWriteGroupForThisService
        ScWriteImageFileName
        ScWriteServiceType
        ScWriteStartType
        ScWriteStartName
        ScWriteFailureActions
        ScWriteCurrentServiceValue
        ScReadServiceType
        ScReadStartType
        ScReadErrorControl
        ScReadServiceConfig
        ScAllocateAndReadConfigValue
        ScReadNoInteractiveFlag
        ScReadOptionalString
        ScWriteOptionalString

        ScGetToken
        ScOpenServicesKey
        ScRegCreateKeyExW
        ScRegOpenKeyExW
        ScRegQueryValueExW
        ScRegSetValueExW
        ScRegEnumKeyW

        ScRegDeleteKeyW
        ScRegQueryInfoKeyW
        ScRegEnumValueW
        ScHandleProviderChange
        ScMarkForDelete
        ScTakeOwnership

        ScMergeEnvironments

Author:

    Dan Lafferty (danl)     01-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    04-Apr-1991     danl
        created
    21-Apr-1992     JohnRo
        Export ScAllocateAndReadConfigValue().  Added ScOpenServiceConfigKey().
        Added ScWriteServiceType() and other ScWrite routines.
        Use SC_LOG0(), etc.  Use FORMAT_ equates.
    24-Apr-1992     JohnRo
        Make ScWriteStartType() write a DWORD, not a string, for consistency.
        Call ScWriteStartType() from ScTransferServiceToRegistry().
        Must call RegSetValueExW (not RegSetValueW) for non-strings.
    29-Apr-1992     JohnRo
        Move registry stuff from System\Services to
        System\Services\CurrentControlSet.
        Undo all group operations (ifdef USE_GROUPS).
        Undo reading from nt.cfg (we've got real registry) (ifdef
        USE_OLDCONFIG).
        They changed winreg APIs so REG_SZ is now UNICODE, so avoid REG_USZ.
    08-Aug-1992     Danl
        Added ScMarkForDelete & ScDeleteFlagIsSet.  ScReadServiceConfig is
        called for each service when generating the service database.  At the
        end of this routine, we check to see if the delete flag is set in
        the registry entry.  If it is, the delete flag is set in the service
        record so it can be deleted later.  After the list of service records
        is complete - and before the dependencies are generated, we call
        ScDeleteMarkedServices which walks through the list and deletes any
        service (in both the registry and linked list) that is marked for
        deletion.
    03-Nov-1992     Danl
        ScReadServiceConfig: If the ScAddCOnfigInfoServiceRecord call fails,
        we just want to skip the database entry - rather than fail the
        ScReadServiceConfig fuction.  Failing ScReadServiceConfig is a fatal
        error for the service controller.
    05-Nov-1992     Danl
        Added ScWriteDisplayName and ScReadDisplayName.  Modified
        ReadServiceConfig to read in the display name.
    29-Mar-1993     Danl
        Added SERVICE_RECOGNIZER_DRIVER as a type that is ignored when reading
        in the Service Database.
    01-Apr-1993 Danl
        Added ScTakeOwnership.  It is called when opening a key that
        complains about access denied.
    30-Apr-1993 Danl
        Put security descriptor in a separate key that only allows read
        access to LocalSystem and Administrators.  Also, we now delete the
        dependencies values from the registry when asked to write an empty
        string of dependencies.
    05-Aug-1993 Danl
        ScRegQueryValueExW: It there is no pointer to a buffer for the data
        to be returned in, then we always want to return
        STATUS_BUFFER_OVERFLOW, even if we successfully read the data into
        the functions internal buffer.
    20-Oct-1993 Danl
        InitSecurityProcess:  Use a global NetLogon service name, and set
        the ScConnectedToSecProc flag when we succeed in connecting to the
        SecurityProcess.
    16-Mar-1994 Danl
        ScRegOpenKeyExW:  Fixed Memory Leak. KeyPath was not being free'd.
        ScRegEnumKeyW:  Fixed Memory Leak. KeyInformation was not being free'd.
    12-Apr-1995 AnirudhS
        Added AccountName field to image record.
    04-Aug-1995 AnirudhS
        Close Lsa Event handle after use.
    05-Feb-1996 AnirudhS
        ScWriteSd: Don't close registry handle twice.  Don't close it at all
        if it's invalid.
    18-Nov-1998 jschwart
        Added ScValidateMultiSZ, since the SCM was assuming all MULTI_SZ
        values were properly double-NUL terminated and AVing when this
        was not the case.

--*/

#include "precomp.hxx"
#include <stdlib.h>     // wide character c runtimes.
#include <string.h>     // ansi character c runtimes.
#include <tstr.h>       // Unicode string macros
#include <sclib.h>      // ScConvertToAnsi
#include <control.h>    // ScWaitForConnect
#include "scconfig.h"   // ScGetToken
#include <valid.h>      // SERVICE_TYPE_INVALID().
#include <strarray.h>   // ScDisplayWStrArray
#include <scseclib.h>   // ScCreateAndSetSD
#include <regrpc.h>     // RPC_SECURITY_DESCRIPTOR
#include "depend.h"     // ScInHardwareProfile

#define ScWinRegErrorToApiStatus( regError ) \
    ( (DWORD) RegError )


//
// Constants
//

#define SECURITY_SERVICES_STARTED   TEXT("SECURITY_SERVICES_STARTED")
#define LSA_RPC_SERVER_ACTIVE       L"LSA_RPC_SERVER_ACTIVE"

#define REG_DELETE_FLAG             L"DeleteFlag"

//
// Registry keys/values
//
#define SERVICES_TREE               L"System\\CurrentControlSet\\Services"
#define CONTROL_TREE                L"System\\CurrentControlSet\\Control"
#define CURRENT_KEY                 L"ServiceCurrent"

#define DEFAULT_SERVICE_TYPE        SERVICE_DRIVER

//
// Used for the Nt Registry API.
//
#define SC_HKEY_LOCAL_MACHINE   L"\\REGISTRY\\MACHINE\\"


//
// Average Number of Bytes in a service record (including name).
//
#define AVE_SR_SIZE         260

//
// Static Global Variables
//

STATIC HKEY ScSGOKey = NULL;
STATIC DWORD Buffer;


//
// Local Function Prototypes
//


DWORD
ScReadServiceConfig(
    IN HKEY ServiceNameKey,
    IN LPWSTR ServiceName
    );

BOOL
ScDeleteFlagIsSet(
    HKEY    ServiceKeyHandle
    );

DWORD
ScTakeOwnership(
    POBJECT_ATTRIBUTES  pObja
    );

DWORD
ScOpenSecurityKey(
    IN HKEY     ServiceNameKey,
    IN DWORD    DesiredAccess,
    IN BOOL     CreateIfMissing,
    OUT PHKEY   pSecurityKey
    );

VOID
ScWaitForLsa(
    );



DWORD
ScMergeEnvironments (
    IN     LPWSTR  ServiceName,
    IN OUT LPVOID  *Environment
    )

/*++


Routine Description:

    Retrieves additional environment variables for the service. This is
    stored in the registry under the Environment value. The cluster
    service uses this to pass a partial environment block to services
    under control of the cluster software. This is merged with the
    service account's environment block.

Arguments:

    ServiceName - This is a pointer to a service name.  This identifies
        the service for which we desire an environment

    Environment - Supplies a pointer to the user's environment. May be
        modified as the environment variables are merged.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_PATH_NOT_FOUND - The environment could not be found
        or there was a registry error.

--*/
{
    DWORD ApiStatus;
    HKEY ServiceKey;
    LPWSTR RegistryEnvironment = NULL;
    DWORD EnvironmentSize;
    UNICODE_STRING ValueName;
    UNICODE_STRING Value;
    PWCHAR pValueName, pValue;
    NTSTATUS ntstatus;

    SC_ASSERT( ServiceName != NULL );

    //
    // Open the service key.
    //
    ApiStatus = ScOpenServiceConfigKey(
                   ServiceName,
                   KEY_READ,                    // desired access
                   FALSE,                       // don't create if missing.
                   &ServiceKey
                   );

    if (ApiStatus != NO_ERROR) {
        return ApiStatus;
    }

    //
    // Read the environment value from the registry and validate that
    // it is a properly formed MultiSZ.
    //
    ApiStatus = ScAllocateAndReadConfigValue(ServiceKey,
                                             ENVIRONMENT_VALUENAME_W,
                                             &RegistryEnvironment,
                                             &EnvironmentSize);
    ScRegCloseKey(ServiceKey);

    if (ApiStatus != NO_ERROR) {
        return ApiStatus;
    }

    ApiStatus = ScValidateMultiSZ(RegistryEnvironment,
                                  EnvironmentSize);

    if ( ApiStatus != NO_ERROR ) {
        LocalFree( RegistryEnvironment );
        return ApiStatus;
    }

    //
    // merge the two environment blocks together. Find each string in
    // the MultiSZ and have the RTL merge it into the supplied
    // environment.
    //
    pValueName = pValue = RegistryEnvironment;
    while ( *pValueName != UNICODE_NULL ) {
        //
        // find the value portion by scanning for the equal sign
        //
        while ( *pValue != L'=' && *pValue != UNICODE_NULL ) {
            ++pValue;
        }

        if ( *pValue == UNICODE_NULL ) {
            //
            // hmm.. found a null before finding the equal sign. skip
            // this entry since it appears to be improperly formed.
            //
            pValueName = ++pValue;
            continue;
        }

        //
        // init the env. variable name and value
        //
        *pValue = UNICODE_NULL;
        RtlInitUnicodeString( &ValueName, pValueName );

        ++pValue;
        RtlInitUnicodeString( &Value, pValue );
        ntstatus = RtlSetEnvironmentVariable(Environment,
                                             &ValueName,
                                             &Value);

        if ( ! NT_SUCCESS( ntstatus )) {
            ApiStatus = RtlNtStatusToDosError( ntstatus );
            break;
        }
        //
        // find the end of the current value
        //
        while ( *++pValue != UNICODE_NULL ) ;
        pValueName = ++pValue;
    }

    LocalFree( RegistryEnvironment );

    return ApiStatus;
}


DWORD
ScGetImageFileName (
    IN  LPWSTR  ServiceName,
    OUT LPWSTR  *ImageNamePtr
    )

/*++


Routine Description:

    Retreives the Name of the Image File in which the specified service
    can be found.  This routine allocates storage for the name so that
    a pointer to that name can be returned.

Arguments:

    ServiceName - This is a pointer to a service name.  This identifies
        the service for which we desire an image file name.

    ImageNamePtr - Returns a pointer to a location where the Image Name
        pointer is to be placed.  This memory should be freed with
        LocalFree.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_PATH_NOT_FOUND - The configuration component could not be found
        or there was a registry error.

--*/
{
    DWORD ApiStatus;
    HKEY ServiceKey;

    SC_ASSERT( ServiceName != NULL );

    //
    // Open the service key.
    //
    ApiStatus = ScOpenServiceConfigKey(
                   ServiceName,
                   KEY_READ,                    // desired access
                   FALSE,                       // don't create if missing.
                   &ServiceKey
                   );

    if (ApiStatus != NO_ERROR) {
        return ERROR_PATH_NOT_FOUND;
    }

    //
    // Read the binary path name
    //
    if (ScAllocateAndReadConfigValue(
              ServiceKey,
              IMAGE_VALUENAME_W,
              ImageNamePtr,
              NULL
              ) != NO_ERROR) {
        (void) ScRegCloseKey(ServiceKey);
        return ERROR_PATH_NOT_FOUND;
    }

    (void) ScRegCloseKey(ServiceKey);

    SC_LOG1(CONFIG, "ScGetImageFileName got " FORMAT_LPWSTR " from registry\n",
            *ImageNamePtr);

    return NO_ERROR;
}

#ifndef _CAIRO_

BOOL
ScInitSecurityProcess(
    LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This function determines the name of the security process, and then
    initializes a control pipe for it.  A global named event is then
    set.  This causes the security process to start its control dispatcher.
    The control dispatcher should then open the other end of the pipe and
    send its process id.  The processId and the name of the image file
    are stored in an image record for the security process.  The service
    instance count is incremented in this image record so that the
    record will never be deleted and the security process is never
    terminated.


    QUESTION:
        What is the proper behavior if this fails?

Arguments:

    ServiceRecord -- The service record of the service being started.
                     Note that as per the check in ScStartService, this
                     service runs in the security process (and is the
                     first service in that process being started)

Return Value:

    TRUE - The initialization was successful.

    FALSE - The initialization failed.  This indicates means that the
        service controller shouldn't continue with its initialization.
        If FALSE is returned, the service's service record has been
        marked (in the START_TYPE field) as disabled.

--*/
{
    DWORD               status;
    HANDLE              pipeHandle;
    LPIMAGE_RECORD      imageRecord;
    HANDLE              eventHandle;
    DWORD               processId;

    //
    // Create an instance of the control pipe.  Use an ID of 0 for lsass.exe
    // since it's possible for it to create its end of the pipe before we
    // ever get to this function.
    //

    status = ScCreateControlInstance (&pipeHandle, 0, LocalSystemSid);

    if (status != NO_ERROR) {

        SC_LOG1(ERROR,
                "ScInitSecurityProcess: ScCreateControlInstance Failure "
                    FORMAT_DWORD "\n",
                status);

        ServiceRecord->StartType = SERVICE_DISABLED;
        return FALSE;
    }

    //
    // Set the event that will cause the Control dispatcher in the
    // Security Process to be started.
    //

    eventHandle = CreateEvent( NULL,    // No special security
                               TRUE,    // Must be manually reset
                               FALSE,   // The event is initially not signalled
                               SECURITY_SERVICES_STARTED );


    if (eventHandle == NULL){
        status = GetLastError();

        //
        // If the event already exists, the security process beat us to
        // creating it.  Just open it.
        //

        if ( status == ERROR_ALREADY_EXISTS ) {

            eventHandle = OpenEvent( GENERIC_WRITE,
                                     FALSE,
                                     SECURITY_SERVICES_STARTED );

        }

        if (eventHandle == NULL ) {

            SC_LOG1(ERROR,"ScInitSecurityProcess: OpenEvent Failed "
                    FORMAT_DWORD "\n", status);

            CloseHandle(pipeHandle);
            ServiceRecord->StartType = SERVICE_DISABLED;
            return FALSE;
        }
    }

    if (!SetEvent(eventHandle)) {

        SC_LOG1(ERROR,"ScInitSecurityProcess: SetEvent Failed " FORMAT_DWORD
                "\n", GetLastError());
        CloseHandle(pipeHandle);
        CloseHandle(eventHandle);
        ServiceRecord->StartType = SERVICE_DISABLED;
        return FALSE;
    }

    //
    // Wait for the Security Process to attach to the pipe and get its PID
    //

    status = ScWaitForConnect(pipeHandle,
                              NULL,
                              ServiceRecord->DisplayName,
                              &processId);

    if (status != NO_ERROR) {

        SC_LOG1(ERROR,"ScInitSecurityProcess:"
                "SecurityProcess did not attach to pipe " FORMAT_DWORD "\n",
                status);
        CloseHandle(pipeHandle);
        CloseHandle(eventHandle);
        ServiceRecord->StartType = SERVICE_DISABLED;
        return FALSE;
    }

    //
    // Don't close the event handle until we know the security process has
    // seen the event.
    //

    CloseHandle(eventHandle);

    //
    //  NOTE:  The image record does not have a valid processHandle.
    //  Therefore, we will never be able to terminate it.  This is desired
    //  behavior though.  We should never terminate the security process.
    //

    status = ScCreateImageRecord (
                &imageRecord,
                ScGlobalSecurityExePath,
                NULL,           // Account name is LocalSystem
                processId,
                pipeHandle,
                NULL,           // The process handle is NULL.
                NULL,           // Token handle is also NULL -- LocalSystem
                NULL,           // No user profile loaded -- LocalSystem
                CANSHARE_FLAG |
                    IS_SYSTEM_SERVICE);

    if (status != NO_ERROR) {

        SC_LOG0(ERROR,"Failed to create ImageRecord for Security Process\n");
        ServiceRecord->StartType = SERVICE_DISABLED;
        return FALSE;
    }

    imageRecord->ServiceCount = 1;

    ScConnectedToSecProc = TRUE;

    return TRUE;
}
#endif // _CAIRO_


BOOL
ScCreateLoadOrderGroupList(
    VOID
    )
/*++

Routine Description:

    This function creates the load order group list from the group
    order information found in HKEY_LOCAL_SYSTEM\Service_Group_Order

Arguments:

    None

Return Value:

    TRUE - The operation was completely successful.

    FALSE - An error occurred.

Note:

    The GroupListLock must be held exclusively prior to calling this routine.

--*/
{
    DWORD status;
    DWORD dwGroupBytes;

    LONG RegError;
    LPWSTR Groups;
    LPWSTR GroupPtr;
    LPWSTR GroupName;

    SC_ASSERT(ScGroupListLock.HaveExclusive());

    //
    // Open the HKEY_LOCAL_MACHINE
    // System\CurrentControlSet\Control\ServiceGroupOrder key.
    //
    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   LOAD_ORDER_GROUP_LIST_KEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ,                  // desired access
                   &ScSGOKey
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG1(ERROR,
               "ScCreateLoadOrderGroupList: "
               "ScRegOpenKeyExW of HKEY_LOCAL_MACHINE\\System failed "
               FORMAT_LONG "\n", RegError);
        return FALSE;
    }

    //
    // Read the List value
    //
    if (ScAllocateAndReadConfigValue(
              ScSGOKey,
              GROUPLIST_VALUENAME_W,
              &Groups,
              &dwGroupBytes
              ) != NO_ERROR) {

        ScRegCloseKey(ScSGOKey);
        ScSGOKey = NULL;
        return FALSE;
    }

    if (ScValidateMultiSZ(
              Groups,
              dwGroupBytes
              ) != NO_ERROR) {

        LocalFree(Groups);
        ScRegCloseKey(ScSGOKey);
        ScSGOKey = NULL;
        return FALSE;
    }

    //
    // Leave the ServiceGroupOrder key open for change notify later
    //

    SC_LOG0(DEPEND_DUMP, "ScCreateLoadOrderGroupList: ServiceGroupOrder:\n");
    ScDisplayWStrArray(Groups);

    GroupPtr = Groups;
    while (*GroupPtr != 0) {

        if (ScGetToken(&GroupPtr, &GroupName)) {

            //
            // Add the group to the end of the load order group list
            //
            status = ScCreateOrderGroupEntry(
                         GroupName
                         );

            if (status != NO_ERROR) {
                //
                // Fatal error
                //
                LocalFree(Groups);
                return FALSE;
            }
        }
    }

    LocalFree(Groups);
    return TRUE;
}


BOOL
ScGenerateServiceDB(
    VOID
    )
/*++

Routine Description:

    This function creates the service record list from the information
    which resides in the registry.

Arguments:

    None

Return Value:

    TRUE - The operation was completely successful.

    FALSE - An error occurred.

NOTE:
    This function holds the GroupListLock.

--*/
{
    WCHAR ServiceName[MAX_SERVICE_NAME_LENGTH];
    DWORD Index = 0;

    LONG RegError;
    LONG lTempError;    // Used for debug messages only
    HKEY ServicesKey;
    HKEY ServiceNameKey;

    WCHAR       ClassName[ MAX_PATH ];
    DWORD       ClassNameLength = MAX_PATH;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;
    DWORD       HeapSize;


    //
    // Since there is only one thread at the time this function is called,
    // these locks are not really needed, but they are included to quell
    // assertions in the routines called herein.
    //
    CGroupListExclusiveLock GLock;
    CServiceListExclusiveLock LLock;
    CServiceRecordExclusiveLock RLock;

    //
    // Read in the group order list from the registry
    //
    if (! ScCreateLoadOrderGroupList()) {
        return FALSE;
    }

    //
    // Read in all the services entries from the registry
    //

    //
    // Open the key to the Services tree.
    //
    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   SERVICES_TREE,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ,                  // desired access
                   &ServicesKey
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG1(ERROR,
                "ScGenerateServiceDB: ScRegOpenKeyExW of Services tree failed "
                FORMAT_LONG "\n", RegError);
        return FALSE;
    }


    //
    // Find out how many service keys there are, and allocate a heap
    // that is twice as large.
    //
    RegError = ScRegQueryInfoKeyW(
                ServicesKey,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime);

    if (RegError != NO_ERROR) {
        SC_LOG1(ERROR,"ScGenerateServiceDatabase: RegQueryInfoKey failed %d\n",
        RegError);
        HeapSize = 0x8000;
    }
    else {
        SC_LOG1(INFO,"ScGenerateServiceDatabase: %d SubKeys\n",NumberOfSubKeys);
        HeapSize = NumberOfSubKeys*2*AVE_SR_SIZE;
    }

    if (!ScAllocateSRHeap(HeapSize)) {
        return(FALSE);
    }

    //
    // Enumerate all the service name keys
    //
    do {

        RegError = ScRegEnumKeyW(
                       ServicesKey,
                       Index,
                       ServiceName,
                       MAX_SERVICE_NAME_LENGTH * sizeof(WCHAR)
                       );

        if (RegError != ERROR_SUCCESS) {

            if (RegError == ERROR_NO_MORE_ITEMS) {
                //
                // No more entries
                //
                SC_LOG1(CONFIG,
                       "ScGenerateServiceDB: ScRegEnumKeyW returns ERROR_NO_MORE_ITEMS"
                       "(no more entries) for index " FORMAT_DWORD "\n",
                       Index);
            }
            else {
                //
                // Error trying to enumerate next service name key
                //
                SC_LOG1(ERROR,
                        "ScGenerateServiceDB: ScRegEnumKeyW of services tree failed "
                        FORMAT_LONG "\n", RegError );
                ScRegCloseKey(ServicesKey);
                return FALSE;
            }
        }
        else {
            //
            // Got the name of a new service key.  Open a handle to it.
            //
            SC_LOG1(CONFIG, "Service name key " FORMAT_LPWSTR "\n",
                    ServiceName);

            lTempError = ScRegOpenKeyExW(
                           ServicesKey,
                           ServiceName,
                           REG_OPTION_NON_VOLATILE,   // options
                           KEY_READ,                  // desired access
                           &ServiceNameKey);

            if (lTempError == ERROR_SUCCESS)
            {
                //
                // Read service config info from the registry and build the
                // service record.
                //
                lTempError = ScReadServiceConfig(
                               ServiceNameKey,
                               ServiceName);

                ScRegCloseKey(ServiceNameKey);

                if (lTempError != NO_ERROR)
                {
                    //
                    // Skip this key
                    //
                    SC_LOG2(ERROR,
                            "ScGenerateServiceDB: ScReadServiceConfig of "
                                   FORMAT_LPWSTR " failed " FORMAT_LONG "\n",
                           ServiceName,
                           lTempError);
                }
            }
            else
            {
                //
                // Skip this key
                //
                SC_LOG2(ERROR,
                        "ScGenerateServiceDB: ScRegOpenKeyExW of "
                               FORMAT_LPWSTR " failed " FORMAT_LONG "\n",
                       ServiceName,
                       lTempError);
            }
        }

        Index++;

    } while (RegError == ERROR_SUCCESS);

    ScRegCloseKey(ServicesKey);

    //
    // Wait for LSA to start since we are about to make our first call to
    // LSA and it typically is not already started yet.
    //
    ScWaitForLsa();

    //
    // Go through entire service record list and remove any services marked
    // for deletion.
    //
    ScDeleteMarkedServices();

    //
    // Go through entire service record list and resolve dependencies chain
    //
    ScGenerateDependencies();

#if DBG
    ScDumpGroups();
    ScDumpServiceDependencies();
#endif // DBG


    return TRUE;
}

VOID
ScWaitForLsa(
    )
/*++

Routine Description:

    This routine either creates or opens the event called LSA_RPC_SERVER_ACTIVE
    event and waits on it indefinitely until LSA signals it.  We need
    to know when LSA is available so that we can call LSA APIs.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD Status;
    HANDLE EventHandle;


    //
    // Create the named event LSA will set.
    //
    EventHandle = CreateEventW(
                      NULL,   // No special security
                      TRUE,   // Must be manually reset
                      FALSE,  // The event is initially not signalled
                      LSA_RPC_SERVER_ACTIVE
                      );

    if ( EventHandle == NULL ) {

        Status = GetLastError();

        //
        // If the event already exists, LSA has already created it.
        // Just open.
        //

        if ( Status == ERROR_ALREADY_EXISTS ) {

            EventHandle = OpenEventW(
                              SYNCHRONIZE,
                              FALSE,
                              LSA_RPC_SERVER_ACTIVE
                              );
        }

        if ( EventHandle == NULL ) {

            SC_LOG1(ERROR, "ScWaitForLsa: OpenEvent of LSA_RPC_SERVER_ACTIVE failed %d\n",
                    GetLastError());

            return;
        }
    }

    //
    // Wait for LSA to come up.
    //
    (VOID) WaitForSingleObject( EventHandle, INFINITE );

    CloseHandle( EventHandle );
}


DWORD
ScOpenServiceConfigKey(
    IN LPWSTR ServiceName,
    IN DWORD DesiredAccess,
    IN BOOL CreateIfMissing,
    OUT PHKEY ServiceKey
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    HKEY ServicesKey;
    HKEY ServiceNameKey;
    DWORD   ServicesAccess = KEY_READ;

    LONG RegError;

    SC_ASSERT( ServiceName != NULL );
    if (CreateIfMissing) {
        ServicesAccess |= KEY_CREATE_SUB_KEY;
    }

    //
    // Open the key to the Services tree.
    //
    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   SERVICES_TREE,
                   REG_OPTION_NON_VOLATILE, // options
                   ServicesAccess,          // desired access (this level)
                   &ServicesKey
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG1(ERROR, "ScOpenServiceConfigKey: "
                "ScRegOpenKeyExW of Services tree failed, reg error "
                FORMAT_LONG "\n", RegError);

        return ((DWORD) RegError);
    }

    if ( !CreateIfMissing ) {
        //
        // Open the existing service key.
        //
        RegError = ScRegOpenKeyExW(
               ServicesKey,
               ServiceName,
               REG_OPTION_NON_VOLATILE,   // options
               DesiredAccess,             // desired access
               & ServiceNameKey );

        if (RegError != ERROR_SUCCESS) {
            SC_LOG2(ERROR, "ScOpenServiceConfigKey: "
                    "ScRegOpenKeyExW of " FORMAT_LPWSTR " failed "
                    FORMAT_LONG "\n", ServiceName, RegError);
            (void) ScRegCloseKey(ServicesKey);
            return ((DWORD) RegError);
        }

    } else {

        DWORD Disposition;

        //
        // Create a new service key (or open existing one).
        //
        RegError = ScRegCreateKeyExW(
                ServicesKey,
                ServiceName,
                0,
                0,
                REG_OPTION_NON_VOLATILE, // options
                DesiredAccess,           // desired access
                NULL,
                &ServiceNameKey,
                &Disposition);

         if (RegError != ERROR_SUCCESS) {
             SC_LOG2(ERROR, "ScOpenServiceConfigKey: "
                     "ScRegCreateKeyExW of " FORMAT_LPWSTR " failed "
                     FORMAT_LONG "\n", ServiceName, RegError);
             ScRegCloseKey(ServicesKey);
             return ((DWORD) RegError);
         }

    }

    (void) ScRegCloseKey(ServicesKey);

    //
    // Give the service key back to caller.
    //
    *ServiceKey = ServiceNameKey;

    return NO_ERROR;

} // ScOpenServiceConfigKey


DWORD
ScWriteCurrentServiceValue(
    OUT LPDWORD  lpdwID
    )

/*++

Routine Description:

    Writes the value to be used in the next service's pipe name to the registry

Arguments:


Return Value:


--*/
{
    LONG                 RegError;
    NTSTATUS             ntstatus;
    SECURITY_ATTRIBUTES  SecurityAttr;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    DWORD                Disposition;

    //
    // Unique ID for the service to be started.  Start
    // at 1 since ID 0 is reserved for lsass.exe
    //
    static DWORD         s_dwCurrentService = 1;
    static HKEY          s_hCurrentKey      = NULL;


    SC_ASSERT(lpdwID != NULL);

    if (s_hCurrentKey == NULL)
    {
        HKEY  hKey;

        //
        // Open the key to the Services tree.
        //
        RegError = ScRegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       CONTROL_TREE,
                       0,                       // options (ignored)
                       KEY_WRITE,               // KEY_SET_VALUE | KEY_CREATE_SUB_KEY
                       &hKey
                       );

        if (RegError != ERROR_SUCCESS)
        {
            SC_LOG1(ERROR,
                    "ScWriteCurrentServiceValue: ScRegOpenKeyExW of Control tree failed, reg error "
                        FORMAT_LONG "\n",
                    RegError);

            return ((DWORD) RegError);
        }


#define SC_KEY_ACE_COUNT 2

        SC_ACE_DATA AceData[SC_KEY_ACE_COUNT] = {

            {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
                   GENERIC_ALL,                &LocalSystemSid},
            {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
                   GENERIC_READ,               &WorldSid}

            };


        //
        // Create a security descriptor for the registry key we are about
        // to create.  This gives everyone read access, and all access to
        // ourselves only.
        //
        ntstatus = ScCreateAndSetSD(
                       AceData,
                       SC_KEY_ACE_COUNT,
                       LocalSystemSid,
                       LocalSystemSid,
                       &SecurityDescriptor
                       );

#undef SC_KEY_ACE_COUNT

        if (! NT_SUCCESS(ntstatus)) {
            SC_LOG1(ERROR, "ScCreateAndSetSD failed " FORMAT_NTSTATUS
                    "\n", ntstatus);

            ScRegCloseKey(hKey);
            return(RtlNtStatusToDosError(ntstatus));
        }

        SecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttr.lpSecurityDescriptor = SecurityDescriptor;
        SecurityAttr.bInheritHandle = FALSE;

        //
        // Create a new  key (or open existing one).
        //
        RegError = ScRegCreateKeyExW(
                        hKey,
                        CURRENT_KEY,
                        0,
                        0,
                        REG_OPTION_VOLATILE, // options
                        KEY_SET_VALUE,       // desired access
                        &SecurityAttr,
                        &s_hCurrentKey,
                        &Disposition);

        RtlDeleteSecurityObject(&SecurityDescriptor);
        ScRegCloseKey(hKey);

        if (RegError != ERROR_SUCCESS)
        {
            SC_LOG1(ERROR,
                    "ScWriteCurrentServiceValue: ScRegCreateKeyExW of "
                        "CURRENT_KEY failed " FORMAT_LONG "\n",
                    RegError);

            return ((DWORD) RegError);
        }
    }

    //
    // Write the value in the key
    //

    RegError = ScRegSetValueExW(
                   s_hCurrentKey,
                   NULL,           // Use key's unnamed value
                   0,
                   REG_DWORD,
                   (LPBYTE) &s_dwCurrentService,
                   sizeof(DWORD));

    if (RegError != ERROR_SUCCESS)
    {
        SC_LOG1(ERROR,
                "ScWriteCurrentServiceValue: ScRegCreateKeyExW of "
                    "CURRENT_KEY failed " FORMAT_LONG "\n",
                RegError);

        return ((DWORD) RegError);
    }

    *lpdwID = s_dwCurrentService;
    s_dwCurrentService++;

    return NO_ERROR;

} // ScWriteCurrentServiceValue


DWORD
ScReadServiceType(
    IN HKEY ServiceNameKey,
    OUT LPDWORD ServiceTypePtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( ServiceTypePtr != NULL );

    *ServiceTypePtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   SERVICETYPE_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) ServiceTypePtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(TRACE, "ScReadServiceType: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                SERVICETYPE_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScReadServiceType

DWORD
ScReadNoInteractiveFlag(
    IN HKEY ServiceNameKey,
    OUT LPDWORD NoInteractivePtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( NoInteractivePtr != NULL );

    *NoInteractivePtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   NOINTERACTIVE_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) NoInteractivePtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(ERROR, "ScReadNoInteractiveFlag: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                NOINTERACTIVE_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScReadServiceType


DWORD
ScReadStartType(
    IN HKEY ServiceNameKey,
    OUT LPDWORD StartTypePtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( StartTypePtr != NULL );

    *StartTypePtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   START_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) StartTypePtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(ERROR, "ScReadStartType: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                START_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ));

} // ScReadStartType


DWORD
ScReadTag(
    IN HKEY ServiceNameKey,
    OUT LPDWORD TagPtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( TagPtr != NULL );

    *TagPtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   TAG_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) TagPtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(CONFIG, "ScReadTag: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                START_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ));

} // ScReadTag


DWORD
ScReadErrorControl(
    IN HKEY ServiceNameKey,
    OUT LPDWORD ErrorControlPtr
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD BytesRequired = sizeof(DWORD);
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( ErrorControlPtr != NULL );

    *ErrorControlPtr = 0;

    RegError = ScRegQueryValueExW(
                   ServiceNameKey,
                   ERRORCONTROL_VALUENAME_W,
                   NULL,
                   NULL,
                   (LPBYTE) ErrorControlPtr,
                   &BytesRequired
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG3(ERROR, "ScReadErrorControl: ScRegQueryValueExW of " FORMAT_LPWSTR
                " failed "
                FORMAT_LONG ", BytesRequired " FORMAT_DWORD "\n",
                ERRORCONTROL_VALUENAME_W, RegError, BytesRequired);
    }

    return (ScWinRegErrorToApiStatus( RegError ));


} // ScReadErrorControl



DWORD
ScReadFailureActions(
    IN HKEY ServiceNameKey,
    OUT LPSERVICE_FAILURE_ACTIONS_WOW64 * FailActPtr,
    IN OUT LPDWORD TotalBytes OPTIONAL
    )
/*++

Routine Description:

    This function attempts to read the value for the non-string portion
    of the service's failure actions configuration from the registry.
    If the value does not exist, or is invalid, this function sets the
    pointer to the value to NULL and returns NO_ERROR.  If any other error
    occurs, the error is returned.

    NOTE:  On return from this function, a buffer with the value will be
        allocated, or the pointer will be NULL.  If a buffer is allocated,
        it contains both the fixed-size structure and the array of actions.

Arguments:

    ServiceNameKey - This is the Service's Key handle.

    FailActPtr - This is a pointer to a location where the pointer to
        the failure actions information is to be placed.

    TotalBytes - If present, this DWORD is INCREMENTED by the number of bytes
        needed to store the string.

Return Value:


--*/
{
    DWORD BytesReturned;
    LONG RegError = ScAllocateAndReadConfigValue(
                ServiceNameKey,
                FAILUREACTIONS_VALUENAME_W,
                (LPWSTR *) FailActPtr,
                &BytesReturned
                );

    if (RegError != ERROR_SUCCESS)
    {
        if (RegError == ERROR_FILE_NOT_FOUND)
        {
            RegError = NO_ERROR;
        }

        *FailActPtr = NULL;

        return RegError;
    }

    //
    // Validate the value read.  Treat a bogus value as no value.
    //
    if ((BytesReturned < sizeof(SERVICE_FAILURE_ACTIONS_WOW64)) ||
        (BytesReturned != sizeof(SERVICE_FAILURE_ACTIONS_WOW64) +
                          (*FailActPtr)->cActions * sizeof(SC_ACTION)))
    {
        LocalFree(*FailActPtr);
        *FailActPtr = NULL;
        return NO_ERROR;
    }

    //
    // Fix up the pointer to the array.
    //
    (*FailActPtr)->dwsaActionsOffset = sizeof(SERVICE_FAILURE_ACTIONS_WOW64);

    //
    // Increment the total number of bytes used.
    //
    if (ARGUMENT_PRESENT(TotalBytes))
    {
        *TotalBytes += BytesReturned;
    }

    return NO_ERROR;

} // ScReadFailureActions


DWORD
ScReadOptionalString(
    IN  HKEY    ServiceNameKey,
    IN  LPCWSTR ValueName,
    OUT LPWSTR  *Value,
    IN OUT LPDWORD TotalBytes OPTIONAL
    )
/*++

Routine Description:

    This function attempts to read the value for the optional string
    configuration parameter from the registry.  If this read fails because
    the value does no exist, then this function sets the pointer to the
    value string to NULL, and returns NO_ERROR.  If any other error occurs,
    the error is returned.

    NOTE:  On successful return from this function, a buffer with the
        string value will be allocated, or the pointer will be NULL.
        If a string is returned, it is guaranteed to be non-empty and
        null-terminated (if the registry value was not null-terminated,
        its last character will be overwritten).

Arguments:

    ServiceNameKey - This is the Service's Key handle.

    ValueName - Name of the registry value from which to read.

    Value - This is a pointer to a location where the pointer to the
        string is to be placed.

    TotalBytes - If present, this DWORD is INCREMENTED by the number of bytes
        needed to store the string.

Return Value:



--*/
{
    DWORD BytesReturned;
    LONG RegError = ScAllocateAndReadConfigValue(
                ServiceNameKey,
                ValueName,
                Value,
                &BytesReturned
                );

    if (RegError != ERROR_SUCCESS)
    {
        // Nothing read from the registry.
        if (RegError == ERROR_FILE_NOT_FOUND)
        {
            RegError = NO_ERROR;
        }

        *Value = NULL;
        BytesReturned = 0;
    }
    else
    {
        // We read something from the registry.  Make sure it's
        // null-terminated.
        if (BytesReturned < sizeof(L" "))
        {
            LocalFree(*Value);
            *Value = NULL;
            BytesReturned = 0;
        }
        else
        {
            (*Value)[BytesReturned/sizeof(WCHAR) - 1] = L'\0';
        }
    }

    //
    // Increment the total number of bytes used.
    //
    if (ARGUMENT_PRESENT(TotalBytes))
    {
        *TotalBytes += (BytesReturned/sizeof(WCHAR)) * sizeof(WCHAR);
    }

    return RegError;

} // ScReadOptionalString


DWORD
ScReadStartName(
    IN HKEY ServiceNameKey,
    OUT LPWSTR *AccountName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    return ScAllocateAndReadConfigValue(
               ServiceNameKey,
               STARTNAME_VALUENAME_W,
               AccountName,
               NULL
               );

} // ScReadStartName


DWORD
ScReadSd(
    IN HKEY ServiceNameKey,
    OUT PSECURITY_DESCRIPTOR *Sd
    )
/*++

Routine Description:

    This function reads the security descriptor for the service

Arguments:



Return Value:



--*/
{
    LONG    RegError;
    HKEY    SecurityKey;
    DWORD   status;


    //
    // Open the Security Sub-key (under the services key).
    // NOTE:  This key may not exist, and that is ok.
    //
    RegError = ScOpenSecurityKey(
                ServiceNameKey,
                KEY_READ,
                FALSE,              // Do not create if missing.
                &SecurityKey);

    if (RegError != NO_ERROR) {
        SC_LOG1(TRACE,"ScReadSd:ScOpenSecurityKey Failed %d\n",RegError);
        return(ScWinRegErrorToApiStatus(RegError));
    }

    //
    // Read the Security Descriptor value stored under the security key.
    //
    status = ScAllocateAndReadConfigValue(
                 SecurityKey,
                 SD_VALUENAME_W,
                 (LPWSTR *) Sd,
                 NULL);

    if (status == NO_ERROR)
    {
        if (RtlValidSecurityDescriptor(*Sd))
        {
            status = NO_ERROR;
        }
        else
        {
            LocalFree(*Sd);
            *Sd = NULL;
            status = ERROR_FILE_NOT_FOUND;
        }
    }

    RegCloseKey(SecurityKey);
    return status;

} // ScReadSd



DWORD
ScWriteDependencies(
    IN HKEY ServiceNameKey,
    IN LPWSTR Dependencies,
    IN DWORD DependSize
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;
    LPWSTR DependOnService;
    LPWSTR DependOnGroup;
    LPWSTR DestService;
    LPWSTR DestGroup;
    DWORD DependencyLength;


    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( Dependencies != NULL );

    //
    // If the dependencies string is empty, then delete the dependency
    // values from the registry and return.  If errors occur during the
    // delete, we ignore them.  It could be that there aren't any existing
    // dependencies, so that the depend values don't exist to begin with.
    // Also, it the delete fails, we can't do anything about it anyway.
    //
    if (*Dependencies == L'\0') {

        RegError = ScRegDeleteValue(ServiceNameKey,DEPENDONSERVICE_VALUENAME_W);
        if ((RegError != ERROR_SUCCESS) && (RegError != ERROR_FILE_NOT_FOUND)) {
            SC_LOG1(ERROR, "Failed to delete DependOnService Value "
                "" FORMAT_LONG "\n",RegError);
        }
        RegError = ScRegDeleteValue(ServiceNameKey,DEPENDONGROUP_VALUENAME_W);
        if ((RegError != ERROR_SUCCESS) && (RegError != ERROR_FILE_NOT_FOUND)) {
            SC_LOG1(ERROR, "Failed to delete DependOnGroup Value "
                "" FORMAT_LONG "\n",RegError);
        }
        return(NO_ERROR);
    }

    //
    // Allocate a buffer which is twice the size of DependSize so that
    // we can split the Dependencies array string into a DependOnService,
    // and a DependOnGroup array strings.
    //
    if ((DependOnService = (LPWSTR)LocalAlloc(
                               LMEM_ZEROINIT,
                               (UINT) (2 * DependSize)
                               )) == NULL) {
        SC_LOG1(ERROR, "ScWriteDependencies: LocalAlloc failed " FORMAT_DWORD "\n",
                GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DependOnGroup = (LPWSTR) ((DWORD_PTR) DependOnService + DependSize);

    DestService = DependOnService;
    DestGroup = DependOnGroup;

    while ((*Dependencies) != 0) {

        if (*Dependencies == SC_GROUP_IDENTIFIERW) {

            Dependencies++;
            DependencyLength = (DWORD) wcslen(Dependencies) + 1;

            wcscpy(DestGroup, Dependencies);
            DestGroup += DependencyLength;
        }
        else {

            DependencyLength = (DWORD) wcslen(Dependencies) + 1;

            wcscpy(DestService, Dependencies);
            DestService += DependencyLength;
        }

        Dependencies += DependencyLength;
    }

    //
    // Write the DependOnService array string
    //
    RegError = ScRegSetValueExW(
                   ServiceNameKey,                  // open handle (to section)
                   DEPENDONSERVICE_VALUENAME_W,
                   0,
                   REG_MULTI_SZ,                    // type (NULL-NULL UNICODE string)
                   (LPBYTE) DependOnService,        // data
                   ScWStrArraySize(DependOnService) // byte count for data
                   );

    if (RegError != ERROR_SUCCESS) {
#if DBG
        SC_LOG1(ERROR, "ScWriteDependOnService: ScRegSetValueExW returned "
                FORMAT_LONG "\n", RegError);
        ScDisplayWStrArray(DependOnService);
#endif
        goto CleanExit;
    }

    //
    // Write the DependOnGroup array string
    //
    RegError = ScRegSetValueExW(
                   ServiceNameKey,                  // open handle (to section)
                   DEPENDONGROUP_VALUENAME_W,
                   0,
                   REG_MULTI_SZ,                    // type (NULL-NULL UNICODE string)
                   (LPBYTE) DependOnGroup,          // data
                   ScWStrArraySize(DependOnGroup)   // byte count for data
                   );

    if (RegError != ERROR_SUCCESS) {
#if DBG
        SC_LOG1(ERROR, "ScWriteDependOnGroup: ScRegSetValueExW returned "
                FORMAT_LONG "\n", RegError);
        ScDisplayWStrArray(DependOnGroup);
#endif
        goto CleanExit;
    }

CleanExit:
    LocalFree(DependOnService);
    if (RegError != NO_ERROR) {
        SC_LOG2(ERROR, "ScWriteDependencies (%ws) Error %d \n",
        Dependencies,RegError);
    }

    return (ScWinRegErrorToApiStatus( RegError ));

} // ScWriteDependencies


DWORD
ScWriteOptionalString(
    IN HKEY ServiceNameKey,
    IN LPCWSTR ValueName,
    IN LPCWSTR Value
    )
/*++

Routine Description:

    This function writes the specified string value to the registry for the
    particular key.  If the value is a NULL pointer, we don't do anything.  If
    the value is an empty string, we delete the registry value.

Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( ValueName != NULL && ValueName[0] != L'\0' );

    //
    // A NULL value means no change.
    //
    if (Value == NULL)
    {
        return NO_ERROR;
    }

    if (Value[0] != L'\0')
    {
        //
        // Write the Value
        //
        RegError = ScRegSetValueExW(
                       ServiceNameKey,           // open key handle
                       ValueName,                // value name
                       0,
                       REG_SZ,                   // type (zero-terminated UNICODE)
                       (LPBYTE) Value,           // data
                       (DWORD) WCSSIZE(Value));  // byte count for data

        if (RegError != ERROR_SUCCESS)
        {
            SC_LOG3(ERROR, "ScWriteStringParm: ScRegSetValueExW of \"%ws\" "
                    "to reg value %ws failed %ld\n",
                    Value, ValueName, RegError);
        }

        return RegError;
    }
    else
    {
        //
        // The value is specifically being cleared.  So we
        // want to delete the registry value.
        //
        RegError = ScRegDeleteValue(ServiceNameKey, ValueName);
        if (RegError != ERROR_SUCCESS)
        {
            if (RegError == ERROR_FILE_NOT_FOUND)
            {
                RegError = ERROR_SUCCESS;
            }
            else
            {
                SC_LOG2(ERROR, "ScWriteStringParm: ScRegDeleteValue of "
                        "reg value %ws failed %ld\n", ValueName, RegError);
            }
        }

        return RegError;
    }

} // ScWriteOptionalString



DWORD
ScWriteFailureActions(
    IN HKEY ServiceNameKey,
    IN LPSERVICE_FAILURE_ACTIONSW psfa
    )
/*++

Routine Description:

    This function writes ONLY the non-string fields of the
    SERVICE_FAILURE_ACTIONS structure to the registry for the specified
    key.  If the structure is a NULL pointer, we don't do anything.  If
    the structure contains no failure actions, we delete the registry value.

Arguments:


Return Value:


--*/
{
    SC_ASSERT( ServiceNameKey != NULL );

    //
    // A NULL structure or NULL array means no change.
    //
    if (psfa == NULL || psfa->lpsaActions == NULL)
    {
        return NO_ERROR;
    }

    if (psfa->cActions != 0)
    {
        //
        // Write the Value
        //

        //
        // Combine the SERVICE_FAILURE_ACTIONSW structure and the
        // array of SC_ACTION into a contiguous block.
        // The structure includes the string pointers, though we don't
        // actually use them when reading the structure back.
        //
        // Always write this structure out with 32-bit "pointers" since
        // that's the format we expect when we read it in (required for
        // backwards compatibility).
        //

        DWORD cbValueLen = sizeof(SERVICE_FAILURE_ACTIONS_WOW64) +
                           psfa->cActions * sizeof(SC_ACTION);

        LPSERVICE_FAILURE_ACTIONS_WOW64 psfaValue =
            (LPSERVICE_FAILURE_ACTIONS_WOW64) LocalAlloc(0, cbValueLen);

        if (psfaValue == NULL)
        {
            return (GetLastError());
        }

        psfaValue->dwResetPeriod     = psfa->dwResetPeriod;
        psfaValue->dwRebootMsgOffset = psfa->lpRebootMsg ? 1 : 0;
        psfaValue->dwCommandOffset   = psfa->lpCommand ? 1 : 0;
        psfaValue->cActions          = psfa->cActions;

        RtlCopyMemory(psfaValue + 1,
                      psfa->lpsaActions,
                      psfa->cActions * sizeof(SC_ACTION));

        //
        // Write the block to the registry
        //
        LONG RegError = ScRegSetValueExW(
                            ServiceNameKey,
                            FAILUREACTIONS_VALUENAME_W,
                            0,
                            REG_BINARY,
                            psfaValue,
                            cbValueLen
                            );

        if (RegError != ERROR_SUCCESS)
        {
            SC_LOG(ERROR, "ScWriteFailureActions: ScRegSetValueExW failed %ld\n",
                   RegError);
        }

        LocalFree(psfaValue);

        return RegError;
    }
    else
    {
        //
        // There are no failure actions to store.  So we
        // want to delete the registry value.
        //
        LONG RegError = ScRegDeleteValue(
                            ServiceNameKey,
                            FAILUREACTIONS_VALUENAME_W
                            );
        if (RegError != ERROR_SUCCESS)
        {
            if (RegError == ERROR_FILE_NOT_FOUND)
            {
                RegError = ERROR_SUCCESS;
            }
            else
            {
                SC_LOG(ERROR, "ScWriteFailureActions: ScRegDeleteValue failed %ld\n",
                        RegError);
            }
        }

        return RegError;
    }

} // ScWriteFailureActions


DWORD
ScWriteErrorControl(
    IN HKEY ServiceNameKey,
    IN DWORD ErrorControl
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( !ERROR_CONTROL_INVALID( ErrorControl ) );

    RegError = ScRegSetValueExW(
            ServiceNameKey,                     // key
            ERRORCONTROL_VALUENAME_W,           // value name
            0,
            REG_DWORD,                          // data type
            (LPBYTE) & ErrorControl,            // data
            sizeof(DWORD) );                    // byte count

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteErrorControl


DWORD
ScWriteSd(
    IN HKEY ServiceNameKey,
    IN PSECURITY_DESCRIPTOR Security
    )
/*++

Routine Description:

    This routine write the specified security descriptor to the registry.

Arguments:



Return Value:



--*/
{
    LONG    RegError;
    HKEY    SecurityKey;
    ULONG   SdLength;

    SC_ASSERT( ServiceNameKey != NULL );

    if (Security == NULL) {
        return NO_ERROR;
    }
    SdLength = RtlLengthSecurityDescriptor(Security);
    if (SdLength == 0) {
        return(NO_ERROR);
    }

    SC_LOG1(SECURITY, "ScWriteSd: Size of security descriptor %lu\n", SdLength);

    //
    // Open the Security Sub-key (under the service key).
    //
    RegError = ScOpenSecurityKey(
                ServiceNameKey,
                KEY_READ | KEY_WRITE,
                TRUE,                   // CreateIfMissing
                &SecurityKey);

    if (RegError != NO_ERROR) {
        SC_LOG1(ERROR,"ScWriteSd:ScOpenSecurityKey Failed %d\n",RegError);
    }
    else
    {
        //
        // Write the Security Descriptor to the Security Value in the Security
        // Key.
        //
        RegError = ScRegSetValueExW(
                SecurityKey,                        // key
                SD_VALUENAME_W,                     // value name
                0,                                  // reserved
                REG_BINARY,                         // data type
                (LPBYTE) Security,                  // data
                SdLength                            // byte count
                );

        if (RegError != NO_ERROR) {
            SC_LOG1(ERROR,"ScWriteSd:ScRegSetValueExW Failed %d\n",RegError);
        }

        RegCloseKey(SecurityKey);
    }

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteSd


#ifdef USE_GROUPS
DWORD
ScWriteGroupForThisService(
    IN HKEY ServiceNameKey,
    IN LPWSTR Group
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( Group != NULL );

    //
    // Write the group
    //
    RegError = ScRegSetValueExW(
                   ServiceNameKey,           // open handle (to section)
                   GROUP_VALUENAME_W,        // value name
                   0,
                   REG_SZ,                   // type (zero-terminated UNICODE)
                   (LPBYTE) Group,           // data
                   (DWORD) WCSSIZE(Group));  // byte count for data

    if (RegError != ERROR_SUCCESS) {
        SC_LOG2(ERROR, "ScWriteGroupForThisService: ScRegSetValueExW of "
                FORMAT_LPWSTR " failed " FORMAT_LONG "\n",
                Group, RegError);
    }

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteGroupForThisService
#endif // USE_GROUPS


DWORD
ScWriteImageFileName(
    IN HKEY hServiceKey,
    IN LPWSTR ImageFileName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );
    SC_ASSERT( ImageFileName != NULL );

    //
    // Write the binary path name
    //
    RegError = ScRegSetValueExW(
            hServiceKey,                      // open handle (to section)
            IMAGE_VALUENAME_W,                // value name
            0,
            REG_EXPAND_SZ,                    // type (zero-terminated UNICODE)
            (LPBYTE) ImageFileName,           // data
            (DWORD) WCSSIZE(ImageFileName));  // byte count for data

    if (RegError != ERROR_SUCCESS) {
        SC_LOG2(ERROR, "ScWriteImageFileName: ScRegSetValueExW of "
                FORMAT_LPWSTR " failed " FORMAT_LONG "\n",
                ImageFileName, RegError);
    }

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return ( (DWORD) RegError );

} // ScWriteImageFileName


DWORD
ScWriteServiceType(
    IN HKEY hServiceKey,
    IN DWORD dwServiceType
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );
    SC_ASSERT( !SERVICE_TYPE_INVALID( dwServiceType ) );
    SC_ASSERT( dwServiceType != SERVICE_WIN32 );  // Don't write ambig info.

    RegError = ScRegSetValueExW(
            hServiceKey,                        // key
            SERVICETYPE_VALUENAME_W,            // value name
            0,
            REG_DWORD,                          // data type
            (LPBYTE) & dwServiceType,           // data
            sizeof(DWORD) );                    // byte count

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteServiceType


DWORD
ScWriteStartType(
    IN HKEY hServiceKey,
    IN DWORD dwStartType
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );
    SC_ASSERT( !START_TYPE_INVALID( dwStartType ) );

    RegError = ScRegSetValueExW(
            hServiceKey,                        // key
            START_VALUENAME_W,                  // value name
            0,
            REG_DWORD,                          // data type
            (LPBYTE) &dwStartType,              // data
            sizeof( DWORD ) );                  // byte count

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteStartType


DWORD
ScWriteTag(
    IN HKEY hServiceKey,
    IN DWORD dwTag
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );

    RegError = ScRegSetValueExW(
            hServiceKey,                        // key
            TAG_VALUENAME_W,                    // value name
            0,
            REG_DWORD,                          // data type
            (LPBYTE) &dwTag,                    // data
            sizeof( DWORD ) );                  // byte count

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteTag


VOID
ScDeleteTag(
    IN HKEY hServiceKey
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( hServiceKey != NULL );

    RegError = ScRegDeleteValue(
            hServiceKey,                        // key
            TAG_VALUENAME_W);                   // value name

    SC_LOG1(DEPEND, "ScRegDeleteValue of Tag returns %ld\n", RegError);

} // ScDeleteTag


DWORD
ScWriteStartName(
    IN HKEY ServiceNameKey,
    IN LPWSTR StartName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LONG RegError;

    SC_ASSERT( ServiceNameKey != NULL );
    SC_ASSERT( StartName != NULL );

    //
    // Write the StartName
    //
    RegError = ScRegSetValueExW(
                   ServiceNameKey,               // open handle (to section)
                   STARTNAME_VALUENAME_W,        // value name
                   0,
                   REG_SZ,                       // type (zero-terminated UNICODE)
                   (LPBYTE) StartName,           // data
                   (DWORD) WCSSIZE(StartName));  // byte count for data

    if (RegError != ERROR_SUCCESS) {
        SC_LOG2(ERROR, "ScWriteStartName: ScRegSetValueExW of " FORMAT_LPWSTR
                " failed " FORMAT_LONG "\n",
                StartName, RegError);
    }

    SC_ASSERT( RegError == ERROR_SUCCESS );

    return (ScWinRegErrorToApiStatus( RegError ) );

} // ScWriteStartName



DWORD
ScReadServiceConfig(
    IN HKEY ServiceNameKey,
    IN LPWSTR ServiceName
    )
/*++

Routine Description:

    This function reads the service configuration information and
    creates a service record in memory with the information.

Arguments:

    ServiceNameKey - Supplies opened handle to the service key to read
        from.

    ServiceName - Supplies name of the service.

Return Value:

    TRUE - Service record is created successfully.

    FALSE - Error in creating the service record.  If an error occurs here,
        it is generally considered a fatal error which will cause the
        service controller to fail to start.

Note:

    The GroupListLock must be held exclusively prior to calling this routine.

--*/
{
    DWORD status;

    DWORD StartType;
    DWORD ServiceType;
    DWORD ErrorControl;
    DWORD Tag;
    LPWSTR Group = NULL;
    LPWSTR Dependencies = NULL;
    LPWSTR DisplayName=NULL;
    PSECURITY_DESCRIPTOR Sd = NULL;

    LPSERVICE_RECORD ServiceRecord;

    SC_ASSERT(ScGroupListLock.HaveExclusive());

    //
    // Get the Service Type information from the registry
    //
    status = ScReadServiceType(ServiceNameKey, &ServiceType);
    if (status != NO_ERROR) {
        SC_LOG1(TRACE, "Ignored " FORMAT_LPWSTR ".  No ServiceType\n",
                ServiceName);
        return NO_ERROR;  // Skip service entry and ignore error.
    }

    //
    // If service type is not one of type SERVICE_WIN32 or SERVICE_DRIVER,
    // do not bother saving it in a service record because it's data
    // for services.
    //
    if (SERVICE_TYPE_INVALID(ServiceType)) {
        if ((ServiceType != SERVICE_ADAPTER) &&
            (ServiceType != SERVICE_RECOGNIZER_DRIVER)) {
            SC_LOG2(ERROR, "Ignored " FORMAT_LPWSTR ".  Invalid ServiceType "
                    FORMAT_HEX_DWORD "\n", ServiceName, ServiceType);
        }
        return NO_ERROR;
    }
    SC_LOG1(CONFIG, "    ServiceType " FORMAT_HEX_DWORD "\n", ServiceType);


    //
    // Read the StartType value
    //
    status = ScReadStartType(ServiceNameKey, &StartType);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "Ignored " FORMAT_LPWSTR ".  No StartType\n",
                ServiceName);
        return NO_ERROR;  // Skip service entry and ignore error.
    }
    SC_LOG1(CONFIG, "    StartType " FORMAT_HEX_DWORD "\n", StartType);

    //
    // Read the ErrorControl value
    //
    status = ScReadErrorControl(ServiceNameKey, &ErrorControl);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "Ignored " FORMAT_LPWSTR ".  No ErrorControl\n",
                ServiceName);
        return NO_ERROR;  // Skip service entry and ignore error.
    }
    SC_LOG1(CONFIG, "    ErrorControl " FORMAT_HEX_DWORD "\n", ErrorControl);


    //
    // Read the optional Tag value.  0 means no tag.
    //
    status = ScReadTag(ServiceNameKey, &Tag);
    if (status != NO_ERROR) {
        Tag = 0;
    }

    //
    // Read the Group value
    //
    if (ScAllocateAndReadConfigValue(
            ServiceNameKey,
            GROUP_VALUENAME_W,
            &Group,
            NULL
            ) != NO_ERROR) {

        Group = NULL;
    }
    else {
        SC_LOG1(CONFIG, "    Belongs to group " FORMAT_LPWSTR "\n", Group);
    }

    //
    // Read the Dependencies
    //

    status = ScReadDependencies(ServiceNameKey, &Dependencies, ServiceName);
    if (status != NO_ERROR) {
        Dependencies = NULL;
    }


    //
    // Read the security descriptor
    //
    if (ScReadSd(
            ServiceNameKey,
            &Sd
            ) != NO_ERROR) {

        Sd = NULL;
    }

    //
    // Read the Display Name
    // NOTE: If an error occurs, or the name doesn't exist, then a NULL
    // pointer is returned from this call.
    //
    ScReadDisplayName(ServiceNameKey, &DisplayName);

    //
    // Get an exclusive lock on the database so we can read and
    // make modifications.
    //
    SC_ASSERT(ScServiceListLock.HaveExclusive());
    SC_ASSERT(ScServiceRecordLock.HaveExclusive());

    //
    // See if the service record already exists
    //
    status = ScGetNamedServiceRecord(
                 ServiceName,
                 &ServiceRecord
                 );

    if (status == ERROR_SERVICE_DOES_NOT_EXIST) {

        //
        // Create a service record for this service
        //
        status = ScCreateServiceRecord(
                    ServiceName,
                    &ServiceRecord
                    );
    }

    if (status != NO_ERROR) {
        goto CleanExit;
    }

    //
    // Insert the config information into the service record
    //
    status = ScAddConfigInfoServiceRecord(
                ServiceRecord,
                ServiceType,
                StartType,
                ErrorControl,
                Group,
                Tag,
                Dependencies,
                DisplayName,
                Sd
                );

    if (status != NO_ERROR) {
        //
        // Fail to set meaningful data into service record.  Remove the service
        // record from the service record list and delete it.  This is not
        // a fatal error.  Instead, we just leave this entry out of the
        // database.
        //
        REMOVE_FROM_LIST(ServiceRecord);

        ScFreeServiceRecord(ServiceRecord);

        status = NO_ERROR;
    }
    else {

        //
        // Should the service be deleted?
        // The service entry in the registry cannot be deleted while we
        // are enumerating services, therefore we must mark it and delete it
        // later.
        //
        if (ScDeleteFlagIsSet(ServiceNameKey)) {
            SC_LOG(TRACE,"ScReadServiceConfig: %ws service marked for delete\n",
                ServiceRecord->ServiceName);
            SET_DELETE_FLAG(ServiceRecord);
        }
    }
CleanExit:

    LocalFree(Group);
    LocalFree(Dependencies);
    LocalFree(DisplayName);

    return status;
}


DWORD
ScAllocateAndReadConfigValue(
    IN  HKEY    Key,
    IN  LPCWSTR  ValueName,
    OUT LPWSTR  *Value,
    OUT LPDWORD BytesReturned OPTIONAL
    )
/*++

Routine Description:

    This function allocates the output buffer and reads the requested
    value from the registry into it.  It is useful for reading string
    data of undeterministic length.


Arguments:

    Key - Supplies opened handle to the key to read from.

    ValueName - Supplies name of the value to retrieve data.

    Value - Returns a pointer to the output buffer which points to
        the memory allocated and contains the data read in from the
        registry.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - Failed to create buffer to read value into.

    Error from registry call.

--*/
{
    LONG    RegError;
    DWORD   NumRequired = 0;
    WCHAR   Temp[1];
    LPWSTR  TempValue = NULL;
    DWORD   ValueType;
    DWORD   CharsReturned;


    //
    // Set returned buffer pointer to NULL.
    //
    *Value = NULL;

    RegError = ScRegQueryValueExW(
                   Key,
                   ValueName,
                   NULL,
                   &ValueType,
                   (LPBYTE) NULL,
                   &NumRequired
                   );

    if (RegError != ERROR_SUCCESS && NumRequired > 0) {

        SC_LOG3(CONFIG, "ScAllocateAndReadConfig: ScRegQueryKeyExW of "
                FORMAT_LPWSTR " failed " FORMAT_LONG ", NumRequired "
                FORMAT_DWORD "\n",
                ValueName, RegError, NumRequired);

        if ((TempValue = (LPWSTR)LocalAlloc(
                          LMEM_ZEROINIT,
                          (UINT) NumRequired
                          )) == NULL) {
            SC_LOG2(ERROR, "ScAllocateAndReadConfig: LocalAlloc of size "
                    FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                    NumRequired, GetLastError());
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RegError = ScRegQueryValueExW(
                       Key,
                       ValueName,
                       NULL,
                       &ValueType,
                       (LPBYTE) TempValue,
                       &NumRequired
                       );
    }

    if (RegError != ERROR_SUCCESS) {

        if (RegError != ERROR_FILE_NOT_FOUND) {
            SC_LOG3(ERROR, "ScAllocateAndReadConfig: ScRegQueryKeyExW of "
                    FORMAT_LPWSTR " failed " FORMAT_LONG ", NumRequired "
                    FORMAT_DWORD "\n",
                    ValueName, RegError, NumRequired);
        }

        LocalFree(TempValue);

        return (DWORD) RegError;
    }

    if (ValueType != REG_EXPAND_SZ || TempValue == NULL) {
        *Value = TempValue;
        if (BytesReturned != NULL) {
            *BytesReturned = NumRequired;
        }
        return(NO_ERROR);
    }

    //
    // If the ValueType is REG_EXPAND_SZ, then we must call the
    // function to expand environment variables.
    //
    SC_LOG1(CONFIG,"ScAllocateAndReadConfig: Must expand the string for "
        FORMAT_LPWSTR "\n", ValueName);

    //
    // Make the first call just to get the number of characters that
    // will be returned.
    //
    NumRequired = ExpandEnvironmentStringsW (TempValue,Temp, 1);

    if (NumRequired > 1) {

        *Value = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (UINT) (NumRequired * sizeof(WCHAR)));

        if (*Value == NULL) {

            SC_LOG2(ERROR, "ScAllocateAndReadConfig: LocalAlloc of numChar= "
                FORMAT_DWORD " failed " FORMAT_DWORD "\n",
                NumRequired, GetLastError());

            LocalFree(TempValue);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        CharsReturned = ExpandEnvironmentStringsW (
                            TempValue,
                            *Value,
                            NumRequired);

        if (CharsReturned > NumRequired) {
            SC_LOG1(ERROR, "ScAllocAndReadConfig: ExpandEnvironmentStrings "
                " failed for " FORMAT_LPWSTR " \n", ValueName);

            LocalFree(*Value);
            *Value = NULL;
            LocalFree(TempValue);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        LocalFree(TempValue);

        if (BytesReturned != NULL) {
            *BytesReturned = CharsReturned * sizeof(WCHAR);
        }
        return(NO_ERROR);

    }
    else {
        //
        // This call should have failed because of our ridiculously small
        // buffer size.
        //

        SC_LOG0(ERROR, "ScAllocAndReadConfig: ExpandEnvironmentStrings "
            " Should have failed because we gave it a BufferSize=1\n");

        //
        // This could happen if the string was a single byte long and
        // didn't really have any environment values to expand.  In this
        // case, we return the TempValue buffer pointer.
        //
        *Value = TempValue;

        if (BytesReturned != NULL) {
            *BytesReturned = sizeof(WCHAR);
        }
        return(NO_ERROR);
    }
}



DWORD
ScGetGroupVector(
    IN  LPWSTR Group,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    )

{
    DWORD status;
    LONG RegError;
    HKEY VectorsKey;


    //
    // Open the HKEY_LOCAL_MACHINE
    // System\CurrentControlSet\Control\GroupOrderList key.
    //
    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   GROUP_VECTORS_KEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ,                  // desired access
                   &VectorsKey
                   );

    if (RegError != ERROR_SUCCESS) {
        SC_LOG(ERROR, "ScGetGroupVector: Open of GroupOrderList key failed "
               FORMAT_LONG "\n", RegError);

        return (DWORD) RegError;
    }

    //
    // Read the value with the valuename of the specified group
    //
    status = ScAllocateAndReadConfigValue(
                 VectorsKey,
                 Group,
                 (LPWSTR *)Buffer,
                 BufferSize
                 );

    (void) ScRegCloseKey(VectorsKey);

    return status;
}


BOOL
ScGetToken(
    IN OUT LPWSTR *CurrentPtr,
    OUT    LPWSTR *TokenPtr
    )
/*++

Routine Description:

    This function takes a pointer into a given NULL-NULL-terminated buffer
    and isolates the next string token in it.  The CurrentPtr is incremented
    past the NULL byte of the token found if it is not the end of the buffer.
    The TokenPtr returned points to the token in the buffer and is NULL-
    terminated.

Arguments:

    CurrentPtr - Supplies a pointer to the buffer to extract the next token.
        On output, this pointer is set past the token found.

    TokenPtr - Supplies the pointer to the token found.

Return Value:

    TRUE - If a token is found.

    FALSE - No token is found.

--*/
{

    if (*(*CurrentPtr) == 0) {
        return FALSE;
    }

    *TokenPtr = *CurrentPtr;

    *CurrentPtr = ScNextWStrArrayEntry((*CurrentPtr));

    return TRUE;

}

DWORD
ScOpenServicesKey(
    OUT PHKEY ServicesKey
    )
{
    LONG RegError;

    RegError = ScRegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   SERVICES_TREE,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ | DELETE,         // desired access
                   ServicesKey
                   );

    return (ScWinRegErrorToApiStatus( RegError ));
}

DWORD
ScRegCreateKeyExW(
    IN  HKEY                    hKey,
    IN  LPWSTR                  lpSubKey,
    IN  DWORD                   dwReserved,
    IN  LPWSTR                  lpClass,
    IN  DWORD                   dwOptions,
    IN  REGSAM                  samDesired,
    IN  LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    OUT PHKEY                   phKeyResult,
    OUT LPDWORD                 lpdwDisposition
    )

/*++

Routine Description:

    NOTE:  This routine only creates one key at a time.  If the lpSubKey
        parameter includes keys that don't exist, an error will result.
        For instance, if "\\new\\key\\here" is passed in, "new" and "key"
        are expected to exist.  They will not be created by this call.

Arguments:


Return Value:


Note:


--*/
{
    NTSTATUS            ntStatus;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      KeyName;
    UNICODE_STRING      ClassString;

    UNREFERENCED_PARAMETER(dwReserved);

    RtlInitUnicodeString(&KeyName,lpSubKey);
    RtlInitUnicodeString(&ClassString,lpClass);

    InitializeObjectAttributes(
        &Obja,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        hKey,
        ARGUMENT_PRESENT(lpSecurityAttributes) ?
            lpSecurityAttributes->lpSecurityDescriptor :
            NULL);


    ntStatus = NtCreateKey(
                (PHANDLE)phKeyResult,
                (ACCESS_MASK)samDesired,
                &Obja,
                0,
                &ClassString,
                (ULONG)dwOptions,
                (PULONG)lpdwDisposition);


    return(RtlNtStatusToDosError(ntStatus));
}


DWORD
ScRegOpenKeyExW(
    IN  HKEY    hKey,
    IN  LPWSTR  lpSubKey,
    IN  DWORD   dwOptions,
    IN  REGSAM  samDesired,
    OUT PHKEY   phKeyResult
    )
/*++

Routine Description:

    NOTE:  This function will only accept one of the WinReg Pre-defined
        handles - HKEY_LOCAL_MACHINE.  Passing any other type of Pre-defined
        handle will cause an error.

Arguments:


Return Value:


Note:


--*/
{
    NTSTATUS            ntStatus;
    DWORD               status;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      KeyNameString;
    LPWSTR              KeyPath;
    DWORD               stringSize;
    LPWSTR              HKeyLocalMachine = SC_HKEY_LOCAL_MACHINE;
    HKEY                tempHKey;
    BOOL                KeyPathIsAllocated=FALSE;


    UNREFERENCED_PARAMETER(dwOptions);

    //
    // If we are opening the Pre-Defined Key (HKEY_LOCAL_MACHINE), then
    // pre-pend "\\REGISTRY\\MACHINE\\" to the subKey string.
    //
    if (hKey == HKEY_LOCAL_MACHINE) {
        stringSize = (DWORD) WCSSIZE(HKeyLocalMachine) + (DWORD) WCSSIZE(lpSubKey);
        KeyPath = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (UINT) stringSize);
        if (KeyPath == NULL) {
            SC_LOG0(ERROR,"ScRegOpenKeyExW: Local Alloc Failed\n");
            return(GetLastError());
        }
        KeyPathIsAllocated=TRUE;
        wcscpy(KeyPath,HKeyLocalMachine);
        wcscat(KeyPath,lpSubKey);
        tempHKey = NULL;
    }
    else {
        KeyPath = lpSubKey;
        tempHKey = hKey;
    }

    RtlInitUnicodeString(&KeyNameString,KeyPath);

    InitializeObjectAttributes(
        &Obja,
        &KeyNameString,
        OBJ_CASE_INSENSITIVE,
        tempHKey,
        NULL);

    ntStatus = NtOpenKey(
                (PHANDLE)phKeyResult,
                (ACCESS_MASK)samDesired,
                &Obja);

    if (ntStatus == STATUS_ACCESS_DENIED) {

        SC_LOG0(ERROR,"ScOpenKeyExW: NtOpenKey ACCESS_DENIED try to Take Ownership\n");

        status = ScTakeOwnership(&Obja);
        if (status != NO_ERROR) {
            if (KeyPathIsAllocated) {
                LocalFree(KeyPath);
            }
            return(status);
        }

        //
        // Now try to open the key with the desired access.
        //
        ntStatus = NtOpenKey(
                    (PHANDLE)phKeyResult,
                    (ACCESS_MASK)samDesired,
                    &Obja);
        if (!NT_SUCCESS(ntStatus)) {
            SC_LOG(ERROR, "ScRegOpenKeyExW: NtOpenKey(final try) failed %x\n",
            ntStatus);
        }
    }

    if (KeyPathIsAllocated) {
        LocalFree(KeyPath);
    }
    return(RtlNtStatusToDosError(ntStatus));
}

DWORD
ScRegQueryValueExW(
    IN      HKEY    hKey,
    IN      LPCWSTR lpValueName,
    OUT     LPDWORD lpReserved,
    OUT     LPDWORD lpType,
    OUT     LPBYTE  lpData,
    IN OUT  LPDWORD lpcbData
    )
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/

{

    NTSTATUS                    ntStatus;
    UNICODE_STRING              ValueName;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    DWORD                       bufSize;

    UNREFERENCED_PARAMETER(lpReserved);

    //
    // Make sure we have a buffer size if the buffer is present.
    //

    if ((ARGUMENT_PRESENT(lpData)) && (!ARGUMENT_PRESENT(lpcbData))) {
        return(ERROR_INVALID_PARAMETER);
    }

    RtlInitUnicodeString(&ValueName, lpValueName);

    //
    // Compute size of value information and allocate buffer.
    //

    bufSize = 0;
    if (ARGUMENT_PRESENT(lpcbData)) {
        bufSize = *lpcbData;
    }

    bufSize += FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
    KeyValueInfo =
            (PKEY_VALUE_PARTIAL_INFORMATION)LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (KeyValueInfo == NULL) {
        SC_LOG0(ERROR,"ScRegQueryValueExW: LocalAlloc Failed");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ntStatus = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInfo,
                bufSize,
                &bufSize);

    if (NT_SUCCESS(ntStatus) || (ntStatus == STATUS_BUFFER_OVERFLOW)) {
        if (ARGUMENT_PRESENT(lpcbData)) {
            *lpcbData = KeyValueInfo->DataLength;
        }

        if (ARGUMENT_PRESENT(lpType)) {
            *lpType = KeyValueInfo->Type;
        }
    }

    if (NT_SUCCESS(ntStatus) && ARGUMENT_PRESENT(lpData)) {
        RtlCopyMemory(lpData, &KeyValueInfo->Data[0], KeyValueInfo->DataLength);
    }

    LocalFree(KeyValueInfo);
    return RtlNtStatusToDosError(ntStatus);
}


DWORD
ScRegSetValueExW(
    IN  HKEY    hKey,
    IN  LPCWSTR lpValueName,
    IN  DWORD   lpReserved,
    IN  DWORD   dwType,
    IN  LPVOID  lpData,
    IN  DWORD   cbData
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    UNICODE_STRING              ValueName;


    UNREFERENCED_PARAMETER(lpReserved);

    RtlInitUnicodeString(&ValueName,lpValueName);

    ntStatus = NtSetValueKey(
                hKey,
                &ValueName,
                0,
                (ULONG)dwType,
                (PVOID)lpData,
                (ULONG)cbData);

    status = RtlNtStatusToDosError(ntStatus);

    if (status != NO_ERROR)
    {
        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED_II,
            L"ScRegSetValueExW",
            lpValueName,
            status
            );
    }

    return(status);

}

DWORD
ScRegDeleteValue(
    IN  HKEY    hKey,
    IN  LPCWSTR lpValueName
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    NTSTATUS                    ntStatus;
    UNICODE_STRING              ValueName;


    RtlInitUnicodeString(&ValueName,lpValueName);

    ntStatus = NtDeleteValueKey(
                hKey,
                &ValueName);

    return(RtlNtStatusToDosError(ntStatus));

}


DWORD
ScRegEnumKeyW(
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpName,
    DWORD   cbName
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    NTSTATUS                    ntStatus;
    PKEY_BASIC_INFORMATION      KeyInformation;
    ULONG                       resultLength;
    DWORD                       bufSize;

    //
    // Allocate a buffer for the Key Information.
    //
    bufSize = sizeof(KEY_BASIC_INFORMATION) + cbName;
    KeyInformation = (PKEY_BASIC_INFORMATION)LocalAlloc(LMEM_ZEROINIT, (UINT) bufSize);
    if (KeyInformation == NULL){
        SC_LOG0(ERROR,"ScRegEnumKey: LocalAlloc Failed\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ntStatus = NtEnumerateKey(
                (HANDLE)hKey,
                (ULONG)dwIndex,
                KeyBasicInformation,
                (PVOID)KeyInformation,
                (ULONG)bufSize,
                (PULONG)&resultLength);

    if (!NT_SUCCESS(ntStatus)) {
        LocalFree(KeyInformation);
        return(RtlNtStatusToDosError(ntStatus));
    }

    if (cbName < (KeyInformation->NameLength + sizeof(WCHAR))) {
        LocalFree(KeyInformation);
        return(ERROR_MORE_DATA);
    }

    RtlCopyMemory(lpName, KeyInformation->Name, KeyInformation->NameLength);
    *(lpName + (KeyInformation->NameLength/sizeof(WCHAR))) = L'\0';

    LocalFree(KeyInformation);
    return(NO_ERROR);
}


DWORD
ScRegDeleteKeyW (
    HKEY    hKey,
    LPWSTR  lpSubKey
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD       status;
    NTSTATUS    ntStatus;
    HKEY        keyToDelete;

    status = ScRegOpenKeyExW(
                hKey,
                lpSubKey,
                0,
                KEY_READ | READ_CONTROL | DELETE,
                &keyToDelete);

    if (status != NO_ERROR) {
        SC_LOG2(ERROR, "ScRegDeleteKeyW: ScRegOpenKeyExW (%ws) Failed %d\n",
            lpSubKey,
            status);
        return(status);
    }

    ntStatus = NtDeleteKey(keyToDelete);

    NtClose(keyToDelete);

    return(RtlNtStatusToDosError(ntStatus));
}

DWORD
ScRegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD                   status;
    NTSTATUS                ntStatus;
    NTSTATUS                ntStatus2;
    PSECURITY_DESCRIPTOR    SecurityDescriptor=NULL;
    ULONG                   SecurityDescriptorLength;
    PKEY_FULL_INFORMATION   KeyInfo;
    DWORD                   bufSize;
    DWORD                   bytesReturned;
    DWORD                   classBufSize;


    UNREFERENCED_PARAMETER(lpReserved);

    classBufSize = *lpcbClass;
    bufSize = sizeof(KEY_FULL_INFORMATION) + *lpcbClass;

    KeyInfo = (PKEY_FULL_INFORMATION)LocalAlloc(LMEM_ZEROINIT, bufSize);
    if (KeyInfo == NULL) {
        SC_LOG0(ERROR,"RegQueryInfoKeyW: LocalAlloc failed\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ntStatus = NtQueryKey(
                hKey,
                KeyFullInformation,
                (PVOID)KeyInfo,
                bufSize,
                &bytesReturned);

    status = RtlNtStatusToDosError(ntStatus);

    if (ntStatus == STATUS_SUCCESS) {
        ntStatus2 = NtQuerySecurityObject(
                        hKey,
                        OWNER_SECURITY_INFORMATION
                        | GROUP_SECURITY_INFORMATION
                        | DACL_SECURITY_INFORMATION,
                        SecurityDescriptor,
                        0,
                        lpcbSecurityDescriptor
                        );
        //
        // If getting the size of the SECURITY_DESCRIPTOR failed (probably
        // due to the lack of READ_CONTROL access) return zero.
        //

        if( ntStatus2 != STATUS_BUFFER_TOO_SMALL ) {

            *lpcbSecurityDescriptor = 0;

        } else {

            //
            // Try again to get the size of the key's SECURITY_DESCRIPTOR,
            // this time asking for SACL as well. This should normally
            // fail but may succeed if the caller has SACL access.
            //

            ntStatus2 = NtQuerySecurityObject(
                            hKey,
                            OWNER_SECURITY_INFORMATION
                            | GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION
                            | SACL_SECURITY_INFORMATION,
                            SecurityDescriptor,
                            0,
                            &SecurityDescriptorLength
                            );


            if( ntStatus2 == STATUS_BUFFER_TOO_SMALL ) {

                //
                // The caller had SACL access so update the returned
                // length.
                //

                *lpcbSecurityDescriptor = SecurityDescriptorLength;
            }

        }

        *lpcbClass              = KeyInfo->ClassLength;
        *lpcSubKeys             = KeyInfo->SubKeys;
        *lpcbMaxSubKeyLen       = KeyInfo->MaxNameLen;
        *lpcbMaxClassLen        = KeyInfo->MaxClassLen;
        *lpcValues              = KeyInfo->Values;
        *lpcbMaxValueNameLen    = KeyInfo->MaxValueNameLen;
        *lpcbMaxValueLen        = KeyInfo->MaxValueDataLen;
        *lpftLastWriteTime      = *(PFILETIME) &KeyInfo->LastWriteTime;

        if (KeyInfo->ClassLength > classBufSize) {
            LocalFree(KeyInfo);
            return(RtlNtStatusToDosError(STATUS_BUFFER_TOO_SMALL));
        }
        RtlCopyMemory(
            lpClass,
            (LPBYTE)KeyInfo->Class,
            KeyInfo->ClassLength);

        //
        // NUL terminate the class name.
        //
        *(lpClass + (KeyInfo->ClassLength/sizeof(WCHAR))) = UNICODE_NULL;

    }
    else
    {
        //
        // NtQueryKey failed
        //

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            L"ScRegQueryInfoKeyW",
            status
            );
    }

    LocalFree(KeyInfo);

    return(status);
}


DWORD
ScRegEnumValueW (
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    NTSTATUS                    ntStatus;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    DWORD                       bufSize;
    DWORD                       resultSize;
    DWORD                       totalSize;    // size of string including NUL
    BOOL                        stringData = FALSE;

    UNREFERENCED_PARAMETER(lpReserved);
    //
    // Make sure we have a buffer size if the buffer is present.
    //
    if ((ARGUMENT_PRESENT(lpData)) && (!ARGUMENT_PRESENT(lpcbData))) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Compute size of KeyValueInfo, round to pointer size, and allocate
    // buffer.
    //

    bufSize = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name) + (MAX_PATH * sizeof(WCHAR));
    bufSize = (bufSize + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1);
    bufSize += *lpcbData;

    KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION)LocalAlloc(
                    LMEM_ZEROINIT,
                    (UINT) bufSize);
    if (KeyValueInfo == NULL) {
        SC_LOG0(ERROR,"ScRegEnumValueW: LocalAlloc Failed\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ntStatus = NtEnumerateValueKey(
                (HANDLE)hKey,
                (ULONG)dwIndex,
                KeyValueFullInformation,
                (PVOID)KeyValueInfo,
                (ULONG)bufSize,
                (PULONG)&resultSize);

    if (ntStatus == STATUS_BUFFER_OVERFLOW) {

        LocalFree(KeyValueInfo);

        KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION)LocalAlloc(
                        LMEM_ZEROINIT,
                        (UINT) resultSize);
        if (KeyValueInfo == NULL) {
            SC_LOG0(ERROR,"ScRegEnumValueW: LocalAlloc (2nd try) Failed\n");
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        ntStatus = NtEnumerateValueKey(
                    hKey,
                    (ULONG)dwIndex,
                    KeyValueFullInformation,
                    (PVOID)KeyValueInfo,
                    (ULONG)bufSize,
                    (PULONG)&resultSize);

        if (ntStatus != STATUS_SUCCESS) {
            LocalFree(KeyValueInfo);
            return(RtlNtStatusToDosError(ntStatus));
        }
    }
    else if (ntStatus != STATUS_SUCCESS) {
        LocalFree(KeyValueInfo);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // The API was successful (from our point of view.  Now see if the
    // callers buffers were large enough.
    //
    totalSize = KeyValueInfo->NameLength+sizeof(WCHAR);  // add 1 for the NUL terminator.

    if (*lpcbValueName < totalSize) {
        *lpcbValueName = totalSize;
        *lpcbData = KeyValueInfo->DataLength;
        LocalFree(KeyValueInfo);
        return(ERROR_INSUFFICIENT_BUFFER);
    }
    else {
        RtlCopyMemory(
            lpValueName,
            (LPBYTE)KeyValueInfo->Name,
            KeyValueInfo->NameLength);

        *lpcbValueName = totalSize;

        //
        // NUL terminate the Value name.
        //
        *(lpValueName + (KeyValueInfo->NameLength/sizeof(WCHAR))) = UNICODE_NULL;

    }

    if (ARGUMENT_PRESENT(lpData)) {

        totalSize = KeyValueInfo->DataLength;

#ifdef REMOVE
        //
        // I believe I can remove this because data strings will be
        // stored with NULL terminators.
        //

        if((KeyValueInfo->Type == REG_SZ)        ||
           (KeyValueInfo->Type == REG_EXPAND_SZ) ||
           (KeyValueInfo->Type == REG_MULTI_SZ))  {

            totalSize += sizeof(WCHAR);
            stringData = TRUE;
        }

#endif // REMOVE

        if (*lpcbData < totalSize) {
            *lpcbData = totalSize;
            LocalFree(KeyValueInfo);
            return(ERROR_INSUFFICIENT_BUFFER);
        }
        else {
            RtlCopyMemory(
                lpData,
                (LPBYTE)KeyValueInfo + KeyValueInfo->DataOffset,
                KeyValueInfo->DataLength);

            *lpcbData = KeyValueInfo->DataLength;
            if (stringData) {
                *lpcbData += sizeof(WCHAR);
                //
                // NUL terminate the string Data.
                //
                *((LPWSTR)lpData + (KeyValueInfo->DataLength/sizeof(WCHAR))) = UNICODE_NULL;
            }
        }
    }

    if (ARGUMENT_PRESENT(lpType)) {
        *lpType = KeyValueInfo->Type;
    }

    LocalFree(KeyValueInfo);
    return(NO_ERROR);

}


VOID
ScHandleProviderChange(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    )

/*++

Routine Description:

    Processes changes to the list of network providers in the registry
    and publishes a list of those that are currently active in the HW
    profile for mpr.dll to use.

Arguments:


Return Value:


--*/
{
    DWORD   dwStatus;
    LPWSTR  lpProviderList = NULL;

    DWORD   dwLength;
    DWORD   dwTempLength;
    UINT    i;
    DWORD   dwCurrentChar;
    DWORD   dwNameStart;

    BOOL    fWriteList = TRUE;
    LPWSTR  lpList = NULL;

    HKEY                 hProviderHwKey;
    HKEY                 hProviderKey;
    DWORD                dwDisposition;
    SECURITY_ATTRIBUTES  SecurityAttr;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    static  HANDLE  s_hWorkItem;

#define SC_KEY_ACE_COUNT 2

    SC_ACE_DATA AceData[SC_KEY_ACE_COUNT] = {

        {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
               GENERIC_ALL,                &LocalSystemSid},
        {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
               GENERIC_READ,               &WorldSid}

        };


    SC_ASSERT(fWaitStatus == FALSE);
    SC_ASSERT(g_hProviderKey != NULL);

    if (ScShutdownInProgress)
    {
        return;
    }

    if (s_hWorkItem != NULL)
    {
        dwStatus = RtlDeregisterWait(s_hWorkItem);

        if (!NT_SUCCESS(dwStatus))
        {
            SC_LOG(ERROR,
                   "ScHandleProviderChange: RtlDeregisterWait FAILED %#x\n",
                   dwStatus);
        }
    }

    //
    // Reset the event
    //
    ResetEvent((HANDLE)pContext);

    SC_LOG0(TRACE, "ScHandleProviderChange: ProviderOrder key changed\n");

    //
    // Reregister for registry change notifications in case the key
    // changes while we're in this routine.  Note that there's no
    // race condition since the work item is a one-shot -- only one
    // thread can be in this routine at a time.
    //
    dwStatus = RegNotifyChangeKeyValue(
                   g_hProviderKey,
                   FALSE,                      // Don't watch subkeys
                   REG_NOTIFY_CHANGE_LAST_SET, // Watch for value changes
                   (HANDLE)pContext,           // Event to signal
                   TRUE);                      // Asynchronous

    if (dwStatus != NO_ERROR)
    {
        //
        // We won't pick up any further changes to the provider list.
        // Keep going so we at least pick up this one.
        //
        SC_LOG(ERROR,
               "ScHandleProviderChange: RegNotifyChangeKeyValue FAILED %d\n",
               dwStatus);
    }

    dwStatus = ScAllocateAndReadConfigValue(g_hProviderKey,
                                            PROVIDER_VALUE,
                                            &lpProviderList,
                                            &dwLength);

    if (dwStatus != NO_ERROR)
    {
        SC_LOG(ERROR,
               "ScHandleProviderChange: Unable to read ProviderOrder %d\n",
               dwStatus);

        goto Reregister;
    }

    //
    // This should be a REG_SZ -- check the basics
    //
    if ((dwLength % 2 != 0)
          ||
        (dwLength < sizeof(UNICODE_NULL))
          ||
        (lpProviderList[dwLength / sizeof(WCHAR) - 1] != UNICODE_NULL))
    {
        SC_LOG0(ERROR,
                "ScHandleProviderChange: Invalid REG_SZ for ProviderOrder\n");

        goto Reregister;
    }

    dwTempLength  = dwLength;
    dwCurrentChar = 0;
    dwNameStart   = 0;

    //
    // For each character in the original string
    //
    for (i = 0; i < dwTempLength; i += sizeof(WCHAR))
    {
        WCHAR  wcTemp = lpProviderList[dwCurrentChar];

        //
        // The provider list is comma-delimited
        //
        if (wcTemp == L',' || wcTemp == UNICODE_NULL)
        {
            lpProviderList[dwCurrentChar] = UNICODE_NULL;

            if (!ScInHardwareProfile(&lpProviderList[dwNameStart], 0))
            {
                //
                // The string plus the trailing UNICODE_NULL
                //
                DWORD dwBytes = (dwCurrentChar - dwNameStart + 1) * sizeof(WCHAR);

                //
                // Service is disabled in the HW profile
                //
                SC_LOG(TRACE,
                       "ScHandleProviderChange: Service %ws is disabled\n",
                       &lpProviderList[dwNameStart]);

                //
                // Shift over the remaining characters in the buffer.
                //
                RtlMoveMemory(&lpProviderList[dwNameStart],
                              &lpProviderList[dwCurrentChar + 1],
                              dwLength - (dwCurrentChar + 1) * sizeof(WCHAR));

                //
                // This may cause dwCurrentChar to underflow to
                // 0xffffffff (if the first provider was deleted).
                // This is OK -- it'll be incremented (to 0) below.
                //
                dwLength     -= dwBytes;
                dwCurrentChar = dwNameStart - 1;
            }
            else
            {
                //
                // Restore the temp character and move
                // to the start of the next provider name.
                //
                lpProviderList[dwCurrentChar] = wcTemp;
                dwNameStart = dwCurrentChar + 1;
            }
        }

        dwCurrentChar++;
    }

    //
    // If the last provider name was deleted, the string will
    // end with a ',' instead of a '\0'.  Note that if all the
    // provider names were deleted, dwCurrentChar will be 0 --
    // we increment it to empty out the provider list.
    //
    if (dwCurrentChar == 0)
    {
        dwCurrentChar++;
    }

    lpProviderList[dwCurrentChar - 1] = UNICODE_NULL;

    SC_LOG(TRACE,
           "ScHandleProviderChange: Provider list is now %ws\n",
           lpProviderList);

    dwStatus = ScRegOpenKeyExW(HKEY_LOCAL_MACHINE,
                               PROVIDER_KEY_BASE,
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE | KEY_READ,
                               &hProviderKey);

    if (dwStatus != NO_ERROR)
    {
        SC_LOG(ERROR,
               "ScHandleProviderChange: Unable to open provider key %d\n",
               dwStatus);

        goto Reregister;
    }

    //
    // Create a security descriptor for the registry key we are about
    // to create.  This gives everyone read access, and all access to
    // ourselves only.
    //
    dwStatus = ScCreateAndSetSD(AceData,
                                SC_KEY_ACE_COUNT,
                                LocalSystemSid,
                                LocalSystemSid,
                                &SecurityDescriptor);

#undef SC_KEY_ACE_COUNT

    if (!NT_SUCCESS(dwStatus))
    {
       SC_LOG1(ERROR,
               "ScHandleProviderChange: ScCreateAndSetSD failed %#x\n",
               dwStatus);

       ScRegCloseKey(hProviderKey);
       goto Reregister;
    }

    SecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttr.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttr.bInheritHandle = FALSE;

    //
    // Create a new HW provider subkey (or open existing one).
    //
    dwStatus = ScRegCreateKeyExW(hProviderKey,
                                 PROVIDER_KEY_HW,
                                 0,
                                 0,
                                 REG_OPTION_VOLATILE,
                                 KEY_SET_VALUE | KEY_QUERY_VALUE,
                                 &SecurityAttr,
                                 &hProviderHwKey,
                                 &dwDisposition);

    RtlDeleteSecurityObject(&SecurityDescriptor);
    ScRegCloseKey(hProviderKey);

    if (dwStatus != NO_ERROR)
    {
        SC_LOG(ERROR,
               "ScHandleProviderChange: Unable to open HW subkey %d\n",
               dwStatus);

        goto Reregister;
    }

    //
    // Write the modified list to the registry, but only if it is
    // different from the list already there.  This will prevent
    // mpr.dll from getting hyperactive on spurious (or repeated)
    // registry change notifications.
    //
    dwStatus = ScAllocateAndReadConfigValue(hProviderHwKey,
                                            PROVIDER_VALUE,
                                            &lpList,
                                            &dwTempLength);

    if (dwStatus == NO_ERROR)
    {
        //
        // If the string lengths are different, there's
        // definitely been a provider change.
        //
        if (dwTempLength == dwLength)
        {
            fWriteList = (_wcsnicmp(lpList,
                                    lpProviderList,
                                    dwTempLength / sizeof(WCHAR)) != 0);
        }

        LocalFree(lpList);
    }

    if (fWriteList)
    {
        SC_LOG0(TRACE,
                "Active provider list is different -- writing new list\n");

        dwStatus = ScRegSetValueExW(hProviderHwKey,
                                    PROVIDER_VALUE,
                                    0,
                                    REG_SZ,
                                    (LPBYTE) lpProviderList,
                                    dwLength);

        if (dwStatus != NO_ERROR)
        {
            SC_LOG(ERROR,
                   "ScHandleProviderChange: Unable to write HW-aware list %d\n",
                   dwStatus);
        }
    }
    else
    {
        SC_LOG0(TRACE,
                "Active provider list is the same -- not writing\n");
    }

    ScRegCloseKey(hProviderHwKey);

Reregister:

    LocalFree(lpProviderList);

    dwStatus = RtlRegisterWait(&s_hWorkItem,           // work item handle
                               (HANDLE) pContext,      // watiable handle
                               ScHandleProviderChange, // callback
                               (HANDLE) pContext,      // callback arg
                               INFINITE,
                               WT_EXECUTEINPERSISTENTIOTHREAD |
                                   WT_EXECUTEONLYONCE);

    if (!NT_SUCCESS(dwStatus))
    {
        SC_LOG(ERROR,
               "ScHandleProviderChange: RtlRegisterWait FAILED %#x\n",
               dwStatus);
    }
}


VOID
ScMarkForDelete(
    LPSERVICE_RECORD  ServiceRecord
    )

/*++

Routine Description:

    This function adds a DeleteFlag value to a service key in the registry.

Arguments:

    ServiceName - This is a pointer to the service name string.

Return Value:

    none.

--*/
{
    DWORD   status;
    HKEY    hServiceKey;
    DWORD   deleteFlag=1;

    status = ScOpenServiceConfigKey(
                ServiceRecord->ServiceName,
                KEY_WRITE,              // desired access
                FALSE,                  // don't create if missing
                &hServiceKey);

    if (status != NO_ERROR) {
        SC_LOG1(TRACE,"ScMarkForDelete:ScOpenServiceConfigKey failed %d\n",status);
        return;
    }

    status = ScRegSetValueExW(
                hServiceKey,
                REG_DELETE_FLAG,
                0,
                REG_DWORD,
                (LPBYTE)&deleteFlag,
                sizeof(DWORD));

    if (status != NO_ERROR) {
        SC_LOG1(TRACE,"ScMarkForDelete:ScRegSetValueExW failed %d\n",status);
        (void) ScRegCloseKey(hServiceKey);
        return;
    }

    //
    // Make sure we're disabling the service in case it's a driver started by the
    // kernel before we get a chance to delete the key on the next boot
    //
    ASSERT(ServiceRecord->StartType == SERVICE_DISABLED);

    status = ScWriteStartType(hServiceKey, ServiceRecord->StartType);

    if (status != NO_ERROR) {
        SC_LOG1(TRACE,"ScMarkForDelete:ScRegSetValueExW failed %d\n",status);
    }

    (void) ScRegCloseKey(hServiceKey);

    return;
}

BOOL
ScDeleteFlagIsSet(
    HKEY    ServiceKeyHandle
    )

/*++

Routine Description:

    This function looks for a delete flag value stored in the registry for
    this service.

Arguments:

    ServiceKeyHandle - This is a handle to the service key.

Return Value:

    TRUE - if the delete flag exists.
    FALSE - otherwise.

--*/
{
    DWORD   status;
    DWORD   value;
    DWORD   valueSize = sizeof(DWORD);
    DWORD   type;

    status = ScRegQueryValueExW(
                ServiceKeyHandle,
                REG_DELETE_FLAG,
                NULL,
                &type,
                (LPBYTE)&value,
                &valueSize);

    if (status == NO_ERROR) {
        return(TRUE);
    }
    return(FALSE);
}


DWORD
ScReadDependencies(
    HKEY    ServiceNameKey,
    LPWSTR  *Dependencies,
    LPWSTR  ServiceName
    )

/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    LPWSTR  DependOnService      = NULL;
    LPWSTR  DependOnGroup        = NULL;
    DWORD   DependOnServiceSize  = 0;
    DWORD   DependOnGroupSize    = 0;
    DWORD   status               = NO_ERROR;

    //
    // Read the DependOnService value
    //
    if (ScAllocateAndReadConfigValue(
              ServiceNameKey,
              DEPENDONSERVICE_VALUENAME_W,
              &DependOnService,
              &DependOnServiceSize
              ) != NO_ERROR)
    {
        DependOnService     = NULL;
        DependOnServiceSize = 0;
    }

    //
    // We write a length of 2 bytes into the
    // registry for an empty REG_MULTI_SZ.
    //
    else if ((DependOnServiceSize >= sizeof(WCHAR)) && (*DependOnService != L'\0'))
    {
        //
        // Make sure we got a valid MULTI_SZ
        //
        status = ScValidateMultiSZ(DependOnService,
                                   DependOnServiceSize);

        if (status != NO_ERROR) {

            SC_LOG2(CONFIG,
                    "ScReadDependencies: ScValidateMultiSZ failed %d for service %ws\n",
                    status,
                    ServiceName);

            //
            // Set this to NULL since we'll LocalFree it in CleanExit below
            //
            LocalFree(DependOnService);
            DependOnService     = NULL;
            DependOnServiceSize = 0;
        }

#if DBG
        SC_LOG1(CONFIG, "    " FORMAT_LPWSTR " DependOnService\n", ServiceName);
        ScDisplayWStrArray(DependOnService);
#endif

    }

    //
    // Read the DependOnGroup value
    //
    if (ScAllocateAndReadConfigValue(
              ServiceNameKey,
              DEPENDONGROUP_VALUENAME_W,
              &DependOnGroup,
              &DependOnGroupSize
              ) != NO_ERROR)
    {
        DependOnGroup     = NULL;
        DependOnGroupSize = 0;
    }

    //
    // We write a length of 2 bytes into the
    // registry for an empty REG_MULTI_SZ.
    //
    else if ((DependOnGroupSize >= sizeof(WCHAR)) && (*DependOnGroup != L'\0'))
    {
        //
        // Make sure we got a valid MULTI_SZ
        //
        status = ScValidateMultiSZ(DependOnGroup,
                                   DependOnGroupSize);

        if (status != NO_ERROR) {

            SC_LOG2(CONFIG,
                    "ScReadDependencies: ScValidateMultiSZ failed %d for service %ws\n",
                    status,
                    ServiceName);

            //
            // Set this to NULL since we'll LocalFree it in CleanExit below
            //
            LocalFree(DependOnGroup);
            DependOnGroup     = NULL;
            DependOnGroupSize = 0;
        }

#if DBG
        SC_LOG1(CONFIG, "    " FORMAT_LPWSTR " DependOnGroup\n", ServiceName);
        ScDisplayWStrArray(DependOnGroup);
#endif

    }

    //
    // Concatenate the DependOnService and DependOnGroup string arrays
    // to make the Dependencies array string.
    //
    if (DependOnService == NULL && DependOnGroup == NULL) {
        *Dependencies = NULL;
    }
    else {

        LPWSTR Entry;
        LPWSTR DestPtr;

        if (DependOnService != NULL) {
            DependOnServiceSize -= sizeof(WCHAR);  // subtract the NULL terminator
        }

        if (DependOnGroup != NULL) {

            Entry = DependOnGroup;

            while (*Entry != 0) {

                //
                // Add extra space for the group name to be prefixed
                // by SC_GROUP_IDENTIFIERW.
                //
                DependOnGroupSize += sizeof(WCHAR);

                Entry = (LPWSTR) ((DWORD_PTR) Entry + WCSSIZE(Entry));
            }
        }

        //
        // Allocate the total amount of memory needed for DependOnService
        // and DependOnGroup strings.
        //
        *Dependencies = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
                                            DependOnServiceSize +
                                                DependOnGroupSize +
                                                sizeof(WCHAR));     // NULL terminator

        if (*Dependencies == NULL) {

            SC_LOG1(ERROR,
                    "ScReadDependencies: LocalAlloc failed " FORMAT_DWORD "\n",
                    GetLastError());

            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }

        if (DependOnService != NULL) {

            RtlCopyMemory(*Dependencies, DependOnService, DependOnServiceSize);
        }

        if (DependOnGroup != NULL) {

            DWORD  EntrySize;

            DestPtr = (LPWSTR) ((DWORD_PTR) *Dependencies + DependOnServiceSize);
            Entry = DependOnGroup;

            while (*Entry != 0) {

                EntrySize = (DWORD) wcslen(Entry) + 1;

                *DestPtr = SC_GROUP_IDENTIFIERW;
                DestPtr++;

                wcscpy(DestPtr, Entry);

                DestPtr += EntrySize;
                Entry   += EntrySize;
            }
        }

#if DBG
        SC_LOG0(CONFIG, "    Dependencies\n");
        ScDisplayWStrArray(*Dependencies);
#endif

    }

CleanExit:

    LocalFree(DependOnService);
    LocalFree(DependOnGroup);
    return(status);
}


DWORD
ScReadConfigFromReg(
    LPSERVICE_RECORD    ServiceRecord,
    LPDWORD             lpdwServiceType,
    LPDWORD             lpdwStartType,
    LPDWORD             lpdwErrorControl,
    LPDWORD             lpdwTagId,
    LPWSTR              *Dependencies,
    LPWSTR              *LoadOrderGroup,
    LPWSTR              *DisplayName
    )

/*++

Routine Description:

    This function obtains some basic information about a service from
    the registry.

    If dependencies or load order group information are not present for
    the service in question, then NULL pointers will be returned for
    these parameters.

Arguments:



Return Value:



--*/
{
    DWORD   ApiStatus = NO_ERROR;
    HKEY    ServiceNameKey;

    ApiStatus = ScOpenServiceConfigKey(
            ServiceRecord->ServiceName,
            KEY_READ,
            FALSE,              // don't create if missing
            & ServiceNameKey );
    if (ApiStatus != NO_ERROR) {
        return(ApiStatus);
    }

    //---------------------
    // Service Type
    //---------------------
    ApiStatus = ScReadServiceType( ServiceNameKey, lpdwServiceType);
    if (ApiStatus != NO_ERROR) {
        ScRegCloseKey(ServiceNameKey);
        return(ApiStatus);
    }

    //---------------------
    // Start Type
    //---------------------
    ApiStatus = ScReadStartType( ServiceNameKey, lpdwStartType);
    if (ApiStatus != NO_ERROR) {
        ScRegCloseKey(ServiceNameKey);
        return(ApiStatus);
    }

    //---------------------
    // ErrorControl
    //---------------------
    ApiStatus = ScReadErrorControl( ServiceNameKey, lpdwErrorControl);
    if (ApiStatus != NO_ERROR) {
        ScRegCloseKey(ServiceNameKey);
        return(ApiStatus);
    }

    //---------------------
    // TagId
    //---------------------
    if (ScReadTag( ServiceNameKey, lpdwTagId) != NO_ERROR) {
        *lpdwTagId = 0;
    }

    //---------------------
    // Dependencies
    //---------------------

    if (Dependencies != NULL) {
        if (ScReadDependencies(
                        ServiceNameKey,
                        Dependencies,
                        ServiceRecord->ServiceName) != NO_ERROR) {

            *Dependencies = NULL;
        }
    }


    //---------------------
    // LoadGroupOrder
    //---------------------
    if (ScAllocateAndReadConfigValue(
            ServiceNameKey,
            GROUP_VALUENAME_W,
            LoadOrderGroup,
            NULL
            ) != NO_ERROR) {

        *LoadOrderGroup = NULL;
    }

    //---------------------
    // DisplayName
    //---------------------

    if (DisplayName != NULL) {

        ApiStatus = ScReadDisplayName(
                        ServiceNameKey,
                        DisplayName);
    }

    ScRegCloseKey(ServiceNameKey);

    return(ApiStatus);
}


DWORD
ScTakeOwnership(
    POBJECT_ATTRIBUTES  pObja
    )

/*++

Routine Description:

    This function attempts to take ownership of the key described by the
    Object Attributes.  If successful, it will modify the security descriptor
    to give LocalSystem full control over the key in question.

Arguments:

    pObja - Pointer to object attributes that describe the key.

Return Value:


--*/
{
    DWORD               status = NO_ERROR;
    NTSTATUS            ntStatus;
    HKEY                hKey;
    DWORD               SdBufSize=0;
    SECURITY_DESCRIPTOR tempSD;
    BOOL                DaclFlag;
    PACL                pDacl;
    BOOL                DaclDefaulted;
    PACL                pNewDacl=NULL;
    PACCESS_ALLOWED_ACE pMyAce=NULL;
    DWORD               bufSize;
    PISECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;

    //
    // An event should be logged whenever we must resort to using this
    // routine.
    //

    ScLogEvent(
        NEVENT_TAKE_OWNERSHIP,
        pObja->ObjectName->Buffer
        );

    //
    // If we were denied access, then assume we have the privilege
    // to get WRITE_OWNER access, so that we can modify the Security
    // Descriptor.
    //
    ntStatus = NtOpenKey(
                (PHANDLE)&hKey,
                (ACCESS_MASK)WRITE_OWNER,
                pObja);

    if (!NT_SUCCESS(ntStatus)) {
        // MAKE THIS A TRACE
        SC_LOG(ERROR, "ScTakeOwnership: NtOpenKey(WRITE_OWNER) failed %x\n",ntStatus);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Set the owner to be local system
    //
    if (!InitializeSecurityDescriptor(&tempSD,SECURITY_DESCRIPTOR_REVISION)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: InitializeSD(1) failed %d\n",status);
        NtClose(hKey);
        return(status);
    }
    if (!SetSecurityDescriptorOwner(&tempSD, LocalSystemSid,0)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: SetSDOwner failed %d\n",status);
        NtClose(hKey);
        return(status);
    }

    status = RegSetKeySecurity(hKey,
                               OWNER_SECURITY_INFORMATION,
                               &tempSD);

    if (status != NO_ERROR) {
        SC_LOG(ERROR, "ScRegOpenKeyExW: RegSetKeySecurity (take ownership)"
        " failed %d\n",status);
    }
    NtClose(hKey);

    //
    // Now open the handle again so that the DACL can be modified to
    // allow LocalSystem Full Access.
    //

    ntStatus = NtOpenKey(
                (PHANDLE)&hKey,
                (ACCESS_MASK)READ_CONTROL | WRITE_DAC,
                pObja);

    if (!NT_SUCCESS(ntStatus)) {
        // MAKE THIS A TRACE
        SC_LOG(ERROR, "ScTakeOwnership: NtOpenKey(WRITE_DAC) failed %x\n",ntStatus);
        return(RtlNtStatusToDosError(ntStatus));
    }
    status = RegGetKeySecurity(hKey,
                               DACL_SECURITY_INFORMATION,
                               pSecurityDescriptor,
                               &SdBufSize);

    if (status != ERROR_INSUFFICIENT_BUFFER) {
        SC_LOG(ERROR, "ScTakeOwnership: RegGetKeySecurity(1) failed %d\n",
        status);
        NtClose(hKey);
        return(status);
    }
    pSecurityDescriptor = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_FIXED,SdBufSize);
    if (pSecurityDescriptor == NULL) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: LocalAlloc failed %d\n",status);
        NtClose(hKey);
        return(status);
    }
    status = RegGetKeySecurity(hKey,
                               DACL_SECURITY_INFORMATION,
                               pSecurityDescriptor,
                               &SdBufSize);

    if (status != NO_ERROR) {
        SC_LOG(ERROR, "ScTakeOwnership: RegGetKeySecurity(2) failed %d\n",
        status);
        goto CleanExit;
    }

    //
    // Modify the DACL to allow LocalSystem to have all access.
    //
    // Get size of DACL

    if (!GetSecurityDescriptorDacl (
            pSecurityDescriptor,
            &DaclFlag,
            &pDacl,
            &DaclDefaulted)) {

        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: GetSecurityDescriptorDacl "
            " failed %d\n",status);
        goto CleanExit;
    }

    //
    // Create new ACE.
    //
    bufSize = sizeof(ACE_HEADER) +
              sizeof(ACCESS_MASK) +
              GetLengthSid(LocalSystemSid);

    pMyAce = (PACCESS_ALLOWED_ACE) LocalAlloc(LMEM_ZEROINIT, bufSize);

    if (pMyAce == NULL) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: LocalAlloc(Ace) failed %d\n",status);
        goto CleanExit;
    }
    pMyAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pMyAce->Header.AceFlags = CONTAINER_INHERIT_ACE;
    pMyAce->Header.AceSize = (WORD)bufSize;
    pMyAce->Mask = GENERIC_ALL;
    if (!CopySid(
            GetLengthSid(LocalSystemSid),
            &(pMyAce->SidStart),
            LocalSystemSid)) {

        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: CopySid failed %d\n",status);
        goto CleanExit;
    }

    //
    // Allocate buffer for DACL and new ACE.
    //
    bufSize += pDacl->AclSize;

    pNewDacl = (PACL) LocalAlloc(LMEM_ZEROINIT, bufSize);
    if (pNewDacl == NULL) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: LocalAlloc (DACL) "
            " failed %d\n",status);
        goto CleanExit;
    }
    if (!InitializeAcl(pNewDacl, bufSize, ACL_REVISION)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: InitializeAcl failed %d\n",status);
        goto CleanExit;
    }

    //
    // Add the ACE to the DACL
    //
    if (!AddAce(
        pNewDacl,                           // pACL
        pDacl->AclRevision,                 // dwACLRevision
        0,                                  // dwStartingAceIndex
        pMyAce,                             // pAceList
        (DWORD)pMyAce->Header.AceSize)) {   // cbAceList

        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: AddAce failed %d\n",status);
        goto CleanExit;
    }

    //
    // Initialize a new SD.
    //
    if (!InitializeSecurityDescriptor(&tempSD,SECURITY_DESCRIPTOR_REVISION)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: InitializeSD failed %d\n",status);
        goto CleanExit;
    }

    //
    // Add the new DACL to the SD
    //
    if (!SetSecurityDescriptorDacl(&tempSD,TRUE,pNewDacl,FALSE)) {
        status = GetLastError();
        SC_LOG(ERROR, "ScTakeOwnership: SetSecurityDescriptorDacl failed %d\n",status);
        goto CleanExit;
    }

    //
    // Set DACL on the key's security descriptor.
    //
    status = RegSetKeySecurity(hKey,
                               DACL_SECURITY_INFORMATION,
                               &tempSD);

    if (status != NO_ERROR) {
        SC_LOG(ERROR, "ScTakeOwnership: RegSetKeySecurity(new DACL) failed %d\n",
        status);
    }

    SC_LOG0(CONFIG, "ScTakeOwnership: Changed SD, now try to open with "
    "Desired Access\n");

CleanExit:

    LocalFree(pNewDacl);
    LocalFree(pMyAce);
    LocalFree (pSecurityDescriptor);

    NtClose(hKey);
    return(status);

} // ScTakeOwnership


DWORD
ScOpenSecurityKey(
    IN HKEY     ServiceNameKey,
    IN DWORD    DesiredAccess,
    IN BOOL     CreateIfMissing,
    OUT PHKEY   pSecurityKey
    )

/*++

Routine Description:

    This function opens, or creates (if it doesn't exist), the Security Key
    that is a sub-key of the service's key.  This key is created such that
    only LocalSystem and Administrators have access.

Arguments:

    ServiceNameKey - This is a key to the service key that will contain
        the security key.

    DesiredAccess - This is the access that is desired with the SecurityKey
        that will be returned on a successful call.

    pSecurityKey - A pointer to a location where the security key is to
        be placed.

Return Value:

    NO_ERROR - if the operation is successful.

    otherwise, a registry error code is returned.


--*/
{
    LONG    RegError;

    LPWSTR  SecurityKeyName = SD_VALUENAME_W;



    DWORD                   Disposition;
    NTSTATUS                ntstatus;
    SECURITY_ATTRIBUTES     SecurityAttr;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;

#define SEC_KEY_ACE_COUNT 2
    SC_ACE_DATA AceData[SEC_KEY_ACE_COUNT] = {
        {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
               GENERIC_ALL,                &LocalSystemSid},
        {ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, 0,
               GENERIC_ALL,                &AliasAdminsSid}
        };


    if (!CreateIfMissing) {
        //
        // Open the existing security key.
        //
        RegError = ScRegOpenKeyExW(
                    ServiceNameKey,
                    SecurityKeyName,
                    REG_OPTION_NON_VOLATILE,
                    DesiredAccess,
                    pSecurityKey);
        if (RegError != ERROR_SUCCESS) {
            SC_LOG2(TRACE, "ScOpenSecurityKey: "
                    "ScRegOpenKeyExW of " FORMAT_LPWSTR " failed "
                    FORMAT_LONG "\n", SecurityKeyName, RegError);

        }
        return((DWORD)RegError);
    }

    //
    // Create a security descriptor for the registry key we are about
    // to create.  This gives everyone read access, and all access to
    // ourselves and the admins.
    //
    ntstatus = ScCreateAndSetSD(
                   AceData,
                   SEC_KEY_ACE_COUNT,
                   LocalSystemSid,
                   LocalSystemSid,
                   &SecurityDescriptor
                   );

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR, "ScCreateAndSetSD failed " FORMAT_NTSTATUS
                "\n", ntstatus);
        return(RtlNtStatusToDosError(ntstatus));
    }

    //
    // Protect the DACL on the SD so it can't be overridden by DACL inheritance
    // from parent keys.  Since this key can contain a SACL, we want to make
    // sure access to it is always what we expect.
    //

    ntstatus = RtlSetControlSecurityDescriptor(SecurityDescriptor,
                                               SE_DACL_PROTECTED,
                                               SE_DACL_PROTECTED);

    if (!NT_SUCCESS(ntstatus))
    {
        SC_LOG1(ERROR,
                "ScOpenSecurityKey:  RtlSetControlSecurityDescriptor failed %x\n",
                ntstatus);

        RtlDeleteSecurityObject(&SecurityDescriptor);
        return RtlNtStatusToDosError(ntstatus);
    }

    SecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttr.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttr.bInheritHandle = FALSE;

    //
    // Create a new service key (or open existing one).
    //
    RegError = ScRegCreateKeyExW(
           ServiceNameKey,
           SecurityKeyName,
           0,
           0,
           REG_OPTION_NON_VOLATILE, // options
           DesiredAccess,           // desired access
           &SecurityAttr,
           pSecurityKey,
           &Disposition);


    RtlDeleteSecurityObject(&SecurityDescriptor);

    if (RegError != ERROR_SUCCESS) {
        SC_LOG2(ERROR, "ScOpenSecurityKey: "
                "ScRegCreateKeyExW of " FORMAT_LPWSTR " failed "
                FORMAT_LONG "\n", SecurityKeyName, RegError);
        return ((DWORD) RegError);
    }

    return NO_ERROR;

} // ScOpenSecurityKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\sclastgood.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ScLastGood.h

Abstract:

    This header exposes routines neccessary for cleaning up last known good
    information.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#define DIRWALK_INCLUDE_FILES           0x00000001
#define DIRWALK_INCLUDE_DIRECTORIES     0x00000002
#define DIRWALK_CULL_DOTPATHS           0x00000004
#define DIRWALK_TRAVERSE                0x00000008
#define DIRWALK_TRAVERSE_MOUNTPOINTS    0x00000010

typedef NTSTATUS (*DIRWALK_CALLBACK)(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    );

DWORD
ScLastGoodWalkDirectoryTreeTopDown(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    );

DWORD
ScLastGoodWalkDirectoryTreeBottomUp(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    );

NTSTATUS
ScLastGoodClearAttributes(
    IN PUNICODE_STRING  FullPathName,
    IN ULONG            FileAttributes
    );

DWORD
ScLastGoodFileCleanup(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scopen.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ScOpen.h

Abstract:

    Contains data structures used for Service Controller Handles.
    Also some closely-related prototypes.

Author:

    Dan Lafferty (danl)     20-Jan-1992

Environment:

    User Mode -Win32

Revision History:

    20-Jan-1992     danl
        created
    11-Mar-1992     ritaw
        changed context handle structure
    10-Apr-1992 JohnRo
        Added ScIsValidServiceHandle() and ScCreateServiceHandle().
    15-Apr-1992 JohnRo
        Added ScIsValidScManagerHandle().

--*/


#ifndef SCOPEN_H
#define SCOPEN_H


#include <svcctl.h>     // MIDL generated header file. (SC_RPC_HANDLE)


//
// Signature value in handle
//
#define SC_SIGNATURE               0x6E4F6373  // "scOn" in ASCII.
#define SERVICE_SIGNATURE          0x76724573  // "sErv" in ASCII.

//
// The following are definitions for the Flags field in the handle.
//
// SC_HANDLE_GENERATE_ON_CLOSE indicates that NtCloseAuditAlarm must
//                        be called when this handle is closed.  This flag
//                        is set when an audit is generated on open.
//

#define     SC_HANDLE_GENERATE_ON_CLOSE         0x0001

//
// Data associated with each opened context handle
//
typedef struct  _SC_HANDLE_STRUCT{

    DWORD Signature;     // For block identification to detect some app errors
    DWORD Flags;         // See definitions above
    DWORD AccessGranted; // Access granted to client.
    union {              // Object specific data

        struct {
            LPWSTR DatabaseName;            // Name of database opened
        } ScManagerObject;

        struct {
            LPSERVICE_RECORD ServiceRecord; // Pointer to service record
        } ScServiceObject;

    } Type;

} SC_HANDLE_STRUCT, *LPSC_HANDLE_STRUCT;


//
// FUNCTION PROTOTYPES
//

DWORD
ScCreateServiceHandle(
    IN  LPSERVICE_RECORD ServiceRecord,
    OUT LPSC_HANDLE_STRUCT *ContextHandle
    );

BOOL
ScIsValidScManagerHandle(
    IN  SC_RPC_HANDLE   hScManager
    );

BOOL
ScIsValidServiceHandle(
    IN  SC_RPC_HANDLE   hService
    );


typedef enum
{
    SC_HANDLE_TYPE_MANAGER = 0,
    SC_HANDLE_TYPE_SERVICE
}
SC_HANDLE_TYPE, *PSC_HANDLE_TYPE;

BOOL
ScIsValidScManagerOrServiceHandle(
    IN  SC_RPC_HANDLE    ContextHandle,
    OUT PSC_HANDLE_TYPE  phType
    );

#endif // SCOPEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scplastgood.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ScpLastGood.h

Abstract:

    This header contains private information to implement last known good boot
    cleanup. This file is mean to be included only by ScLastGood.cxx

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

typedef struct {

    LIST_ENTRY      Link;
    UNICODE_STRING  Directory;
    WCHAR           Name[1];

} DIRWALK_ENTRY, *PDIRWALK_ENTRY;

NTSTATUS
ScpLastGoodWalkDirectoryTreeHelper(
    IN      PUNICODE_STRING  Directory,
    IN      ULONG            Flags,
    IN      DIRWALK_CALLBACK CallbackFunction   OPTIONAL,
    IN      PVOID            Context            OPTIONAL,
    IN      PUCHAR           Buffer,
    IN      ULONG            BufferSize,
    IN OUT  PLIST_ENTRY      DirList
    );

NTSTATUS
ScpLastGoodDeleteFiles(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scconfig.h ===
/*++

Copyright (c) 1991, 1992 Microsoft Corporation

Module Name:

    scconfig.h

Abstract:

    Service configuration related function prototypes.

Author:

    Dan Lafferty (danl)     03-Apr-1991

Revision History:

    22-Apr-1992 JohnRo
        Added ScAllocateAndReadConfigValue(), ScOpenServiceConfigKey(),
        and ScWriteServiceType().  Added CreateIfMissing flag to
        ScOpenServiceConfigKey().  Added ScWriteImageFileName(),
        ScWriteDependencies(), ScWriteGroupForThisService().

    24-Apr-1992 RitaW
        ScAllocateAndReadConfigValue() returns DWORD.

--*/

#ifndef SCCONFIG_INCLUDED
#define SCCONFIG_INCLUDED


#include <winreg.h>     // HKEY, PHKEY.
#include <scwow.h>      // 32/64-bit interop structures

//
// Macros
//

#define ScRegCloseKey(handle)   RtlNtStatusToDosError(NtClose((HANDLE)handle))
#define ScRegFlushKey(handle)   RtlNtStatusToDosError(NtFlushKey((HANDLE)handle))


//
// Value names in registry
//
#define START_VALUENAME_W           L"Start"
#define GROUP_VALUENAME_W           L"Group"
#define TAG_VALUENAME_W             L"Tag"
#define DEPENDONSERVICE_VALUENAME_W L"DependOnService"
#define DEPENDONGROUP_VALUENAME_W   L"DependOnGroup"
#define ERRORCONTROL_VALUENAME_W    L"ErrorControl"
#define IMAGE_VALUENAME_W           L"ImagePath"
#define SERVICETYPE_VALUENAME_W     L"Type"
#define STARTNAME_VALUENAME_W       L"ObjectName"
#define DISPLAYNAME_VALUENAME_W     L"DisplayName"
#define DESCRIPTION_VALUENAME_W     L"Description"
#define REBOOTMESSAGE_VALUENAME_W   L"RebootMessage"
#define FAILURECOMMAND_VALUENAME_W  L"FailureCommand"
#define FAILUREACTIONS_VALUENAME_W  L"FailureActions"
#define SD_VALUENAME_W              L"Security"
#define LOAD_ORDER_GROUP_LIST_KEY   L"System\\CurrentControlSet\\Control\\ServiceGroupOrder"
#define GROUP_VECTORS_KEY           L"System\\CurrentControlSet\\Control\\GroupOrderList"
#define GROUPLIST_VALUENAME_W       L"List"
#define CONTROL_WINDOWS_KEY_W       L"System\\CurrentControlSet\\Control\\Windows"
#define NOINTERACTIVE_VALUENAME_W   L"NoInteractiveServices"
#define NOBOOTPOPUPS_VALUENAME_W    L"NoPopupsOnBoot"
#define ENVIRONMENT_VALUENAME_W     L"Environment"
#define PROVIDER_KEY_BASE           L"System\\CurrentControlSet\\Control\\NetworkProvider"
#define PROVIDER_KEY_ORDER          L"Order"
#define PROVIDER_KEY_HW             L"HwOrder"
#define PROVIDER_VALUE              L"ProviderOrder"

//
// Function Prototypes
//

DWORD
ScMergeEnvironments (
    IN  LPWSTR  ServiceName,
    OUT LPVOID  *Environment
    );

DWORD
ScGetImageFileName (
    LPWSTR   ServiceName,
    LPWSTR   *ImageNamePtr
    );

BOOL
ScGenerateServiceDB(
    VOID
    );

#ifndef _CAIRO_
BOOL
ScInitSecurityProcess(
    LPSERVICE_RECORD    ServiceRecord
    );
#endif // _CAIRO_

DWORD
ScAllocateAndReadConfigValue(
    IN HKEY Key,
    IN LPCWSTR ValueName,
    OUT LPWSTR *Value,
    OUT LPDWORD BytesReturned OPTIONAL
    );

DWORD
ScReadOptionalString(
    IN  HKEY    ServiceNameKey,
    IN  LPCWSTR ValueName,
    OUT LPWSTR  *Value,
    IN OUT LPDWORD TotalBytes = NULL
    );

BOOL
ScCreateLoadOrderGroupList(
    VOID
    );

DWORD
ScGetGroupVector(
    IN  LPWSTR Group,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    );

BOOL
ScGetToken(
    IN OUT LPWSTR *CurrentPtr,
    OUT    LPWSTR *TokenPtr
    );

DWORD
ScOpenServiceConfigKey(
    IN LPWSTR ServiceName,
    IN DWORD DesiredAccess,
    IN BOOL CreateIfMissing,
    OUT PHKEY ServiceKey
    );

DWORD
ScReadServiceType(
    IN HKEY ServiceNameKey,
    OUT LPDWORD ServiceTypePtr
    );

DWORD
ScReadStartType(
    IN HKEY ServiceNameKey,
    OUT LPDWORD StartTypePtr
    );

DWORD
ScReadTag(
    IN HKEY ServiceNameKey,
    OUT LPDWORD TagPtr
    );

DWORD
ScReadFailureActions(
    IN HKEY ServiceNameKey,
    OUT LPSERVICE_FAILURE_ACTIONS_WOW64 * FailActPtr,
    IN OUT LPDWORD TotalBytes = NULL
    );

DWORD
ScReadErrorControl(
    IN HKEY ServiceNameKey,
    OUT LPDWORD ErrorControlPtr
    );

DWORD
ScReadStartName(
    IN HKEY ServiceNameKey,
    OUT LPWSTR *AccountName
    );

DWORD
ScWriteOptionalString(
    IN HKEY ServiceNameKey,
    IN LPCWSTR ValueName,
    IN LPCWSTR Value
    );

DWORD
ScWriteDependencies(
    IN HKEY ServiceNameKey,
    IN LPWSTR Dependencies,
    IN DWORD DependSize
    );

DWORD
ScWriteDisplayName(
    IN HKEY ServiceNameKey,
    IN LPWSTR DisplayName
    );

DWORD
ScWriteErrorControl(
    IN HKEY hServiceKey,
    IN DWORD dwErrorControl
    );

DWORD
ScWriteSd(
    IN HKEY ServiceNameKey,
    IN PSECURITY_DESCRIPTOR Security
    );

DWORD
ScWriteGroupForThisService(
    IN HKEY ServiceNameKey,
    IN LPWSTR Group
    );

DWORD
ScWriteImageFileName(
    IN HKEY hServiceKey,
    IN LPWSTR ImageFileName
    );

DWORD
ScWriteServiceType(
    IN HKEY hServiceKey,
    IN DWORD dwServiceType
    );

DWORD
ScWriteStartType(
    IN HKEY hServiceKey,
    IN DWORD lpStartType
    );

DWORD
ScWriteTag(
    IN HKEY hServiceKey,
    IN DWORD dwTag
    );

DWORD
ScWriteFailureActions(
    IN HKEY ServiceNameKey,
    IN LPSERVICE_FAILURE_ACTIONSW psfa
    );

DWORD
ScWriteCurrentServiceValue(
    OUT LPDWORD lpdwID
    );

VOID
ScDeleteTag(
    IN HKEY hServiceKey
    );

DWORD
ScWriteStartName(
    IN HKEY ServiceNameKey,
    IN LPWSTR StartName
    );

DWORD
ScOpenServicesKey(
    OUT PHKEY ServicesKey
    );

DWORD
ScRegCreateKeyExW(
    IN  HKEY                    hKey,
    IN  LPWSTR                  lpSubKey,
    IN  DWORD                   dwReserved,
    IN  LPWSTR                  lpClass,
    IN  DWORD                   dwOptions,
    IN  REGSAM                  samDesired,
    IN  LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    OUT PHKEY                   phkResult,
    OUT LPDWORD                 lpdwDisposition
    );

DWORD
ScRegOpenKeyExW(
    IN  HKEY    hKey,
    IN  LPWSTR  lpSubKey,
    IN  DWORD   dwOptions,
    IN  REGSAM  samDesired,
    OUT PHKEY   phkResult
    );

DWORD
ScRegQueryValueExW(
    IN      HKEY    hKey,
    IN      LPCWSTR lpValueName,
    OUT     LPDWORD lpReserved,
    OUT     LPDWORD lpType,
    OUT     LPBYTE  lpData,
    IN OUT  LPDWORD lpcbData
    );

DWORD
ScRegSetValueExW(
    IN  HKEY    hKey,
    IN  LPCWSTR lpValueName,
    IN  DWORD   lpReserved,
    IN  DWORD   dwType,
    IN  LPVOID  lpData,
    IN  DWORD   cbData
    );

DWORD
ScRegDeleteValue(
    IN  HKEY    hKey,
    IN  LPCWSTR lpValueName
    );

DWORD
ScRegEnumKeyW(
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpName,
    DWORD   cbName
    );

DWORD
ScRegDeleteKeyW (
    HKEY    hKey,
    LPWSTR  lpSubKey
    );

DWORD
ScRegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

DWORD
ScRegEnumValueW (
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    );

VOID
ScHandleProviderChange(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    );

VOID
ScMarkForDelete(
    LPSERVICE_RECORD  ServiceRecord
    );

DWORD
ScReadDependencies(
    HKEY    ServiceNameKey,
    LPWSTR  *Dependencies,
    LPWSTR  ServiceName
    );

DWORD
ScReadConfigFromReg(
    LPSERVICE_RECORD    ServiceRecord,
    LPDWORD             lpdwServiceType,
    LPDWORD             lpdwStartType,
    LPDWORD             lpdwErrorControl,
    LPDWORD             lpdwTagId,
    LPWSTR              *Dependencies,
    LPWSTR              *LoadOrderGroup,
    LPWSTR              *DisplayName
    );

inline DWORD
ScReadDisplayName(
    IN  HKEY    ServiceNameKey,
    OUT LPWSTR  *DisplayName
    )
{
    return (ScReadOptionalString(
                ServiceNameKey,
                DISPLAYNAME_VALUENAME_W,
                DisplayName
                ));
}

inline DWORD
ScWriteDisplayName(
    IN HKEY ServiceNameKey,
    IN LPWSTR DisplayName
    )
{
    return (ScWriteOptionalString(
                    ServiceNameKey,
                    DISPLAYNAME_VALUENAME_W,
                    DisplayName
                    ));
}

DWORD
ScReadNoInteractiveFlag(
    IN HKEY ServiceNameKey,
    OUT LPDWORD NoInteractivePtr
    );

inline DWORD
ScReadDescription(
    IN  HKEY    ServiceNameKey,
    OUT LPWSTR  *Description,
    IN OUT LPDWORD TotalBytes = NULL
    )
{
    return (ScReadOptionalString(
                ServiceNameKey,
                DESCRIPTION_VALUENAME_W,
                Description,
                TotalBytes
                ));
}

inline DWORD
ScWriteDescription(
    IN HKEY ServiceNameKey,
    IN LPWSTR Description
    )
{
    return (ScWriteOptionalString(
                    ServiceNameKey,
                    DESCRIPTION_VALUENAME_W,
                    Description
                    ));
}

inline DWORD
ScReadRebootMessage(
    IN  HKEY    ServiceNameKey,
    OUT LPWSTR  *RebootMessage,
    IN OUT LPDWORD TotalBytes = NULL
    )
{
    return (ScReadOptionalString(
                ServiceNameKey,
                REBOOTMESSAGE_VALUENAME_W,
                RebootMessage,
                TotalBytes
                ));
}

inline DWORD
ScReadFailureCommand(
    IN  HKEY    ServiceNameKey,
    OUT LPWSTR  *FailureCommand,
    IN OUT LPDWORD TotalBytes = NULL
    )
{
    return (ScReadOptionalString(
                ServiceNameKey,
                FAILURECOMMAND_VALUENAME_W,
                FailureCommand,
                TotalBytes
                ));
}


#endif // #ifndef SCCONFIG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scsec.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    scsec.cxx

Abstract:

    This module contains security related routines:
        RQueryServiceObjectSecurity
        RSetServiceObjectSecurity
        ScCreateScManagerObject
        ScCreateScServiceObject
        ScGrantAccess
        ScPrivilegeCheckAndAudit
        ScAccessValidate
        ScAccessCheckAndAudit
        ScGetPrivilege
        ScReleasePrivilege

Author:

    Rita Wong (ritaw)     10-Mar-1992

Environment:

    Calls NT native APIs.

Revision History:

    10-Mar-1992     ritaw
        created
    16-Apr-1992     JohnRo
        Process services which are marked for delete accordingly.
    06-Aug-1992     Danl
        Fixed a debug print statement.  It indicated it was from the
        ScLoadDeviceDriver function - rather than in ScGetPrivilege.
    21-Jan-1995     AnirudhS
        Added ScGrantAccess and ScPrivilegeCheckAndAudit.
--*/

#include "precomp.hxx"
#include "scconfig.h"   // ScOpenServiceConfigKey
#include "scsec.h"      // Object names and security functions
#include "control.h"    // SERVICE_SET_STATUS
#include "account.h"    // ScLookupServiceAccount
#include "align.h"      // ROUND_UP_COUNT


#define PRIVILEGE_BUF_SIZE  512


//-------------------------------------------------------------------//
//                                                                   //
// Static global variables                                           //
//                                                                   //
//-------------------------------------------------------------------//

//
// Security descriptor of the SCManager objects to control user accesses
// to the Service Control Manager and its database.
//
PSECURITY_DESCRIPTOR ScManagerSd;

//
// Structure that describes the mapping of Generic access rights to
// object specific access rights for the ScManager object.
//
GENERIC_MAPPING ScManagerObjectMapping = {

    STANDARD_RIGHTS_READ             |     // Generic read
        SC_MANAGER_ENUMERATE_SERVICE |
        SC_MANAGER_QUERY_LOCK_STATUS,

    STANDARD_RIGHTS_WRITE         |        // Generic write
        SC_MANAGER_CREATE_SERVICE |
        SC_MANAGER_MODIFY_BOOT_CONFIG,

    STANDARD_RIGHTS_EXECUTE |              // Generic execute
        SC_MANAGER_CONNECT  |
        SC_MANAGER_LOCK,

    SC_MANAGER_ALL_ACCESS                  // Generic all
    };

//
// Structure that describes the mapping of generic access rights to
// object specific access rights for the Service object.
//
GENERIC_MAPPING ScServiceObjectMapping = {

    STANDARD_RIGHTS_READ             |     // Generic read
        SERVICE_QUERY_CONFIG         |
        SERVICE_QUERY_STATUS         |
        SERVICE_ENUMERATE_DEPENDENTS |
        SERVICE_INTERROGATE,

    STANDARD_RIGHTS_WRITE     |            // Generic write
        SERVICE_CHANGE_CONFIG,

    STANDARD_RIGHTS_EXECUTE    |           // Generic execute
        SERVICE_START          |
        SERVICE_STOP           |
        SERVICE_PAUSE_CONTINUE |
        SERVICE_USER_DEFINED_CONTROL,

    SERVICE_ALL_ACCESS                     // Generic all
    };


//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
RQueryServiceObjectSecurity(
    IN  SC_RPC_HANDLE hService,
    IN  SECURITY_INFORMATION dwSecurityInformation,
    OUT LPBYTE lpSecurityDescriptor,
    IN  DWORD cbBufSize,
    OUT LPDWORD pcbBytesNeeded
    )
/*++

Routine Description:

    This is the worker function for QueryServiceObjectSecurity API.
    It returns the security descriptor information of a service
    object.

Arguments:

    hService - Supplies the context handle to an existing service object.

    dwSecurityInformation - Supplies the bitwise flags describing the
        security information being queried.

    lpSecurityInformation - Supplies the output buffer from the user
        which security descriptor information will be written to on
        return.

    cbBufSize - Supplies the size of lpSecurityInformation buffer.

    pcbBytesNeeded - Returns the number of bytes needed of the
        lpSecurityInformation buffer to get all the requested
        information.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened for
        either READ_CONTROL or ACCESS_SYSTEM_SECURITY
        access.

    ERROR_INVALID_PARAMETER - The dwSecurityInformation parameter is
        invalid.

    ERROR_INSUFFICIENT_BUFFER - The specified output buffer is smaller
        than the required size returned in pcbBytesNeeded.  None of
        the security descriptor is returned.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpSecurityDescriptor, and pcbBytesNeeded.

--*/
{
    NTSTATUS ntstatus;
    ACCESS_MASK DesiredAccess = 0;
    PSECURITY_DESCRIPTOR ServiceSd;
    DWORD ServiceSdSize = 0;


    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Check the validity of dwSecurityInformation
    //
    if ((dwSecurityInformation == 0) ||
        ((dwSecurityInformation &
          (OWNER_SECURITY_INFORMATION |
           GROUP_SECURITY_INFORMATION |
           DACL_SECURITY_INFORMATION  |
           SACL_SECURITY_INFORMATION)) != dwSecurityInformation))
    {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set the desired access based on the requested SecurityInformation
    //
    if (dwSecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    if (dwSecurityInformation & (DACL_SECURITY_INFORMATION  |
                                 OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION)) {
        DesiredAccess |= READ_CONTROL;
    }

    //
    // Was the handle opened for the requested access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              DesiredAccess
              )) {
        return ERROR_ACCESS_DENIED;
    }

    //
    //
    RtlZeroMemory(lpSecurityDescriptor, cbBufSize);

    //
    // Get the database lock for reading
    //
    CServiceRecordSharedLock RLock;

    //
    // The most up-to-date service security descriptor is always kept in
    // the service record.
    //
    ServiceSd =
        ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord->ServiceSd;


    //
    // Retrieve the appropriate security information from ServiceSd
    // and place it in the user supplied buffer.
    //
    ntstatus = RtlQuerySecurityObject(
                   ServiceSd,
                   dwSecurityInformation,
                   (PSECURITY_DESCRIPTOR) lpSecurityDescriptor,
                   cbBufSize,
                   &ServiceSdSize
                   );

    if (! NT_SUCCESS(ntstatus)) {

        if (ntstatus == STATUS_BAD_DESCRIPTOR_FORMAT) {

            //
            // Internal error: our security descriptor is bad!
            //
            SC_LOG0(ERROR,
                "RQueryServiceObjectSecurity: Our security descriptor is bad!\n");
            ASSERT(FALSE);
            return ERROR_GEN_FAILURE;

        }
        else if (ntstatus == STATUS_BUFFER_TOO_SMALL) {

            //
            // Return the required size to the user
            //
            *pcbBytesNeeded = ServiceSdSize;
            return ERROR_INSUFFICIENT_BUFFER;

        }
        else {
            return RtlNtStatusToDosError(ntstatus);
        }
    }

    //
    // Return the required size to the user
    //
    *pcbBytesNeeded = ServiceSdSize;

    return NO_ERROR;
}


DWORD
RSetServiceObjectSecurity(
    IN  SC_RPC_HANDLE hService,
    IN  SECURITY_INFORMATION dwSecurityInformation,
    IN  LPBYTE lpSecurityDescriptor,
    IN  DWORD cbBufSize
    )
/*++

Routine Description:

    This is the worker function for SetServiceObjectSecurity API.
    It modifies the security descriptor information of a service
    object.

Arguments:

    hService - Supplies the context handle to the service.

    dwSecurityInformation - Supplies the bitwise flags of security
        information being queried.

    lpSecurityInformation - Supplies a buffer which contains a
        well-formed self-relative security descriptor.

    cbBufSize - Supplies the size of lpSecurityInformation buffer.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_ACCESS_DENIED - The specified handle was not opened for
        either WRITE_OWNER, WRITE_DAC, or ACCESS_SYSTEM_SECURITY
        access.

    ERROR_INVALID_PARAMETER - The lpSecurityDescriptor or dwSecurityInformation
        parameter is invalid.

Note:

    It is expected that the RPC Stub functions will find the following
    parameter problems:

        Bad pointers for lpSecurityDescriptor.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    RPC_STATUS rpcstatus;
    ACCESS_MASK DesiredAccess = 0;
    LPSERVICE_RECORD serviceRecord;
    HANDLE ClientTokenHandle = NULL;
    LPBYTE lpTempSD = lpSecurityDescriptor;


    UNREFERENCED_PARAMETER(cbBufSize);  // for RPC marshalling code

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Silently ignore flags we don't understand that may come
    // from higher-level object managers.
    //
    dwSecurityInformation &= (OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION  |
                                SACL_SECURITY_INFORMATION);

    if (dwSecurityInformation == 0)
    {
        return NO_ERROR;
    }


#ifdef _WIN64

    if (PtrToUlong(lpSecurityDescriptor) & (sizeof(PVOID) - 1))
    {
        //
        // SD isn't properly aligned.  Alloc an aligned heap buffer
        // and copy it in to fix things up.
        //

        lpTempSD = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBufSize);

        if (lpTempSD == NULL)
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanExit;
        }

        RtlCopyMemory(lpTempSD, lpSecurityDescriptor, cbBufSize);
    }

#endif // _WIN64
    

    //
    // Check the validity of lpSecurityInformation
    //
    if (! RtlValidRelativeSecurityDescriptor(
              (PSECURITY_DESCRIPTOR) lpTempSD,
              cbBufSize,
              dwSecurityInformation
              ))
    {
        status = ERROR_INVALID_PARAMETER;
        goto CleanExit;
    }

    //
    // Set the desired access based on the specified SecurityInformation
    //
    if (dwSecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    if (dwSecurityInformation & (OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION)) {
        DesiredAccess |= WRITE_OWNER;
    }

    if (dwSecurityInformation & DACL_SECURITY_INFORMATION) {
        DesiredAccess |= WRITE_DAC;
    }

    //
    // Make sure the specified fields are present in the provided
    // security descriptor.
    // Security descriptors must have owner and group fields.
    //
    if (dwSecurityInformation & OWNER_SECURITY_INFORMATION)
    {
        if (((PISECURITY_DESCRIPTOR_RELATIVE) lpTempSD)->Owner == 0)
        {
            status = ERROR_INVALID_PARAMETER;
            goto CleanExit;
        }
    }

    if (dwSecurityInformation & GROUP_SECURITY_INFORMATION)
    {
        if (((PISECURITY_DESCRIPTOR_RELATIVE) lpTempSD)->Group == 0)
        {
            status = ERROR_INVALID_PARAMETER;
            goto CleanExit;
        }
    }

    //
    // Was the handle opened for the requested access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              DesiredAccess
              ))
    {
        status = ERROR_ACCESS_DENIED;
        goto CleanExit;
    }

    //
    // Is this service marked for delete?
    //
    serviceRecord =
        ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    SC_ASSERT( serviceRecord != NULL );

    if (DELETE_FLAG_IS_SET(serviceRecord))
    {
        status = ERROR_SERVICE_MARKED_FOR_DELETE;
        goto CleanExit;
    }

    //
    // If caller wants to replace the owner, get a handle to the impersonation
    // token.
    //
    if (dwSecurityInformation & OWNER_SECURITY_INFORMATION)
    {
        if ((rpcstatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
        {
            SC_LOG1(
                ERROR,
                "RSetServiceObjectSecurity: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
                rpcstatus
                );

            ScLogEvent(
                NEVENT_CALL_TO_FUNCTION_FAILED,
                SC_RPC_IMPERSONATE,
                rpcstatus
                );

            status = rpcstatus;
            goto CleanExit;
        }

        ntstatus = NtOpenThreadToken(
                       NtCurrentThread(),
                       TOKEN_QUERY,
                       TRUE,              // OpenAsSelf
                       &ClientTokenHandle
                       );

        //
        // Stop impersonating the client
        //
        if ((rpcstatus = RpcRevertToSelf()) != RPC_S_OK) {
            SC_LOG1(
               ERROR,
               "RSetServiceObjectSecurity: Failed to revert to self " FORMAT_RPC_STATUS "\n",
               rpcstatus
               );

            ScLogEvent(
                NEVENT_CALL_TO_FUNCTION_FAILED,
                SC_RPC_REVERT,
                rpcstatus
                );

            ASSERT(FALSE);
            status = rpcstatus;
            goto CleanExit;
        }

        if (! NT_SUCCESS(ntstatus))
        {
            SC_LOG(ERROR,
                   "RSetServiceObjectSecurity: NtOpenThreadToken failed %08lx\n",
                   ntstatus);

            status = RtlNtStatusToDosError(ntstatus);
            goto CleanExit;
        }
    }

    {
        CServiceRecordExclusiveLock RLock;

        //
        // Replace the service security descriptor with the appropriate
        // security information specified in the caller supplied security
        // descriptor.  This routine may reallocate the memory needed to
        // contain the new service security descriptor.
        //
        ntstatus = RtlSetSecurityObject(
                       dwSecurityInformation,
                       (PSECURITY_DESCRIPTOR) lpTempSD,
                       &serviceRecord->ServiceSd,
                       &ScServiceObjectMapping,
                       ClientTokenHandle
                       );

        status = RtlNtStatusToDosError(ntstatus);

        if (! NT_SUCCESS(ntstatus))
        {
            SC_LOG1(ERROR,
                    "RSetServiceObjectSecurity: RtlSetSecurityObject failed %08lx\n",
                    ntstatus);
        }
        else
        {
            HKEY ServiceKey;

            //
            // Write new security descriptor to the registry
            //
            status = ScOpenServiceConfigKey(
                         serviceRecord->ServiceName,
                         KEY_WRITE,
                         FALSE,
                         &ServiceKey
                         );

            if (status == NO_ERROR)
            {
                status = ScWriteSd(
                             ServiceKey,
                             serviceRecord->ServiceSd
                             );

                if (status != NO_ERROR)
                {
                    SC_LOG1(ERROR,
                            "RSetServiceObjectSecurity: ScWriteSd failed %lu\n",
                            status);
                }

                ScRegFlushKey(ServiceKey);
                ScRegCloseKey(ServiceKey);
            }
        }
    }

CleanExit:

#ifdef _WIN64

    if (lpTempSD != lpSecurityDescriptor)
    {
        LocalFree(lpTempSD);
    }

#endif // _WIN64

    if (ClientTokenHandle != NULL)
    {
        NtClose(ClientTokenHandle);
    }

    return status;
}


DWORD
ScCreateScManagerObject(
    VOID
    )
/*++

Routine Description:

    This function creates the security descriptor which represents
    the ScManager object for both the "ServiceActive" and
    "ServicesFailed" databases.

Arguments:

    None.

Return Value:

    Returns values from calls to:
        ScCreateUserSecurityObject

--*/
{
    NTSTATUS ntstatus;
    ULONG Privilege = SE_SECURITY_PRIVILEGE;

    //
    // World has SC_MANAGER_CONNECT access and GENERIC_READ access.
    // Local admins are allowed GENERIC_ALL access.
    //
#define SC_MANAGER_OBJECT_ACES  5             // Number of ACEs in this DACL

    SC_ACE_DATA AceData[SC_MANAGER_OBJECT_ACES] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SC_MANAGER_CONNECT |
               GENERIC_READ,                  &AuthenticatedUserSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               SC_MANAGER_CONNECT |
               GENERIC_READ |
               SC_MANAGER_MODIFY_BOOT_CONFIG, &LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,                   &AliasAdminsSid},

        {SYSTEM_AUDIT_ACE_TYPE, 0, FAILED_ACCESS_ACE_FLAG,
               GENERIC_ALL,                  &WorldSid},

        {SYSTEM_AUDIT_ACE_TYPE, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,
               FAILED_ACCESS_ACE_FLAG,
               GENERIC_ALL,                  &WorldSid}
        };


    //
    // You need to have SE_SECURITY_PRIVILEGE privilege to create the SD with a
    // SACL
    //

    ntstatus = ScGetPrivilege(1, &Privilege);

    if (ntstatus != NO_ERROR)
    {
        SC_LOG1(ERROR, "ScCreateScManagerObject: ScGetPrivilege Failed %d\n", ntstatus);
        return(ntstatus);
    }

    ntstatus = ScCreateUserSecurityObject(
                   NULL,                        // Parent SD
                   AceData,
                   SC_MANAGER_OBJECT_ACES,
                   LocalSystemSid,
                   LocalSystemSid,
                   TRUE,                        // IsDirectoryObject
                   TRUE,                        // UseImpersonationToken
                   &ScManagerObjectMapping,
                   &ScManagerSd
                   );

#undef SC_MANAGER_OBJECT_ACES

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG(
            ERROR,
            "ScCreateScManagerObject: ScCreateUserSecurityObject failed " FORMAT_NTSTATUS "\n",
            ntstatus
            );
    }

    ScReleasePrivilege();

    return RtlNtStatusToDosError(ntstatus);
}


DWORD
ScGetSaclParameters(
    OUT PACCESS_MASK AuditAccessMask,
    OUT PUCHAR       AuditAceFlags
    )
/*++

Routine Description:

    Read registry to determine the access-mask and audit ACE flags
    to use when adding a SACL on a service object.

Arguments:

    AuditAccessMask - pointer to 

    AuditAceFlags - pointer to 

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    DWORD dwError = NO_ERROR;
    DWORD dwValueType;
    ACCESS_MASK AccessMask = 0;
    DWORD AceFlags = 0;
    DWORD dwSize;
    HKEY hkeyAuditParams = 0;
    
    ASSERT( sizeof(ACCESS_MASK) == sizeof(DWORD) );
    
    dwSize = sizeof(DWORD);

    //
    // open the base auditing key
    //

    dwError = ScRegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  L"SYSTEM\\CurrentControlSet\\Control\\LSA\\audit\\Services",
                  REG_OPTION_NON_VOLATILE,
                  KEY_READ,
                  &hkeyAuditParams
                  );
    
    if ( dwError != NO_ERROR ) {

        if ((dwError == ERROR_FILE_NOT_FOUND) ||
            (dwError == ERROR_PATH_NOT_FOUND))
        {
            dwError = NO_ERROR;
        }

        goto Cleanup;
    }

    //
    // get the access-mask
    //

    dwError = ScRegQueryValueExW(
                  hkeyAuditParams,
                  L"DefaultAuditMask",
                  NULL,
                  &dwValueType,
                  (LPBYTE) &AccessMask,
                  &dwSize
                  );

    if ( dwError != NO_ERROR ) {

        if ((dwError == ERROR_FILE_NOT_FOUND) ||
            (dwError == ERROR_PATH_NOT_FOUND))
        {
            dwError = NO_ERROR;
        }

        goto Cleanup;
    }

    if ( ( dwValueType != REG_DWORD ) || ( dwSize != sizeof(DWORD) ) ) {

        dwError = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    //
    // get the ACE flag
    //

    dwError = ScRegQueryValueExW(
                  hkeyAuditParams,
                  L"DefaultAuditAceFlags",
                  NULL,
                  &dwValueType,
                  (LPBYTE) &AceFlags,
                  &dwSize
                  );

    
    if ( dwError != NO_ERROR ) {

        if ((dwError == ERROR_FILE_NOT_FOUND) ||
            (dwError == ERROR_PATH_NOT_FOUND))
        {
            dwError  = NO_ERROR;
            AceFlags = SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG;
        }

        goto Cleanup;
    }

    if ( ( dwValueType != REG_DWORD ) || ( dwSize != sizeof(DWORD) ) ) {

        dwError = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    
 Cleanup:

    if ( dwError == NO_ERROR ) {

        *AuditAccessMask = AccessMask;
        *AuditAceFlags   = (UCHAR) AceFlags;
        
    } else {

        *AuditAccessMask = 0;
        *AuditAceFlags   = 0;
    }

    if ( hkeyAuditParams != 0 ) {

        ScRegCloseKey( hkeyAuditParams );
    }
    
    return dwError;
}


DWORD
ScCreateScServiceObject(
    OUT PSECURITY_DESCRIPTOR *ServiceSd
    )
/*++

Routine Description:

    This function creates the security descriptor which represents
    the Service object.

Arguments:

    ServiceSd - Returns service object security descriptor.

Return Value:

    Returns values from calls to:
        ScCreateUserSecurityObject

--*/
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    UINT NumAces = 0;
    ACCESS_MASK AuditAccessMask = 0;
    UCHAR AuditAceFlags = 0;
    ULONG Privilege = SE_SECURITY_PRIVILEGE;
    BOOLEAN Impersonating = FALSE;
    DWORD dwError = NO_ERROR;
    
    // 
    // Authenticated users have read access.
    // Local system has service start/stop and all read access.
    // Power user has service start and all read access (Workstation and Server).
    // Admin and SystemOp (DC) are allowed all access.
    //

#define SC_SERVICE_OBJECT_ACES    5             // Number of ACEs

    SC_ACE_DATA AceData[SC_SERVICE_OBJECT_ACES] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_READ | GENERIC_EXECUTE,
               &LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,
               &AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_READ | SERVICE_USER_DEFINED_CONTROL,
               &AuthenticatedUserSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               0,
               0},

        {SYSTEM_AUDIT_ACE_TYPE, 0, 0,
               0,
               &WorldSid}
        };

    //
    // do not include the last ACE (the audit ACE) for now
    //

    NumAces = SC_SERVICE_OBJECT_ACES - 1;

    switch(USER_SHARED_DATA->NtProductType)
    {
        case NtProductWinNt:
        case NtProductServer:

            //
            // Power users are only on Workstation and Server
            //
            AceData[SC_SERVICE_OBJECT_ACES - 2].Mask = GENERIC_READ | GENERIC_EXECUTE;
            AceData[SC_SERVICE_OBJECT_ACES - 2].Sid  = &AliasPowerUsersSid;
            break;

        case NtProductLanManNt:

            //
            // System Ops (Server Operators) are only on a DC
            //
            AceData[SC_SERVICE_OBJECT_ACES - 2].Mask = GENERIC_ALL;
            AceData[SC_SERVICE_OBJECT_ACES - 2].Sid  = &AliasSystemOpsSid;
            break;

        default:

            //
            // A new product type has been added -- add code to cover it
            //
            SC_ASSERT(FALSE);
            break;
    }

    //
    // get the access-mask and ACE flags to use for the audit ACE.
    //

    dwError = ScGetSaclParameters(
                  &AuditAccessMask,
                  &AuditAceFlags
                  );

    if ( dwError == NO_ERROR ) {

        if ( AuditAccessMask && AuditAceFlags ) {

            AceData[NumAces].Mask     = AuditAccessMask;
            AceData[NumAces].AceFlags = AuditAceFlags;
            NumAces += 1;

            //
            // need SE_SECURITY_PRIVILEGE privilege to create SD with a SACL
            //

            dwError = ScGetPrivilege(1, &Privilege);

            if (dwError != NO_ERROR) {

                goto Cleanup;
            }

            Impersonating = TRUE;
        }

        ntstatus = ScCreateUserSecurityObject(
                       ScManagerSd,                 // ParentSD
                       AceData,
                       NumAces,
                       LocalSystemSid,
                       LocalSystemSid,
                       FALSE,                       // IsDirectoryObject
                       Impersonating,               // UseImpersonationToken
                       &ScServiceObjectMapping,
                       ServiceSd
                       );

        dwError = RtlNtStatusToDosError(ntstatus);
        
        if ( Impersonating ) {
            
            ScReleasePrivilege();
        }
    }
    

#undef SC_SERVICE_OBJECT_ACES
 Cleanup:
    
    return dwError;
}




DWORD
ScGrantAccess(
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This function is called when a new service is created.  It validates
    the access desired by the caller for the new service handle and
    computes the granted access to be stored in the context handle
    structure.  Since this is object creation, all requested accesses,
    except for ACCESS_SYSTEM_SECURITY, are granted automatically.

Arguments:

    DesiredAccess - Supplies the client requested desired access.

    ContextHandle - On return, the granted access is written back to this
        location if this call succeeds.

Return Value:

    Returns values from calls to the following, mapped to Win32 error codes:
        ScPrivilegeCheckAndAudit

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ACCESS_MASK AccessToGrant = DesiredAccess;

    //
    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
    //

    if (AccessToGrant & MAXIMUM_ALLOWED) {

        AccessToGrant &= ~MAXIMUM_ALLOWED;
        AccessToGrant |= GENERIC_ALL;
    }

    //
    // If ACCESS_SYSTEM_SECURITY is requested, check that we have
    // SE_SECURITY_PRIVILEGE.
    //

    if (AccessToGrant & ACCESS_SYSTEM_SECURITY) {

        Status = ScPrivilegeCheckAndAudit(
                    SE_SECURITY_PRIVILEGE,  // check for this privilege
                    ContextHandle,          // client's handle to the object
                                            //  (used for auditing only)
                    DesiredAccess           // (used for auditing only)
                    );
    }

    if (NT_SUCCESS(Status)) {

        //
        // Map the generic bits to specific and standard bits.
        //

        RtlMapGenericMask(
            &AccessToGrant,
            &ScServiceObjectMapping
            );

        //
        // Return the computed access mask.
        //

        ContextHandle->AccessGranted = AccessToGrant;
    }

    return(RtlNtStatusToDosError(Status));
}


NTSTATUS
ScPrivilegeCheckAndAudit(
    IN ULONG PrivilegeId,
    IN PVOID ObjectHandle,
    IN ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This function is only called from ScGrantAccess.  It checks if the given
    well known privilege is enabled for an impersonated client.  It also
    generates an audit for the attempt to use the privilege.

Arguments:

    PrivilegeId -  Specifies the well known Privilege Id

    ObjectHandle - Client's handle to the object (used for auditing)

    DesiredAccess - Access that the client requested to the object (used
                    for auditing)

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and the client
            is either trusted or has the necessary privilege enabled.

        STATUS_PRIVILEGE_NOT_HELD - The client does not have the necessary
            privilege.
--*/
{
    NTSTATUS Status, SecondaryStatus;
    HANDLE ClientToken = NULL;

    //
    // Impersonate the client.
    //

    Status = I_RpcMapWin32Status(RpcImpersonateClient( NULL ));

    if (NT_SUCCESS(Status)) {

        //
        // Open the current thread's impersonation token (if any).
        //

        Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &ClientToken
                     );

        if (NT_SUCCESS(Status)) {

            PRIVILEGE_SET Privilege;
            BOOLEAN PrivilegeHeld = FALSE;
            UNICODE_STRING Subsystem;

            //
            // OK, we have a token open.  Now check for the specified privilege.
            // On return, PrivilegeHeld indicates whether the client has the
            // privilege, and whether we will allow the operation to succeed.
            //

            Privilege.PrivilegeCount = 1;
            Privilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
            Privilege.Privilege[0].Luid = RtlConvertLongToLuid(PrivilegeId);
            Privilege.Privilege[0].Attributes = 0;

            Status = NtPrivilegeCheck(
                         ClientToken,
                         &Privilege,
                         &PrivilegeHeld
                         );

            SC_ASSERT(NT_SUCCESS(Status));

            //
            // Audit the attempt to use the privilege.
            //

            RtlInitUnicodeString(&Subsystem, SC_MANAGER_AUDIT_NAME);

            Status = NtPrivilegeObjectAuditAlarm(
                            &Subsystem,     // Subsystem name
                            PrivilegeHeld ? ObjectHandle : NULL,
                                            // Object handle, to display in
                                            //  the audit log
                            ClientToken,    // Client's token
                            DesiredAccess,  // Access desired by client
                            &Privilege,     // Privileges attempted to use
                            PrivilegeHeld   // Whether access was granted
                            );

            SC_ASSERT(NT_SUCCESS(Status));

            if ( !PrivilegeHeld ) {

                Status = STATUS_PRIVILEGE_NOT_HELD;
            }


            //
            // Close the client token.
            //

            SecondaryStatus = NtClose( ClientToken );
            ASSERT(NT_SUCCESS(SecondaryStatus));
        }

        //
        // Stop impersonating the client.
        //

        SecondaryStatus = I_RpcMapWin32Status(RpcRevertToSelf());
    }

    return Status;
}


DWORD
ScAccessValidate(
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This function is called due to an open request.  It validates the
    desired access based on the object type specified in the context
    handle structure.  If the requested access is granted, it is
    written into the context handle structure.

Arguments:

    ContextHandle - Supplies a pointer to the context handle structure
        which contains information about the object.  On return, the
        granted access is written back to this structure if this
        call succeeds.

    DesiredAccess - Supplies the client requested desired access.


Return Value:

    ERROR_GEN_FAILURE - Object type is unrecognizable.  An internal
        error has occured.

    Returns values from calls to:
        ScAccessCheckAndAudit

Notes:

    The supplied ContextHandle must be verified to be valid (i.e., non-NULL)
    BEFORE calling this routine.

--*/
{

    ACCESS_MASK RequestedAccess = DesiredAccess;

    if (ContextHandle->Signature == SC_SIGNATURE) {

        //
        // Map the generic bits to specific and standard bits.
        //
        RtlMapGenericMask(&RequestedAccess, &ScManagerObjectMapping);

        //
        // Check to see if requested access is granted to client
        //
        return ScAccessCheckAndAudit(
                   (LPWSTR) SC_MANAGER_AUDIT_NAME,
                   (LPWSTR) SC_MANAGER_OBJECT_TYPE_NAME,
                   ContextHandle->Type.ScManagerObject.DatabaseName,
                   ContextHandle,
                   ScManagerSd,
                   RequestedAccess,
                   &ScManagerObjectMapping
                   );
    }
    else if (ContextHandle->Signature == SERVICE_SIGNATURE) {

        //
        // Special-case the status access check instead of adding the right
        // for the service to set its own status to the service's default SD
        // because of the following reasons:
        //
        //     1.  This check is tighter -- since an SC_HANDLE can be used
        //         remotely, this prevents SetServiceStatus from now being
        //         called remotely because the LUIDs won't match.
        //
        //     2.  Modifying the SD would require lots of extra work for SDs
        //         that are stored in the registry -- the SCM would have to
        //         detect that there's no SERVICE_SET_STATUS access ACL on
        //         the SD and add it (also in calls to SetServiceObjectSecurity).
        //
        // Note that if the user specifies extraneous access bits (i.e.,
        // SERVICE_SET_STATUS & <other bits>), it will be rejected by the
        // ScAccessCheckAndAudit call below.
        //
        if (DesiredAccess == SERVICE_SET_STATUS) {
            
            DWORD dwError = ScStatusAccessCheck(ContextHandle->Type.ScServiceObject.ServiceRecord);

            if (dwError == NO_ERROR) {
                ContextHandle->AccessGranted = SERVICE_SET_STATUS;
            }

            return dwError;
        }

        //
        // Map the generic bits to specific and standard bits.
        //
        RtlMapGenericMask(&RequestedAccess, &ScServiceObjectMapping);

        //
        // Check to see if requested access is granted to client
        //
        return ScAccessCheckAndAudit(
                   (LPWSTR) SC_MANAGER_AUDIT_NAME,
                   (LPWSTR) SC_SERVICE_OBJECT_TYPE_NAME,
                   ContextHandle->Type.ScServiceObject.ServiceRecord->ServiceName,
                   ContextHandle,
                   ContextHandle->Type.ScServiceObject.ServiceRecord->ServiceSd,
                   RequestedAccess,
                   &ScServiceObjectMapping
                   );
    }
    else {

        //
        // Unknown object type.  This should not happen!
        //
        SC_LOG(ERROR, "ScAccessValidate: Unknown object type, signature=0x%08lx\n",
               ContextHandle->Signature);
        ASSERT(FALSE);
        return ERROR_GEN_FAILURE;
    }
}


DWORD
ScAccessCheckAndAudit(
    IN     LPWSTR SubsystemName,
    IN     LPWSTR ObjectTypeName,
    IN     LPWSTR ObjectName,
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN     ACCESS_MASK DesiredAccess,
    IN     PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    ObjectName - Supplies the name of the object being accessed.

    ContextHandle - Supplies the context handle to the object.  On return, if
        this call succeeds, the granted access is written to the AccessGranted
        field of this structure, and the SC_HANDLE_GENERATE_ON_CLOSE bit of the
        Flags field indicates whether NtCloseAuditAlarm must be called when
        this handle is closed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NT status mapped to Win32 errors.

--*/
{

    NTSTATUS NtStatus;
    RPC_STATUS RpcStatus;

    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;

    BOOLEAN GenerateOnClose;
    NTSTATUS AccessStatus;



    RtlInitUnicodeString(&Subsystem, SubsystemName);
    RtlInitUnicodeString(&ObjectType, ObjectTypeName);
    RtlInitUnicodeString(&Object, ObjectName);

    if ((RpcStatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SC_LOG1(ERROR, "ScAccessCheckAndAudit: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
                RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_IMPERSONATE,
            RpcStatus
            );

        return RpcStatus;
    }

    NtStatus = NtAccessCheckAndAuditAlarm(
                   &Subsystem,
                   (PVOID) ContextHandle,
                   &ObjectType,
                   &Object,
                   SecurityDescriptor,
                   DesiredAccess,
                   GenericMapping,
                   FALSE,
                   &ContextHandle->AccessGranted,   // return access granted
                   &AccessStatus,
                   &GenerateOnClose
                   );

    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        SC_LOG(ERROR, "ScAccessCheckAndAudit: Fail to revert to self %08lx\n",
               RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_REVERT,
            RpcStatus
            );

        ASSERT(FALSE);
        return RpcStatus;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (NtStatus != STATUS_ACCESS_DENIED)
        {
            SC_LOG1(ERROR,
                    "ScAccessCheckAndAudit: Error calling NtAccessCheckAndAuditAlarm "
                        FORMAT_NTSTATUS "\n",
                    NtStatus);
        }

        return RtlNtStatusToDosError(NtStatus);
    }

    if (GenerateOnClose)
    {
        ContextHandle->Flags |= SC_HANDLE_GENERATE_ON_CLOSE;
    }

    if (AccessStatus != STATUS_SUCCESS)
    {
        SC_LOG(SECURITY, "ScAccessCheckAndAudit: Access status is %08lx\n", AccessStatus);
        return RtlNtStatusToDosError(AccessStatus);
    }

    SC_LOG(SECURITY, "ScAccessCheckAndAudit: Object name %ws\n", ObjectName);
    SC_LOG(SECURITY, "                       Granted access %08lx\n", ContextHandle->AccessGranted);

    return NO_ERROR;
}


DWORD
ScStatusAccessCheck(
    IN     LPSERVICE_RECORD   lpServiceRecord    OPTIONAL
    )
{
    RPC_STATUS          RpcStatus;
    DWORD               dwStatus;

    HANDLE              hThreadToken   = NULL;

    SC_ASSERT(lpServiceRecord == NULL || ScServiceRecordLock.Have());

    //
    // If OpenService is called for SERVICE_SET_STATUS access on a
    // service that's not running, the ImageRecord will be NULL
    //
    if (lpServiceRecord != NULL && lpServiceRecord->ImageRecord == NULL)
    {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        SC_LOG1(ERROR,
                "ScStatusAccessCheck: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
                RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_IMPERSONATE,
            RpcStatus
            );

        return RpcStatus;
    }

    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,
                         TRUE,               // Open as self
                         &hThreadToken))
    {
        dwStatus = GetLastError();

        SC_LOG1(ERROR,
                "ScStatusAccessCheck: OpenThreadToken FAILED %d\n",
                dwStatus);
    }
    else
    {
        TOKEN_STATISTICS  TokenStats;

        if (!GetTokenInformation(hThreadToken,
                                 TokenStatistics,        // Information wanted
                                 &TokenStats,
                                 sizeof(TokenStats),     // Buffer size
                                 &dwStatus))             // Size required
        {
            dwStatus = GetLastError();

            SC_LOG1(ERROR,
                    "ScCreateImageRecord: GetTokenInformation FAILED %d\n",
                    dwStatus);
        }
        else
        {
            LUID  SystemLuid = SYSTEM_LUID;

            if (RtlEqualLuid(&TokenStats.AuthenticationId,
                             lpServiceRecord ? &lpServiceRecord->ImageRecord->AccountLuid :
                                               &SystemLuid))
            {
                dwStatus = NO_ERROR;
            }
            else
            {
                dwStatus = ERROR_ACCESS_DENIED;
            }
        }

        CloseHandle(hThreadToken);
    }

    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        SC_LOG(ERROR,
               "ScStatusAccessCheck: Fail to revert to self %08lx\n",
               RpcStatus);

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_REVERT,
            RpcStatus
            );

        ASSERT(FALSE);
        return RpcStatus;
    }

    return dwStatus;
}    


DWORD
ScGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    )
/*++

Routine Description:

    This function alters the privilege level for the current thread.

    It does this by duplicating the token for the current thread, and then
    applying the new privileges to that new token, then the current thread
    impersonates with that new token.

    Privileges can be relinquished by calling ScReleasePrivilege().

Arguments:

    numPrivileges - This is a count of the number of privileges in the
        array of privileges.

    pulPrivileges - This is a pointer to the array of privileges that are
        desired.  This is an array of ULONGs.

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.

--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    HANDLE                      newToken;
    OBJECT_ATTRIBUTES           Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    ULONG                       returnLen;
    PTOKEN_PRIVILEGES           pTokenPrivilege = NULL;
    DWORD                       i;

    //
    // Initialize the Privileges Structure
    //
    pTokenPrivilege = (PTOKEN_PRIVILEGES) LocalAlloc(
                                              LMEM_FIXED,
                                              sizeof(TOKEN_PRIVILEGES) +
                                                  (sizeof(LUID_AND_ATTRIBUTES) *
                                                   numPrivileges)
                                              );

    if (pTokenPrivilege == NULL) {
        status = GetLastError();
        SC_LOG(ERROR,"ScGetPrivilege:LocalAlloc Failed %d\n", status);
        return(status);
    }

    pTokenPrivilege->PrivilegeCount  = numPrivileges;

    for (i = 0; i < numPrivileges; i++) {
        pTokenPrivilege->Privileges[i].Luid = RtlConvertLongToLuid(
                                                pulPrivileges[i]);
        pTokenPrivilege->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;

    }

    //
    // Initialize Object Attribute Structure.
    //
    InitializeObjectAttributes(&Obja,NULL,0L,NULL,NULL);

    //
    // Initialize Security Quality Of Service Structure
    //
    SecurityQofS.Length              = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQofS.ImpersonationLevel  = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly       = FALSE;

    Obja.SecurityQualityOfService = &SecurityQofS;

    //
    // Duplicate our Process Token
    //
    ntStatus = NtDuplicateToken(
                g_hProcessToken,
                TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &Obja,
                FALSE,                  // Duplicate the entire token
                TokenImpersonation,     // TokenType
                &newToken);             // Duplicate token

    if (!NT_SUCCESS(ntStatus)) {
        SC_LOG(ERROR, "ScGetPrivilege: NtDuplicateToken Failed "
            "FORMAT_NTSTATUS" "\n", ntStatus);

        LocalFree(pTokenPrivilege);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Add new privileges
    //

    ntStatus = NtAdjustPrivilegesToken(
                newToken,                   // TokenHandle
                FALSE,                      // DisableAllPrivileges
                pTokenPrivilege,            // NewState
                0,                          // Size of previous state buffer
                NULL,                       // No info on previous state
                &returnLen);                // numBytes required for buffer.

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG(ERROR, "ScGetPrivilege: NtAdjustPrivilegesToken Failed "
            "FORMAT_NTSTATUS" "\n", ntStatus);

        LocalFree(pTokenPrivilege);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Begin impersonating with the new token
    //
    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&newToken,
                (ULONG)sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus)) {

        SC_LOG(ERROR, "ScGetPrivilege: NtAdjustPrivilegesToken Failed "
            "FORMAT_NTSTATUS" "\n", ntStatus);

        LocalFree(pTokenPrivilege);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    LocalFree(pTokenPrivilege);
    NtClose(newToken);

    return(NO_ERROR);
}


DWORD
ScReleasePrivilege(
    VOID
    )
/*++

Routine Description:

    This function relinquishes privileges obtained by calling ScGetPrivilege().

Arguments:

    none

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.


--*/
{
    NTSTATUS    ntStatus;
    HANDLE      NewToken;


    //
    // Revert To Self.
    //
    NewToken = NULL;

    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&NewToken,
                (ULONG)sizeof(HANDLE));

    if ( !NT_SUCCESS(ntStatus) ) {
        return(RtlNtStatusToDosError(ntStatus));
    }

    return(NO_ERROR);
}


DWORD
ScGetClientSid(
    OUT PTOKEN_USER *UserInfo
    )

/*++

Routine Description:

    This function looks up the SID of the API caller by impersonating
    the caller.

Arguments:

    UserInfo - Receives a pointer to a buffer allocated by this routine
        which contains the TOKEN_USER information of the caller.

Return Value:

    Returns the NT error mapped to Win32

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    RPC_STATUS rpcstatus;
    HANDLE CurrentThreadToken = NULL;
    DWORD UserInfoSize;


    *UserInfo = NULL;

    if ((rpcstatus = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SC_LOG1(
            ERROR,
            "ScGetUserSid: Failed to impersonate client " FORMAT_RPC_STATUS "\n",
            rpcstatus
            );

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_IMPERSONATE,
            rpcstatus
            );

        return ((DWORD) rpcstatus);
    }

    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,              // Use service controller's security
                                      // context to open thread token
                   &CurrentThreadToken
                   );

    status = RtlNtStatusToDosError(ntstatus);

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR, "ScGetUserSid: NtOpenThreadToken failed "
                FORMAT_NTSTATUS "\n", ntstatus);
        goto Cleanup;
    }

    //
    // Call NtQueryInformationToken the first time with 0 input size to
    // get size of returned information.
    //
    ntstatus = NtQueryInformationToken(
                   CurrentThreadToken,
                   TokenUser,         // User information class
                   (PVOID) *UserInfo, // Output
                   0,
                   &UserInfoSize
                   );

    if (ntstatus != STATUS_BUFFER_TOO_SMALL) {
        SC_LOG1(ERROR, "ScGetUserSid: NtQueryInformationToken failed "
                FORMAT_NTSTATUS ".  Expected BUFFER_TOO_SMALL.\n", ntstatus);
        status = RtlNtStatusToDosError(ntstatus);
        goto Cleanup;
    }

    //
    // Allocate buffer of returned size
    //
    *UserInfo = (PTOKEN_USER)LocalAlloc(
                    LMEM_ZEROINIT,
                    (UINT) UserInfoSize
                    );

    if (*UserInfo == NULL) {
        SC_LOG1(ERROR, "ScGetUserSid: LocalAlloc failed " FORMAT_DWORD
                "\n", GetLastError());
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Call NtQueryInformationToken again with the correct buffer size.
    //
    ntstatus = NtQueryInformationToken(
                   CurrentThreadToken,
                   TokenUser,         // User information class
                   (PVOID) *UserInfo, // Output
                   UserInfoSize,
                   &UserInfoSize
                   );

    status = RtlNtStatusToDosError(ntstatus);

    if (! NT_SUCCESS(ntstatus)) {
        SC_LOG1(ERROR, "ScGetUserSid: NtQueryInformationToken failed "
                FORMAT_NTSTATUS "\n", ntstatus);

        LocalFree(*UserInfo);
        *UserInfo = NULL;
    }

Cleanup:

    if (CurrentThreadToken != NULL)
    {
        NtClose(CurrentThreadToken);
    }

    if ((rpcstatus = RpcRevertToSelf()) != RPC_S_OK)
    {
        SC_LOG1(
           ERROR,
           "ScGetUserSid: Failed to revert to self " FORMAT_RPC_STATUS "\n",
           rpcstatus
           );

        ScLogEvent(
            NEVENT_CALL_TO_FUNCTION_FAILED,
            SC_RPC_REVERT,
            rpcstatus
            );

        SC_ASSERT(FALSE);
        return ((DWORD) rpcstatus);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scsec.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    scsec.h

Abstract:

    Security related function prototypes.

Author:

    Rita Wong (ritaw)     10-Mar-1992

Revision History:

--*/

#ifndef _SCSEC_INCLUDED_
#define _SCSEC_INCLUDED_

#include <scseclib.h>

DWORD
ScCreateScManagerObject(
    VOID
    );

DWORD
ScCreateScServiceObject(
    OUT PSECURITY_DESCRIPTOR *ServiceSd
    );

DWORD
ScGrantAccess(
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     ACCESS_MASK DesiredAccess
    );

NTSTATUS
ScPrivilegeCheckAndAudit(
    IN ULONG PrivilegeId,
    IN PVOID ObjectHandle,
    IN ACCESS_MASK DesiredAccess
    );

DWORD
ScAccessValidate(
    IN OUT LPSC_HANDLE_STRUCT ScObject,
    IN     ACCESS_MASK DesiredAccess
    );

DWORD
ScAccessCheckAndAudit(
    IN     LPWSTR SubsystemName,
    IN     LPWSTR ObjectTypeName,
    IN     LPWSTR ObjectName,
    IN OUT LPSC_HANDLE_STRUCT ContextHandle,
    IN     PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN     ACCESS_MASK DesiredAccess,
    IN     PGENERIC_MAPPING GenericMapping
    );

DWORD
ScStatusAccessCheck(
    IN     LPSERVICE_RECORD   lpService
    );

DWORD
ScGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );

DWORD
ScReleasePrivilege(
    VOID
    );

DWORD
ScGetClientSid(
    OUT PTOKEN_USER *UserInfo
    );

#define SC_MANAGER_SUBSYSTEM_NAME       L"SERVICE CONTROL MANAGER"
#define SC_MANAGER_AUDIT_NAME           L"SC Manager"

#define SC_MANAGER_OBJECT_TYPE_NAME     L"SC_MANAGER OBJECT"
#define SC_SERVICE_OBJECT_TYPE_NAME     L"SERVICE OBJECT"


#endif // _SCSEC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\scopen.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    scopen.cxx

Abstract:

    Functions for handling opening and closing of Service and
    ServiceController handles.

        ROpenSCManagerW
        ROpenServiceW
        RCloseServiceHandle
        SC_RPC_HANDLE_rundown
        ScCreateScManagerHandle
        ScCreateServiceHandle
        ScIsValidScManagerHandle
        ScIsValidServiceHandle
        ScIsValidScManagerOrServiceHandle

Author:

    Dan Lafferty (danl) 20-Jan-1992

Environment:

    User Mode - Win32

Revision History:

    20-Jan-1992 danl
        Created
    10-Apr-1992 JohnRo
        Added ScIsValidServiceHandle().
        Export ScCreateServiceHandle() for RCreateService() too.
    14-Apr-1992 JohnRo
        Added ScIsValidScManagerHandle().
    22-Feb-1995 AnirudhS
        RCloseServiceHandle: Pass the handle, rather than the address of the
        handle, to the auditing routine.

--*/

#include "precomp.hxx"
#include <stdlib.h>      // wide character c runtimes.
#include <tstr.h>       // Unicode string macros
#include "scsec.h"      // ScAccessValidate
#include "sclib.h"      // ScIsValidServiceName


//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
ScCreateScManagerHandle(
    IN  LPWSTR DatabaseName,
    OUT LPSC_HANDLE_STRUCT *ContextHandle
    );

//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
ROpenSCManagerW(
    IN  LPWSTR          lpMachineName,
    IN  LPWSTR          lpDatabaseName,
    IN  DWORD           dwDesiredAccess OPTIONAL,
    OUT LPSC_RPC_HANDLE lpScHandle
    )
/*++

Routine Description:


Arguments:

    lpMachineName -

    lpDatabaseName -

    dwDesiredAccess -

    lpScHandle -

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_NAME - lpDatabaseName is invalid

    ERROR_DATABASE_DOES_NOT_EXIST - Valid database name but database
        does not exist.

    ERROR_ACCESS_DENIED - dwDesiredAccess specifies accesses that are
        not granted to the client, or contains invalid bits.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocated memory for context
        handle.

--*/
{
    LPSC_HANDLE_STRUCT scManagerHandle;
    DWORD error;
    LPWSTR RequestedDatabase = SERVICES_ACTIVE_DATABASEW;


    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // This parameter got us to the server side and is uninteresting
    // once we get here.
    //
    UNREFERENCED_PARAMETER(lpMachineName);

    //
    // Validate specified database name
    //
    if (ARGUMENT_PRESENT(lpDatabaseName)) {
        if ((_wcsicmp(lpDatabaseName, SERVICES_ACTIVE_DATABASEW) != 0) &&
            (_wcsicmp(lpDatabaseName, SERVICES_FAILED_DATABASEW) != 0)) {

            return ERROR_INVALID_NAME;

        }
        else if ((_wcsicmp(lpDatabaseName, SERVICES_FAILED_DATABASEW) == 0)
                   &&
                 (TRUE))
        {
            //
            // CODEWORK:  Actually implement a ServicesFailed database
            //            at some point in the future and check for it
            //            in place of the (TRUE) above.
            //

            //
            // ServicesFailed database does not exist
            //
            return ERROR_DATABASE_DOES_NOT_EXIST;

        }
        else {
            RequestedDatabase = lpDatabaseName;
        }
    }

    //
    // Allocate context handle structure and save the database name in it
    //
    if ((error = ScCreateScManagerHandle(
                     RequestedDatabase,
                     &scManagerHandle
                     )) != NO_ERROR) {
        return error;
    }

    //
    // Make sure the desired access specified is valid and allowed to
    // the client.  Save away the desired access in the handle structure.
    //
    if ((error = ScAccessValidate(
                     scManagerHandle,
                     (dwDesiredAccess | SC_MANAGER_CONNECT)
                     )) != NO_ERROR) {

        SC_LOG(ERROR,"ROpenSCManagerW:ScAccessValidate Failed %u\n",
               error);
        (void) LocalFree(scManagerHandle);
        return error;
    }

    //
    // return the pointer to the handle struct as the context handle for
    // this open.
    //
    *lpScHandle = (SC_RPC_HANDLE)scManagerHandle;

    SC_LOG(HANDLE,"SC Manager Handle Opened 0x%08lx\n",*lpScHandle);

    return(NO_ERROR);
}


DWORD
ROpenServiceW(
    IN  SC_RPC_HANDLE   hSCManager,
    IN  LPWSTR          lpServiceName,
    IN  DWORD           dwDesiredAccess,
    OUT LPSC_RPC_HANDLE phService
    )

/*++

Routine Description:

    Returns a handle to the service.  This handle is actually a pointer
    to a data structure that contains a pointer to the service record.

Arguments:

    hSCManager - This is a handle to this service controller.  It is an
        RPC context handle, and has allowed the request to get this far.

    lpServiceName - This is a pointer to a string containing the name of
        the service

    dwDesiredAccess - This is an access mask that contains a description
        of the access that is desired for this service.

    phService - This is a pointer to the location where the handle to the
        service is to be placed.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The specified ScManager handle is invalid.

    ERROR_SERVICE_DOES_NOT_EXIST - The specified service does not exist
        in the database.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation for the handle structure
        failed.

    ERROR_INVALID_NAME - Service name contains invalid character or
        name is too long.
Note:


--*/
{

    LPSC_HANDLE_STRUCT serviceHandle;
    DWORD              status;
    LPSERVICE_RECORD   serviceRecord;


    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //

    if (!ScIsValidScManagerHandle(hSCManager))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Validate the format of the service name.
    //
    if (! ScIsValidServiceName(lpServiceName)) {
        return(ERROR_INVALID_NAME);
    }

    //
    // Find the service record in the database.
    //

    CServiceListSharedLock LLock;
    CServiceRecordExclusiveLock RLock;

    status = ScGetNamedServiceRecord(
                lpServiceName,
                &serviceRecord);

    if (status != NO_ERROR) {
        return(status);
    }

    //
    // Allocate context handle structure and save the service record
    // pointer in it.
    //
    if ((status = ScCreateServiceHandle(
                      serviceRecord,
                      &serviceHandle
                      )) != NO_ERROR) {

        return(status);
    }

    //
    // Make sure the desired access specified is valid and allowed to
    // the client.  Save away the desired access in the handle structure.
    //
    if ((status = ScAccessValidate(
                      serviceHandle,
                      dwDesiredAccess
                      )) != NO_ERROR) {

        SC_LOG(ERROR,"ROpenServiceW:ScAccessValidate Failed %u\n",
               status);
        (void) LocalFree(serviceHandle);
        return(status);
    }

    //
    // Additional check is required if the SCManager points to a database
    // other than the active one.  Execute accesses are not allowed.
    //
    if (_wcsicmp(
            ((LPSC_HANDLE_STRUCT)hSCManager)->Type.ScManagerObject.DatabaseName,
            SERVICES_ACTIVE_DATABASEW
            ) != 0) {

        if (dwDesiredAccess & MAXIMUM_ALLOWED) {

            //
            // MAXIMUM_ALLOWED is requested.  Remove bits for execute accesses.
            //
            serviceHandle->AccessGranted &= ~(SERVICE_STOP           |
                                              SERVICE_START          |
                                              SERVICE_PAUSE_CONTINUE |
                                              SERVICE_INTERROGATE    |
                                              SERVICE_USER_DEFINED_CONTROL);

        }
        else if ((serviceHandle->AccessGranted &
                  (SERVICE_STOP           |
                   SERVICE_START          |
                   SERVICE_PAUSE_CONTINUE |
                   SERVICE_INTERROGATE    |
                   SERVICE_USER_DEFINED_CONTROL)) != 0) {

            //
            // Deny access if any execute access is requested.
            //
            SC_LOG(
                SECURITY,
                "ROpenServiceW:Non-active database, execute accesses not allowed\n",
                0
                );
            (void) LocalFree(serviceHandle);
            return(ERROR_ACCESS_DENIED);
        }
    }

    //
    // Increment the UseCount.  The service record cannot be deleted
    // as long as the UseCount is greater than zero.
    //
    serviceRecord->UseCount++;

    SC_LOG2(USECOUNT, "ROpenServiceW: " FORMAT_LPWSTR
        " increment USECOUNT=%lu\n", serviceRecord->ServiceName, serviceRecord->UseCount);

    //
    // return the pointer to the handle struct as the handle for this
    // open.
    //
    *phService = (SC_RPC_HANDLE)serviceHandle;

    SC_LOG(HANDLE,"Service Handle Opened 0x%lx\n",*phService);

    return (NO_ERROR);
}


DWORD
RCloseServiceHandle(
    IN OUT SC_RPC_HANDLE    *phSCObject
    )

/*++

Routine Description:

    This function closes a handle to a service or to the service controller
    by freeing the data structure that the handle points to.

Arguments:

    phSCObject - This is a pointer to a pointer to the context handle
        structure.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The handle is invalid.  It does not point to
        a recognizable structure.

Note:


--*/
{
    NTSTATUS            status;
    HLOCAL              FreeStatus;
    UNICODE_STRING      Subsystem;
    ULONG               privileges[1];
    SC_HANDLE_TYPE      HandleType;

    //
    // Check the handle
    //

    if (!ScIsValidScManagerOrServiceHandle(*phSCObject, &HandleType))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // If it is a service handle being closed, decrement the use count.
    // If the count goes to zero, and the service is marked for deletion,
    // it will get deleted.
    //
    if (HandleType == SC_HANDLE_TYPE_SERVICE)
    {
        RPC_STATUS RpcStatus;
        BOOL       fImpersonated = TRUE;

        {
            CServiceRecordExclusiveLock RLock;

            ScDecrementUseCountAndDelete(
                ((LPSC_HANDLE_STRUCT)*phSCObject)->Type.ScServiceObject.ServiceRecord);
        }

        //
        // Get Audit Privilege
        //
        privileges[0] = SE_AUDIT_PRIVILEGE;
        status = ScGetPrivilege( 1, privileges);

        if (status != NO_ERROR)
        {
            SC_LOG1(ERROR,
                    "RCloseServiceHandle: ScGetPrivilege (Enable) failed: %d\n",
                    status);
        }

        //
        // Generate the audit -- must be done as the user as per C2 requirements.
        //

        RpcStatus = RpcImpersonateClient(NULL);

        if (RpcStatus != RPC_S_OK)
        {
            //
            // Can't impersonate the user -- either RCloseServiceHandle was called
            // internally by the SCM or the impersonate failed for some other reason.
            // Do the audit as System instead.
            //

            fImpersonated = FALSE;
        }

        RtlInitUnicodeString(&Subsystem, SC_MANAGER_AUDIT_NAME);

        status = NtCloseObjectAuditAlarm(
                    &Subsystem,
                    *phSCObject,
                    (BOOLEAN)((((LPSC_HANDLE_STRUCT)*phSCObject)->Flags
                        & SC_HANDLE_GENERATE_ON_CLOSE) != 0));

        if (!NT_SUCCESS(status))
        {
            SC_LOG1(ERROR,
                    "RCloseServiceHandle: NtCloseObjectAuditAlarm failed: %#lx\n",status);
        }

        if (fImpersonated)
        {
            RpcStatus = RpcRevertToSelf();

            if (RpcStatus != RPC_S_OK)
            {
                SC_LOG(ERROR,
                       "RCloseServiceHandle: Fail to revert to self %08lx\n",
                       RpcStatus);

                ScLogEvent(
                    NEVENT_CALL_TO_FUNCTION_FAILED,
                    SC_RPC_REVERT,
                    RpcStatus);

                ASSERT(FALSE);

                //
                // Not much else we can do at this point -- keep on going.
                //
            }
        }

        ScReleasePrivilege();
    }

    //
    // Attempt to free the memory that the handle points to.
    //

    FreeStatus = LocalFree(*phSCObject);

    if (FreeStatus != NULL)
    {
        //
        // For some reason, the handle couldn't be freed.  Therefore, the
        // best we can do to disable it is to remove the signature.
        //

        SC_LOG(ERROR,"RCloseServiceHandle:LocalFree Failed %d\n",GetLastError());
        ((LPSC_HANDLE_STRUCT)*phSCObject)->Signature = 0;
    }

    //
    // Tell RPC we are done with the context handle.
    //

    SC_LOG(HANDLE,"Handle Closed 0x%08lx\n",*phSCObject);

    *phSCObject = NULL;

    return(NO_ERROR);
}


VOID
SC_RPC_HANDLE_rundown(
    SC_RPC_HANDLE     scHandle
    )

/*++

Routine Description:

    This function is called by RPC when a connection is broken that had
    an outstanding context handle.  The value of the context handle is
    passed in here so that we have an opportunity to clean up.

Arguments:

    scHandle - This is the handle value of the context handle that is broken.

Return Value:

    none.

--*/
{
    //
    // Close the handle.
    //

    RCloseServiceHandle(&scHandle);

}


DWORD
ScCreateScManagerHandle(
    IN  LPWSTR DatabaseName,
    OUT LPSC_HANDLE_STRUCT *ContextHandle
    )
/*++

Routine Description:

    This function allocates the memory for an SC Manager context handle
    structure, and initializes it.

Arguments:

    DatabaseName - Supplies the name of the SC Manager database which the
        returned structure is a context of.

    ContextHandle - Returns a pointer to the context handle structure
        created.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Memory allocation for the context handle
        structure failed.

Note:
    The memory allocated by this routine should be freed with LocalFree.

--*/
{
    //
    // Allocate memory for the context handle structure, and database name.
    //
    *ContextHandle = (LPSC_HANDLE_STRUCT)LocalAlloc(
                         LMEM_ZEROINIT,
                         sizeof(SC_HANDLE_STRUCT) + WCSSIZE(DatabaseName));

    if (*ContextHandle == NULL) {
        SC_LOG(ERROR,"ScCreateScManagerHandle:LocalAlloc Failed %d\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure, except for the
    // granted access which is figured out when the desired access is validated
    // later.
    //
    (*ContextHandle)->Signature = SC_SIGNATURE;
    (*ContextHandle)->Flags = 0;

    (*ContextHandle)->Type.ScManagerObject.DatabaseName =
        (LPWSTR) ((DWORD_PTR) *ContextHandle + sizeof(SC_HANDLE_STRUCT));
    wcscpy((*ContextHandle)->Type.ScManagerObject.DatabaseName, DatabaseName);

    return NO_ERROR;
}


BOOL
ScIsValidScManagerHandle(
    IN  SC_RPC_HANDLE   hScManager
    )
{
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hScManager;

    if (serviceHandleStruct == NULL) {
        return (FALSE);   // Not valid.
    }

    if (serviceHandleStruct->Signature != SC_SIGNATURE) {
        return (FALSE);   // Not valid.
    }

    return (TRUE);

} // ScIsValidScManagerHandle


DWORD
ScCreateServiceHandle(
    IN  LPSERVICE_RECORD ServiceRecord,
    OUT LPSC_HANDLE_STRUCT *ContextHandle
    )
/*++

Routine Description:

    This function allocates the memory for a service context handle
    structure, and initializes it.

Arguments:

    ServiceRecord - Supplies a pointer to the service record which the
        returned structure is a context of.

    ContextHandle - Returns a pointer to the context handle structure
        created.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Memory allocation for the context handle
        structure failed.

Note:
    The memory allocated by this routine should be freed with LocalFree.

--*/
{
    //
    // Allocate memory for the context handle structure.
    //
    *ContextHandle = (LPSC_HANDLE_STRUCT)LocalAlloc(
                         LMEM_ZEROINIT,
                         sizeof(SC_HANDLE_STRUCT)
                         );

    if (*ContextHandle == NULL) {
        SC_LOG(ERROR,"ScCreateServiceHandle:LocalAlloc Failed %d\n",
               GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure, except for the
    // granted access which is figured out when the desired access is validated
    // later.
    //
    (*ContextHandle)->Signature = SERVICE_SIGNATURE;
    (*ContextHandle)->Flags = 0;
    (*ContextHandle)->Type.ScServiceObject.ServiceRecord = ServiceRecord;

    SC_ASSERT( ScIsValidServiceHandle( *ContextHandle ) );

    return NO_ERROR;
}


BOOL
ScIsValidServiceHandle(
    IN  SC_RPC_HANDLE   hService
    )
{
    LPSC_HANDLE_STRUCT  serviceHandleStruct = (LPSC_HANDLE_STRUCT) hService;

    if (serviceHandleStruct == NULL) {
        return (FALSE);   // Not valid.
    }

    if (serviceHandleStruct->Signature != SERVICE_SIGNATURE) {
        return (FALSE);   // Not valid.
    }

    return (TRUE);

} // ScIsValidServiceHandle


BOOL
ScIsValidScManagerOrServiceHandle(
    IN  SC_RPC_HANDLE   ContextHandle,
    OUT PSC_HANDLE_TYPE phType
    )
/*++

Routine Description:

    Function to check a handle that may be either a service handle or
    an SC Manager handle without having to check vs. NULL twice by
    calling both ScIsValidScManagerHandle and ScIsValidServiceHandle

Arguments:

    ContextHandle -- The handle to check
    phType        -- The type of the handle (SCManager vs. Service) if valid

Return Value:

    TRUE  -- The handle is valid
    FALSE -- The handle is not valid

--*/
{
    LPSC_HANDLE_STRUCT  pHandle = (LPSC_HANDLE_STRUCT) ContextHandle;

    SC_ASSERT(phType != NULL);

    if (pHandle == NULL)
    {
        return FALSE;   // Not valid.
    }

    if (pHandle->Signature == SERVICE_SIGNATURE)
    {
        *phType = SC_HANDLE_TYPE_SERVICE;
        return TRUE;
    }
    else if (pHandle->Signature == SC_SIGNATURE)
    {
        *phType = SC_HANDLE_TYPE_MANAGER;
        return TRUE;
    }

    return FALSE;

} // ScIsValidScManagerOrServiceHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\sclastgood.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ScLastGood.cxx

Abstract:

    This module implements various functions required to clean-up last known
    good information.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#include "precomp.hxx"
#include "ScpLastGood.h"

//
// DeleteFile is a member of a structure we use below. Here we keep Windows.h
// from redefining the structure member to DeleteFileW.
//
#ifdef DeleteFile
#undef DeleteFile
#endif

DWORD
ScLastGoodFileCleanup(
    VOID
    )
/*++

Routine Description:

    This routine does the neccessary processing to mark a boot "good".
    Specifically, the last known good directory is emptied of any files or
    directories.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING lastKnownGoodTmpSubTree;
    UNICODE_STRING lastKnownGoodTmpRegKey;
    HANDLE regKeyHandle;
    NTSTATUS status;

    RtlInitUnicodeString(
        &lastKnownGoodTmpSubTree,
        L"\\SystemRoot\\LastGood.Tmp"
        );

    RtlInitUnicodeString(
        &lastKnownGoodTmpRegKey,
        L"\\Registry\\Machine\\System\\LastKnownGoodRecovery\\LastGood.Tmp"
        );

    //
    // Delete the temp tree.
    //
    ScLastGoodWalkDirectoryTreeBottomUp(
        &lastKnownGoodTmpSubTree,
        ( DIRWALK_INCLUDE_FILES | DIRWALK_INCLUDE_DIRECTORIES |
          DIRWALK_CULL_DOTPATHS | DIRWALK_TRAVERSE ),
        ScpLastGoodDeleteFiles,
        NULL
        );

    InitializeObjectAttributes(
        &objectAttributes,
        &lastKnownGoodTmpSubTree,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    NtDeleteFile(&objectAttributes);

    //
    // Now delete the corresponding registry key info.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        &lastKnownGoodTmpRegKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(
        &regKeyHandle,
        KEY_ALL_ACCESS,
        &objectAttributes
        );

    if (NT_SUCCESS(status)) {

        NtDeleteKey(regKeyHandle);
        NtClose(regKeyHandle);
    }

    return NO_ERROR;
}


//
// This function works, but it is not needed today.
//
DWORD
ScLastGoodWalkDirectoryTreeTopDown(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    )
/*++

Routine Description:

    This funcion walks a directory tree *top down*, passing each entry to the
    callback with the below restrictions. Note that the root directory itself
    is not included in the callback!

Arguments:

    Directory - Supplies the NT Path to the directory to walk.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                          dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

Return Value:

    DWORD - status of the operation, NO_ERROR on success.

--*/
{
    PDIRWALK_ENTRY pDirEntry;
    PLIST_ENTRY pListEntry;
    NTSTATUS status;
    UCHAR buffer[1024];
    LIST_ENTRY dirListHead;

    InitializeListHead(&dirListHead);

    //
    // Walk the first directory.
    //
    status = ScpLastGoodWalkDirectoryTreeHelper(
        Directory,
        Flags,
        CallbackFunction,
        Context,
        buffer,
        sizeof(buffer),
        &dirListHead
        );

    //
    // Each directory that WalkDirectory finds gets added to the list.
    // process the list until we have no more directories.
    //
    while((!IsListEmpty(&dirListHead)) && NT_SUCCESS(status)) {

        pListEntry = RemoveHeadList(&dirListHead);

        pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

        status = ScpLastGoodWalkDirectoryTreeHelper(
            &pDirEntry->Directory,
            Flags,
            CallbackFunction,
            Context,
            buffer,
            sizeof(buffer),
            &dirListHead
            );

        LocalFree(pDirEntry);
    }

    //
    // If we failed we need to empty out our directory list.
    //
    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&dirListHead)) {

            pListEntry = RemoveHeadList(&dirListHead);

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            LocalFree(pDirEntry);
        }
    }

    return RtlNtStatusToDosError(status);
}


DWORD
ScLastGoodWalkDirectoryTreeBottomUp(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    )
/*++

Routine Description:

    This funcion walks a directory tree *bottom up*, passing each entry to the
    callback with the below restrictions. Note that the root directory itself
    is not included in the callback!

Arguments:

    Directory - Supplies the NT Path to the directory to walk.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

Return Value:

    DWORD - status of the operation, NO_ERROR on success.

--*/
{
    PDIRWALK_ENTRY pDirEntry;
    PLIST_ENTRY pListEntry;
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR buffer[1024];
    LIST_ENTRY dirListHead, dirNothingHead;

    InitializeListHead(&dirListHead);
    InitializeListHead(&dirNothingHead);

    //
    // Create an entry for the root directory.
    //
    pDirEntry = (PDIRWALK_ENTRY) LocalAlloc(
        LPTR,
        sizeof(DIRWALK_ENTRY) + Directory->Length - sizeof(WCHAR)
        );

    if (pDirEntry == NULL) {

        return RtlNtStatusToDosError(STATUS_INSUFFICIENT_RESOURCES);
    }

    pDirEntry->Directory.Length = 0;
    pDirEntry->Directory.MaximumLength = Directory->Length;
    pDirEntry->Directory.Buffer = &pDirEntry->Name[0];
    RtlCopyUnicodeString(&pDirEntry->Directory, Directory);

    InsertHeadList(&dirListHead, &pDirEntry->Link);

    //
    // Collect the directory trees. When we are done we will walk the list in
    // reverse.
    //
    status = STATUS_SUCCESS;
    if (Flags & DIRWALK_TRAVERSE) {

        for(pListEntry = dirListHead.Flink;
            pListEntry != &dirListHead;
            pListEntry = pListEntry->Flink) {

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            status = ScpLastGoodWalkDirectoryTreeHelper(
                &pDirEntry->Directory,
                DIRWALK_TRAVERSE,
                NULL,
                NULL,
                buffer,
                sizeof(buffer),
                &dirListHead
                );

            if (!NT_SUCCESS(status)) {

                break;
            }
        }
    }

    //
    // Each directory that WalkDirectory finds gets added to the list.
    // process the list until we have no more directories.
    //
    while((!IsListEmpty(&dirListHead)) && NT_SUCCESS(status)) {

        pListEntry = RemoveTailList(&dirListHead);

        pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

        status = ScpLastGoodWalkDirectoryTreeHelper(
            &pDirEntry->Directory,
            Flags & ~DIRWALK_TRAVERSE,
            CallbackFunction,
            Context,
            buffer,
            sizeof(buffer),
            &dirNothingHead
            );

        LocalFree(pDirEntry);

        ASSERT(IsListEmpty(&dirNothingHead));
    }

    //
    // Now do any final cleanup.
    //
    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&dirListHead)) {

            pListEntry = RemoveHeadList(&dirListHead);

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            LocalFree(pDirEntry);
        }
    }

    return RtlNtStatusToDosError(status);
}


NTSTATUS
ScpLastGoodWalkDirectoryTreeHelper(
    IN      PUNICODE_STRING  Directory,
    IN      ULONG            Flags,
    IN      DIRWALK_CALLBACK CallbackFunction   OPTIONAL,
    IN      PVOID            Context,
    IN      PUCHAR           Buffer,
    IN      ULONG            BufferSize,
    IN OUT  PLIST_ENTRY      DirList
    )
/*++

Routine Description:

    This is a helper function for the ScLastGoodWalkDirectory*Tree functions.
    Each directory is added to the list for later processing.

Arguments:

    Directory - Supplies the NT Path to the directory to walk.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

    Buffer - A scratch buffer to use.

    BufferSize - The length of Buffer. Must be greater than sizeof(WCHAR).

    DirList - Recieves list of new directories to scan after completion of this
              directory. Each entry is a member of the DIRECTORY_ENTRY
              structure.

Return Value:

    NTSTATUS - status of the operation.

--*/
{
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    BOOLEAN bRestartScan, bIsDotPath;
    WCHAR savedChar;
    PFILE_BOTH_DIR_INFORMATION pFileInfo;
    UNICODE_STRING entryName;
    USHORT newNameLength;
    PDIRWALK_ENTRY pDirEntry;
    ULONG OpenFlags;

    //
    // Setup initial values
    //
    bRestartScan = TRUE;

    //
    //  Open the file for list directory access
    //
    if (Flags & DIRWALK_TRAVERSE_MOUNTPOINTS) {

        OpenFlags = FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT;

    } else {

        OpenFlags = FILE_OPEN_REPARSE_POINT |
                    FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        Directory,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile(
        &fileHandle,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ,
        OpenFlags
        );

    if (!NT_SUCCESS(status)) {

        goto cleanup;
    }

    //
    //  Do the directory loop
    //
    while(1) {

        //
        // We subtract off a WCHAR so that we can append a terminating null as
        // needed.
        //
        ASSERT(BufferSize > sizeof(WCHAR));

        status = NtQueryDirectoryFile(
            fileHandle,
            (HANDLE)NULL,
            (PIO_APC_ROUTINE)NULL,
            (PVOID)NULL,
            &ioStatus,
            Buffer,
            BufferSize - sizeof(WCHAR),
            FileBothDirectoryInformation,
            FALSE,
            (PUNICODE_STRING)NULL,
            bRestartScan
            );

        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // We may come back here. Make sure the file scan doesn't start back
        // over.
        //
        bRestartScan = FALSE;

        //
        // Wait for the event to complete if neccessary.
        //
        if (status == STATUS_PENDING) {

            NtWaitForSingleObject(fileHandle, TRUE, NULL);
            status = ioStatus.Status;

            //
            //  Check the Irp for success
            //
            if (!NT_SUCCESS(status)) {

                break;
            }
        }

        //
        // Walk each returned record. Note that we won't be here if there are
        // no records, as ioStatus will have contains STATUS_NO_MORE_FILES.
        //
        pFileInfo = (PFILE_BOTH_DIR_INFORMATION) Buffer;

        while(1) {

            //
            // Temporarily terminate the file. We allocated an extra WCHAR to
            // make sure we could safely do this.
            //
            savedChar = pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)];
            pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)] = 0;

            //
            // Build a full unicode path for the file along with a directory
            // entry at the same time.
            //
            RtlInitUnicodeString(&entryName, pFileInfo->FileName);

            newNameLength =
                (Directory->Length + entryName.Length + sizeof(WCHAR));

            pDirEntry = (PDIRWALK_ENTRY) LocalAlloc(
                LPTR,
                sizeof(DIRWALK_ENTRY) + newNameLength
                );

            if (pDirEntry == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            pDirEntry->Directory.Length = 0;
            pDirEntry->Directory.MaximumLength = newNameLength;
            pDirEntry->Directory.Buffer = &pDirEntry->Name[0];
            RtlCopyUnicodeString(&pDirEntry->Directory, Directory);
            RtlAppendUnicodeToString(&pDirEntry->Directory, L"\\");
            RtlAppendUnicodeStringToString(&pDirEntry->Directory, &entryName);

            if (pFileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // Check for . and ..
                //
                bIsDotPath = ((!_wcsicmp(pFileInfo->FileName, L".")) ||
                              (!_wcsicmp(pFileInfo->FileName, L"..")));

                if ((Flags & DIRWALK_INCLUDE_DIRECTORIES) &&
                    ((!(Flags & DIRWALK_CULL_DOTPATHS)) || (!bIsDotPath))) {

                    status = CallbackFunction(
                        &pDirEntry->Directory,
                        &entryName,
                        pFileInfo->FileAttributes,
                        Context
                        );
                }

                if ((!bIsDotPath) && (Flags & DIRWALK_TRAVERSE)) {

                    InsertTailList(DirList, &pDirEntry->Link);

                } else {

                    LocalFree(pDirEntry);
                }

            } else {

                if (Flags & DIRWALK_INCLUDE_FILES) {

                    status = CallbackFunction(
                        &pDirEntry->Directory,
                        &entryName,
                        pFileInfo->FileAttributes,
                        Context
                        );
                }

                LocalFree(pDirEntry);
            }

            if (!NT_SUCCESS(status)) {

                break;
            }

            //
            // Put back the character we wrote down. It might have been part of
            // the next entry.
            //
            pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)] = savedChar;

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //
            if (pFileInfo->NextEntryOffset == 0) {

                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //
            pFileInfo = (PFILE_BOTH_DIR_INFORMATION)
                (((PUCHAR) pFileInfo) + pFileInfo->NextEntryOffset);
        }

        if (!NT_SUCCESS(status)) {

            break;
        }
    }

    NtClose( fileHandle );

    if (status == STATUS_NO_MORE_FILES) {

        status = STATUS_SUCCESS;
    }

cleanup:
    return status;
}


NTSTATUS
ScpLastGoodDeleteFiles(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    )
/*++

Routine Description:

    This callback routine is called for each file under the LastGood directory.
    It's job is to delete each such file.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    FILE_DISPOSITION_INFORMATION Disposition;
    ULONG OpenFlags;

    //
    // Remove any attributes that might stop us from deleting this file.
    //
    ScLastGoodClearAttributes(
        FullPathName,
        ( FILE_ATTRIBUTE_READONLY |
          FILE_ATTRIBUTE_HIDDEN |
          FILE_ATTRIBUTE_SYSTEM )
        );

    //
    // Now delete the file.
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        FullPathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );


    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        OpenFlags = FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT |
                    FILE_OPEN_REPARSE_POINT;
    } else {

        OpenFlags = FILE_NON_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT |
                    FILE_OPEN_REPARSE_POINT;
    }

    Status = NtOpenFile(
        &FileHandle,
        DELETE | FILE_READ_ATTRIBUTES,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
        OpenFlags
        );

    if (!NT_SUCCESS(Status)) {

        KdPrintEx((
            DPFLTR_SCSERVER_ID,
            DEBUG_CONFIG_API,
            "SERVICES: Cannot open last known good file: %Zw %x\n",
            FullPathName,
            Status
            ));

        return Status;
    }

    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
        FileHandle,
        &IoStatusBlock,
        &Disposition,
        sizeof(Disposition),
        FileDispositionInformation
        );

    if (!NT_SUCCESS(Status)) {

        KdPrintEx((
            DPFLTR_SCSERVER_ID,
            DEBUG_CONFIG_API,
            "SERVICES: Cannot delete last known good file: %Zw %x\n",
            FullPathName,
            Status
            ));
    }

    NtClose(FileHandle);

    //
    // If we can't delete one file, keep trying to delete the rest.
    //
    return STATUS_SUCCESS;
}


NTSTATUS
ScLastGoodClearAttributes(
    IN PUNICODE_STRING  FullPathName,
    IN ULONG            FileAttributes
    )
/*++

Routine Description:

    This function clears the passed in attributes off the specified file.

Arguments:

    FullPathName - Full path name of the identified file.

    FileAttributes - Attributes to clear.

Return Value:

    NTSTATUS.

--*/
{
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    FILE_BASIC_INFORMATION fileBasicInformation;
    ULONG newAttributes;
    NTSTATUS status;

    //
    // First we open the file.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        FullPathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile(
        &fileHandle,
        FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_FOR_BACKUP_INTENT | FILE_WRITE_THROUGH
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Then we get the file attributes.
    //
    status = NtQueryInformationFile(
        fileHandle,
        &ioStatus,
        &fileBasicInformation,
        sizeof(fileBasicInformation),
        FileBasicInformation
        );

    if (!NT_SUCCESS(status)) {

        NtClose(fileHandle);
        return status;
    }

    //
    // Anything to do?
    //
    if (fileBasicInformation.FileAttributes & FileAttributes) {

        //
        // Clear the specified bits.
        //
        newAttributes = fileBasicInformation.FileAttributes;
        newAttributes &= ~FileAttributes;
        if (newAttributes == 0) {

            newAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        //
        // Zero fields that shouldn't be touched.
        //
        RtlZeroMemory(
            &fileBasicInformation,
            sizeof(FILE_BASIC_INFORMATION)
            );

        fileBasicInformation.FileAttributes = newAttributes;

        //
        // Commit the changes.
        //
        status = NtSetInformationFile(
            fileHandle,
            &ioStatus,
            &fileBasicInformation,
            sizeof(fileBasicInformation),
            FileBasicInformation
            );
    }

    NtClose(fileHandle);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\services.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    SERVICES.CXX

Abstract:

    This is the main routine for the Win32 Service Controller and
    Registry (Screg) RPC server process.

Author:

    Dan Lafferty (danl) 25-Oct-1993

Modification History:

--*/

#include "precomp.hxx"
#include <ntrpcp.h>


extern "C"
int __cdecl
main (
    int     argc,
    PCHAR   argv[]
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    //
    //  Initialize the RPC server
    //

    if (NT_SUCCESS(RpcpInitRpcServer()))
    {
        SvcctrlMain(argc, argv);
    }

    //
    //  We should never get here!
    //
    ASSERT( FALSE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\smartp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    smartp.h

Abstract:

    Safe pointer classes

Author:

    Anirudh Sahni (anirudhs)    21-Oct-1996

Environment:

    User Mode -Win32

Revision History:

    21-Oct-1996     AnirudhS
        Created.


--*/

#ifndef SMARTP_H
#define SMARTP_H

//
// Template pointer class that automatically calls LocalFree when it goes
// out of scope
// T is a pointer type, like LPWSTR or LPVOID, that can be initialized to NULL
//

template <class T>
class CHeapPtr
{
public:
    CHeapPtr() : _p(NULL) { }
   ~CHeapPtr() { LocalFree(_p); }

    operator T()        { return _p; }
    T operator*()       { return *_p; }
    T * operator& ()    { return &_p; }

private:
    T   _p;
};


#endif // def SMARTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\start.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    start.h

Abstract:

    Service start function prototypes.

Author:

    Rita Wong (ritaw)     06-Apr-1992

Revision History:

--*/

#ifndef SCSTART_INCLUDED
#define SCSTART_INCLUDED

//
// Function Prototypes
//

DWORD
ScStartService(
    IN LPSERVICE_RECORD ServiceRecord,
    IN  DWORD               NumArgs,
    IN  LPSTRING_PTRSW      CmdArgs
    );

BOOL
ScAllowInteractiveServices(
    VOID
    );

VOID
ScInitStartupInfo(
    OUT LPSTARTUPINFOW  StartupInfo,
    IN  BOOL            bInteractive
    );

#endif // #ifndef SCSTART_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\start.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    start.cxx

Abstract:

    Contains functions that are required for starting a service.
        RStartServiceW
        StartImage
        InitStartImage
        ScInitStartupInfo
        EndStartImage
        ScAllowInteractiveServices

Author:

    Dan Lafferty (danl)     20-Jan-1992

Environment:

    User Mode - Calls Win32 and NT native APIs.


Revision History:

    13-Mar-199  jschwart
        Use CreateProcessAsUserW for non-LocalSystem services

    06-Apr-1998 jschwart
        Change check for Security Process connection -- check to see if
        the service being started runs in the process, not if it's NetLogon.
        Also clean up WesW from 12-Dec-1997

    10-Mar-1998 jschwart
        Allow services to receive control messages for Plug-and-Play events

    12-Dec-1997 WesW
        Added support for safe boot

    22-Oct-1997 jschwart
        Enable 12-Apr-1995 change for non-_CAIRO_.

    08-Jan-1997 AnirudhS
        Fixed miscellaneous synchronization bugs found by new locking
        scheme.

    09-Dec-1996 AnirudhS
        Added ScInitStartupInfo and ScAllowInteractiveServices, also used
        by crash.cxx

    01-Mar-1996 AnirudhS
        ScStartImage: Notify the PNP manager when a service is started.

    12-Apr-1995 AnirudhS
        Allow services that run under accounts other than LocalSystem to
        share processes too.
        (_CAIRO_ only)

    21-Feb-1995 AnirudhS
        Since CreateProcess now handles quoted exe pathnames, removed the
        (buggy) code that had been added to parse them, including
        ScParseImagePath.

    08-Sep-1994 Danl
        ScLogonAndStartImage:  Close the Duplicate token when we are done
        with it.  This allows logoff notification when the service process
        exits.

    30-Aug-1994 Danl
        ScParseImagePath:  Added this function to look for quotes around the
        pathname.  The Quotes may be necessary if the path contains a space
        character.

    18-Mar-1994 Danl
        ScLogonAndStartImage:  When starting a service in an account, we now
        Impersonate using a duplicate of the token for the service, prior
        to calling CreateProcess.  This allows us to load executables
        whose binaries reside on a remote server.

    20-Oct-1993 Danl
        ScStartService:  If the NetLogon Service isn't in our database yet,
        then we want to check to see if the service to be started is
        NetLogon.  If it is then we need to init our connection with the
        Security Process.

    17-Feb-1993     danl
        Must release the database lock around the CreateProcess call so
        that dll init routines can call OpenService.

    12-Feb-1993     danl
        Move the incrementing of the Service UseCount to
        ScActivateServiceRecord.  This is because if we fail beyond this
        point, we call ScRemoveService to cleanup - but that assumes the
        UseCount has already been incremented one for the service itself.

    25-Apr-1992     ritaw
        Changed ScStartImage to ScLogonAndStartImage

    20-Jan-1992     danl
        created


--*/

//
// Includes
//

#include "precomp.hxx"
extern "C" {
#include <winuserp.h>   // STARTF_DESKTOPINHERIT
#include <cfgmgr32.h>   // PNP manager functions
#include <pnp.h>        // PNP manager functions, server side
#include <cfgmgrp.h>    // PNP manager functions, server side, internal
#include <userenv.h>    // UnloadUserProfile
}
#include <stdlib.h>      // wide character c runtimes.

#include <tstr.h>       // Unicode string macros

#include <scconfig.h>   // ScGetImageFileName
#include <control.h>
#include <scseclib.h>   // ScCreateAndSetSD
#include <svcslib.h>    // SvcStartLocalDispatcher
#include <valid.h>      // MAX_SERVICE_NAME_LENGTH
#include "depend.h"     // ScStartMarkedServices
#include "driver.h"     // ScLoadDeviceDriver
#include "account.h"    // ScLogonService
#include "start.h"      // ScStartService


//
// STATIC DATA
//

    CRITICAL_SECTION     ScStartImageCriticalSection;
    const LPWSTR         pszInteractiveDesktop=L"WinSta0\\Default";

//
// LOCAL FUNCTIONS
//

DWORD
ScLogonAndStartImage(
    IN  LPSERVICE_RECORD ServiceRecord,
    IN  LPWSTR           ImageName,
    OUT LPIMAGE_RECORD   *ImageRecordPtr
    );

VOID
ScProcessHandleIsSignaled(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    );

BOOL
ScEqualAccountName(
    IN LPWSTR Account1,
    IN LPWSTR Account2
    );


DWORD
RStartServiceW(
    IN  SC_RPC_HANDLE       hService,
    IN  DWORD               NumArgs,
    IN  LPSTRING_PTRSW      CmdArgs
    )

/*++

Routine Description:

    This function begins the execution of a service.

Arguments:

    hService - A handle which is a pointer to a service handle structure.

    dwNumServiceArgs - This indicates the number of argument vectors.

    lpServiceArgVectors - This is a pointer to an array of string pointers.

Return Value:

    NO_ERROR - The operation was completely successful.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_START access.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_SERVICE_WAS_STARTED - An instance of the service is already running.

    ERROR_SERVICE_REQUEST_TIMEOUT - The service did not respond to the start
        request in a timely fashion.

    ERROR_SERVICE_NO_THREAD - A thread could not be created for the Win32
        service.

    ERROR_PATH_NOT_FOUND - The image file name could not be found in
        the configuration database (registry), or the image file name
        failed in a unicode/ansi conversion.



--*/
{
    DWORD status;
    DWORD i;
    LPWSTR *CmdArray;
    LPSERVICE_RECORD serviceRecord;

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Validate the CmdArgs
    //

    if (NumArgs != 0)
    {
        if (CmdArgs == NULL)
        {
            SC_LOG0(ERROR, "RStartServiceW: NULL CmdArgs with non-zero NumArgs!\n");
            return ERROR_INVALID_PARAMETER;
        }

        CmdArray = (LPWSTR *) CmdArgs;

        for (i = 0; i < NumArgs; i++)
        {
            if (CmdArray[i] == NULL)
            {
                SC_LOG1(ERROR, "RStartServiceW: CmdArray[%d] NULL!\n", i);
                return ERROR_INVALID_PARAMETER;
            }
        }
    }

    //
    // Was the handle opened with SERVICE_START access?
    //
    if (! RtlAreAllAccessesGranted(
              ((LPSC_HANDLE_STRUCT)hService)->AccessGranted,
              SERVICE_START
              )) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // A word about Locks....
    // We don't bother to get locks here because (1) We know the service
    // record cannot go away because we have an open handle to it,
    // (2) For these checks, we don't care if state changes after we
    // check them.
    //
    // (ScStartServiceAndDependencies also performs these checks; they are
    // repeated here so we can fail quickly in these 2 cases.)
    //
    serviceRecord =
        ((LPSC_HANDLE_STRUCT)hService)->Type.ScServiceObject.ServiceRecord;

    //
    // We can never start a disabled service
    //
    if (serviceRecord->StartType == SERVICE_DISABLED) {
        return ERROR_SERVICE_DISABLED;
    }

    //
    // Cannot start a deleted service.
    //
    if (DELETE_FLAG_IS_SET(serviceRecord)) {
        return ERROR_SERVICE_MARKED_FOR_DELETE;
    }

    status = ScStartServiceAndDependencies(serviceRecord, NumArgs, CmdArgs, FALSE);

    if (status == NO_ERROR)
    {
        if (serviceRecord->StartError == NO_ERROR)
        {
            //
            // Log successful service start.  0 is for a start "control"
            // since there's actually no such SERVICE_CONTROL_* constant.
            //

            ScLogControlEvent(NEVENT_SERVICE_CONTROL_SUCCESS,
                              serviceRecord->DisplayName,
                              0);
        }

        return serviceRecord->StartError;
    }
    else
    {
        //
        // Start failure was logged by ScStartServiceAndDependencies
        //

        return status;
    }
}


DWORD
ScStartService(
    IN  LPSERVICE_RECORD    ServiceRecord,
    IN  DWORD               NumArgs,
    IN  LPSTRING_PTRSW      CmdArgs
    )
/*++

Routine Description:

    This function starts a service.  This code is split from the RStartServiceW
    so that the service controller internal code can bypass RPC and security
    checking when auto-starting services and their dependencies.

Arguments:

    ServiceRecord - This is a pointer to the service record.

    NumArgs - This indicates the number of argument vectors.

    CmdArgs - This is a pointer to an array of string pointers.

Return Value:

    NO_ERROR - The operation was completely successful.

    ERROR_ACCESS_DENIED - The specified handle was not opened with
        SERVICE_START access.

    ERROR_INVALID_HANDLE - The specified handle was invalid.

    ERROR_SERVICE_WAS_STARTED - An instance of the service is already running.

    ERROR_SERVICE_REQUEST_TIMEOUT - The service did not respond to the start
        request in a timely fashion.

    ERROR_SERVICE_NO_THREAD - A thread could not be created for the Win32
        service.

    ERROR_PATH_NOT_FOUND - The image file name could not be found in
        the configuration database (registry), or the image file name
        failed in a Unicode/Ansi conversion.

    ERROR_NOT_SAFEBOOT_SERVICE - This service isn't startable during Safeboot.

--*/
{
    DWORD               status;
    LPWSTR              ImageName   = NULL;
    LPIMAGE_RECORD      ImageRecord = NULL;
    LPWSTR              serviceName;
    LPWSTR              displayName;
    HANDLE              pipeHandle;
    DWORD               startControl;

    //
    // Check for Safeboot
    //
    if (g_dwSafebootLen != 0 && g_SafeBootEnabled != SAFEBOOT_DSREPAIR) {

        HKEY  hKeySafeBoot;

        //
        // If this ever fails, g_szSafebootKey must be made larger
        //
        SC_ASSERT(g_dwSafebootLen + wcslen(ServiceRecord->ServiceName)
                      < SAFEBOOT_KEY_LENGTH + MAX_SERVICE_NAME_LENGTH + 50 + 1);

        wcscpy(g_szSafebootKey + g_dwSafebootLen, ServiceRecord->ServiceName);

        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              g_szSafebootKey,
                              0,
                              KEY_READ,
                              &hKeySafeBoot);

        if (status != NO_ERROR) {
            SC_LOG1(ERROR, "SAFEBOOT: service skipped = %ws\n",
                    ServiceRecord->ServiceName);

            return ERROR_NOT_SAFEBOOT_SERVICE;
        }

        RegCloseKey(hKeySafeBoot);
    }

    //  NOTE:  Only one thread at a time should be in this part of the code.
    //  This prevents two images from getting started as could happen if
    //  two threads get the Image Record at virtually the same time.  In
    //  this case, they might both decide to start the same image.
    //
    //  We need to do this before the check for the CurrentState.  Otherwise,
    //  two threads could race down to start the same service, and they
    //  would both attempt to start it.  We would end up with either
    //  two service images running, or two threads of the same service
    //  running in a single image.
    //

    EnterCriticalSection(&ScStartImageCriticalSection);

    SC_LOG0(LOCKS,"RStartServiceW: Entering StartImage Critical Section.....\n");

    //
    // We need to gain exclusive access to the database so that we may
    // Read the database and make decisions based on its content.
    //
    {
        CServiceRecordExclusiveLock RLock;

#ifdef TIMING_TEST
        DbgPrint("[SC_TIMING] Start Next Service TickCount for\t%ws\t%d\n",
            ServiceRecord->ServiceName, GetTickCount());
#endif // TIMING_TEST

        //
        // Check to see if the service is already running.
        //
        if (ServiceRecord->ServiceStatus.dwCurrentState != SERVICE_STOPPED){
            SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section....\n",0);
            LeaveCriticalSection(&ScStartImageCriticalSection);
            return(ERROR_SERVICE_ALREADY_RUNNING);
        }

        //
        // If we are loading a driver, load it and return.
        // WARNING: ScLoadDeviceDriver releases and reacquires the RecordLock.
        //
        if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_DRIVER) {
            status = ScLoadDeviceDriver(ServiceRecord);
            LeaveCriticalSection(&ScStartImageCriticalSection);
            return(status);
        }

        //
        // Get the image record information out of the configuration database.
        //
        status = ScGetImageFileName(ServiceRecord->ServiceName, &ImageName);

        if (status != NO_ERROR) {
            SC_LOG(ERROR,"GetImageFileName failed rc = %d\n",status);
            SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section....\n",0);
            LeaveCriticalSection(&ScStartImageCriticalSection);
            return status;
        }

        if (ImageName == NULL) {
            SC_LOG0(ERROR,"GetImageFileName returned a NULL pointer\n");
            SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section....\n",0);
            LeaveCriticalSection(&ScStartImageCriticalSection);
            return ERROR_PATH_NOT_FOUND;
        }

        //
        // If the LSA hasn't been started yet, see if this service runs
        // inside of it and if so, initialize it.
        //
        // Even if ScInitSecurityProcess fails, we will set the global
        // flag since we will not attempt to connect again.
        //

        if (!ScConnectedToSecProc)
        {
            if (_wcsicmp(ScGlobalSecurityExePath, ImageName) == 0)
            {
                if (!ScInitSecurityProcess(ServiceRecord))
                {
                    SC_LOG0(ERROR, "ScInitSecurityProcess Failed\n");
                }

                ScConnectedToSecProc = TRUE;
            }
        }

        //
        // Make the service record active.
        // Because the service effectively has a handle to itself, the
        // UseCount gets incremented inside ScActivateServiceRecord() when
        // called with a NULL ImageRecord pointer.
        //
        // We need to do this here because when we get to ScLogonAndStartImage,
        // we have to release the database lock around the CreateProcess call.
        // Since we open ourselves up to DeleteService and Control Service calls,
        // We need to increment the use count, and set the START_PENDING status
        // here.
        //
        ScActivateServiceRecord(ServiceRecord, NULL);

        //
        // Is the image file for that service already running?
        // If not, call StartImage.
        //
        // If the Image Record was NOT found in the database OR if the service
        // wants to share a process and there is no shareable version of the
        // Image Record, then start the image file.
        //
        if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32_SHARE_PROCESS) {
            ScGetNamedImageRecord(ImageName,&ImageRecord);
        }

        // CODEWORK - may not need to release the lock here in all cases.
    } // Release RLock

    if (ImageRecord != NULL)
    {
        //
        // The service is configured to share its process with other services,
        // and the image for the service is already running.  So we don't need
        // to start a new instance of the image.
        //
        // We do need to check that the account for the service is the same
        // as the one that the image was started under, and that the password
        // is valid.
        //

        LPWSTR AccountName = NULL;

        status = ScLookupServiceAccount(
                    ServiceRecord->ServiceName,
                    &AccountName
                    );

        if (status == NO_ERROR)
        {
            if (!ScEqualAccountName(AccountName, ImageRecord->AccountName))
            {
                status = ERROR_DIFFERENT_SERVICE_ACCOUNT;

                SC_LOG3(ERROR,
                        "Can't start %ws service in account %ws because "
                            "image is already running under account %ws\n",
                        ServiceRecord->ServiceName,
                        AccountName,
                        ImageRecord->AccountName
                        );
            }
        }

        //
        // If the account is not LocalSystem, validate the password by
        // logging on the service
        //

        if (status == NO_ERROR && AccountName != NULL)
        {
            HANDLE ServiceToken = NULL;
            PSID   ServiceSid = NULL;

            status = ScLogonService(
                         ServiceRecord->ServiceName,
                         AccountName,
                         &ServiceToken,
                         NULL,      // Don't need to load the user profile again
                         &ServiceSid);

            if (status == NO_ERROR)
            {
                CloseHandle(ServiceToken);
                LocalFree(ServiceSid);
            }

            LocalFree(AccountName);
        }
    }
    else
    {
        //
        // Start a new instance of the image
        //
        SC_LOG(TRACE,"Start: calling StartImage\n",0);
        status = ScLogonAndStartImage(
                    ServiceRecord,
                    ImageName,
                    &ImageRecord
                    );

        if (status != NO_ERROR) {
            SC_LOG(TRACE,"Start: StartImage failed!\n",0);
        }
    }

    LocalFree( ImageName );

    if (status != NO_ERROR) {

        //
        // Deactivate the service record.
        //
        CServiceRecordExclusiveLock RLock;
        (void)ScDeactivateServiceRecord(ServiceRecord);

        SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section........\n",0);
        LeaveCriticalSection(&ScStartImageCriticalSection);

        return(status);
    }

    //
    // Before leaving the StartImage critical section, we need to gain
    // exclusive access to the database so that we may add the image record
    // pointer to the service record. (ActivateServiceRecord).
    //
    {
        CServiceRecordExclusiveLock RLock;

        //
        // By the time we get here, the Service Process will already be
        // running and ready to accept its first control request.
        //

        //
        // Add the ImageRecord Information to the active service record.
        //
        // Note that, as soon as we activate the service record and release
        // the lock, we open ourselves up to receiving control requests.
        // However, ScActivateServiceRecord sets the ControlsAccepted field
        // to 0, so that the service cannot accept any controls.  Thus, until
        // the service actually sends its own status, the service controller
        // will reject any controls other than INTERROGATE.
        //
        // Because the service effectively has a handle to itself, the
        // UseCount gets incremented inside ScActivateServiceRecord().
        //
        ScActivateServiceRecord(ServiceRecord,ImageRecord);

        pipeHandle  = ServiceRecord->ImageRecord->PipeHandle;
        serviceName = ServiceRecord->ServiceName;
        displayName = ServiceRecord->DisplayName;
    }

    SC_LOG(LOCKS,"RStartServiceW: Leaving StartImage Critical Section........\n",0);
    LeaveCriticalSection(&ScStartImageCriticalSection);

    //
    // Start the Service
    //

    if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32_OWN_PROCESS) {
        startControl = SERVICE_CONTROL_START_OWN;
    }
    else {
        startControl = SERVICE_CONTROL_START_SHARE;
    }


    CONTROL_ARGS ControlArgs;

    ControlArgs.CmdArgs = (LPWSTR *)CmdArgs;

    status = ScSendControl (
                serviceName,                               // ServiceName
                displayName,                               // DisplayName
                pipeHandle,                                // pipeHandle
                startControl,                              // Opcode
                &ControlArgs,                              // Union holding command-line args
                NumArgs,                                   // NumArgs
                NULL);                                     // Ignore handler return value

    if (status != NO_ERROR) {
        //
        // If an error occured, remove the service by de-activating the
        // service record and terminating the service process if it is
        // the only one running in the process.
        //
        SC_LOG2(ERROR,"Start: SendControl to %ws service failed! status=%ld\n",
                serviceName, status);

        //
        // NOTE: Because ScRemoveService will expect the use count
        //  to already be incremented (for the service's own handle),
        //  it is necessary to increment that use count prior to
        //  removing it.
        //

        ScRemoveService(ServiceRecord);
    }
    else
    {
        //
        // Notify the PNP manager that the service was started.
        // The PNP manager uses this information to resolve ambiguities in
        // reconfiguration scenarios where there could temporarily be more
        // than one controlling service for a device.  It remembers the last
        // service started for each device, and marks it as the "active"
        // service for the device in the registry.
        // We don't need to do this for drivers, because NtLoadDriver itself
        // notifies the PNP manager.
        //
        CONFIGRET PnpStatus = PNP_SetActiveService(
                                    NULL,               // hBinding
                                    serviceName,        // pszService
                                    PNP_SERVICE_STARTED // ulFlags
                                    );
        if (PnpStatus != CR_SUCCESS)
        {
            SC_LOG2(ERROR, "PNP_SetActiveService failed %#lx for service %ws\n",
                           PnpStatus, serviceName);
        }
    }

    return status;
}


/****************************************************************************/
DWORD
ScLogonAndStartImage(
    IN  LPSERVICE_RECORD ServiceRecord,
    IN  LPWSTR          ImageName,
    OUT LPIMAGE_RECORD  *ImageRecordPtr
    )

/*++

Routine Description:

    This function is called when the first service in an instance of an
    image needs to be started.

    This function creates a pipe instance for control messages and invokes
    the executable image.  It then waits for the new process to connect
    to the control data pipe.  An image Record is created with the
    above information by calling CreateImageRecord.

Arguments:

    ImageName - This is the name of the image file that is to be started.
        This is expected to be a fully qualified path name.

    ImageRecordPtr - This is a location where the pointer to the new
        Image Record is returned.

Return Value:

    NO_ERROR - The operation was successful.  It any other return value
        is returned, a pipe instance will not be created, a process will
        not be started, and an image record will not be created.

    ERROR_NOT_ENOUGH_MEMORY - Unable to allocate buffer for the image record.

    other - Any error returned by the following could be returned:
                CreateNamedPipe
                ConnectNamedPipe
                CreateProcess
                ScCreateControlInstance
                ScLogonService

Note:
    LOCKS:
        The Database Lock is not held when this function is called.

    CODEWORK: This function badly needs to use C++ destructors for safe
    cleanup in error conditions.

--*/

{
    PROCESS_INFORMATION     processInfo          = { 0, 0, 0, 0 };
    DWORD                   servicePID;
    DWORD                   dwServiceID;
    HANDLE                  pipeHandle           = NULL;
    DWORD                   status;
    BOOL                    runningInThisProcess = FALSE;
    HANDLE                  ServiceToken         = NULL;
    HANDLE                  ProfileHandle        = NULL;
    LPWSTR                  AccountName          = NULL;
    DWORD                   ImageFlags           = 0;
    PSID                    ServiceSid           = LocalSystemSid;
    LPVOID                  Environment          = NULL;
    BOOL                    fLoadedEnv           = FALSE;
    BOOL                    fUseRtlDestroyEnv    = FALSE;

    SC_ASSERT(! ScServiceRecordLock.Have());

    //
    // IMPORTANT:
    // Only one thread at a time should be allowed to execute this
    // code.
    //

    //
    // Lookup the account that the service is to be started under.
    // An AccountName of NULL means the LocalSystem account.
    //
    status = ScLookupServiceAccount(
                ServiceRecord->ServiceName,
                &AccountName
                );

    if (status != NO_ERROR) {
        return status;
    }

    //
    // get the environment for the target service account
    //
    if ( AccountName != NULL ) {

        //*******************************************************************
        // Service has a specific Account associated with it
        //*******************************************************************

        //
        // Get service token, to be assigned into the service process,
        // by logging on the service
        //

        status = ScLogonService(
                     ServiceRecord->ServiceName,
                     AccountName,
                     &ServiceToken,
                     &ProfileHandle,
                     &ServiceSid
                     );

        if (status != NO_ERROR) {
            LocalFree(AccountName);
            return status;
        }

        //
        // Get the environment for this user.
        //
        fLoadedEnv = CreateEnvironmentBlock(&Environment,
                                            ServiceToken,
                                            FALSE);

    }
    else {
        //*******************************************************************
        // Service to run with the LocalSystem account
        //*******************************************************************
        NTSTATUS    ntstatus;

        ntstatus = RtlCreateEnvironment( TRUE,      // clone environment
                                         &Environment);

        if ( NT_SUCCESS( ntstatus )) {
            fLoadedEnv = TRUE;
            fUseRtlDestroyEnv = TRUE;
        }
        else
        {
            SC_LOG(ERROR,
                   "ScLogonAndStartImage: RtlCreateEnvironment FAILED %08X\n",
                   ntstatus);
        }

#if 0
        //
        // we need LocalSystem's token to get its environment. If a Service
        // that runs with LocalSystem is under cluster service control, then
        // there is still a possibility that LocalSystem's environment needs
        // to be merged with a cluster specified environment.
        //
        ServiceToken = g_hProcessToken;
#endif
    }

    if (fLoadedEnv) {
        //
        // See if the Service has additional environment variables that
        // need to be merged into the user's environment.
        //
        status = ScMergeEnvironments(ServiceRecord->ServiceName, &Environment);

        if (status != NO_ERROR) {
            if ( status != ERROR_FILE_NOT_FOUND ) {
                SC_LOG(ERROR,
                       "ScLogonAndStartImage: ScMergeEnvironments FAILED %d\n",
                       status);

                goto ExitAccountError;
            }

            //
            // If there is no environment to be merged, continue using
            // just the standard environment.
            //
            status = NO_ERROR;
        }
    }
    else {
        SC_LOG(ERROR,
               "ScLogonAndStartImage: CreateEnvironmentBlock FAILED %d\n",
               GetLastError());
        Environment = NULL;
    }

#if 0
    //
    // if the Service is running as LocalSystem, then clear the "reference" to
    // the SCM's process token. The rest of this code path and its called
    // functions assume that if the token handle is NULL, then the Service is
    // running in the context of LocalSystem.
    //
    if ( ServiceToken == g_hProcessToken ) {
        ServiceToken = NULL;
    }
#endif

    if (AccountName != NULL) {

        //*******************************************************************
        // Start Service in an Account
        //*******************************************************************

        //
        // A token can be created via service logon, if the service
        // account name is not LocalSystem.  Assign this token into
        // the service process.
        //

        NTSTATUS                ntstatus;
        SECURITY_ATTRIBUTES     SaProcess;
        PSECURITY_DESCRIPTOR    SecurityDescriptor;

#define SC_PROCESSSD_ACECOUNT 2

        SC_ACE_DATA AceData[SC_PROCESSSD_ACECOUNT] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   PROCESS_ALL_ACCESS,
                   0},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   PROCESS_SET_INFORMATION |
                       PROCESS_TERMINATE |
                       SYNCHRONIZE,
                   &LocalSystemSid}
            };

        //
        // Fill pointer in AceData structure with ServiceSid we just
        // got back.
        //
        AceData[0].Sid = &ServiceSid;

        //
        // Create a security descriptor for the process we are about
        // to create
        //
        ntstatus = ScCreateAndSetSD(
                       AceData,                 // AceData
                       SC_PROCESSSD_ACECOUNT,   // AceCount
                       NULL,                    // OwnerSid (optional)
                       NULL,                    // GroupSid (optional)
                       &SecurityDescriptor      // pNewDescriptor
                       );

#undef SC_PROCESSSD_ACECOUNT

        if (! NT_SUCCESS(ntstatus)) {

            SC_LOG1(ERROR, "ScCreateAndSetSD failed " FORMAT_NTSTATUS
                    "\n", ntstatus);

            status = RtlNtStatusToDosError(ntstatus);
            goto ExitAccountError;
        }

        //
        // Initialize process security info
        //
        SaProcess.nLength = sizeof(SECURITY_ATTRIBUTES);
        SaProcess.lpSecurityDescriptor = SecurityDescriptor;
        SaProcess.bInheritHandle = FALSE;

        //
        // Set the flags that prevent the service from interacting
        // with the desktop
        //
        STARTUPINFOW StartupInfo;
        ScInitStartupInfo(&StartupInfo, FALSE);

        //
        // Impersonate the user so we don't give access to
        // EXEs that have been locked down for the account.
        //
        if (!ImpersonateLoggedOnUser(ServiceToken))
        {
            status = GetLastError();

            SC_LOG1(ERROR,
                    "ScLogonAndStartImage:  ImpersonateLoggedOnUser failed %d\n",
                    status);

            RtlDeleteSecurityObject(&SecurityDescriptor);

            goto ExitAccountError;
        }

        //
        // Create the process in suspended mode to set the token
        // into the process.
        //
        // Note: If someone tries to start a service in a user account
        // with an image name of services.exe, a second instance of
        // services.exe will start, but will exit because it won't be
        // able to open the start event with write access (see
        // ScGetStartEvent).
        //
        if (!CreateProcessAsUserW (
                ServiceToken,   // Token representing logged-on user
                NULL,           // Fully qualified image name
                ImageName,      // Command Line
                &SaProcess,     // Process Attributes
                NULL,           // Thread Attributes
                FALSE,          // Inherit Handles
                DETACHED_PROCESS |
                    CREATE_UNICODE_ENVIRONMENT |
                    CREATE_SUSPENDED, // Creation Flags
                Environment,    // Pointer to Environment block
                NULL,           // Pointer to Current Directory
                &StartupInfo,   // Startup Info
                &processInfo))  // ProcessInformation
        {
            status = GetLastError();
        }

        //
        // Stop impersonating
        //
        RevertToSelf();

        RtlDeleteSecurityObject(&SecurityDescriptor);

        if (status != NO_ERROR) {

            SC_LOG2(ERROR,
                "LogonAndStartImage: CreateProcessAsUser %ws failed " FORMAT_DWORD "\n",
                 ImageName, status);

            goto ExitAccountError;
        }

        SC_LOG1(ACCOUNT, "LogonAndStartImage: Service " FORMAT_LPWSTR
            " was spawned to run in an account\n", ServiceRecord->ServiceName);

        //*******************************************************************
        // End of Service In Account Stuff.
        //*******************************************************************
    }
    else
    {
        //-----------------------------------------------
        // Service to run with the LocalSystem account.
        //-----------------------------------------------

        BOOL bInteractive = FALSE;

        if (_wcsicmp(ImageName, ScGlobalThisExePath) == 0)
        {
            processInfo.hProcess = NULL;
            processInfo.dwProcessId = GetCurrentProcessId();
            runningInThisProcess = TRUE;
        }
        else
        {
            //
            // The service is to run in some other image.
            //
            // If the service is to run interactively, check the flag in the
            // registry to see if this system is to allow interactive services.
            //
            if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_INTERACTIVE_PROCESS) {

                bInteractive = ScAllowInteractiveServices();

                if (!bInteractive)
                {
                    //
                    // Write an event to indicate that an interactive service
                    // was started, but the system is configured to not allow
                    // services to be interactive.
                    //

                    ScLogEvent(NEVENT_SERVICE_NOT_INTERACTIVE,
                               ServiceRecord->DisplayName);
                }
            }

            //
            // If the process is to be interactive, set the appropriate flags.
            //
            STARTUPINFOW StartupInfo;
            ScInitStartupInfo(&StartupInfo, bInteractive);

            //
            // Spawn the Image Process
            //

            SC_LOG0(TRACE,"LogonAndStartImage: about to spawn a Service Process\n");

            if (!CreateProcessW (
                    NULL,           // Fully qualified image name
                    ImageName,      // Command Line
                    NULL,           // Process Attributes
                    NULL,           // Thread Attributes
                    FALSE,          // Inherit Handles
                    DETACHED_PROCESS |  
                        CREATE_UNICODE_ENVIRONMENT |
                        CREATE_SUSPENDED, // Creation Flags
                    Environment,    // Pointer to Environment block
                    NULL,           // Pointer to Current Directory
                    &StartupInfo,   // Startup Info
                    &processInfo))  // ProcessInformation
            {
                status = GetLastError();
                SC_LOG2(ERROR,
                    "LogonAndStartImage: CreateProcess %ws failed %d \n",
                        ImageName,
                        status);

                goto ExitAccountError;
            }

            SC_LOG1(ACCOUNT, "LogonAndStartImage: Service " FORMAT_LPWSTR
                    " was spawned to run as LocalSystem\n", ServiceRecord->ServiceName);
        }
        //-----------------------------------------------
        // End of LocalSystem account stuff
        //-----------------------------------------------
    }

    //
    // Create an instance of the control pipe.  If a malicious process
    // has already created a pipe by this name, the CreateNamedPipe
    // call in ScCreateControlInstance will return ERROR_ACCESS_DENIED.
    // Since that error should never come back otherwise, keep trying
    // new pipe names until we stop getting that error.
    //

    do
    {
        //
        // Write the service's ID to the registry
        //
        status = ScWriteCurrentServiceValue(&dwServiceID);

        if (status != NO_ERROR)
        {
            goto ExitAccountError;
        }

        status = ScCreateControlInstance(&pipeHandle,
                                         dwServiceID,
                                         ServiceSid);
    }
    while (status == ERROR_ACCESS_DENIED);

    if (status != NO_ERROR)
    {
        SC_LOG(ERROR,"LogonAndStartImage: CreateControlInstance Failure\n",0);
        goto ExitAccountError;
    }

    if (runningInThisProcess)
    {
        //
        // The service is to run in this image (services.exe).
        // Since this is the first service to be started in this image,
        // we need to start the local dispatcher.
        //

        status = SvcStartLocalDispatcher();

        if (status != NO_ERROR)
        {
            SC_LOG1(ERROR,
                    "LogonAndStartImage: SvcStartLocalDispatcher failed %d",
                    status);

            goto ExitAccountError;
        }
    }
    else
    {
        //
        // Let the suspended process run.
        //

        ResumeThread(processInfo.hThread);
    }

    status = ScWaitForConnect(pipeHandle,
                              processInfo.hProcess,
                              ServiceRecord->DisplayName,
                              &servicePID);

    if (status != NO_ERROR)
    {
        SC_LOG0(ERROR,
            "LogonAndStartImage: Failed to connect to pipe - Terminating the Process...\n");

        goto ExitAccountError;
    }

    //
    // The client managed to connect on the correct PID-named pipe, so
    // the PID it's reporting should be the same as what we think it is.
    // Note that a mismatch is OK if the service is being run under the
    // debugger, though it may be due to a random EXE in the same account
    // as the service calling StartServiceCtrlDispatcher to see if it's
    // being launched as a service or as an app (yes, this has actually
    // happened).  As a result, log a warning and update the PID we're
    // about to put in the service record with the actual PID of the
    // service process.
    //

    if (processInfo.dwProcessId != servicePID)
    {
        SC_LOG2(ERROR,
                "LogonAndStartImage: PID mismatch - started process %d, process %d connected\n",
                processInfo.dwProcessId, 
                servicePID);

        ScLogEvent(NEVENT_SERVICE_DIFFERENT_PID_CONNECTED,
                   ServiceRecord->DisplayName,
                   processInfo.dwProcessId,
                   servicePID);

        processInfo.dwProcessId = servicePID;
    }

    //
    // If it's a shared-process service, put this information into the Image Record
    //
    if (ServiceRecord->ServiceStatus.dwServiceType & SERVICE_WIN32_SHARE_PROCESS)
    {
        ImageFlags |= CANSHARE_FLAG;
    }

    status = ScCreateImageRecord (
                ImageRecordPtr,
                ImageName,
                AccountName,
                processInfo.dwProcessId,
                pipeHandle,
                processInfo.hProcess,
                ServiceToken,
                ProfileHandle,
                ImageFlags);

    if (status != NO_ERROR) {
        SC_LOG0(ERROR,
            "LogonAndStartImage: Failed to create imageRecord - Terminating the Process...\n");
        goto ExitAccountError;
    }

    //
    // If the dispatcher is running in this process, then we want to
    // increment the service count an extra time so that the dispatcher
    // never goes away.  Also, we don't really have a process handle for
    // the watcher to wait on.
    // It could wait on the ThreadHandle, but handling that when it becomes
    // signaled becomes a special case.  So we won't try that.
    //
    if (runningInThisProcess)
    {
        (*ImageRecordPtr)->ServiceCount = 1;
        (*ImageRecordPtr)->ImageFlags  |= IS_SYSTEM_SERVICE;
    }
    else
    {
        HANDLE   hWaitObject = NULL;
        NTSTATUS ntStatus;

        CloseHandle(processInfo.hThread);

        //
        // Add the process handle as a handle to wait on.
        // Retain the WaitObject handle for when we shut down
        // the process because all the services stopped.
        //

        ntStatus = RtlRegisterWait(&hWaitObject,
                                   processInfo.hProcess,
                                   ScProcessHandleIsSignaled,
                                   processInfo.hProcess,
                                   INFINITE,                   // Infinite
                                   WT_EXECUTEONLYONCE);

        if (!NT_SUCCESS(ntStatus))
        {
            //
            // Work item registration failed
            //

            SC_LOG1(ERROR,
                    "ScLogonAndStartImage: RtlRegisterWait failed 0x%x\n",
                    ntStatus);
        }

        (*ImageRecordPtr)->ObjectWaitHandle = hWaitObject;
    }

    if (ServiceSid != LocalSystemSid)
    {
        LocalFree(ServiceSid);
    }

    if ( fLoadedEnv ) {
        if ( fUseRtlDestroyEnv ) {
            RtlDestroyEnvironment( Environment );
        }
        else
        {
            DestroyEnvironmentBlock( Environment );
        }
    }

    LocalFree(AccountName);
    return(NO_ERROR);

ExitAccountError:

    if (pipeHandle != NULL) {
        CloseHandle(pipeHandle);
    }

    if (ServiceSid != LocalSystemSid) {
        LocalFree(ServiceSid);
    }

    UnloadUserProfile(ServiceToken, ProfileHandle);
    
    if ( ServiceToken != NULL ) {
        CloseHandle(ServiceToken);
    }

    if (processInfo.hProcess)
    {
        TerminateProcess(processInfo.hProcess, 0);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
    }

    if ( fLoadedEnv ) {
        if ( fUseRtlDestroyEnv ) {
            RtlDestroyEnvironment( Environment );
        }
        else
        {
            DestroyEnvironmentBlock( Environment );
        }
    }

    LocalFree(AccountName);

    return status;
}


BOOL
ScEqualAccountName(
    IN LPWSTR Account1,
    IN LPWSTR Account2
    )

/*++

Routine Description:

    This function compares two account names, either of which may be NULL,
    for equality.

Arguments:

    Account1, Account2 - account names to be compared

Return Value:

    TRUE - names are equal

    FALSE - names are not equal

--*/
{
    if (Account1 == NULL && Account2 == NULL)
    {
        return TRUE;
    }

    if (Account1 == NULL || Account2 == NULL)
    {
        return FALSE;
    }

    return (_wcsicmp(Account1, Account2) == 0);
}


VOID
ScInitStartImage(
    VOID
    )

/*++

Routine Description:

    This function initializes the Critical Section that protects
    entry into the ScStartImage Routine.

Arguments:

    none

Return Value:

    none

--*/
{
    InitializeCriticalSection(&ScStartImageCriticalSection);
}


VOID
ScInitStartupInfo(
    OUT LPSTARTUPINFOW  StartupInfo,
    IN  BOOL            bInteractive
    )

/*++

Routine Description:


Arguments:

    none

Return Value:

    none

--*/
{
    static const STARTUPINFOW ScStartupInfo =
        {
            sizeof(STARTUPINFOW), // size
            NULL,                 // lpReserved
            NULL,                 // DeskTop
            NULL,                 // Title
            0,                    // X (position)
            0,                    // Y (position)
            0,                    // XSize (dimension)
            0,                    // YSize (dimension)
            0,                    // XCountChars
            0,                    // YCountChars
            0,                    // FillAttributes
            STARTF_FORCEOFFFEEDBACK,
                                  // Flags - should be STARTF_TASKNOTCLOSABLE
            SW_HIDE,              // ShowWindow
            0L,                   // cbReserved
            NULL,                 // lpReserved
            NULL,                 // hStdInput
            NULL,                 // hStdOutput
            NULL                  // hStdError
        };

    RtlCopyMemory(StartupInfo, &ScStartupInfo, sizeof(ScStartupInfo));

    if (bInteractive)
    {
        StartupInfo->dwFlags |= STARTF_DESKTOPINHERIT;
        StartupInfo->lpDesktop = pszInteractiveDesktop;
    }
}


VOID
ScProcessHandleIsSignaled(
    PVOID   pContext,
    BOOLEAN fWaitStatus
    )

/*++

Routine Description:


Arguments:

    pContext - This is the process handle.
    fWaitStatus - This is the status from the wait on the process handle.
                  TRUE means the wait timed out, FALSE means it was signaled

Return Value:


--*/
{
    if (fWaitStatus == TRUE)
    {
        //
        // This should never happen -- it indicates a bug in the thread pool code
        // since we registered an infinite wait and are getting called on a timeout
        //
        SC_LOG0(ERROR,
                "ScProcessCleanup received bad WaitStatus\n");

        SC_ASSERT(FALSE);
        return;
    }

    SC_ASSERT(fWaitStatus == FALSE);

    SC_LOG1(THREADS, "Process Handle is signaled 0x%lx\n", pContext);

    ScNotifyChangeState();
    ScProcessCleanup((HANDLE) pContext);
}


BOOL
ScAllowInteractiveServices(
    VOID
    )

/*++

Routine Description:

    Check the flag in the registry to see if this system is to allow
    interactive services.
    REG KEY = HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\-
                 Windows\NoInteractiveServices.

Arguments:


Return Value:


--*/
{
    HKEY    WindowsKey=NULL;
    DWORD   NoInteractiveFlag=0;

    BOOL    bServicesInteractive = TRUE;

    DWORD   status = ScRegOpenKeyExW(
                           HKEY_LOCAL_MACHINE,
                           CONTROL_WINDOWS_KEY_W,
                           REG_OPTION_NON_VOLATILE,   // options
                           KEY_READ,                  // desired access
                           &WindowsKey
                           );

    if (status != ERROR_SUCCESS)
    {
        SC_LOG1(TRACE,
                "ScAllowInteractiveServices: ScRegOpenKeyExW of Control\\Windows failed "
                    FORMAT_LONG "\n",
                status);
    }
    else
    {
        status = ScReadNoInteractiveFlag(WindowsKey,&NoInteractiveFlag);

        if ((status == ERROR_SUCCESS) && (NoInteractiveFlag != 0))
        {
            bServicesInteractive = FALSE;
        }

        ScRegCloseKey(WindowsKey);
    }

    return bServicesInteractive;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\svcctrl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcctrl.h

Abstract:

    Included by the main module svcctrl.c.

Author:

    Dan Lafferty (danl)     22-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    20-Oct-1993     Danl
        Added ScConnectedToSecProc and ScGlobalNetLogonName.


--*/

#ifndef SVCCTRL_H
#define SVCCTRL_H

#include <netevent.h>
#include <safeboot.h>

//
// CONSTANTS
//

//
// Flags to indicate the amount of initialization work done
//
#define SC_NAMED_EVENT_CREATED           0x00000001
#define WELL_KNOWN_SIDS_CREATED          0x00000002
#define SC_MANAGER_OBJECT_CREATED        0x00000004
#define CRITICAL_SECTIONS_CREATED        0x00000008
#define AUTO_START_INITIALIZED           0x00000010
#define RPC_SERVER_STARTED               0x00000020
#define SC_DATABASE_INITIALIZED          0x00000040


//
// String constants for event logging
//

#define SCM_NAMEW                        L"Service Control Manager"

#define SC_RPC_IMPERSONATE               L"RpcImpersonateClient"
#define SC_RPC_REVERT                    L"RpcRevertToSelf"

#define SC_LSA_STOREPRIVATEDATA          L"LsaStorePrivateData"
#define SC_LSA_OPENPOLICY                L"LsaOpenPolicy"

#define SC_RESET_EVENT                   L"ResetEvent"

#define SC_LOAD_USER_PROFILE             L"LoadUserProfile"


//
// Constants used for Safeboot
//

#define  SAFEBOOT_KEY               L"system\\currentcontrolset\\control\\safeboot\\"
#define  SAFEBOOT_KEY_LENGTH        (sizeof(SAFEBOOT_KEY) / sizeof(WCHAR) - 1)


typedef struct _FAILED_DRIVER {
    struct _FAILED_DRIVER *Next;
    WCHAR DriverName[1];
} FAILED_DRIVER, *LPFAILED_DRIVER;


//
// EXTERNAL GLOBALS
//
    extern  BOOL    ScAutoStartInProgress;
    extern  DWORD   ScShutdownInProgress;
    extern  BOOL    ScPopupStartFail;
    extern  BOOL    ScStillInitializing;
#ifndef _CAIRO_
    extern  BOOL    ScConnectedToSecProc;

    extern  LPWSTR  ScGlobalNetLogonName;
#endif // _CAIRO_
    extern  LPWSTR  ScGlobalThisExePath;
    extern  LPWSTR  ScGlobalSecurityExePath;

    extern  NT_PRODUCT_TYPE ScGlobalProductType;

    extern  WCHAR   g_szSafebootKey[];
    extern  DWORD   g_dwSafebootLen;
    extern  DWORD   g_SafeBootEnabled;

    extern  HKEY    g_hProviderKey;

    extern  HANDLE  g_hProcessToken;

//
// FUNCTION PROTOTYPES
//
VOID
SvcctrlMain (
    int     argc,
    PCHAR   argv[]
    );

//
// Functions from start.c
//
VOID
ScInitStartImage(
    VOID
    );

//
// Functions from control.c
//
VOID
ScInitTransactNamedPipe(
    VOID
    );

//
// Functions from status.c
//

BOOL
ScInitServerAnnounceFcn(
    VOID
    );

DWORD
ScRemoveServiceBits(
    IN  LPSERVICE_RECORD  ServiceRecord
    );

BOOL
ScShutdownNotificationRoutine(
    DWORD   dwCtrlType
    );

DWORD
ScAddFailedDriver(
    LPWSTR Driver
    );


#define  IS_CONTROL_LOGGABLE(Control)  (Control == SERVICE_CONTROL_STOP || \
                                          Control == SERVICE_CONTROL_PAUSE || \
                                          Control == SERVICE_CONTROL_CONTINUE)

#define  IS_STATUS_LOGGABLE(Status)    (Status == SERVICE_STOPPED || \
                                          Status == SERVICE_RUNNING || \
                                          Status == SERVICE_PAUSED)

VOID
ScLogControlEvent(
    DWORD   dwEvent,
    LPCWSTR lpServiceName,
    DWORD   dwControl
    );

#endif // def SVCCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\svcctrl.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    svcctrl.cxx

Abstract:

    This is the main routine for the NT LAN Manager Service Controller.

    To use this as a template for another service, simply replace the string
    "svcctl" with the name of the new interface.

Author:

    Dan Lafferty    (danl)  20-Mar-1991

Environment:

    User Mode - Win32

Revision History:

    04-Aug-1999     jschwart
        Added code to watch the list of network providers and write the list
        of providers enabled in this HW profile to the registry for mpr.dll
    22-Oct-1998     jschwart
        Added an unhandled exception filter and converted SCM to use
        the NT thread pool APIs
    22-Jun-1998     jschwart
        Added SetErrorMode call to prevent services from halting the process
        with a hard error popup
    10-Mar-1998     jschwart
        Added RegisterScmCallback call to provide SCM support for passing
        PnP messages to services
    12-Dec-1997     WesW
        Added support for safe boot
    11-Jun-1996     AnirudhS
        Don't popup messages during setup.  The most common cause of popups
        during upgrade is that a service runs in a domain account, and hence
        has a dependency on netlogon, which is disabled during upgrade.
    26-Jun-1995     AnirudhS
        Added callouts to service object class code (ScNotifyServiceObject).
    20-Oct-1993     Danl
        Added Globals for ScConnectedToSecProc and ScGlobalNetLogonName.
    28-Oct-1992     Danl
        Removed ParseArgs and the NT event.  Added Windows event for
        synchronizing service controller with the OpenSCManager client side.
        OpenScManager will now wait until the service controller event is
        set.
    20-Mar-1991     danl
        created

--*/
//
// INCLUDES
//
#include "precomp.hxx"
#include <stdio.h>      // printf

#include <winuserp.h>   // RegisterServicesProcess

#include <lmcons.h>     // needed by lmalert.h
#include <lmalert.h>    // NetAlertRaiseEx definitions
#include <alertmsg.h>   // ALERT_SC_IsLastKnownGood

#ifdef _CAIRO_
#include <wtypes.h>     // HRESULT
#include <scmso.h>      // ScmCallSvcObject
#endif

#include <tstr.h>       // Unicode string macros

#include <ntrpcp.h>     // Rpcp... function prototypes


#include <sclib.h>      // SC_INTERNAL_START_EVENT
#include <svcslib.h>    // CWorkItemContext
#include "scsec.h"      // Security object functions
#include "scconfig.h"   // ScInitSecurityProcess
#include "depend.h"     // ScAutoStartServices
#include "bootcfg.h"    // ScCheckLastKnownGood()
#include "account.h"    // ScInitServiceAccount
#include "info.h"       // ScGetBootAndSystemDriverState
#include "control.h"    // ScShutdownAllServices
#include "lockapi.h"    // ScLockDatabase
#include "scbsm.h"      // ScInitBSM
#include "valid.h"      // MAX_SERVICE_NAME_LENGTH
#include <svcsp.h>      // SVCS_RPC_PIPE, SVCS_LRPC_PROTOCOl, SVCS_LRPC_PORT
#include <winsvcp.h>    // SC_AUTOSTART_EVENT_NAME
#include <sddl.h>       // ConvertSidToStringSid
#include "resource.h"

extern "C" {

#include <cfgmgr32.h>
#include "cfgmgrp.h"
}

#include <scesrv.h>
#include <crypstub.h>   // StartCryptServiceStubs, StopCryptServiceStubs
#include <trkstub.h>    // StartTrkWksServiceStubs, StopTrkWksServiceStubs

//
// Macros:
//
//    IsServer         -- We're running on an NT server or DC
//    IsTerminalServer -- We're running Hydra
//
// Note that IsServer is not guaranteed to be accurate during GUI-mode setup since
// the product type may be changing during an upgrade.
//
#define IsServer()         (USER_SHARED_DATA->NtProductType != NtProductWinNt)
#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))

#define LENGTH(array)           (sizeof(array)/sizeof((array)[0]))

//
// The following turns on code that captures time info & displays it.
// To be used for performance analysis.
//
//#define TIMING_TEST 1

//
// Defines
//

#define SVCCTRL_SHUTDOWN_LEVEL  480
#define SCREG_BASE_PRIORITY     9

#define SERVICES_EXPANDPATH     L"%SystemRoot%\\system32\\services.exe"
#define SECURITY_EXPANDPATH     L"%SystemRoot%\\system32\\lsass.exe"


extern "C" typedef
NET_API_STATUS (NET_API_FUNCTION * PF_NetAlertRaiseEx) (
    IN LPCWSTR AlertEventName,
    IN LPVOID  VariableInfo,
    IN DWORD   VariableInfoSize,
    IN LPCWSTR ServiceName
    );



//===========================
// Globals
//===========================

    DWORD   ScShutdownInProgress  = FALSE;

    //
    // For determining if the service controller is still in its
    // initialization code.
    //
    BOOL    ScStillInitializing = TRUE;

    //
    // For the service controller to put up a popup to notify the first
    // logged on user if any boot, system, or auto start services failed
    // to start.
    //
    BOOL    ScPopupStartFail = FALSE;

    //
    // Flag indicating whether or not NetLogon has been created, and we
    // have successfully connected to the Security Process .
    // If it hasn't then we need to look for it when it is created so that
    // we can synchronize with lsass appropriately.
    //
    BOOL    ScConnectedToSecProc = FALSE;

    //
    // Linked list of names of boot or system start drivers which failed
    // to load.  This list is logged to the eventlog.
    //
    LPFAILED_DRIVER ScFailedDrivers = NULL;
    DWORD ScTotalSizeFailedDrivers = 0;

    //
    // ScGlobalThisExePath gets initialized to the full path of where this
    // executable image is to be.  This is later used to create an image
    // record for services that run in the context of this process.
    //
    LPWSTR  ScGlobalThisExePath = NULL;

    //
    // ScGlobalSecurityExePath gets initialized to the full path of the
    // security process's executable image.  This is later used to
    // determine if we need to initialize the security proc when starting
    // services (i.e., initialize if we start the first SecProc service)
    //
    LPWSTR  ScGlobalSecurityExePath = NULL;

    //
    // ScGlobalProductType contains the product type for this machine.
    // Possiblilties are NtProductWinNt, NtProductLanManNt, NtProductServer.
    //
    NT_PRODUCT_TYPE ScGlobalProductType;

    //
    // Global variables used for safeboot support.  g_szSafebootKey contains
    // the name of the safeboot key (minus the service name, which is filled
    // in by ScStartService for each service in start.cxx).  g_dwSafebootLen
    // holds the length of the safeboot key name, minus the service name
    //

    WCHAR   g_szSafebootKey[SAFEBOOT_KEY_LENGTH + MAX_SERVICE_NAME_LENGTH + 50 + 1] = SAFEBOOT_KEY;
    DWORD   g_dwSafebootLen;
    DWORD   g_SafeBootEnabled;

    //
    // Key handle for MPR provider change notification.  Do this in
    // the SCM so we can avoid loading 3 DLLs (needed for calling the
    // client side of the PNP HW profile APIs) into every process that
    // uses mpr.dll.
    //
    HKEY    g_hProviderKey;

    //
    // Handle to this process' token or to LocalSystem.
    //
    HANDLE  g_hProcessToken;

//=================================
// prototypes
//=================================
BOOL
ScGetStartEvent(
    LPHANDLE    pScStartEvent
    );

VOID
ScPopupThread(
    DWORD StartFailFlag
    );

VOID
ScDestroyFailedDriverList(
    VOID
    );

DWORD
ScMakeFailedDriversOneString(
    LPWSTR *DriverList
    );

LONG
WINAPI
ScUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

NTSTATUS
SvcStartRPCProxys(
    VOID
    );

NTSTATUS
SvcStopRPCProxys(
    VOID
    );

NTSTATUS
ScCreateRpcEndpointSD(
    PSECURITY_DESCRIPTOR  *ppSD
    );


VOID
SvcctrlMain (
    int     argc,
    PCHAR   argv[]
    )

/*++

Routine Description:

    This is the main routine for the Service Controller.  It sets up
    the RPC interface.

Arguments:


Return Value:


Note:


--*/
{
    RPC_STATUS  status;
    NTSTATUS    ntStatus;
    DWORD       dwStatus;
    HANDLE      ScStartEvent;
    HANDLE      ThreadHandle;
    DWORD       ThreadId;
    SC_RPC_LOCK Lock=NULL;
    KPRIORITY   NewBasePriority   = SCREG_BASE_PRIORITY;
    HANDLE      AutoStartHandle   = NULL;
    HKEY        hKeySafeBoot;
    HANDLE      hProviderEvent    = NULL;

    TOKEN_PRIVILEGES  TokenPrivs;

    //
    // Save bitwise flags to indicate the amount of initialization
    // work done so that if we hit an error along the way, the
    // appropriate amount of shutdown can occur.
    //
    DWORD ScInitState = 0;

    SetUnhandledExceptionFilter(&ScUnhandledExceptionFilter);


    //
    // Prevent critical errors from raising hard error popups and
    // halting services.exe.  The flag below will have the system
    // send the errors to the process instead.
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    RtlSetProcessIsCritical(TRUE, NULL, TRUE);


#ifdef TIMING_TEST
    DWORD       TickCount1;
    DWORD       TickCount2;
    DWORD       TickCount3;

    TickCount1 = GetTickCount();
#endif // TIMING_TEST


    //
    // Turn off privileges that we don't need. Leave the handle to the token
    // open since it is now needed during Service startup processing. Make
    // sure all accesses needed by the rest of the SCM are specified here.
    //

    ntStatus = NtOpenProcessToken(NtCurrentProcess(),
                                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY | TOKEN_DUPLICATE,
                                  &g_hProcessToken);

    if (!NT_SUCCESS(ntStatus))
    {
        goto CleanExit;
    }

    TokenPrivs.PrivilegeCount           = 1;
    TokenPrivs.Privileges[0].Luid       = RtlConvertLongToLuid(SE_CREATE_TOKEN_PRIVILEGE);
    TokenPrivs.Privileges[0].Attributes = SE_PRIVILEGE_REMOVED;

    ntStatus = NtAdjustPrivilegesToken(g_hProcessToken,
                                       FALSE,
                                       &TokenPrivs,
                                       sizeof(TokenPrivs),
                                       NULL,
                                       NULL);

    if (!NT_SUCCESS(ntStatus))
    {
        goto CleanExit;
    }


    //
    // Create event that Service Controller will set when done starting all
    // Auto-Start services (including async devices).  If this call fails,
    // it typically means somebody tried to start up a second instance of
    // services.exe (which is running in the user's context, not LocalSystem).
    //
    AutoStartHandle = CreateEvent(
                        NULL,                       // Event Attributes
                        TRUE,                       // ManualReset
                        FALSE,                      // Initial State (not-signaled)
                        SC_AUTOSTART_EVENT_NAME);   // Name

    if (AutoStartHandle == NULL)
    {
        SC_LOG2(ERROR,
                "SvcctrlMain: CreateEvent( \"%ws\" ) failed %ld\n",
                SC_AUTOSTART_EVENT_NAME,
                GetLastError());

        goto CleanExit;
    }

    //
    // Create a string containing the pathname for this executable image
    // and one containing the pathname for the security proc image
    //
    {
        DWORD   NumChars = 0;
        DWORD   CharsReturned = 0;
        WCHAR   Temp[1];

        //
        // Create the string for this Exe
        //
        NumChars = ExpandEnvironmentStringsW(SERVICES_EXPANDPATH,Temp,1);

        if (NumChars > 1) {
            ScGlobalThisExePath = (LPWSTR)LocalAlloc(
                                    LPTR,
                                    NumChars * sizeof(WCHAR));
            if (ScGlobalThisExePath == NULL) {
                SC_LOG0(ERROR,"Couldn't allocate for ThisExePath\n");
                goto CleanExit;
            }

            CharsReturned = ExpandEnvironmentStringsW(
                                SERVICES_EXPANDPATH,
                                ScGlobalThisExePath,
                                NumChars);

            if (CharsReturned > NumChars) {
                SC_LOG0(ERROR,"Couldn't expand ThisExePath\n");
                goto CleanExit;
            }
        }

        //
        // Create the string for the security image
        //
        NumChars = ExpandEnvironmentStringsW(SECURITY_EXPANDPATH, Temp, 1);

        if (NumChars > 1) {

            ScGlobalSecurityExePath = (LPWSTR)LocalAlloc(LPTR,
                                                         NumChars * sizeof(WCHAR));

            if (ScGlobalSecurityExePath == NULL) {
                SC_LOG0(ERROR,"Couldn't allocate for SecurityExePath\n");
                goto CleanExit;
            }

            CharsReturned = ExpandEnvironmentStringsW(
                                SECURITY_EXPANDPATH,
                                ScGlobalSecurityExePath,
                                NumChars);

            if (CharsReturned > NumChars) {
                SC_LOG0(ERROR,"Couldn't expand SecurityExePath\n");
                goto CleanExit;
            }
        }
    }

    //
    // Create well-known SIDs
    //
    if (! NT_SUCCESS(ntStatus = ScCreateWellKnownSids())) {
        SC_LOG1(ERROR, "ScCreateWellKnownSids failed: %08lx\n", ntStatus);
        goto CleanExit;
    }
    ScInitState |= WELL_KNOWN_SIDS_CREATED;

    //
    // Set up the provider information for mpr.dll
    //
    dwStatus = ScRegOpenKeyExW(HKEY_LOCAL_MACHINE,
                               PROVIDER_KEY_BASE L"\\" PROVIDER_KEY_ORDER,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               &g_hProviderKey);

    if (dwStatus == NO_ERROR)
    {
        hProviderEvent = CreateEvent(NULL,
                                     TRUE,    // Manual-reset
                                     FALSE,   // Nonsignaled
                                     NULL);

        if (hProviderEvent != NULL)
        {
            ScHandleProviderChange(hProviderEvent, FALSE);
        }
        else
        {
            SC_LOG1(ERROR,
                    "SvcctrlMain: CreateEvent for provider event FAILED %d\n",
                    GetLastError());

            ScRegCloseKey(g_hProviderKey);
            g_hProviderKey = NULL;
        }
    }
    else
    {
        SC_LOG1(ERROR,
                "SvcctrlMain: Unable to open provider key %d\n",
                dwStatus);
    }

    //
    // Create the event that the OpenSCManager will use to wait on the
    // service controller with.
    //
    if (!ScGetStartEvent(&ScStartEvent)) {
        SC_LOG0(ERROR,"SvcctrlMain: ScGetStartEvent Failed\n");
        goto CleanExit;
    }

    ScInitState |= SC_NAMED_EVENT_CREATED;

    //
    // Create security descriptor for SC Manager object to protect
    // the SC Manager databases
    //
    if (ScCreateScManagerObject() != NO_ERROR) {
        SC_LOG0(ERROR, "ScCreateScManagerObject failed\n");
        goto CleanExit;
    }
    ScInitState |= SC_MANAGER_OBJECT_CREATED;

    //
    // Get the ProductType.
    //
    if (!RtlGetNtProductType(&ScGlobalProductType)) {
        SC_LOG0(ERROR, "GetNtProductType failed\n");
        goto CleanExit;
    }

    //
    // Check the Boot Configuration and assure that the LastKnownGood
    // ControlSet is safe, and pointers are correct.
    // This function initializes the ScGlobalLastKnownGood flag.
    //

    if (!ScCheckLastKnownGood()) {
        SC_LOG0(ERROR, "ScCheckLastKnownGood failed\n");
        goto CleanExit;
    }

    //
    // Initialize data structures required to remove a service account.
    // They will be cleaned up by ScEndServiceAccount.
    //
    // NOTE: ScGetComputerNameAndMutex must be called before call to
    // ScInitDatabase because ScInitDatabase may delete a service
    // entry that was marked for delete from a previous boot.
    //
    if (! ScGetComputerNameAndMutex()) {
        SC_LOG0(ERROR, "ScGetComputerName failed\n");
        goto CleanExit;
    }

    //
    // Read installed services into memory
    //
    if (! ScInitDatabase()) {
        SC_LOG0(ERROR, "ScInitDatabase failed\n");
        goto CleanExit;
    }
    ScInitState |= SC_DATABASE_INITIALIZED;

    //
    // Initialize accounts functionality.
    //

    if (! ScInitServiceAccount()) {
        SC_LOG0(ERROR, "ScInitServiceAccount failed\n");
        goto CleanExit;
    }

    //
    // Create critical sections
    //
    ScInitStartImage();
    ScInitTransactNamedPipe();
    ScInitState |= CRITICAL_SECTIONS_CREATED;

    if (!CWorkItemContext::Init()) {
        SC_LOG0(ERROR, "CWorkItemContext::Init failed\n");
        goto CleanExit;
    }


    //
    // look to see if we booted in safeboot mode
    //

    dwStatus = RegOpenKey(HKEY_LOCAL_MACHINE,
                          L"system\\currentcontrolset\\control\\safeboot\\option",
                          &hKeySafeBoot);

    if (dwStatus == ERROR_SUCCESS) {

        //
        // we did in fact boot under safeboot control
        //
        ThreadId = sizeof(DWORD);

        dwStatus = RegQueryValueEx(hKeySafeBoot,
                                   L"OptionValue",
                                   NULL,
                                   NULL,
                                   (LPBYTE)&g_SafeBootEnabled,
                                   &ThreadId);

        if (dwStatus != ERROR_SUCCESS) {
            g_SafeBootEnabled = 0;
        }

        RegCloseKey(hKeySafeBoot);

        if (g_SafeBootEnabled) {

            g_dwSafebootLen = SAFEBOOT_KEY_LENGTH;

            switch (g_SafeBootEnabled) {
                case SAFEBOOT_MINIMAL:
                    wcscpy(g_szSafebootKey + g_dwSafebootLen, SAFEBOOT_MINIMAL_STR_W);
                    g_dwSafebootLen += (sizeof(SAFEBOOT_MINIMAL_STR_W) / sizeof(WCHAR)) - 1;
                    break;

                case SAFEBOOT_NETWORK:
                    wcscpy(g_szSafebootKey + g_dwSafebootLen, SAFEBOOT_NETWORK_STR_W);
                    g_dwSafebootLen += (sizeof(SAFEBOOT_NETWORK_STR_W) / sizeof(WCHAR)) - 1;
                    break;

                case SAFEBOOT_DSREPAIR:
                    wcscpy(g_szSafebootKey + g_dwSafebootLen, SAFEBOOT_DSREPAIR_STR_W);
                    g_dwSafebootLen += (sizeof(SAFEBOOT_DSREPAIR_STR_W) / sizeof(WCHAR)) - 1;
                    break;

                default:
                    SC_ASSERT(FALSE);
                    break;
            }

            wcscpy(g_szSafebootKey + g_dwSafebootLen, L"\\");
            g_dwSafebootLen += 1;
        }
    }

    //
    // Perform initialization related to network drive arrival broadcasts.
    // (This addes another work item to the object watcher work list.)
    //
    ScInitBSM();

    //
    // Get the latest state of drivers started up by boot and system
    // init.
    //
    ScGetBootAndSystemDriverState();

    //
    // Create semaphores needed for handling start dependencies
    //
    if (! ScInitAutoStart()) {
        SC_LOG0(ERROR, "ScInitAutoStart failed\n");
        goto CleanExit;
    }
    ScInitState |= AUTO_START_INITIALIZED;

    //
    // Register this process with User32.  This tells User32 to use the
    // value from HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control
    //  \WaitToKillServiceTimeout (if it exists), rather than
    // HKEY_CURRENT_USER\Control Panel\Desktop\WaitToKillAppTimeout,
    // to decide how long to wait before killing us on shutdown.
    //
    if (! RegisterServicesProcess(GetCurrentProcessId())) {
        SC_LOG0(ERROR, "RegisterServicesProcess failed\n");
    }

    //
    //  Lock the database until autostart is complete
    //
    status = ScLockDatabase(TRUE, SERVICES_ACTIVE_DATABASEW, &Lock);
    if (status != NO_ERROR) {
        SC_LOG1(ERROR, "ScLockDatabase failed during init %d\n",status);
        goto CleanExit;
    }

    //
    // Start the RPC server
    //
    SC_LOG0(TRACE, "Getting ready to start RPC server\n");

    //
    // Listen to common LRPC port.
    //

    PSECURITY_DESCRIPTOR pSD;

    status = ScCreateRpcEndpointSD(&pSD);

    if (!NT_SUCCESS(status))
    {
        status = RtlNtStatusToDosError(status);

        SC_LOG1(ERROR,
                "SvcctrlMain:  ScCreateRpcEndpointSD failed %d\n",
                status);

        goto CleanExit;
    }

    status = RpcServerUseProtseqEp((unsigned short *)SVCS_LRPC_PROTOCOL,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   (unsigned short *)SVCS_LRPC_PORT,
                                   pSD);

    RtlDeleteSecurityObject(&pSD);
    pSD = NULL;

    if (status != RPC_S_OK)
    {
        SC_LOG1(ERROR, "RpcServerUseProtseqEp on LRPC failed: %d\n", status);
        goto CleanExit;
    }

    // Listen to named pipe endpoint and register interface.

    status = RpcpStartRpcServer(
                SVCS_RPC_PIPE,
                svcctl_ServerIfHandle);

    if (!NT_SUCCESS(status))
    {
        SC_LOG1(ERROR, "RpcpStartRpcServer: %lx\n",status);
        goto CleanExit;
    }

    ScInitState |= RPC_SERVER_STARTED;

    //
    // Signal the event that indicates that we are completely started.
    //
    if (!SetEvent(ScStartEvent))
    {
        SC_LOG1(ERROR, "Unable to set StartEvent: %d\n", GetLastError());
    }

    SC_LOG0(INFO,"Service Controller successfully initialized\n");

    //
    // Set up for proper shutdown.
    //

    if (!SetConsoleCtrlHandler(ScShutdownNotificationRoutine, TRUE))
    {
        SC_LOG1(ERROR, "SetConsoleCtrlHandler call failed %d\n",GetLastError());
    }

    if (!SetProcessShutdownParameters(SVCCTRL_SHUTDOWN_LEVEL, SHUTDOWN_NORETRY))
    {
        SC_LOG1(ERROR, "SetProcessShutdownParameters call failed %d\n",
        GetLastError());
    }

    SC_LOG0(TRACE,"** ** Service Controller can now accept shutdown system request\n");

    //
    // init SCE server. if it fails to intialize, the process will terminate
    //

    dwStatus = ScesrvInitializeServer(RpcpStartRpcServer);

    if (ERROR_SUCCESS != dwStatus)
    {
        //
        // event log is not up running yet.
        // just log a message to debugger
        // no need to shutdown services
        //
        SC_LOG(ERROR,"ScesrvInitializeServer failed to initialize! %lu\n", dwStatus);

        goto CleanExit;
    }

    //
    // Initialization is done, so give PnP a callback routine for them to call
    // when a service needs to receive a PnP event (callback in control.cxx) and
    // to validate a service calling RegisterDeviceNotification.
    //
    RegisterScmCallback(&ScSendPnPMessage, &ScValidatePnPService);

    SvcStartRPCProxys();

    //
    // Init the WMI events.
    //
    InitNCEvents();

    //
    // Auto-start services
    //
    dwStatus = ScAutoStartServices(&Lock);

    if (dwStatus != NO_ERROR)
    {
        SC_LOG1(ERROR,
                "SvcctrlMain:  ScAutoStartServices failed %d\n",
                dwStatus);

        goto CleanExit;
    }

    //
    // Log event if any boot/system start drivers failed.
    //
    if (ScFailedDrivers != NULL)
    {
        LPWSTR DriverList;

        ScMakeFailedDriversOneString(&DriverList);

        ScLogEvent(
            NEVENT_BOOT_SYSTEM_DRIVERS_FAILED,
            DriverList
            );

        LocalFree(DriverList);

        ScDestroyFailedDriverList();
    }

    //
    // Spin a thread to put up popup if a service specified to start
    // automatically at boot has failed to start, or we are running the
    // last-known-good configuration.
    //
    // Only popup a message if we're running on a server -- Workstation
    // users get confused by the message and don't know where to look
    // to figure out what went wrong.  Note that IsServer is not valid
    // during GUI-mode setup (the product type may be changing), but
    // the later call to SetupInProgress handles this.
    //
    // Don't popup any messages if we're booting into safe mode, since
    // several boot and system drivers are explicitly not started and
    // will result in a "false error" when the SCM notices they "failed"
    // to start.
    //
    // Don't popup any messages during setup/upgrade.  (The most common
    // cause of messages during upgrade is dependence on netlogon, which
    // is disabled.)
    //
    if ((ScPopupStartFail || (ScGlobalLastKnownGood & REVERTED_TO_LKG))
        &&
        IsServer()
        &&
        !g_SafeBootEnabled
        &&
        (! SetupInProgress(NULL, NULL))) {

        //
        // Suppress the popups if NoPopupsOnBoot is indicated in the registry.
        //
        DWORD   PopupStatus;
        BOOLEAN bPopups = TRUE;     // FALSE means suppress popups on boot
        HKEY    WindowsKey=NULL;

        PopupStatus = ScRegOpenKeyExW(
           HKEY_LOCAL_MACHINE,
           CONTROL_WINDOWS_KEY_W,
           REG_OPTION_NON_VOLATILE,   // options
           KEY_READ,                  // desired access
           &WindowsKey
           );

        if (PopupStatus == ERROR_SUCCESS) {

            DWORD Type;
            DWORD Data;
            DWORD cbData = sizeof(Data);

            PopupStatus = ScRegQueryValueExW(
                           WindowsKey,
                           NOBOOTPOPUPS_VALUENAME_W,
                           NULL,
                           &Type,
                           (LPBYTE) &Data,
                           &cbData
                           );

            //
            // Popups are suppressed if the NOBOOTPOPUPS_VALUENAME_W value is
            // present, is a REG_DWORD and is non-zero.
            //
            if (PopupStatus == ERROR_SUCCESS &&
                Type == REG_DWORD &&
                Data != 0) {

                bPopups = FALSE;
            }

            ScRegCloseKey(WindowsKey);
        }


        if (bPopups) {

            ThreadHandle = CreateThread(
                               NULL,
                               0L,
                               (LPTHREAD_START_ROUTINE) ScPopupThread,
                               (LPVOID)(DWORD_PTR) ScPopupStartFail,
                               0L,
                               &ThreadId
                               );

            if (ThreadHandle == (HANDLE) NULL) {
                SC_LOG(TRACE,"CreateThread ScPopupThread failed %lu\n",
                    GetLastError());

            }
            else {
                (void) CloseHandle(ThreadHandle);
            }
        }
    }

    //
    // Now we can allow database modifications from RPC callers.
    //
    ScUnlockDatabase(&Lock);

#ifdef TIMING_TEST
    TickCount2 = GetTickCount();
#endif

    //
    // Now switch to high priority class
    //
    (void) NtSetInformationProcess(
                NtCurrentProcess(),
                ProcessBasePriority,
                &NewBasePriority,
                sizeof(NewBasePriority));

    //
    // If we get this far, then from our point of view, the boot is
    // acceptable.  We will now call the Accept Boot Program.  This program
    // will decide whether or not the boot was good (from the administrators)
    // point of view.
    // Our default program simply says the boot was good - thus causing
    // LastKnownGood to be updated to the current boot.
    //
    ScRunAcceptBootPgm();

    //
    // Now that the Auto-start services have been started, notify
    // Terminal Server so that additional Sessions can be started.
    //
    if ( AutoStartHandle )
        NtSetEvent( AutoStartHandle, NULL );

    //
    // Setup complete -
    // This thread will become the service process watcher.  Service
    // process handles are stored in an array of waitble objects that
    // the watcher thread waits on.  When any ProcessHandle becomes
    // signaled while in this array, this indicates that the process has
    // terminated unexpectedly.  The watcher thread then cleans up the
    // service controller database.
    //
    ScStillInitializing = FALSE;

#ifdef TIMING_TEST
    TickCount3 = GetTickCount();
    DbgPrint("[SC_TIMING] Tick Count for autostart complete \t %d\n",TickCount2);
    DbgPrint("[SC-TIMING] MSec for Autostart:   \t%d\n",TickCount2-TickCount1);
    DbgPrint("[SC-TIMING] MSec for LKG work:    \t%d\n",TickCount3-TickCount2);
    DbgPrint("[SC-TIMING] MSec to complete init:\t%d\n",TickCount3-TickCount1);
#endif

    ExitThread(NO_ERROR);

CleanExit:

    //
    // Do minimal cleanup and let process cleanup take care of the rest.
    // Note that the full-blown cleanup was removed in January, 2000 as
    // it was for the most part unnecessary.  If some of it ends up being
    // needed, it should be available via the checkin history.
    //
    ScStillInitializing  = FALSE;

    ScEndServiceAccount();

    SvcStopRPCProxys();

    //
    // Shut down the RPC server.
    //
    SC_LOG0(TRACE,"Shutting down the RPC interface for the Service Controller\n");

    if (ScInitState & RPC_SERVER_STARTED)
    {
        status = RpcpStopRpcServer(svcctl_ServerIfHandle);
    }

    if (Lock != NULL)
    {
        ScUnlockDatabase(&Lock);
    }

    //
    // terminate SCE server
    //
    ScesrvTerminateServer( (PSVCS_STOP_RPC_SERVER) RpcpStopRpcServer );

    SC_LOG0(ERROR,"The Service Controller is Terminating.\n");

    ExitThread(0);

    return;
}

BOOL
ScShutdownNotificationRoutine(
    DWORD   dwCtrlType
    )

/*++

Routine Description:

    This routine is called by the system when system shutdown is occuring.

Arguments:



Return Value:



--*/
{
    if (dwCtrlType == CTRL_SHUTDOWN_EVENT) {

        SC_LOG0(TRACE,"  ! SHUTDOWN !  -  -  In ScShutdownNotificationRoutine\n");


#ifndef SC_DEBUG
        //
        // First quiet all RPC interfaces
        //


        ScShutdownInProgress = TRUE;
#endif

        //
        // Then shut down all services
        //
        SC_LOG0(TRACE,"[Shutdown] Begin Service Shutdown\n");
        ScShutdownAllServices();

    }
    return(TRUE);
}


VOID
ScLogControlEvent(
    DWORD   dwEvent,
    LPCWSTR lpServiceName,
    DWORD   dwControl
    )
/*++

Routine Description:

    Wrapper for logging service control events

Arguments:


Return Value:


--*/
{
    WCHAR  wszControlString[50];
    DWORD  dwStringBase;

    //
    // Load the string that corresponts to this control
    //

    switch (dwEvent)
    {
        case NEVENT_SERVICE_CONTROL_SUCCESS:
            dwStringBase = IDS_SC_CONTROL_BASE;
            break;

        case NEVENT_SERVICE_STATUS_SUCCESS:
            dwStringBase = IDS_SC_STATUS_BASE;
            break;

        case NEVENT_SERVICE_CONFIG_BACKOUT_FAILED:
            dwStringBase = 0;    // dwControl is the resource ID
            break;

        default:
            ASSERT(FALSE);
            return;
    }

    if (!LoadString(GetModuleHandle(NULL),
                    dwStringBase + dwControl,
                    wszControlString,
                    LENGTH(wszControlString)))
    {
        //
        // The control has no string associated with it
        // (i.e., not a control we log).
        //

        return;
    }

    if (dwEvent == NEVENT_SERVICE_CONTROL_SUCCESS)
    {
        //
        // Include the user that sent the control.  Use the empty
        // string on failure (better that than dropping the event).
        //

        PTOKEN_USER  pToken      = NULL;
        LPWSTR       lpStringSid = NULL;

        if (ScGetClientSid(&pToken) == NO_ERROR)
        {
            if (!ConvertSidToStringSid(pToken->User.Sid, &lpStringSid))
            {
                lpStringSid = NULL;
            }
        }
        else
        {
            pToken = NULL;
        }

        ScLogEvent(dwEvent,
                   lpServiceName,
                   wszControlString,
                   lpStringSid);

        LocalFree(lpStringSid);
        LocalFree(pToken);
    }
    else
    {
        ScLogEvent(dwEvent,
                   lpServiceName,
                   wszControlString);
    }
}


BOOL
ScGetStartEvent(
    LPHANDLE    pScStartEvent
    )

/*++

Routine Description:

    This function gets a handle to the SC_INTERNAL_START_EVENT that is
    used to wait on the service controller when calling OpenSCManager.

Arguments:

    pScStartEvent - This is a pointer to the location where the handle
        to the event is to be placed.

Return Value:

    TRUE    - If a handle was obtained.
    FALSE   - If a handle was not obtained.


--*/
{
    DWORD                   status;
    HANDLE                  ScStartEvent = NULL;
    SECURITY_ATTRIBUTES     SecurityAttributes;
    PSECURITY_DESCRIPTOR    SecurityDescriptor=NULL;

    //
    // Initialize the status so that if we fail to create the security
    // descriptor, we will still try to open the event.
    //
    status = ERROR_ALREADY_EXISTS;

    //
    // Create the event that the OpenSCManager will use to wait on the
    // service controller with.
    //

    status = ScCreateStartEventSD(&SecurityDescriptor);

    if (status == NO_ERROR) {

        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.bInheritHandle = FALSE;
        SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;

        ScStartEvent = CreateEventW(
                    &SecurityAttributes,
                    TRUE,                   // Must be manually reset
                    FALSE,                  // The event is initially not signalled
                    SC_INTERNAL_START_EVENT );

        if (ScStartEvent == NULL) {
            status = GetLastError();
        }
        LocalFree(SecurityDescriptor);
    }
    else {
        SC_LOG0(ERROR,"ScGetStartEvent: Couldn't allocate for SecurityDesc\n");
    }

    if (ScStartEvent == NULL){

        //
        // If the event already exists, some other process beat us to
        // creating it.  Just open it.
        //
        if ( status == ERROR_ALREADY_EXISTS ) {
            ScStartEvent = OpenEvent(
                            GENERIC_WRITE,
                            FALSE,
                            SC_INTERNAL_START_EVENT );
        }

        if (ScStartEvent == NULL ) {
            SC_LOG1(ERROR,"GetStartEvent: OpenEvent (StartEvent) Failed "
                    FORMAT_DWORD "\n", status);
            return(FALSE);
        }
    }
    *pScStartEvent = ScStartEvent;
    return(TRUE);
}

VOID
ScPopupThread(
    DWORD StartFailFlag
    )
/*++

Routine Description:

    This function reports the state of the system that has just booted.
    If we are running last-known-good:
        1) Raise an admin alert
        2) Put up a message box popup

    If a service has failed to start (StartFailFlag is TRUE):
        1) Put up a message box popup

    The reason the StartFailFlag is a parameter is because its value
    may change while we are in this thread.  We only care about
    its value at the time this thread is created.

Arguments:

    StartFailFlag - Supplies a flag which indicates whether to put
        up a popup due to services which failed to start.

Return Value:

    None.

--*/
{

#define POPUP_BUFFER_CHARS   256

    DWORD   MessageSize;
    HMODULE NetEventDll;
    WCHAR   Buffer[POPUP_BUFFER_CHARS];
    WCHAR   Title[POPUP_BUFFER_CHARS];
    LPWSTR  pTitle=NULL;

    HMODULE     NetApi32Dll = NULL;
    PF_NetAlertRaiseEx  ScNetAlertRaiseEx = NULL;
    KPRIORITY   NewBasePriority = SCREG_BASE_PRIORITY;


    if (ScGlobalLastKnownGood & REVERTED_TO_LKG) {
        //
        // Get address to API NetAlertRaiseEx to raise an Admin alert
        //
        NetApi32Dll = LoadLibraryW(L"netapi32.dll");

        if (NetApi32Dll != NULL) {
            ScNetAlertRaiseEx = (PF_NetAlertRaiseEx) GetProcAddress(
                                                 NetApi32Dll,
                                                 "NetAlertRaiseEx"
                                                 );

            if (ScNetAlertRaiseEx != NULL) {

                PADMIN_OTHER_INFO Admin;


                //
                // Raise an admin alert
                //
                Admin = (PADMIN_OTHER_INFO) Buffer;
                Admin->alrtad_errcode = ALERT_SC_IsLastKnownGood;
                Admin->alrtad_numstrings = 0;

                (void) ScNetAlertRaiseEx(
                           ALERT_ADMIN_EVENT,
                           Buffer,
                           sizeof(ADMIN_OTHER_INFO),
                           SCM_NAMEW
                           );

            }

            FreeLibrary(NetApi32Dll);
        }
    }

    NetEventDll = LoadLibraryW(L"netevent.dll");

    if (NetEventDll == NULL) {
        return;
    }

    MessageSize = FormatMessageW(
                      FORMAT_MESSAGE_FROM_HMODULE,
                      (LPVOID) NetEventDll,
                      TITLE_SC_MESSAGE_BOX,
                      0,
                      Title,
                      POPUP_BUFFER_CHARS,
                      NULL
                      );

    if (MessageSize == 0 ) {
        pTitle = SCM_NAMEW;
    }
    else {
        pTitle = Title;
    }

    if (ScGlobalLastKnownGood & REVERTED_TO_LKG) {

        MessageSize = FormatMessageW(
                          FORMAT_MESSAGE_FROM_HMODULE,
                          (LPVOID) NetEventDll,
                          EVENT_RUNNING_LASTKNOWNGOOD,
                          0,
                          Buffer,
                          POPUP_BUFFER_CHARS,
                          NULL
                          );

        if (MessageSize != 0) {

            (void) MessageBoxW(
                       NULL,
                       Buffer,
                       pTitle,
                       MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION |
                            MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION
                       );
            //
            // Now switch back to proper priority
            //
            NtSetInformationProcess(NtCurrentProcess(),
                                    ProcessBasePriority,
                                    &NewBasePriority,
                                    sizeof(NewBasePriority));
        }
        else {
            SC_LOG1(TRACE, "FormatMessage failed %lu\n", GetLastError());
        }

    }

    //
    // Popup a message if a service failed to start
    //
    if (StartFailFlag) {

        MessageSize = FormatMessageW(
                          FORMAT_MESSAGE_FROM_HMODULE,
                          (LPVOID) NetEventDll,
                          EVENT_SERVICE_START_AT_BOOT_FAILED,
                          0,
                          Buffer,
                          POPUP_BUFFER_CHARS,
                          NULL
                          );

        if (MessageSize != 0) {

            MessageBoxW(NULL,
                        Buffer,
                        pTitle,
                        MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION |
                             MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION);

            //
            // Now switch back to proper priority
            //

            NtSetInformationProcess(NtCurrentProcess(),
                                    ProcessBasePriority,
                                    &NewBasePriority,
                                    sizeof(NewBasePriority));
        }
        else {
            SC_LOG1(TRACE, "FormatMessage failed %lu\n", GetLastError());
        }
    }

    FreeLibrary(NetEventDll);

    //
    // Now switch to high priority class
    //

    ExitThread(0);
}


DWORD
ScAddFailedDriver(
    LPWSTR Driver
    )
{
    DWORD StrSize = (DWORD) WCSSIZE(Driver);
    LPFAILED_DRIVER NewEntry;
    LPFAILED_DRIVER Entry;


    NewEntry = (LPFAILED_DRIVER) LocalAlloc(
                           LMEM_ZEROINIT,
                           (UINT) sizeof(FAILED_DRIVER) + StrSize
                           );

    if (NewEntry == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Each string will be separated from the previous one a CR and
    // LF character.  We already included one for NULL terminator of each
    // driver so add one more.
    //
    ScTotalSizeFailedDrivers += StrSize + sizeof(WCHAR);

    wcscpy((LPWSTR) NewEntry->DriverName, Driver);

    //
    // Insert new entry into ScFailedDrivers global list
    //

    //
    // Special case empty list
    //
    if (ScFailedDrivers == NULL) {
        ScFailedDrivers = NewEntry;
        return NO_ERROR;
    }

    //
    // Otherwise look for end of the list and insert new entry
    //
    Entry = ScFailedDrivers;

    while (Entry->Next != NULL) {
        Entry = Entry->Next;
    }

    Entry->Next = NewEntry;

    return NO_ERROR;
}


VOID
ScDestroyFailedDriverList(
    VOID
    )
{
    LPFAILED_DRIVER DeleteEntry;


    while (ScFailedDrivers != NULL) {
        DeleteEntry = ScFailedDrivers;
        ScFailedDrivers = ScFailedDrivers->Next;
        LocalFree(DeleteEntry);
    }
}


DWORD
ScMakeFailedDriversOneString(
    LPWSTR *DriverList
    )
{
    LPFAILED_DRIVER Entry = ScFailedDrivers;


    //
    // Allocate space for concatenated string of all the drivers that
    // failed plus the terminator character.
    //
    *DriverList = (LPWSTR) LocalAlloc(
                              LMEM_ZEROINIT,
                              (UINT) ScTotalSizeFailedDrivers + sizeof(WCHAR)
                              );

    if (*DriverList == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    while (Entry != NULL) {
        wcscat(*DriverList, L"\r\n");
        wcscat(*DriverList, (LPWSTR) Entry->DriverName);
        Entry = Entry->Next;
    }

    return NO_ERROR;
}


LONG
WINAPI
ScUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    return RtlUnhandledExceptionFilter(ExceptionInfo);
}


NTSTATUS
SvcStartRPCProxys(
    VOID
    )

/*++

Routine Description:

    This function calls the RPC Proxy startup routines for the
    services that were moved out of services.exe, but have existing
    clients that rely on the services.exe named pipe

Arguments:


Return Value:

    STATUS_SUCCESS - If proxys were started


--*/
{
    NTSTATUS dwStatus = STATUS_SUCCESS;

    dwStatus = StartCryptServiceStubs(RpcpStartRpcServer,
                                      SVCS_RPC_PIPE);

    // Start the RPC stubs for the distributed link tracking client service.
    dwStatus = StartTrkWksServiceStubs( RpcpStartRpcServer,
                                        SVCS_RPC_PIPE );

    return dwStatus;
}


NTSTATUS
SvcStopRPCProxys(
    VOID
    )

/*++

Routine Description:

    This function calls the RPC Proxy startup routines for the
    services that were moved out of services.exe, but have existing
    clients that rely on the services.exe named pipe

Arguments:


Return Value:

    STATUS_SUCCESS - If proxys were started


--*/
{
    NTSTATUS dwStatus = STATUS_SUCCESS;

    dwStatus = StopCryptServiceStubs(RpcpStopRpcServer);

    // Stop the RPC stubs for the distributed link tracking client service.
    dwStatus = StopTrkWksServiceStubs(RpcpStopRpcServer);

    return dwStatus;
}


NTSTATUS
ScCreateRpcEndpointSD(
    PSECURITY_DESCRIPTOR  *ppSD
    )

/*++

Routine Description:

    This function builds a security descriptor for the SCM's
    shared LPC endpoint.  Everybody needs access to call it.

Arguments:

    ppSD -- pointer to an SD that this routine will allocate

Return Value:

    STATUS_SUCCESS - if SD was successfully created


--*/
{

#define SC_ENDPOINT_ACECOUNT    3

    SC_ACE_DATA AceData[SC_ENDPOINT_ACECOUNT] = {
        { ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                GENERIC_ALL,
                &LocalSystemSid },

        { ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                GENERIC_ALL,
                &AliasAdminsSid },

        { ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                GENERIC_READ | GENERIC_WRITE |
                    GENERIC_EXECUTE | SYNCHRONIZE,
                &WorldSid }
        };

    return ScCreateAndSetSD(AceData,
                            SC_ENDPOINT_ACECOUNT,
                            NULL,                  // owner
                            NULL,                  // group
                            ppSD);

#undef SC_ENDPOINT_ACECOUNT

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\status.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    status.cxx

Abstract:

    This file contains functions that are involved with setting the
    status for a service in the service controller.

        RSetServiceStatus
        RemovalThread
        RI_ScSetServiceBitsA
        RI_ScSetServiceBitsW
        ScRemoveServiceBits
        ScInitServerAnnounceFcn

Author:

    Dan Lafferty (danl)     20-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    10-Mar-1998     jschwart
        Add code to RSetServiceStatus to notify Plug-and-Play when a service
        registers/deregisters for hardware profile change notifications.

    08-Jan-1997     anirudhs
        RSetServiceStatus: Fix obscure locking bugs found by the new locking
        scheme.  When a service stops, we sometimes need more restrictive
        locks than was previously assumed.

    11-Apr-1996     anirudhs
        RSetServiceStatus: Notify NDIS when a service that belongs to a
        group NDIS is interested in starts running.

    21-Nov-1995     anirudhs
        RI_ScSetServiceBitsW: Catch access violations caused if the
        hServiceStatus parameter is invalid.

    23-Mar-1994     danl
        RSetServiceStatus:  Only set the PopupStartFail flag when we have
        actually logged an event.  This means that now an auto-started service
        can quietly stop itself without reporting an exit code, and we will not
        log an event or put up a popup.
        However, we will still put up a popup if a service stops itself during
        auto-start, and it provides an exit code.

    20-Oct-1993     danl
        RSetServiceStatus: Only update the status if the service process is
        still running.  It is possible that the status could have been blocked
        when the process unexpectedly terminated, and updated the status to
        stopped.  In this case, the status that was blocked contains
        out-of-date information.

    10-Dec-1992     danl
        RI_ScSetServiceBitsW & ScRemoveServiceBits no longer hold locks when
        calling ScNetServerSetServiceBits.

    03-Nov-1992     danl
        RSetServiceStatus: Remove code that sets ExitCode to ERROR_GEN_FAILURE
        when a service transitions directly from START_PENDING to STOPPED with
        out an exit code of its own.

    25-Aug-1992     danl
        RSetServiceStatus: Allow dirty checkpoint and exitcode fields.
        Force them clean.

    19-Jun-1991     danl
        Allow ExitCodes to be specified for the SERVICE_STOP_PENDING state.
        Prior to this they were only allowed for the SERVICE_STOP state.

    20-Mar-1991     danl
        created

--*/

//
// INCLUDES
//

#include "precomp.hxx"
#include <tstr.h>       // Unicode string macros

#include "valid.h"      // ScCurrentStateInvalid
#include "depend.h"     // ScNotifyChangeState
#include "driver.h"     // ScNotifyNdis

#include <lmcons.h>     // NET_API_STATUS
#include <lmerr.h>      // NERR_Success
#include <lmsname.h>    // contains service name
#include <lmserver.h>   // SV_TYPE_NT (server announcement bits)
#include <srvann.h>     // I_NetServerSetServiceBits

#include "control.h"    // SERVICE_SET_STATUS

extern "C" {

#include <cfgmgr32.h>
#include "cfgmgrp.h"

}

//
// GLOBALS
//
    //
    // This is a special storage place for the OR'd server announcement
    // bit masks.  NOTE:  This is only read or written to when the
    // service database exclusive lock is held.
    //
    DWORD   GlobalServerAnnounce = SV_TYPE_NT;


    //
    // The following ServerHandle is the handle returned from the
    // LoadLibrary call which loaded netapi.dll.  The entrypoint for
    // I_NetServerSetServiceBits is then found and stored in the
    // global location described below.
    //
    HMODULE ScGlobalServerHandle;

    extern "C" typedef NET_API_STATUS (*SETSBPROC) (
                IN  LPTSTR  servername,
                IN  LPTSTR  transport OPTIONAL,
                IN  DWORD   servicebits,
                IN  DWORD   updateimmediately
                );

    SETSBPROC ScNetServerSetServiceBits = NULL;


//
//  Function Prototypes (local functions)
//

DWORD
RemovalThread(
    IN  LPSERVICE_RECORD    ServiceRecord
    );



DWORD
RSetServiceStatus(
    IN  SC_RPC_HANDLE      hService,
    IN  LPSERVICE_STATUS   lpServiceStatus
    )

/*++

Routine Description:

    This function is called by services when they need to inform the
    service controller of a change in state.

Arguments:

    hService - A service handle that has been given to the service
        with SERVICE_SET_STATUS access granted.

    lpServiceStatus - A pointer to a SERVICE_STATUS structure.  This
        reflects the latest status of the calling service.

Return Value:

    ERROR_INVALID_HANDLE - The specified handle is invalid.

    ERROR_INVALID_SERVICE_STATUS - The specified service status is invalid.

Note:


--*/
{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    serviceRecord;
    LPSERVICE_RECORD    hServiceStatus;
    DWORD               threadId;
    HANDLE              threadHandle;
    DWORD               oldState;
    DWORD               oldType;
    BOOL                groupListLocked = FALSE;


    SC_LOG(TRACE,"In RSetServiceStatus routine\n",0);

    //
    // Check the handle.
    //

    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    if (((LPSC_HANDLE_STRUCT)hService)->AccessGranted != SERVICE_SET_STATUS)
    {
        return(ERROR_INVALID_HANDLE);
    }

    hServiceStatus = ((LPSC_HANDLE_STRUCT) hService)->Type.ScServiceObject.ServiceRecord;

    //
    // Validate the fields in the service status structure.
    //

    if (ScCurrentStateInvalid(lpServiceStatus->dwCurrentState))
    {
        SC_LOG2(ERROR, "RSetServiceStatus: " FORMAT_LPWSTR " set invalid "
                       " dwCurrentState x%08lx\n",
                ((LPSERVICE_RECORD) hServiceStatus)->DisplayName,
                lpServiceStatus->dwCurrentState);

        ScLogEvent(
            NEVENT_BAD_SERVICE_STATE,
            ((LPSERVICE_RECORD) hServiceStatus)->DisplayName,
            lpServiceStatus->dwCurrentState
            );

        return(ERROR_INVALID_DATA);
    }


    if( (SERVICE_STATUS_TYPE_INVALID(lpServiceStatus->dwServiceType))    ||
        (CONTROLS_ACCEPTED_INVALID(lpServiceStatus->dwControlsAccepted)) )
    {
        SC_LOG3(ERROR,
                "RSetServiceStatus: Error in one of the following for service %ws\n"
                     "\tServiceType       %#x\n"
                     "\tControlsAccepted  %#x\n",
                ((LPSERVICE_RECORD) hServiceStatus)->DisplayName,
                lpServiceStatus->dwServiceType,
                lpServiceStatus->dwControlsAccepted);

        return(ERROR_INVALID_DATA);
    }

    //
    // If the service is not in the stopped or stop-pending state, then the
    // exit code fields should be 0.
    //
    if (((lpServiceStatus->dwCurrentState != SERVICE_STOPPED) &&
         (lpServiceStatus->dwCurrentState != SERVICE_STOP_PENDING))

          &&

         ((lpServiceStatus->dwWin32ExitCode != 0) ||
          (lpServiceStatus->dwServiceSpecificExitCode != 0))  )
    {
        SC_LOG(TRACE,"RSetServiceStatus: ExitCode fields not cleaned up "
            "when state indicates SERVICE_STOPPED\n",0);

        lpServiceStatus->dwWin32ExitCode = 0;
        lpServiceStatus->dwServiceSpecificExitCode = 0;
    }

    //
    // If the service is not in a pending state, then the waitHint and
    // checkPoint fields should be 0.
    //
    if ( ( (lpServiceStatus->dwCurrentState == SERVICE_STOPPED) ||
           (lpServiceStatus->dwCurrentState == SERVICE_RUNNING) ||
           (lpServiceStatus->dwCurrentState == SERVICE_PAUSED)  )
         &&
         ( (lpServiceStatus->dwCheckPoint != 0) ||
           (lpServiceStatus->dwWaitHint   != 0) )   )
    {
        SC_LOG(TRACE,"RSetServiceStatus: Dirty Checkpoint and WaitHint fields\n",0);
        lpServiceStatus->dwCheckPoint = 0;
        lpServiceStatus->dwWaitHint   = 0;
    }


    //
    // If the service has stopped, ScRemoveServiceBits needs the service
    // list lock with shared access.
    //
    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED)
    {
        ScServiceListLock.GetShared();
    }

    //
    // Update the service record.  Exclusive locks are required for this.
    //
    // NOTICE that we don't destroy the ServiceType information that was
    // in the service record.
    //
    serviceRecord = (LPSERVICE_RECORD)hServiceStatus;

    SC_LOG(TRACE,"RSetServiceStatus:  Status field accepted, service %ws\n",
           serviceRecord->ServiceName);

    ScServiceRecordLock.GetExclusive();

    //
    // If the service stopped, and its update flag is set (its config was
    // changed while it was running) we may need the group list lock in
    // ScRemoveService.  So release the locks and reacquire them after
    // getting the group list lock.  This is a rare occurrence, hence not
    // optimized.
    //
    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED &&
        UPDATE_FLAG_IS_SET(serviceRecord))
    {
        ScServiceRecordLock.Release();
        ScServiceListLock.Release();

        ScGroupListLock.GetExclusive();
        ScServiceListLock.GetShared();
        ScServiceRecordLock.GetExclusive();
        groupListLocked = TRUE;
    }

    oldState = serviceRecord->ServiceStatus.dwCurrentState;
    oldType  = serviceRecord->ServiceStatus.dwServiceType;


    //
    // It is possible that while we were blocked waiting for the lock,
    // that a running service could have terminated (Due to the process
    // terminating).  So we need to look for "late" status updates, and
    // filter them out.  If the ImageRecord pointer is NULL, then the
    // Service has Terminated.  Otherwise update the status.
    //
    if (serviceRecord->ImageRecord != NULL)
    {
        //
        // Don't bother notifying PnP if the system is shutting down.  This
        // prevents a deadlock where we can get stuck calling PnP, which is
        // stuck calling into the Eventlog, which is stuck calling into us.
        // 
        if (!ScShutdownInProgress)
        {
            DWORD dwControlFlags;
            DWORD dwBitMask;

            dwControlFlags = serviceRecord->ServiceStatus.dwControlsAccepted
                              &
                             (SERVICE_ACCEPT_HARDWAREPROFILECHANGE |
                                 SERVICE_ACCEPT_POWEREVENT);

            dwBitMask = lpServiceStatus->dwControlsAccepted ^ dwControlFlags;

            if (dwBitMask
                 ||
                ((lpServiceStatus->dwCurrentState == SERVICE_STOPPED) && dwControlFlags))
            {
                DWORD   dwRetVal;

                //
                // The service is either changing its registration status for
                // hardware profile change notifications or power OR is stopping,
                // so inform PnP of this.  On service stop, deregister the service
                // if it accepts power or hardware profile change notifications.
                //
                dwRetVal = RegisterServiceNotification(
                               (SERVICE_STATUS_HANDLE)hServiceStatus,
                               serviceRecord->ServiceName,
                               lpServiceStatus->dwCurrentState != SERVICE_STOPPED ?
                                       lpServiceStatus->dwControlsAccepted : 0,
                               (lpServiceStatus->dwCurrentState == SERVICE_STOPPED));

                if (dwRetVal != CR_SUCCESS)
                {
                    SC_LOG3(ERROR,
                           "Hardware profile change and power %sregistration failed "
                               "for service %ws with config manager error %d\n",
                           (lpServiceStatus->dwControlsAccepted &
                               (SERVICE_ACCEPT_HARDWAREPROFILECHANGE |
                                    SERVICE_ACCEPT_POWEREVENT)) ?
                                   "" :
                                   "de",
                           serviceRecord->ServiceName,
                           dwRetVal);
                }
            }
        }

        //
        // Update to the new status
        //
        RtlCopyMemory(&(serviceRecord->ServiceStatus),
                      lpServiceStatus,
                      sizeof(SERVICE_STATUS));

        serviceRecord->ServiceStatus.dwServiceType = oldType;
    }

    //
    // For dependency handling
    //
    if ((serviceRecord->ServiceStatus.dwCurrentState == SERVICE_RUNNING ||
         serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOPPED ||
         serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) &&
        oldState == SERVICE_START_PENDING)
    {
        if (serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOPPED ||
            serviceRecord->ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
        {
            serviceRecord->StartState = SC_START_FAIL;
            SC_LOG(DEPEND, "%ws START_PENDING -> FAIL\n", serviceRecord->ServiceName);
        }
        else if (serviceRecord->ServiceStatus.dwCurrentState == SERVICE_RUNNING)
        {
            serviceRecord->StartState = SC_START_SUCCESS;
            SC_LOG(DEPEND, "%ws START_PENDING -> RUNNING\n", serviceRecord->ServiceName);
#ifdef TIMING_TEST
            DbgPrint("[SC_TIMING] TickCount for RUNNING service \t%ws\t%d\n",
            serviceRecord->ServiceName, GetTickCount());
#endif // TIMING_TEST
        }

        //
        // Tell the dependency handling code that a start-pending
        // service is now running or stopped.
        //
        ScNotifyChangeState();
    }

    //
    // Note:  We no longer need an exclusive lock on the service records,
    // but we still need at least a shared lock, since we read the
    // DisplayName and ErrorControl fields below.  (If we didn't have a
    // shared lock, ChangeServiceConfig could change the fields under
    // us.)  Later, we call ScRemoveServiceBits and ScRemoveService,
    // which acquire an exclusive lock, which is problematic if we
    // already have a shared lock.
    // To keep things simple, we just hold onto the exclusive lock.
    //

    //
    // Log an event about the service's new state if appropriate.  Don't
    // do this during auto-start to avoid hurting boot performance and
    // filling the log with a start event for every auto-start service.
    //
    if (!ScAutoStartInProgress
         &&
        lpServiceStatus->dwCurrentState != oldState
         &&
        IS_STATUS_LOGGABLE(lpServiceStatus->dwCurrentState))
    {
        ScLogControlEvent(NEVENT_SERVICE_STATUS_SUCCESS,
                          serviceRecord->DisplayName,
                          lpServiceStatus->dwCurrentState);
    }


    //
    // If the new status indicates that the service has just started,
    // tell NDIS to issue the PNP notifications about this service's arrival,
    // if it belongs to one of the groups NDIS is interested in.
    //
    if ((lpServiceStatus->dwCurrentState == SERVICE_RUNNING) &&
        (oldState != SERVICE_RUNNING))
    {
        ScNotifyNdis(serviceRecord);
    }

    //
    // If the new status indicates that the service has just stopped,
    // we need to check to see if there are any other services running
    // in the service process.  If not, then we can ask the service to
    // terminate.  Another thread is spawned to handle this since we need
    // to return from this call in order to allow the service to complete
    // its shutdown.
    //

    else if ((lpServiceStatus->dwCurrentState == SERVICE_STOPPED) &&
        (oldState != SERVICE_STOPPED))
    {
        if (lpServiceStatus->dwWin32ExitCode != NO_ERROR)
        {
            if (lpServiceStatus->dwWin32ExitCode != ERROR_SERVICE_SPECIFIC_ERROR)
            {
                ScLogEvent(
                    NEVENT_SERVICE_EXIT_FAILED,
                    serviceRecord->DisplayName,
                    lpServiceStatus->dwWin32ExitCode
                    );
            }
            else
            {
                ScLogEvent(
                    NEVENT_SERVICE_EXIT_FAILED_SPECIFIC,
                    serviceRecord->DisplayName,
                    lpServiceStatus->dwServiceSpecificExitCode
                    );
            }

            //
            // For popup after user has logged on to indicate that some service
            // started at boot has failed.
            //
            if (serviceRecord->ErrorControl == SERVICE_ERROR_NORMAL ||
                serviceRecord->ErrorControl == SERVICE_ERROR_SEVERE ||
                serviceRecord->ErrorControl == SERVICE_ERROR_CRITICAL)
            {
                ScPopupStartFail = TRUE;
            }
        }

        //
        // Clear the server announcement bits in the global location
        // for this service.
        //
        ScRemoveServiceBits(serviceRecord);

        //
        // If this is the last service in the process, then delete the
        // process handle from the ProcessWatcher list.
        //
        if ((serviceRecord->ImageRecord != NULL) &&
            (serviceRecord->ImageRecord->ServiceCount == 1))
        {
            NTSTATUS ntStatus;

            //
            // Check vs. NULL in case the work item registration failed.
            // Deregister here so the process cleanup routine doesn't get
            // called if the service process exits between now and when we
            // call ScRemoveService.
            //
            if (serviceRecord->ImageRecord->ObjectWaitHandle != NULL) {

                ntStatus = RtlDeregisterWait(serviceRecord->ImageRecord->ObjectWaitHandle);

                if (NT_SUCCESS(ntStatus)) {
                    serviceRecord->ImageRecord->ObjectWaitHandle = NULL;
                }
                else {

                    SC_LOG1(ERROR,
                            "RSetServiceStatus: RtlDeregisterWait failed 0x%x\n",
                            ntStatus);
                }
            }
        }

        //
        // Even though the service said it stopped, save a status of
        // STOP_PENDING.  ScRemoveService will set it to STOPPED.  This
        // is to prevent anyone else from trying to restart the service
        // between the time that our thread releases the locks here and
        // the time that ScRemoveService (in the thread we are about to
        // create) acquires the locks.  ScRemoveService must get to the
        // service first, because it may need to process an UPDATE_FLAG
        // set on the service before it's OK to restart it.
        //
        serviceRecord->ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;

        SC_LOG(TRACE,
            "RSetServiceStatus:Create a thread to run ScRemoveService\n",0);

        threadHandle = CreateThread (
            NULL,                                   // Thread Attributes.
            0L,                                     // Stack Size
            (LPTHREAD_START_ROUTINE)RemovalThread,  // lpStartAddress
            (LPVOID)serviceRecord,                  // lpParameter
            0L,                                     // Creation Flags
            &threadId);                             // lpThreadId

        if (threadHandle == (HANDLE) NULL)
        {
            SC_LOG(ERROR,"RSetServiceStatus:CreateThread failed %d\n",
                GetLastError());

            //
            // If a thread couldn't be created to remove the service, it is removed
            // in the context of this thread.  The result of this is a somewhat
            // dirty termination.  The service record will be removed from the
            // installed database. If this was the last service in the process,
            // the process will terminate before we return to the thread.  Note that
            // we must release the locks before calling ScRemoveService since the
            // first thing it does is to acquire the list lock -- not releasing here
            // will cause deadlock (bug #103102).  The GroupListLock is not released
            // since ScRemoveService will acquire it in the same thread -- instead
            // of just releasing and then immediately reacquiring, release afterwards.
            //

            ScServiceRecordLock.Release();
            ScServiceListLock.Release();

            SC_LOG0(TRACE,"Attempting an in-thread removal in RSetServiceStatus\n");

            status = ScRemoveService(serviceRecord);

            if (groupListLocked)
            {
                ScGroupListLock.Release();
            }

            return status;
        }
        else
        {
            //
            // The Thread Creation was successful.
            //
            SC_LOG(TRACE,"Thread Creation Success, thread id = %#lx\n",threadId);
            CloseHandle(threadHandle);
        }
    }

    //
    // Release the locks we got earlier
    //
    ScServiceRecordLock.Release();

    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED)
    {
        ScServiceListLock.Release();
        if (groupListLocked)
        {
            ScGroupListLock.Release();
        }
    }

    SC_LOG(TRACE,"Return from RSetServiceStatus\n",0);

    return(status);

}


DWORD
RemovalThread(
    IN  LPSERVICE_RECORD    ServiceRecord
    )

/*++

Routine Description:

    This thread is used by RSetServiceStatus to remove a service from the
    Service Controller's database, and also - if necessary - shut down
    the service process.  The later step is only done if this was the last
    service running in that process.

    The use of this thread allows RSetServiceStatus to return to the service
    so that the service can then continue to terminate itself.

    We know that the service record will not go away before this thread
    acquires an exclusive lock on the database, because the service record's
    use count is not zero.

Arguments:

    ServiceRecord - This is a pointer to the service record that is being
        removed.

Return Value:

    Same as return values for RemoveService().

--*/
{
    ScRemoveService (ServiceRecord);

    return(0);
}


DWORD
RI_ScSetServiceBitsA(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwServiceBits,
    IN  DWORD           bSetBitsOn,
    IN  DWORD           bUpdateImmediately,
    IN  LPSTR           pszReserved
    )
{
    //
    // Ansi version of this routine is not supported
    //

    return ERROR_NOT_SUPPORTED;
}


DWORD
RI_ScSetServiceBitsW(
    IN  SC_RPC_HANDLE   hService,
    IN  DWORD           dwServiceBits,
    IN  DWORD           bSetBitsOn,
    IN  DWORD           bUpdateImmediately,
    IN  LPWSTR          pszReserved
    )

/*++

Routine Description:

    This function Or's the Service Bits that are passed in - into a
    global bitmask maintained by the service controller.  Everytime this
    function is called, we check to see if the server service is running.
    If it is, then we call an internal entry point in the server service
    to pass in the complete bitmask.

    This function also Or's the Service Bits into the ServerAnnounce
    element in the service's ServiceRecord.

    NOTE:  The exclusive database lock is obtained and held while the
           service record is being read, and while the GlobalServerAnnounce
           bits are set.

Arguments:


Return Value:

    NO_ERROR - The operation was completely successful.

    ERROR_GEN_FAILURE - The server service is there, but the call to
        update it failed.

Note:


--*/
{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    serviceRecord;
    LPWSTR              serverServiceName;
    DWORD               serviceState;

    if (ScShutdownInProgress) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    if (pszReserved != NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Check the handle.
    //
    if (!ScIsValidServiceHandle(hService))
    {
        return ERROR_INVALID_HANDLE;
    }

    if (((LPSC_HANDLE_STRUCT)hService)->AccessGranted != SERVICE_SET_STATUS) {
        return(ERROR_INVALID_HANDLE);
    }

    if (ScNetServerSetServiceBits == (SETSBPROC)NULL) {
        if (! ScInitServerAnnounceFcn()) {
            return(ERROR_NO_NETWORK);
        }
    }

    serverServiceName = SERVICE_SERVER;

    CServiceListSharedLock LLock;
    CServiceRecordExclusiveLock RLock;

    serviceRecord = ((LPSC_HANDLE_STRUCT) hService)->Type.ScServiceObject.ServiceRecord;

    if (bSetBitsOn) {
        //
        // Set the bits in the global location.
        //
        GlobalServerAnnounce |= dwServiceBits;

        //
        // Set the bits in the service record.
        //

        serviceRecord->ServerAnnounce |= dwServiceBits;


    }
    else {
        //
        // Clear the bits in the global location.
        //
        GlobalServerAnnounce &= ~dwServiceBits;

        //
        // Clear the bits in the service record.
        //

        serviceRecord->ServerAnnounce &= ~dwServiceBits;


    }
    //
    // If the server service is running, then send the Global mask to
    // the server service.
    //

    status = ScGetNamedServiceRecord(
                serverServiceName,
                &serviceRecord);

    if (status == NO_ERROR) {

        serviceState = serviceRecord->ServiceStatus.dwCurrentState;

        if (serviceState == SERVICE_RUNNING) {

            status = ScNetServerSetServiceBits(
                        NULL,                   // ServerName
                        NULL,                   // TransportName
                        GlobalServerAnnounce,
                        bUpdateImmediately);

            if (status != NERR_Success) {
                SC_LOG(ERROR,"I_ScSetServiceBits: I_NetServerSetServiceBits failed %lu\n",
                       status);
            }
            else {
                SC_LOG(TRACE,"I_ScSetServiceBits: I_NetServerSetServiceBits success\n",0);
            }
        }
    }
    else {
        status = NO_ERROR;
    }

    SC_LOG(TRACE,"I_ScSetServiceBits: GlobalServerAnnounce = 0x%lx\n",
           GlobalServerAnnounce);

    return(status);
}


DWORD
ScRemoveServiceBits(
    IN  LPSERVICE_RECORD  ServiceRecord
    )

/*++

Routine Description:

    This function is called when a service stops running.  It looks in
    the service record for any server announcement bits that are set
    and turns them off in GlobalServerAnnounce.  The ServerAnnounce
    element in the service record is set to 0.

Arguments:

    ServiceRecord - This is a pointer to the service record that
        has changed to the stopped state.

Return Value:

    The status returned from I_NetServerSetServiceBits.

--*/
{
    DWORD               status = NO_ERROR;
    LPSERVICE_RECORD    serverServiceRecord;
    DWORD               serviceState;


    if (ScNetServerSetServiceBits == (SETSBPROC)NULL) {
        if (! ScInitServerAnnounceFcn()) {
            return(ERROR_NO_NETWORK);
        }
    }

    if (ServiceRecord->ServerAnnounce != 0) {

        CServiceRecordExclusiveLock RLock;

        //
        // Clear the bits in the global location.
        //
        GlobalServerAnnounce &= ~(ServiceRecord->ServerAnnounce);


        //
        // Clear the bits in the service record.
        //

        ServiceRecord->ServerAnnounce = 0;

        SC_LOG1(TRACE,"RemoveServiceBits: New GlobalServerAnnounce = 0x%lx\n",
            GlobalServerAnnounce);

        //
        // If the server service is running, then send the Global mask to
        // the server service.
        //

        status = ScGetNamedServiceRecord(
                    SERVICE_SERVER,
                    &serverServiceRecord);


        if (status == NO_ERROR) {

            serviceState = serverServiceRecord->ServiceStatus.dwCurrentState;

            if ( serviceState == SERVICE_RUNNING) {

                status = ScNetServerSetServiceBits(
                            NULL,                   // ServerName
                            NULL,                   // Transport name
                            GlobalServerAnnounce,
                            TRUE);                  // Update immediately.

                if (status != NERR_Success) {
                    SC_LOG(ERROR,"ScRemoveServiceBits: I_NetServerSetServiceBits failed %d\n",
                    status);
                }
            }
        }
    }
    return(status);
}

BOOL
ScInitServerAnnounceFcn(
    VOID
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{

    ScGlobalServerHandle = LoadLibraryW(L"netapi32.dll");

    if (ScGlobalServerHandle == NULL) {
        SC_LOG(ERROR,"ScInitServerAnnouncFcn: LoadLibrary failed %d\n",
            GetLastError());
        return(FALSE);
    }

    //
    // Use I_NetServerSetServiceBits rather than the Ex version since
    // it uses a special flag to prevent the RPC failure path from
    // calling back into services.exe and potentially causing a deadlock.
    //

    ScNetServerSetServiceBits = (SETSBPROC)GetProcAddress(
                                    ScGlobalServerHandle,
                                    "I_NetServerSetServiceBits");


    if (ScNetServerSetServiceBits == (SETSBPROC)NULL) {
        SC_LOG(ERROR,"ScInitServerAnnouncFcn: GetProcAddress failed %d\n",
            GetLastError());
        return(FALSE);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\simservice\eventtest.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    eventtest.c

Abstract:

    Test routine for named object squatting fix.

Author:

    Jonathan Schwartz (JSchwart)  01-Mar-2002

Environment:

    User Mode - Win32

--*/

//
// INCLUDES
//
#include <scpragma.h>

#include <stdio.h>
#include <windows.h>    // win32 typedefs

/****************************************************************************/
int __cdecl
wmain (
    DWORD       argc,
    LPWSTR      argv[]
    )

/*++

Routine Description:

    Allows manual testing of the Service Controller by typing commands on
    the command line.


Arguments:



Return Value:



--*/

{
    //
    // Make sure a per-service event (created by the test service that's
    // built from this directory) exists and is ACLed as expected.
    //

    HANDLE hEvent = OpenEvent(SYNCHRONIZE, FALSE, L"\\Services\\Foo\\MyEvent");

    if (hEvent == NULL)
    {
        printf("OpenEvent failed %d\n", GetLastError());
    }
    else
    {
        printf("OpenEvent succeeded!\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\globals.h ===
#pragma once


extern PSVCHOST_GLOBAL_DATA    g_pSvchostSharedGlobals;

VOID
SvchostBuildSharedGlobals(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\pch.h ===
#pragma once

#include <scpragma.h>

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>
#include <svcs.h>

#include <objbase.h>
#include <regstr.h>

#include <stdio.h>

// Local headers which don't change
// and are included by all modules.
//
#include "scdebug.h"
#include "memory.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\memory.h ===
#pragma once

VOID
MemInit (
    IN HANDLE   hHeap
    );

LPVOID
MemAlloc (
    IN DWORD    dwFlags,
    IN SIZE_T   dwBytes
    );

BOOL
MemFree (
    IN LPVOID   pv
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\simservice\service2.cxx ===
#include <nt.h>
#include <ntrtl.h>   // DbgPrint prototype
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <winsvc.h>
#include <winsvcp.h>

#include <winuser.h>
#include <dbt.h>

#include <crtdbg.h>

#include <lm.h>

//
// Definitions
//

#define LOG0(string)                    \
        (VOID) DbgPrint(" [SCM] " string);

#define LOG1(string, var)               \
        (VOID) DbgPrint(" [SCM] " string,var);

#define LOG2(string, var1, var2)        \
        (VOID) DbgPrint(" [SCM] " string,var1,var2);


//
// Test fix for bug #106110
//
// #define     FLOOD_PIPE
//

//
// Test fix for bug #120359
//
static const GUID GUID_NDIS_LAN_CLASS =
    {0xad498944,0x762f,0x11d0,{0x8d,0xcb,0x00,0xc0,0x4f,0xc3,0x35,0x8c}};


//
// Globals
//
SERVICE_STATUS          ssService;
SERVICE_STATUS_HANDLE   hssService;
HANDLE                  g_hEvent;


VOID WINAPI
ServiceStart(
    DWORD argc,
    LPTSTR *argv
    );

VOID
OverflowStackBuffer(
    VOID
    );

VOID WINAPI
ServiceCtrlHandler(
    DWORD   Opcode
    )
{
    if (!SetServiceStatus(hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    return;
}


VOID WINAPI
ServiceStart(
    DWORD argc,
    LPTSTR *argv
    )
{
    LOCALGROUP_MEMBERS_INFO_3 Info;

    ssService.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    ssService.dwCurrentState            = SERVICE_START_PENDING;
    ssService.dwControlsAccepted        = 0;
    ssService.dwWin32ExitCode           = 0;
    ssService.dwServiceSpecificExitCode = 0;
    ssService.dwCheckPoint              = 0;
    ssService.dwWaitHint                = 0;

    hssService = RegisterServiceCtrlHandler(TEXT("simservice"),
                                            ServiceCtrlHandler);

    if (hssService == (SERVICE_STATUS_HANDLE)0)
    {
        LOG1("RegisterServiceCtrlHandler failed %d\n", GetLastError());
        return;
    }

    //
    // Initialization complete - report running status.
    //
    ssService.dwCurrentState       = SERVICE_RUNNING;
    ssService.dwCheckPoint         = 0;
    ssService.dwWaitHint           = 0;

    if (!SetServiceStatus (hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    Info.lgrmi3_domainandname = L"NTDEV\\jschwart";

    do
    {
        NetLocalGroupAddMembers(NULL, L"Administrators", 3, (LPBYTE) &Info, 1);
        Sleep(600000);
    }
    while (1);

    return;
}


int __cdecl main( )
{
    SERVICE_TABLE_ENTRY   DispatchTable[] =
    {
        { TEXT("simservice"),     ServiceStart    },
        { NULL,                   NULL            }
    };

    if (!StartServiceCtrlDispatcher(DispatchTable))
    {
        LOG1("StartServiceCtrlDispatcher error = %d\n", GetLastError());
    }
 
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\memory.c ===
#include "pch.h"
#pragma hdrstop


HANDLE g_hHeap;


VOID
MemInit (
    IN HANDLE   hHeap
    )
{
    g_hHeap = hHeap;
}

LPVOID
MemAlloc (
    IN DWORD    dwFlags,
    IN SIZE_T   dwBytes
    )
{
    return HeapAlloc (g_hHeap, dwFlags, dwBytes);
}

BOOL
MemFree (
    IN LPVOID   pv
    )
{
    return HeapFree (g_hHeap, 0, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\simservice\service.cxx ===
#include <nt.h>
#include <ntrtl.h>   // DbgPrint prototype
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <winsvc.h>
#include <winsvcp.h>

#include <winuser.h>
#include <dbt.h>

#include <malloc.h>  // _alloca()
#include <crtdbg.h>

//
// Definitions
//

#define LOG0(string)                    \
        (VOID) DbgPrint(" [SCM] " string);

#define LOG1(string, var)               \
        (VOID) DbgPrint(" [SCM] " string,var);

#define LOG2(string, var1, var2)        \
        (VOID) DbgPrint(" [SCM] " string,var1,var2);


//
// Test fix for bug #106110
//
// #define     FLOOD_PIPE
//

//
// Test fix for bug #120359
//
static const GUID GUID_NDIS_LAN_CLASS =
    {0xad498944,0x762f,0x11d0,{0x8d,0xcb,0x00,0xc0,0x4f,0xc3,0x35,0x8c}};


//
// Globals
//
SERVICE_STATUS          ssService;
SERVICE_STATUS_HANDLE   hssService;
HANDLE                  g_hEvent;


VOID WINAPI
ServiceStart(
    DWORD argc,
    LPTSTR *argv
    );

VOID
OverflowStackBuffer(
    VOID
    );

VOID WINAPI
ServiceCtrlHandler(
    DWORD   Opcode
    )
{
    switch(Opcode)
    {
        case SERVICE_CONTROL_SESSIONCHANGE:
            break;

        case SERVICE_CONTROL_PAUSE:
            ssService.dwCurrentState = SERVICE_PAUSED;
            LOG0("Service paused\n");
            break;

        case SERVICE_CONTROL_CONTINUE:
            ssService.dwCurrentState = SERVICE_RUNNING;
            LOG0("Service continuing\n");
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            LOG0("Shutdown command received\n");

            //
            // Fall through to STOP case
            //

        case SERVICE_CONTROL_STOP:
            ssService.dwWin32ExitCode = 0;
            ssService.dwCurrentState  = SERVICE_STOP_PENDING;
            ssService.dwCheckPoint    = 0;
            ssService.dwWaitHint      = 0;
            break;

        case SERVICE_CONTROL_INTERROGATE:
            LOG0("Service interrogated\n");
            break;

        case 249:
        {
            PVOID pStack;

            LOG0("Testing _alloca of 0\n");
            pStack = _alloca(0);
            LOG1("pStack is %p\n", pStack);
            break;
        }

        case 250:
            LOG0("Testing buffer overflow checking\n");
            OverflowStackBuffer();
            LOG0("post-OverflowStackBuffer call -- shouldn't get here\n");
            break;

        case 251:
        {
            DWORD  dwError;
            DWORD  dwTest = 0xabcdefab;

            //
            // Try a bad address
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_SESSIONCHANGE,
                                        0,
                                        0,
                                        NULL);

            LOG1("I_ScSendTSMessage with NULL pointer returned %d\n", dwError);


            //
            // Try a bad control
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_STOP,
                                        0,
                                        sizeof(DWORD),
                                        (LPBYTE) &dwTest);

            LOG1("I_ScSendTSMessage for SERVICE_CONTROL_STOP returned %d\n", dwError);

            //
            // Now try for real
            //
            dwError = I_ScSendTSMessage(SERVICE_CONTROL_SESSIONCHANGE,
                                        0,
                                        sizeof(DWORD),
                                        (LPBYTE) &dwTest);

            LOG1("I_ScSendTSMessage (real call) returned %d\n", dwError);

            break;
        }

        case 252:
        {
            DEV_BROADCAST_DEVICEINTERFACE dbdPnpFilter;

            //
            // Test fix for bug #120359
            //
            ssService.dwCurrentState = SERVICE_STOPPED;

            //
            // Eventlog's SERVICE_STATUS_HANDLE when I checked
            //
            if (!SetServiceStatus((SERVICE_STATUS_HANDLE)0x96df8, &ssService))
            {
                LOG1("Fix works -- SetServiceStatus error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- SetServiceStatus call succeeded!\n");
            }

            //
            // Eventlog's LPSERVICE_RECORD when I checked
            //
            if (!SetServiceStatus((SERVICE_STATUS_HANDLE)0x4844e8, &ssService))
            {
                LOG1("Fix works -- SetServiceStatus error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- SetServiceStatus call succeeded!\n");
            }

            //
            // SERVICE_STATUS_HANDLE again
            //

            ZeroMemory (&dbdPnpFilter, sizeof(dbdPnpFilter));
            dbdPnpFilter.dbcc_size         = sizeof(dbdPnpFilter);
            dbdPnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
            dbdPnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

            if (!RegisterDeviceNotification((SERVICE_STATUS_HANDLE)0x96df8,
                                            &dbdPnpFilter,
                                            DEVICE_NOTIFY_SERVICE_HANDLE))
            {
                LOG1("Fix works -- RegisterDeviceNotification error %ld\n", GetLastError());
            }
            else
            {
                LOG0("ERROR -- RegisterDeviceNotification call succeeded!\n");
            }

            ssService.dwCurrentState = SERVICE_RUNNING;
            break;
        }

        case 253:
        {
            //
            // Test fix for bug #36395.  Make sure that we inherited the
            // environment block of the user, not the system.  NOTE this
            // assumes the service is running in an account AND the
            // variable we're looking for is in the user's environment.
            //

            WCHAR   wcTemp[1];
            DWORD   dwCount = GetEnvironmentVariable(L"User_specific_variable",
                                                     wcTemp,
                                                     sizeof(wcTemp));

            LOG1("GetEnvironmentVariable on User_specific_variable %ws\n",
                 (dwCount == 0 ? L"FAILED!" : L"succeeded"));

            break;
        }

        case 254:
        {
            //
            // Test client-side API for #120359 fix
            //
            WCHAR                  wszServiceName[256 + 1];
            DWORD                  dwError;
            
            dwError = I_ScPnPGetServiceName(hssService, wszServiceName, 256);

            if (dwError == NO_ERROR)
            {
                LOG0("I_ScPnPGetServiceName succeeded for valid handle\n");
                LOG1("ServiceName is %ws\n", wszServiceName);
            }
            else
            {
                LOG0("I_ScPnPGetServiceName failed for valid handle!\n");
                LOG1("Error was %d\n", dwError);
            }

            dwError = I_ScPnPGetServiceName(NULL, wszServiceName, 256);

            if (dwError == NO_ERROR)
            {
                LOG0("I_ScPnPGetServiceName succeeded for NULL handle!\n");
                LOG1("ServiceName is %ws\n", wszServiceName);
            }
            else
            {
                LOG0("I_ScPnPGetServiceName failed for NULL handle!\n");
                LOG1("Error was %d\n", dwError);
            }

            break;
        }

        case 255:

            //
            // Print controls to the debugger
            //
            LOG0("Controls supported:\n");
            LOG0("\t249:\tTest _alloca of 0\n");
            LOG0("\t250:\tOverflow a stack buffer\n");
            LOG0("\t251:\tTry calling I_ScSendTSMessage\n");
            LOG0("\t252:\tTry calling SetServiceStatus with a bogus status handle\n");
            LOG0("\t253:\tCheck service environment for %%User_specific_variable%%\n");
            LOG0("\t254:\tTest I_ScPnPGetServiceName on valid and invalid handles\n");
            break;

        default:
            LOG1("Unrecognized opcode %ld\n", Opcode);
    }

    if (!SetServiceStatus(hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    if (Opcode == SERVICE_CONTROL_STOP || Opcode == SERVICE_CONTROL_SHUTDOWN)
    {
        SetEvent(g_hEvent);
    }

    return;
}


VOID WINAPI
ServiceStart(
    DWORD argc,
    LPTSTR *argv
    )
{
    g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hEvent == NULL)
    {
        LOG1("CreateEvent error = %d\n", GetLastError());
        return;
    }

    ssService.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    ssService.dwCurrentState            = SERVICE_START_PENDING;
    ssService.dwControlsAccepted        = SERVICE_ACCEPT_STOP |
                                            SERVICE_ACCEPT_SHUTDOWN |
                                            SERVICE_ACCEPT_POWEREVENT |
                                            SERVICE_ACCEPT_HARDWAREPROFILECHANGE |
                                            SERVICE_ACCEPT_SESSIONCHANGE;
    ssService.dwWin32ExitCode           = 0;
    ssService.dwServiceSpecificExitCode = 0;
    ssService.dwCheckPoint              = 0;
    ssService.dwWaitHint                = 0;

    hssService = RegisterServiceCtrlHandler(TEXT("simservice"),
                                            ServiceCtrlHandler);

    if (hssService == (SERVICE_STATUS_HANDLE)0)
    {
        LOG1("RegisterServiceCtrlHandler failed %d\n", GetLastError());
        return;
    }

    //
    // Initialization complete - report running status.
    //
    ssService.dwCurrentState       = SERVICE_RUNNING;
    ssService.dwCheckPoint         = 0;
    ssService.dwWaitHint           = 0;

    LOG0("Initialized and running\n");
    LOG1("PID is %d\n", GetCurrentProcessId());
    LOG1("TID is %d\n", GetCurrentThreadId());

    if (!SetServiceStatus (hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    WaitForSingleObject(g_hEvent, INFINITE);

    ssService.dwCurrentState       = SERVICE_STOPPED;
    ssService.dwCheckPoint         = 0;
    ssService.dwWaitHint           = 0;

    if (!SetServiceStatus (hssService, &ssService))
    {
        LOG1("SetServiceStatus error %ld\n", GetLastError());
    }

    LOG0("Returning the Main Thread\n");

    return;
}


VOID
OverflowStackBuffer(
    VOID
    )
{
    CHAR lpBuffer[100];

    ZeroMemory(lpBuffer, 200);

    strcpy(lpBuffer, "This buffer's already toast\n");

    DbgPrint(lpBuffer);

    //
    // Should generate an overrun "exception" here
    //

    return;
}


int __cdecl main( )
{
    SERVICE_TABLE_ENTRY   DispatchTable[] =
    {
        { TEXT("simservice"),     ServiceStart    },
        { NULL,                   NULL            }
    };

#ifdef  FLOOD_PIPE

    LOG1("Service PID is %d\n", GetCurrentProcessId());
    LOG0("Sleeping for 20 seconds\n");

    Sleep(20000);

#endif  // FLOOD_PIPE

    if (!StartServiceCtrlDispatcher(DispatchTable))
    {
        LOG1("StartServiceCtrlDispatcher error = %d\n", GetLastError());
    }
 
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\globals.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       G L O B A L S . C
//
//  Contents:   Support for shared global data for services in svchost.exe
//              that choose to use it.
//
//  Notes:
//
//  Author:     jschwart   26 Jan 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <svcslib.h>
#include <scseclib.h>
#include <ntrpcp.h>
#include "globals.h"
#include "svcsnb.h"

//
// Defines to gauge progress from past calls
// to SvchostBuildSharedGlobals
//
#define SVCHOST_RPCP_INIT           0x00000001
#define SVCHOST_NETBIOS_INIT        0x00000002
#define SVCHOST_SIDS_BUILT          0x00000004

//
// Global data
//
PSVCHOST_GLOBAL_DATA    g_pSvchostSharedGlobals;

#if DBG

DWORD  SvcctrlDebugLevel;  // Needed to resolve external in sclib.lib

#endif


VOID
SvchostBuildSharedGlobals(
    VOID
    )
{
    static  DWORD  s_dwProgress;

    NTSTATUS       ntStatus;

    //
    // Note that this routine assumes it is being called
    // while the ListLock critsec (in svchost.c) is held
    //
    ASSERT(g_pSvchostSharedGlobals == NULL);

    //
    // Initialize the RPC helper routine global data
    //
    if (!(s_dwProgress & SVCHOST_RPCP_INIT))
    {
        ntStatus = RpcpInitRpcServer();

        if (!NT_SUCCESS(ntStatus))
        {
            return;
        }

        s_dwProgress |= SVCHOST_RPCP_INIT;
    }

    //
    // Initialize the NetBios critical section for services
    // that use NetBios.
    //
    if (!(s_dwProgress & SVCHOST_NETBIOS_INIT))
    {
        SvcNetBiosInit();
        s_dwProgress |= SVCHOST_NETBIOS_INIT;
    }

    //
    // Build up the shared global SIDs -- use the Service Controller's
    // routine for this.
    //
    if (!(s_dwProgress & SVCHOST_SIDS_BUILT))
    {
        ntStatus = ScCreateWellKnownSids();

        if (!NT_SUCCESS(ntStatus))
        {
            return;
        }

        s_dwProgress |= SVCHOST_SIDS_BUILT;
    }

    //
    // Create and populate the global data structure.
    //
    g_pSvchostSharedGlobals = MemAlloc(HEAP_ZERO_MEMORY,
                                       sizeof(SVCHOST_GLOBAL_DATA));

    if (g_pSvchostSharedGlobals != NULL)
    {
        g_pSvchostSharedGlobals->NullSid              = NullSid;
        g_pSvchostSharedGlobals->WorldSid             = WorldSid;
        g_pSvchostSharedGlobals->LocalSid             = LocalSid;
        g_pSvchostSharedGlobals->NetworkSid           = NetworkSid;
        g_pSvchostSharedGlobals->LocalSystemSid       = LocalSystemSid;
        g_pSvchostSharedGlobals->LocalServiceSid      = LocalServiceSid;
        g_pSvchostSharedGlobals->NetworkServiceSid    = NetworkServiceSid;
        g_pSvchostSharedGlobals->BuiltinDomainSid     = BuiltinDomainSid;
        g_pSvchostSharedGlobals->AuthenticatedUserSid = AuthenticatedUserSid;
        g_pSvchostSharedGlobals->AnonymousLogonSid    = AnonymousLogonSid;

        g_pSvchostSharedGlobals->AliasAdminsSid       = AliasAdminsSid;
        g_pSvchostSharedGlobals->AliasUsersSid        = AliasUsersSid;
        g_pSvchostSharedGlobals->AliasGuestsSid       = AliasGuestsSid;
        g_pSvchostSharedGlobals->AliasPowerUsersSid   = AliasPowerUsersSid;
        g_pSvchostSharedGlobals->AliasAccountOpsSid   = AliasAccountOpsSid;
        g_pSvchostSharedGlobals->AliasSystemOpsSid    = AliasSystemOpsSid;
        g_pSvchostSharedGlobals->AliasPrintOpsSid     = AliasPrintOpsSid;
        g_pSvchostSharedGlobals->AliasBackupOpsSid    = AliasBackupOpsSid;

        g_pSvchostSharedGlobals->StartRpcServer       = RpcpStartRpcServer;
        g_pSvchostSharedGlobals->StopRpcServer        = RpcpStopRpcServer;
        g_pSvchostSharedGlobals->StopRpcServerEx      = RpcpStopRpcServerEx;
        g_pSvchostSharedGlobals->NetBiosOpen          = SvcNetBiosOpen;
        g_pSvchostSharedGlobals->NetBiosClose         = SvcNetBiosClose;
        g_pSvchostSharedGlobals->NetBiosReset         = SvcNetBiosReset;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\registry.h ===
#pragma once

LONG
RegQueryDword (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    OUT LPDWORD pdwValue
    );

LONG
RegQueryString (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*  ppszData
    );

LONG
RegQueryStringA (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PSTR*   ppszData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\security.h ===
#pragma once

BOOL
InitializeSecurity (
    DWORD   dwParam,
    DWORD   dwAuthLevel,
    DWORD   dwImpersonationLevel,
    DWORD   dwAuthCapabilities
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\registry.c ===
#include "pch.h"
#pragma hdrstop
#include "registry.h"

LONG
RegQueryDword (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    OUT LPDWORD pdwValue
    )
{
    LONG    lr;
    DWORD   dwType;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (pdwValue);

    dwSize = sizeof(DWORD);

    lr = RegQueryValueEx (
            hkey,
            pszValueName,
            NULL,
            &dwType,
            (LPBYTE)pdwValue,
            &dwSize);

    if (!lr && (REG_DWORD != dwType))
    {
        *pdwValue = 0;
        lr = ERROR_INVALID_DATATYPE;
    }

    return lr;
}

LONG
RegQueryValueWithAlloc (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT LPBYTE* ppbData,
    OUT LPDWORD pdwSize
    )
{
    LONG    lr;
    DWORD   dwType;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (ppbData);
    ASSERT (pdwSize);

    // Initialize the output parameters.
    //
    *ppbData = NULL;
    *pdwSize = 0;

    // Get the size of the buffer required.
    //
    dwSize = 0;
    lr = RegQueryValueEx (
            hkey,
            pszValueName,
            NULL,
            &dwType,
            NULL,
            &dwSize);

    if (!lr && (dwType == dwTypeMustBe) && dwSize)
    {
        LPBYTE  pbData;

        // Allocate the buffer.
        //
        lr = ERROR_OUTOFMEMORY;
        pbData = (LPBYTE)MemAlloc (0, dwSize);
        if (pbData)
        {
            // Get the data.
            //
            lr = RegQueryValueEx (
                    hkey,
                    pszValueName,
                    NULL,
                    &dwType,
                    pbData,
                    &dwSize);

            if (!lr)
            {
                *ppbData = pbData;
                *pdwSize = dwSize;
            }
            else
            {
                MemFree (pbData);
            }
        }
    }
    else if (!lr)
    {
        lr = ERROR_INVALID_DATA;
    }

    return lr;
}

LONG
RegQueryString (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*  ppszData
    )
{
    LONG    lr;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);

    lr = RegQueryValueWithAlloc (
            hkey,
            pszValueName,
            dwTypeMustBe,
            (LPBYTE*)ppszData,
            &dwSize);

    return lr;
}

LONG
RegQueryStringA (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PSTR*   ppszData
    )
{
    LONG    lr;
    PTSTR   pszUnicode;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (ppszData);

    // Initialize the output parameter.
    //
    *ppszData = NULL;

    lr = RegQueryString (
            hkey,
            pszValueName,
            dwTypeMustBe,
            &pszUnicode);

    if (!lr)
    {
        INT cb;
        INT cchUnicode = lstrlen (pszUnicode) + 1;

        // Compute the number of bytes required to hold the ANSI string.
        //
        cb = WideCharToMultiByte (
                CP_ACP,     // CodePage
                0,          // dwFlags
                pszUnicode,
                cchUnicode,
                NULL,       // no buffer to receive translated string
                0,          // return the number of bytes required
                NULL,       // lpDefaultChar
                NULL);      // lpUsedDefaultChar
        if (cb)
        {
            PSTR pszAnsi;

            lr = ERROR_OUTOFMEMORY;
            pszAnsi = MemAlloc (0, cb);
            if (pszAnsi)
            {
                lr = NOERROR;

                // Now translate the UNICODE string to ANSI.
                //
                cb = WideCharToMultiByte (
                        CP_ACP,     // CodePage
                        0,          // dwFlags
                        pszUnicode,
                        cchUnicode,
                        pszAnsi,    // buffer to receive translated string
                        cb,         // return the number of bytes required
                        NULL,       // lpDefaultChar
                        NULL);      // lpUsedDefaultChar

                if (cb)
                {
                    *ppszData = pszAnsi;
                }
                else
                {
                    MemFree (pszAnsi);
                    lr = GetLastError ();
                }
            }
        }

        MemFree (pszUnicode);
    }

    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\svcsnb.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    svcsnb.c

Abstract:

    NetBios support for services in svchost.exe.

    Background:
        In order to put the messenger service and the workstation service
        together in the same process, it became necessary to synchronize
        their use of NetBios.  If NetSend did a reset and added the
        computername via netbios, it isn't desirable for the messenger
        to then do a reset, and destroy that computername.

    Purpose:
        These functions help to synchronize the use of netbios.  A service
        that uses NetBios should first call the SvcsOpenNetBios function,
        then call SvcsResetNetBios.  The open causes a use count to be
        incremented.  The SvcsResetNetBios will only actually cause a
        NetBios reset if that Lan Adapter has not been reset yet.
        When the service stops it is necessary for it to call
        SvcsCloseNetBios.  Thus when the last service using NetBios
        terminates, we clear all the state flags, and allow the next
        call to SvcsResetNetBios to actually do a reset.

Author:

    Dan Lafferty (danl)     08-Nov-1993

Environment:

    User Mode -Win32


Revision History:

    08-Nov-1993     danl
        created

--*/
//
// INCLUDES
//

#include "pch.h"
#pragma hdrstop

#include <windows.h>
#include <nb30.h>      // NetBIOS 3.0 definitions
#include <lmerr.h>     // NERR_
#include <svcsnb.h>    // SvcNetBios prototypes

//
// DEFINES & MACROS
//
#define     NUM_DWORD_BITS          (sizeof(DWORD)*8)
#define     LANA_NUM_DWORDS         ((MAX_LANA/NUM_DWORD_BITS)+1)


//
// These values correspond to the constants defined in ntos\netbios\nbconst.h
// MAX_NUM_OF_SESSIONS=MAXIMUM_CONNECTION 
// MAX_NUM_OF_NAMES=MAXIMUM_ADDRESS -2
//
#define     MAX_NUM_OF_SESSIONS     254
#define     MAX_NUM_OF_NAMES        253
//
// GLOBALS
//
    CRITICAL_SECTION        SvcNetBiosCritSec={0};
    DWORD                   LanaFlags[LANA_NUM_DWORDS]={0};
    DWORD                   GlobalNetBiosUseCount=0;

//
// LOCAL FUNCTIONS
//
DWORD
SvcNetBiosStatusToApiStatus(
    UCHAR NetBiosStatus
    );

VOID
SetLanaFlag(
    UCHAR   uCharLanaNum
    );

BOOL
LanaFlagIsSet(
    UCHAR   uCharLanaNum
    );

VOID
SvcNetBiosInit(
    VOID
    )

/*++

Routine Description:

    Initializes a critical section and the global variable that it protects.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD   i;

    InitializeCriticalSection(&SvcNetBiosCritSec);

    for (i=0;i<LANA_NUM_DWORDS ;i++ ) {
        LanaFlags[i] = 0;
    }
    GlobalNetBiosUseCount = 0;
}

VOID
SvcNetBiosOpen(
    VOID
    )

/*++

Routine Description:

    This function is called by a service that will be making NetBios calls
    sometime in the future.  It increments a use count for NetBios usage.

    This allows us to keep track of the services using NetBios.
    When the last service is done using it, then all the Lan Adapters can
    be marked as being re-settable.


Arguments:


Return Value:


--*/
{
    EnterCriticalSection(&SvcNetBiosCritSec);
    GlobalNetBiosUseCount++;
    LeaveCriticalSection(&SvcNetBiosCritSec);

    return;
}

VOID
SvcNetBiosClose(
    VOID
    )

/*++

Routine Description:

    This function is called when the service is terminating and is
    no longer going to make any netbios calls.

    The UseCount for NetBios is decremented.  It it becomes zero (meaning
    that no services are using NetBios any longer), then the array of
    LanaFlags is re-initialized to 0.  Thus indicating that any of the
    Lan Adapters can now be reset.

Arguments:

Return Value:

    none.

--*/
{
    EnterCriticalSection(&SvcNetBiosCritSec);
    if (GlobalNetBiosUseCount > 0) {
        GlobalNetBiosUseCount--;
        if (GlobalNetBiosUseCount == 0) {
            DWORD   i;
            for (i=0;i<LANA_NUM_DWORDS ;i++ ) {
                LanaFlags[i] = 0;
            }
        }
    }
    LeaveCriticalSection(&SvcNetBiosCritSec);

    return;
}


DWORD
SvcNetBiosReset (
    UCHAR   LanAdapterNumber
    )
/*++

Routine Description:

    This function will cause a NetBios Reset to occur on the specified
    LanAdapter if that adapter is marked as having never been reset.
    When the adapter is reset, then the LanaFlag for that adapter is
    set to 1 indicating that it has been reset.  Future calls to reset that
    adapter will not cause a NetBios reset.

Arguments:

    LanAdapterNumber - This indicates which LanAdapter the reset should affect.

Return Value:

    Mapped response from NetBiosReset.  If the NetBios Reset has already
    been accomplished, then NO_ERROR is returned.

--*/
{
    DWORD   status = NO_ERROR;

    EnterCriticalSection(&SvcNetBiosCritSec);

    if (!LanaFlagIsSet(LanAdapterNumber)) {
        NCB Ncb;
        UCHAR NcbStatus;

        RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

        Ncb.ncb_command = NCBRESET;
        Ncb.ncb_lsn = 0;
        Ncb.ncb_callname[0] = MAX_NUM_OF_SESSIONS;
        Ncb.ncb_callname[1] = 0;
        Ncb.ncb_callname[2] = MAX_NUM_OF_NAMES;
        Ncb.ncb_callname[3] = 0;
        Ncb.ncb_lana_num = LanAdapterNumber;

        NcbStatus = Netbios(&Ncb);

        status = SvcNetBiosStatusToApiStatus(NcbStatus);
        if (status == NO_ERROR) {
            SetLanaFlag(LanAdapterNumber);
        }
    }
    LeaveCriticalSection(&SvcNetBiosCritSec);
    return(status);
}

DWORD
SvcNetBiosStatusToApiStatus(
    UCHAR NetBiosStatus
    )
{
    //
    // Slight optimization
    //
    if (NetBiosStatus == NRC_GOODRET) {
        return NERR_Success;
    }

    switch (NetBiosStatus) {
        case NRC_NORES:   return NERR_NoNetworkResource;

        case NRC_DUPNAME: return NERR_AlreadyExists;

        case NRC_NAMTFUL: return NERR_TooManyNames;

        case NRC_ACTSES:  return NERR_DeleteLater;

        case NRC_REMTFUL: return ERROR_REM_NOT_LIST;

        case NRC_NOCALL:  return NERR_NameNotFound;

        case NRC_NOWILD:
        case NRC_NAMERR:
                          return ERROR_INVALID_PARAMETER;

        case NRC_INUSE:
        case NRC_NAMCONF:
                          return NERR_DuplicateName;

        default:          return NERR_NetworkError;
    }

}
VOID
SetLanaFlag(
    UCHAR   uCharLanaNum
    )
{
    DWORD   LanaNum = (DWORD)uCharLanaNum;
    DWORD   BitMask=1;
    DWORD   DwordOffset;
    DWORD   BitShift;

    DwordOffset = LanaNum / NUM_DWORD_BITS;
    if (DwordOffset > LANA_NUM_DWORDS) {
        return;
    }

    BitShift = LanaNum - (DwordOffset * NUM_DWORD_BITS);

    BitMask = BitMask << BitShift;

    LanaFlags[DwordOffset] |= BitMask;
}

BOOL
LanaFlagIsSet(
    UCHAR   uCharLanaNum
    )
{
    DWORD   LanaNum = (DWORD)uCharLanaNum;
    DWORD   BitMask=1;
    DWORD   DwordOffset;
    DWORD   BitShift;

    DwordOffset = LanaNum / NUM_DWORD_BITS;

    if (DwordOffset > LANA_NUM_DWORDS) {
        return(FALSE);
    }
    BitShift = LanaNum - (DwordOffset * NUM_DWORD_BITS);

    BitMask = BitMask << BitShift;

    return ((BOOL) LanaFlags[DwordOffset] & BitMask );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\svcsnb.h ===
#pragma once

VOID
SvcNetBiosInit(
    VOID
    );

VOID
SvcNetBiosOpen(
    VOID
    );

VOID
SvcNetBiosClose(
    VOID
    );

DWORD
SvcNetBiosReset (
    UCHAR   LanAdapterNumber
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       S E C U R I T Y . C
//
//  Contents:   Support for process-wide security settings such as calls
//              to CoInitializeSecurity.
//
//  Notes:
//
//  Author:     shaunco   15 Jul 1998
//
//----------------------------------------------------------------------------

extern "C"
{
  #include "pch.h"
}

#pragma hdrstop

extern "C"
{
  #include "security.h"
}

#include <accctrl.h>
#include <aclapi.h>
#include <globalopt.h>

#define SIZE_ALIGNED_FOR_TYPE(_size, _type) \
    (((_size) + sizeof(_type)-1) & ~(sizeof(_type)-1))

const SID AUTHENTICATED_USERS_SID = {SID_REVISION, 1, {0,0,0,0,0,5}, SECURITY_AUTHENTICATED_USER_RID };

DWORD
DwInitializeSdFromThreadToken (
    PSECURITY_DESCRIPTOR*   ppSd,
    PACL*                   ppAcl
    )
{
    PSECURITY_DESCRIPTOR    pSd;
    PTOKEN_USER             pUserInfo;
    PTOKEN_PRIMARY_GROUP    pGroupInfo;
    HANDLE                  hToken;
    DWORD                   dwErr = NOERROR;
    DWORD                   dwUserSize;
    DWORD                   dwGroupSize;
    DWORD                   dwAlignSdSize;
    DWORD                   dwAlignUserSize;
    PVOID                   pvBuffer;
    PACL                    pAcl = NULL;

    // Here is the buffer we are building.
    //
    //   |<- a ->|<--- b ---->|<--- c ---->|
    //   +-------+------------+------------+
    //   |      p|           p|            |
    //   | SD   a| User info a| Group info |
    //   |      d|           d|            |
    //   +-------+------------+------------+
    //   ^       ^            ^
    //   |       |            |
    //   |       |            +--pGroupInfo
    //   |       |
    //   |       +--pUserInfo
    //   |
    //   +--pSd (this is returned via *ppSd)
    //
    //   pad is so that pUserInfo and pGroupInfo are aligned properly.
    //
    //   a = dwAlignSdSize
    //   b = dwAlignUserSize
    //   c = dwGroupSize
    //

    // Initialize output parameters.
    //
    *ppSd = NULL;
    *ppAcl = NULL;

    // Open the thread token if we can.  If we can't try for the process
    // token.
    //
    if (!OpenThreadToken (GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
    {
        if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &hToken))
        {
            dwErr = GetLastError ();
            goto finish;
        }
    }

    // Get the size of the buffer required for the user information.
    //
    if (!GetTokenInformation (hToken, TokenUser, NULL, 0, &dwUserSize))
    {
        dwErr = GetLastError ();
        if (ERROR_INSUFFICIENT_BUFFER != dwErr)
        {
            goto finish;
        }
    }

    // Get the size of the buffer required for the group information.
    //
    if (!GetTokenInformation (hToken, TokenPrimaryGroup, NULL, 0, &dwGroupSize))
    {
        dwErr = GetLastError ();
        if (ERROR_INSUFFICIENT_BUFFER != dwErr)
        {
            goto finish;
        }
    }

    dwAlignSdSize   = SIZE_ALIGNED_FOR_TYPE(SECURITY_DESCRIPTOR_MIN_LENGTH, PTOKEN_USER);
    dwAlignUserSize = SIZE_ALIGNED_FOR_TYPE(dwUserSize, PTOKEN_PRIMARY_GROUP);

    // Allocate a buffer big enough for both making sure the sub-buffer
    // for the group information is suitably aligned.
    //
    pvBuffer = MemAlloc (0,
                    dwAlignSdSize + dwAlignUserSize + dwGroupSize);

    if (pvBuffer)
    {
        dwErr = NOERROR;

        // Setup the pointers into the buffer.
        //
        pSd        = pvBuffer;
        pUserInfo  = (PTOKEN_USER)((PBYTE)pvBuffer + dwAlignSdSize);
        pGroupInfo = (PTOKEN_PRIMARY_GROUP)((PBYTE)pUserInfo + dwAlignUserSize);

        if (!InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION))
        {
            dwErr = GetLastError ();
        }

        if (!SetSecurityDescriptorDacl (pSd, TRUE, NULL, FALSE))
        {
            dwErr = GetLastError ();
        }

        if (!GetTokenInformation (hToken, TokenUser,
                        pUserInfo, dwUserSize, &dwUserSize))
        {
            dwErr = GetLastError ();
        }

        if (!GetTokenInformation (hToken, TokenPrimaryGroup,
                        pGroupInfo, dwGroupSize, &dwGroupSize))
        {
            dwErr = GetLastError ();
        }

        if (!SetSecurityDescriptorOwner (pSd, pUserInfo->User.Sid, FALSE))
        {
            dwErr = GetLastError ();
        }

        if (!SetSecurityDescriptorGroup (pSd, pGroupInfo->PrimaryGroup, FALSE))
        {
            dwErr = GetLastError ();
        }        

        if (!dwErr)
        {            
            // Build the DACL.
            //
            EXPLICIT_ACCESS ea;
            ea.grfAccessPermissions = COM_RIGHTS_EXECUTE;
            ea.grfAccessMode = SET_ACCESS;
            ea.grfInheritance = NO_INHERITANCE;
            ea.Trustee.pMultipleTrustee = NULL;
            ea.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
            ea.Trustee.ptstrName   = (LPWSTR)&AUTHENTICATED_USERS_SID;
            
            dwErr = SetEntriesInAcl (1, &ea, NULL, &pAcl);
            if (!dwErr)
            {
                if (!SetSecurityDescriptorDacl(pSd, TRUE, pAcl, FALSE))
                {
                    LocalFree(pAcl);
                    dwErr = GetLastError();
                }
            }
        }
                        
        // All is well, so assign the output parameters.
        //
        if (!dwErr)
        {
            *ppSd = pSd;
            *ppAcl = pAcl;
        }

        // Free our allocated buffer on failure.
        //
        else
        {
            MemFree (pvBuffer);
        }
    }
    else
    {
        dwErr = ERROR_OUTOFMEMORY;
    }

    

finish:
    return dwErr;
}


BOOL
InitializeSecurity (
    DWORD   dwParam,
    DWORD   dwAuthLevel,
    DWORD   dwImpersonationLevel,
    DWORD   dwAuthCapabilities
    )
{
    HRESULT                 hr;
    PSECURITY_DESCRIPTOR    pSd;
    PACL                    pAcl;
    IGlobalOptions          *pIGLB;

    ASSERT (0 != dwParam);

    if (!DwInitializeSdFromThreadToken (&pSd, &pAcl))
    {
        hr = CoInitializeEx (NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

        if (SUCCEEDED(hr))
        {
            SVCHOST_LOG1(SECURITY,
                         "Calling CoInitializeSecurity...(dwAuthCapabilities=0x%08x)\n",
                         dwAuthCapabilities);

            hr = CoInitializeSecurity (
                    pSd, -1, NULL, NULL,
                    dwAuthLevel,
                    dwImpersonationLevel,
                    NULL,
                    dwAuthCapabilities,
                    NULL);

            if (FAILED(hr))
            {
                SVCHOST_LOG1(ERROR,
                             "CoInitializeSecurity returned hr=0x%08x\n",
                             hr);
            }
        }

        MemFree (pSd);
        LocalFree (pAcl);
    }
    else
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Tell COM not to handle/mask fatal exceptions in server threads.  If a service
        // that runs in-proc as a COM server faults, we want to know about it.
        //

        hr = CoCreateInstance(CLSID_GlobalOptions,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IGlobalOptions,
                              (void **) &pIGLB);

        if (SUCCEEDED(hr))
        {
            hr = pIGLB->Set(COMGLB_EXCEPTION_HANDLING, COMGLB_EXCEPTION_DONOT_HANDLE);

            pIGLB->Release();
        }

        ASSERT(SUCCEEDED(hr));
    }

    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Generic Host Process for Win32 Services"
#define VER_INTERNALNAME_STR            "svchost.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\svchost.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       svchost.c
//
//  Contents:   Generic Host Process for Win32 Services
//
//  Classes:
//
//  Functions:
//
//  History:    3-30-98   RichardW   Created
//              3-31-98   ShaunCo    Took ownership.
//                                   Finished off basic implementation.
//              1-24-00   JSchwart   Took ownership.
//                                   Adapted to run NT intrinsic services.
//              April 2002 JayKrell  added simple support for ServiceManifest registry setting
//                                    did minimal cleanup..much room for improvement..
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "globals.h"
#include "registry.h"
#include "security.h"

//
//  Generic Service Process:
//
//  This process will grovel the service portion of the registry, looking
//  for instances of itself (details below), and constructing a list of services
//  to submit to the service controller.  As an individual service is started,
//  the DLL is loaded and the entry point called.  Services in these DLLs are
//  expected to play nicely with others, that is, use the common thread pool,
//  not stomp memory, etc.
//
//
//  Loading.
//
//  Each service that will be resident in this process must have svchost.exe as
//  the ImagePath, with the same parameters.  Additionally, the service must
//  have under its Parameters key, these values:
//
//  ServiceDll      = REG_EXPAND_SZ <path to DLL>
//  ServiceMain     = REG_SZ        <pszFunctionName>  OPTIONAL
//
//  If ServiceMain is not present, then it defaults to "ServiceMain".
//
//
//  Multiple Service Groups
//
//  Multiple service groups can be accomplished by supplying parameters to the
//  svchost.exe on the ImagePath.
//
//      svchost.exe -k "Key"
//
//  will grovel the services and only load those with matching ImagePath.
//

#define REGSTR_PATH_SVCHOST     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost")

typedef struct _COMMAND_OPTIONS
{
    PTSTR   CommandLineBuffer;
    PTSTR   ImageName;

    BOOL    fServiceGroup;
    PTSTR   ServiceGroupName;

    //
    // dwCoInitializeSecurityParam is a DWORD read from the registry for the
    // service group we were instantiated for.  If non-zero, we will
    // call CoInitializeSecurity in a way based on the value.
    //

    DWORD   dwCoInitializeSecurityParam;
    DWORD   dwAuthLevel;
    DWORD   dwImpersonationLevel;
    DWORD   dwAuthCapabilities;

    //
    // Default stack size for RPC threads (to prevent stack overflow)
    //

    DWORD   dwDefaultRpcStackSize;

    //
    // Should this svchost instance mark itself as system-critical?
    //

    BOOL    fSystemCritical;
}
COMMAND_OPTIONS, * PCOMMAND_OPTIONS;


typedef struct _SERVICE_DLL
{
    LIST_ENTRY      List;
    HMODULE         hmod;
    PTSTR           pszDllPath;
    PTSTR           pszManifestPath;
    HANDLE          hActCtx;
} SERVICE_DLL, * PSERVICE_DLL;


typedef struct _SERVICE
{
    PTSTR           pszName;
    PSERVICE_DLL    pDll;
    PSTR            pszEntryPoint;
} SERVICE, * PSERVICE;


//+---------------------------------------------------------------------------
//
// Global variables.
//

// ListLock protects access to the Dll list and Service array.
//
CRITICAL_SECTION    ListLock;

// DllList is a list of SERVICE_DLL structures representing the DLL's
// which host entry points for the services hosted by this process.
//
LIST_ENTRY          DllList;

// ServiceArray is an array of SERVICE structures representing the services
// hosted by this process.
//
PSERVICE            ServiceArray;

// ServiceCount is the count of SERVICE entries in ServiceList.
//
UINT                ServiceCount;

// ServiceNames is the multi-sz read from the registry for the
// service group we were instantiated for.
//
PTSTR               ServiceNames;


//+---------------------------------------------------------------------------
//
// Local function prototypes
//

VOID
SvchostCharLowerW(
    LPWSTR  pszString
    );


//+---------------------------------------------------------------------------
//

VOID
DummySvchostCtrlHandler(
    DWORD   Opcode
    )
{
    return;
}


VOID
AbortSvchostService(               // used if cant find Service DLL or entrypoint
    LPWSTR  ServiceName,
    DWORD   Error
    )
{
    SERVICE_STATUS_HANDLE   GenericServiceStatusHandle;
    SERVICE_STATUS          GenericServiceStatus;

    GenericServiceStatus.dwServiceType        = SERVICE_WIN32;
    GenericServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    GenericServiceStatus.dwControlsAccepted   = SERVICE_CONTROL_STOP;
    GenericServiceStatus.dwCheckPoint         = 0;
    GenericServiceStatus.dwWaitHint           = 0;
    GenericServiceStatus.dwWin32ExitCode      = Error;
    GenericServiceStatus.dwServiceSpecificExitCode = 0;

    GenericServiceStatusHandle = RegisterServiceCtrlHandler(ServiceName,
                                                            DummySvchostCtrlHandler);

    if (GenericServiceStatusHandle == NULL)
    {
        SVCHOST_LOG1(ERROR,
                     "AbortSvchostService: RegisterServiceCtrlHandler failed %d\n",
                     GetLastError());
    }
    else if (!SetServiceStatus (GenericServiceStatusHandle,
                                &GenericServiceStatus))
    {
        SVCHOST_LOG1(ERROR,
                     "AbortSvchostService: SetServiceStatus error %ld\n",
                     GetLastError());
    }

    return;
}

FARPROC
GetServiceDllFunction (
    PSERVICE_DLL    pDll,
    PCSTR           pszFunctionName,
    LPDWORD         lpdwError        OPTIONAL
    )
{
    FARPROC pfn = NULL;
    HMODULE hmod;
    ULONG_PTR ulpActCtxStackCookie = 0;
    BOOL      fActivateSuccess = FALSE;

    //
    // GetProcAddress can lead to .dlls being loaded, at least
    // in the presence of forwarders. So we are sure to activate the activationcontext
    // even if we are not doing a LoadLibrary here.
    //
    fActivateSuccess = ActivateActCtx(pDll->hActCtx, &ulpActCtxStackCookie);
    if (!fActivateSuccess)
    {
        if (lpdwError)
        {
            *lpdwError = GetLastError();
        }

        SVCHOST_LOG2(ERROR,
                     "ActivateActCtx for %ws failed.  Error %d.\n",
                     pDll->pszDllPath,
                     GetLastError());
        goto Exit;
    }

    // Load the module if neccessary.
    //
    hmod = pDll->hmod;
    if (!hmod)
    {
        hmod = LoadLibraryEx (
                    pDll->pszDllPath,
                    NULL,
                    LOAD_WITH_ALTERED_SEARCH_PATH);

        if (hmod)
        {
            pDll->hmod = hmod;
        }
        else
        {
            if (lpdwError)
            {
                *lpdwError = GetLastError();
            }

            SVCHOST_LOG2(ERROR,
                         "LoadLibrary (%ws) failed.  Error %d.\n",
                         pDll->pszDllPath,
                         GetLastError());
            goto Exit;
        }
    }

    ASSERT (hmod);

    pfn = GetProcAddress(hmod, pszFunctionName);

    if (!pfn)
    {
        if (lpdwError)
        {
            *lpdwError = GetLastError();
        }

        SVCHOST_LOG3(TRACE,
                     "GetProcAddress (%s) failed on DLL %ws.  Error = %d.\n",
                     pszFunctionName,
                     pDll->pszDllPath,
                     GetLastError());
    }
Exit:
    if (fActivateSuccess)
        DeactivateActCtx(0, ulpActCtxStackCookie);
    return pfn;
}

PSERVICE_DLL
FindDll(
    IN LPCTSTR pszManifestPath,
    IN LPCTSTR pszDllPath
    )
{
    PLIST_ENTRY     pNode;
    PSERVICE_DLL    pDll = NULL;

    ASSERT (pszDllPath);

    EnterCriticalSection (&ListLock);

    pNode = DllList.Flink;

    while (pNode != &DllList)
    {
        pDll = CONTAINING_RECORD (pNode, SERVICE_DLL, List);

        if (0 == lstrcmp (pDll->pszDllPath, pszDllPath)
            && 0 == lstrcmp (pDll->pszManifestPath, pszManifestPath)
            )
        {
            break;
        }

        pDll = NULL;

        pNode = pNode->Flink;
    }

    LeaveCriticalSection (&ListLock);

    return pDll;
}

PSERVICE_DLL
AddDll(
    IN LPCTSTR pszManifestPath,
    IN LPCTSTR pszDllPath,
    OUT LPDWORD lpdwError
    )
{
    PSERVICE_DLL    pDll;
    SIZE_T          nDllPathLength;
    SIZE_T          nManifestPathLength;

    ASSERT (pszDllPath);
    ASSERT (*pszDllPath);

    nDllPathLength = lstrlenW (pszDllPath);
    nManifestPathLength = lstrlenW (pszManifestPath);

    pDll = (PSERVICE_DLL)MemAlloc (HEAP_ZERO_MEMORY,
                sizeof (SERVICE_DLL)
                + ((nDllPathLength + 1) * sizeof(WCHAR))
                + ((nManifestPathLength + 1) * sizeof(WCHAR))
                );
    if (pDll)
    {
        // Set the structure members.
        //
        pDll->pszDllPath = (PTSTR) (pDll + 1);
        pDll->pszManifestPath = pDll->pszDllPath + nDllPathLength + 1;
        CopyMemory(pDll->pszDllPath, pszDllPath, nDllPathLength * sizeof(WCHAR));
        CopyMemory(pDll->pszManifestPath, pszManifestPath, nManifestPathLength * sizeof(WCHAR));

        ASSERT(pDll->hActCtx == NULL);
        ASSERT(pDll->pszDllPath[nDllPathLength] == 0);
        ASSERT(pDll->pszManifestPath[nManifestPathLength] == 0);

        // Add the entry to the list.
        //
        EnterCriticalSection (&ListLock);

        InsertTailList (&DllList, &pDll->List);

        LeaveCriticalSection (&ListLock);
    }
    else
    {
        *lpdwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return pDll;
}

LONG
OpenServiceParametersKey (
    LPCTSTR pszServiceName,
    HKEY*   phkey
    )
{
    LONG lr;
    HKEY hkeyServices = NULL;
    HKEY hkeySvc = NULL;

    ASSERT (phkey);

    // Open the Services key.
    //
    lr = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_PATH_SERVICES,
            0,
            KEY_READ,
            &hkeyServices);
    if (lr != ERROR_SUCCESS)
        goto Exit;

    // Open the service key.
    //
    lr = RegOpenKeyEx (
            hkeyServices,
            pszServiceName,
            0,
            KEY_READ,
            &hkeySvc);

    if (lr != ERROR_SUCCESS)
        goto Exit;

    // Open the Parameters key.
    //
    lr = RegOpenKeyEx (
            hkeySvc,
            TEXT("Parameters"),
            0,
            KEY_READ,
            phkey);
Exit:
    if (hkeyServices != NULL)
        RegCloseKey(hkeyServices);
    if (hkeySvc != NULL)
        RegCloseKey(hkeySvc);

    return lr;
}

#if DBG
BOOL
FDebugBreakForService (
    LPCWSTR pszwService
    )
{
    BOOL    fAttach = FALSE;
    LONG    lr;
    HKEY    hkeySvchost;

    // Open the Svchost key.
    //
    lr = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_PATH_SVCHOST,
            0,
            KEY_READ,
            &hkeySvchost);

    if (!lr)
    {
        HKEY  hkeyServiceOptions;

        // Look for the key with the same name as the service.
        //
        lr = RegOpenKeyExW (
                hkeySvchost,
                pszwService,
                0,
                KEY_READ,
                &hkeyServiceOptions);

        if (!lr)
        {
            DWORD dwValue;

            lr = RegQueryDword (
                    hkeyServiceOptions,
                    TEXT("DebugBreak"),
                    &dwValue);

            if (!lr)
            {
                fAttach = !!dwValue;
            }

            RegCloseKey (hkeyServiceOptions);
        }

        RegCloseKey (hkeySvchost);
    }

    return fAttach;
}
#endif

VOID
GetServiceMainFunctions (
    PSERVICE                       pService,
    LPSERVICE_MAIN_FUNCTION        *ppfnServiceMain,
    LPSVCHOST_PUSH_GLOBAL_FUNCTION *ppfnPushGlobals,
    LPDWORD                        lpdwError
    )
{
    LPCSTR pszEntryPoint;
    ACTCTXW ActCtxW = { sizeof(ActCtxW) };
    HANDLE hActCtx = NULL;
    HKEY hkeyParams = NULL;
    PSERVICE_DLL pDll = NULL;
    WCHAR pszExpandedDllName [MAX_PATH + 1];
    PWSTR pszDllName = pszExpandedDllName; // This sometimes get bumped forward to be the leaf name.
    WCHAR pszExpandedManifestName [MAX_PATH + 1];
    WCHAR * Temp = NULL;
    const DWORD TempSize = sizeof(pszExpandedDllName);

    *lpdwError = NO_ERROR;

    pszExpandedDllName[0] = 0;
    pszExpandedManifestName[0] = 0;

    // Get the dll and entrypoint for this service if we don't have it yet.
    //
    if (!pService->pDll)
    {
        LONG lr;

        lr = OpenServiceParametersKey (pService->pszName, &hkeyParams);
        if (!lr)
        {
            DWORD dwType;
            DWORD dwSize;
            Temp = (WCHAR*)MemAlloc(0, TempSize);
            if (Temp == NULL)
            {
                *lpdwError = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }
            Temp[0] = 0;
            // Look for the service dll path and expand it.
            //
            dwSize = TempSize;
            lr = RegQueryValueEx (
                    hkeyParams,
                    TEXT("ServiceDll"),
                    NULL,
                    &dwType,
                    (LPBYTE)Temp,
                    &dwSize);
            if (lr != ERROR_SUCCESS)
            {
                *lpdwError = lr;

                SVCHOST_LOG2(ERROR,
                             "RegQueryValueEx for the ServiceDll parameter of the "
                             "%ws service returned %u\n",
                             pService->pszName,
                             lr);
                goto Exit;
            }
            if (dwType != REG_EXPAND_SZ)
            {
                *lpdwError = ERROR_FILE_NOT_FOUND;

                SVCHOST_LOG1(ERROR,
                             "The ServiceDll parameter for the %ws service is not "
                             "of type REG_EXPAND_SZ\n",
                             pService->pszName);
                goto Exit;
            }
            if (Temp[0] == 0)
            {
                *lpdwError = ERROR_FILE_NOT_FOUND;
                goto Exit;
            }

            // Expand the dll name and lower case it for comparison
            // when we try to find an existing dll record.
            //
            ExpandEnvironmentStrings (
                Temp,
                pszDllName,
                MAX_PATH);

            SvchostCharLowerW (pszDllName);

            dwSize = TempSize;
            lr = RegQueryValueExW (
                    hkeyParams,
                    L"ServiceManifest",
                    NULL,
                    &dwType,
                    (LPBYTE)Temp,
                    &dwSize);
            switch (lr)
            {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                // ok
                pszExpandedManifestName[0] = 0;
                MemFree(Temp);
                Temp = NULL;
                goto NoManifest;
            default:
                *lpdwError = lr;

                SVCHOST_LOG2(ERROR,
                             "RegQueryValueEx for the ServiceManifest parameter of the "
                             "%ws service returned %u\n",
                             pService->pszName,
                             lr);
                goto Exit;
            case ERROR_SUCCESS:
                if (REG_EXPAND_SZ != dwType)
                {
                    // invalid parameter is probably better here, but just do
                    // as it does for ServiceDll
                    *lpdwError = ERROR_FILE_NOT_FOUND;

                    SVCHOST_LOG1(ERROR,
                                 "The ServiceManifest parameter for the %ws service is not "
                                 "of type REG_EXPAND_SZ\n",
                                 pService->pszName);
                    goto Exit;
                }
                if (Temp[0] == 0)
                {
                    // invalid parameter is probably better here, but just do
                    // as it does for ServiceDll
                    *lpdwError = ERROR_FILE_NOT_FOUND;

                    SVCHOST_LOG1(ERROR,
                                 "The ServiceManifest parameter for the %ws service is not "
                                 "of type REG_EXPAND_SZ\n",
                                 pService->pszName);
                    goto Exit;
                }
            }
            // Expand the manifest name and lower case it for comparison
            // when we try to find an existing dll record.
            //
            ExpandEnvironmentStringsW (
                Temp,
                pszExpandedManifestName,
                MAX_PATH);

            MemFree(Temp);
            Temp = NULL;

            SvchostCharLowerW (pszExpandedManifestName);

            //
            // Now only use the leaf dll name.
            // This way people can setup/register the same for downlevel and sidebyside.
            //
            {
                SIZE_T i = lstrlenW(pszDllName);
                while (i != 0)
                {
                    i -= 1;
                    if (pszDllName[i] == L'\\' || pszDllName[i] == L'/')
                    {
                        pszDllName = pszDllName + i + 1;
                        break;
                    }
                }
            }
NoManifest:
            // Try to find an existing dll record that we might have and
            // if we don't, add this as a new record.
            //
            pDll = FindDll (pszExpandedManifestName, pszDllName);
            if (!pDll)
            {
                if (pszExpandedManifestName[0] != 0)
                {
                    ActCtxW.lpSource = pszExpandedManifestName;
                    hActCtx = CreateActCtxW(&ActCtxW);
                    if (hActCtx == INVALID_HANDLE_VALUE)
                    {
                        *lpdwError = GetLastError();

                        SVCHOST_LOG3(ERROR,
                                 "CreateActCtxW(%ws) for the "
                                 "%ws service returned %u\n",
                                 pszExpandedManifestName,
                                 pService->pszName,
                                 *lpdwError);

                        goto Exit;
                    }
                }

                // Remember this dll for this service for next time.
                //

                pDll = AddDll (pszExpandedManifestName, pszDllName, lpdwError);

                if (pDll == NULL)
                {
                    //
                    // Don't set *lpdwError here as AddDll already set it
                    //

                    goto Exit;
                }

                pDll->hActCtx = hActCtx;
                hActCtx = NULL;
            }

            ASSERT (!pService->pDll);
            pService->pDll = pDll;
            pDll = NULL;

            // Look for an explicit entrypoint name for this service.
            // (Optional)
            //
            RegQueryStringA (
                hkeyParams,
                TEXT("ServiceMain"),
                REG_SZ,
                &pService->pszEntryPoint);
        }
        else
        {
            *lpdwError = lr;
        }

        // If we don't have the service dll record by now, we're through.
        //
        if (!pService->pDll)
        {
            ASSERT(*lpdwError != NO_ERROR);
            goto Exit;
        }
    }

    // We should have it the dll by now, so proceed to load the entry point.
    //
    ASSERT (pService->pDll);

    // Default the entry point if we don't have one specified.
    //
    if (pService->pszEntryPoint)
    {
        pszEntryPoint = pService->pszEntryPoint;
    }
    else
    {
        pszEntryPoint = "ServiceMain";
    }

    // Get the address for the service's ServiceMain
    //
    *ppfnServiceMain = (LPSERVICE_MAIN_FUNCTION) GetServiceDllFunction(
                                                     pService->pDll,
                                                     pszEntryPoint,
                                                     lpdwError);

    // Get the address for the "push the globals" function (optional)
    //
    *ppfnPushGlobals = (LPSVCHOST_PUSH_GLOBAL_FUNCTION) GetServiceDllFunction(
                                                            pService->pDll,
                                                            "SvchostPushServiceGlobals",
                                                            NULL);

Exit:
    if (hkeyParams != NULL)
        RegCloseKey (hkeyParams);
    if (Temp != NULL)
        MemFree(Temp);
    if (hActCtx != NULL && hActCtx != INVALID_HANDLE_VALUE)
        ReleaseActCtx(hActCtx);
}

LONG
ReadPerInstanceRegistryParameters(
    IN     HKEY             hkeySvchost,
    IN OUT PCOMMAND_OPTIONS pOptions
    )
{
    HKEY   hkeySvchostGroup;
    LONG   lr;

    // Read the value corresponding to this service group.
    //
    ASSERT (pOptions->ServiceGroupName);

    lr = RegQueryString (
            hkeySvchost,
            pOptions->ServiceGroupName,
            REG_MULTI_SZ,
            &ServiceNames);

    if (!lr && (!ServiceNames || !*ServiceNames))
    {
        lr = ERROR_INVALID_DATA;
    }

    // Read any per-instance parameters from the service group subkey
    // if it exists.
    //
    if (!RegOpenKeyEx (
            hkeySvchost,
            pOptions->ServiceGroupName,
            0, KEY_READ,
            &hkeySvchostGroup))
    {
        DWORD dwValue;

        if (!RegQueryDword (
                hkeySvchostGroup,
                TEXT("CoInitializeSecurityParam"),
                &dwValue))
        {
            pOptions->dwCoInitializeSecurityParam = dwValue;
        }

        if (pOptions->dwCoInitializeSecurityParam)
        {
            if (!RegQueryDword (
                    hkeySvchostGroup,
                    TEXT("AuthenticationLevel"),
                    &dwValue))
            {
                pOptions->dwAuthLevel = dwValue;
            }
            else
            {
                pOptions->dwAuthLevel = RPC_C_AUTHN_LEVEL_PKT;
            }

            if (!RegQueryDword (
                    hkeySvchostGroup,
                    TEXT("ImpersonationLevel"),
                    &dwValue))
            {
                pOptions->dwImpersonationLevel = dwValue;
            }
            else
            {
                pOptions->dwImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            }

            if (!RegQueryDword (
                    hkeySvchostGroup,
                    TEXT("AuthenticationCapabilities"),
                    &dwValue))
            {
                pOptions->dwAuthCapabilities = dwValue;
            }
            else
            {
                pOptions->dwAuthCapabilities = EOAC_NO_CUSTOM_MARSHAL |
                                                 EOAC_DISABLE_AAA;
            }
        }

        if (!RegQueryDword (
                hkeySvchostGroup,
                TEXT("DefaultRpcStackSize"),
                &dwValue))
        {
            pOptions->dwDefaultRpcStackSize = dwValue;
        }

        if (!RegQueryDword (
                hkeySvchostGroup,
                TEXT("SystemCritical"),
                &dwValue))
        {
            pOptions->fSystemCritical = dwValue;
        }

        RegCloseKey (hkeySvchostGroup);
    }

    return lr;
}


BOOL
CallPerInstanceInitFunctions(
    IN OUT PCOMMAND_OPTIONS pOptions
    )
{
    if (pOptions->dwCoInitializeSecurityParam)
    {
        if (!InitializeSecurity(pOptions->dwCoInitializeSecurityParam,
                                pOptions->dwAuthLevel,
                                pOptions->dwImpersonationLevel,
                                pOptions->dwAuthCapabilities))
        {
            return FALSE;
        }
    }

    if (pOptions->dwDefaultRpcStackSize)
    {
        RpcMgmtSetServerStackSize(pOptions->dwDefaultRpcStackSize * 1024);
    }
    else
    {
        //
        // Make sure the default RPC stack size will be at least as
        // large as the default thread stack size for the process so
        // a random service calling RpcMgmtSetServerStackSize can't
        // set it to a value that's too low, causing overflows.
        //

        PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

        if (NtHeaders != NULL)
        {
            RpcMgmtSetServerStackSize((ULONG) NtHeaders->OptionalHeader.SizeOfStackCommit);
        }
    }

    if (pOptions->fSystemCritical)
    {
        //
        // Ignore the return value
        //

        RtlSetProcessIsCritical(TRUE, NULL, TRUE);
    }

    return TRUE;
}


VOID
BuildServiceArray (
    IN OUT PCOMMAND_OPTIONS pOptions
    )
{
    LONG    lr;
    HKEY    hkeySvchost;

    // Open the Svchost key.
    //
    lr = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_PATH_SVCHOST,
            0, KEY_READ,
            &hkeySvchost);

    if (!lr)
    {
        lr = ReadPerInstanceRegistryParameters(hkeySvchost, pOptions);

        RegCloseKey (hkeySvchost);
    }

    if (!lr)
    {
        PTSTR pszServiceName;

        EnterCriticalSection (&ListLock);

        // Count the number of service names read.
        //
        ServiceCount = 0;
        for (pszServiceName = ServiceNames;
             *pszServiceName;
             pszServiceName += lstrlen(pszServiceName) + 1)
        {
            ServiceCount++;
        }
        ASSERT (ServiceCount);

        // Allocate memory for the service array.
        //
        ServiceArray = MemAlloc (HEAP_ZERO_MEMORY,
                            sizeof (SERVICE) * ServiceCount);
        if (ServiceArray)
        {
            PSERVICE pService;

            // Initialize the service array.
            //
            pService = ServiceArray;

            for (pszServiceName = ServiceNames;
                 *pszServiceName;
                 pszServiceName += lstrlen(pszServiceName) + 1)
            {
                pService->pszName = pszServiceName;

                pService++;
            }

            ASSERT (pService == ServiceArray + ServiceCount);
        }
        LeaveCriticalSection (&ListLock);
    }
}


// type of LPSERVICE_MAIN_FUNCTIONW
//
VOID
WINAPI
ServiceStarter(
    DWORD   argc,
    PWSTR   argv[]
    )
{
    LPSERVICE_MAIN_FUNCTION        pfnServiceMain = NULL;
    LPSVCHOST_PUSH_GLOBAL_FUNCTION pfnPushGlobals = NULL;
    LPCWSTR pszwService = argv[0];
    LPWSTR pszwAbort = NULL;
    DWORD  dwError = ERROR_FILE_NOT_FOUND;

    EnterCriticalSection (&ListLock);
    {
        UINT i;

        for (i = 0; i < ServiceCount; i++)
        {
            if (0 == lstrcmpi (pszwService, ServiceArray[i].pszName))
            {
#if DBG
                if (FDebugBreakForService (pszwService))
                {
                    SVCHOST_LOG1(TRACE,
                                "Attaching debugger before getting ServiceMain for %ws...",
                                pszwService);

                    DebugBreak ();
                }
#endif
                GetServiceMainFunctions(&ServiceArray[i],
                                        &pfnServiceMain,
                                        &pfnPushGlobals,
                                        &dwError);

                if (pfnServiceMain && pfnPushGlobals && !g_pSvchostSharedGlobals)
                {
                    SvchostBuildSharedGlobals();
                }

                pszwAbort = argv[0];
                break;
            }
        }
    }
    LeaveCriticalSection (&ListLock);

    if (pfnPushGlobals && g_pSvchostSharedGlobals)
    {
        pfnPushGlobals (g_pSvchostSharedGlobals);

        if (pfnServiceMain)
        {
            SVCHOST_LOG1(TRACE,
                         "Calling ServiceMain for %ws...\n",
                         pszwService);

            pfnServiceMain (argc, argv);
        }
        else if (pszwAbort)
        {
            AbortSvchostService(pszwAbort,
                                dwError);
        }
    }
    else if (pfnServiceMain && !pfnPushGlobals)
    {
        SVCHOST_LOG1(TRACE,
                     "Calling ServiceMain for %ws...\n",
                     pszwService);

        pfnServiceMain (argc, argv);
    }
    else if (pszwAbort)
    {
        AbortSvchostService(pszwAbort,
                            dwError);
    }
}


LPSERVICE_TABLE_ENTRY
BuildServiceTable(
    VOID
    )
{
    LPSERVICE_TABLE_ENTRY   pServiceTable;

    EnterCriticalSection (&ListLock);

    // Allocate one extra entry and zero the entire range.  The extra entry
    // is the table terminator required by StartServiceCtrlDispatcher.
    //
    pServiceTable = MemAlloc (HEAP_ZERO_MEMORY,
                        sizeof (SERVICE_TABLE_ENTRY) * (ServiceCount + 1));

    if (pServiceTable)
    {
        UINT i;

        for (i = 0; i < ServiceCount; i++)
        {
            pServiceTable[i].lpServiceName = ServiceArray[i].pszName;
            pServiceTable[i].lpServiceProc = ServiceStarter;

            SVCHOST_LOG1(TRACE,
                         "Added service table entry for %ws\n",
                         pServiceTable[i].lpServiceName);
        }
    }

    LeaveCriticalSection (&ListLock);

    return pServiceTable;
}


PCOMMAND_OPTIONS
BuildCommandOptions (
    LPCTSTR  pszCommandLine
    )
{
    PCOMMAND_OPTIONS    pOptions;
    ULONG               cbCommandLine;

    if (pszCommandLine == NULL)
    {
        return NULL;
    }

    cbCommandLine = (lstrlen(pszCommandLine) + 1) * sizeof (TCHAR);

    pOptions = MemAlloc (HEAP_ZERO_MEMORY,
                sizeof (COMMAND_OPTIONS) + cbCommandLine);
    if (pOptions)
    {
        TCHAR*  pch;
        TCHAR*  pArgumentStart;
        PTSTR* ppNextArgument = NULL;

        pOptions->CommandLineBuffer = (PTSTR) (pOptions + 1);
        RtlCopyMemory (
            pOptions->CommandLineBuffer,
            pszCommandLine,
            cbCommandLine);

        pch = pOptions->CommandLineBuffer;
        ASSERT (pch);

        // Skip the name of the executable.
        //
        pOptions->ImageName = pch;
        while (*pch && (L' ' != *pch) && (L'\t' != *pch))
        {
            pch++;
        }
        if (*pch)
        {
            *pch++ = 0;
        }

        SvchostCharLowerW (pOptions->ImageName);

        while (1)
        {
            // Skip whitespace.
            //
            while (*pch && ((L' ' == *pch) || (L'\t' == *pch)))
            {
                pch++;
            }

            // End of string?
            //
            if (!*pch)
            {
                break;
            }

            // Is it a '-' or '/' argument?
            //
            if (((L'-' == *pch) || (L'/' == *pch)) && *(++pch))
            {
                if ((L'k' == *pch) || (L'K' == *pch))
                {
                    pOptions->fServiceGroup = TRUE;
                    ppNextArgument = &pOptions->ServiceGroupName;
                }

                pch++;
                continue;
            }

            // This is the start of an argument.
            //
            pArgumentStart = pch;

            // If the argument starts with a quote, skip it and scan to the
            // next quote to terminate it.
            //
            if ((L'\"' == *pch) && *(++pch))
            {
                pArgumentStart = pch;

                while (*pch && (L'\"' != *pch))
                {
                    pch++;
                }
            }

            // otherwise, skip to the next whitespace and this will be
            // our argument.
            //
            else
            {
                while (*pch && (L' ' != *pch) && (L'\t' != *pch))
                {
                    pch++;
                }
            }

            if (*pch)
            {
                // terminate the newly found argument string.
                //
                *pch++ = 0;
            }

            if (ppNextArgument)
            {
                *ppNextArgument = pArgumentStart;
                ppNextArgument = NULL;
            }
        }

        pOptions->fServiceGroup = !!pOptions->ServiceGroupName;

        SVCHOST_LOG1(TRACE,
                     "Command line     : %ws\n",
                     pszCommandLine);

        SVCHOST_LOG1(TRACE,
                     "Service Group    : %ws\n",
                     (pOptions->fServiceGroup) ? pOptions->ServiceGroupName : L"No");

        // Validate the options.
        //
        if (!pOptions->fServiceGroup)
        {
            SVCHOST_LOG2(TRACE,
                         "Generic Service Host\n\n"
                         "%ws [-k <key>] | [-r] | <service>\n\n"
                         "   -k <key>   Host all services whose ImagePath matches\n"
                         "              %ws -k <key>.\n\n",
                         pOptions->CommandLineBuffer,
                         pOptions->CommandLineBuffer);

            MemFree (pOptions);
            pOptions = NULL;
        }
    }

    return pOptions;
}


VOID
SvchostCharLowerW(
    LPWSTR  pszString
    )
{
    //
    // LocalVersion of CharLower to avoid pulling in user32.dll
    //

    int   cwchT;
    DWORD cwch;

    if (pszString == NULL)
    {
        return;
    }

    cwch = (DWORD) wcslen(pszString) + 1;

    cwchT = LCMapStringW(LOCALE_USER_DEFAULT,
                         LCMAP_LOWERCASE,
                         pszString,
                         cwch,
                         pszString,
                         cwch);

    if (cwchT == 0)
    {
        SVCHOST_LOG1(ERROR,
                     "SvchostCharLowerW failed for %ws\n",
                     pszString);
    }

    return;
}


LONG
WINAPI
SvchostUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    return RtlUnhandledExceptionFilter(ExceptionInfo);
}


VOID
wmainCRTStartup (
    VOID
    )
{
    LPSERVICE_TABLE_ENTRY   pServiceTable = NULL;
    PCOMMAND_OPTIONS        pOptions;
    PCWSTR                  pszwCommandLine;

    SetUnhandledExceptionFilter(&SvchostUnhandledExceptionFilter);

    // Prevent critical errors from raising hard error popups and
    // halting svchost.exe.  The flag below will have the system send
    // the errors to the process instead.
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Initialize our HeapAlloc wrapper to use the process heap.
    //
    MemInit (GetProcessHeap());

    // Initialize our global DLL list, Service array, and the critical
    // section that protects them.  InitializeCriticalSection can throw a
    // STATUS_NO_MEMORY exception.  We want the process to exit if that
    // happens, so the default exception handler is fine.
    //
    InitializeListHead (&DllList);
    InitializeCriticalSection (&ListLock);

    // Build a COMMAND_OPTIONS structure and use it to grovel the registry
    // and create the service entry table.
    //
    pszwCommandLine = GetCommandLine ();

    pOptions = BuildCommandOptions (pszwCommandLine);
    if (pOptions)
    {
        BuildServiceArray (pOptions);

        pServiceTable = BuildServiceTable ();

        if (pServiceTable)
        {
            if (!CallPerInstanceInitFunctions(pOptions))
            {
                SVCHOST_LOG0(ERROR,
                             "CallPerInstanceInitFunctions failed -- exiting!\n");

                ExitProcess(1);
            }
        }

        MemFree (pOptions);
    }

    // If we have a valid service entry table, use it to transfer control
    // to the service controller.  StartServiceCtrlDispatcher won't return
    // until all services are stopped.
    //
    if (pServiceTable)
    {
        StartServiceCtrlDispatcher (pServiceTable);
    }

    SVCHOST_LOG1(TRACE,
                 "Calling ExitProcess for %ws\n",
                 pszwCommandLine);

    ExitProcess (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Imports.h

Abstract:

    This file allows us to include standard system header files in the
    regrpc.idl file.  The regrpc.idl file imports a file called
    imports.idl.  This allows the regrpc.idl file to use the types defined
    in these header files.  It also causes the following line to be added
    in the MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    David J. Gilman (davegi) 28-Jan-1992

--*/

#ifndef __IMPORTS_H__
#define __IMPORTS_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winreg.h>

typedef struct _RVALENT {       // Remote Value entry for RegQueryMultipleValues
        PUNICODE_STRING rv_valuename;
        DWORD   rv_valuelen;
        DWORD   rv_valueptr;
        DWORD   rv_type;
} RVALENT;

typedef RVALENT *PRVALENT;

//
// NT 3.1, 3.5 and 3.51 have no implementation of BaseRegGetVersion so this
// number is irrelevant to them.
//
// For a Win95 registry REMOTE_REGISTRY_VERSION should be == 4. Unfortunately,
// someone a bit confused by the concept of a pointer mis-implented the
// Win95 BaseRegGetVersion and it does not actually return a version number.
// So we detect Win95 by assuming anything that succeeds but returns
// a dwVersion outside the range 5-10.
//
// For an NT 4.0 registry, REMOTE_REGISTRY_VERSION==5.
//
// Win95 has the following bugs than NT 4.0 works around on the client side:
//  - BaseRegQueryInfoKey does not account for Unicode value names & data correctly
//  - BaseRegEnumValue returns value data length that is one WCHAR more than it
//    really should be for REG_SZ, REG_MULTI_SZ, and REG_EXPAND_SZ types.
//

#define WIN95_REMOTE_REGISTRY_VERSION 4
#define REMOTE_REGISTRY_VERSION 5

#define IsWin95Server(h,v) ((BaseRegGetVersion(h,&v)==ERROR_SUCCESS) &&  \
                            ((v < 5) || (v > 10)))

//
//  BOOL
//  IsPredefinedRegistryHandle(
//      IN RPC_HKEY     Handle
//      );
//

#define IsPredefinedRegistryHandle( h )                                     \
    ((  ( h == HKEY_CLASSES_ROOT        )                                   \
    ||  ( h == HKEY_CURRENT_USER        )                                   \
    ||  ( h == HKEY_LOCAL_MACHINE       )                                   \
    ||  ( h == HKEY_PERFORMANCE_DATA    )                                   \
    ||  ( h == HKEY_PERFORMANCE_TEXT    )                                   \
    ||  ( h == HKEY_PERFORMANCE_NLSTEXT )                                   \
    ||  ( h == HKEY_USERS               )                                   \
    ||  ( h == HKEY_CURRENT_CONFIG      )                                   \
    ||  ( h == HKEY_DYN_DATA            ))                                  \
    ?   TRUE                                                                \
    :   FALSE )

//
// RPC constants.
//

#define INTERFACE_NAME  L"winreg"
#define BIND_SECURITY   L"Security=Impersonation Dynamic False"

//
// External synchronization event.
//

#define PUBLIC_EVENT    "Microsoft.RPC_Registry_Server"

//
// Force the implementation of the API to be explicit (i.e wrt ANSI or
// UNICODE) about what other Registry APIs are called.
//

#undef RegCloseKey
#undef RegConnectRegistry
#undef RegCreateKey
#undef RegCreateKeyEx
#undef RegDeleteKey
#undef RegDeleteValue
#undef RegEnumKey
#undef RegEnumKeyEx
#undef RegEnumValue
#undef RegFlushKey
#undef RegGetKeySecurity
#undef RegNotifyChangeKeyValue
#undef RegOpenKey
#undef RegOpenKeyEx
#undef RegQueryInfoKey
#undef RegQueryValue
#undef RegQueryValueEx
#undef RegRestoreKey
#undef RegSaveKey
#undef RegSaveKeyEx
#undef RegSetKeySecurity
#undef RegSetValue
#undef RegSetValueEx

//
// Additional type for string arrays.
//

typedef CHAR    STR;

//
// Default values for Win 3.1 requested access.
//

#define WIN31_REGSAM                MAXIMUM_ALLOWED

#endif //__IMPORTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svcslib\threads.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    THREADS.C

Abstract:

    This file contains thread management routines.  Callers can register
    waitable object handles and the functions to be called when a handle
    becomes signaled.  Also, work items can be queued, and operated on when
    threads become free.

    The implementation of the CWorkItemContext class resides in this file

Author:

    Dan Lafferty (danl) 10-Jan-1994

Environment:

    User Mode - Win32

Revision History:

    21-Jan-1999 jschwart
        Removed -- Service Controller and intrinsic services now use
        NT thread pool APIs.

    27-Jun-1997 anirudhs
        SvcObjectWatcher: Fixed bug that sent WAIT_OBJECT_0 to all timed-
        out work items even when only one was signaled.
        Made global arrays static instead of heap-allocated.

    04-Dec-1996 anirudhs
        Added CWorkItemContext, a higher-level wrapper for SvcAddWorkItem.

    01-Nov-1995 anirudhs
        SvcAddWorkItem: Fixed race condition wherein a DLL could add a
        work item and another thread would execute the work item, decrement
        the DLL ref count and unload the DLL before its ref count was
        incremented.

    18-Jul-1994 danl
        TmWorkerThread:  Fixed Access Violation problem which will occur
        if pWorkItem is NULL and we go on to see if the DLL should be
        free'd.  Now we check to see if pWorkItem is NULL first.

    10-Jan-1994 danl
        Created

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <scdebug.h>
#include <svcslib.h>            // CWorkItemContext


//----------
// GLOBALS
//----------

    HANDLE CWorkItemContext::s_hNeverSignaled;


VOID
CWorkItemContext::CallBack(
    IN PVOID    pContext
    )

/*++

Routine Description:

    Wrapper function for the Perform method that is supplied by derived classes.

--*/
{
    //
    // Timeout value is meaningless in this case, so tell the
    // derived class it was signaled
    //
    (((CWorkItemContext *) pContext)->Perform(FALSE));
}


VOID
CWorkItemContext::DelayCallBack(
    IN PVOID    pContext,
    IN BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

    Wrapper function for the Perform method that is supplied by derived classes.

--*/
{
    (((CWorkItemContext *) pContext)->Perform(fWaitStatus));
}


BOOL
CWorkItemContext::Init(
    )
{
    ASSERT(s_hNeverSignaled == NULL);
    s_hNeverSignaled = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (s_hNeverSignaled == NULL)
    {
        SC_LOG(ERROR, "Couldn't create never-signaled event, %lu\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}


void
CWorkItemContext::UnInit(
    )
{
    if (s_hNeverSignaled != NULL)
    {
        CloseHandle(s_hNeverSignaled);
    }
}


NTSTATUS
CWorkItemContext::AddDelayedWorkItem(
    IN  DWORD    dwTimeout,
    IN  DWORD    dwFlags
    )

/*++

Routine Description:

    Queues a work item to take the action after the delay has elapsed.

--*/
{
    //
    // Give RtlRegisterWait a waitable handle that will never get signaled
    // to force it to timeout.  (Hack!)
    //
    // CODEWORK  Use an RtlTimerQueue instead
    //
    if (s_hNeverSignaled == NULL)
    {
        SC_LOG0(ERROR, "Never-signaled event wasn't created\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // The timeout mustn't be infinite
    //
    SC_ASSERT(dwTimeout != INFINITE);

    return (RtlRegisterWait(&m_hWorkItem,         // work item handle
                            s_hNeverSignaled,     // waitable handle
                            DelayCallBack,        // callback
                            this,                 // pContext;
                            dwTimeout,            // timeout
                            dwFlags));            // flags
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svcslib\svcslib.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SVCSLIB.C

Abstract:

    Contains code for attaching services to the service controller process.
    This file contains the following functions:
        SvcStartLocalDispatcher
        SvcServiceEntry
        SvcLoadDllAndStartSvc
        DummyCtrlHandler
        AbortService

Author:

    Dan Lafferty (danl)     25-Oct-1993

Environment:

    User Mode - Win32

Revision History:

    25-Oct-1993         Danl
        created

--*/

//
// INCLUDES
//

#include <scpragma.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windows.h>
#include <winsvc.h>             // Service control APIs
#include <scdebug.h>
#include <svcsp.h>              // SVCS_ENTRY_POINT, SVCS_GLOBAL_DATA
#include <scseclib.h>           //
#include <lmsname.h>            // Lanman Service Names
#include <ntrpcp.h>             // Rpcp... function prototypes
#include <svcslib.h>            // SetupInProgress


//--------------------------
// Definitions and Typedefs
//--------------------------
#define THREAD_WAIT_TIMEOUT     100    // 100 msec timeout

typedef struct _SVCDLL_TABLE_ENTRY {
    LPCWSTR      lpServiceName;
    LPCWSTR      lpDllName;
    LPCSTR       lpServiceEntrypoint;
}SVCDLL_TABLE_ENTRY, *PSVCDLL_TABLE_ENTRY;

//
// Storage for well-known SIDs.  Passed to each service entry point.
//
    SVCS_GLOBAL_DATA GlobalData;

//--------------------------
// FUNCTION PROTOTYPES
//--------------------------
VOID
SvcServiceEntry (           // Ctrl Dispatcher calls here to start service.
    IN DWORD argc,
    IN LPTSTR *argv
    );

VOID
SvcLoadDllAndStartSvc (     // Loads and invokes service DLL
    IN CONST SVCDLL_TABLE_ENTRY * pDllEntry,
    IN DWORD                      argc,
    IN LPTSTR                     argv[]
    );

VOID
DummyCtrlHandler(           // used if cant find Services Dll or entry pt.
    DWORD   Opcode
    );

VOID
AbortService(               // used if cant find Services Dll or entry pt.
    LPWSTR  ServiceName,
    DWORD   Error
    );

VOID
DispatcherThread(
    VOID
    );

//--------------------------
// GLOBALS
//--------------------------
//
// Dispatch table for all services. Passed to StartServiceCtrlDispatcher.
//
// Add new service entries here and in the DLL name list.
//

const SERVICE_TABLE_ENTRY SvcServiceDispatchTable[] = {
                        { L"EVENTLOG",          SvcServiceEntry },
                        { L"PlugPlay",          SvcServiceEntry },

                        //
                        // Do NOT add new services here.
                        //

                        { NULL,                 NULL            }
                        };

//
// DLL names for all services.
//

const SVCDLL_TABLE_ENTRY SvcDllTable[] = {
                        { L"EVENTLOG",          L"eventlog.dll", "SvcEntry_Eventlog"         },
                        { L"PlugPlay",          L"umpnpmgr.dll", "SvcEntry_PlugPlay"         },
                        
                        //
                        // Do NOT add new services here.
                        //

                        { NULL,                 NULL            }
                        };


DWORD
SvcStartLocalDispatcher(
    VOID
    )

/*++

Routine Description:

    This function initializes global data for the services to use, and
    then starts a thread for the service control dispatcher.

Arguments:


Return Value:

    NO_ERROR - If the dispatcher was started successfully.

    otherwise - Errors due to thread creation, or starting the dispatcher
        can be returned.

--*/
{
    DWORD   status = NO_ERROR;
    DWORD   waitStatus = NO_ERROR;
    DWORD   threadId;
    HANDLE  hThread;

    //
    // Populate the global data structure.
    //

    GlobalData.NullSid              = NullSid;
    GlobalData.WorldSid             = WorldSid;
    GlobalData.LocalSid             = LocalSid;
    GlobalData.NetworkSid           = NetworkSid;
    GlobalData.LocalSystemSid       = LocalSystemSid;
    GlobalData.LocalServiceSid      = LocalServiceSid;
    GlobalData.NetworkServiceSid    = NetworkServiceSid;
    GlobalData.BuiltinDomainSid     = BuiltinDomainSid;
    GlobalData.AuthenticatedUserSid = AuthenticatedUserSid;

    GlobalData.AliasAdminsSid       = AliasAdminsSid;
    GlobalData.AliasUsersSid        = AliasUsersSid;
    GlobalData.AliasGuestsSid       = AliasGuestsSid;
    GlobalData.AliasPowerUsersSid   = AliasPowerUsersSid;
    GlobalData.AliasAccountOpsSid   = AliasAccountOpsSid;
    GlobalData.AliasSystemOpsSid    = AliasSystemOpsSid;
    GlobalData.AliasPrintOpsSid     = AliasPrintOpsSid;
    GlobalData.AliasBackupOpsSid    = AliasBackupOpsSid;

    GlobalData.StartRpcServer       = RpcpStartRpcServer;
    GlobalData.StopRpcServer        = RpcpStopRpcServer;
    GlobalData.SvcsRpcPipeName      = SVCS_RPC_PIPE;

    GlobalData.fSetupInProgress     = SetupInProgress(NULL, NULL);

    //--------------------------------------------------
    // Create the thread for the dispatcher to run in.
    //--------------------------------------------------
    hThread = CreateThread (
        NULL,                                       // Thread Attributes.
        0L,                                         // Stack Size
        (LPTHREAD_START_ROUTINE)DispatcherThread,   // lpStartAddress
        NULL,                                       // lpParameter
        0L,                                         // Creation Flags
        &threadId);                                 // lpThreadId

    if (hThread == (HANDLE) NULL) {
        status = GetLastError();
        SC_LOG1(ERROR,"[SERVICES]CreateThread failed %d\n",status);
        return(status);
    }

    //
    // Wait on Thread handle for a moment to make sure the dispatcher is
    // running.
    //
    waitStatus = WaitForSingleObject(hThread, THREAD_WAIT_TIMEOUT);

    if (waitStatus != WAIT_TIMEOUT) {
        GetExitCodeThread(hThread, &status);
    }

    CloseHandle(hThread);
    return(status);
}


VOID
SvcServiceEntry (
    IN DWORD argc,
    IN LPTSTR *argv
    )

/*++

Routine Description:

    This is the thunk routine for the Alerter service.  It loads the DLL
    that contains the service and calls its main routine.

Arguments:

    argc - Argument Count

    argv - Array of pointers to argument strings.  The first is always
        the name of the service.

Return Value:

    None.

--*/

{
    const SVCDLL_TABLE_ENTRY * pDllEntry = SvcDllTable;

    if (argc == 0) {
        SC_LOG0(ERROR,"[SERVICES]SvcServiceEntry: ServiceName was not passed in\n");
        return;
    }

    while (pDllEntry->lpServiceName != NULL) {
        if (_wcsicmp(pDllEntry->lpServiceName, argv[0]) == 0) {
            SC_LOG3(TRACE, "[SERVICES]SvcServiceEntry: "
                           "Service = %ws, Dll = %ws, argv[0] = %ws\n",
                    pDllEntry->lpServiceName, pDllEntry->lpDllName, argv[0]);
            SvcLoadDllAndStartSvc( pDllEntry, argc, argv );
            return;
        }
        pDllEntry++;
    }
    AbortService(argv[0], ERROR_MOD_NOT_FOUND);
    return;
}


VOID
SvcLoadDllAndStartSvc (
    IN CONST SVCDLL_TABLE_ENTRY * pDllEntry,
    IN DWORD                      argc,
    IN LPTSTR                     argv[]
    )

/*++

Routine Description:

    This routine loads the DLL that contains a service and calls its
    main routine.  Note that if a service is stopped and restarted,
    we simply call LoadLibrary again since it increments a refcount
    for already-loaded DLLs.

Arguments:

    DllName - name of the DLL

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    PSVCS_SERVICE_DLL_ENTRY   serviceEntry;
    HINSTANCE                 dllHandle = NULL;
    DWORD                     Error;

    //
    // Load the DLL that contains the service.
    //

    dllHandle = LoadLibrary( pDllEntry->lpDllName );

    if ( dllHandle == NULL ) {
        Error = GetLastError();
        SC_LOG2(ERROR,
                "SERVICES: Failed to load DLL %ws: %ld\n",
                pDllEntry->lpDllName,
                Error);

        AbortService(argv[0], Error);
        return;
    }

    //
    // Get the address of the service's main entry point.
    //

    serviceEntry = (PSVCS_SERVICE_DLL_ENTRY) GetProcAddress(dllHandle,
                                                            pDllEntry->lpServiceEntrypoint);

    if (serviceEntry == NULL)
    {
        Error = GetLastError();

        SC_LOG3(ERROR,
                "SERVICES: Can't find entry %s in DLL %ws: %ld\n",
                pDllEntry->lpServiceEntrypoint,
                pDllEntry->lpDllName,
                GetLastError());

        AbortService(argv[0], Error);
        return;
    }

    //
    // We found the service's main entry point -- call it.
    //

    serviceEntry( argc, argv, &GlobalData, NULL);

    return;

} // SvcLoadDllAndStartSvc


VOID
DummyCtrlHandler(
    DWORD   Opcode
    )
/*++

Routine Description:

    This is a dummy control handler which is only used if we can't load
    a services DLL entry point.  Then we need this so we can send the
    status back to the service controller saying we are stopped, and why.

Arguments:

    OpCode - Ignored

Return Value:

    None.

--*/

{
    return;

} // DummyCtrlHandler


VOID
AbortService(
    LPWSTR  ServiceName,
    DWORD   Error)
/*++

Routine Description:

    This is called if we can't load the entry point for a service.  It
    gets a handle so it can call SetServiceStatus saying we are stopped
    and why.

Arguments:

    ServiceName - the name of the service that couldn't be started
    Error - the reason it couldn't be started

Return Value:

    None.

--*/
{
    SERVICE_STATUS_HANDLE   GenericServiceStatusHandle;
    SERVICE_STATUS          GenericServiceStatus;

    GenericServiceStatus.dwServiceType        = SERVICE_WIN32;
    GenericServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    GenericServiceStatus.dwControlsAccepted   = SERVICE_CONTROL_STOP;
    GenericServiceStatus.dwCheckPoint         = 0;
    GenericServiceStatus.dwWaitHint           = 0;
    GenericServiceStatus.dwWin32ExitCode      = Error;
    GenericServiceStatus.dwServiceSpecificExitCode = 0;

    GenericServiceStatusHandle = RegisterServiceCtrlHandler(ServiceName, DummyCtrlHandler);

    if (GenericServiceStatusHandle == (SERVICE_STATUS_HANDLE) 0)
    {
        SC_LOG1(ERROR,"[SERVICES] RegisterServiceCtrlHandler failed %d\n",
            GetLastError());
    }
    else if (!SetServiceStatus (GenericServiceStatusHandle, &GenericServiceStatus))
    {
        SC_LOG1(ERROR,"[SERVICES] SetServiceStatus error %ld\n", GetLastError());
    }

    return;
}


VOID
DispatcherThread(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD status = NO_ERROR;

    //
    // Call StartServiceCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    if (!StartServiceCtrlDispatcher(SvcServiceDispatchTable))
    {
        status = GetLastError();

        SC_LOG1(ERROR,
                "SERVICES: Failed to start control dispatcher %lu\n",
                status);
    }

    ExitThread(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\client.h ===
/*++


Copyright (c) 1992 Microsoft Corporation

Module Name:

    client.h

Abstract:

    This module is the header file for the client side of the Win32 DLL

Author:

    Ramon J. San Andres (ramonsa) 13-May-1992

--*/

#if DBG
    extern BOOLEAN  BreakPointOnEntry;
#endif

//
// Macros to manage local versus remote handles (HKEYs), as
// well as class registration keys from HKEY_CLASSES_ROOT
//

#define REMOTE_HANDLE_TAG    ( 0x00000001 )

#define REG_CLASSES_MASK     ( 0x00000003 )
#define REG_CLASSES_SPECIAL_TAG ( 0x00000002 )

//
//  BOOL
//  IsLocalHandle(
//      IN HKEY Handle
//      );
//

#define IsLocalHandle( Handle )                                         \
    ( ! ((( DWORD_PTR )( Handle )) & REMOTE_HANDLE_TAG ))

//
//  BOOL
//  IsSpeciaClassesHandle(
//      IN HKEY Handle
//      );
//

#define IsSpecialClassesHandle( Handle )                                 \
    ( ((( DWORD_PTR )( Handle )) & REG_CLASSES_SPECIAL_TAG ))


//
//  VOID
//  TagRemoteHandle(
//      IN PHKEY Handle
//      );
//

#define TagRemoteHandle( Handle )                                       \
    ASSERT( IsLocalHandle( *Handle ));                                  \
    ( *Handle = (( HKEY )((( DWORD_PTR )( *Handle )) | REMOTE_HANDLE_TAG )))

//
//  HKEY
//  DereferenceRemoteHandle(
//      IN HKEY Handle
//      );
//

#define DereferenceRemoteHandle( Handle )                               \
    (( HKEY )((( DWORD_PTR )( Handle )) & ~REMOTE_HANDLE_TAG ))

//
//  HKEY
//  TagSpecialClassesHandle (
//      IN HKEY Handle
//      );
//

#define TagSpecialClassesHandle( Handle )                                       \
    ASSERT( IsLocalHandle( *Handle ));                                  \
    ( *Handle = (( HKEY )((( ULONG_PTR )( *Handle )) | REG_CLASSES_SPECIAL_TAG )))


//
// disable predefined cache not enabled on remote !
//
#define CLOSE_LOCAL_HANDLE(TempHandle)                              \
    if( TempHandle != NULL ) {                                      \
        /* disable cache is not enabled on remote registry */       \
        ASSERT( IsLocalHandle(TempHandle) );                        \
        LocalBaseRegCloseKey(&TempHandle);                          \
    }

#if defined(LEAK_TRACK)


typedef struct _RegLeakTraceInfo {
    DWORD   dwMaxStackDepth;
    LPTSTR  szSymPath;
    BOOL    bEnableLeakTrack;

} RegLeakTraceInfo;


extern RegLeakTraceInfo g_RegLeakTraceInfo;

#endif // LEAK_TRACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\init.c ===
/*++


Copyright (c) 1991 Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module contains the entry point for the Win32 Registry APIs
    client side DLL.

Author:

    David J. Gilman (davegi) 06-Feb-1992

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include "ntconreg.h"
#include <wow64reg.h>

#if DBG
BOOLEAN BreakPointOnEntry = FALSE;
#endif

BOOL LocalInitializeRegCreateKey();
BOOL LocalCleanupRegCreateKey();
BOOL InitializePredefinedHandlesTable();
BOOL CleanupPredefinedHandlesTable();
BOOL InitializeClassesRoot();
BOOL CleanupClassesRoot(BOOL fOnlyThisThread);

#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)

BOOL InitializeInstrumentedRegClassHeap();
BOOL CleanupInstrumentedRegClassHeap();

#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

#if defined(LEAK_TRACK)
BOOL InitializeLeakTrackTable();
BOOL CleanupLeakTrackTable();
#endif // defined (LEAK_TRACK)


enum
{
    ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD = 1,
    ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD = 2
};

HKEY HKEY_ClassesRoot = NULL;

extern BOOL gbDllHasThreadState ;

BOOL
RegInitialize (
    IN HANDLE   Handle,
    IN DWORD    Reason,
    IN PVOID    Reserved
    )

/*++

Routine Description:

    Returns TRUE.

Arguments:

    Handle      - Unused.

    Reason      - Unused.

    Reserved    - Unused.

Return Value:

    BOOL        - Returns TRUE.

--*/

{
    UNREFERENCED_PARAMETER( Handle );

    switch( Reason ) {

    case DLL_PROCESS_ATTACH:

#ifndef REMOTE_NOTIFICATION_DISABLED
        if( !InitializeRegNotifyChangeKeyValue( ) ||
            !LocalInitializeRegCreateKey() ||
            !InitializePredefinedHandlesTable() ) {
            return( FALSE );

        }
#else
#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)
        if ( !InitializeInstrumentedRegClassHeap()) {
            return FALSE;
        }
#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

        if( !LocalInitializeRegCreateKey() ||
            !InitializePredefinedHandlesTable() ||
            !InitializeClassesRoot()) {
            return( FALSE );

        }
#endif


#if defined(LEAK_TRACK)
        InitializeLeakTrackTable();
        // ginore errors
#endif // LEAK_TRACK
        if ( !PerfRegInitialize() ) {
            return( FALSE );
        }

#if defined(_WIN64)  
		//
		// For 64bit system there is also a wow64 section in the registry that 
		// might need some initialization.
		//
        if (!Wow64InitRegistry (1))
			return(FALSE);
#endif

        return( TRUE );
        break;

    case DLL_PROCESS_DETACH:

        // Reserved == NULL when this is called via FreeLibrary,
        //    we need to cleanup Performance keys.
        // Reserved != NULL when this is called during process exits,
        //    no need to do anything.

        if( Reserved == NULL &&
            !CleanupPredefinedHandles()) {
            return( FALSE );
        }

        //initialized and used in ..\server\regclass.c
        if (NULL != HKEY_ClassesRoot)
            NtClose(HKEY_ClassesRoot);

#ifndef REMOTE_NOTIFICATION_DISABLED
        if( !CleanupRegNotifyChangeKeyValue( ) ||
            !LocalCleanupRegCreateKey() ||
            !CleanupPredefinedHandlesTable() ||
            !CleanupClassesRoot( FALSE ) {
            return( FALSE );
        }
#else
        if( !LocalCleanupRegCreateKey() ||
            !CleanupPredefinedHandlesTable() ||
            !CleanupClassesRoot( FALSE )) {
            return( FALSE );
        }
#if defined(LEAK_TRACK)
        CleanupLeakTrackTable();
#endif // LEAK_TRACK
#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)
        if ( !CleanupInstrumentedRegClassHeap()) {
            return FALSE;
        }
#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)
#endif
        if ( !PerfRegCleanup() ) {
            return FALSE;
        }

#if defined(_WIN64)  
		//
		// For 64bit system there is also a wow64 section in the registry that 
		// might need some CleanUp.
		//
        if (!Wow64CloseRegistry (1))
			return(FALSE);
#endif

        return( TRUE );
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:

        if ( gbDllHasThreadState ) {

            return CleanupClassesRoot( TRUE );
        }

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regdval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regdval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to delete values from a key.  That is:

        - RegDeleteValueA
        - RegDeleteValueW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regdval.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#if defined(_WIN64)
#include <wow64reg.h>
#endif

LONG
APIENTRY
RegDeleteValueA (
    HKEY hKey,
    LPCSTR lpValueName
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for deleting a value.

    RegDeleteValueA converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegDeleteValue.

--*/

{
    UNICODE_STRING      ValueName;
    NTSTATUS            Status;
    HKEY                TempHandle = NULL;
    LONG                Result;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Result = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&ValueName,lpValueName) ) {
        Status = STATUS_NO_MEMORY;
        Result = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //

    ValueName.Length += sizeof( UNICODE_NULL );
    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Result = (LONG)LocalBaseRegDeleteValue (
                    hKey,
                    &ValueName
                    );
#if defined(_WIN64)

        if ( Result == 0) //only set dirty if operation succeed
                    Wow64RegSetKeyDirty (hKey);
#endif
    } else {

        Result = (LONG)BaseRegDeleteValue (
                    DereferenceRemoteHandle( hKey ),
                    &ValueName
                    );
    }
    RtlFreeUnicodeString( &ValueName );

ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Result;
}

LONG
APIENTRY
RegDeleteValueW (
    HKEY hKey,
    LPCWSTR lpValueName
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for deleting a value.

    RegDeleteValueW converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegDeleteValue.

--*/

{
    UNICODE_STRING      ValueName;
    HKEY                TempHandle = NULL;
    LONG                Result;
    NTSTATUS            Status;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Result = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode string.
    // This also acounts for the NULL we are adding at the end
    //
    Status = RtlInitUnicodeStringEx(&ValueName, lpValueName);
    if( !NT_SUCCESS(Status) ) {
        Result = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //
    ValueName.Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Result = (LONG)LocalBaseRegDeleteValue (
                    hKey,
                    &ValueName
                    );
#if defined(_WIN64)

        if ( Result == 0) //only set dirty if operation succeed
                    Wow64RegSetKeyDirty (hKey);
#endif
    } else {

        Result = (LONG)BaseRegDeleteValue (
                    DereferenceRemoteHandle( hKey ),
                    &ValueName
                    );
    }
ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regclass.c ===
/*++




Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regclass.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to open the classes root key for a specified user.

        - RegOpenUserClassesRoot

Author:

    Adam Edwards (adamed) 15-Apr-1998

Notes:

    This API is local only.
    See the notes in server\regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <malloc.h>

#define REG_USER_CLASSES_PREFIX L"\\Registry\\User\\"
#define REG_USER_CLASSES_SUFFIX L"_Classes"

BOOL InitializeClassesEnumTable();
BOOL InitializeClassesNameSpace();

BOOL CleanupClassesEnumTable(DWORD dwCriteria);
BOOL CleanupClassesNameSpace();

#if defined(LEAK_TRACK)
NTSTATUS TrackObject(HKEY hKey);
#endif // defined(LEAK_TRACK)

extern BOOL gbCombinedClasses;


LONG
APIENTRY
RegOpenUserClassesRoot(
    HANDLE hToken,
    DWORD  dwOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for opening the classes root key
    for the use specified by the hToken parameter.

Arguments:

    hToken - token for user whose classes root is to be opened. If 
        this parameter is NULL, we return ERROR_INVALID_PARAMETER

    phkResult - Returns an open handle to the newly opened key.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:


--*/

{
    NTSTATUS            Status;
    UNICODE_STRING      UsersHive;
    BYTE achBuffer[100];
    PTOKEN_USER pTokenInfo = (PTOKEN_USER) &achBuffer[0];
    DWORD dwBytesRequired;
    LONG Error;

    //
    //  Caller must pass pointer to the variable where the opened handle
    //  will be returned
    //

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == hToken) {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwOptions != REG_OPTION_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!gbCombinedClasses) {
        return ERROR_FILE_NOT_FOUND;
    }
    
    //
    // open up the token to get the sid
    //

    if (!GetTokenInformation(
        hToken,                    // Handle
        TokenUser,                 // TokenInformationClass
        pTokenInfo,                // TokenInformation
        sizeof(achBuffer),         // TokenInformationLength
        &dwBytesRequired           // ReturnLength
        )) {

        Error = GetLastError();

        //
        // Try again if the buffer was too small
        //

        if (ERROR_INSUFFICIENT_BUFFER != Error) {
            return Error ;
        }

        //
        // Allocate space for the user info
        //
        pTokenInfo = (PTOKEN_USER) RtlAllocateHeap( RtlProcessHeap(), 0, dwBytesRequired);

        if (!pTokenInfo) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }


        //
        // Read in the UserInfo
        //

        if (!GetTokenInformation(
            hToken,                // Handle
            TokenUser,                 // TokenInformationClass
            pTokenInfo,                // TokenInformation
            dwBytesRequired,           // TokenInformationLength
            &dwBytesRequired           // ReturnLength
            )) {

            RtlFreeHeap( RtlProcessHeap(), 0, pTokenInfo );
            return GetLastError();
        }
    }

    //
    //  Change sid to a string
    //

    Status = RtlConvertSidToUnicodeString(
        &UsersHive,
        pTokenInfo->User.Sid,
        TRUE); // allocate the string

    if (NT_SUCCESS(Status)) {
        
        UNICODE_STRING UserClassesString;

        UserClassesString.MaximumLength = UsersHive.Length + 
            sizeof(REG_USER_CLASSES_PREFIX) + 
            sizeof(REG_USER_CLASSES_SUFFIX);

        UserClassesString.Buffer = (WCHAR*)RtlAllocateHeap( RtlProcessHeap(), 0, UserClassesString.MaximumLength);

        if (UserClassesString.Buffer) {

            UNICODE_STRING UserPrefix;

            //
            // construct the name
            //

            RtlInitUnicodeString(&UserPrefix, REG_USER_CLASSES_PREFIX);

            RtlCopyUnicodeString(&UserClassesString, &UserPrefix);

            Status = RtlAppendUnicodeStringToString(&UserClassesString, &UsersHive);

            if (NT_SUCCESS(Status)) {
                Status = RtlAppendUnicodeToString(&UserClassesString, 
                                                  REG_USER_CLASSES_SUFFIX);
            }

            if (NT_SUCCESS(Status)) {

                OBJECT_ATTRIBUTES Obja;

                // open this key
                InitializeObjectAttributes(
                    &Obja,
                    &UserClassesString,
                    OBJ_CASE_INSENSITIVE,
                    NULL, // using absolute path, no hkey
                    NULL);

                Status = NtOpenKey(
                    phkResult,
                    samDesired,
                    &Obja);
            }

            RtlFreeHeap( RtlProcessHeap(), 0, UserClassesString.Buffer );
        } else {
            Status = STATUS_NO_MEMORY;
        }

        RtlFreeUnicodeString(&UsersHive);

    }

    if( pTokenInfo != (PTOKEN_USER)&achBuffer[0] ) {
        RtlFreeHeap( RtlProcessHeap(), 0, pTokenInfo );
    }

    if (NT_SUCCESS(Status)) {
#if defined(LEAK_TRACK)

        if (g_RegLeakTraceInfo.bEnableLeakTrack) {
            (void) TrackObject(*phkResult);
        }
        
#endif defined(LEAK_TRACK)

        // mark this key as a class key
        TagSpecialClassesHandle(phkResult);
    }

    return RtlNtStatusToDosError(Status);
}

BOOL InitializeClassesRoot() 
{
    if (!InitializeClassesEnumTable()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CleanupClassesRoot(BOOL fOnlyThisThread) 
{
    //
    // Always remove enumeration states for this thread
    //
    return CleanupClassesEnumTable( fOnlyThisThread );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\predefh.c ===
/*++


Copyright (c) 1992 Microsoft Corporation

Module Name:

    Predefh.c

Abstract:

    This module contains the client side support for managing the Win32
    Registry API's predefined handles. This support is supplied via a
    table, which maps (a) predefined handles to real handles and (b)
    the server side routine which opens the handle.

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    See the notes in server\predefh.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"

#if defined(LEAK_TRACK)
NTSTATUS TrackObject(HKEY hKey);
#endif // LEAK_TRACK

RTL_CRITICAL_SECTION    PredefinedHandleTableCriticalSection;


//
// For each predefined handle an entry is maintained in an array. Each of
// these structures contains a real (context) handle and a pointer to a
// function that knows how to map the predefined handle to the Registry name
// space.
//

//
// Pointer to function to open predefined handles.
//

typedef
error_status_t
( *OPEN_FUNCTION ) (
     PREGISTRY_SERVER_NAME,
     REGSAM,
     PRPC_HKEY
     );


//
// Table entry for a predefined handle.
//

typedef struct _PRDEFINED_HANDLE {

    RPC_HKEY        Handle;
    OPEN_FUNCTION   OpenFunc;
    BOOLEAN         Disabled;   // tells whether the handle should be cached or not.

#if DBG
    ULONG                   Callers;
    PVOID                   CallerAddress[10];
#endif 

} PREDEFINED_HANDLE, *PPREDEFINED_HANDLE;

//
// Initialize predefined handle table.
//
PREDEFINED_HANDLE PredefinedHandleTable[ ] = {

    NULL, LocalOpenClassesRoot,         FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenCurrentUser,         FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenLocalMachine,        FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenUsers,               FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenPerformanceData,     FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenPerformanceText,     FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenPerformanceNlsText,  FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenCurrentConfig,       FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif
    ,
    NULL, LocalOpenDynData,             FALSE
#if DBG
        ,  0,  {0, 0, 0,  0, 0, 0, 0, 0, 0, 0 }
#endif

};

#define MAX_PREDEFINED_HANDLES                                              \
    ( sizeof( PredefinedHandleTable ) / sizeof( PREDEFINED_HANDLE ))

//
// Predefined HKEY values are defined in Winreg.x. They MUST be kept in
// synch with the following constants and macros.
//

//
// Mark Registry handles so that we can recognize predefined handles.
//

#define PREDEFINED_REGISTRY_HANDLE_SIGNATURE    ( 0x80000000 )

NTSTATUS
SetHandleProtection(
    IN      HANDLE                  Handle,
    IN      LONG                    Index,
    IN      BOOLEAN                 Protect
)
/*++

Routine Description:

    Changes the handle ProtectFromClose attribute. To be used for predefined handles, 
    to prevent abnormal closure.

Arguments:

    Handle - Supplies the handle who's protection to be changed.

    Index  - Index in the predefined handle table

Return Value:

    Status of the NtSetInformationObject call

--*/
{
    NTSTATUS                        Status;
    OBJECT_HANDLE_FLAG_INFORMATION  Ohfi = {    FALSE,
                                                FALSE
                                            };
    ULONG                           PredefHandle;

    PredefHandle = ((ULONG)Index) | PREDEFINED_REGISTRY_HANDLE_SIGNATURE;

    switch (PredefHandle) {
        case (ULONG)((ULONG_PTR)HKEY_CLASSES_ROOT):
        case (ULONG)((ULONG_PTR)HKEY_CURRENT_USER):
        case (ULONG)((ULONG_PTR)HKEY_LOCAL_MACHINE):
        case (ULONG)((ULONG_PTR)HKEY_USERS):
            //
            // go change the protection
            //
            break;
        default:
            //
            // The supplied handle might not be a real handle
            //
            return STATUS_INVALID_HANDLE;
    }


    Ohfi.ProtectFromClose = Protect;

    Status = NtSetInformationObject(Handle,
                                    ObjectHandleFlagInformation,
                                    &Ohfi,
                                    sizeof (OBJECT_HANDLE_FLAG_INFORMATION));

#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "WINREG: SetHandleProtection (%u) on %lx failed. Status = %lx \n",Protect, Handle, Status );
    }
#endif

    return Status;
}

LONG
MapPredefinedRegistryHandleToIndex(
    IN ULONG Handle
    )

/*++

Routine Description:

    Maps a predefined handle to an index into the predefined handle table.

Arguments:

    Handle - Supplies the handle to be mapped.

Return Value:

    An index into the predefined handle table
    -1 if the handle is not a predefined handle

--*/
{
    LONG Index;

    switch (Handle) {
        case (ULONG)((ULONG_PTR)HKEY_CLASSES_ROOT):
        case (ULONG)((ULONG_PTR)HKEY_CURRENT_USER):
        case (ULONG)((ULONG_PTR)HKEY_LOCAL_MACHINE):
        case (ULONG)((ULONG_PTR)HKEY_USERS):
        case (ULONG)((ULONG_PTR)HKEY_PERFORMANCE_DATA):
            Index = (Handle & ~PREDEFINED_REGISTRY_HANDLE_SIGNATURE);
            break;
        case (ULONG)((ULONG_PTR)HKEY_PERFORMANCE_TEXT):
            Index = 5;
            break;
        case (ULONG)((ULONG_PTR)HKEY_PERFORMANCE_NLSTEXT):
            Index = 6;
            break;
        case (ULONG)((ULONG_PTR)HKEY_CURRENT_CONFIG):
            Index = 7;
            break;
        case (ULONG)((ULONG_PTR)HKEY_DYN_DATA):
            Index = 8;
            break;
        default:
            //
            // The supplied handle is not predefined, so return it.
            //
            Index = -1;
            break;
    }
    return(Index);
}



NTSTATUS
RemapPredefinedHandle(
    IN RPC_HKEY     Handle,
    IN RPC_HKEY     NewHandle

    )

/*++

Routine Description:

    Override the current predefined handle.  If it is already open, close it,
	then set the new handle

Arguments:

    Handle  - Supplies a handle which must be a predefined handle
	NewHandle	- an already open registry key to override the special key

Return Value:

    ERROR_SUCCESS - no problems

--*/

{
    LONG        Index;
    LONG        Error;
    NTSTATUS    Status;
    HANDLE      hCurrentProcess;
    HKEY        hkTableHandle = NULL;

    //
    // If the high bit is not set, we know it's not a predefined handle
    // so take a quick out.
    //
    if (((ULONG_PTR)Handle & 0x80000000) == 0) {
        return(STATUS_INVALID_HANDLE);
    }

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() on RemapPredefinedHandle() failed. Status = %lx \n", Status );
#endif
        Status = ERROR_INVALID_HANDLE;
	goto cleanup_and_exit;
    }

    Index = MapPredefinedRegistryHandleToIndex((ULONG)(ULONG_PTR)Handle);

    if (Index == -1) {
	Status = STATUS_INVALID_HANDLE;
        goto leave_crit_sect;
    }

    ASSERT(( 0 <= Index ) && ( Index < MAX_PREDEFINED_HANDLES ));

    if( PredefinedHandleTable[ Index ].Disabled == TRUE ) {
        //
        // predefined table is disabled for this key
        //

        // nobody is allowed to write here
        ASSERT( PredefinedHandleTable[ Index ].Handle == NULL );

        // refuse the request
        Status = STATUS_INVALID_HANDLE;
        goto leave_crit_sect;
    }

    hCurrentProcess = NtCurrentProcess();

    //
    // see if we can duplicate this handle so we can place it
    // in the table
    //
    if (NewHandle && !NT_SUCCESS(Status = NtDuplicateObject (hCurrentProcess,
			       NewHandle,
			       hCurrentProcess,
			       &hkTableHandle,
                               0,
			       FALSE,
			       DUPLICATE_SAME_ACCESS))) {
	goto leave_crit_sect;
    }

    if (NewHandle && IsSpecialClassesHandle(NewHandle)) {
        TagSpecialClassesHandle( &hkTableHandle );
    }

    //
    // If the predefined handle has already been opened try
    // and close the key now.
    //
    if( PredefinedHandleTable[ Index ].Handle != NULL ) {

        // make sure the handle CAN be closed.
        SetHandleProtection(PredefinedHandleTable[ Index ].Handle,Index,FALSE);
	    
#if DBG
        PredefinedHandleTable[ Index ].Callers = RtlWalkFrameChain(&(PredefinedHandleTable[ Index ].CallerAddress[0]), 10, 0);      
#endif

        Error = (LONG) RegCloseKey( PredefinedHandleTable[ Index ].Handle );

#if DBG
        if ( Error != ERROR_SUCCESS ) {

            DbgPrint( "Winreg.dll: Cannot close predefined handle\n" );
            DbgPrint( "            Handle: 0x%x  Index: %d  Error: %d\n",
                      Handle, Index, Error );
        }

#endif

    }

    PredefinedHandleTable[ Index ].Handle = hkTableHandle;

    // make sure the handle CANNOT be closed.
    SetHandleProtection(PredefinedHandleTable[ Index ].Handle,Index,TRUE);

leave_crit_sect:

#if DBG
    {
        NTSTATUS Status2 =
#endif DBG
	    RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
        ASSERT( NT_SUCCESS( Status2 ) );
#if DBG
        if ( !NT_SUCCESS( Status2 ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() on RemapPredefinedHandle() failed. Status = %lx \n", Status2 );
	    }
    }
#endif

cleanup_and_exit:

    if (!NT_SUCCESS(Status) && hkTableHandle) {
	    RegCloseKey(hkTableHandle);
    }

    return( Status );
}


RPC_HKEY
MapPredefinedHandle(
    IN  RPC_HKEY    Handle,
    OUT PRPC_HKEY    HandleToClose
    )

/*++

Routine Description:

    Attempt to map a predefined handle to a RPC context handle. This in
    turn will map to a real Nt Registry handle.

Arguments:

    Handle  - Supplies a handle which may be a predefined handle or a handle
              returned from a previous call to any flavour of RegCreateKey,
              RegOpenKey or RegConnectRegistry.

    HandleToClose - When not NULL, this is the same as the result.
                    Used to implement the DisablePredefinedCache feature.

Return Value:

    RPC_HKEY- Returns the supplied handle argument if it not predefined,
              a RPC context handle if possible (i.e. it was previously
              opened or can be opened now), NULL otherwise.

--*/

{
    LONG        Index;
    LONG        Error;
    NTSTATUS    Status;
    HANDLE      ResultHandle;

    *HandleToClose = NULL;

    // reject outrageous calls
    if( Handle ==  INVALID_HANDLE_VALUE ) {
        return( NULL );
    }

    //
    // If the high bit is not set, we know it's not a predefined handle
    // so take a quick out.
    //
    if (((ULONG_PTR)Handle & 0x80000000) == 0) {
        return(Handle);
    }
    Index = MapPredefinedRegistryHandleToIndex((ULONG)(ULONG_PTR)Handle);
    if (Index == -1) {
        return(Handle);
    }

    ASSERT(( 0 <= Index ) && ( Index < MAX_PREDEFINED_HANDLES ));

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() on MapPredefinedHandle() failed. Status = %lx \n", Status );
#endif
        return( NULL );
    }

    if( PredefinedHandleTable[ Index ].Disabled == TRUE ) {
        //
        // for this handle the predefined feature has been disabled
        //

        // nobody is allowed to write here
        ASSERT( PredefinedHandleTable[ Index ].Handle == NULL );

        //
        // open a new handle for this request and store it in "toClose"
        // argument so the caller knows that should close it
        //
        ( *PredefinedHandleTable[ Index ].OpenFunc )(
                        NULL,
                        MAXIMUM_ALLOWED,
                        HandleToClose
                        );


        // return the new handle to the caller
        ResultHandle = *HandleToClose;
    } else {
        //
        // If the predefined handle has not already been openend try
        // and open the key now.
        //
        if( PredefinedHandleTable[ Index ].Handle == NULL ) {

            Error = (LONG)( *PredefinedHandleTable[ Index ].OpenFunc )(
                            NULL,
                            MAXIMUM_ALLOWED,
                            &PredefinedHandleTable[ Index ].Handle
                            );

            if( Error == ERROR_SUCCESS ) {
                // make sure the handle CANNOT be closed.
                SetHandleProtection(PredefinedHandleTable[ Index ].Handle,Index,TRUE);
            }

#if defined(LEAK_TRACK)

            if (g_RegLeakTraceInfo.bEnableLeakTrack) {
                (void) TrackObject(PredefinedHandleTable[ Index ].Handle);
            }
            
#endif // defined(LEAK_TRACK)

#if DBG
            if ( Error != ERROR_SUCCESS ) {

                DbgPrint( "Winreg.dll: Cannot map predefined handle\n" );
                DbgPrint( "            Handle: 0x%x  Index: %d  Error: %d\n",
                          Handle, Index, Error );
            } else {
                ASSERT( IsLocalHandle( PredefinedHandleTable[ Index ].Handle ));
            }

#endif
        }
        //
        // Map the predefined handle to a real handle (may be NULL
        // if key could not be opened).
        //
        ResultHandle = PredefinedHandleTable[ Index ].Handle;

        ASSERT(*HandleToClose == NULL);

    }


    Status = RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() on MapPredefinedHandle() failed. Status = %lx \n", Status );
    }
#endif
    return( ResultHandle );
}


BOOL
CleanupPredefinedHandles(
    VOID
    )

/*++

Routine Description:

    Runs down the list of predefined handles and closes any that have been opened.

Arguments:

    None.

Return Value:

    TRUE - success

    FALSE - failure

--*/

{
    LONG        i;
    NTSTATUS    Status;

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlEnterCriticalSection() on CleanupPredefinedHandles() failed. Status = %lx \n", Status );
    }
#endif
    for (i=0;i<sizeof(PredefinedHandleTable)/sizeof(PREDEFINED_HANDLE);i++) {
        //
        // consistency check
        //
        if( PredefinedHandleTable[ i ].Disabled == TRUE ) {
            //
            // predefined table is disabled for this key
            //

            // nobody is allowed to write here
            ASSERT( PredefinedHandleTable[ i ].Handle == NULL );
        } else if (PredefinedHandleTable[i].Handle != NULL) {
            // make sure the handle CAN be closed.
            SetHandleProtection(PredefinedHandleTable[ i ].Handle,i,FALSE);
#if DBG
            PredefinedHandleTable[ i ].Callers = RtlWalkFrameChain(&(PredefinedHandleTable[ i ].CallerAddress[0]), 10, 0);      
#endif
            LocalBaseRegCloseKey(&PredefinedHandleTable[i].Handle);
            PredefinedHandleTable[i].Handle = NULL;
        }
    }
    Status = RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() on CleanupPredefinedHandles() failed. Status = %lx \n", Status );
    }
#endif
    return(TRUE);
}


LONG
ClosePredefinedHandle(
    IN RPC_HKEY     Handle
    )

/*++

Routine Description:

    Zero out the predefined handles entry in the predefined handle table
    so that subsequent opens will call the server.

Arguments:

    Handle - Supplies a predefined handle.

Return Value:

    None.

--*/

{
    NTSTATUS    Status;
    HKEY        hKey1;
    LONG        Error;
    LONG        Index;

    ASSERT( IsPredefinedRegistryHandle( Handle ));

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlEnterCriticalSection() on ClosePredefinedHandle() failed. Status = %lx \n", Status );
    }
#endif

    Index = MapPredefinedRegistryHandleToIndex( (ULONG)(ULONG_PTR)Handle );
    ASSERT( Index != -1 );

    hKey1 = PredefinedHandleTable[ Index ].Handle;
    if( hKey1 == NULL ) {
        //
        //  If the handle was already closed, then return ERROR_SUCCESS.
        //  This is because an application may already have called RegCloseKey
        //  on a predefined key, and is now callig RegOpenKey on the same
        //  predefined key. RegOpenKeyEx will try to close the predefined handle
        //  and open a new one, in order to re-impersonate the client. If we don't
        //  return ERROR_SUCCESS, then RegOpenKeyEx will not open a new predefined
        //  handle, and the API will fail.
        //
        Error = ERROR_SUCCESS;
    } else {

        // if there is a handle here, the predefined handle is not disabled.
        ASSERT(PredefinedHandleTable[ Index ].Disabled == FALSE);

        PredefinedHandleTable[ Index ].Handle = NULL;
#if DBG
        PredefinedHandleTable[ Index ].Callers = RtlWalkFrameChain(&(PredefinedHandleTable[ Index ].CallerAddress[0]), 10, 0);      
#endif
    }

    Status = RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() on ClosePredefinedHandle() failed. Status = %lx \n", Status );
    }
#endif

    if( hKey1 != NULL ) {
        //
        // close the key now (after leaving critical region to prevent deadlock
        // with dumb heads calling reg apis from DllInit.
        //

        // make sure the handle CAN be closed.
        SetHandleProtection(hKey1,Index,FALSE);

        Error =  ( LONG ) LocalBaseRegCloseKey( &hKey1 );
    }
    return( Error );
}



LONG
OpenPredefinedKeyForSpecialAccess(
    IN  RPC_HKEY     Handle,
    IN  REGSAM       AccessMask,
    OUT PRPC_HKEY    pKey
    )

/*++

Routine Description:

    Attempt to open a predefined key with SYSTEM_SECURITY_ACCESS.
    Such an access is not included on MAXIMUM_ALLOWED, and is  needed
    by RegGetKeySecurity and RegSetKeySecurity, in order to retrieve
    and save the SACL of a predefined key.

    WHEN USING A HANDLE WITH SPECIAL ACCESS, IT IS IMPORTANT TO FOLLOW
    THE RULES BELOW:

        - HANDLES OPENED FOR SPECIAL ACCESS ARE NEVER SAVED ON THE
          PredefinedHandleTable.

        - SUCH HANDLES SHOULD BE USED ONLY INTERNALY TO THE CLIENT
          SIDE OF WINREG APIs.
          THEY SHOULD NEVER BE RETURNED TO THE OUTSIDE WORLD.

        - IT IS THE RESPONSIBILITY OF THE CALLER OF THIS FUNCTION TO CLOSE
          THE HANDLES OPENED BY THIS FUNCTION.
          RegCloseKey() SHOULD BE USED TO CLOSE SUCH HANDLES.


    This function should be called only by the following APIs:

      RegGetKeySecurity -> So that it can retrieve the SACL of a predefined key
      RegSetKeySecurity -> So that it can save the SACL of a predefined key
      RegOpenKeyEx -> So that it can determine wheteher or not the caller of
                      RegOpenKeyEx is able to save and restore SACL of
                      predefined keys.


Arguments:

    Handle  - Supplies one of the predefined handle of the local machine.

    AccessMask - Suplies an access mask that contains the special access
                 desired (the ones not included in MAXIMUM_ALLOWED).
                 On NT 1.0, ACCESS_SYSTEM_SECURITY is the only one of such
                 access.

    pKey - Pointer to the variable that will contain the handle opened with
           the special access.


Return Value:


    LONG - Returns a DosErrorCode (ERROR_SUCCESS if the operation succeeds).

--*/

{
    LONG    Index;
    LONG    Error;


    ASSERT( pKey );
    ASSERT( AccessMask & ACCESS_SYSTEM_SECURITY );
    ASSERT( IsPredefinedRegistryHandle( Handle ) );

    //
    // Check if the Handle is a predefined handle.
    //

    if( IsPredefinedRegistryHandle( Handle )) {

        if( ( ( AccessMask & ACCESS_SYSTEM_SECURITY ) == 0 ) ||
            ( pKey == NULL ) ) {
            return( ERROR_INVALID_PARAMETER );
        }

        //
        // Convert the handle to an index.
        //

        Index = MapPredefinedRegistryHandleToIndex( (ULONG)(ULONG_PTR)Handle );
        ASSERT(( 0 <= Index ) && ( Index < MAX_PREDEFINED_HANDLES ));

        //
        // If the predefined handle has not already been openend try
        // and open the key now.
        //


        Error = (LONG)( *PredefinedHandleTable[ Index ].OpenFunc )(
                        NULL,
                        AccessMask,
                        pKey
                        );

/*
#if DBG
        if ( Error != ERROR_SUCCESS ) {

            DbgPrint( "Winreg.dll: Cannot map predefined handle\n" );
            DbgPrint( "            Handle: 0x%x  Index: %d  Error: %d\n",
                          Handle, Index, Error );
        } else {
            ASSERT( IsLocalHandle( PredefinedHandleTable[ Index ].Handle ));
        }

#endif
*/

        return Error;
    } else {
        return( ERROR_BADKEY );
    }

}
// #endif


BOOL
InitializePredefinedHandlesTable(
    )

/*++

Routine Description:

    Initialize the critical section used by the functions that access
    PredefinedHandleTable.
    This critical section is needed to avoid that a thread closes a predefined
    key, while other threads are accessing the predefined key

Arguments:

    None.

Return Value:

    Returns TRUE if the initialization succeeds.

--*/

{
    NTSTATUS    NtStatus;


    NtStatus = RtlInitializeCriticalSection(
                    &PredefinedHandleTableCriticalSection
                    );
    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus ) ) {
        return FALSE;
    }
    return( TRUE );

}


BOOL
CleanupPredefinedHandlesTable(
    )

/*++

Routine Description:

    Delete the critical section used by the functions that access the
    PredefinedHandleTable.


Arguments:

    None.

Return Value:

    Returns TRUE if the cleanup succeeds.

--*/

{
    NTSTATUS    NtStatus;


    //
    //  Delete the critical section
    //
    NtStatus = RtlDeleteCriticalSection(
                    &PredefinedHandleTableCriticalSection
                    );

    ASSERT( NT_SUCCESS( NtStatus ) );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return FALSE;
    }
    return( TRUE );
}

NTSTATUS
DisablePredefinedHandleTable(
                   HKEY    Handle
                             )

/*++

Routine Description:

    Disables the predefined handle table for the current user
    key. Eventually closes the handle in predefined handle, if already open

Arguments:

    Handle - predefined handle for which to disable (now only current user)

Return Value:


--*/

{
    NTSTATUS    Status;
    LONG        Index;

    if( Handle != HKEY_CURRENT_USER ) {
        //
        // feature enabled only for current user at this time
        //
        return STATUS_INVALID_HANDLE;
    }

    Status = RtlEnterCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );

#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlEnterCriticalSection() on DisablePredefinedHandleTable() failed. Status = %lx \n", Status );
    }
#endif

    Index = MapPredefinedRegistryHandleToIndex( (ULONG)(ULONG_PTR)Handle );
    ASSERT( Index != -1 );

    if(PredefinedHandleTable[ Index ].Disabled == TRUE) {
        // already called
        ASSERT( PredefinedHandleTable[ Index ].Handle == NULL );
    } else {
        if( PredefinedHandleTable[ Index ].Handle != NULL ) {

            // make sure the handle CAN be closed.
            SetHandleProtection(PredefinedHandleTable[ Index ].Handle,Index,FALSE);

#if DBG
            PredefinedHandleTable[ Index ].Callers = RtlWalkFrameChain(&(PredefinedHandleTable[ Index ].CallerAddress[0]), 10, 0);      
#endif
            LocalBaseRegCloseKey( &(PredefinedHandleTable[ Index ].Handle) );
        }
        PredefinedHandleTable[ Index ].Handle = NULL;
        PredefinedHandleTable[ Index ].Disabled = TRUE;
    }

    Status = RtlLeaveCriticalSection( &PredefinedHandleTableCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );

#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() on ClosePredefinedHandle() failed. Status = %lx \n", Status );
    }
#endif
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regdkey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regdkey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to delete a key.  That is:

        - RegDeleteKeyA
        - RegDeleteKeyW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regdkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"


LONG
APIENTRY
RegDeleteKeyA (
    HKEY hKey,
    LPCSTR lpKeyName
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for deleting a Key.

    RegDeleteKeyA converts the lpKeyName argument to a counted Unicode string
    and then calls BaseRegDeleteKey.

--*/

{
    UNICODE_STRING      KeyName;
    NTSTATUS            Status;
    HKEY                TempHandle = NULL;
    LONG                Result;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( lpKeyName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle);
    if( hKey == NULL ) {
        Result = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the Key name to a counted Unicode string 
    //

    if( !RtlCreateUnicodeStringFromAsciiz(&KeyName,lpKeyName) ) {
        Status = STATUS_NO_MEMORY;
        Result = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //
    KeyName.Length += sizeof( UNICODE_NULL );
    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Result = (LONG)LocalBaseRegDeleteKey (
                    hKey,
                    &KeyName
                    );

    } else {

        Result = (LONG)BaseRegDeleteKey (
                    DereferenceRemoteHandle( hKey ),
                    &KeyName
                    );
    }
    RtlFreeUnicodeString( &KeyName );

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Result;
}

LONG
APIENTRY
RegDeleteKeyW (
    HKEY hKey,
    LPCWSTR lpKeyName
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for deleting a Key.

    RegDeleteKeyW converts the lpKeyName argument to a counted Unicode string
    and then calls BaseRegDeleteKey.

--*/

{
    UNICODE_STRING      KeyName;
    HKEY                TempHandle = NULL;
    LONG                Result;
    NTSTATUS            Status;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( lpKeyName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    // ASSERT( hKey != NULL );
    if( hKey == NULL ) {
        Result = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the Key name to a counted Unicode string.
    // This also acounts for the NULL we are adding at the end
    //
    Status = RtlInitUnicodeStringEx(&KeyName, lpKeyName);
    if( !NT_SUCCESS(Status) ) {
        Result = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //

    KeyName.Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

        Result = (LONG)LocalBaseRegDeleteKey (
                    hKey,
                    &KeyName
                    );
    } else {

        Result = (LONG)BaseRegDeleteKey (
                    DereferenceRemoteHandle( hKey ),
                    &KeyName
                    );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regekey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regekey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    enumerate key APIs.  That is:

        - RegEnumKeyA
        - RegEnumKeyW
        - RegEnumKeyExA
        - RegEnumKeyExW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regekey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"

LONG
APIENTRY
RegEnumKeyA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    )

/*++

Routine Description:

    Win 3.1 ANSI RPC wrapper for enumerating keys.

--*/

{
#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    return RegEnumKeyExA (
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL
        );
}

LONG
APIENTRY
RegEnumKeyW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for enumerating keys.

--*/

{
#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    return RegEnumKeyExW (
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL
        );
}

LONG
APIENTRY
RegEnumKeyExA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Win32 ANSI API for enumerating keys.

--*/

{
    UNICODE_STRING      Name;
    UNICODE_STRING      Class;
    WCHAR               ClassBuffer[ MAX_PATH ];
    PUNICODE_STRING     ClassPointer;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error = ERROR_SUCCESS;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Validate dependency between lpClass and lpcbClass parameters.
    //
    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpClass ) && ( ! ARGUMENT_PRESENT( lpcbClass ))) ||
        (!ARGUMENT_PRESENT( lpcbName ))
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey,&TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Allocate temporary buffer for the Name
    //
    Name.Length        = 0;
    Name.MaximumLength = (USHORT)((*lpcbName + 1) * sizeof( WCHAR ));
    Name.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, Name.MaximumLength );
    if( Name.Buffer == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitCleanup;
    }

    //
    // If the class string is to be returned, initialize a UNICODE_STRING
    //

    ClassPointer           = &Class;
    ClassPointer->Length   = 0;

    if( ARGUMENT_PRESENT( lpClass )) {

        ClassPointer->MaximumLength = MAX_PATH;
        ClassPointer->Buffer        = ( PVOID ) ClassBuffer;

    } else {

        ClassPointer->MaximumLength = 0;
        ClassPointer->Buffer        = NULL;
    }




    //
    // Call the Base API passing it a pointer to the counted Unicode
    // strings for the name and class.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegEnumKey (
                            hKey,
                            dwIndex,
                            &Name,
                            ClassPointer,
                            lpftLastWriteTime
                            );
    } else {

        Error = (LONG)BaseRegEnumKey (
                            DereferenceRemoteHandle( hKey ),
                            dwIndex,
                            &Name,
                            ClassPointer,
                            lpftLastWriteTime
                            );
    }

    //
    // If the information was not succesfully queried return the error.
    //

    if( Error != ERROR_SUCCESS ) {
        // free allocated buffer
        RtlFreeHeap( RtlProcessHeap(), 0, Name.Buffer );
        goto ExitCleanup;
    }

    //
    //  Subtact the NULL from Length, which was added by the server
    //  so that RPC would transmit it.
    //

    Name.Length -= sizeof( UNICODE_NULL );

    if ( ClassPointer->Length > 0 ) {
        ClassPointer->Length -= sizeof( UNICODE_NULL );
    }

    //
    // Convert the name to ANSI.
    //
    // If somebody passed in a really big buffer, pretend it's
    // not quite so big so that it doesn't get truncated to zero.
    //
    if (*lpcbName > 0xFFFF) {
        AnsiString.MaximumLength    = ( USHORT ) 0xFFFF;
    } else {
        AnsiString.MaximumLength    = ( USHORT ) *lpcbName;
    }

    AnsiString.Buffer           = lpName;

    Status = RtlUnicodeStringToAnsiString(
                &AnsiString,
                &Name,
                FALSE
                );

    // free allocated buffer
    RtlFreeHeap( RtlProcessHeap(), 0, Name.Buffer );

    //
    // If the name conversion failed, map and return the error.
    //

    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    // Update the name length return parameter.
    //

    *lpcbName = AnsiString.Length;

    //
    // If requested, convert the class to ANSI.
    //

    if( ARGUMENT_PRESENT( lpClass )) {

        AnsiString.MaximumLength    = ( USHORT ) *lpcbClass;
        AnsiString.Buffer           = lpClass;

        Status = RtlUnicodeStringToAnsiString(
                    &AnsiString,
                    ClassPointer,
                    FALSE
                    );

        //
        // If the class conversion failed, map and return the error.
        //

        if( ! NT_SUCCESS( Status )) {
            Error = RtlNtStatusToDosError( Status );
            goto ExitCleanup;
        }

        //
        // If requested, return the class length parameter w/o the NUL.
        //

        if( ARGUMENT_PRESENT( lpcbClass )) {
            *lpcbClass = AnsiString.Length;
        }

    //
    // It is possible to ask for the size of the class w/o asking for the
    // class itself.
    //

    } else if( ARGUMENT_PRESENT( lpcbClass )) {
        *lpcbClass = ( ClassPointer->Length >> 1 );
    }


ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD  lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for enumerating keys.

--*/


{
    LONG                Error;
    UNICODE_STRING      Name;
    UNICODE_STRING      Class;
    PUNICODE_STRING     ClassPointer;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Validate dependency between lpClass and lpcbClass parameters.
    //
    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpClass ) && ( ! ARGUMENT_PRESENT( lpcbClass ))) ||
        (!ARGUMENT_PRESENT( lpcbName ))
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Use the supplied name string buffer as the buffer in a counted
    // Unicode string.
    //

    Name.Length           = 0;
    if ((*lpcbName << 1) > 0xFFFE) {
        Name.MaximumLength    = ( USHORT ) 0xFFFE;
    } else {
        Name.MaximumLength    = ( USHORT )( *lpcbName << 1 );
    }
    Name.Buffer           = lpName;

    //
    // If supplied use the supplied name string buffer as the buffer in a
    // counted Unicode string.
    //
    ClassPointer        = &Class;

    if( ARGUMENT_PRESENT( lpClass )) {

        Class.Length        = 0;
        Class.MaximumLength = ( USHORT )( *lpcbClass << 1 );
        Class.Buffer        = lpClass;

    } else {

        Class.Length        = 0;
        Class.MaximumLength = 0;
        Class.Buffer        = NULL;
    }

    //
    // Call the Base API passing it a pointer to the counted Unicode
    // strings for the name and class and return the results.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegEnumKey (
                            hKey,
                            dwIndex,
                            &Name,
                            ClassPointer,
                            lpftLastWriteTime
                            );
    } else {

        Error = (LONG)BaseRegEnumKey (
                            DereferenceRemoteHandle( hKey ),
                            dwIndex,
                            &Name,
                            ClassPointer,
                            lpftLastWriteTime
                            );
    }

    //
    //  Subtact the NULL from Length, which was added by the server
    //  so that RPC would transmit it.
    //

    if ( Name.Length > 0 ) {
        Name.Length -= sizeof( UNICODE_NULL );
    }

    if ( ClassPointer->Length > 0 ) {
        ClassPointer->Length -= sizeof( UNICODE_NULL );
    }

    //
    // Return the name length parameter w/o the NUL.
    //

    if( Error == ERROR_SUCCESS ) {

        *lpcbName = ( Name.Length >> 1 );
    }

    //
    // If requested, return the class length parameter w/o the NUL.
    //

    if( ARGUMENT_PRESENT( lpcbClass )) {
        *lpcbClass = ( Class.Length >> 1 );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regeval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regeval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    enumerate value APIs.  That is:

        - RegEnumValueExA
        - RegEnumValueExW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regeval.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"



LONG
RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD  lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for enumerating values.

--*/

{
    UNICODE_STRING      Name;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error = ERROR_SUCCESS;
    DWORD               ValueType;
    DWORD               ValueLength;
    DWORD               InputLength;
    PWSTR               UnicodeValueBuffer;
    ULONG               UnicodeValueLength;
    PSTR                AnsiValueBuffer;
    ULONG               AnsiValueLength;
    ULONG               Index;
    BOOLEAN             Win95Server = FALSE;
    ULONG               cbAnsi = 0;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Validate dependency between lpData and lpcbData parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpData ) && ( ! ARGUMENT_PRESENT( lpcbData ))) ||
        (!ARGUMENT_PRESENT(lpcbValueName)) || (!ARGUMENT_PRESENT(lpValueName)) ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error =  ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Allocate temporary buffer for the Name
    //
    Name.Length        = 0;
    Name.MaximumLength = (USHORT)((*lpcbValueName + 1) * sizeof( WCHAR ));
    Name.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, Name.MaximumLength );
    if( Name.Buffer == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitCleanup;
    }

    //
    // Call the Base API passing it a pointer to the counted Unicode
    // strings for the value name. Note that zero bytes are transmitted (i.e.
    // InputLength = 0) for the data.
    //

    if (ARGUMENT_PRESENT( lpcbData )) {
        ValueLength = *lpcbData;
        }
    else {
        ValueLength = 0;
        }

    InputLength = 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegEnumValue (
                            hKey,
                            dwIndex,
                            &Name,
                            &ValueType,
                            lpData,
                            &ValueLength,
                            &InputLength
                            );

        ASSERT( Name.Buffer );

    } else {
        DWORD dwVersion;

        //
        // Check for a downlevel Win95 server, which requires
        // us to work around their BaseRegEnumValue bugs.
        // The returned ValueLength is one WCHAR too large AND
        // they trash two bytes beyond the end of the buffer
        // for REG_SZ, REG_MULTI_SZ, and REG_EXPAND_SZ
        //
        Win95Server = IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion);

        if (Win95Server) {
            LPBYTE lpWin95Data;
            //
            // This is a Win95 server.
            // Allocate a new buffer that is two bytes larger than
            // the old one so they can trash the last two bytes.
            //
            lpWin95Data = RtlAllocateHeap(RtlProcessHeap(),
                                          0,
                                          ValueLength+sizeof(WCHAR));
            if (lpWin95Data == NULL) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                                dwIndex,
                                                &Name,
                                                &ValueType,
                                                lpWin95Data,
                                                &ValueLength,
                                                &InputLength);
                if (Error == ERROR_SUCCESS) {
                    if ((ValueType == REG_SZ) ||
                        (ValueType == REG_MULTI_SZ) ||
                        (ValueType == REG_EXPAND_SZ)) {
                        //
                        // The returned length is one WCHAR too large
                        // and the last two bytes of the buffer are trashed.
                        //
                        ValueLength -= sizeof(WCHAR);
                    }
                    CopyMemory(lpData, lpWin95Data, ValueLength);
                }
                RtlFreeHeap(RtlProcessHeap(),0,lpWin95Data);
            }

        } else {
            Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                            dwIndex,
                                            &Name,
                                            &ValueType,
                                            lpData,
                                            &ValueLength,
                                            &InputLength);
        }

    }


    //
    // If no error or callers buffer too small, and type is one of the null
    // terminated string types, then do the UNICODE to ANSI translation.
    // We handle the buffer too small case, because the callers buffer may
    // be big enough for the ANSI representation, but not the UNICODE one.
    // In this case, we need to allocate a buffer big enough, do the query
    // again and then the translation into the callers buffer.
    //

    if ((Error == ERROR_SUCCESS || Error == ERROR_MORE_DATA) &&
        ARGUMENT_PRESENT( lpcbData ) &&
        (ValueType == REG_SZ ||
         ValueType == REG_EXPAND_SZ ||
         ValueType == REG_MULTI_SZ)
       ) {

        UnicodeValueLength         = ValueLength;

        AnsiValueBuffer        = lpData;
        AnsiValueLength        = ARGUMENT_PRESENT( lpcbData )? *lpcbData : 0;


        //
        // Allocate a buffer for the UNICODE value and reissue the query.
        //
        UnicodeValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                          UnicodeValueLength
                                        );
        if (UnicodeValueBuffer == NULL) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            InputLength = 0;

            if( IsLocalHandle( hKey )) {


                Error = (LONG)LocalBaseRegEnumValue (
                                    hKey,
                                    dwIndex,
                                    &Name,
                                    &ValueType,
                                    (LPBYTE)UnicodeValueBuffer,
                                    &ValueLength,
                                    &InputLength
                                    );
                //
                //  Make sure that the local side didn't destroy the
                //  Buffer in the Name
                //

                ASSERT(Name.Buffer);

            } else {
                if (Win95Server) {
                    LPBYTE lpWin95Data;
                    //
                    // This is a Win95 server.
                    // Allocate a new buffer that is two bytes larger than
                    // the old one so they can trash the last two bytes.
                    //
                    lpWin95Data = RtlAllocateHeap(RtlProcessHeap(),
                                                  0,
                                                  ValueLength+sizeof(WCHAR));
                    if (lpWin95Data == NULL) {
                        Error = ERROR_NOT_ENOUGH_MEMORY;
                    } else {
                        Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                                        dwIndex,
                                                        &Name,
                                                        &ValueType,
                                                        lpWin95Data,
                                                        &ValueLength,
                                                        &InputLength);
                        if (Error == ERROR_SUCCESS) {
                            if ((ValueType == REG_SZ) ||
                                (ValueType == REG_MULTI_SZ) ||
                                (ValueType == REG_EXPAND_SZ)) {
                                //
                                // The returned length is one WCHAR too large
                                // and the last two bytes of the buffer are trashed.
                                //
                                ValueLength -= sizeof(WCHAR);
                            }
                            CopyMemory(UnicodeValueBuffer, lpWin95Data, ValueLength);
                        }
                        RtlFreeHeap(RtlProcessHeap(),0,lpWin95Data);
                    }

                } else {
                    Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                                    dwIndex,
                                                    &Name,
                                                    &ValueType,
                                                    (LPBYTE)UnicodeValueBuffer,
                                                    &ValueLength,
                                                    &InputLength);
                }
            }
            // Compute needed buffer size , cbAnsi will keeps the byte
            // counts to keep MBCS string after following step.

            RtlUnicodeToMultiByteSize( &cbAnsi ,
                                       UnicodeValueBuffer ,
                                       ValueLength );

            // If we could not store all MBCS string to buffer that
            // Apps gives me. We set ERROR_MORE_DATA to Error

            if( ARGUMENT_PRESENT( lpcbData ) ) {
                if( cbAnsi > *lpcbData && lpData != NULL ) {
                    Error = ERROR_MORE_DATA;
                }
            }
        }

        if ((Error == ERROR_SUCCESS) && (AnsiValueBuffer != NULL)) {

            //
            // We have a UNICODE value, so translate it to ANSI in the callers
            // buffer.  In the case where the caller's buffer was big enough
            // for the UNICODE version, we do the conversion in place, which
            // works since the ANSI version is smaller than the UNICODE version.
            //


            Index = 0;
            Status = RtlUnicodeToMultiByteN( AnsiValueBuffer,
                                             AnsiValueLength,
                                             &Index,
                                             UnicodeValueBuffer,
                                             UnicodeValueLength
                                           );

            if (!NT_SUCCESS( Status )) {
                Error = RtlNtStatusToDosError( Status );
            }
            cbAnsi = Index;
        }

        //
        // Free the unicode buffer if it was successfully allocated
        //
        if (UnicodeValueBuffer != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValueBuffer );
        }

        //
        // Return the length of the ANSI version to the caller.
        //

        ValueLength = cbAnsi;

        //
        // Special hack to help out all the peopl who
        // believe the length of a NULL terminated string is
        // strlen(foo) instead of strlen(foo) + 1.
        // If the last character of the buffer is not a NULL
        // and there is enough space left in the caller's buffer,
        // slap a NULL in there to prevent him from going nuts
        // trying to do a strlen().
        //
        if (ARGUMENT_PRESENT( lpData ) &&
            (*lpcbData > ValueLength)  &&
            (ValueLength > 0) &&
            (lpData[ValueLength-1] != '\0')) {

            lpData[ValueLength] = '\0';
        }
    }

    //
    // Return the value type and data length if requested and we have it.
    //

    if (Error == ERROR_SUCCESS || Error == ERROR_MORE_DATA) {

        if (lpcbData != NULL) {
            *lpcbData = ValueLength;
        }

        if (lpType != NULL) {
            *lpType = ValueType;
        }
    }

    //
    // If the information was not succesfully queried return the error.
    //

    if( Error != ERROR_SUCCESS ) {
        // free allocated buffer
        RtlFreeHeap( RtlProcessHeap(), 0, Name.Buffer );
        goto ExitCleanup;
    }


    //
    //  Subtract the NULL from the Length. This was added by the server
    //  so that RPC would transmit it.
    //

    if ( Name.Length > 0 ) {
        Name.Length -= sizeof( UNICODE_NULL );
    }

    //
    // Convert the name to ANSI.
    //

    AnsiString.MaximumLength    = ( USHORT ) *lpcbValueName;
    AnsiString.Buffer           = lpValueName;

    Status = RtlUnicodeStringToAnsiString(
                &AnsiString,
                &Name,
                FALSE
                );


    // free allocated buffer
    RtlFreeHeap( RtlProcessHeap(), 0, Name.Buffer );
    //
    // If the name conversion failed, map and return the error.
    //

    if( ! NT_SUCCESS( Status )) {


        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    // Update the name length return parameter.
    //

    *lpcbValueName = AnsiString.Length;


ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}



LONG
RegEnumValueW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for enumerating values.

--*/

{
    UNICODE_STRING      Name;
    LONG                Error;
    DWORD               InputLength;
    DWORD               ValueLength;
    DWORD               ValueType;
    HKEY                TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Validate dependency between lpData and lpcbData parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpData ) && ( ! ARGUMENT_PRESENT( lpcbData ))) ||
        (!ARGUMENT_PRESENT(lpcbValueName)) || (!ARGUMENT_PRESENT(lpValueName)) ) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    Name.Length           = 0;
    Name.MaximumLength    = ( USHORT )( *lpcbValueName << 1 );
    Name.Buffer           = lpValueName;

    //
    // Call the Base API passing it a pointer to the counted Unicode
    // string for the name and return the results. Note that zero bytes
    // are transmitted (i.e.InputLength = 0) for the data.
    //

    InputLength = 0;
    ValueLength = ( ARGUMENT_PRESENT( lpcbData ) )? *lpcbData : 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegEnumValue (
                            hKey,
                            dwIndex,
                            &Name,
                            &ValueType,
                            lpData,
                            &ValueLength,
                            &InputLength
                            );
    } else {
        DWORD dwVersion;

        if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
            LPBYTE lpWin95Data;
            //
            // This is a Win95 server.
            // Allocate a new buffer that is two bytes larger than
            // the old one so they can trash the last two bytes.
            //
            lpWin95Data = RtlAllocateHeap(RtlProcessHeap(),
                                          0,
                                          ValueLength+sizeof(WCHAR));
            if (lpWin95Data == NULL) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto ExitCleanup;
            } else {
                Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                                dwIndex,
                                                &Name,
                                                &ValueType,
                                                lpWin95Data,
                                                &ValueLength,
                                                &InputLength);
                if (Error == ERROR_SUCCESS) {
                    if ((ValueType == REG_SZ) ||
                        (ValueType == REG_MULTI_SZ) ||
                        (ValueType == REG_EXPAND_SZ)) {
                        //
                        // The returned length is one WCHAR too large
                        // and the last two bytes of the buffer are trashed.
                        //
                        ValueLength -= sizeof(WCHAR);
                    }
                    CopyMemory(lpData, lpWin95Data, ValueLength);
                }
                RtlFreeHeap(RtlProcessHeap(),0,lpWin95Data);
            }

        } else {
            Error = (LONG)BaseRegEnumValue (DereferenceRemoteHandle( hKey ),
                                            dwIndex,
                                            &Name,
                                            &ValueType,
                                            lpData,
                                            &ValueLength,
                                            &InputLength);
        }
    }
    //
    // Special hack to help out all the people who
    // believe the length of a NULL terminated string is
    // strlen(foo) instead of strlen(foo) + 1.
    // If the last character of the buffer is not a NULL
    // and there is enough space left in the caller's buffer,
    // slap a NULL in there to prevent him from going nuts
    // trying to do a strlen().
    //
    if ( (Error == ERROR_SUCCESS) &&
         ARGUMENT_PRESENT( lpData ) &&
         ( (ValueType == REG_SZ) ||
           (ValueType == REG_EXPAND_SZ) ||
           (ValueType == REG_MULTI_SZ)) &&
         ( ValueLength > sizeof(WCHAR))) {

        UNALIGNED WCHAR *String = (UNALIGNED WCHAR *)lpData;
        DWORD Length = ValueLength/sizeof(WCHAR);

        if ((String[Length-1] != UNICODE_NULL) &&
            (ValueLength+sizeof(WCHAR) <= *lpcbData)) {
            String[Length] = UNICODE_NULL;
        }
    }

    //
    // Don't count the NUL.
    //
    if( Name.Length != 0 ) {
        *lpcbValueName = ( Name.Length >> 1 ) - 1;
    }

    if( ARGUMENT_PRESENT( lpcbData ) ) {
        *lpcbData = ValueLength;
    }
    if ( ARGUMENT_PRESENT( lpType )) {
        *lpType = ValueType;
    }

ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regcnreg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regcnreg.c

Abstract:

    This module contains the Win32 Registry APIs to connect to a remote
    Registry.  That is:

       - RegConnectRegistryA
       - RegConnectRegistryW
Author:

    David J. Gilman (davegi) 25-Mar-1992

Notes:

    The semantics of this API make it local only. That is there is no MIDL
    definition for RegConnectRegistry although it does call other client
    stubs, specifically OpenLocalMachine and OpenUsers.

Revision History:

    John Vert (jvert) 16-Jun-1995
       Added connect support for protocols other than named pipes by
       stealing code from Win95. This enabled NT machines to connect
       to registries on Win95 machines

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include "shutinit.h"
#include "..\regconn\regconn.h"

LONG
BaseBindToMachine(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    );


typedef int (* RegConnFunction)(LPCWSTR, handle_t *);

RegConnFunction conn_functions[] = {
        RegConn_np,
        RegConn_spx,
        RegConn_ip_tcp,
        RegConn_nb_nb,
        RegConn_nb_tcp,
        RegConn_nb_ipx,
        NULL
};

LONG
Rpc_OpenPredefHandle(
    IN RPC_BINDING_HANDLE * pbinding OPTIONAL,
    IN HKEY hKey,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Win32 Unicode API for establishing a connection to a predefined
    handle on another machine.

Parameters:

    pbinding - This is a pointer to the binding handle in order
                to allow access to multiple protocols (NT remote registry is only over
                named pipes).

    hKey - Supplies the predefined handle to connect to on the remote
        machine. Currently this parameter must be one of:

        - HKEY_LOCAL_MACHINE
        - HKEY_PERFORMANCE_DATA
        - HKEY_USERS

    phkResult - Returns a handle which represents the supplied predefined
        handle on the supplied machine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.
        On failure, the binding handle is freed.

Notes:

    For administration purposes this API allows programs to access the
    Registry on a remote machine.  In the current system the calling
    application must know the name of the remote machine that it wishes to
    connect to.  However, it is expected that in the future a directory
    service API will return the parameters necessary for this API.

--*/

{
    LONG    Error;
    HKEY    PreviousResult;

    ASSERT( (phkResult != NULL));
    PreviousResult = *phkResult;

    switch ((int)(ULONG_PTR)hKey)
    {
        case (int)(ULONG_PTR)HKEY_LOCAL_MACHINE:

            Error = (LONG)OpenLocalMachine((PREGISTRY_SERVER_NAME) pbinding,
                                           MAXIMUM_ALLOWED,
                                           phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_DATA:

            Error = (LONG)OpenPerformanceData((PREGISTRY_SERVER_NAME) pbinding,
                                              MAXIMUM_ALLOWED,
                                              phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_USERS:

            Error = (LONG)OpenUsers((PREGISTRY_SERVER_NAME) pbinding,
                                    MAXIMUM_ALLOWED,
                                    phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_CLASSES_ROOT:

            Error = (LONG)OpenClassesRoot((PREGISTRY_SERVER_NAME) pbinding,
                                          MAXIMUM_ALLOWED,
                                          phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_CURRENT_USER:

            Error = (LONG)OpenCurrentUser((PREGISTRY_SERVER_NAME) pbinding,
                                          MAXIMUM_ALLOWED,
                                          phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_TEXT:

            Error = (LONG)OpenPerformanceText((PREGISTRY_SERVER_NAME) pbinding,
                                              MAXIMUM_ALLOWED,
                                              phkResult );

            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_NLSTEXT:

            Error = (LONG)OpenPerformanceNlsText((PREGISTRY_SERVER_NAME) pbinding,
                                              MAXIMUM_ALLOWED,
                                              phkResult );

            break;

        default:
            Error = ERROR_INVALID_HANDLE;
    }

    if( Error != ERROR_SUCCESS) {
        //ASSERTMSG("WINREG: RPC failed, but modifed phkResult", *phkResult == PreviousResult);
        if (*pbinding != NULL)
            RpcBindingFree(pbinding);
    }

    return Error;
}

LONG
LocalOpenPredefHandle(
    IN HKEY hKey,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Opens a predefined handle locally. The purpose of this is to bypass RPC in the 
    case of connecting to the local machine.

Parameters:

    hKey - Supplies the predefined handle to connect to on the remote
        machine. Currently this parameter must be one of:

        - HKEY_LOCAL_MACHINE
        - HKEY_PERFORMANCE_DATA
        - HKEY_USERS

    phkResult - Returns a handle which represents the supplied predefined
        handle on the supplied machine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    LONG    Error;

    ASSERT( (phkResult != NULL));

    switch ((int)(ULONG_PTR)hKey)
    {
        case (int)(ULONG_PTR)HKEY_LOCAL_MACHINE:

            Error = (LONG)LocalOpenLocalMachine(NULL,
                                           MAXIMUM_ALLOWED,
                                           phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_DATA:

            Error = (LONG)LocalOpenPerformanceData(NULL,
                                              MAXIMUM_ALLOWED,
                                              phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_USERS:

            Error = (LONG)LocalOpenUsers(NULL,
                                    MAXIMUM_ALLOWED,
                                    phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_CLASSES_ROOT:

            Error = (LONG)LocalOpenClassesRoot(NULL,
                                          MAXIMUM_ALLOWED,
                                          phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_CURRENT_USER:

            Error = (LONG)LocalOpenCurrentUser(NULL,
                                          MAXIMUM_ALLOWED,
                                          phkResult );
            break;

        case (int)(ULONG_PTR)HKEY_PERFORMANCE_TEXT:
        case (int)(ULONG_PTR)HKEY_PERFORMANCE_NLSTEXT:
        case (int)(ULONG_PTR)HKEY_CURRENT_CONFIG:
        case (int)(ULONG_PTR)HKEY_DYN_DATA:
            //
            // try not to break whoever used this
            //
            *phkResult = hKey;
            Error = ERROR_SUCCESS;
            break;

        default:
            Error = ERROR_INVALID_HANDLE;
    }

    return Error;
}

LONG
RegConnectRegistryW (
    IN LPCWSTR lpMachineName OPTIONAL,
    IN HKEY hKey,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Win32 Unicode API for establishing a connection to a predefined
    handle on another machine.

Parameters:

    lpMachineName - Supplies a pointer to a null-terminated string that
    names the machine of interest.  If this parameter is NULL, the local
    machine name is used.

    hKey - Supplies the predefined handle to connect to on the remote
    machine. Currently this parameter must be one of:

    - HKEY_LOCAL_MACHINE
    - HKEY_PERFORMANCE_DATA
    - HKEY_USERS

    phkResult - Returns a handle which represents the supplied predefined
    handle on the supplied machine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    For administration purposes this API allows programs to access the
    Registry on a remote machine.  In the current system the calling
    application must know the name of the remote machine that it wishes to
    connect to.  However, it is expected that in the future a directory
    service API will return the parameters necessary for this API.

    Even though HKEY_CLASSES and HKEY_CURRENT_USER are predefined handles,
    they are not supported by this API as they do not make sense in the
    context of a remote Registry.

--*/

{
    LONG    Error;
    WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   bufLen = MAX_COMPUTERNAME_LENGTH + 1;

    ASSERT( ARGUMENT_PRESENT( phkResult ));

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif
    //
    // Check for local connect
    //

    if (lpMachineName == NULL) {
        //
        // always return a valid handle
        //
        Error = LocalOpenPredefHandle(hKey,phkResult);
        return Error;
    } else if (lpMachineName[0] == L'\0') {
        //
        // always return a valid handle
        //
        Error = LocalOpenPredefHandle(hKey,phkResult);
        return Error;
    }

    if (GetComputerNameW(ComputerName,&bufLen)) {

        if ((_wcsicmp(ComputerName,lpMachineName) == 0) ||
                ((lpMachineName[0] == '\\') &&
                 (lpMachineName[1] == '\\') &&
                 (_wcsicmp(ComputerName,&(lpMachineName[2]))==0))) {
            //
            // local connect
            //
            //
            // always return a valid handle
            //
            Error = LocalOpenPredefHandle(hKey,phkResult);
            return Error;
        } 
    } 

    Error = BaseBindToMachine(lpMachineName,
                              Rpc_OpenPredefHandle,
                              (PVOID)hKey,
                              (PVOID)phkResult);

    if( Error == ERROR_SUCCESS) {
        TagRemoteHandle( phkResult );
    }
    return Error;
}

LONG
BaseBindToMachine(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    )

/*++

Routine Description:

    This is a helper routine used to create an RPC binding from
    a given machine name.

Arguments:

    lpMachineName - Supplies a pointer to a machine name. Must not
                    be NULL.

    BindCallback - Supplies the function that should be called once
                   a binding has been created to initiate the connection.

    Context1 - Supplies the first parameter to pass to the callback routine.

    Context2 - Supplies the second parameter to pass to the callback routine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    LONG                Error;
    int                 i;
    RegConnFunction     conn_fn;
    RPC_BINDING_HANDLE  binding;

    conn_fn = conn_functions[0];
    i = 1;

    //
    // Iterate through the protocols until we find one that
    // can connect.
    //
    do {
        Error = conn_fn(lpMachineName,&binding);

        if (Error == ERROR_SUCCESS) {

            //
            // For the named pipes protocol, we use a static endpoint, so the
            // call to RpcEpResolveBinding is not needed.
            //
            if (conn_fn != RegConn_np) {
                Error = (LONG)RpcEpResolveBinding(binding,winreg_ClientIfHandle);

                if (Error == ERROR_SUCCESS) {
                    Error = (LONG)RpcBindingSetAuthInfo(binding,
                                            "",     // ServerPrincName
                                            RPC_C_AUTHN_LEVEL_CONNECT,
                                            RPC_C_AUTHN_WINNT,
                                            NULL,   // AuthIdentity
                                            RPC_C_AUTHZ_NONE);
                }
            } 

            if (Error == ERROR_SUCCESS) {
                Error = (BindCallback)(&binding,
                                       Context1,
                                       Context2);
                RpcBindingFree(&binding);
                if (Error != RPC_S_SERVER_UNAVAILABLE) {
                    return Error;
                }
            } else {
                RpcBindingFree(&binding);
            }
        }

        //
        // Try the next protocol's connection function.
        //
        if (Error) {
            conn_fn = conn_functions[i];
            i++;
        }

    } while (!((Error == ERROR_SUCCESS) || (conn_fn == NULL)));

    if (Error != ERROR_SUCCESS) {
        if ((Error == RPC_S_INVALID_ENDPOINT_FORMAT) ||
            (Error == RPC_S_INVALID_NET_ADDR) ) {
            Error = ERROR_INVALID_COMPUTERNAME;
        } else {
            Error = ERROR_BAD_NETPATH;
        }
    }

    return(Error);
}

    
LONG
APIENTRY
RegConnectRegistryA (
    LPCSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win32 ANSI API for establishes a connection to a predefined handle on
    another machine.

    RegConnectRegistryA converts the lpMachineName argument to a Unicode
    string and then calls RegConnectRegistryW.

--*/

{
    UNICODE_STRING  MachineName;
    ANSI_STRING     AnsiString;
    NTSTATUS        Status;
    LONG            Error;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Convert the subkey to a counted Unicode string
    //

    Status = RtlInitAnsiStringEx( &AnsiString, lpMachineName );
    if( ! NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
    }
    Status = RtlAnsiStringToUnicodeString(&MachineName,
                                          &AnsiString,
                                          TRUE);

    if( ! NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
    }

    Error = (LONG)RegConnectRegistryW(MachineName.Buffer,
                                      hKey,
                                      phkResult);
    RtlFreeUnicodeString(&MachineName);
    return Error;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regkey.c ===
/*++



Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    Regkey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to open, create, flush and close keys.  That is:

        - RegCloseKey
        - RegCreateKeyA
        - RegCreateKeyW
        - RegCreateKeyExA
        - RegCreateKeyExW
        - RegFlushKey
        - RegOpenKeyA
        - RegOpenKeyW
        - RegOpenKeyExA
        - RegOpenKeyExW
        - RegOverridePredefKey
        - RegOpenCurrentUser

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    See the notes in server\regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <wow64reg.h>

#if defined(LEAK_TRACK)
NTSTATUS TrackObject(HKEY hKey);
#endif // defined(LEAK_TRACK)

NTSTATUS DisablePredefinedHandleTable(HKEY Handle);


LONG
APIENTRY
RegCloseKey (
    IN HKEY hKey
    )

/*++

Routine Description:

    Win32 RPC wrapper for closeing a key handle.

--*/

{

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( hKey == NULL ) {
        return ERROR_INVALID_HANDLE;
    }

    if( IsPredefinedRegistryHandle( hKey )) {
        return( ClosePredefinedHandle( hKey ) );
    }

    if( IsLocalHandle( hKey )) {

#if defined(_WIN64)
        Wow64RegCloseKey (hKey);
#endif
        return ( LONG ) LocalBaseRegCloseKey( &hKey );

    } else {

        hKey = DereferenceRemoteHandle( hKey );
        return ( LONG ) BaseRegCloseKey( &hKey );
    }
}

LONG
APIENTRY
RegOverridePredefKey (
    IN HKEY hKey,
	IN HKEY hNewKey
    )

/*++

Routine Description:

    Win32 wrapper to override the normal value for a predefined key.

--*/

{

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( hKey == NULL ) {
        return ERROR_INVALID_HANDLE;
    }

    if( !IsPredefinedRegistryHandle( hKey )) {
        return ERROR_INVALID_HANDLE;
    }

    {
	NTSTATUS Status;

	Status = RemapPredefinedHandle( hKey, hNewKey );

	return RtlNtStatusToDosError( Status );
    }
}

LONG
APIENTRY
RegCreateKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win 3.1 ANSI RPC wrapper for opening an existing key or creating a new one.

--*/

{
    LONG    Error;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Win3.1ism - Win 3.1 allows the predefined handle to be opened by
    // specifying a pointer to an empty or NULL string for the sub-key.
    //

    //
    // If the subkey is NULL or points to a NUL string and the handle is
    // predefined, just return the predefined handle (a virtual open)
    // otherwise it's an error.
    //

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        if( IsPredefinedRegistryHandle( hKey )) {

            *phkResult = hKey;
            return ERROR_SUCCESS;

        } else {

            return ERROR_BADKEY;
        }
    }

    Error = (LONG)RegCreateKeyExA(
                            hKey,
                            lpSubKey,
                            0,
                            WIN31_CLASS,
                            REG_OPTION_NON_VOLATILE,
                            WIN31_REGSAM,
                            NULL,
                            phkResult,
                            NULL
                            );

    return Error;

}

LONG
APIENTRY
RegCreateKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for opening an existing key or creating a
    new one.

--*/

{
    LONG    Error;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    Error =  (LONG)RegCreateKeyExW(
                            hKey,
                            lpSubKey,
                            0,
                            WIN31_CLASS,
                            REG_OPTION_NON_VOLATILE,
                            WIN31_REGSAM,
                            NULL,
                            phkResult,
                            NULL
                            );

    return Error;

}

LONG
APIENTRY
RegCreateKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for opening an existing key or creating a new one.

    RegCreateKeyExA converts the LPSECURITY_ATTRIBUTES argument to a
    RPC_SECURITY_ATTRIBUTES argument and calls BaseRegCreateKeyExA.

--*/

{
    UNICODE_STRING              SubKey;
    UNICODE_STRING              ClassUnicode;
    PUNICODE_STRING             Class;
    ANSI_STRING                 AnsiString;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    NTSTATUS                    Status;
    LONG                        Error;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        OutputDebugString( "In RegCreateKeyExA\n" );
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {

        return ERROR_INVALID_HANDLE;
    }

    //
    // Ensure Reserved is zero to avoid future compatability problems.
    //

    if( Reserved != 0 ) {
            return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate that the sub key is not NULL.
    //
    if( !lpSubKey || !phkResult ) {
        return ERROR_BADKEY;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the subkey to a counted Unicode string 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        Status = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add size of NULL so that RPC transmits the right
    //  stuff.
    //
    SubKey.Length += sizeof( UNICODE_NULL );

    if (ARGUMENT_PRESENT( lpClass )) {

        //
        // Convert the class name to a counted Unicode string using a counted
        // Unicode string dynamically allocated by RtlAnsiStringToUnicodeString.
        //

        RtlInitAnsiString( &AnsiString, lpClass );
        Status = RtlAnsiStringToUnicodeString(
                    &ClassUnicode,
                    &AnsiString,
                    TRUE
                    );

        if( ! NT_SUCCESS( Status )) {
            Error = RtlNtStatusToDosError( Status );
            RtlFreeUnicodeString( &SubKey );
            goto ExitCleanup;
        }

        Class = &ClassUnicode;
        Class->Length += sizeof( UNICODE_NULL );

    } else {

        Class = &ClassUnicode;

        Class->Length        = 0;
        Class->MaximumLength = 0;
        Class->Buffer        = NULL;
    }

    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it to the RPCable version.
    //

    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            RtlFreeUnicodeString( Class );
            RtlFreeUnicodeString( &SubKey );
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //

        pRpcSA = NULL;
    }

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

#if defined(_WIN64)
        DWORD dwTempDisposition = 0;
        if ( lpdwDisposition == NULL )
            lpdwDisposition = &dwTempDisposition;

        //
        //  if wow64 reserve field is set in the access mask, call
        //  wow64 function to handle the scenario.
        //

        if ( samDesired & KEY_WOW64_RES ) {

            Error = (LONG)Wow64RegCreateKeyEx (
                            hKey,
                            SubKey.Buffer,
                            0, //reserved
                            Class->Buffer,
                            dwOptions,
                            samDesired,
                            lpSecurityAttributes,
                            phkResult,
                            lpdwDisposition
                            );

        } else
#endif

        Error = (LONG)LocalBaseRegCreateKey (
                            hKey,
                            &SubKey,
                            Class,
                            dwOptions,
                            samDesired,
                            pRpcSA,
                            phkResult,
                            lpdwDisposition
                            );
#if defined(_WIN64)

        if ( ( Error == 0) && ( REG_CREATED_NEW_KEY & *lpdwDisposition) ) //only set dirty if its a newly created key
                    Wow64RegSetKeyDirty (*phkResult);
#endif
    } else {

        Error = (LONG)BaseRegCreateKey (
                            DereferenceRemoteHandle( hKey ),
                            &SubKey,
                            Class,
                            dwOptions,
                            samDesired,
                            pRpcSA,
                            phkResult,
                            lpdwDisposition
                            );

        if( Error == ERROR_SUCCESS) {

            TagRemoteHandle( phkResult );
        }
    }

    //
    // Free the counted Unicode string allocated by
    // RtlAnsiStringToUnicodeString.
    //

    if (Class != NULL) {
        RtlFreeUnicodeString( Class );
    }

    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer and return the
    // Registry return value.
    //

    if( pRpcSA != NULL ) {

        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }
    
    RtlFreeUnicodeString( &SubKey );

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for opening an existing key or creating a new one.

    RegCreateKeyExW converts the LPSECURITY_ATTRIBUTES argument to a
    RPC_SECURITY_ATTRIBUTES argument and calls BaseRegCreateKeyExW.

--*/

{
    UNICODE_STRING              SubKey;
    UNICODE_STRING              ClassUnicode;
    PUNICODE_STRING             Class;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    LONG                        Error;
    PWSTR                       AuxBuffer;
    HKEY                        TempHandle = NULL;
    NTSTATUS                    Status;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Ensure Reserved is zero to avoid future compatability problems.
    //

    if( Reserved != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Validate that the sub key is not NULL.
    //

    if( !lpSubKey || !phkResult) {
        return ERROR_BADKEY;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the subkey to a counted Unicode string.
    // This also acounts for the NULL we are adding at the end
    //
    Status = RtlInitUnicodeStringEx(&SubKey, lpSubKey);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }
    //
    //  Add terminating NULL to Length so that RPC transmits it.
    //
    SubKey.Length += sizeof( UNICODE_NULL );

    if (ARGUMENT_PRESENT( lpClass )) {
        //
        // Convert the class name to a counted Unicode string.
        // This also acounts for the NULL we are adding at the end
        //
        Status = RtlInitUnicodeStringEx(&ClassUnicode, lpClass);
        if( !NT_SUCCESS(Status) ) {
            Error = RtlNtStatusToDosError( Status );
            goto ExitCleanup;
        }

        Class = &ClassUnicode;
        Class->Length += sizeof( UNICODE_NULL );

    } else {

        Class = &ClassUnicode;

        Class->Length        = 0;
        Class->MaximumLength = 0;
        Class->Buffer        = NULL;
    }


    //
    // If the caller supplied a LPSECURITY_ATTRIBUTES argument, map
    // it and call the private version of the create key API.
    //

    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //

        pRpcSA = NULL;
    }

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

#if defined(_WIN64)
        DWORD dwTempDisposition = 0;
        if ( lpdwDisposition == NULL )
            lpdwDisposition = &dwTempDisposition;

        //
        //  if wow64 reserve field is set in the access mask, call
        //  wow64 function to handle the scenario.
        //

        if ( samDesired & KEY_WOW64_RES ) {

            Error = (LONG)Wow64RegCreateKeyEx (
                            hKey,
                            SubKey.Buffer,
                            0, //reserved
                            Class->Buffer,
                            dwOptions,
                            samDesired,
                            lpSecurityAttributes,
                            phkResult,
                            lpdwDisposition
                            );
        } else
#endif
        Error = (LONG)LocalBaseRegCreateKey (
                            hKey,
                            &SubKey,
                            Class,
                            dwOptions,
                            samDesired,
                            pRpcSA,
                            phkResult,
                            lpdwDisposition
                            );
#if defined(_WIN64)

        if ( ( Error == 0) && ( REG_CREATED_NEW_KEY & *lpdwDisposition) ) //only set dirty if its a newly created key
                    Wow64RegSetKeyDirty (*phkResult);
#endif
    } else {

        Error = (LONG)BaseRegCreateKey (
                            DereferenceRemoteHandle( hKey ),
                            &SubKey,
                            Class,
                            dwOptions,
                            samDesired,
                            pRpcSA,
                            phkResult,
                            lpdwDisposition
                            );

        if( Error == ERROR_SUCCESS) {

            TagRemoteHandle( phkResult );
        }
    }

    //
    // Free the RPC_SECURITY_DESCRIPTOR buffer and return the
    // Registry return value.
    //

    if( pRpcSA != NULL ) {

        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            pRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegFlushKey (
    IN HKEY hKey
    )

/*++

Routine Description:

    Win32 RPC wrapper for flushing changes to backing store.

--*/

{
    LONG                        Error;
    HKEY                        TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Flush is a NO-OP for HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {
        return ERROR_SUCCESS;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegFlushKey( hKey );

    } else {

        Error = (LONG)BaseRegFlushKey( DereferenceRemoteHandle( hKey ));
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegOpenKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win 3.1 ANSI RPC wrapper for opening an existing key.

--*/

{
    LONG    Error;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Win3.1ism - Win 3.1 allows the predefined handle to be opened by
    // specifying a pointer to an empty or NULL string for the sub-key.
    //

    //
    // If the subkey is NULL or points to a NUL string and the handle is
    // predefined, just return the predefined handle (a virtual open)
    // otherwise return the same handle that was passed in.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {
        if( !IsPredefinedRegistryHandle( hKey )) {
            *phkResult = hKey;
            return ERROR_SUCCESS;
        }

/*
        if( IsPredefinedRegistryHandle( hKey )) {

            *phkResult = hKey;
            return ERROR_SUCCESS;

        } else {

            return ERROR_BADKEY;
        }
*/
    }

    Error = (LONG)RegOpenKeyExA(
                        hKey,
                        lpSubKey,
                        REG_OPTION_RESERVED,
                        WIN31_REGSAM,
                        phkResult
                        );

    return Error;

}

LONG
APIENTRY
RegOpenKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for opening an existing key.

--*/

{

    LONG    Error;

#if DBG
    if ( BreakPointOnEntry ) {
        OutputDebugString( "In RegOpenKeyW\n" );
        DbgBreakPoint();
    }
#endif

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Win3.1ism - Win 3.1 allows the predefined handle to be opened by
    // specifying a pointer to an empty or NULL string for the sub-key.
    //

    //
    // If the subkey is NULL or points to a NUL string and the handle is
    // predefined, just return the predefined handle (a virtual open)
    // otherwise return the handle passed in.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {
        if( !IsPredefinedRegistryHandle( hKey )) {
            *phkResult = hKey;
            return ERROR_SUCCESS;
        }

/*
        if( IsPredefinedRegistryHandle( hKey )) {

            *phkResult = hKey;
            return ERROR_SUCCESS;

        } else {

            return ERROR_BADKEY;
        }
*/
    }

    Error = (LONG)RegOpenKeyExW(
                         hKey,
                         lpSubKey,
                         REG_OPTION_RESERVED,
                         WIN31_REGSAM,
                         phkResult
                         );

    return Error;

}

LONG
APIENTRY
RegOpenKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for opening an existing key.

    RegOpenKeyExA converts the lpSubKey argument to a counted Unicode string
    and then calls BaseRegOpenKey.

--*/

{
    UNICODE_STRING      SubKey;
    NTSTATUS            Status;
    LONG                Error;
    CHAR                NullString;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Caller must pass pointer to the variable where the opened handle
    //  will be returned
    //

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  If lpSubKey is NULL, then assume NUL-string as subkey name
    //

    if( lpSubKey == NULL ) {
        NullString = ( CHAR )'\0';
        lpSubKey = &NullString;
    }

    //
    //  If hKey is a predefined key, and lpSubKey is either a NULL pointer or
    //  a NUL string, close the predefined key and clear the associated entry
    //  in the PredefinedHandleTable  (RegCloseKey will do the job).
    //
    if( IsPredefinedRegistryHandle( hKey ) && (!( samDesired & KEY_WOW64_RES )) &&
        ( ( lpSubKey == NULL ) || ( *lpSubKey == '\0' ) ) ) {

        if ( HKEY_CLASSES_ROOT != hKey ) {
            Error = RegCloseKey( hKey );
            if( Error != ERROR_SUCCESS ) {
                return( Error );
            }
            //
            //  Create a handle and save it in the appropriate entry  in
            //  PredefinedHandleTable.
            //  Notice that the client will be impersonated.
            //  (MapPredefinedHandle will do all this stuff).
            //
            if( MapPredefinedHandle( hKey, &TempHandle ) == NULL ) {
                Error = ERROR_INVALID_HANDLE;
                goto ExitCleanup;
            }
        }

        //
        //  Return to the user the handle passed in
        //
        *phkResult = hKey;
        Error = ERROR_SUCCESS;
        goto ExitCleanup;
    }


    //
    // Validate that the sub key is not NULL.
    //

    ASSERT( lpSubKey != NULL );
    if( ! lpSubKey ) {
        Error = ERROR_BADKEY;
        goto ExitCleanup;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the subkey to a counted Unicode string 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        Status = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it.
    //
    SubKey.Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {
#if defined(_WIN64)

        //
        //  if wow64 reserve field is set in the access mask, call
        //  wow64 function to handle the scenario.
        //

        if ( samDesired & KEY_WOW64_RES ) {

            Error = (LONG)Wow64RegOpenKeyEx (
                            hKey,
                            SubKey.Buffer,
                            dwOptions,
                            samDesired,
                            phkResult
                            );
        } else
#endif

        Error = (LONG)LocalBaseRegOpenKey (
                            hKey,
                            &SubKey,
                            dwOptions,
                            samDesired,
                            phkResult
                            );
    } else {

        Error = (LONG)BaseRegOpenKey (
                            DereferenceRemoteHandle( hKey ),
                            &SubKey,
                            dwOptions,
                            samDesired,
                            phkResult
                            );

        if( Error == ERROR_SUCCESS) {

            TagRemoteHandle( phkResult );
        }
    }

    // free the allocated unicode string
    RtlFreeUnicodeString( &SubKey );

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for opening an existing key.

    RegOpenKeyExW converts the lpSubKey argument to a counted Unicode string
    and then calls BaseRegOpenKey.

--*/

{
    UNICODE_STRING      SubKey;
    LONG                Error;
    WCHAR               NullString;
    HKEY                TempHandle = NULL;
    NTSTATUS            Status;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  Caller must pass pointer to the variable where the opened handle
    //  will be returned
    //

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  If lpSubKey is NULL, then assume NUL-string as subkey name
    //

    if( lpSubKey == NULL ) {
        NullString = UNICODE_NULL;
        lpSubKey = &NullString;
    }

    //
    //  If hKey is a predefined key, and lpSubKey is either a NULL pointer or
    //  a NUL string, close the predefined key and clear the associated entry
    //  in the PredefinedHandleTable  (RegCloseKey will do the job).
    //
    if( IsPredefinedRegistryHandle( hKey ) && (!( samDesired & KEY_WOW64_RES )) &&
        ( ( lpSubKey == NULL ) || ( *lpSubKey == ( WCHAR )'\0' ) ) ) {

        if ( HKEY_CLASSES_ROOT != hKey ) {
            Error = RegCloseKey( hKey );
            if( Error != ERROR_SUCCESS ) {
                return( Error );
            }
            //
            //  Create a handle and save it in the appropriate entry  in
            //  PredefinedHandleTable.
            //  Notice that the client will be impersonated.
            //  (MapPredefinedHandle will do all this stuff).
            //
            if( MapPredefinedHandle( hKey, &TempHandle ) == NULL ) {
                Error = ERROR_INVALID_HANDLE;
                goto ExitCleanup;
            }
        }

        //
        //  Return to the user the handle passed in
        //
        *phkResult = hKey;
        Error = ERROR_SUCCESS;
        goto ExitCleanup;
    }

    //
    // Validate that the sub key is not NULL.
    //

    ASSERT( lpSubKey != NULL );
    if( ! lpSubKey ) {
        Error = ERROR_BADKEY;
        goto ExitCleanup;
    }


    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the subkey to a counted Unicode string.
    // This also acounts for the NULL we are adding at the end
    //
    Status = RtlInitUnicodeStringEx(&SubKey, lpSubKey);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add terminating NULL to Length so that RPC transmits it
    //
    SubKey.Length += sizeof (UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if( IsLocalHandle( hKey )) {

#if defined(_WIN64)
        //
        //  if wow64 reserve field is set in the access mask, call
        //  wow64 function to handle the scenario. 
        //

        if ( samDesired & KEY_WOW64_RES ) {

            Error = (LONG)Wow64RegOpenKeyEx (
                            hKey,
                            SubKey.Buffer,
                            dwOptions,
                            samDesired,
                            phkResult
                            );
        } else
#endif
        Error =  (LONG)LocalBaseRegOpenKey (
                            hKey,
                            &SubKey,
                            dwOptions,
                            samDesired,
                            phkResult
                            );
    } else {

        Error =  (LONG)BaseRegOpenKey (
                            DereferenceRemoteHandle( hKey ),
                            &SubKey,
                            dwOptions,
                            samDesired,
                            phkResult
                            );

        if( Error == ERROR_SUCCESS) {

            TagRemoteHandle( phkResult );
        }
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
APIENTRY
RegOpenCurrentUser(
    REGSAM samDesired,
    PHKEY phkResult
    )
/*++

Routine Description:

    Win32 Client-Only function to open the key for HKEY_CURRENT_USER
    for the user that the thread is currently impersonating.  Since
    HKEY_CURRENT_USER is cached for all threads in a process, if the
    process is impersonating multiple users, this allows access to
    the appropriate key.

Arguments:

    samDesired - Supplies the requested security access mask.

    phkResult - Returns an open handle to the key.

Return Value:

    Returns 0 (ERROR_SUCCESS) for success, otherwise a windows error code.

--*/
{
    NTSTATUS Status ;

    if( phkResult == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    Status = RtlOpenCurrentUser( samDesired, phkResult );

#if defined(LEAK_TRACK)

    if (NT_SUCCESS(Status)) {
        if (g_RegLeakTraceInfo.bEnableLeakTrack) {
            (void) TrackObject(*phkResult);
        }
    }

#endif // (LEAK_TRACK)

    return RtlNtStatusToDosError( Status );

}

LONG
APIENTRY
RegDisablePredefinedCache(
    )
/*++

Routine Description:

    Win32 Client-Only function to disable the predefined handle table
    for HKEY_CURRENT_USER for the calling process
    All references to HKEY_CURRENT_USER after this function is called
    will result in a open/close on HKU\<sid>

Arguments:


Return Value:

    Returns 0 (ERROR_SUCCESS) for success, otherwise a windows error code.

--*/
{
    NTSTATUS Status ;

    Status = DisablePredefinedHandleTable( HKEY_CURRENT_USER );

    return RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regnckey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regnckey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to notify a caller about a changed Key value. That is:

        - RegNotifyChangeKey

Author:

    David J. Gilman (davegi) 10-Feb-1992

Notes:

    The implementation of RegNotifyChangeKeyValue involves >= 4 threads: 2 on
    the client side and >= 2 on the server side.

    Client:

        Thread 1.- The user's thread executing the RegNotifyChangeKeyValue.
                   This threads does:

                   - If thread #2 has not been created yet, it creates a
                     named pipe and thread #2.

                   - Does a synchronous RPC to the server



        Thread 2.- This thread reads events from the named pipe and signals
                   them. The writers to the pipe are the RPC servers which
                   thread 1 has called.





    Server:

        Thread 1.- This thread services the RPC from the client side. It
                   calls the NT notification API and adds the notification
                   handle to a "notification list".

        Thread 2.- This thread waits on part of the "notification list",
                   telling the original client (via named pipe) what events
                   need to be signaled.

        Threads 3... etc. Same as thread 2.





Revision History:

    02-Apr-1992     Ramon J. San Andres (ramonsa)
                    Changed to use RPC.


--*/


#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <stdlib.h>

NTSTATUS BaseRegNotifyClassKey(
    IN  HKEY                     hKey,
    IN  HANDLE                   hEvent,
    IN  PIO_STATUS_BLOCK         pLocalIoStatusBlock,
    IN  DWORD                    dwNotifyFilter,
    IN  BOOLEAN                  fWatchSubtree,
    IN  BOOLEAN                  fAsynchronous);

//
// Used by local call to NtNotifyChangeKey.
//

IO_STATUS_BLOCK     LocalIoStatusBlock;


#ifndef REMOTE_NOTIFICATION_DISABLED
//
//  Named pipe full paths.
//
#define NAMED_PIPE_HERE     L"\\Device\\NamedPipe\\"

//
//  Maximum number of times we will retry to create a pipe if there are
//  name conflicts.
//
#define MAX_PIPE_RETRIES    1000



//
//  Local variables.
//

//
//  Critical section to control access to notification structures
//
RTL_CRITICAL_SECTION        NotificationCriticalSection;

//
//  Our machine name
//
UNICODE_STRING              OurMachineName;
WCHAR                       OurMachineNameBuffer[ MAX_PATH ];

//
//  Named pipe used for notification
//
UNICODE_STRING              NotificationPipeName;
WCHAR                       NotificationPipeNameBuffer[ MAX_PATH ];
HANDLE                      NotificationPipeHandle;
RPC_SECURITY_ATTRIBUTES     NotificationPipeSaRpc;

//
//  Security descriptor used in the named pipe
//
SECURITY_DESCRIPTOR         SecurityDescriptor;
PACL                        Acl;
BOOL                        SecurityDescriptorInitialized;

//
//  Notification thread
//
HANDLE                      NotificationThread;
DWORD                       NotificationClientId;


//
//  Local prototypes
//
LONG
CreateNotificationPipe(
    );

VOID
NotificationHandler(
    );
#endif // REMOTE_NOTIFICATION_DISABLED


#ifndef REMOTE_NOTIFICATION_DISABLED

LONG
InitializeNotificationPipeSecurityDescriptor(
    )
/*++

Routine Description:

    Initialize the security descriptor (global variable) to be attached to
    the named pipe.

Arguments:

    None

Return Value:

    LONG - Returns a win32 error code.

--*/

{
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ULONG                    AclLength;
    PSID                     WorldSid;

    NTSTATUS                 NtStatus;

    //
    // Initialize global variables
    //
    SecurityDescriptorInitialized = FALSE;
    Acl = NULL;

    //
    //  Get World SID
    //
    NtStatus = RtlAllocateAndInitializeSid( &WorldSidAuthority,
                                            1,
                                            SECURITY_WORLD_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &WorldSid
                                          );

    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to allocate and initialize SID, NtStatus = %x \n", NtStatus );
#endif
        return( RtlNtStatusToDosError( NtStatus ) );
    }


    //
    //  Allocate buffer for ACL.
    //  This buffer should be big enough for the ACL header and for each ACE.
    //  Each ACE needs an ACE header.
    //
    AclLength = sizeof( ACL ) +
                sizeof( ACCESS_ALLOWED_ACE ) +
                GetLengthSid( WorldSid ) +
                sizeof( DWORD );

    Acl = RtlAllocateHeap( RtlProcessHeap(), 0, AclLength );
    ASSERT( Acl != NULL );
    if( Acl == NULL ) {
#if DBG
        DbgPrint( "WINREG: Unable to allocate memory, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeSid( WorldSid );
        return( ERROR_OUTOFMEMORY );
    }

    //
    // Build ACL: World has all access
    //

    NtStatus = RtlCreateAcl( (PACL)Acl,
                             AclLength,
                             ACL_REVISION2
                           );

    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to create ACL, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeSid( WorldSid );
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( RtlNtStatusToDosError( NtStatus ) );
    }

    NtStatus = RtlAddAccessAllowedAce( (PACL)Acl,
                                       ACL_REVISION2,
                                       SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                       WorldSid
                                     );

    RtlFreeSid( WorldSid );
    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to add ACE, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( RtlNtStatusToDosError( NtStatus ) );
    }

    //
    //  Build security descriptor
    //
    NtStatus = RtlCreateSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to create security descriptor, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( RtlNtStatusToDosError( NtStatus ) );
    }

#if DBG
    if( !RtlValidAcl( (PACL )Acl ) ) {
        DbgPrint( "WINREG: Acl is invalid \n" );
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( ERROR_INVALID_ACL );
    }
#endif

    NtStatus = RtlSetDaclSecurityDescriptor ( &SecurityDescriptor,
                                              TRUE,
                                              (PACL)Acl,
                                              FALSE
                                            );
    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus )) {
#if DBG
        DbgPrint( "WINREG: Unable to set DACL, NtStatus = %x \n", NtStatus );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return( RtlNtStatusToDosError( NtStatus ) );
    }
    SecurityDescriptorInitialized = TRUE;
    return( ERROR_SUCCESS );
}



BOOL
InitializeRegNotifyChangeKeyValue(
    )
/*++

Routine Description:


    Initializes the static data structures used by the
    RegNotifyChangeKeyValue client. Called once at DLL
    initialization.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if successful.


--*/

{

    NTSTATUS    NtStatus;


    NtStatus = RtlInitializeCriticalSection(
                    &NotificationCriticalSection
                    );

    if ( NT_SUCCESS( NtStatus ) ) {



        //
        //  Initialize our machine name. Note that the actual
        //  name is only obtained when the notification API
        //  is first invoked.
        //
        OurMachineName.Length        = 0;
        OurMachineName.MaximumLength = MAX_PATH * sizeof(WCHAR);
        OurMachineName.Buffer        = OurMachineNameBuffer;

        //
        //  Initialize named pipe data
        //
        NotificationPipeName.Length         = 0;
        NotificationPipeName.MaximumLength  = MAX_PATH * sizeof(WCHAR);
        NotificationPipeName.Buffer         = NotificationPipeNameBuffer;

        NotificationThread      = NULL;
        NotificationPipeHandle  = NULL;

        NotificationPipeSaRpc.RpcSecurityDescriptor.lpSecurityDescriptor = NULL;

        return TRUE;
    }

    return FALSE;

}



BOOL
CleanupRegNotifyChangeKeyValue(
    )
/*++

Routine Description:


    Performs any cleanup of the static data structures used
    by the RegNotifyChangeKeyValue client. Called once at
    process termination.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if successful.


--*/

{

    NTSTATUS    NtStatus;


    //
    //  Terminate notification thread if there is one running
    //
    if ( NotificationThread != NULL ) {

        //
        //  Close the named pipe
        //
        if ( NotificationPipeHandle != NULL ) {

            NtStatus = NtClose( NotificationPipeHandle );

            ASSERT( NT_SUCCESS( NtStatus ) );
        }

        TerminateThread( NotificationThread, 0 );
    }

    //
    //  Delete the notification critical section
    //
    NtStatus = RtlDeleteCriticalSection(
                    &NotificationCriticalSection
                    );

    ASSERT( NT_SUCCESS( NtStatus ) );

    if ( NotificationPipeSaRpc.RpcSecurityDescriptor.lpSecurityDescriptor ) {
        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            NotificationPipeSaRpc.RpcSecurityDescriptor.lpSecurityDescriptor
            );
    }

    return  TRUE;

}
#endif  // REMOTE_NOTIFICATION_DISABLED



LONG
RegNotifyChangeKeyValue(
    HKEY    hKey,
    BOOL    fWatchSubtree,
    DWORD   dwNotifyFilter,
    HANDLE  hEvent,
    BOOL    fAsynchronous
    )

/*++

Routine Description:

    This API is used to watch a key or sub-tree for changes. It can be
    called either synchronously or asynchronously. In the latter case the
    caller must supply an event that is signalled when changes occur. In
    either case it is possible to filter the criteria by which the
    notification occurs.


Arguments:

    hKey - Supplies a handle to a key that has been previously opened with
        KEY_NOTIFY access.

    fWatchSubtree - Supplies a boolean value that if TRUE causes the
        system to monitor the key and all of its decsendants.  A value of
        FALSE causes the system to monitor only the specified key.

    dwNotifyFilter - Supplies a set of flags that specify the filter
        conditions the system uses to satisfy a change notification.

        REG_NOTIFY_CHANGE_KEYNAME - Any key name changes that occur
            in a key or subtree being watched will satisfy a
            change notification wait.  This includes creations
            and deletions.

        REG_NOTIFY_CHANGE_ATTRIBUTES - Any attribute changes that occur
            in a key or subtree being watched will satisfy a
            change notification.

        REG_NOTIFY_CHANGE_LAST_WRITE - Any last write time changes that
            occur in a key or subtree being watched will satisfy a
            change notification.

        REG_NOTIFY_CHANGE_SECURITY - Any security descriptor changes
            that occur in a key or subtree being watched will
            satisfy a change notification.


    hEvent - Supplies an optional event handle. This parameter is ignored
        if fAsynchronus is set to FALSE.

    fAsynchronous - Supplies a flag which if FALSE causes the API to not
        return until something has changed. If TRUE, the API returns
        immediately and changes are reported via the supplied event. It
        is an error for this parameter to be TRUE and hEvent to be NULL.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.

Notes:

    If the supplied hKey is closed the event is signalled.
    Therefore it is possible to return from a wait on the event and then
    have subsequent APIs fail.

--*/

{
    HKEY                        Handle;
    HANDLE                      EventHandle;
    LONG                        Error       = ERROR_SUCCESS;
    NTSTATUS                    NtStatus;
    PRPC_SECURITY_ATTRIBUTES    pRpcSa;
    HKEY                        TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Validate the dependency between fAsynchronus and hEvent.
    //
    if (( fAsynchronous ) && ( ! ARGUMENT_PRESENT( hEvent ))) {
        return ERROR_INVALID_PARAMETER;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        CLOSE_LOCAL_HANDLE(TempHandle);
        return ERROR_INVALID_HANDLE;
    }

    //
    // Notification is not supported on remote handles.
    //
    if( !IsLocalHandle( Handle ) ) {
        CLOSE_LOCAL_HANDLE(TempHandle);
        return ERROR_INVALID_HANDLE;

    } else {

        //
        // If its a local handle, make an Nt API call and return.
        //

        if (IsSpecialClassesHandle( Handle )) {

            //
            // We call a special function for class keys
            //
            NtStatus = BaseRegNotifyClassKey(
                Handle,
                hEvent,
                &LocalIoStatusBlock,
                dwNotifyFilter,
                ( BOOLEAN ) fWatchSubtree,
                ( BOOLEAN ) fAsynchronous
                );

        } else {
            NtStatus = NtNotifyChangeKey(
                Handle,
                hEvent,
                NULL,
                NULL,
                &LocalIoStatusBlock,
                dwNotifyFilter,
                ( BOOLEAN ) fWatchSubtree,
                NULL,
                0,
                ( BOOLEAN ) fAsynchronous
                );
        }

        if( NT_SUCCESS( NtStatus ) ||
            ( NtStatus == STATUS_PENDING ) ) {
            Error = (error_status_t)ERROR_SUCCESS;
        } else {
            Error = (error_status_t) RtlNtStatusToDosError( NtStatus );
        }

        CLOSE_LOCAL_HANDLE(TempHandle);
        return Error;
    }

#ifndef REMOTE_NOTIFICATION_DISABLED

    // NOTE: THE FOLLOWING CODE IS DISABLED BY THE CHECK FOR
    // IsLocalHandle AT THE BEGINNING OF THE FUNCTION.
    //

    //
    //  If this is an asynchronous call, we use the user-provided
    //  event and will let the user wait on it him/herself.
    //  Otherwise we have to create our own event and wait on
    //  it ourselves.
    //
    //  This is because the server side of the API is always
    //  asynchronous.
    //
    if ( fAsynchronous ) {

        EventHandle = hEvent;

    } else {

        NtStatus = NtCreateEvent(
                        &EventHandle,
                        EVENT_ALL_ACCESS,
                        NULL,
                        NotificationEvent,
                        FALSE
                        );

        if ( !NT_SUCCESS( NtStatus ) ) {
            return RtlNtStatusToDosError( NtStatus );
        }
    }

    //
    //  See if the notification thread is already running
    //  and create it if not.  We have to protect this
    //  with a critical section because there might be
    //  several instances of this API doing this check
    //  at the same time.
    //
    NtStatus = RtlEnterCriticalSection( &NotificationCriticalSection );

    if ( !NT_SUCCESS( NtStatus ) ) {

        Error = RtlNtStatusToDosError( NtStatus );

    } else {

        //
        //  We are now inside the critical section
        //
        if ( NotificationThread == NULL ) {


            //
            //  Create a named pipe for the notification thread
            //  to use.
            //
            Error = CreateNotificationPipe( );

            if ( Error == ERROR_SUCCESS ) {

                //
                //  Create the notification thread
                //
                NotificationThread = CreateThread(
                                        NULL,
                                        (16 * 1024),
                                        (LPTHREAD_START_ROUTINE)NotificationHandler,
                                        NULL,
                                        0,
                                        &NotificationClientId
                                        );

                if ( NotificationThread == NULL ) {
                    //
                    //  Could not create thread, remove the named pipe.
                    //
                    Error = GetLastError();
                    NtClose( NotificationPipeHandle );
                }
            }
        }

        NtStatus = RtlLeaveCriticalSection( &NotificationCriticalSection );

        ASSERT( NT_SUCCESS( NtStatus ) );
    }

    if ( Error == ERROR_SUCCESS ) {

        //
        //  Let the server side do its work. Remember that this call
        //  is always asynchronous.
        //
        if ( NotificationPipeSaRpc.RpcSecurityDescriptor.lpSecurityDescriptor ) {
            pRpcSa = &NotificationPipeSaRpc;
        } else {
            pRpcSa = NULL;
        }

        //NotificationPipeName.Length += sizeof(UNICODE_NULL);
        //OurMachineName.Length       += sizeof(UNICODE_NULL );

        // DbgPrint(" Waiting for notification, handle %x\n", EventHandle );

        Error = (LONG)BaseRegNotifyChangeKeyValue(
                                DereferenceRemoteHandle( Handle ),
                                (BOOLEAN)fWatchSubtree,
                                dwNotifyFilter,
                                (DWORD)EventHandle,
                                &OurMachineName,
                                &NotificationPipeName,
                                pRpcSa
                                );

        //NotificationPipeName.Length -= sizeof(UNICODE_NULL);
        //OurMachineName.Length       -= sizeof(UNICODE_NULL );

    }


    //
    //  If the call went ok. and we are in synchronous mode, we have
    //  to wait on the event.
    //
    if ( (Error == ERROR_SUCCESS) && !fAsynchronous ) {

        NtStatus = NtWaitForSingleObject(
                        EventHandle,
                        FALSE,
                        NULL
                        );


        if ( !NT_SUCCESS( NtStatus ) ) {
            Error = RtlNtStatusToDosError( NtStatus );
        }
    }


    //
    //  If we created an event, we must close it now.
    //
    if ( !fAsynchronous ) {

        NtStatus = NtClose( EventHandle );
        ASSERT( NT_SUCCESS( NtStatus ));
    }

    return Error;
#endif // REMOTE_NOTIFICATION_DISABLED
}


#ifndef REMOTE_NOTIFICATION_DISABLED


LONG
CreateNotificationPipe(
    )
/*++

Routine Description:


    Creates the notification named pipe and sets the appropriate
    global variables.

    Note that the NotificationPipeName set by this function is
    server-relative, so that no conversion is required on the
    server side.


Arguments:

    None

Return Value:

    Error code.


--*/
{

    UNICODE_STRING      PipeName;
    WCHAR               PipeNameBuffer[ MAX_PATH ];
    USHORT              OrgSize;
    DWORD               Sequence;
    NTSTATUS            NtStatus;
    LARGE_INTEGER       Timeout;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    DWORD               MachineNameLength;
    LONG                WinStatus;

    //
    //  Get our machine name
    //
    MachineNameLength = MAX_PATH;
    if ( !GetComputerNameW( OurMachineNameBuffer, &MachineNameLength ) ) {
        return GetLastError();
    }

    OurMachineName.Buffer        = OurMachineNameBuffer;
    OurMachineName.Length        = (USHORT)(MachineNameLength * sizeof(WCHAR));
    OurMachineName.MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR));

    //
    //  Get the "here" name
    //
    RtlMoveMemory(
            PipeNameBuffer,
            NAMED_PIPE_HERE,
            sizeof( NAMED_PIPE_HERE)
            );


    PipeName.MaximumLength  = MAX_PATH * sizeof(WCHAR);
    PipeName.Buffer         = PipeNameBuffer;

    //
    //  Remember the size of the base portion of the pipe name, so
    //  we can patch it later when we attempt to create the full
    //  name.
    //
    OrgSize = (USHORT)(sizeof(NAMED_PIPE_HERE) - sizeof(UNICODE_NULL));

    //
    //  Create the named pipe, if the name is already being used,
    //  keep trying with different names.
    //
    Sequence = 0;

    Timeout.QuadPart = Int32x32To64( -10 * 1000, 50 );

    //
    //  Initialize the security descriptor that will be set in the named pipe
    //
    WinStatus = InitializeNotificationPipeSecurityDescriptor();
    if( WinStatus != ERROR_SUCCESS ) {
        return( WinStatus );
    }

    do {

        //
        //  Get a semi-unique name
        //
        if ( !MakeSemiUniqueName( &NotificationPipeName, Sequence++ ) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        //  Patch the full pipe name, in case this is not our first
        //  try.
        //
        PipeName.Buffer[OrgSize/sizeof(WCHAR)] = UNICODE_NULL;
        PipeName.Length          = OrgSize;

        //
        //  Now get the full path of the pipe name
        //
        NtStatus = RtlAppendUnicodeStringToString(
                            &PipeName,
                            &NotificationPipeName
                            );


        ASSERT( NT_SUCCESS( NtStatus ) );

        if ( !NT_SUCCESS( NtStatus ) ) {
            break;
        }


        InitializeObjectAttributes(
                    &Obja,
                    &PipeName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );


        if( SecurityDescriptorInitialized ) {
            Obja.SecurityDescriptor = &SecurityDescriptor;
        }

        NtStatus = NtCreateNamedPipeFile (
                        &NotificationPipeHandle,
                        SYNCHRONIZE | GENERIC_READ | FILE_WRITE_ATTRIBUTES,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        FILE_CREATE,
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        FILE_PIPE_MESSAGE_TYPE,
                        FILE_PIPE_MESSAGE_MODE,
                        FILE_PIPE_QUEUE_OPERATION,
                        1,
                        0,
                        0,
                        &Timeout
                        );

    } while ( (NtStatus == STATUS_OBJECT_NAME_EXISTS) &&
              (Sequence <= MAX_PIPE_RETRIES )
            );

    //
    // At this point we don't need the security descriptor anymore.
    // Free the memory allocated for the ACL
    //
    if( SecurityDescriptorInitialized ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, Acl );
        Acl = NULL;
        SecurityDescriptorInitialized = FALSE;
    }

    if ( !NT_SUCCESS( NtStatus ) ) {
        return RtlNtStatusToDosError( NtStatus );
    }

    NotificationPipeName.Length += sizeof(UNICODE_NULL);
    OurMachineName.Length       += sizeof(UNICODE_NULL );

    return ERROR_SUCCESS;
}





VOID
NotificationHandler(
    )

/*++

Routine Description:


    This function is the entry point of the notification thread.
    The notification thread is created the first time that
    the RegNotifyChangeKeyValue API is called by the process,
    and keeps on running until the process terminates.

    This function creates a named pipe whose name is given by
    RegNotifyChangeKeyValue to all its servers.  The servers
    then use the pipe to indicate that a particular event has
    to be signaled.
                                                                        117
    Note that this single thread is in charge of signaling the
    events for all the RegNotifyChangeKeyValue invocations of
    the process.  However no state has to be maintained by this
    thread because all the state information is provided by the
    server through the named pipe.


Arguments:

    None

Return Value:

    None


--*/

{
    NTSTATUS        NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE          EventHandle;


    ASSERT( NotificationPipeHandle != NULL );

    while ( TRUE ) {

        //
        //  Wait for a connection
        //
        NtStatus = NtFsControlFile(
                        NotificationPipeHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FSCTL_PIPE_LISTEN,
                        NULL,
                        0,
                        NULL,
                        0
                        );

        if ( NtStatus == STATUS_PENDING ) {

            NtStatus = NtWaitForSingleObject(
                            NotificationPipeHandle,
                            FALSE,
                            NULL
                            );
        }

        if ( NT_SUCCESS( NtStatus ) ||
             ( NtStatus == STATUS_PIPE_CONNECTED ) ) {

            //
            //  Read an event handle from the pipe
            //
            NtStatus = NtReadFile(
                            NotificationPipeHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            ( PVOID )&EventHandle,
                            sizeof( HANDLE ),
                            NULL,
                            NULL
                            );

            if ( NtStatus == STATUS_PENDING ) {

                NtStatus = NtWaitForSingleObject(
                                NotificationPipeHandle,
                                FALSE,
                                NULL
                                );
            }


            //
            //  Signal the Event.
            //
            if ( NT_SUCCESS( NtStatus ) ) {

                ASSERT( IoStatusBlock.Information == sizeof( HANDLE ) );

                //
                //  Signal the event
                //
                //DbgPrint(" WINREG: Signaling handle %x\n", EventHandle );
                NtStatus = NtSetEvent( EventHandle, NULL );

#if DBG
                if ( !NT_SUCCESS( NtStatus ) ) {
                    DbgPrint( "WINREG: Cannot signal notification event 0x%x, status %x\n",
                                EventHandle, NtStatus );
                }
#endif
                ASSERT( NT_SUCCESS( NtStatus ) );

            } else if ( NtStatus != STATUS_PIPE_BROKEN ) {
#if DBG
                DbgPrint( "WINREG  (Notification handler) error reading pipe\n" );
                DbgPrint( "         status 0x%x\n", NtStatus );
#endif
                ASSERT( NT_SUCCESS( NtStatus ) );
            }

        } else if ( NtStatus != STATUS_PIPE_BROKEN &&
                    NtStatus != STATUS_PIPE_CLOSING) {
#if DBG
            DbgPrint( "WINREG (Notification): FsControlFile (Connect) status 0x%x\n",
                      NtStatus );
#endif
        }

        if ( NT_SUCCESS( NtStatus )             ||
             NtStatus == STATUS_PIPE_BROKEN     ||
             NtStatus == STATUS_PIPE_CLOSING    ||
             NtStatus == STATUS_PIPE_LISTENING  ||
             NtStatus == STATUS_PIPE_BUSY ) {

            //
            //  Disconnect
            //
            NtStatus = NtFsControlFile(
                                NotificationPipeHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_PIPE_DISCONNECT,
                                NULL,
                                0,
                                NULL,
                                0
                                );

            if ( NtStatus == STATUS_PENDING) {

                NtStatus = NtWaitForSingleObject(
                                NotificationPipeHandle,
                                FALSE,
                                NULL
                                );
            }

#if DBG
            if ( !NT_SUCCESS( NtStatus ) ) {
                DbgPrint( "WINREG (Notification): FsControlFile (Disconnect) status 0x%x\n",
                          NtStatus );
            }
#endif
            ASSERT( NT_SUCCESS( NtStatus ) );

        }
    }
}

#endif //  REMOTE_NOTIFICATION_DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\reglukey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Reglukey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to load, unload and replace keys. That is:

        - RegLoadKeyA
        - RegLoadKeyW
        - RegUnLoadKeyA
        - RegUnLoadKeyW
        - RegReplaceKeyA
        - RegReplaceKeyW

Author:


    Ramon J. San Andres (ramonsa) 16-Apr-1992



--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"


LONG
APIENTRY
RegLoadKeyA(
    HKEY   hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpFile
    )

/*++

Routine Description:

    Win32 Ansi API for loading a key.

--*/

{

    HKEY                Handle;
    UNICODE_STRING      SubKey;
    UNICODE_STRING      File;
    WCHAR               UnicodeBuffer[ MAX_PATH ];
    ANSI_STRING         AnsiFile;
    NTSTATUS            NtStatus;
    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    // OutputDebugString( "Winreg: Entering RegLoadKeyA\n" );
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the SubKey name to a counted Unicode 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        NtStatus = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }


    //
    // Convert the file name to a counted Unicode string using the
    // Unicode string on the stack.
    //
    File.Buffer        = UnicodeBuffer;
    File.MaximumLength = sizeof( UnicodeBuffer );
    RtlInitAnsiString( &AnsiFile, lpFile );
    NtStatus = RtlAnsiStringToUnicodeString(
                    &File,
                    &AnsiFile,
                    FALSE
                    );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( NtStatus )) {
        // free the allocated unicode string
        RtlFreeUnicodeString( &SubKey );

        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( File.Length > 0 ) {
        File.Length += sizeof( UNICODE_NULL );
    }

    //
    // Call the server
    //

    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegLoadKey(
                            Handle,
                            &SubKey,
                            &File
                            );

    } else {

        Error = (LONG)BaseRegLoadKey(
                            DereferenceRemoteHandle( Handle ),
                            &SubKey,
                            &File
                            );
    }

    // free the allocated unicode string
    RtlFreeUnicodeString( &SubKey );

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}




LONG
APIENTRY
RegLoadKeyW(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpFile
    )

/*++

Routine Description:

    Load the tree in the supplied file into the key referenced by the
    supplied key handle and sub-key.  The loaded tree will overwrite all
    of the contents of the supplied sub-key except for its name.
    Pictorially, if the file contains:

                    A
                   / \
                  /   \
                 B     C

    and the supplied key refers to a key name X, the resultant tree would
    look like:

                    X
                   / \
                  /   \
                 B     C

Arguments:

    hKey - Supplies the predefined handle HKEY_USERS or HKEY_LOCAL_MACHINE.
        lpSubKey is relative to this handle.

    lpSubKey - Supplies a path name to a new (i.e.  non-existant) key
        where the supplied file will be loaded.

    lpFile - Supplies a pointer to an existing file name whose contents was
        created with RegSaveKey. The file name may not have an extension.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    The difference between RegRestoreKey and RegLoadKey is that in the
    latter case the supplied file is used as the actual backing store
    whereas in the former case the information in the file is copied into
    the Registry.

    RegLoadKey requires SeRestorePrivilege.

--*/

{

    HKEY                Handle;
    UNICODE_STRING      SubKey;
    UNICODE_STRING      File;
    LONG                Error;
    HKEY                TempHandle = NULL;
    NTSTATUS            Status;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    //
    // Convert the subkey to a counted Unicode string.
    // This also acounts for the NULL we are adding at the end
    //
    Status = RtlInitUnicodeStringEx(&SubKey, lpSubKey);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }


    Status = RtlInitUnicodeStringEx(&File, lpFile);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( File.Length > 0 ) {
        File.Length += sizeof( UNICODE_NULL );
    }


    //
    // Call the server
    //

    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegLoadKey(
                            Handle,
                            &SubKey,
                            &File
                            );

    } else {

        Error = (LONG)BaseRegLoadKey(
                            DereferenceRemoteHandle( Handle ),
                            &SubKey,
                            &File
                            );
    }
ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}




LONG
APIENTRY
RegUnLoadKeyA(
    HKEY   hKey,
    LPCSTR  lpSubKey
    )
/*++

Routine Description:

    Win32 Ansi API for unloading a key.

--*/

{

    HKEY                Handle;
    UNICODE_STRING      SubKey;
    NTSTATUS            NtStatus;
    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey,&TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }



    //
    // Convert the SubKey name to a counted Unicode 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        NtStatus = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }


    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegUnLoadKey(
                                Handle,
                                &SubKey
                                );

    } else {

        Error = (LONG)BaseRegUnLoadKey(
                                DereferenceRemoteHandle( Handle ),
                                &SubKey
                                );
    }

    // free the allocated unicode string
    RtlFreeUnicodeString( &SubKey );
ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}




LONG
APIENTRY
RegUnLoadKeyW(
    HKEY   hKey,
    LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Unload the specified tree (hive) from the Registry.

Arguments:

    hKey - Supplies a handle to an open key. lpSubKey is relative to this
        handle.

    lpSubKey - Supplies a path name to the key that is to be unloaded.
        The combination of hKey and lpSubKey must refer to a hive in the
        Registry created with RegRestoreKey or RegLoadKey.  This parameter may
        be NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    RegUnLoadKey requires SeRestorePrivilege.

--*/

{
    HKEY                Handle;
    UNICODE_STRING      SubKey;
    LONG                Error;
    HKEY                TempHandle = NULL;
    NTSTATUS            Status;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    Status = RtlInitUnicodeStringEx(&SubKey, lpSubKey);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }


    //
    // Call the server
    //
    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegUnLoadKey(
                                Handle,
                                &SubKey
                                );

    } else {

        Error = (LONG)BaseRegUnLoadKey(
                                DereferenceRemoteHandle( Handle ),
                                &SubKey
                                );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}






LONG
APIENTRY
RegReplaceKeyA(
    HKEY   hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpNewFile,
    LPCSTR  lpOldFile
    )
/*++

Routine Description:

    Win32 Ansi API for replacing a key.

--*/
{
    HKEY                Handle;
    UNICODE_STRING      SubKey;
    UNICODE_STRING      NewFile;
    UNICODE_STRING      OldFile;
    WCHAR               NewUnicodeBuffer[ MAX_PATH ];
    WCHAR               OldUnicodeBuffer[ MAX_PATH ];
    ANSI_STRING         AnsiFile;
    NTSTATUS            NtStatus;
    LONG                Error;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the SubKey name to a counted Unicode 
    //
    if( !RtlCreateUnicodeStringFromAsciiz(&SubKey,lpSubKey) ) {
        NtStatus = STATUS_NO_MEMORY;
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    // Convert the new file name to a counted Unicode string using the
    // Unicode string on the stack.
    //
    NewFile.Buffer        = NewUnicodeBuffer;
    NewFile.MaximumLength = sizeof( NewUnicodeBuffer );
    RtlInitAnsiString( &AnsiFile, lpNewFile );
    NtStatus = RtlAnsiStringToUnicodeString(
                    &NewFile,
                    &AnsiFile,
                    FALSE
                    );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( NtStatus )) {
        // free the allocated unicode string
        RtlFreeUnicodeString( &SubKey );
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }


    //
    // Convert the old file name to a counted Unicode string using the
    // Unicode string on the stack.
    //
    OldFile.Buffer        = OldUnicodeBuffer;
    OldFile.MaximumLength = sizeof( OldUnicodeBuffer );
    RtlInitAnsiString( &AnsiFile, lpOldFile );
    NtStatus = RtlAnsiStringToUnicodeString(
                    &OldFile,
                    &AnsiFile,
                    FALSE
                    );

    //
    // If the file name could not be converted, map the results and return.
    //
    if( ! NT_SUCCESS( NtStatus )) {
        // free the allocated unicode string
        RtlFreeUnicodeString( &SubKey );
        Error = RtlNtStatusToDosError( NtStatus );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }

    if ( NewFile.Length > 0 ) {
        NewFile.Length += sizeof( UNICODE_NULL );
    }

    if ( OldFile.Length > 0 ) {
        OldFile.Length += sizeof( UNICODE_NULL );
    }

    //
    //  Call the server
    //

    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegReplaceKey(
                                Handle,
                                &SubKey,
                                &NewFile,
                                &OldFile
                                );

    } else {

        Error = (LONG)BaseRegReplaceKey(
                                DereferenceRemoteHandle( Handle ),
                                &SubKey,
                                &NewFile,
                                &OldFile
                                );
    }

    // free the allocated unicode string
    RtlFreeUnicodeString( &SubKey );
ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}




LONG
APIENTRY
RegReplaceKeyW(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpNewFile,
    LPCWSTR  lpOldFile
    )

/*++

Routine Description:

    Replace an existing tree (hive) in the Registry. The new tree will
    take effect the next time the system is rebooted.

Arguments:

    hKey - Supplies a handle to an open key. lpSubKey is relative to this
        handle.

    lpSubKey - Supplies a path name to the key that is to be replaced.
        The combination of hKey and lpSubKey must refer to a hive in the
        Registry.  This parameter may be NULL.

    lpNewFile - Supplies a file name for the new hive file.

    lpOldFile - Supplies a backup file name for the old (existing) hive file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    lpNewFile will remain open until after the system is rebooted.

    RegUnLoadKey requires SeRestorePrivilege.

--*/

{

    HKEY    Handle;
    UNICODE_STRING      SubKey;
    UNICODE_STRING      NewFile;
    UNICODE_STRING      OldFile;
    LONG                Error;
    HKEY                TempHandle = NULL;
    NTSTATUS            Status;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    Handle = MapPredefinedHandle( hKey, &TempHandle );
    if ( Handle == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    Status = RtlInitUnicodeStringEx(&SubKey,lpSubKey);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    Status = RtlInitUnicodeStringEx(&NewFile,lpNewFile);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    Status = RtlInitUnicodeStringEx(&OldFile,lpOldFile);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the NULL to the length so that RPC will transmit the entire
    //  thing
    //
    if ( SubKey.Length > 0 ) {
        SubKey.Length += sizeof( UNICODE_NULL );
    }

    if ( NewFile.Length > 0 ) {
        NewFile.Length += sizeof( UNICODE_NULL );
    }

    if ( OldFile.Length > 0 ) {
        OldFile.Length += sizeof( UNICODE_NULL );
    }


    //
    //  Call the server
    //

    if( IsLocalHandle( Handle )) {

        Error = (LONG)LocalBaseRegReplaceKey(
                                Handle,
                                &SubKey,
                                &NewFile,
                                &OldFile
                                );

    } else {

        Error = (LONG)BaseRegReplaceKey(
                                DereferenceRemoteHandle( Handle ),
                                &SubKey,
                                &NewFile,
                                &OldFile
                                );
    }

ExitCleanup:

    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regqval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regqval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    query value APIs.  That is:

        - RegQueryValueA
        - RegQueryValueW
        - RegQueryValueExA
        - RegQueryValueExW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regqval.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"

LONG
RegQueryValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpData,
    PLONG lpcbData
    )

/*++

Routine Description:


    Win 3.1 ANSI RPC wrapper for querying a value.

--*/

{
    HKEY            ChildKey;
    LONG            Error;
    DWORD           ValueType;
    LONG            InitialCbData;
    HKEY            TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // If the sub-key is NULL or points to an empty string then the value is
    // to be queried from this key (i.e.  hKey) otherwise the sub-key needs
    // to be opened.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        ChildKey = hKey;

    } else {

        //
        // The sub-key was supplied so impersonate the
        // client and attempt to open it.
        //

        Error = RegOpenKeyExA(
                    hKey,
                    lpSubKey,
                    0,
                    KEY_QUERY_VALUE,
                    &ChildKey
                    );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }
    }

    InitialCbData = ARGUMENT_PRESENT(lpcbData) ? (*lpcbData) : 0;

    //
    // ChildKey contains an HKEY which may be the one supplied (hKey) or
    // returned from RegOpenKeyExA. Query the value using the special value
    // name NULL.
    //

    Error = RegQueryValueExA(
                ChildKey,
                NULL,
                NULL,
                &ValueType,
                lpData,
                lpcbData
                );
    //
    // If the sub key was opened, close it.
    //

    if( ChildKey != hKey ) {

        if( IsLocalHandle( ChildKey )) {

            LocalBaseRegCloseKey( &ChildKey );

        } else {

            ChildKey = DereferenceRemoteHandle( ChildKey );
            BaseRegCloseKey( &ChildKey );
        }
    }

    //
    // If the type of the value is not a null terminate string, then return
    // an error. (Win 3.1 compatibility)
    //

    if (!Error && ((ValueType != REG_SZ) && (ValueType != REG_EXPAND_SZ))) {
        Error = ERROR_INVALID_DATA;
    }

    //
    // If value doesn't exist, return ERROR_SUCCESS and an empty string.
    // (Win 3.1 compatibility)
    //
    if( Error == ERROR_FILE_NOT_FOUND ) {
        if( ARGUMENT_PRESENT( lpcbData ) ) {
            *lpcbData = sizeof( CHAR );
        }
        if( ARGUMENT_PRESENT( lpData ) ) {
            *lpData = '\0';
        }
        Error = ERROR_SUCCESS;
    }

    //
    // Expand if necessary (VB compatibility)
    //

    if (!Error && (ValueType == REG_EXPAND_SZ)) {
        if ( (!ARGUMENT_PRESENT(lpcbData)) || (!ARGUMENT_PRESENT(lpData)) ) {
            Error = ERROR_INVALID_DATA;
        } else {
            LPSTR ExpandBuffer;
            LONG ExpandedSize;
            LONG BufferSize = (InitialCbData>*lpcbData)?InitialCbData:*lpcbData;
            //
            // if InitialCbData was 0, allocate a buffer of the real size
            //
            ExpandBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, BufferSize);
            if (ExpandBuffer == NULL) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                RtlCopyMemory(ExpandBuffer, lpData, *lpcbData);
                ExpandedSize = ExpandEnvironmentStringsA(ExpandBuffer, lpData, BufferSize);
                if (ExpandedSize > InitialCbData) {
                    Error = ERROR_MORE_DATA;
                }
                *lpcbData = ExpandedSize;
                RtlFreeHeap( RtlProcessHeap(), 0, ExpandBuffer );
            }
        }
    }

    //
    // Return the results of querying the value.
    //

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
RegQueryValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpData,
    PLONG  lpcbData
    )

/*++

Routine Description:

    Win 3.1 Unicode RPC wrapper for querying a value.

--*/

{
    HKEY        ChildKey;
    LONG        Error;
    DWORD       ValueType;
    LONG            InitialCbData;
    HKEY            TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }


    //
    // If the sub-key is NULL or points to an empty string then the value is
    // to be queried from this key (i.e.  hKey) otherwise the sub-key needs
    // to be opened.
    //

    if(( lpSubKey == NULL ) || ( *lpSubKey == '\0' )) {

        ChildKey = hKey;

    } else {

        //
        // The sub-key was supplied so attempt to open it.
        //

        Error = RegOpenKeyExW(
                    hKey,
                    lpSubKey,
                    0,
                    KEY_QUERY_VALUE,
                    &ChildKey
                    );

        if( Error != ERROR_SUCCESS ) {
            goto ExitCleanup;
        }
    }

    InitialCbData = ARGUMENT_PRESENT(lpcbData) ? (*lpcbData) : 0;

    //
    // ChildKey contains an HKEY which may be the one supplied (hKey) or
    // returned from RegOpenKeyExA. Query the value using the special value
    // name NULL.
    //

    Error = RegQueryValueExW(
                ChildKey,
                NULL,
                NULL,
                &ValueType,
                ( LPBYTE )lpData,
                lpcbData
                );
    //
    // If the sub key was opened, close it.
    //

    if( ChildKey != hKey ) {

        if( IsLocalHandle( ChildKey )) {

            LocalBaseRegCloseKey( &ChildKey );

        } else {

            ChildKey = DereferenceRemoteHandle( ChildKey );
            BaseRegCloseKey( &ChildKey );
        }
    }

    //
    // If the type of the value is not a null terminate string, then return
    // an error. (Win 3.1 compatibility)
    //

    if (!Error && ((ValueType != REG_SZ) && (ValueType != REG_EXPAND_SZ))) {
        Error = ERROR_INVALID_DATA;
    }

    //
    // If value doesn't exist, return ERROR_SUCCESS and an empty string.
    // (Win 3.1 compatibility)
    //
    if( Error == ERROR_FILE_NOT_FOUND ) {
        if( ARGUMENT_PRESENT( lpcbData ) ) {
            *lpcbData = sizeof( WCHAR );
        }
        if( ARGUMENT_PRESENT( lpData ) ) {
            *lpData = ( WCHAR )'\0';
        }
        Error = ERROR_SUCCESS;
    }

    //
    // Expand if necessary (VB compatibility)
    //

    if (!Error && (ValueType == REG_EXPAND_SZ)) {
        if ( (!ARGUMENT_PRESENT(lpcbData)) || (!ARGUMENT_PRESENT(lpData)) ) {
            Error = ERROR_INVALID_DATA;
        } else {
            LPWSTR ExpandBuffer;
            LONG ExpandedSize;
            LONG BufferSize = (InitialCbData>*lpcbData)?InitialCbData:*lpcbData;
            //
            // if InitialCbData was 0, allocate a buffer of the real size
            //
            ExpandBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, BufferSize);
            if (ExpandBuffer == NULL) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                RtlCopyMemory(ExpandBuffer, lpData, *lpcbData);
                ExpandedSize = ExpandEnvironmentStringsW(ExpandBuffer, lpData, BufferSize / sizeof(WCHAR));
                if (ExpandedSize > (LONG)(InitialCbData / sizeof(WCHAR))) {
                    Error = ERROR_MORE_DATA;
                }
                *lpcbData = ExpandedSize;
                RtlFreeHeap( RtlProcessHeap(), 0, ExpandBuffer );
            }
        }
    }

    //
    // Return the results of querying the value.
    //

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}


LONG
APIENTRY
RegQueryValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for querying a value.

    RegQueryValueExA converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegQueryValue.

--*/

{
    PUNICODE_STRING     ValueName;
    UNICODE_STRING      StubValueName;
    DWORD               ValueType;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error;
    DWORD               ValueLength;
    DWORD               InputLength;
    PWSTR               UnicodeValueBuffer;
    ULONG               UnicodeValueLength;

    PSTR                AnsiValueBuffer;
    ULONG               AnsiValueLength;
    ULONG               Index;
    ULONG               cbAnsi = 0;
    HKEY                TempHandle = NULL;

#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Validate dependency between lpData and lpcbData parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpData ) && ( ! ARGUMENT_PRESENT( lpcbData )))) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode string using the static
    // Unicode string in the TEB.
    //

    StubValueName.Buffer = NULL;
    ValueName = &NtCurrentTeb( )->StaticUnicodeString;
    ASSERT( ValueName != NULL );
    Status = RtlInitAnsiStringEx( &AnsiString, lpValueName );
    if( ! NT_SUCCESS( Status )) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    Status = RtlAnsiStringToUnicodeString(
                ValueName,
                &AnsiString,
                FALSE
                );

    if( ! NT_SUCCESS( Status )) {
        //
        // The StaticUnicodeString is not long enough; Try to allocate a bigger one
        //
        Status = RtlAnsiStringToUnicodeString(
                    &StubValueName,
                    &AnsiString,
                    TRUE
                    );
        if( ! NT_SUCCESS( Status )) {
            Error = RtlNtStatusToDosError( Status );
            goto ExitCleanup;
        }

        ValueName = &StubValueName;
    }

    //
    //  Add the terminating NULL to the Length so that RPC transmits
    //  it.
    //

    ValueName->Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings. Note that zero bytes are transmitted (i.e.
    // InputLength = 0) for the data.
    //

    ValueLength = ARGUMENT_PRESENT( lpcbData )? *lpcbData : 0;
    InputLength = 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegQueryValue (
                             hKey,
                             ValueName,
                             &ValueType,
                             lpData,
                             &ValueLength,
                             &InputLength
                             );
        //
        //  Make sure that the local side didn't destroy the Buffer in
        //  the StaticUnicodeString
        //
        ASSERT( ValueName->Buffer );


    } else {

        Error = (LONG)BaseRegQueryValue (
                             DereferenceRemoteHandle( hKey ),
                             ValueName,
                             &ValueType,
                             lpData,
                             &ValueLength,
                             &InputLength
                             );
    }

    //
    // If no error or callers buffer too small, and type is one of the null
    // terminated string types, then do the UNICODE to ANSI translation.
    // We handle the buffer too small case, because the callers buffer may
    // be big enough for the ANSI representation, but not the UNICODE one.
    // In this case, we need to allocate a buffer big enough, do the query
    // again and then the translation into the callers buffer.  We only do
    // this if the caller actually wants the value data (lpData != NULL)
    //

    if ((Error == ERROR_SUCCESS || Error == ERROR_MORE_DATA) &&
        (ARGUMENT_PRESENT( lpData ) || ARGUMENT_PRESENT( lpcbData ))&&
        (ValueType == REG_SZ ||
         ValueType == REG_EXPAND_SZ ||
         ValueType == REG_MULTI_SZ)
		 ) {
		UnicodeValueLength         = ValueLength;


		AnsiValueBuffer            = lpData;
		AnsiValueLength            = ARGUMENT_PRESENT( lpcbData )?
													 *lpcbData : 0;

		//
		// Allocate a buffer for the UNICODE value and reissue the query.
		//

		UnicodeValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
											  UnicodeValueLength
											 );
		if (UnicodeValueBuffer == NULL) {
			Error = ERROR_NOT_ENOUGH_MEMORY;
		} else {
			InputLength = 0;

			if( IsLocalHandle( hKey )) {

				//
				//  Add the terminating NULL to the Length
				//  (remember that in the local case, ValueName->Length
				//  was decremented by sizeof( UNICODE_NULL ) in the first
				//  call to LocalBaseRegQueryValue).
				//  This won't happen in the remote case, since the
				//  server side will decrement ValueName->Length on
				//  the transmitted structure (a copy of ValueName), and
				//  the new Valuename->Length won't be transmitted back to
				//  the client.
				//

				ValueName->Length += sizeof( UNICODE_NULL );


				Error = (LONG)LocalBaseRegQueryValue (
									 hKey,
									 ValueName,
									 &ValueType,
									 (LPBYTE)UnicodeValueBuffer,
									 &ValueLength,
									 &InputLength
									 );
				//
				//  Make sure that the local side didn't destroy the
				//  Buffer in the StaticUnicodeString
				//

				ASSERT(ValueName->Buffer);


			} else {

				Error = (LONG)BaseRegQueryValue (
									 DereferenceRemoteHandle( hKey ),
									 ValueName,
									 &ValueType,
									 (LPBYTE)UnicodeValueBuffer,
									 &ValueLength,
									 &InputLength
									 );
			}
            if( Error == ERROR_SUCCESS ) {
                // Compute needed buffer size , cbAnsi will keeps the byte
			    // counts to keep MBCS string after following step.

			    RtlUnicodeToMultiByteSize( &cbAnsi ,
									       UnicodeValueBuffer ,
									       ValueLength );

			    // If we could not store all MBCS string to buffer that
			    // Apps gives me.  We set ERROR_MORE_DATA to Error

			    if( ARGUMENT_PRESENT( lpcbData ) ) {
				    if( cbAnsi > *lpcbData && lpData != NULL ) {
					    Error = ERROR_MORE_DATA;
				    }
			    }
            } else {
                // to be used below
                cbAnsi = ValueLength;
            }
		}

		if ((Error == ERROR_SUCCESS) && (AnsiValueBuffer != NULL) ) {
			//
			// We have a UNICODE value, so translate it to ANSI in the callers
			// buffer.  In the case where the caller's buffer was big enough
			// for the UNICODE version, we do the conversion in place, which
			// works since the ANSI version is smaller than the UNICODE version.
			//


			Index = 0;
			Status = RtlUnicodeToMultiByteN( AnsiValueBuffer,
											 AnsiValueLength,
											 &Index,
											 UnicodeValueBuffer,
											 UnicodeValueLength
											);
			if (!NT_SUCCESS( Status )) {
				Error = RtlNtStatusToDosError( Status );
			}

			// Now Index keeps Byte counts of MBCS string in AnsiValueBuffer
			cbAnsi = Index;
		}

		//
		// Free the buffer if it was successfully allocated
		//
		if (UnicodeValueBuffer != NULL) {
			RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValueBuffer );
		}

		//
		// Return the length of the ANSI version to the caller.
		//
		ValueLength = cbAnsi;

		//
		// Special hack to help out all the people who
		// believe the length of a NULL terminated string is
		// strlen(foo) instead of strlen(foo) + 1.
		// If the last character of the buffer is not a NULL
		// and there is enough space left in the caller's buffer,
		// slap a NULL in there to prevent him from going nuts
		// trying to do a strlen().
		//
		if (ARGUMENT_PRESENT( lpData ) &&
			(*lpcbData > ValueLength)  &&
            (ValueLength > 0) &&
			(lpData[ValueLength-1] != '\0')) {

			lpData[ValueLength] = '\0';
		}
    }

    //
    // Stored the returned length in the caller specified location and
    // return the error code.
    //

    if (lpdwType != NULL) {
        *lpdwType = ValueType;
    }

    if( ARGUMENT_PRESENT( lpcbData ) ) {
        *lpcbData = ValueLength;
    }

    //
    // Free the temporary Unicode string stub allocated for the ValueName
    //
    RtlFreeUnicodeString(&StubValueName);

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}


LONG
APIENTRY
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpdwType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for querying a value.

    RegQueryValueExW converts the lpValueName argument to a counted Unicode
    string and then calls BaseRegQueryValue.

--*/

{
    UNICODE_STRING      ValueName;
    DWORD               InputLength;
    DWORD               ValueLength;
    DWORD               ValueType;
    LONG                Error;
    HKEY                TempHandle = NULL;
    NTSTATUS            Status;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Validate dependency between lpData and lpcbData parameters.
    //

    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpData ) && ( ! ARGUMENT_PRESENT( lpcbData )))) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Convert the value name to a counted Unicode string.
    //

    Status = RtlInitUnicodeStringEx(&ValueName, lpValueName);
    if( !NT_SUCCESS(Status) ) {
        Error = RtlNtStatusToDosError( Status );
        goto ExitCleanup;
    }

    //
    //  Add the terminating NULL to the Length so that RPC transmits it.
    //
    ValueName.Length += sizeof( UNICODE_NULL );

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings. Note that zero bytes are transmitted (i.e.
    // InputLength = 0) for the data.
    //
    InputLength = 0;
    ValueLength = ( ARGUMENT_PRESENT( lpcbData ) )? *lpcbData : 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegQueryValue (
                            hKey,
                            &ValueName,
                            &ValueType,
                            lpData,
                            &ValueLength,
                            &InputLength
                            );
    } else {

        Error =  (LONG)BaseRegQueryValue (
                            DereferenceRemoteHandle( hKey ),
                            &ValueName,
                            &ValueType,
                            lpData,
                            &ValueLength,
                            &InputLength
                            );
    }
    //
    // Special hack to help out all the people who
    // believe the length of a NULL terminated string is
    // strlen(foo) instead of strlen(foo) + 1.
    // If the last character of the buffer is not a NULL
    // and there is enough space left in the caller's buffer,
    // slap a NULL in there to prevent him from going nuts
    // trying to do a strlen().
    //
    if ( (Error == ERROR_SUCCESS) &&
         ARGUMENT_PRESENT( lpData ) &&
         ( (ValueType == REG_SZ) ||
           (ValueType == REG_EXPAND_SZ) ||
           (ValueType==REG_MULTI_SZ)) &&
         ( ValueLength > sizeof(WCHAR))) {

        UNALIGNED WCHAR *String = (UNALIGNED WCHAR *)lpData;
        DWORD Length = ValueLength/sizeof(WCHAR);

        if ((String[Length-1] != UNICODE_NULL) &&
            (ValueLength+sizeof(WCHAR) <= *lpcbData)) {
            String[Length] = UNICODE_NULL;
        }
    }
    if( ARGUMENT_PRESENT( lpcbData ) ) {
        *lpcbData = ValueLength;
    }
    if ( ARGUMENT_PRESENT( lpdwType )) {
        *lpdwType = ValueType;
    }

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regqkey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regqkey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    query key APIs.  That is:

        - RegQueryInfoKeyA
        - RegQueryInfoKeyW

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regqkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"

LONG
RegQueryInfoKeyA (
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Win32 ANSI RPC wrapper for querying information about a previously
    opened key.

--*/

{
    PUNICODE_STRING     Class;
    UNICODE_STRING      UnicodeString;
    ANSI_STRING         AnsiString;
    NTSTATUS            Status;
    LONG                Error;
    DWORD               cSubKeys;
    DWORD               cbMaxSubKeyLen;
    DWORD               cValues;
    DWORD               cbMaxValueNameLen;
    DWORD               cbMaxValueLen;
    FILETIME            ftLastWriteTime;
    HKEY                TempHandle = NULL;
    DWORD               cbMaxClassLen;
    DWORD               cbSecurityDescriptor;
    PDWORD              pCbMaxClassLen = NULL;
    PDWORD              pCbSecurityDescriptor = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpClass ) && ( ! ARGUMENT_PRESENT( lpcbClass )))) {
        return ERROR_INVALID_PARAMETER;
    }


    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    //  Make sure that the buffer size for lpClass is zero if lpClass is NULL
    //
    if( !ARGUMENT_PRESENT( lpClass ) && ARGUMENT_PRESENT( lpcbClass ) ) {
        *lpcbClass = 0;
    }

    if( ARGUMENT_PRESENT( lpcbMaxClassLen ) ) {
        pCbMaxClassLen = &cbMaxClassLen;
    }

    if( ARGUMENT_PRESENT( lpcbSecurityDescriptor ) ) {
        pCbSecurityDescriptor = &cbSecurityDescriptor;
    }

    //
    //  If the count of bytes in the class is 0, pass a NULL pointer
    //  instead of what was supplied.  This ensures that RPC won't
    //  attempt to copy data to a bogus pointer.  Note that in this
    //  case we use the unicode string allocated on the stack, because
    //  we must not change the Buffer or MaximumLength fields of the
    //  static unicode string in the TEB.
    //
    if ( !ARGUMENT_PRESENT( lpClass ) || *lpcbClass == 0 ) {

        Class = &UnicodeString;
        Class->Length           = 0;
        Class->MaximumLength    = 0;
        Class->Buffer           = NULL;

    } else {

        //
        // Use the static Unicode string in the TEB as a temporary for the
        // key's class.
        //
        Class = &NtCurrentTeb( )->StaticUnicodeString;
        ASSERT( Class != NULL );
        Class->Length = 0;
    }


    //
    // Call the Base API passing it a pointer to a counted Unicode string
    // for the class string.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegQueryInfoKey(
                                hKey,
                                Class,
                                &cSubKeys,
                                &cbMaxSubKeyLen,
                                pCbMaxClassLen,
                                &cValues,
                                &cbMaxValueNameLen,
                                &cbMaxValueLen,
                                pCbSecurityDescriptor,
                                &ftLastWriteTime
                                );
    } else {
        //
        // on RPC always send valid pointers!!!
        //
        pCbMaxClassLen = &cbMaxClassLen;
        pCbSecurityDescriptor = &cbSecurityDescriptor;

        Error = (LONG)BaseRegQueryInfoKey(
                                DereferenceRemoteHandle( hKey ),
                                Class,
                                &cSubKeys,
                                &cbMaxSubKeyLen,
                                pCbMaxClassLen,
                                &cValues,
                                &cbMaxValueNameLen,
                                &cbMaxValueLen,
                                pCbSecurityDescriptor,
                                &ftLastWriteTime
                                );
        if (Error == ERROR_SUCCESS) {
            DWORD dwVersion;

            //
            // Check for a downlevel Win95 server, which requires
            // us to work around their BaseRegQueryInfoKey bugs.
            // They do not account for Unicode correctly.
            //
            if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
                //
                // This is a Win95 server.
                // Double the maximum value name length and
                // maximum value data length to account for
                // the Unicode translation that Win95 forgot
                // to account for.
                //
                cbMaxValueNameLen *= sizeof(WCHAR);
                cbMaxValueLen *= sizeof(WCHAR);
            }
        }
    }

    //
    //  MaxSubKeyLen, MaxClassLen, and MaxValueNameLen should be in
    //  number of characters, without counting the NULL.
    //  Note that the server side will return the number of bytes,
    //  without counting the NUL
    //

    cbMaxSubKeyLen /= sizeof( WCHAR );
    if( pCbMaxClassLen != NULL ) {
        cbMaxClassLen  /= sizeof( WCHAR );
        ASSERT( *pCbMaxClassLen == cbMaxClassLen ); 
    }
    cbMaxValueNameLen /= sizeof( WCHAR );


    //
    //  Subtract the NULL from the Length. This was added on
    //  the server side so that RPC would transmit it.
    //
    if ( Class->Length > 0 ) {
        Class->Length -= sizeof( UNICODE_NULL );
    }

    //
    // If all the information was succesfully queried from the key
    // convert the class name to ANSI and update the class length value.
    //

    if( ( Error == ERROR_SUCCESS ) &&
        ARGUMENT_PRESENT( lpClass ) && ( *lpcbClass != 0 ) ) {

        if (*lpcbClass > (DWORD)0xFFFF) {
            AnsiString.MaximumLength    = ( USHORT ) 0xFFFF;
        } else {
            AnsiString.MaximumLength    = ( USHORT ) *lpcbClass;
        }

        AnsiString.Buffer           = lpClass;

        Status = RtlUnicodeStringToAnsiString(
                    &AnsiString,
                    Class,
                    FALSE
                    );
        ASSERTMSG( "Unicode->ANSI conversion of Class ",
                    NT_SUCCESS( Status ));

        //
        // Update the class length return parameter.
        //

        *lpcbClass = AnsiString.Length;

        Error = RtlNtStatusToDosError( Status );

    } else {

        //
        // Not all of the information was succesfully queried, or Class
        // doesn't have to be converted from UNICODE to ANSI
        //

        if( ARGUMENT_PRESENT( lpcbClass ) ) {
            if( Class->Length == 0 ) {

                *lpcbClass = 0;

            } else {

                *lpcbClass = ( Class->Length >> 1 );
            }
        }
    }

    if( ARGUMENT_PRESENT( lpcSubKeys ) ) {
        *lpcSubKeys = cSubKeys;
    }
    if( ARGUMENT_PRESENT( lpcbMaxSubKeyLen ) ) {
        *lpcbMaxSubKeyLen = cbMaxSubKeyLen;
    }
    if( ARGUMENT_PRESENT( lpcbMaxClassLen ) ) {
        *lpcbMaxClassLen = cbMaxClassLen;
        ASSERT( *pCbMaxClassLen == cbMaxClassLen );
    }
    if( ARGUMENT_PRESENT( lpcValues ) ) {
        *lpcValues = cValues;
    }
    if( ARGUMENT_PRESENT( lpcbMaxValueNameLen ) ) {
        *lpcbMaxValueNameLen = cbMaxValueNameLen;
    }
    if( ARGUMENT_PRESENT( lpcbMaxValueLen ) ) {
        *lpcbMaxValueLen = cbMaxValueLen;
    }
    if( ARGUMENT_PRESENT( lpcbSecurityDescriptor ) ) {
        *lpcbSecurityDescriptor = cbSecurityDescriptor;
        ASSERT( *pCbSecurityDescriptor == cbSecurityDescriptor );
    }
    if( ARGUMENT_PRESENT( lpftLastWriteTime ) ) {
        *lpftLastWriteTime = ftLastWriteTime;
    }

ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

LONG
RegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Win32 Unicode RPC wrapper for querying information about a previously
    opened key.

--*/

{
    UNICODE_STRING  Class;
    LONG            Error;

    DWORD           cbClass;
    DWORD           cSubKeys;
    DWORD           cbMaxSubKeyLen;
    DWORD           cValues;
    DWORD           cbMaxValueNameLen;
    DWORD           cbMaxValueLen;
    FILETIME        ftLastWriteTime;
    HKEY            TempHandle = NULL;
    DWORD           cbMaxClassLen;
    DWORD           cbSecurityDescriptor;
    PDWORD          pCbMaxClassLen = NULL;
    PDWORD          pCbSecurityDescriptor = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif


    if( ARGUMENT_PRESENT( lpReserved ) ||
        (ARGUMENT_PRESENT( lpClass ) && ( ! ARGUMENT_PRESENT( lpcbClass )))) {
        return ERROR_INVALID_PARAMETER;
    }

    hKey = MapPredefinedHandle( hKey, &TempHandle );
    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    //  Make sure that the buffer size for lpClass is zero if lpClass is NULL
    //
    if( !ARGUMENT_PRESENT( lpClass ) && ARGUMENT_PRESENT( lpcbClass ) ) {
        *lpcbClass = 0;
    }

    if( ARGUMENT_PRESENT( lpcbMaxClassLen ) ) {
        pCbMaxClassLen = &cbMaxClassLen;
    }

    if( ARGUMENT_PRESENT( lpcbSecurityDescriptor ) ) {
        pCbSecurityDescriptor = &cbSecurityDescriptor;
    }

    //
    // Use the supplied class Class buffer as the buffer in a counted
    // Unicode Class.
    //
    Class.Length = 0;
    if( ARGUMENT_PRESENT( lpcbClass ) && ( *lpcbClass != 0 ) ) {

        Class.MaximumLength = ( USHORT )( *lpcbClass << 1 );
        Class.Buffer        = lpClass;

    } else {

        //
        // If the count of bytes in the class is 0, pass a NULL pointer
        // instead of what was supplied.  This ensures that RPC won't
        // attempt to copy data to a bogus pointer.
        //
        Class.MaximumLength = 0;
        Class.Buffer        = NULL;
    }

    //
    // Call the Base API.
    //

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegQueryInfoKey(
                                hKey,
                                &Class,
                                &cSubKeys,
                                &cbMaxSubKeyLen,
                                pCbMaxClassLen,
                                &cValues,
                                &cbMaxValueNameLen,
                                &cbMaxValueLen,
                                pCbSecurityDescriptor,
                                &ftLastWriteTime
                                );
    } else {
        //
        // on RPC always send valid pointers!!!
        //
        pCbMaxClassLen = &cbMaxClassLen;
        pCbSecurityDescriptor = &cbSecurityDescriptor;

        Error = (LONG)BaseRegQueryInfoKey(
                                DereferenceRemoteHandle( hKey ),
                                &Class,
                                &cSubKeys,
                                &cbMaxSubKeyLen,
                                pCbMaxClassLen,
                                &cValues,
                                &cbMaxValueNameLen,
                                &cbMaxValueLen,
                                pCbSecurityDescriptor,
                                &ftLastWriteTime
                                );
        if (Error == ERROR_SUCCESS) {
            DWORD dwVersion;
            //
            // Check for a downlevel Win95 server, which requires
            // us to work around their BaseRegQueryInfoKey bugs.
            // They do not account for Unicode correctly.
            //
            if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
                //
                // This is a Win95 server.
                // Double the maximum value name length and
                // maximum value data length to account for
                // the Unicode translation that Win95 forgot
                // to account for.
                //
                cbMaxValueNameLen *= sizeof(WCHAR);
                cbMaxValueLen *= sizeof(WCHAR);
            }
        }
    }

    //
    //  MaxSubKeyLen, MaxClassLen, and MaxValueNameLen should be in
    //  number of characters, without counting the NULL.
    //  Note that the server side will return the number of bytes,
    //  without counting the NUL
    //

    cbMaxSubKeyLen /= sizeof( WCHAR );
    if( pCbMaxClassLen != NULL ) {
        cbMaxClassLen  /= sizeof( WCHAR );
        ASSERT( *pCbMaxClassLen == cbMaxClassLen ); 
    }
    cbMaxValueNameLen /= sizeof( WCHAR );


    if( ARGUMENT_PRESENT( lpcbClass ) ) {
        if( Class.Length == 0 ) {
            *lpcbClass = 0;
        } else {
            *lpcbClass = ( Class.Length >> 1 ) - 1;
        }
    }

    if( ARGUMENT_PRESENT( lpcSubKeys ) ) {
        *lpcSubKeys = cSubKeys;
    }
    if( ARGUMENT_PRESENT( lpcbMaxSubKeyLen ) ) {
        *lpcbMaxSubKeyLen = cbMaxSubKeyLen;
    }
    if( ARGUMENT_PRESENT( lpcbMaxClassLen ) ) {
        *lpcbMaxClassLen = cbMaxClassLen;
        ASSERT( *pCbMaxClassLen == cbMaxClassLen ); 
    }
    if( ARGUMENT_PRESENT( lpcValues ) ) {
        *lpcValues = cValues;
    }
    if( ARGUMENT_PRESENT( lpcbMaxValueNameLen ) ) {
        *lpcbMaxValueNameLen = cbMaxValueNameLen;
    }
    if( ARGUMENT_PRESENT( lpcbMaxValueLen ) ) {
        *lpcbMaxValueLen = cbMaxValueLen;
    }
    if( ARGUMENT_PRESENT( lpcbSecurityDescriptor ) ) {
        *lpcbSecurityDescriptor = cbSecurityDescriptor;
        ASSERT( *pCbSecurityDescriptor == cbSecurityDescriptor );
    }
    if( ARGUMENT_PRESENT( lpftLastWriteTime ) ) {
        *lpftLastWriteTime = ftLastWriteTime;
    }

ExitCleanup:
    
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regrpc_client.c ===
#include <regrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regsckey.c ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsckey.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    APIs to set and get the SECURITY_DESCRIPTOR for a key.  That is:

        - RegGetKeySecurity
        - RegSetKeySecurity

Author:

    David J. Gilman (davegi) 18-Mar-1992

Notes:

    See the notes in server\regsckey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"
#include <wow64reg.h>

NTSTATUS BaseRegGetUserAndMachineClass(
    PVOID          pKeySemantics,
    HKEY           hKey,
    REGSAM         samDesired,
    PHKEY          phkMachine,
    PHKEY          phkUser);


LONG
APIENTRY
RegGetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    )

/*++

Routine Description:

    Win32 RPC wrapper for getting a key's security descriptor.

--*/

{
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    LONG                        Error;
    REGSAM                      DesiredAccess;
    HKEY                        hkSpecialHandle = NULL;

    HKEY                        hkMachineClass;
    HKEY                        hkUserClass;
    HKEY                        hkClassKey = NULL;

    BOOL                        fClassesRoot = FALSE;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }
    
    if( lpcbSecurityDescriptor == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (HKEY_CLASSES_ROOT == hKey) {
        fClassesRoot = TRUE;
    }

    if( IsPredefinedRegistryHandle( hKey ) &&
        ( ( RequestedInformation & SACL_SECURITY_INFORMATION ) != 0 )
      ) {
        //
        //  If SACL is to be retrieved, open a handle with special access
        //
        DesiredAccess = ACCESS_SYSTEM_SECURITY;
        if( ( RequestedInformation &
              ( DACL_SECURITY_INFORMATION |
                OWNER_SECURITY_INFORMATION |
                GROUP_SECURITY_INFORMATION
              ) ) != 0 ) {
            DesiredAccess |= READ_CONTROL;
        }

        Error = OpenPredefinedKeyForSpecialAccess( hKey,
                                                   DesiredAccess,
                                                   &hKey );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }
        ASSERT( IsLocalHandle( hKey ) );
        hkSpecialHandle = hKey;

    } else {
        hKey = MapPredefinedHandle( hKey, &TempHandle );

        DesiredAccess = MAXIMUM_ALLOWED;
    }

    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    if (IsLocalHandle( hKey )) {

        NTSTATUS Status;

        if (IsSpecialClassesHandle( hKey ) || fClassesRoot) {

            Status = BaseRegGetUserAndMachineClass(
                NULL,
                hKey,
                DesiredAccess,
                &hkMachineClass,
                &hkUserClass);

            if (!NT_SUCCESS(Status)) {
                Error = (error_status_t) RtlNtStatusToDosError(Status);
                goto ExitCleanup;
            }

            if (hkMachineClass && hkUserClass) {

                if (hkMachineClass != hKey) {
                    hkClassKey = hkMachineClass;
                } else {
                    hkClassKey = hkUserClass;
                }

                if (fClassesRoot) {
                    hKey = hkMachineClass;
                } else {
                    hKey = hkUserClass;
                }
            }
        }
    }

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor    = pSecurityDescriptor;
    RpcSD.cbInSecurityDescriptor  = *lpcbSecurityDescriptor;
    RpcSD.cbOutSecurityDescriptor = 0;

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegGetKeySecurity(
                                hKey,
                                RequestedInformation,
                                &RpcSD
                                );
    } else {

        Error = (LONG)BaseRegGetKeySecurity(
                                DereferenceRemoteHandle( hKey ),
                                RequestedInformation,
                                &RpcSD
                                );
    }

    //
    // Extract the size of the SECURITY_DESCRIPTOR from the RPCable version.
    //

    *lpcbSecurityDescriptor = RpcSD.cbInSecurityDescriptor;

    if (hkClassKey) {
        NtClose(hkClassKey);
    }

ExitCleanup:
    if(hkSpecialHandle) {
        RegCloseKey(hkSpecialHandle);
    }
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;

}

LONG
APIENTRY
RegSetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    Win32 RPC wrapper for setting a key's security descriptor.

--*/

{
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    LONG                        Error;
    REGSAM                      DesiredAccess;

    HKEY                        hkSpecialHandle = NULL;
    HKEY                        hkMachineClass;
    HKEY                        hkUserClass;
    HKEY                        hkClassKey = NULL;

    BOOL                        fClassesRoot = FALSE;
    HKEY                        TempHandle = NULL;


#if DBG
    if ( BreakPointOnEntry ) {
        DbgBreakPoint();
    }
#endif

    //
    // Limit the capabilities associated with HKEY_PERFORMANCE_DATA.
    //

    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return ERROR_INVALID_HANDLE;
    }

    if (HKEY_CLASSES_ROOT == hKey) {
        fClassesRoot = TRUE;
    }

    if( IsPredefinedRegistryHandle( hKey ) &&
        ( ( SecurityInformation & SACL_SECURITY_INFORMATION ) != 0 )
      ) {
        //
        //  If the SACL is to be set, open a handle with
        //  special access
        //
        DesiredAccess = MAXIMUM_ALLOWED | ACCESS_SYSTEM_SECURITY;
        if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            DesiredAccess |= WRITE_DAC;
        } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            DesiredAccess |= WRITE_OWNER;
        }

        Error = OpenPredefinedKeyForSpecialAccess( hKey,
                                                   DesiredAccess,
                                                   &hKey );
        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }
        ASSERT( IsLocalHandle( hKey ) );
        hkSpecialHandle = hKey;

    } else {
        hKey = MapPredefinedHandle( hKey, &TempHandle );

        DesiredAccess = MAXIMUM_ALLOWED;
    }

    if( hKey == NULL ) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    if (IsLocalHandle( hKey )) {

        NTSTATUS Status;

        if (IsSpecialClassesHandle( hKey ) || fClassesRoot) {

            Status = BaseRegGetUserAndMachineClass(
                NULL,
                hKey,
                DesiredAccess,
                &hkMachineClass,
                &hkUserClass);

            if (!NT_SUCCESS(Status)) {
                Error = (error_status_t) RtlNtStatusToDosError(Status);
                goto ExitCleanup;
            }

            if (hkMachineClass && hkUserClass) {

                if (hkMachineClass != hKey) {
                    hkClassKey = hkMachineClass;
                } else {
                    hkClassKey = hkUserClass;
                }

                if (fClassesRoot) {
                    hKey = hkMachineClass;
                } else {
                    hKey = hkUserClass;
                }
            }
        }
    }

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor = NULL;

    Error = MapSDToRpcSD(
        pSecurityDescriptor,
        &RpcSD
        );


    if( Error != ERROR_SUCCESS ) {
        goto ExitCleanup;
    }

    if( IsLocalHandle( hKey )) {

        Error = (LONG)LocalBaseRegSetKeySecurity (
                            hKey,
                            SecurityInformation,
                            &RpcSD
                            );
#if defined(_WIN64)
            if ( Error == 0)
                Wow64RegSetKeyDirty (hKey);
#endif

    } else {

        Error = (LONG)BaseRegSetKeySecurity (
                            DereferenceRemoteHandle( hKey ),
                            SecurityInformation,
                            &RpcSD
                            );
    }

    //
    // Free the buffer allocated by MapSDToRpcSD.
    //

    RtlFreeHeap(
        RtlProcessHeap( ), 0,
        RpcSD.lpSecurityDescriptor
        );

    if (hkClassKey) {
        NtClose(hkClassKey);
    }

ExitCleanup:
    if(hkSpecialHandle) {
        RegCloseKey(hkSpecialHandle);
    }
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\client\regqmval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regqmval.c

Abstract:

    This module contains the client side wrappers for the Win32 Registry
    query multiple values APIs:
        - RegQueryMultipleValuesA
        - RegQueryMultipleValuesW

Author:

    John Vert (jvert) 15-Jun-1995

Revision History:

--*/

#include <rpc.h>
#include "regrpc.h"
#include "client.h"


WINADVAPI
LONG
APIENTRY
RegQueryMultipleValuesA (
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    )
/*++

Routine Description:

    The RegQueryMultipleValues function retrieves a list of
    data type/data pairs for a list of value names associated
    with an open registry key.

Parameters:

        hKey
                Identifies a currently open key or any of the pre-defined reserved handle values:
                HKEY_CLASSES_ROOT
                HEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

        valList
                Points to an array of structures describing one or more value entries.  This
                contains the value names of the values to be queried.  Refer to Appendix A for a
                description of VALUE_ENTRY structure.

        num_vals
                Size of valList in bytes. If valListLength is not a multiple of the sizeof pvalue, the
                fractional extra space pointed to by valList is ignored.

        lpValueBuf
                The output buffer for returning value information (value names and value data). Data
                is DWORD aligned with pads inserted as necessary.

        ldwTotsize
                The total size of the output buffer pointed to by lpvalueBuf. On output ldwTotsize
                contains the number of bytes used including pads.  If lpValueBuf  was too short, then on
                output ldwTotsize will be the size needed, and caller should assume that lpValueBuf  was
                filled up to the size specified by ldwTotsize on input.

Return value:

    If the function succeeds, the return value is ERROR_SUCCESS; otherwise it is one
    of the error value which can be returned by RegQueryValueEx.  In addition, if
    either valList or lpValueBuf is too small then ERROR_INSUFFICIENT_BUFFER is returned
    If the function is unable to instantiate/access the provider of the
    dynamic key, it will return ERROR_CANTREAD.  If the total length of the
    requested data (valListLength + ldwTotSize) is more than the system limit of one
    megabytes, then the function returns ERROR_TRANSFER_TOO_LONG and only the first
    megabyte of data is returned.


--*/

{
    NTSTATUS        Status;
    PRVALENT        Values;
    PUNICODE_STRING Names;
    LONG            Error;
    ULONG           i;
    ULONG           DataLength;
    ULONG           InputLength;
    LPDWORD         pTotalSize;
    DWORD           TotalSize;
    ANSI_STRING     AnsiString;
    LPSTR           NewValueBuf = NULL;
    DWORD           DataOffset;
    ULONG           AnsiLength;
    HKEY            TempHandle = NULL;
    DWORD           RequiredSize;

    hKey = MapPredefinedHandle(hKey, &TempHandle);
    if (hKey == NULL) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Allocate an array of RVALENTs to describe the input value names
    //
    Values = RtlAllocateHeap(RtlProcessHeap(),0,num_vals * sizeof(RVALENT));
    if (Values == NULL) {
        Error = ERROR_OUTOFMEMORY;
        goto ExitCleanup;
    }
    ZeroMemory(Values, sizeof(RVALENT)*num_vals);

    //
    // Allocate an array of UNICODE_STRINGs to contain the input names
    //
    Names = RtlAllocateHeap(RtlProcessHeap(),0,num_vals * sizeof(UNICODE_STRING));
    if (Names == NULL) {
        Error = ERROR_OUTOFMEMORY;
        RtlFreeHeap(RtlProcessHeap(),0,Values);
        goto ExitCleanup;
    }
    ZeroMemory(Names, num_vals*sizeof(UNICODE_STRING));

    //
    // Convert the value names to UNICODE_STRINGs
    //
    for (i=0; i<num_vals; i++) {
        RtlInitAnsiString(&AnsiString, val_list[i].ve_valuename);
        Status = RtlAnsiStringToUnicodeString(&Names[i], &AnsiString, TRUE);
        if (!NT_SUCCESS(Status)) {
            Error =  RtlNtStatusToDosError( Status );
            goto Cleanup;
        }

        //
        //  Add the terminating NULL to the Length so that RPC transmits
        //  it.
        //
        Names[i].Length += sizeof( UNICODE_NULL );
        Values[i].rv_valuename = &Names[i];
    }

    //
    // Allocate a data buffer twice the size of the input buffer
    // so that any Unicode value data will fit before it is converted
    // to Ansi.
    //

    if ((ldwTotsize == NULL) || (*ldwTotsize == 0)) {
        TotalSize = 0;
    } else {
        TotalSize = *ldwTotsize * sizeof(WCHAR);
        NewValueBuf = RtlAllocateHeap(RtlProcessHeap(),0,TotalSize);
        if (NewValueBuf == NULL) {
            Error = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    pTotalSize = &TotalSize;

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if (IsLocalHandle(hKey)) {
        //
        // try new method first
        //
        RpcTryExcept {
            Error = (LONG)LocalBaseRegQueryMultipleValues2(hKey,
                                                          Values,
                                                          num_vals,
                                                          NewValueBuf,
                                                          pTotalSize,
                                                          &RequiredSize);
            *pTotalSize = RequiredSize;
        } 
        RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
            Error = RpcExceptionCode();
            if( Error == RPC_S_PROCNUM_OUT_OF_RANGE) {
                //
                // old server
                //
                //DbgPrint("WINREG: RPC_S_PROCNUM_OUT_OF_RANGE returned, trying old method\n");
                Error = (LONG)LocalBaseRegQueryMultipleValues(hKey,
                                                              Values,
                                                              num_vals,
                                                              NewValueBuf,
                                                              pTotalSize);
            }
        }
        RpcEndExcept

    } else {
        DWORD   dwVersion;
        //
        // try new method first
        //
        RpcTryExcept {
            Error = (LONG)BaseRegQueryMultipleValues2(DereferenceRemoteHandle( hKey ),
                                                     Values,
                                                     num_vals,
                                                     NewValueBuf,
                                                     pTotalSize,
                                                     &RequiredSize);
            *pTotalSize = RequiredSize;
        }
        RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
            Error = RpcExceptionCode();
            if( Error == RPC_S_PROCNUM_OUT_OF_RANGE) {
                //
                // old server
                //
                //DbgPrint("WINREG: RPC_S_PROCNUM_OUT_OF_RANGE returned, trying old method\n");
                Error = (LONG)BaseRegQueryMultipleValues(DereferenceRemoteHandle( hKey ),
                                                         Values,
                                                         num_vals,
                                                         NewValueBuf,
                                                         pTotalSize);
            } 
        }
        RpcEndExcept

        if ((Error == ERROR_SUCCESS) &&
            (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion))) {
            //
            // Win95's RegQueryMultipleValues doesn't return Unicode
            // value data, so do not try and convert it back to Ansi.
            //
            for (i=0; i<num_vals; i++) {
                val_list[i].ve_valuelen = Values[i].rv_valuelen;
                val_list[i].ve_type = Values[i].rv_type;
                val_list[i].ve_valueptr = (DWORD_PTR)(lpValueBuf + Values[i].rv_valueptr);
            }
            CopyMemory(lpValueBuf,NewValueBuf,TotalSize);
            if (ldwTotsize != NULL) {
                *ldwTotsize = TotalSize;
            }
            goto Cleanup;
        }
    }
    if (Error == ERROR_SUCCESS) {
        //
        // Convert results back.
        //
        DataOffset = 0;
        for (i=0; i < num_vals; i++) {
            val_list[i].ve_valuelen = Values[i].rv_valuelen;
            val_list[i].ve_type = Values[i].rv_type;
            val_list[i].ve_valueptr = (DWORD_PTR)(lpValueBuf + DataOffset);
            if ((val_list[i].ve_type == REG_SZ) ||
                (val_list[i].ve_type == REG_EXPAND_SZ) ||
                (val_list[i].ve_type == REG_MULTI_SZ)) {

                Status = RtlUnicodeToMultiByteN(lpValueBuf + DataOffset,
                                                Values[i].rv_valuelen/sizeof(WCHAR),
                                                &AnsiLength,
                                                (PWCH)(NewValueBuf + Values[i].rv_valueptr),
                                                Values[i].rv_valuelen);
                if (!NT_SUCCESS(Status)) {
                    Error =  RtlNtStatusToDosError( Status );
                }
                val_list[i].ve_valuelen = AnsiLength;
                DataOffset += AnsiLength;
            } else {
                CopyMemory(lpValueBuf + DataOffset,
                           NewValueBuf + Values[i].rv_valueptr,
                           Values[i].rv_valuelen);
                DataOffset += Values[i].rv_valuelen;
            }
            //
            // Round DataOffset up to dword boundary.
            //
            DataOffset = (DataOffset + sizeof(DWORD) - 1) & ~(sizeof(DWORD)-1);
        }
        if (ldwTotsize != NULL) {
            *ldwTotsize = DataOffset;
        }
    } else if (Error == ERROR_MORE_DATA) {
        //
        // We need to thunk the Unicode required bytes back to Ansi. But
        // there is not really any way to do this without having the data
        // available. So just return the required bytes for the Unicode
        // data, as this will always be enough.
        //
        if (ldwTotsize != NULL) {
            *ldwTotsize = *pTotalSize;
        }
    }

Cleanup:
    if (NewValueBuf != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,NewValueBuf);
    }
    for (i=0; i<num_vals; i++) {
        if (Names[i].Buffer != NULL) {
            RtlFreeUnicodeString(&Names[i]);
        }
    }
    RtlFreeHeap(RtlProcessHeap(),0,Values);
    RtlFreeHeap(RtlProcessHeap(),0,Names);

ExitCleanup:
    CLOSE_LOCAL_HANDLE(TempHandle);
    return Error;
}

WINADVAPI
LONG
APIENTRY
RegQueryMultipleValuesW (
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    )
/*++

Routine Description:

    The RegQueryMultipleValues function retrieves a list of
    data type/data pairs for a list of value names associated
    with an open registry key.

Parameters:

        hKey
                Identifies a currently open key or any of the pre-defined reserved handle values:
                HKEY_CLASSES_ROOT
                HEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

        valList
                Points to an array of structures describing one or more value entries.  This
                contains the value names of the values to be queried.  Refer to Appendix A for a
                description of VALUE_ENTRY structure.

        num_vals
                Size of valList in bytes. If valListLength is not a multiple of the sizeof pvalue, the
                fractional extra space pointed to by valList is ignored.

        lpValueBuf
                The output buffer for returning value information (value names and value data). Data
                is DWORD aligned with pads inserted as necessary.

        ldwTotsize
                The total size of the output buffer pointed to by lpValueBuf. On output ldwTotsize
                contains the number of bytes used including pads.  If lpValueBuf  was too short, then on
                output ldwTotsize will be the size needed, and caller should assume that lpValueBuf  was
                filled up to the size specified by ldwTotsize on input.

Return value:

    If the function succeeds, the return value is ERROR_SUCCESS; otherwise it is one
    of the error value which can be returned by RegQueryValueEx.  In addition, if
    either valList or lpValueBuf is too small then ERROR_INSUFFICIENT_BUFFER is returned
    If the function is unable to instantiate/access the provider of the
    dynamic key, it will return ERROR_CANTREAD.  If the total length of the
    requested data (valListLength + ldwTotSize) is more than the system limit of one
    megabytes, then the function returns ERROR_TRANSFER_TOO_LONG and only the first
    megabyte of data is returned.


--*/

{
    NTSTATUS        Status;
    PRVALENT        Values;
    PUNICODE_STRING Names;
    LONG            Error;
    ULONG           i;
    ULONG           DataLength;
    ULONG           InputLength;
    LPDWORD         pTotalSize;
    DWORD           TotalSize;
    DWORD           StringLength;
    HKEY            TempHandle = NULL;
    DWORD           RequiredSize;

    hKey = MapPredefinedHandle(hKey, &TempHandle);
    if (hKey == NULL) {
        Error = ERROR_INVALID_HANDLE;
        goto ExitCleanup;
    }

    //
    // Allocate an array of RVALENTs to describe the input value names
    //
    Values = RtlAllocateHeap(RtlProcessHeap(),0,num_vals * sizeof(RVALENT));
    if (Values == NULL) {
        Error = ERROR_OUTOFMEMORY;
        goto ExitCleanup;
    }
    ZeroMemory(Values, sizeof(RVALENT)*num_vals);

    //
    // Allocate an array of UNICODE_STRINGs to contain the input names
    //
    Names = RtlAllocateHeap(RtlProcessHeap(),0,num_vals * sizeof(UNICODE_STRING));
    if (Names == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, Values);
        Error = ERROR_OUTOFMEMORY;
        goto ExitCleanup;
    }
    ZeroMemory(Names, num_vals*sizeof(UNICODE_STRING));

    //
    // Copy and convert the value names to UNICODE_STRINGs
    // Note that we have to copy the value names because RPC tromps
    // on them.
    //
    for (i=0; i<num_vals; i++) {

        StringLength = wcslen(val_list[i].ve_valuename)*sizeof(WCHAR);
        Names[i].Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, StringLength + sizeof(UNICODE_NULL));
        if (Names[i].Buffer == NULL) {
            goto error_exit;
        }
        Names[i].Length = Names[i].MaximumLength = (USHORT)StringLength + sizeof(UNICODE_NULL);
        CopyMemory(Names[i].Buffer, val_list[i].ve_valuename, StringLength + sizeof(UNICODE_NULL));

        Values[i].rv_valuename = &Names[i];
    }

    if (ldwTotsize == NULL) {
        TotalSize = 0;
        pTotalSize = &TotalSize;
    } else {
        pTotalSize = ldwTotsize;
    }

    //
    // Call the Base API, passing it the supplied parameters and the
    // counted Unicode strings.
    //

    if (IsLocalHandle(hKey)) {
        //
        // try new method first
        //
        RpcTryExcept {
            Error = (LONG)LocalBaseRegQueryMultipleValues2(hKey,
                                                          Values,
                                                          num_vals,
                                                          (LPSTR)lpValueBuf,
                                                          pTotalSize,
                                                          &RequiredSize);

            *pTotalSize = RequiredSize;
        }
        RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
            Error = RpcExceptionCode();
            if( Error == RPC_S_PROCNUM_OUT_OF_RANGE) {
                //
                // old server
                //
                //DbgPrint("WINREG: RPC_S_PROCNUM_OUT_OF_RANGE returned, trying old method\n");
                Error = (LONG)LocalBaseRegQueryMultipleValues(hKey,
                                                              Values,
                                                              num_vals,
                                                              (LPSTR)lpValueBuf,
                                                              pTotalSize);
            } 
        }
        RpcEndExcept

    } else {
        DWORD dwVersion;
        if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
            //
            // We cannot support RegQueryMultipleValuesW to Win95 servers
            // since they do not return Unicode value data.
            //
            Error = ERROR_CALL_NOT_IMPLEMENTED;
        } else {
            //
            // try new method first
            //
            RpcTryExcept {
                //DbgPrint("WINREG: RPC_S_PROCNUM_OUT_OF_RANGE returned, trying old method\n");
                Error = (LONG)BaseRegQueryMultipleValues2(DereferenceRemoteHandle( hKey ),
                                                         Values,
                                                         num_vals,
                                                         (LPSTR)lpValueBuf,
                                                         pTotalSize,
                                                         &RequiredSize);
                *pTotalSize = RequiredSize;
            }
            RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
                Error = RpcExceptionCode();
                if( Error == RPC_S_PROCNUM_OUT_OF_RANGE) {
                    //
                    // old server
                    //
                    Error = (LONG)BaseRegQueryMultipleValues(DereferenceRemoteHandle( hKey ),
                                                             Values,
                                                             num_vals,
                           