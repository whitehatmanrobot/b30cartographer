n porting to 64 bit platforms, and MUST be used in all of our public 
// APIs (and therefore in our private APIs too, once we get 64 bit builds working).
//
// If you have a method that takes a native struct, you have two options for
// declaring that struct.  You can make it a value class ('struct' in cool), or
// a normal class.  This choice doesn't seem very interesting, but your function
// prototype must use different syntax depending on your choice.  For example,
// if your native method is prototyped as such:
// 
//    bool GetVersionEx(OSVERSIONINFO & lposvi);
//
//
// you must EITHER THIS OR THE NEXT syntax:
//
//    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
//    internal struct OSVERSIONINFO {  ...  }
//
//    [DllImport(KERNEL32, CharSet=CharSet.Auto)]
//    internal static extern bool GetVersionEx(ref OSVERSIONINFO lposvi);
//
// OR:
// 
//    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
//    internal class OSVERSIONINFO {  ...  }
//
//    [DllImport(KERNEL32, CharSet=CharSet.Auto)]
//    internal static extern bool GetVersionEx([In, Out] OSVERSIONINFO lposvi);
//
// Note that classes require being marked as [In, Out] while value classes must
// be passed as ref parameters.
//
// Also note the CharSet.Auto on GetVersionEx - while it does not take a String
// as a parameter, the OSVERSIONINFO contains an embedded array of TCHARs, so 
// the size of the struct varies on different platforms, and there's a 
// GetVersionExA & a GetVersionExW.  Also, the OSVERSIONINFO struct has a sizeof
// field so the OS can ensure you've passed in the correctly-sized copy of an
// OSVERSIONINFO.  You must explicitly set this using Marshal.SizeOf(Object);

namespace Microsoft.Win32 {

    using System;
    using System.Security;
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    // Win32 encapsulation for MSCORLIB.
    // Remove the default demands for all N/Direct methods with this
    // global declaration on the class.
    //
    [SuppressUnmanagedCodeSecurityAttribute()]
    internal sealed class Win32Native {

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        internal class OSVERSIONINFO { 
            public OSVERSIONINFO() {
                OSVersionInfoSize = (int)Marshal.SizeOf(this);
            }

            // The OSVersionInfoSize field must be set to Marshal.SizeOf(this)
            internal int OSVersionInfoSize = 0;
            internal int MajorVersion = 0; 
            internal int MinorVersion = 0; 
            internal int BuildNumber = 0; 
            internal int PlatformId = 0;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=128)]
            internal String CSDVersion = null;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal class SECURITY_ATTRIBUTES {
            internal int nLength = 0;
            internal int lpSecurityDescriptor = 0;
            internal int bInheritHandle = 0;
        }
    
        [StructLayout(LayoutKind.Sequential), Serializable]
        internal struct WIN32_FILE_ATTRIBUTE_DATA {
            internal int fileAttributes;
            internal uint ftCreationTimeLow;
            internal uint ftCreationTimeHigh;
            internal uint ftLastAccessTimeLow;
            internal uint ftLastAccessTimeHigh;
            internal uint ftLastWriteTimeLow;
            internal uint ftLastWriteTimeHigh;
            internal int fileSizeHigh;
            internal int fileSizeLow;
        }

        internal const String KERNEL32 = "kernel32.dll";
        internal const String USER32   = "user32.dll";
        internal const String ADVAPI32 = "advapi32.dll";
        internal const String OLE32    = "ole32.dll";
        internal const String OLEAUT32 = "oleaut32.dll";
        internal const String SHFOLDER = "shfolder.dll";
        internal const String LSTRCPY  = "lstrcpy";
        internal const String LSTRCPYN = "lstrcpyn";
        internal const String LSTRLEN  = "lstrlen";
        internal const String LSTRLENA = "lstrlenA";
        internal const String LSTRLENW = "lstrlenW";
        internal const String MOVEMEMORY = "RtlMoveMemory";

        // From WinBase.h
        internal const int SEM_FAILCRITICALERRORS = 1;
        internal const int VER_PLATFORM_WIN32s = 0;
        internal const int VER_PLATFORM_WIN32_WINDOWS = 1;
        internal const int VER_PLATFORM_WIN32_NT = 2;
        internal const int VER_PLATFORM_WINCE = 3;

        [DllImport(KERNEL32, CharSet=CharSet.Auto, SetLastError=true)]
        internal static extern bool GetVersionEx([In, Out] OSVERSIONINFO ver);
    
        [DllImport(KERNEL32, CharSet=CharSet.Auto)]
        internal static extern int FormatMessage(int dwFlags, IntPtr lpSource,
                    int dwMessageId, int dwLanguageId, StringBuilder lpBuffer,
                    int nSize, IntPtr va_list_arguments);
    
        [DllImport(ADVAPI32)]
        internal static extern int RegCloseKey(IntPtr hKey);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegConnectRegistry(String machineName,
                    IntPtr key, out IntPtr result);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegCreateKey(IntPtr hKey, String lpSubKey,
                    out IntPtr phkResult);
    
        // Note: RegCreateKeyEx won't set the last error on failure - it returns
        // an error code if it fails.
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegCreateKeyEx(IntPtr hKey, String lpSubKey,
                    int Reserved, String lpClass, int dwOptions,
                    int samDesigner, SECURITY_ATTRIBUTES lpSecurityAttributes,
                    out IntPtr hkResult, out int lpdwDisposition);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegDeleteKey(IntPtr hKey, String lpSubKey);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegDeleteValue(IntPtr hKey, String lpValueName);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegEnumKey(IntPtr hKey, int dwIndex,
                    StringBuilder lpName, int cbName);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegEnumKeyEx(IntPtr hKey, int dwIndex,
                    StringBuilder lpName, out int lpcbName, int[] lpReserved,
                    StringBuilder lpClass, int[] lpcbClass,
                    long[] lpftLastWriteTime);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegEnumValue(IntPtr hKey, int dwIndex,
                    StringBuilder lpValueName, ref int lpcbValueName,
                    IntPtr lpReserved_MustBeZero, int[] lpType, byte[] lpData,
                    int[] lpcbData);
    
        [DllImport(ADVAPI32)]
        internal static extern int RegFlushKey(IntPtr hKey);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegLoadKey(IntPtr hKey, String lpSubKey,
                    String lpFile);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegOpenKey(IntPtr hKey, String lpSubKey,
                    out IntPtr phkResult);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegOpenKeyEx(IntPtr hKey, String lpSubKey,
                    int ulOptions, int samDesired, out IntPtr hkResult);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegQueryInfoKey(IntPtr hKey, StringBuilder lpClass,
                    int[] lpcbClass, IntPtr lpReserved_MustBeZero, ref int lpcSubKeys,
                    int[] lpcbMaxSubKeyLen, int[] lpcbMaxClassLen,
                    ref int lpcValues, int[] lpcbMaxValueNameLen,
                    int[] lpcbMaxValueLen, int[] lpcbSecurityDescriptor,
                    int[] lpftLastWriteTime);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegQueryValue(IntPtr hKey, String lpSubKey,
                    StringBuilder lpValue, int[] lpcbValue);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)] 
        internal static extern int RegQueryValueEx(IntPtr hKey, String lpValueName,
                    int[] lpReserved, ref int lpType, [Out] byte[] lpData,
                    ref int lpcbData);

        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegQueryValueEx(IntPtr hKey, String lpValueName,
                    int[] lpReserved, int[] lpType, ref int lpData,
                    ref int lpcbData);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegQueryValueEx(IntPtr hKey, String lpValueName,
                     int[] lpReserved, ref int lpType, [Out] char[] lpData, 
                     ref int lpcbData);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegQueryValueEx(IntPtr hKey, String lpValueName,
                    int[] lpReserved, ref int lpType, StringBuilder lpData,
                    ref int lpcbData);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegReplaceKey(IntPtr hKey, String lpSubKey,
                    String lpNewFile, String lpOldFile);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegRestoreKey(IntPtr hKey, String lpFile,
                    int dwFlags);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegSaveKey(IntPtr hKey, String lpFile,
                    SECURITY_ATTRIBUTES lpSecuriteAttributes);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegSetValue(IntPtr hKey, String lpSubKey,
                    int dwType, String lpData, int cbData);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegSetValueEx(IntPtr hKey, String lpValueName,
                    int Reserved, int dwType, byte[] lpData, int cbData);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegSetValueEx(IntPtr hKey, String lpValueName,
                    int Reserved, int dwType, int[] lpData, int cbData);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegSetValueEx(IntPtr hKey, String lpValueName,
                    int Reserved, int dwType, IntPtr lpData, int cbData);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegSetValueEx(IntPtr hKey, String lpValueName,
                    int Reserved, int dwType, String lpData, int cbData);
    
        [DllImport(ADVAPI32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int RegUnLoadKey(IntPtr hKey, String lpSubKey);
    
        [DllImport(KERNEL32, CharSet=CharSet.Auto, SetLastError=true, BestFitMapping=false)]
        internal static extern int ExpandEnvironmentStrings(String lpSrc, StringBuilder lpDst, int nSize);

        [DllImport(KERNEL32, CharSet=CharSet.Ansi, SetLastError=true, BestFitMapping=false)]
        internal static extern int ExpandEnvironmentStringsA(byte [] lpSrc, byte [] lpDst, int nSize);
    
        [DllImport(KERNEL32)]
        internal static extern IntPtr LocalAlloc(int uFlags, IntPtr sizetdwBytes);

        [DllImport(KERNEL32)]
        internal static extern IntPtr LocalReAlloc(IntPtr handle, IntPtr sizetcbBytes, int uFlags);
    
        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern IntPtr LocalFree(IntPtr handle);
    
        [DllImport(KERNEL32, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern uint GetTempPath(int bufferLen, StringBuilder buffer);

        [DllImport(KERNEL32, CharSet=CharSet.Unicode, EntryPoint="GetCommandLineW")]
        private static extern IntPtr GetCommandLineWin32();

        // When marshaling strings as return types, the P/Invoke marshaller assumes
        // it must free the memory the original LPTSTR pointed to.  This isn't
        // quite valid when a function like this returns a pointer into the 
        // process's environment or similar kernel data structure.  This was causing
        // OLE32 to assert on checked builds of the OS, since OLEAUT didn't 
        // allocate the memory we were trying to free.
        internal static String GetCommandLine()
        {
            IntPtr cmdLineStr = GetCommandLineWin32();
            String CommandLine = Marshal.PtrToStringUni(cmdLineStr);
            return CommandLine;
        }
    
        [DllImport(KERNEL32, CharSet=CharSet.Auto, EntryPoint=LSTRCPY)]
        internal static extern IntPtr lstrcpy(IntPtr dst, String src);
    
        [DllImport(KERNEL32, CharSet=CharSet.Auto, EntryPoint=LSTRCPY)]
        internal static extern IntPtr lstrcpy(StringBuilder dst, IntPtr src);
    
        [DllImport(KERNEL32, CharSet=CharSet.Auto, EntryPoint=LSTRCPYN)]
        internal static extern IntPtr lstrcpyn(Delegate d1, Delegate d2, int cb);
    
        [DllImport(KERNEL32, CharSet=CharSet.Auto, EntryPoint=LSTRLEN)]
        internal static extern int lstrlen(sbyte [] ptr);
    
        [DllImport(KERNEL32, CharSet=CharSet.Auto, EntryPoint=LSTRLEN)]
        internal static extern int lstrlen(IntPtr ptr);
    
        [DllImport(KERNEL32, CharSet=CharSet.Ansi, EntryPoint=LSTRLENA)]
        internal static extern int lstrlenA(IntPtr ptr);
    
        [DllImport(KERNEL32, CharSet=CharSet.Unicode, EntryPoint=LSTRLENW)]
        internal static extern int lstrlenW(IntPtr ptr);
    
        [DllImport(Win32Native.OLE32)]
        internal static extern IntPtr CoTaskMemAlloc(int cb);

        [DllImport(Win32Native.OLE32)]
        internal static extern IntPtr CoTaskMemRealloc(IntPtr pv, int cb);
    
        [DllImport(Win32Native.OLE32)]
        internal static extern void CoTaskMemFree(IntPtr ptr);
    
        [DllImport(Win32Native.OLEAUT32, CharSet=CharSet.Unicode)]
        internal static extern IntPtr SysAllocStringLen(String src, int len);  // BSTR

        [DllImport(Win32Native.OLEAUT32)]
        internal static extern int SysStringLen(IntPtr bstr);

        [DllImport(Win32Native.OLEAUT32)]
        internal static extern void SysFreeString(IntPtr bstr);

        [DllImport(KERNEL32, CharSet=CharSet.Unicode, EntryPoint=MOVEMEMORY)]
        internal static extern void CopyMemoryUni(IntPtr pdst, String psrc, IntPtr sizetcb);
    
        [DllImport(KERNEL32, CharSet=CharSet.Unicode, EntryPoint=MOVEMEMORY)]
        internal static extern void CopyMemoryUni(StringBuilder pdst,
                    IntPtr psrc, IntPtr sizetcb);
    
        [DllImport(KERNEL32, CharSet=CharSet.Ansi, EntryPoint=MOVEMEMORY)]
        internal static extern void CopyMemoryAnsi(IntPtr pdst, String psrc, IntPtr sizetcb);
    
        [DllImport(KERNEL32, CharSet=CharSet.Ansi, EntryPoint=MOVEMEMORY)]
        internal static extern void CopyMemoryAnsi(StringBuilder pdst,
                    IntPtr psrc, IntPtr sizetcb);
    
        [DllImport(KERNEL32)]
        internal static extern int GetACP();
    
        // For GetFullPathName, the last param is a useless TCHAR**, set by native.
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int GetFullPathName(String path, int numBufferChars, StringBuilder buffer, IntPtr mustBeZero);

        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int SearchPath(String path, String fileName, String extension, int numBufferChars, StringBuilder buffer, int[] filePart);
        
        internal static IntPtr SafeCreateFile(String lpFileName,
                    int dwDesiredAccess, int dwShareMode,
                    IntPtr lpSecurityAttributes, int dwCreationDisposition,
                    int dwFlagsAndAttributes, IntPtr hTemplateFile)
        {
            IntPtr handle = CreateFile( lpFileName, dwDesiredAccess, dwShareMode,
                                lpSecurityAttributes, dwCreationDisposition,
                                dwFlagsAndAttributes, hTemplateFile );

            if (handle != Win32Native.INVALID_HANDLE_VALUE)
            {
                int fileType = Win32Native.GetFileType(handle);
                if (fileType != Win32Native.FILE_TYPE_DISK) {
                    Win32Native.CloseHandle(handle);
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_FileStreamOnNonFiles"));
                }
            }

            return handle;
        }            
                

        internal static IntPtr SafeCreateFile(String lpFileName,
                    int dwDesiredAccess, System.IO.FileShare dwShareMode,
                    SECURITY_ATTRIBUTES securityAttrs, System.IO.FileMode dwCreationDisposition,
                    int dwFlagsAndAttributes, IntPtr hTemplateFile)
        {
            IntPtr handle = CreateFile( lpFileName, dwDesiredAccess, dwShareMode,
                                securityAttrs, dwCreationDisposition,
                                dwFlagsAndAttributes, hTemplateFile );

            if (handle != Win32Native.INVALID_HANDLE_VALUE)
            {
                int fileType = Win32Native.GetFileType(handle);
                if (fileType != Win32Native.FILE_TYPE_DISK) {
                    Win32Native.CloseHandle(handle);
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_FileStreamOnNonFiles"));
                }
            }

            return handle;
        }            

        internal static IntPtr UnsafeCreateFile(String lpFileName,
                    int dwDesiredAccess, int dwShareMode,
                    IntPtr lpSecurityAttributes, int dwCreationDisposition,
                    int dwFlagsAndAttributes, IntPtr hTemplateFile)
        {
            IntPtr handle = CreateFile( lpFileName, dwDesiredAccess, dwShareMode,
                                lpSecurityAttributes, dwCreationDisposition,
                                dwFlagsAndAttributes, hTemplateFile );

            return handle;
        }            


        internal static IntPtr UnsafeCreateFile(String lpFileName,
                    int dwDesiredAccess, System.IO.FileShare dwShareMode,
                    SECURITY_ATTRIBUTES securityAttrs, System.IO.FileMode dwCreationDisposition,
                    int dwFlagsAndAttributes, IntPtr hTemplateFile)
        {
            IntPtr handle = CreateFile( lpFileName, dwDesiredAccess, dwShareMode,
                                securityAttrs, dwCreationDisposition,
                                dwFlagsAndAttributes, hTemplateFile );

            return handle;
        }            

        // Do not use these directly, use the safe or unsafe versions above.
        // The safe version does not support devices (aka if will only open
        // files on disk), while the unsafe version give you the full semantic
        // of the native version.

        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        private static extern IntPtr CreateFile(String lpFileName,
                    int dwDesiredAccess, int dwShareMode,
                    IntPtr lpSecurityAttributes, int dwCreationDisposition,
                    int dwFlagsAndAttributes, IntPtr hTemplateFile);

        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        private static extern IntPtr CreateFile(String lpFileName,
                    int dwDesiredAccess, System.IO.FileShare dwShareMode,
                    SECURITY_ATTRIBUTES securityAttrs, System.IO.FileMode dwCreationDisposition,
                    int dwFlagsAndAttributes, IntPtr hTemplateFile);
    
        [DllImport(KERNEL32)]
        internal static extern bool CloseHandle(IntPtr handle);

        [DllImport(KERNEL32)]
        internal static extern int GetFileType(IntPtr handle);

        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern bool SetEndOfFile(IntPtr hFile);
    
        [DllImport(KERNEL32, SetLastError=true, EntryPoint="SetFilePointer")]
        private unsafe static extern int SetFilePointerWin32(IntPtr handle, int lo, int * hi, int origin);

        internal unsafe static long SetFilePointer(IntPtr handle, long offset, System.IO.SeekOrigin origin, out int hr) {
            hr = 0;
            int lo = (int) offset;
            int hi = (int) (offset >> 32);
            lo = SetFilePointerWin32(handle, lo, &hi, (int) origin);
            if (lo == -1 && ((hr = Marshal.GetLastWin32Error()) != 0)) 
                return -1;
            return (long) (((ulong) ((uint) hi)) << 32) | ((uint) lo);
        }

        [DllImport(KERNEL32, CharSet=CharSet.Auto, SetLastError=true)]
        internal static extern int GetSystemDirectory(StringBuilder sb, int length);

        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern bool GetFileTime(IntPtr hFile, long[] creationTime,
                    long[] lastAccessTime, long[] lastWriteTime);
    
        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern bool SetFileTime(IntPtr hFile, long[] creationTime,
                    long[] lastAccessTime, long[] lastWriteTime);

        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern int GetFileSize(IntPtr hFile, out int highSize);

        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern bool LockFile(IntPtr handle, long offset, long count);
    
        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern bool UnlockFile(IntPtr handle,long offset,long count);

    
        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern IntPtr GetStdHandle(int nStdHandle);  // param is NOT a handle, but it returns one!

        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern bool SetConsoleMode(IntPtr hConsoleHandle, int mode);

        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern bool GetConsoleMode(IntPtr hConsoleHandle, out int mode);


        internal static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);  // WinBase.h
        internal static readonly IntPtr NULL = IntPtr.Zero;
    

        // Note, these are #defines used to extract handles, and are NOT handles.
        internal const int STD_INPUT_HANDLE = -10;
        internal const int STD_OUTPUT_HANDLE = -11;
        internal const int STD_ERROR_HANDLE = -12;

        // From wincon.h
        internal const int ENABLE_LINE_INPUT  = 0x0002;
        internal const int ENABLE_ECHO_INPUT  = 0x0004;
       
        // From WinBase.h
        internal const int FILE_TYPE_DISK = 0x0001;
        internal const int FILE_TYPE_CHAR = 0x0002;
        internal const int FILE_TYPE_PIPE = 0x0003;

        // Constants from WinNT.h
        internal const int FILE_ATTRIBUTE_DIRECTORY = 0x10;

        // Error codes from WinError.h
        internal const int ERROR_FILE_NOT_FOUND = 0x2;
        internal const int ERROR_PATH_NOT_FOUND = 0x3;
        internal const int ERROR_ACCESS_DENIED  = 0x5;
        internal const int ERROR_INVALID_HANDLE = 0x6;
        internal const int ERROR_NO_MORE_FILES = 0x12;
        internal const int ERROR_NOT_READY = 0x15;
        internal const int ERROR_SHARING_VIOLATION = 0x20;
        internal const int ERROR_FILE_EXISTS = 0x50;
        internal const int ERROR_INVALID_PARAMETER = 0x57;
        internal const int ERROR_CALL_NOT_IMPLEMENTED = 0x78;
        internal const int ERROR_PATH_EXISTS = 0xB7;
        internal const int ERROR_FILENAME_EXCED_RANGE = 0xCE;  // filename too long.
        internal const int ERROR_DLL_INIT_FAILED = 0x45A;


        // For the registry class
        internal const int ERROR_MORE_DATA = 234;

        // Use this to translate error codes like the above into HRESULTs like
        // 0x80070006 for ERROR_INVALID_HANDLE
        internal static int MakeHRFromErrorCode(int errorCode)
        {
            BCLDebug.Assert((0xFFFF0000 & errorCode) == 0, "This is an HRESULT, not an error code!");
            return unchecked(((int)0x80070000) | errorCode);
        }

        // Win32 Structs in N/Direct style
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto), Serializable]
        [BestFitMapping(false)]
        internal class WIN32_FIND_DATA {
            internal int  dwFileAttributes = 0;
            // ftCreationTime was a by-value FILETIME structure
            internal int  ftCreationTime_dwLowDateTime = 0 ;
            internal int  ftCreationTime_dwHighDateTime = 0;
            // ftLastAccessTime was a by-value FILETIME structure
            internal int  ftLastAccessTime_dwLowDateTime = 0;
            internal int  ftLastAccessTime_dwHighDateTime = 0;
            // ftLastWriteTime was a by-value FILETIME structure
            internal int  ftLastWriteTime_dwLowDateTime = 0;
            internal int  ftLastWriteTime_dwHighDateTime = 0;
            internal int  nFileSizeHigh = 0;
            internal int  nFileSizeLow = 0;
            internal int  dwReserved0 = 0;
            internal int  dwReserved1 = 0;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=260)]
            internal String   cFileName = null;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=14)]
            internal String   cAlternateFileName = null;
        }
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool CopyFile(
                    String src, String dst, bool failIfExists);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool CreateDirectory(
                    String path, int lpSecurityAttributes);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool DeleteFile(String path);
    
        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern bool FindClose(IntPtr hndFindFile);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern IntPtr FindFirstFile(
                    String pFileName,
                    [In, Out]
                    WIN32_FIND_DATA pFindFileData);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool FindNextFile(
                    IntPtr hndFindFile,
                    [In, Out, MarshalAs(UnmanagedType.LPStruct)]
                    WIN32_FIND_DATA lpFindFileData);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto)]
        internal static extern int GetCurrentDirectory(
                  int nBufferLength,
                  StringBuilder lpBuffer);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern int GetFileAttributes(String name);

        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);

        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool SetFileAttributes(String name, int attr);
    
        [DllImport(KERNEL32, SetLastError=true)]
        internal static extern int GetLogicalDrives();

        [DllImport(KERNEL32, CharSet=CharSet.Auto, SetLastError=true, BestFitMapping=false)]
        internal static extern uint GetTempFileName(String tmpPath, String prefix, uint uniqueIdOrZero, StringBuilder tmpFileName);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool MoveFile(String src, String dst);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool RemoveDirectory(String path);
    
        [DllImport(KERNEL32, SetLastError=true, CharSet=CharSet.Auto, BestFitMapping=false)]
        internal static extern bool SetCurrentDirectory(String path);

        [DllImport(KERNEL32, SetLastError=false)]
        internal static extern int SetErrorMode(int newMode);
    
        internal const int LCID_SUPPORTED = 0x00000002;  // supported locale ids
    
        [DllImport(KERNEL32)] 
        internal static extern bool IsValidLocale(int /*LCID*/ Locale, 
                                                [In, Out] long /*DWORD*/ flags);
    
        [DllImport(KERNEL32)]
        internal static extern int /*LCID*/ GetUserDefaultLCID();


        internal const int SHGFP_TYPE_CURRENT               = 0;             // the current (user) folder path setting
        internal const int UOI_FLAGS                        = 1;
        internal const int WSF_VISIBLE                      = 1;
        internal const int CSIDL_APPDATA                    = 0x001a;
        internal const int CSIDL_COMMON_APPDATA             = 0x0023;
        internal const int CSIDL_LOCAL_APPDATA              = 0x001c; 
        internal const int CSIDL_COOKIES                    = 0x0021;
        internal const int CSIDL_FAVORITES                  = 0x0006;   
        internal const int CSIDL_HISTORY                    = 0x0022;
        internal const int CSIDL_INTERNET_CACHE             = 0x0020;
        internal const int CSIDL_PROGRAMS                   = 0x0002; 
        internal const int CSIDL_RECENT                     = 0x0008; 
        internal const int CSIDL_SENDTO                     = 0x0009;
        internal const int CSIDL_STARTMENU                  = 0x000b;
        internal const int CSIDL_STARTUP                    = 0x0007;
        internal const int CSIDL_SYSTEM                     = 0x0025; 
        internal const int CSIDL_TEMPLATES                  = 0x0015;
        internal const int CSIDL_DESKTOPDIRECTORY           = 0x0010;
        internal const int CSIDL_PERSONAL                   = 0x0005; 
        internal const int CSIDL_PROGRAM_FILES              = 0x0026;
        internal const int CSIDL_PROGRAM_FILES_COMMON       = 0x002b;
        internal const int CSIDL_DESKTOP                    = 0x0000;
        internal const int CSIDL_DRIVES                     = 0x0011;
        internal const int CSIDL_MYMUSIC                    = 0x000d;
        internal const int CSIDL_MYPICTURES                 = 0x0027;


        [DllImport(KERNEL32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        internal static extern int GetModuleFileName(IntPtr hModule, StringBuilder buffer, int length);

        [DllImport(ADVAPI32, CharSet=CharSet.Auto)]
        internal static extern bool GetUserName(StringBuilder lpBuffer, int[] nSize);

        [DllImport(SHFOLDER, CharSet=CharSet.Auto)]
        internal static extern int SHGetFolderPath(IntPtr hwndOwner, int nFolder, IntPtr hToken, int dwFlags, StringBuilder lpszPath);

        [DllImport(ADVAPI32, CharSet=CharSet.Auto, SetLastError=true)]
        internal static extern bool LookupAccountName(string machineName, string accountName, byte[] sid,
                                 ref int sidLen, StringBuilder domainName, ref int domainNameLen, out int peUse);

        [DllImport(USER32, ExactSpelling=true)]
        internal static extern IntPtr GetProcessWindowStation();

        [DllImport(USER32, SetLastError=true)]
        internal static extern bool GetUserObjectInformation(IntPtr hObj, int nIndex, 
        [MarshalAs(UnmanagedType.LPStruct)] USEROBJECTFLAGS pvBuffer, int nLength, ref int lpnLengthNeeded);


        [StructLayout(LayoutKind.Sequential)]
        internal class USEROBJECTFLAGS {
            internal int fInherit = 0;
            internal int fReserved = 0;
            internal int dwFlags = 0;
        }

        [DllImport("Kernel32.dll")]
        internal static extern void GetSystemTimeAsFileTime(ref long lpSystemTimeAsFileTime);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\microsoft\win32\fusionwrap.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// FusionInterfaces.cs
//
// This implements wrappers to Fusion interfaces
//-------------------------------------------------------------
namespace Microsoft.Win32
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Globalization; 
    using StringBuilder = System.Text.StringBuilder;
     
    internal struct AssemblyInformation
    {
        public String FullName;
        public String Name;
        public String Version;
        public String Locale;
        public String PublicKeyToken;
    }
    
    
    //-------------------------------------------------------------
    // Interfaces defined by fusion
    //-------------------------------------------------------------
    [ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("21b8916c-f28e-11d2-a473-00c04f8ef448")]
    interface IAssemblyEnum
    { 
        [PreserveSig()]
        int GetNextAssembly(out IApplicationContext ppAppCtx, out IAssemblyName ppName, uint dwFlags);
        [PreserveSig()]
        int Reset();
        [PreserveSig()]
        int Clone(out IAssemblyEnum ppEnum);
    }
    
    [ComImport,InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("7c23ff90-33af-11d3-95da-00a024a85b51")]
    interface IApplicationContext
    {
        void SetContextNameObject(IAssemblyName pName); 
        void GetContextNameObject(out IAssemblyName ppName);
        void Set([MarshalAs(UnmanagedType.LPWStr)] String szName, int pvValue, uint cbValue, uint dwFlags);
        void Get([MarshalAs(UnmanagedType.LPWStr)] String szName, out int pvValue, ref uint pcbValue, uint dwFlags);
        void GetDynamicDirectory(out int wzDynamicDir, ref uint pdwSize);
    }
    
    
    [ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
    interface IAssemblyName
    {
        [PreserveSig()]
        int SetProperty(uint PropertyId, IntPtr pvProperty, uint cbProperty);
        [PreserveSig()]
        int GetProperty(uint PropertyId, IntPtr pvProperty, ref uint pcbProperty);
        [PreserveSig()]
        int Finalize();
        [PreserveSig()]
        int GetDisplayName(IntPtr szDisplayName, ref uint pccDisplayName, uint dwDisplayFlags);
        [PreserveSig()]
        int BindToObject(Object /*REFIID*/ refIID,  
                         Object /*IAssemblyBindSink*/ pAsmBindSink, 
                         IApplicationContext pApplicationContext,
                         [MarshalAs(UnmanagedType.LPWStr)] String szCodeBase,
                         Int64 llFlags,
                         int pvReserved,
                         uint cbReserved,
                         out int ppv);
        [PreserveSig()] 
        int GetName(out uint lpcwBuffer, out int pwzName);
        [PreserveSig()]
        int GetVersion(out uint pdwVersionHi, out uint pdwVersionLow);
        [PreserveSig()]
        int IsEqual(IAssemblyName pName, uint dwCmpFlags);
        [PreserveSig()]
        int Clone(out IAssemblyName pName);
    }
    
    internal class ASM_CACHE
    {
         public const uint ZAP          = 0x1;
         public const uint GAC          = 0x2;
         public const uint DOWNLOAD     = 0x4;
    }

    internal class CANOF
    {
        public const uint PARSE_DISPLAY_NAME = 0x1;
        public const uint SET_DEFAULT_VALUES = 0x2;
    }
    
    internal class ASM_NAME
    {   
         public const uint PUBLIC_KEY            = 0;
         public const uint PUBLIC_KEY_TOKEN      = PUBLIC_KEY + 1;
         public const uint HASH_VALUE            = PUBLIC_KEY_TOKEN + 1;
         public const uint NAME                  = HASH_VALUE + 1;
         public const uint MAJOR_VERSION         = NAME + 1;
         public const uint MINOR_VERSION         = MAJOR_VERSION + 1;
         public const uint BUILD_NUMBER          = MINOR_VERSION + 1;
         public const uint REVISION_NUMBER       = BUILD_NUMBER + 1;
         public const uint CULTURE               = REVISION_NUMBER + 1;
         public const uint PROCESSOR_ID_ARRAY    = CULTURE + 1;
         public const uint OSINFO_ARRAY          = PROCESSOR_ID_ARRAY + 1;
         public const uint HASH_ALGID            = OSINFO_ARRAY + 1;
         public const uint ALIAS                 = HASH_ALGID + 1;
         public const uint CODEBASE_URL          = ALIAS + 1;
         public const uint CODEBASE_LASTMOD      = CODEBASE_URL + 1;
         public const uint NULL_PUBLIC_KEY       = CODEBASE_LASTMOD + 1;
         public const uint NULL_PUBLIC_KEY_TOKEN  = NULL_PUBLIC_KEY + 1;
         public const uint CUSTOM                = NULL_PUBLIC_KEY_TOKEN + 1;
         public const uint NULL_CUSTOM           = CUSTOM + 1;
         public const uint MVID                  = NULL_CUSTOM + 1;
         public const uint _32_BIT_ONLY          = MVID + 1;
         public const uint MAX_PARAMS            = _32_BIT_ONLY + 1;
    }
    
    internal class Fusion
    {
        public static void ReadCache(ArrayList alAssems, String name, uint nFlag)
        {
            IAssemblyEnum aEnum         = null;
            IApplicationContext AppCtx  = null;
            IAssemblyName   aName       = null;
            IAssemblyName   pNameEnum   = null;
            int hr;

            if (name != null) {
                hr = CreateAssemblyNameObject(out pNameEnum, name, CANOF.PARSE_DISPLAY_NAME, 0);
                if (hr != 0)
                    return;
            }
            
            hr = CreateAssemblyEnum(out aEnum, null, pNameEnum, nFlag, 0);
            while (hr == 0)
            {
                hr = aEnum.GetNextAssembly(out AppCtx, out aName, 0);
                if (hr == 0)
                {
                    uint iLen=0;
                    IntPtr pDisplayName=(IntPtr)0;
                    // Get the length of the string we need
                    aName.GetDisplayName((IntPtr)0, ref iLen, 0);
                    if (iLen > 0)
                    {
                        // Do some yucky memory allocating here
                        // We need to assume that a wide character is 2 bytes.
                        pDisplayName = Marshal.AllocHGlobal(((int)iLen+1)*2);
                        aName.GetDisplayName(pDisplayName, ref iLen, 0);
                        String sDisplayName = Marshal.PtrToStringUni(pDisplayName);
                        Marshal.FreeHGlobal(pDisplayName);

                        // Our info is in a comma seperated list. Let's pull it out
                        String[] sFields = sDisplayName.Split(new char[] {','});
    
                        AssemblyInformation newguy = new AssemblyInformation();
                        newguy.FullName = sDisplayName;
                        newguy.Name = sFields[0];
                        // The version string is represented as Version=######
                        // Let's take out the 'Version='
                        newguy.Version = sFields[1].Substring(sFields[1].IndexOf('=')+1);
                        // Same goes for the locale
                        newguy.Locale = sFields[2].Substring(sFields[2].IndexOf('=')+1);
                        // And the  key token
                        sFields[3]=sFields[3].Substring(sFields[3].IndexOf('=')+1);
                        if (sFields[3].Equals("null"))
                            sFields[3] = "null"; 
                        newguy.PublicKeyToken = sFields[3];
                        
                        alAssems.Add(newguy);
                    }
                }
            }
        }
    
        [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
        static extern int CreateAssemblyNameObject(out IAssemblyName ppEnum, [MarshalAs(UnmanagedType.LPWStr)]String szAssemblyName, uint dwFlags, int pvReserved);
    
        [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
        static extern int CreateAssemblyEnum(out IAssemblyEnum ppEnum, IApplicationContext pAppCtx, IAssemblyName pName, uint dwFlags, int pvReserved);
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\microsoft\win32\oavariantlib.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  OAVariantLib
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: The CLR wrapper for OLE Automation operations.
**
** Date:  November 5, 1998
** 
===========================================================*/
namespace Microsoft.Win32 {
    
	using System;
	using System.Reflection;
	using System.Threading;
	using System.Runtime.CompilerServices;
	using CultureInfo = System.Globalization.CultureInfo;
	using Assert = System.Diagnostics.Assert;
    // Provides fully Ole Automation compatible Variant math operations.
    // This library provides Visual Basic backwards compatibility through
    // wrappers to routines from OleAut.dll.  This class will be of 
    // little interest to anyone outside of Microsoft's VB development team,
    // or developers porting code using OleAut32 to our runtime.
    // 
    // There are also some static methods duplicating the non-static 
    // methods on Variant.  Visual Basic cannot call methods on a Variant 
    // directly, only on the contents of a Variant.  We've stuck these
    // methods here for lack of a better place.
    // 
    //This class contains only static members and does not need to be serializable.
    internal sealed class OAVariantLib
    {
    	// Constants returned by VarCmp - we don't return these though.
    	private const int VARCMP_LT = 0;
    	private const int VARCMP_EQ = 1;
    	private const int VARCMP_GT = 2;
    	private const int VARCMP_NULL = 3;
    
    	// Constants for VariantChangeType from OleAuto.h
    	public const int NoValueProp = 0x01;
    	public const int AlphaBool = 0x02;
    	public const int NoUserOverride = 0x04;
    	public const int CalendarHijri = 0x08;
    	public const int LocalBool = 0x10;
    	
    	/////// HACK HACK HACK  : Had to move here when OAVariantLib was moved to
    	// another package.
        internal static readonly Type [] ClassTypes = {
            typeof(Empty),
            typeof(void),
            typeof(Boolean),
            typeof(Char),
            typeof(SByte),
            typeof(Byte),
            typeof(Int16),
            typeof(UInt16),
            typeof(Int32),
            typeof(UInt32),
            typeof(Int64),
            typeof(UInt64),
            typeof(Single),
            typeof(Double),
            typeof(String),
            typeof(void),
            typeof(DateTime),
            typeof(TimeSpan),
            typeof(Object),
            typeof(Decimal),
            null,  // Enums - what do we do here?
            typeof(Missing),
            typeof(DBNull),
        };
    	// Same hack hack hack - Keep these numbers in sync w/ the above array.
        private const int CV_OBJECT=0x12;
    	
    	private OAVariantLib() {
    	}
    	
    	
    	private static int GetCVTypeFromClass(Type ctype) {
#if _DEBUG
            BCLDebug.Assert(ClassTypes[CV_OBJECT] == typeof(Object), "OAVariantLib::ClassTypes[CV_OBJECT] == Object.class");
#endif
    
            int cvtype=-1;
            for (int i=0; i<ClassTypes.Length; i++) {
                if (ctype.Equals(ClassTypes[i])) {
                    cvtype=i;
                    break;
                }
            }
    
            // David Mortenson's OleAut Binder stuff works better if unrecognized
            // types were changed to Object.  So don't throw here.
    		if (cvtype == -1)
                cvtype = CV_OBJECT;
    
            return cvtype;
        }
    
    	// Adds two Variants, calling the OLE Automation VarAdd routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Add(Variant left, Variant right);
    	
    	// Subtracts two Variants, calling the OLE Automation VarSub routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Subtract(Variant left, Variant right);
    
    	// Multiplies two Variants, calling the OLE Automation VarMul routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Multiply(Variant left, Variant right);
    
    	// Divides two Variants, calling the OLE Automation VarDiv routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Divide(Variant left, Variant right);
    	
    	// Returns A mod B, calling the OLE Automation VarMod routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Mod(Variant left, Variant right);
    	
    	// Returns A to the B power, calling the OLE Automation VarPow routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Pow(Variant left, Variant right);
    	
    	// ANDs two Variants, calling the OLE Automation VarAnd routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant And(Variant left, Variant right);
    	
    	// ORs two Variants, calling the OLE Automation VarOr routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Or(Variant left, Variant right);
    	
    	// XORs two Variants, calling the OLE Automation VarXor routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Xor(Variant left, Variant right);
    	
    	// Returns the complement of XOR'ing two Variants, calling the OLE Automation VarEqv routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Eqv(Variant left, Variant right);
    	
    	// Divides two Variants as integers, calling the OLE Automation VarIdiv routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant IntDivide(Variant left, Variant right);
    	
    	// Returns (NOT A) OR B, calling the OLE Automation VarImp routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Implies(Variant left, Variant right);
    	
    	
    	// Negates a Variant, calling the OLE Automation VarNeg routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Negate(Variant op);
    
    	// Variant NOT operator, calling the OLE Automation VarNot routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Not(Variant op);
    
    	// Returns the absolute value of a Variant, calling the OLE 
    	// Automation VarAbs routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Abs(Variant value);
    	
    	// Rounds a Variant towards 0, calling the OLE Automation VarFix routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Fix(Variant op);
    	
    	// Rounds a Variant towards negative infinity (like C's floor function), 
    	// calling the OLE Automation VarInt routine.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Int(Variant op);
    	
    	// Compares two Variants, calling the OLE Automation VarCmp routine.
    	// Uses null as the culture and 0 as the flags value.
    	// 
    	public static int Compare(Variant left, Variant right)
    	{
    		return Compare(left, right, (CultureInfo)null, 0);
    	}
    	
    
    	// Compares two Variants, calling the OLE Automation VarCmp routine.
    	// Returns an int defined on the Relation class.
    	// 
    	public static int Compare(Variant left, Variant right, CultureInfo cultureInfo, int options)
    	{
    	    int r = Compare(left, right, false, false, (cultureInfo==null ? 0 : cultureInfo.LCID), options);
    		switch (r) {
    		case VARCMP_LT:
    			return -1;
    		case VARCMP_GT:
    			return 1;
    		case VARCMP_EQ:
    			return 0;
    		case VARCMP_NULL:
    			return 1; //Null sorts greater than any value.
    		default:
    			throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_UnexpectedValue"));
    		}
    	}
    
    	// Compares two Variants, calling the OLE Automation VarCmp routine.
    	// Use this for comparing variants that require a 0 or a 1 for an culture
    	// such as comparing 2 BStrs.
    	// 
    	public static int Compare(Variant left, Variant right, int lcid, int flags)
    	{
    		return Compare(left, right, false, false, lcid, flags);
    	}		
    	
    	// Compares two Variants, calling the OLE Automation VarCmp routine.
    	// This method will optionally set the undocumented VT_HARDTYPE bit 
    	// for Compares.
    	// 
    	// This is an undocumented feature of OleAut32.dll and may not
    	// be supported in the future, by either the Runtime or OleAut.  Don't
    	// expect this method to work or remain around in future versions.
    	// 
    	// One Variant must be a string.  If one Variant is a number and 
    	// its hard type bit is set, then the string will be converted into a 
    	// number and compared with the number (irregardless of whether the 
    	// string's hard type bit is set).  If the string has it's hard type 
    	// bit set, the number is converted into a string, then compared.  
    	// 
    	// Note that the numeric conversions are done in a restricted 
    	// set of types.  Those types are R8, Date, Bool and Decimal.
    	// 
    	public static int Compare(Variant left, Variant right, bool leftHardType, bool rightHardType, int lcid, int flags) {
            if (left.VariantType==typeof(Variant)) {
                left = (Variant)UnwrapVariant(left);
            }
            if (right.VariantType==typeof(Variant)) {
                right = (Variant)UnwrapVariant(right);
            }
            return InternalCompare(left, right, leftHardType, rightHardType, lcid, flags);
        }

    	internal static Object UnwrapVariant (Variant value) {
            Object retVal;
            retVal = value.ToObject();
            
            while (retVal is Variant) {
                Variant[] vArray = new Variant[1];
                vArray.SetValue(retVal, 0);
                retVal = vArray[0].ToObject();
            }

            return retVal;
        }

    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int InternalCompare(Variant left, Variant right, bool leftHardType, bool rightHardType, int lcid, int flags);
    
    	// Changes a Variant from one type to another, calling the OLE
    	// Automation VariantChangeType routine.  Note the legal types here are
    	// restricted to the subset of what can be legally found in a VB
    	// Variant and the types that CLR supports explicitly in the 
    	// CLR Variant class.  This means no arrays at this time.
    	// 
    	public static Variant ChangeType(Variant source, Type targetClass, short options)
    	{
    		if (targetClass==null)
    			throw new ArgumentNullException("targetClass");
    		return ChangeType(source, GetCVTypeFromClass(targetClass), options);
    	}
    
    	// Changes a Variant from one type to another, calling the OLE
    	// Automation VariantChangeType routine.  Note the legal types here are
    	// restricted to the subset of what can be legally found in a VB
    	// Variant and the types that CLR supports explicitly in the 
    	// CLR Variant class.  This means no arrays at this time.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern Variant ChangeType(Variant source, int cvType, short options);
    
    
    	// Changes a Variant from one type to another, calling the OLE
    	// Automation VariantChangeTypeEx routine.  Note the legal types here are
    	// restricted to the subset of what can be legally found in a VB
    	// Variant and the types that CLR supports explicitly in the 
    	// CLR Variant class.  This means no arrays at this time.
    	// 
    	public static Variant ChangeType(Variant source, Type targetClass, short options, CultureInfo culture)
    	{
    		if (targetClass==null)
    			throw new ArgumentNullException("targetClass");
            if (culture==null)
    			throw new ArgumentNullException("culture");
    		return ChangeTypeEx(source, culture.LCID, GetCVTypeFromClass(targetClass), options);
    	}
    
    	// Changes a Variant from one type to another, calling the OLE
    	// Automation VariantChangeTypeEx routine.  Note the legal types here are
    	// restricted to the subset of what can be legally found in a VB
    	// Variant and the types that CLR supports explicitly in the 
    	// CLR Variant class.  This means no arrays at this time.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern Variant ChangeTypeEx(Variant source, int lcid, int cvType, short flags);
    	
    	// Converts a Variant to a string with some custom formatting specifiers, 
    	// callling the OLE Automation VarFormat routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern String Format(Variant value, String format, int firstDay, int firstWeek, int flags);
    	
    	// Converts a boolean to a string, callling the OLE Automation
    	// VarBstrFromBool routine.
    	// 
    	public static String FormatBoolean(bool value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatBoolean(value, lcid, flags);
    	}
    
    	// Converts a boolean to a string, callling the OLE Automation
    	// VarBstrFromBool routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatBoolean(bool value, int lcid, int flags);
    
    	// Converts an unsigned byte to a string, callling the OLE Automation
    	// VarBstrFromUI1 routine.
    	// 
    	public static String FormatByte(byte value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatByte(value, lcid, flags);
    	}
    
    	// Converts an unsigned byte to a string, callling the OLE Automation
    	// VarBstrFromUI1 routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatByte(byte value, int lcid, int flags);
    	
    	// Converts a signed byte to a string, callling the OLE Automation
    	// VarBstrFromI1 routine.
    	// 
    	 [CLSCompliant(false)]
    	public static String FormatSByte(sbyte value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatSByte(value, lcid, flags);
    	}
    
    	// Converts a signed byte to a string, callling the OLE Automation
    	// VarBstrFromI1 routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatSByte(sbyte value, int lcid, int flags);
    
    	// Converts a short to a string, callling the OLE Automation
    	// VarBstrFromI2 routine.
    	// 
    	public static String FormatInt16(short value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatInt16(value, lcid, flags);
    	}
    
    	// Converts a short to a string, callling the OLE Automation
    	// VarBstrFromI2 routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatInt16(short value, int lcid, int flags);
    
    	// Converts an int to a string, callling the OLE Automation
    	// VarBstrFromI4 routine.
    	// 
    	public static String FormatInt32(int value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatInt32(value, lcid, flags);
    	}
    
    	// Converts an int to a string, callling the OLE Automation
    	// VarBstrFromI4 routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatInt32(int value, int lcid, int flags);
    
    	// Converts a float to a string, callling the OLE Automation
    	// VarBstrFromR4 routine.
    	// 
    	public static String FormatSingle(float value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatSingle(value, lcid, flags);
    	}
    
    	// Converts a float to a string, callling the OLE Automation
    	// VarBstrFromR4 routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatSingle(float value, int lcid, int flags);
    
    	// Converts a double to a string, callling the OLE Automation
    	// VarBstrFromR8 routine.
    	// 
    	public static String FormatDouble(double value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatDouble(value, lcid, flags);
    	}
    
    	// Converts a double to a string, callling the OLE Automation
    	// VarBstrFromR8 routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatDouble(double value, int lcid, int flags);
        	
    	// Converts a DateTime to a string, callling the OLE Automation
    	// VarBstrFromDate routine.
    	// 
    	public static String FormatDateTime(DateTime value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatDateTime(value, lcid, flags);
    	}
    
    	// Converts a DateTime to a string, callling the OLE Automation
    	// VarBstrFromR8 routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatDateTime(DateTime value, int lcid, int flags);
    
    	// Converts a DateTime to a string with formatting info, callling the 
    	// OLE Automation VarFormatDateTime routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern String FormatDateTime(Variant value, int namedFormat, int flags);
    
    	// Converts a Decimal to a string, callling the OLE Automation
    	// VarBstrFromDec routine.
    	// 
    	public static String FormatDecimal(Decimal value, CultureInfo culture, int flags)
    	{
    		int lcid = 0;
    		if (culture!=null)
    			lcid = culture.LCID;
    		return FormatDecimal(value, lcid, flags);
    	}
    
    	// Converts a Decimal to a string, callling the OLE Automation
    	// VarBstrFromDec routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern String FormatDecimal(Decimal value, int lcid, int flags);
    	
    	// Converts a Number to a string with formatting info, callling the 
    	// OLE Automation VarFormatNumber routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern String FormatNumber(Variant value, int numDig, int incLead, int useParens, int group, int flags);
    	
    	// Converts a percentage to a string with formatting info, callling the 
    	// OLE Automation VarFormatPercent routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern String FormatPercent(Variant value, int numDig, int incLead, int useParens, int group, int flags);
    
    	// Parses a DateTime from a String, calling the OLE Automation 
    	// VarDateFromStr routine.
    	// 
    	public static DateTime ParseDateTime(String str, CultureInfo culture, int flags)
    	{
    		if (str==null)
    			throw new ArgumentNullException("str");
    		int lcid = 0;
    		if (culture != null)
    			lcid = culture.LCID;
    		return new DateTime(ParseDateTime(str, lcid, flags));
    	}
    	
    	// Parses a tick counts for a DateTime from a String, calling 
    	// the OLE Automation VarDateFromStr routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern long ParseDateTime(String str, int lcid, int flags);
    	
    	// Parses a boolean from a String, calling the OLE Automation 
    	// VarBoolFromStr routine.
    	// 
    	public static bool ParseBoolean(String str, CultureInfo culture, int flags)
    	{
    		if (str==null)
    			throw new ArgumentNullException("str");
    		int lcid = 0;
    		if (culture != null)
    			lcid = culture.LCID;
    		return ParseBoolean(str, lcid, flags);
    	}
    	
    	// Parses a boolean from a String, calling the OLE Automation 
    	// VarBoolFromStr routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern bool ParseBoolean(String str, int lcid, int flags);
    	
    	// Rounds a Variant to a certain precision, calling the OLE Automation
    	// VarRound routine.
    	// 
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Variant Round(Variant src, int cDecimals);
    	
    	
    	//////////////////////////////////////////////////////////
    	/////////  Static Variant-wrapping methods for VB
    	/////////  (VB can't call methods on a Variant directly,
    	/////////   only on the contents of a Variant)
    	//////////////////////////////////////////////////////////
    	// Calls Variant::VariantType's get method.
    	public static Type VariantType(Variant v)
    	{

            Type t = v.VariantType;
            if (t!=typeof(Variant)) {
                return t;
            }
            
            //
            //Convert.ToObject has the code to tunnel into the Variant.
            //At that point, we just need to simulate Variant's semantics for what to return.
            //
            Object o = UnwrapVariant(v);
            if (o==null) {
                return typeof(Object);
            }
            return o.GetType();
    	}
    	
    	// Calls Variant::GetHashCode()
    	public static int GetHashCode(Variant v)
    	{
    		return v.GetHashCode();
    	}
    	
    	// Calls Variant::ToBoolean()
    	public static bool ToBoolean(Variant v)
    	{
    		return v.ToBoolean();
    	}
    	
    	// Calls Variant::ToByte()
    	public static byte ToByte(Variant v)
    	{
    		return v.ToByte();
    	}
    	
    	// Calls Variant::ToSByte()
    	 [CLSCompliant(false)]
    	public static sbyte ToSByte(Variant v)
    	{
    		return v.ToSByte();
    	}
    	
    	// Calls Variant::ToInt16()
    	public static short ToInt16(Variant v)
    	{
    		return v.ToInt16();
    	}
    	
    	// Calls Variant::ToUInt16()
    	 [CLSCompliant(false)]
    	public static ushort ToUInt16(Variant v)
    	{
    		return v.ToUInt16();
    	}
    	
    	// Calls Variant::ToChar()
    	public static char ToChar(Variant v)
    	{
    		return v.ToChar();
    	}
    
    	// Calls Variant::ToInt32()
    	public static int ToInt32(Variant v)
    	{
    		return v.ToInt32();
    	}
    
    	// Calls Variant::ToUInt32()
    	 [CLSCompliant(false)]
    	public static uint ToUInt32(Variant v)
    	{
    		return v.ToUInt32();
    	}
    
    	// Calls Variant::ToInt64()
    	public static long ToInt64(Variant v)
    	{
    		return v.ToInt64();
    	}
    
    	// Calls Variant::ToUInt64()
    	 [CLSCompliant(false)]
    	public static ulong ToUInt64(Variant v)
    	{
    		return v.ToUInt64();
    	}
    
    	// Calls Variant::ToSingle()
    	public static float ToSingle(Variant v)
    	{
    		return v.ToSingle();
    	}
    
    	// Calls Variant::ToDouble()
    	public static double ToDouble(Variant v)
    	{
    		return v.ToDouble();
    	}
    
    	// Calls Variant::ToDateTime()
    	public static DateTime ToDateTime(Variant v)
    	{
    		return v.ToDateTime();
    	}
    
    	// Calls Variant::ToTimeSpan()
    	public static TimeSpan ToTimeSpan(Variant v)
    	{
    		return v.ToTimeSpan();
    	}
    	
    	// Calls Variant::ToDecimal()
    	public static Decimal ToDecimal(Variant v)
    	{
    		return v.ToDecimal();
    	}
    
    	
    	// Calls Variant::ToString()
    	public static String ToString(Variant v)
    	{
    		return v.ToString();
    	}
    
    	// Calls Variant::ToObject()
    	public static Object ToObject(Variant v)
    	{
    		return v.ToObject();
    	}
    	
    	// Calls Variant::Equals(Variant)
    	public static bool Equals(Variant v1, Variant v2)
    	{
    		return v1.Equals(v2);
    	}
    
    	// Calls Variant::Equals(Object)
    	public static bool Equals(Variant v, Object obj)
    	{
    		return v.Equals(obj);
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\appdomainsetup.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: LoaderFlags
**
** Purpose: Defines the settings that the loader uses to find assemblies in an
**          AppDomain
**
** Date: Dec 22, 2000
**
=============================================================================*/

namespace System {
    
    using System;
    using System.Runtime.CompilerServices;
    using System.Text;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Globalization;
    using Path = System.IO.Path;

    // Only statics, does not need to be marked with the serializable attribute
    /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup"]/*' />
    [Serializable]
    [ClassInterface(ClassInterfaceType.None)]
    public sealed class AppDomainSetup : IAppDomainSetup
    {
        [Serializable]
        internal enum LoaderInformation
        {
            // If you add a new value, add the corresponding property
            // to AppDomain.GetData() and SetData()'s switch statements.
            ApplicationBaseValue = LOADER_APPLICATION_BASE,
            ConfigurationFileValue = LOADER_CONFIGURATION_BASE,
            DynamicBaseValue = LOADER_DYNAMIC_BASE,
            DevPathValue = LOADER_DEVPATH,
            ApplicationNameValue = LOADER_APPLICATION_NAME,
            PrivateBinPathValue = LOADER_PRIVATE_PATH,
            PrivateBinPathProbeValue = LOADER_PRIVATE_BIN_PATH_PROBE,
            ShadowCopyDirectoriesValue = LOADER_SHADOW_COPY_DIRECTORIES,
            ShadowCopyFilesValue = LOADER_SHADOW_COPY_FILES,
            CachePathValue = LOADER_CACHE_PATH,
            LicenseFileValue = LOADER_LICENSE_FILE,
            DisallowPublisherPolicyValue = LOADER_DISALLOW_PUBLISHER_POLICY,
            DisallowCodeDownloadValue = LOADER_DISALLOW_CODE_DOWNLOAD,
            DisallowBindingRedirectsValue = LOADER_DISALLOW_BINDING_REDIRECTS,
            LoaderMaximum = LOADER_MAXIMUM,
        }           
        
            
        private string[] _Entries;
        private LoaderOptimization _LoaderOptimization;
        private String _AppBase;
 
        internal AppDomainSetup(AppDomainSetup copy)
        {
            string[] mine = Value;
            if(copy != null) {
                string[] other = copy.Value;
                int size = _Entries.Length;
                for(int i = 0; i < size; i++) 
                    mine[i] = other[i];
                _LoaderOptimization = copy._LoaderOptimization;

            }
            else 
                _LoaderOptimization = LoaderOptimization.NotSpecified;

        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.AppDomainSetup"]/*' />
        public AppDomainSetup()
        { 
            _LoaderOptimization = LoaderOptimization.NotSpecified;
        }
        
        internal string[] Value
        {
            get {
                if( _Entries == null)
                    _Entries = new String[LOADER_MAXIMUM];
                return _Entries;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ApplicationBase"]/*' />
        public String ApplicationBase
        {
            get {
                if (_AppBase == null) {
                    String appbase = Value[(int) LoaderInformation.ApplicationBaseValue];
                    if (appbase != null)
                        _AppBase = NormalizePath(appbase, false);
                }

                if ((_AppBase != null) &&
                    ( (_AppBase[1] == ':') ||
                      ((_AppBase[0] == '\\') && (_AppBase[1] == '\\')) ))
                    new FileIOPermission( FileIOPermissionAccess.PathDiscovery, _AppBase ).Demand();
                
                return _AppBase;
            }

            set {
                Value[(int) LoaderInformation.ApplicationBaseValue] = value;
            }
        }

        //@TODO: get rid of this...
        private String NormalizePath(String path, bool useAppBase)
        {
            int len = path.Length;
            if ((len > 7) &&
                (String.Compare( path, 0, "file:", 0, 5, true, CultureInfo.InvariantCulture ) == 0)) {

                int trim;

                if (path[6] == '\\') {
                    if ((path[7] == '\\') || (path[7] == '/')) {

                        // Don't allow "file:\\\\", because we can't tell the difference
                        // with it for "file:\\" + "\\server" and "file:\\\" + "\localpath"
                        if ( (len > 8) && 
                             ((path[8] == '\\') || (path[8] == '/')) )
                            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPathChars"));
                        
                        // file:\\\ means local path
                        else
                            trim = 8;
                    }

                    // file:\\ means remote server
                    else
                        trim = 5;
                }

                // local path
                else if (path[7] == '/')
                    trim = 8;

                // remote
                else
                    trim = 7;
                
                path = path.Substring(trim);
            }
            
            if (path.IndexOf(':') == -1) {
                if (useAppBase) {
                    String appBase = Value[(int) LoaderInformation.ApplicationBaseValue];
                    if ((appBase == null) || (appBase.Length == 0))
                        throw new MemberAccessException(Environment.GetResourceString("AppDomain_AppBaseNotSet"));

                    if (_AppBase == null)
                        _AppBase = NormalizePath(appBase, false);

                    StringBuilder result = new StringBuilder();
                    result.Append(_AppBase);
                    int aLen = _AppBase.Length;

                    if (!( (_AppBase[aLen-1] == '/') ||
                           (_AppBase[aLen-1] == '\\') )) {
                        if ((aLen > 7) &&
                            (String.Compare(_AppBase, 0, "http:", 0, 5, true, CultureInfo.InvariantCulture) == 0))
                            result.Append('/');
                        else
                            result.Append('\\');
                    }

                    result.Append(path);
                    path = result.ToString();
                }
                else
                    path = Path.GetFullPathInternal(path);            
            }

            return path;
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ApplicationBaseKey"]/*' />
        internal static String ApplicationBaseKey
        {
            get {
                return ACTAG_APP_BASE_URL;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ConfigurationFile"]/*' />
        public String ConfigurationFile
        {
            get {
                String config = Value[(int) LoaderInformation.ConfigurationFileValue];
                if ((config != null) && (config.Length > 1)) {
                    config = NormalizePath(config, true);
                    if ((config[1] == ':') ||
                        ( (config[0] == '\\') && (config[1] == '\\') ))
                        new FileIOPermission( FileIOPermissionAccess.PathDiscovery, config ).Demand();
                }

                return config;             
            }

            set {
                Value[(int) LoaderInformation.ConfigurationFileValue] = value;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ConfigurationFileKey"]/*' />
        internal static String ConfigurationFileKey
        {
            get {
                return ACTAG_APP_CONFIG_FILE;
            }

        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.DynamicBase"]/*' />
        public String DynamicBase
        {
            get {
                String dynbase = Value[(int) LoaderInformation.DynamicBaseValue];
                if ((dynbase != null) && (dynbase.Length > 1)) {
                    dynbase = NormalizePath(dynbase, true);
                    if ((dynbase[1] == ':') ||
                        ( (dynbase[0] == '\\') && (dynbase[1] == '\\') ))
                        new FileIOPermission( FileIOPermissionAccess.PathDiscovery, dynbase ).Demand();
                }
                return dynbase;
            }

            set {
                if (value == null)
                    Value[(int) LoaderInformation.DynamicBaseValue] = null;
                else {
                    if(ApplicationName == null)
                        throw new MemberAccessException(Environment.GetResourceString("AppDomain_RequireApplicationName"));
                    
                    StringBuilder s = new StringBuilder(value);
                    s.Append('\\');
                    string h = ParseNumbers.IntToString(ApplicationName.GetHashCode(),
                                                        16, 8, '0', ParseNumbers.PrintAsI4);
                    s.Append(h);
                    
                    Value[(int) LoaderInformation.DynamicBaseValue] = s.ToString();
                }
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.DynamicBaseKey"]/*' />
        internal static String DynamicBaseKey
        {
            get {
                return ACTAG_APP_DYNAMIC_BASE;
            }
        }


        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.DisallowPublisherPolicy"]/*' />
        public bool DisallowPublisherPolicy
        {
            get 
            {
                return (Value[(int) LoaderInformation.DisallowPublisherPolicyValue] != null);
            }
            set
            {
                if (value)
                    Value[(int) LoaderInformation.DisallowPublisherPolicyValue] = "true";
                else
                    Value[(int) LoaderInformation.DisallowPublisherPolicyValue] = null;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.DisallowBindingRedirects"]/*' />
        public bool DisallowBindingRedirects
        {
            get 
            {
                return (Value[(int) LoaderInformation.DisallowBindingRedirectsValue] != null);
            }
            set
            {
                if (value)
                    Value[(int) LoaderInformation.DisallowBindingRedirectsValue] = "true";
                else
                    Value[(int) LoaderInformation.DisallowBindingRedirectsValue] = null;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.DisallowCodeDownload"]/*' />
        public bool DisallowCodeDownload
        {
            get 
            {
                return (Value[(int) LoaderInformation.DisallowCodeDownloadValue] != null);
            }
            set
            {
                if (value)
                    Value[(int) LoaderInformation.DisallowCodeDownloadValue] = "true";
                else
                    Value[(int) LoaderInformation.DisallowCodeDownloadValue] = null;
            }
        }
       
        private void VerifyDirList(String dirs)
        {
            if (dirs != null) {
                String[] dirArray = dirs.Split(';');
                int len = dirArray.Length;
                
                for (int i = 0; i < len; i++) {
                    if (dirArray[i].Length > 1) {
                        dirArray[i] = NormalizePath(dirArray[i], true);
                        if ((dirArray[i][1] == ':') ||
                            ( (dirArray[i][0] == '\\') && (dirArray[i][1] == '\\') ))
                            new FileIOPermission( FileIOPermissionAccess.PathDiscovery, dirArray[i] ).Demand();
                    }
                }
            }
        }

        internal String DeveloperPath
        {
            get {
                String dirs = Value[(int) LoaderInformation.DevPathValue];
                VerifyDirList(dirs);
                return dirs;
            }

            set {
                if(value == null)
                    Value[(int) LoaderInformation.DevPathValue] = null;
                else {
                    String[] directories = value.Split(';');
                    int size = directories.Length;
                    if(size > 0) {
                        StringBuilder newPath = new StringBuilder();
                        bool fDelimiter = false;
                        
                        for(int i = 0; i < size; i++) {
                            if(directories[i].Length > 0) {
                                if(fDelimiter) 
                                    newPath.Append(";");
                                else
                                    fDelimiter = true;
                                
                                newPath.Append(Path.GetFullPathInternal(directories[i]));
                            }
                        }

                        Value[(int) LoaderInformation.DevPathValue] = newPath.ToString();
                    }
                }
            }
        }
        
        internal static String DisallowPublisherPolicyKey
        {
            get
            {
                return ACTAG_DISALLOW_APPLYPUBLISHERPOLICY;
            }
        }

        internal static String DisallowCodeDownloadKey
        {
            get
            {
                return ACTAG_CODE_DOWNLOAD_DISABLED;
            }
        }

        internal static String DisallowBindingRedirectsKey
        {
            get
            {
                return ACTAG_DISALLOW_APP_BINDING_REDIRECTS;
            }
        }

        internal static String DeveloperPathKey
        {
            get {
                return ACTAG_DEV_PATH;
            }
        }
        
        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ApplicationName"]/*' />
        public String ApplicationName
        {
            get {
                return Value[(int) LoaderInformation.ApplicationNameValue];
            }

            set {
                Value[(int) LoaderInformation.ApplicationNameValue] = value;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ApplicationNameKey"]/*' />
        internal static String ApplicationNameKey
        {
            get {
                return ACTAG_APP_NAME;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.PrivateBinPath"]/*' />
        public String PrivateBinPath
        {
            get {
                String dirs = Value[(int) LoaderInformation.PrivateBinPathValue];
                VerifyDirList(dirs);
                return dirs;
            }

            set {
                Value[(int) LoaderInformation.PrivateBinPathValue] = value;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.PrivateBinPathKey"]/*' />
        internal static String PrivateBinPathKey
        {
            get {
                return ACTAG_APP_PRIVATE_BINPATH;
            }
        }


        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.PrivateBinPathProbe"]/*' />
        public String PrivateBinPathProbe
        {
            get {
                return Value[(int) LoaderInformation.PrivateBinPathProbeValue];
            }

            set {
                Value[(int) LoaderInformation.PrivateBinPathProbeValue] = value;
            }
        }
 
        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.PrivateBinPathProbeKey"]/*' />
        internal static String PrivateBinPathProbeKey
        {
            get {
                return ACTAG_BINPATH_PROBE_ONLY;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ShadowCopyDirectories"]/*' />
        public String ShadowCopyDirectories
        {
            get {
                String dirs = Value[(int) LoaderInformation.ShadowCopyDirectoriesValue];
                VerifyDirList(dirs);
                return dirs;
            }

            set {
                if (value == null)
                    Value[(int) LoaderInformation.ShadowCopyDirectoriesValue] = null;
                else {
                    String[] dirArray = value.Split(';');
                    int len = dirArray.Length;
                    StringBuilder newPath = new StringBuilder();
                    bool fDelimiter = false;
                    
                    for(int i = 0; i < len; i++) {
                        if(dirArray[i].Length > 0) {
                            if(fDelimiter) 
                                newPath.Append(";");
                            else
                                fDelimiter = true;
                            
                            newPath.Append(dirArray[i]);
                        }
                    }
                    
                    Value[(int) LoaderInformation.ShadowCopyDirectoriesValue] = newPath.ToString();
                }
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ShadowCopyDirectoriesKey"]/*' />
        internal static String ShadowCopyDirectoriesKey
        {
            get {
                return ACTAG_APP_SHADOW_COPY_DIRS;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ShadowCopyFiles"]/*' />
        public String ShadowCopyFiles
        {
            get {
                return Value[(int) LoaderInformation.ShadowCopyFilesValue];
            }

            set {
                Value[(int) LoaderInformation.ShadowCopyFilesValue] = value;
            }
        }
        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ShadowCopyFilesKey"]/*' />
        internal static String ShadowCopyFilesKey
        {
            get {
                return ACTAG_FORCE_CACHE_INSTALL;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.CachePath"]/*' />
        public String CachePath
        {
            get {
                String dir = Value[(int) LoaderInformation.CachePathValue];
                if ((dir != null) && (dir.Length > 1)) {
                    dir = NormalizePath(dir, true);
                    if ((dir[1] == ':') ||
                        ( (dir[0] == '\\') && (dir[1] == '\\') ))
                        new FileIOPermission( FileIOPermissionAccess.PathDiscovery, dir ).Demand();
                }

                return dir;
            }

            set {
                Value[(int) LoaderInformation.CachePathValue] = value;
            }
        }
        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.CachePathKey"]/*' />
        internal static String CachePathKey
        {
            get {
                return ACTAG_APP_CACHE_BASE;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.LicenseFile"]/*' />
        public String LicenseFile
        {
            get {
                String dir = Value[(int) LoaderInformation.LicenseFileValue];
                if ((dir != null) && (dir.Length > 1)) {
                    dir = NormalizePath(dir, true);
                    if ((dir[1] == ':') ||
                        ( (dir[0] == '\\') && (dir[1] == '\\') ))
                        new FileIOPermission( FileIOPermissionAccess.PathDiscovery, dir ).Demand();
                }

                return dir;
            }

            set {
                Value[(int) LoaderInformation.LicenseFileValue] = value;
            }
        }
        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.LicenseFileKey"]/*' />
        internal static String LicenseFileKey
        {
            get {
                return LICENSE_FILE;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.LoaderOptimization"]/*' />
        public LoaderOptimization LoaderOptimization
        {
            get {
                return _LoaderOptimization;
            }

            set {
                _LoaderOptimization = value;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.LoaderOptimizationKey"]/*' />
        internal static string LoaderOptimizationKey
        {
            get {
                return LOADER_OPTIMIZATION;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.DynamicDirectoryKey"]/*' />
        internal static string DynamicDirectoryKey
        {
            get {
                return DYNAMIC_DIRECTORY;
            }
        }

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.ConfigurationExtenstion"]/*' />
        internal static string ConfigurationExtenstion
        {
            get {
                return CONFIGURATION_EXTENSION;
            }
        }

        internal static String PrivateBinPathEnvironmentVariable
        {
            get {
                return APPENV_RELATIVEPATH;
            }
        }

        internal static string RuntimeConfigurationFile
        {
            get {
                return MACHINE_CONFIGURATION_FILE;
            }
        }

        internal static string MachineConfigKey
        {
            get {
                return ACTAG_MACHINE_CONFIG;
            }
        }

        internal static string HostBindingKey
        {
            get {
                return ACTAG_HOST_CONFIG_FILE;
            }
        }

        internal void SetupFusionContext(IntPtr fusionContext)
        {
            String appbase = Value[(int) LoaderInformation.ApplicationBaseValue];
            if(appbase != null)
                UpdateContextProperty(fusionContext, ApplicationBaseKey, appbase);

            String privBinPath = Value[(int) LoaderInformation.PrivateBinPathValue];
            if(privBinPath != null)
                UpdateContextProperty(fusionContext, PrivateBinPathKey, privBinPath);

            String devpath = Value[(int) LoaderInformation.DevPathValue];
            if(devpath != null)
                UpdateContextProperty(fusionContext, DeveloperPathKey, devpath);

            if (DisallowPublisherPolicy)
                UpdateContextProperty(fusionContext, DisallowPublisherPolicyKey, "true");

            if (DisallowCodeDownload)
                UpdateContextProperty(fusionContext, DisallowCodeDownloadKey, "true");

            if (DisallowBindingRedirects)
                UpdateContextProperty(fusionContext, DisallowBindingRedirectsKey, "true");

            if(ShadowCopyFiles != null) {
                UpdateContextProperty(fusionContext, ShadowCopyFilesKey, ShadowCopyFiles);

                // If we are asking for shadow copy directories then default to
                // only to the ones that are in the private bin path.
                if(Value[(int) LoaderInformation.ShadowCopyDirectoriesValue] == null)
                    ShadowCopyDirectories = BuildShadowCopyDirectories();

                String shadowDirs = Value[(int) LoaderInformation.ShadowCopyDirectoriesValue];
                if(shadowDirs != null)
                    UpdateContextProperty(fusionContext, ShadowCopyDirectoriesKey, shadowDirs);
            }

            String cache = Value[(int) LoaderInformation.CachePathValue];
            if(cache != null)
                UpdateContextProperty(fusionContext, CachePathKey, cache);

            if(PrivateBinPathProbe != null)
                UpdateContextProperty(fusionContext, PrivateBinPathProbeKey, PrivateBinPathProbe); 

            String config = Value[(int) LoaderInformation.ConfigurationFileValue];
            if (config != null)
                UpdateContextProperty(fusionContext, ConfigurationFileKey, config);

            if(ApplicationName != null)
                UpdateContextProperty(fusionContext, ApplicationNameKey, ApplicationName);

            String dynbase = Value[(int) LoaderInformation.DynamicBaseValue];
            if(dynbase != null)
                UpdateContextProperty(fusionContext, DynamicBaseKey, dynbase);

            // Always add the runtime configuration file to the appdomain
            StringBuilder configFile = new StringBuilder();
            configFile.Append(RuntimeEnvironment.GetRuntimeDirectoryImpl());
            configFile.Append(RuntimeConfigurationFile);
            UpdateContextProperty(fusionContext, MachineConfigKey, configFile.ToString());

            String hostBindingFile = RuntimeEnvironment.GetHostBindingFile();
            if(hostBindingFile != null) 
              UpdateContextProperty(fusionContext, HostBindingKey, hostBindingFile);

        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void UpdateContextProperty(IntPtr fusionContext, string key, string value);

        /// <include file='doc\AppDomainSetup.uex' path='docs/doc[@for="AppDomainSetup.Locate"]/*' />
        static internal int Locate(String s)
        {
            return Mapping.Locate(s);
        }

        private string BuildShadowCopyDirectories()
        {
            String binPath = Value[(int) LoaderInformation.PrivateBinPathValue];
            if(binPath == null)
                return null;

            StringBuilder result = new StringBuilder();
            String appBase = Value[(int) LoaderInformation.ApplicationBaseValue];
            if(appBase != null) {
                char[] sep = {';'};
                string[] directories = binPath.Split(sep);
                int size = directories.Length;
                bool appendSlash = !( (appBase[appBase.Length-1] == '/') ||
                                      (appBase[appBase.Length-1] == '\\') );

                if (size == 0) {
                    result.Append(appBase);
                    if (appendSlash)
                        result.Append('\\');
                    result.Append(binPath);
                }
                else {
                    for(int i = 0; i < size; i++) {
                        result.Append(appBase);
                        if (appendSlash)
                            result.Append('\\');
                        result.Append(directories[i]);
                        
                        if (i < size-1)
                            result.Append(';');
                    }
                }
            }
            
            return result.ToString();
        }

        // This is a separate class that will be loaded only when a mapping is
        // required.
        private class Mapping {

            struct Entry
            {
                public string value;
                public int slot;
            }

            private static Object _table; 

            // Make sure these are sorted
            static private string[] OldNames =
            { 
                ACTAG_APP_CONFIG_FILE,
                ACTAG_APP_NAME,
                ACTAG_APP_BASE_URL,
                ACTAG_BINPATH_PROBE_ONLY,
                ACTAG_APP_CACHE_BASE,
                ACTAG_DEV_PATH,
                ACTAG_APP_DYNAMIC_BASE,
                ACTAG_FORCE_CACHE_INSTALL,
                LICENSE_FILE,
                ACTAG_APP_PRIVATE_BINPATH,
                ACTAG_APP_SHADOW_COPY_DIRS,
            };

            static private LoaderInformation[] Location = 
            {
                LoaderInformation.ConfigurationFileValue,
                LoaderInformation.ApplicationNameValue,
                LoaderInformation.ApplicationBaseValue,
                LoaderInformation.PrivateBinPathProbeValue,
                LoaderInformation.CachePathValue,
                LoaderInformation.DevPathValue,
                LoaderInformation.DynamicBaseValue,
                LoaderInformation.ShadowCopyFilesValue,
                LoaderInformation.LicenseFileValue,
                LoaderInformation.PrivateBinPathValue,
                LoaderInformation.ShadowCopyDirectoriesValue,
            };

            internal static int Locate(String setting)
            {
                if(setting == null)
                    return -1;

                Entry[] t = Table();
                int l = 0;     
                int r = t.Length - 1;
                int piviot;
                while(true) {
                    piviot =  (l + r) / 2;
                    int v = String.Compare(t[piviot].value, setting, false, CultureInfo.InvariantCulture);
                    if(v == 0)
                        return t[piviot].slot; // Found it
                    else if(v < 0) 
                        l = piviot + 1;
                    else
                        r = piviot - 1;

                    if(l > r) return -1; // Not here
                }

            }
            
            private static Entry[] Table()
            {
                if(_table == null) {
                    int size = OldNames.Length;
                    Entry[] newTable = new Entry[size];
                    for(int i = 0; i < size; i++) {
                        newTable[i].value = OldNames[i];
                        newTable[i].slot  = (int) Location[i];
                    }
                    Interlocked.CompareExchange(ref _table, (Object) newTable, (Object) null);
                }
                
                if(_table == null)
                    throw new NullReferenceException();
                
                return (Entry[]) _table;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\appdomainattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** File: AppDomainAttributes
**
** Author: 
**
** Purpose: For AppDomain-related custom attributes.
**
** Date: July, 2000
**
=============================================================================*/

namespace System {

    /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimization"]/*' />
    [Serializable()]
    public enum LoaderOptimization 
    {
        /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimization.NotSpecified"]/*' />
        NotSpecified            = 0,
        /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimization.SingleDomain"]/*' />
        SingleDomain            = 1,
        /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimization.MultiDomain"]/*' />
        MultiDomain             = 2,
        /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimization.MultiDomainHost"]/*' />
        MultiDomainHost         = 3,

        DomainMask              = 3,

        DisallowBindings        = 4
           
    }

    /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimizationAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Method)]  
    public sealed class LoaderOptimizationAttribute : Attribute
    {
        internal byte _val;

        /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimizationAttribute.LoaderOptimizationAttribute"]/*' />
        public LoaderOptimizationAttribute(byte value)
        {
            _val = value;
        }
        /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimizationAttribute.LoaderOptimizationAttribute1"]/*' />
        public LoaderOptimizationAttribute(LoaderOptimization value)
        {
            _val = (byte) value;
        }
        /// <include file='doc\AppDomainAttributes.uex' path='docs/doc[@for="LoaderOptimizationAttribute.Value"]/*' />
        public LoaderOptimization Value 
        {  get {return (LoaderOptimization) _val;} }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\accessexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// AccessException
// Thrown when we try accessing a member that we cannot
// access, due to it being removed, private or something similar.
////////////////////////////////////////////////////////////////////////////////

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    // The AccessException is thrown when trying to access a class
    // member fails.
    // 
    /// <include file='doc\AccessException.uex' path='docs/doc[@for="AccessException"]/*' />
    [Serializable()] public class AccessException : SystemException {
    	
        // Creates a new AccessException with its message string set to
        // the empty string, its HRESULT set to COR_E_MEMBERACCESS, 
        // and its ExceptionInfo reference set to null. 
    	/// <include file='doc\AccessException.uex' path='docs/doc[@for="AccessException.AccessException"]/*' />
    	public AccessException() 
            : base(Environment.GetResourceString("Arg_AccessException")) {
    		SetErrorCode(__HResults.COR_E_MEMBERACCESS);
        }
    	
        // Creates a new AccessException with its message string set to
        // message, its HRESULT set to COR_E_ACCESS, 
        // and its ExceptionInfo reference set to null. 
        // 
        /// <include file='doc\AccessException.uex' path='docs/doc[@for="AccessException.AccessException1"]/*' />
        public AccessException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_MEMBERACCESS);
        }
    	
        /// <include file='doc\AccessException.uex' path='docs/doc[@for="AccessException.AccessException2"]/*' />
        public AccessException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_MEMBERACCESS);
        }

        /// <include file='doc\AccessException.uex' path='docs/doc[@for="AccessException.AccessException3"]/*' />
        protected AccessException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\appdomainunloadinprogressexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: AppDomainUnloadInProgressException
**
** Author: Jennifer Hamilton (jenh)
**
** Purpose: Exception class for attempt unload multiple AppDomains 
**		 	simultaneously
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {

	using System.Runtime.Serialization;

    /// <include file='doc\AppDomainUnloadInProgressException.uex' path='docs/doc[@for="AppDomainUnloadInProgressException"]/*' />
    [Serializable()] public class AppDomainUnloadInProgressException : SystemException {
        /// <include file='doc\AppDomainUnloadInProgressException.uex' path='docs/doc[@for="AppDomainUnloadInProgressException.AppDomainUnloadInProgressException"]/*' />
        public AppDomainUnloadInProgressException() 
            : base(Environment.GetResourceString("Arg_CannotUnloadAppDomainException")) {
    		SetErrorCode(__HResults.COR_E_CANNOTUNLOADAPPDOMAIN);
        }
    
        /// <include file='doc\AppDomainUnloadInProgressException.uex' path='docs/doc[@for="AppDomainUnloadInProgressException.AppDomainUnloadInProgressException1"]/*' />
        public AppDomainUnloadInProgressException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_CANNOTUNLOADAPPDOMAIN);
        }
    
        /// <include file='doc\AppDomainUnloadInProgressException.uex' path='docs/doc[@for="AppDomainUnloadInProgressException.AppDomainUnloadInProgressException2"]/*' />
        public AppDomainUnloadInProgressException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_CANNOTUNLOADAPPDOMAIN);
        }

        //
        // This constructor is required for serialization
        //
        /// <include file='doc\AppDomainUnloadInProgressException.uex' path='docs/doc[@for="AppDomainUnloadInProgressException.AppDomainUnloadInProgressException3"]/*' />
        protected AppDomainUnloadInProgressException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\appdomainunloadedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: AppDomainUnloadedException
**
** Author: Jennifer Hamilton (jenh)
**
** Purpose: Exception class for attempt to access an unloaded AppDomain
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {

	using System.Runtime.Serialization;

    /// <include file='doc\AppDomainUnloadedException.uex' path='docs/doc[@for="AppDomainUnloadedException"]/*' />
    [Serializable()] public class AppDomainUnloadedException : SystemException {
        /// <include file='doc\AppDomainUnloadedException.uex' path='docs/doc[@for="AppDomainUnloadedException.AppDomainUnloadedException"]/*' />
        public AppDomainUnloadedException() 
            : base(Environment.GetResourceString("Arg_AppDomainUnloadedException")) {
    		SetErrorCode(__HResults.COR_E_APPDOMAINUNLOADED);
        }
    
        /// <include file='doc\AppDomainUnloadedException.uex' path='docs/doc[@for="AppDomainUnloadedException.AppDomainUnloadedException1"]/*' />
        public AppDomainUnloadedException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_APPDOMAINUNLOADED);
        }
    
        /// <include file='doc\AppDomainUnloadedException.uex' path='docs/doc[@for="AppDomainUnloadedException.AppDomainUnloadedException2"]/*' />
        public AppDomainUnloadedException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_APPDOMAINUNLOADED);
        }

        //
        //This constructor is required for serialization.
        //
        /// <include file='doc\AppDomainUnloadedException.uex' path='docs/doc[@for="AppDomainUnloadedException.AppDomainUnloadedException3"]/*' />
        protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\applicationexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ApplicationException
**
** Author: 
**
** Purpose: The base class for all "less serious" exceptions that must be
**          declared or caught.
**
** Date: March 11, 1998
**
=============================================================================*/

namespace System {
    
	using System.Runtime.Serialization;
    // The ApplicationException is the base class for nonfatal, 
    // application errors that occur.  These exceptions are generated 
    // (i.e., thrown) by an application, not the Runtime. Applications that need 
    // to create their own exceptions do so by extending this class. 
    // ApplicationException extends but adds no new functionality to 
    // RecoverableException.
    // 
    /// <include file='doc\ApplicationException.uex' path='docs/doc[@for="ApplicationException"]/*' />
    [Serializable()] public class ApplicationException : Exception {
    	
        // Creates a new ApplicationException with its message string set to
        // the empty string, its HRESULT set to COR_E_APPLICATION, 
        // and its ExceptionInfo reference set to null. 
        /// <include file='doc\ApplicationException.uex' path='docs/doc[@for="ApplicationException.ApplicationException"]/*' />
        public ApplicationException() 
            : base(Environment.GetResourceString("Arg_ApplicationException")) {
    		SetErrorCode(__HResults.COR_E_APPLICATION);
        }
    	
        // Creates a new ApplicationException with its message string set to
        // message, its HRESULT set to COR_E_APPLICATION, 
        // and its ExceptionInfo reference set to null. 
        // 
        /// <include file='doc\ApplicationException.uex' path='docs/doc[@for="ApplicationException.ApplicationException1"]/*' />
        public ApplicationException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_APPLICATION);
        }
    	
        /// <include file='doc\ApplicationException.uex' path='docs/doc[@for="ApplicationException.ApplicationException2"]/*' />
        public ApplicationException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_APPLICATION);
        }

        /// <include file='doc\ApplicationException.uex' path='docs/doc[@for="ApplicationException.ApplicationException3"]/*' />
        protected ApplicationException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\activator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Activator is an object that contains the Activation (CreateInstance/New) 
//  methods for late bound support.
//
// Author: darylo,craigsi,taruna
// Date: March 2000
//
namespace System {

    using System;
    using System.Reflection;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Activation;
    using Message = System.Runtime.Remoting.Messaging.Message;
    using CultureInfo = System.Globalization.CultureInfo;
    using Evidence = System.Security.Policy.Evidence;
    using StackCrawlMark = System.Threading.StackCrawlMark;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using AssemblyHashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm;

    // Only statics, does not need to be marked with the serializable attribute
    /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator"]/*' />
    public sealed class Activator {

        internal const int LookupMask                 = 0x000000FF;
        internal const BindingFlags ConLookup         = (BindingFlags) (BindingFlags.Instance | BindingFlags.Public);
        internal const BindingFlags ConstructorDefault= BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance;

        // This class only contains statics, so hide the worthless constructor
        private Activator()
        {
        }

        // CreateInstance
        // The following methods will create a new instance of an Object
        // Full Binding Support
        // For all of these methods we need to get the underlying RuntimeType and
        //  call the Impl version.
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance"]/*' />
        static public Object CreateInstance(Type type,
                                            BindingFlags bindingAttr,
                                            Binder binder,
                                            Object[] args,
                                            CultureInfo culture) 
        {
            return CreateInstance(type, bindingAttr, binder, args, culture, null);
        }

        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance1"]/*' />
        static public Object CreateInstance(Type type,
                                            BindingFlags bindingAttr,
                                            Binder binder,
                                            Object[] args,
                                            CultureInfo culture,
                                            Object[] activationAttributes)
        {
            if (type == null)
                throw new ArgumentNullException("type");

            if (type is System.Reflection.Emit.TypeBuilder)
                throw new NotSupportedException(Environment.GetResourceString( "NotSupported_CreateInstanceWithTypeBuilder" ));

            // If they didn't specify a lookup, then we will provide the default lookup.
            if ((bindingAttr & (BindingFlags) LookupMask) == 0)
                bindingAttr |= Activator.ConstructorDefault;

            if (activationAttributes != null && activationAttributes.Length > 0){
                // If type does not derive from MBR
                // throw notsupportedexception
                if(type.IsMarshalByRef){
                    // The fix below is preventative.
                    //
                    if(!(type.IsContextful)){
                        if(activationAttributes.Length > 1 || !(activationAttributes[0] is UrlAttribute))
                           throw new NotSupportedException(Environment.GetResourceString("NotSupported_NonUrlAttrOnMBR"));
                    }
                }
                else
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_ActivAttrOnNonMBR" ));
            }
                               
            try {
                RuntimeType rt = (RuntimeType) type.UnderlyingSystemType;
                return rt.CreateInstanceImpl(bindingAttr,binder,args,culture,activationAttributes);
            }
            catch (InvalidCastException) {
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"type");
            }
        }

        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance2"]/*' />
        static public Object CreateInstance(Type type, Object[] args)
        {
            return CreateInstance(type,
                                  Activator.ConstructorDefault,
                                  null,
                                  args,
                                  null,
                                  null);
        }

        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance3"]/*' />
        static public Object CreateInstance(Type type,
                                            Object[] args,
                                            Object[] activationAttributes)
        {
             return CreateInstance(type,
                                   Activator.ConstructorDefault,
                                   null,
                                   args,
                                   null,
                                   activationAttributes);
        }
        
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance4"]/*' />
        static public Object CreateInstance(Type type)
        {
            return Activator.CreateInstance(type, false);
        }

        /*
         * Create an instance using the name of type and the assembly where it exists. This allows
         * types to be created remotely without having to load the type locally.
         */

        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance5"]/*' />
        static public ObjectHandle CreateInstance(String assemblyName,
                                                  String typeName)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return CreateInstance(assemblyName,
                                  typeName, 
                                  false,
                                  Activator.ConstructorDefault,
                                  null,
                                  null,
                                  null,
                                  null,
                                  null,
                                  ref stackMark);
        }
                                                  
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance6"]/*' />
        static public ObjectHandle CreateInstance(String assemblyName,
                                                  String typeName,
                                                  Object[] activationAttributes)
                                                  
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return CreateInstance(assemblyName,
                                  typeName, 
                                  false,
                                  Activator.ConstructorDefault,
                                  null,
                                  null,
                                  null,
                                  activationAttributes,
                                  null,
                                  ref stackMark);
        }
            
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance8"]/*' />
        static public Object CreateInstance(Type type, bool nonPublic)
        {
            if (type == null)
                throw new ArgumentNullException("type");

            try {
                RuntimeType rt = (RuntimeType) type.UnderlyingSystemType;
                return rt.CreateInstanceImpl(!nonPublic);
            }
            catch (InvalidCastException) {
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"type");
            }
        }

        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstanceFrom"]/*' />
        static public ObjectHandle CreateInstanceFrom(String assemblyFile,
                                                      String typeName)
                                         
        {
            return CreateInstanceFrom(assemblyFile, typeName, null);
        }

        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstanceFrom1"]/*' />
        static public ObjectHandle CreateInstanceFrom(String assemblyFile,
                                                      String typeName,
                                                      Object[] activationAttributes)
                                         
        {
            return CreateInstanceFrom(assemblyFile,
                                      typeName, 
                                      false,
                                      Activator.ConstructorDefault,
                                      null,
                                      null,
                                      null,
                                      activationAttributes,
                                      null);
        }
                                  
                                  
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstance7"]/*' />
        static public ObjectHandle CreateInstance(String assemblyName, 
                                                  String typeName, 
                                                  bool ignoreCase,
                                                  BindingFlags bindingAttr, 
                                                  Binder binder,
                                                  Object[] args,
                                                  CultureInfo culture,
                                                  Object[] activationAttributes,
                                                  Evidence securityInfo)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return CreateInstance(assemblyName,
                                  typeName,
                                  ignoreCase,
                                  bindingAttr,
                                  binder,
                                  args,
                                  culture,
                                  activationAttributes,
                                  securityInfo,
                                  ref stackMark);
        }

        static internal ObjectHandle CreateInstance(String assemblyName, 
                                                    String typeName, 
                                                    bool ignoreCase,
                                                    BindingFlags bindingAttr, 
                                                    Binder binder,
                                                    Object[] args,
                                                    CultureInfo culture,
                                                    Object[] activationAttributes,
                                                    Evidence securityInfo,
                                                    ref StackCrawlMark stackMark)
        {
            Assembly assembly;
            if(assemblyName == null)
                assembly = Assembly.nGetExecutingAssembly(ref stackMark);
            else
                assembly = Assembly.InternalLoad(assemblyName, securityInfo, ref stackMark);

            Log(assembly != null, "CreateInstance:: ", "Loaded " + assembly.FullName, "Failed to Load: " + assemblyName);
            if(assembly == null) return null;

            Type t = assembly.GetTypeInternal(typeName, true, ignoreCase, false);
            
            Object o = Activator.CreateInstance(t,
                                                bindingAttr,
                                                binder,
                                                args,
                                                culture,
                                                activationAttributes);

            Log(o != null, "CreateInstance:: ", "Created Instance of class " + typeName, "Failed to create instance of class " + typeName);
            if(o == null)
                return null;
            else {
                ObjectHandle Handle = new ObjectHandle(o);
                return Handle;
            }
        }

        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateInstanceFrom2"]/*' />
        static public ObjectHandle CreateInstanceFrom(String assemblyFile,
                                                      String typeName, 
                                                      bool ignoreCase,
                                                      BindingFlags bindingAttr, 
                                                      Binder binder,
                                                      Object[] args,
                                                      CultureInfo culture,
                                                      Object[] activationAttributes,
                                                      Evidence securityInfo)
                                               
        {
            Assembly assembly = Assembly.LoadFrom(assemblyFile, securityInfo);
            Type t = assembly.GetTypeInternal(typeName, true, ignoreCase, false);
            
            Object o = Activator.CreateInstance(t,
                                                bindingAttr,
                                                binder,
                                                args,
                                                culture,
                                                activationAttributes);

            Log(o != null, "CreateInstanceFrom:: ", "Created Instance of class " + typeName, "Failed to create instance of class " + typeName);
            if(o == null)
                return null;
            else {
                ObjectHandle Handle = new ObjectHandle(o);
                return Handle;
            }
        }
        
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateComInstanceFrom"]/*' />
        public static ObjectHandle CreateComInstanceFrom(String assemblyName,
                                                         String typeName)
        {
            return CreateComInstanceFrom(assemblyName,
                                         typeName,
                                         null,
                                         AssemblyHashAlgorithm.None);
                                         
        }
                                         
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.CreateComInstanceFrom1"]/*' />
        public static ObjectHandle CreateComInstanceFrom(String assemblyName,
                                                         String typeName,
                                                         byte[] hashValue, 
                                                         AssemblyHashAlgorithm hashAlgorithm)
                                         
        {
            // jit does not check for that, so we should do it ...
            Assembly assembly = Assembly.LoadFrom(assemblyName, null, hashValue, hashAlgorithm);

            Type t = assembly.GetTypeInternal(typeName, true, false, false);
            Object[] Attr = t.GetCustomAttributes(typeof(ComVisibleAttribute),false);
            if (Attr.Length > 0)
            {
                if (((ComVisibleAttribute)Attr[0]).Value == false)
                    throw new TypeLoadException(Environment.GetResourceString( "Argument_TypeMustBeVisibleFromCom" ));
            }

            Log(assembly != null, "CreateInstance:: ", "Loaded " + assembly.FullName, "Failed to Load: " + assemblyName);

            if(assembly == null) return null;

  
            Object o = Activator.CreateInstance(t,
                                                Activator.ConstructorDefault,
                                                null,
                                                null,
                                                null,
                                                null);

            Log(o != null, "CreateInstance:: ", "Created Instance of class " + typeName, "Failed to create instance of class " + typeName);
            if(o == null)
                return null;
            else {
                ObjectHandle Handle = new ObjectHandle(o);
                return Handle;
            }
        }
                                  

        //  This method is a helper method and delegates to the remoting 
        //  services to do the actual work. 
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.GetObject"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.RemotingConfiguration)]    
        static public Object GetObject(Type type, String url)
        {
            return GetObject(type, url, null);
        }
        
        //  This method is a helper method and delegates to the remoting 
        //  services to do the actual work. 
        /// <include file='doc\Activator.uex' path='docs/doc[@for="Activator.GetObject1"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.RemotingConfiguration)]    
        static public Object GetObject(Type type, String url, Object state)
        {
            if (type == null)
                throw new ArgumentNullException("type");
            return RemotingServices.Connect(type, url, state);
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        private static void Log(bool test, string title, string success, string failure)
        {
            if(test)
                Message.DebugOut(title+success+"\n");
            else
                Message.DebugOut(title+failure+"\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\argumentnullexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ArgumentNullException
**
** Author: Brian Grunkemeyer
**
** Purpose: Exception class for null arguments to a method.
**
** Date: April 28, 1999
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
	using System.Runtime.Remoting;
    // The ArgumentException is thrown when an argument 
    // is null when it shouldn't be.
    // 
    /// <include file='doc\ArgumentNullException.uex' path='docs/doc[@for="ArgumentNullException"]/*' />
    [Serializable] public class ArgumentNullException : ArgumentException
    {
    	private static String _nullMessage = null;
    	
        private static String NullMessage {
            get { 
                // Don't bother with synchronization here.  A duplicated string 
                // is not a major problem.
                if (_nullMessage == null)
                    _nullMessage = Environment.GetResourceString("ArgumentNull_Generic");
                return _nullMessage;
            }
        }
            
        // Creates a new ArgumentNullException with its message 
        // string set to a default message explaining an argument was null.
        /// <include file='doc\ArgumentNullException.uex' path='docs/doc[@for="ArgumentNullException.ArgumentNullException"]/*' />
        public ArgumentNullException() 
            : base(NullMessage) {
    		// Use E_POINTER - COM used that for null pointers.  Description is "invalid pointer"
    		SetErrorCode(__HResults.E_POINTER);
        }
    	
        /// <include file='doc\ArgumentNullException.uex' path='docs/doc[@for="ArgumentNullException.ArgumentNullException1"]/*' />
        public ArgumentNullException(String paramName) 
            : base(NullMessage, paramName) {
    		SetErrorCode(__HResults.E_POINTER);
        }
    	
        /// <include file='doc\ArgumentNullException.uex' path='docs/doc[@for="ArgumentNullException.ArgumentNullException2"]/*' />
        public ArgumentNullException(String paramName, String message) 
            : base(message, paramName) {
    		SetErrorCode(__HResults.E_POINTER);
     
        }

        /// <include file='doc\ArgumentNullException.uex' path='docs/doc[@for="ArgumentNullException.ArgumentNullException3"]/*' />
        protected ArgumentNullException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\array.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Array
**
** Purpose: Base class which can be used to access any array
**
===========================================================*/
namespace System {

    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;

    /// <include file='doc\Array.uex' path='docs/doc[@for="Array"]/*' />
    [Serializable]
    public abstract class Array : ICloneable, IList
    {
        /// <internalonly/>
        private Array() {}

        // Create instance will create an array
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.CreateInstance"]/*' />
        public static Array CreateInstance(Type elementType, int length)
        {
            if (elementType == null)
                throw new ArgumentNullException("elementType");
            RuntimeType t = elementType.UnderlyingSystemType as RuntimeType;
            if (t == null)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            if (length < 0)
                throw new ArgumentOutOfRangeException("length", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            return InternalCreate(t,1,length,0,0);
        }
        
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.CreateInstance1"]/*' />
        public static Array CreateInstance(Type elementType, int length1, int length2)
        {
            if (elementType == null)
                throw new ArgumentNullException("elementType");
            RuntimeType t = elementType.UnderlyingSystemType as RuntimeType;
            if (t == null)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            if (length1 < 0 || length2 < 0)
                throw new ArgumentOutOfRangeException((length1<0 ? "length1" : "length2"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            return InternalCreate(t,2,length1,length2,0);
        }
        
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.CreateInstance2"]/*' />
        public static Array CreateInstance(Type elementType, int length1, int length2, int length3)
        {
            if (elementType == null)
                throw new ArgumentNullException("elementType");
            RuntimeType t = elementType.UnderlyingSystemType as RuntimeType;
            if (t == null)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            if (length1 < 0 || length2 < 0 || length3 < 0) {
                String arg = "length1";
                if (length2 < 0) arg = "length2";
                if (length3 < 0) arg = "length3";
                throw new ArgumentOutOfRangeException(arg, Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            return InternalCreate(t,3,length1,length2,length3);
        }
        
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.CreateInstance3"]/*' />
        public static Array CreateInstance(Type elementType, params int[] lengths)
        {
            if (elementType == null)
                throw new ArgumentNullException("elementType");
            RuntimeType t = elementType.UnderlyingSystemType as RuntimeType;
            if (t == null)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            if (lengths == null)
                throw new ArgumentNullException("lengths");
            for (int i=0;i<lengths.Length;i++)
                if (lengths[i] < 0)
                    throw new ArgumentOutOfRangeException("lengths["+i+']', Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (lengths.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_NeedAtLeast1Rank"));
            
            return InternalCreateEx(t,lengths,null);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.CreateInstance5"]/*' />        
        public static Array CreateInstance(Type elementType, params long[] lengths)
        {
            int[] intLengths = new int[lengths.Length];

            for (int i = 0; i < lengths.Length; ++i) 
            {
                long len = lengths[i];
                if (len > Int32.MaxValue || len < Int32.MinValue) 
                    throw new ArgumentOutOfRangeException("len", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
                intLengths[i] = (int) len;
            }

            return Array.CreateInstance(elementType, intLengths);
        }

        
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.CreateInstance4"]/*' />
        public static Array CreateInstance(Type elementType, int[] lengths,int[] lowerBounds)
        {
            if (elementType == null)
                throw new ArgumentNullException("elementType");
            RuntimeType t = elementType.UnderlyingSystemType as RuntimeType;
            if (t == null)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            if (lengths == null)
                throw new ArgumentNullException("lengths");
            if (lowerBounds == null)
                throw new ArgumentNullException("lowerBounds");
            for (int i=0;i<lengths.Length;i++)
                if (lengths[i] < 0)
                    throw new ArgumentOutOfRangeException("lengths["+i+']', Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (lengths.Length != lowerBounds.Length)
                throw new ArgumentException(Environment.GetResourceString("Arg_RanksAndBounds"));
            if (lengths.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_NeedAtLeast1Rank"));
            
            return InternalCreateEx(t,lengths,lowerBounds);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Array InternalCreate(RuntimeType elementType,int rank,int length1,int length2, int length3);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Array InternalCreateEx(RuntimeType element_type,int[] lengths,int[] lowerBounds);
        
        // Copies length elements from sourceArray, starting at index 0, to
        // destinationArray, starting at index 0.
        //
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Copy"]/*' />
        public static void Copy(Array sourceArray, Array destinationArray, int length)
        {
            if (sourceArray == null)
                throw new ArgumentNullException("sourceArray");
            if (destinationArray == null)
                throw new ArgumentNullException("destinationArray");
            Copy(sourceArray, sourceArray.GetLowerBound(0), destinationArray, destinationArray.GetLowerBound(0), length);
        }
    
        // Copies length elements from sourceArray, starting at sourceIndex, to
        // destinationArray, starting at destinationIndex.
        //
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Copy1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Copy2"]/*' />
        public static void Copy(Array sourceArray, Array destinationArray, long length)
        {
            if (length > Int32.MaxValue || length < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("length", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));

            Array.Copy(sourceArray, destinationArray, (int) length);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Copy3"]/*' />
        public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length)
        {
            if (sourceIndex > Int32.MaxValue || sourceIndex < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("sourceIndex", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            if (destinationIndex > Int32.MaxValue || destinationIndex < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("destinationIndex", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            if (length > Int32.MaxValue || length < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("length", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));

            Array.Copy(sourceArray, (int) sourceIndex, destinationArray, (int) destinationIndex, (int) length);
        }

    
        // Sets length elements in array to 0 (or null for Object arrays), starting
        // at index.
        //
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Clear"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void Clear(Array array, int index, int length);
        
        // The various Get values...
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetValue"]/*' />
        public Object GetValue(params int[] indices)
        {
            if (indices == null)
                throw new ArgumentNullException("indices");
            if (Rank != indices.Length)
                throw new ArgumentException(Environment.GetResourceString("Arg_RankIndices"));
            return InternalGetValueEx(indices);
        }
    
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetValue1"]/*' />
        public Object GetValue(int index)
        {
            if (Rank != 1)
                throw new ArgumentException(Environment.GetResourceString("Arg_Need1DArray"));
            return InternalGetValue(index,0,0);
        }
    
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetValue2"]/*' />
        public Object GetValue(int index1, int index2)
        {
            if (Rank != 2)
                throw new ArgumentException(Environment.GetResourceString("Arg_Need2DArray"));
            return InternalGetValue(index1,index2,0);
        }
    
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetValue3"]/*' />
        public Object GetValue(int index1, int index2, int index3)
        {
            if (Rank != 3)
                throw new ArgumentException(Environment.GetResourceString("Arg_Need3DArray"));
            return InternalGetValue(index1,index2,index3);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetValue4"]/*' />
        [ComVisible(false)]       
        public Object GetValue(long index)
        {
            if (index > Int32.MaxValue || index < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));

            return this.GetValue((int) index);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetValue5"]/*' />
        [ComVisible(false)]
        public Object GetValue(long index1, long index2)
        {
            if (index1 > Int32.MaxValue || index1 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index1", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            if (index2 > Int32.MaxValue || index2 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index2", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));

            return this.GetValue((int) index1, (int) index2);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetValue6"]/*' />
        [ComVisible(false)]
        public Object GetValue(long index1, long index2, long index3)
        {
            if (index1 > Int32.MaxValue || index1 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index1", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            if (index2 > Int32.MaxValue || index2 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index2", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            if (index3 > Int32.MaxValue || index3 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index3", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            
            return this.GetValue((int) index1, (int) index2, (int) index3);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetValue7"]/*' />
        [ComVisible(false)]
        public Object GetValue(params long[] indices)
        {
            int[] intIndices = new int[indices.Length];

            for (int i = 0; i < indices.Length; ++i) 
            {
                long index = indices[i];
                if (index > Int32.MaxValue || index < Int32.MinValue) 
                    throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
                intIndices[i] = (int) index;
            }

            return this.GetValue(intIndices);
        }

        
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SetValue"]/*' />
        public void SetValue(Object value,int index)
        {
            if (Rank != 1)
                throw new ArgumentException(Environment.GetResourceString("Arg_Need1DArray"));
            InternalSetValue(value,index,0,0);
        }
    
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SetValue1"]/*' />
        public void SetValue(Object value,int index1, int index2)
        {
            if (Rank != 2)
                throw new ArgumentException(Environment.GetResourceString("Arg_Need2DArray"));
            InternalSetValue(value,index1,index2,0);
        }
    
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SetValue2"]/*' />
        public void SetValue(Object value,int index1, int index2, int index3)
        {
            if (Rank != 3)
                throw new ArgumentException(Environment.GetResourceString("Arg_Need3DArray"));
            InternalSetValue(value,index1,index2,index3);
        }
        
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SetValue3"]/*' />
        public void SetValue(Object value,params int[] indices)
        {
            if (indices == null)
                throw new ArgumentNullException("indices");
            if (Rank != indices.Length)
                throw new ArgumentException(Environment.GetResourceString("Arg_RankIndices"));
            InternalSetValueEx(value,indices);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SetValue4"]/*' />
        [ComVisible(false)]
        public void SetValue(Object value, long index)
        {
            if (index > Int32.MaxValue || index < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));

            this.SetValue(value, (int) index);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SetValue5"]/*' />
        [ComVisible(false)]
        public void SetValue(Object value, long index1, long index2)
        {
            if (index1 > Int32.MaxValue || index1 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index1", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            if (index2 > Int32.MaxValue || index2 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index2", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));

            this.SetValue(value, (int) index1, (int) index2);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SetValue6"]/*' />
        [ComVisible(false)]
        public void SetValue(Object value, long index1, long index2, long index3)
        {
            if (index1 > Int32.MaxValue || index1 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index1", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            if (index2 > Int32.MaxValue || index2 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index2", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
            if (index3 > Int32.MaxValue || index3 < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index3", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));

            this.SetValue(value, (int) index1, (int) index2, (int) index3);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SetValue7"]/*' />
        [ComVisible(false)]
        public void SetValue(Object value, params long[] indices)
        {
            int[] intIndices = new int[indices.Length];

            for (int i = 0; i < indices.Length; ++i) 
            {
                long index = indices[i];
                if (index > Int32.MaxValue || index < Int32.MinValue) 
                    throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));
                intIndices[i] = (int) index;
            }

            this.SetValue(value, intIndices);
        }

        
        // This is the set of native routines that implement the real
        //  Get/Set Value.  The arguments have been verified that they exist
        //  before we get to this point.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Object InternalGetValue(int index1, int index2, int index3);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Object InternalGetValueEx(int[] indices);    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void InternalSetValue(Object value,int index1, int index2, int index3);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void InternalSetValueEx(Object value,int[] indices);
    
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int GetLengthNative();
          
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Length"]/*' />
        public int Length {
            get { return GetLengthNative(); }
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.LongLength"]/*' />
        [ComVisible(false)]
        public long LongLength {
            get { return Length; }
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetLength"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern int GetLength(int dimension);

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetLongLength"]/*' />
        [ComVisible(false)]
        public long GetLongLength(int dimension) {
            return GetLength(dimension);
        }


        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int GetRankNative();

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Rank"]/*' />
        public int Rank {
            get { return GetRankNative(); }
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetUpperBound"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern int GetUpperBound(int dimension);
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetLowerBound"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern int GetLowerBound(int dimension);
        
        // Number of elements in the Array.
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.ICollection.Count"]/*' />
        int ICollection.Count
        { get { return Length; } }

    
        // Returns an object appropriate for synchronizing access to this 
        // Array.
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.SyncRoot"]/*' />
        public virtual Object SyncRoot
        { get { return this; } }
        
        // Is this Array read-only?
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IsReadOnly"]/*' />
        public virtual bool IsReadOnly
        { get { return false; } }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IsFixedSize"]/*' />
        public virtual bool IsFixedSize {
            get { return true; }
        }
    
        // Is this Array synchronized (i.e., thread-safe)?  If you want a synchronized
        // collection, you can use SyncRoot as an object to synchronize your 
        // collection with.  You could also call GetSynchronized() 
        // to get a synchronized wrapper around the Array.
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IsSynchronized"]/*' />
        public virtual bool IsSynchronized
        { get { return false; } }


        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IList.this"]/*' />
        Object IList.this[int index] {
            get { return GetValue(index); }
            set { SetValue(value, index); }
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IList.Add"]/*' />
        int IList.Add(Object value)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IList.Contains"]/*' />
        bool IList.Contains(Object value)
        {
            return Array.IndexOf(this, value) >= this.GetLowerBound(0);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IList.Clear"]/*' />
        void IList.Clear()
        {
            Array.Clear(this, 0, this.Length);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IList.IndexOf"]/*' />
        int IList.IndexOf(Object value)
        {
            return Array.IndexOf(this, value);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IList.Insert"]/*' />
        void IList.Insert(int index, Object value)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IList.Remove"]/*' />
        void IList.Remove(Object value)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IList.RemoveAt"]/*' />
        void IList.RemoveAt(int index)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
        }

        // Make a new array which is a deep copy of the original array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Clone"]/*' />
        public virtual Object Clone()
        {
            return MemberwiseClone();
        }
    
        // Searches an array for a given element using a binary search algorithm.
        // Elements of the array are compared to the search value using the
        // IComparable interface, which must be implemented by all elements
        // of the array and the given search value. This method assumes that the
        // array is already sorted according to the IComparable interface;
        // if this is not the case, the result will be incorrect.
        //
        // The method returns the index of the given value in the array. If the
        // array does not contain the given value, the method returns a negative
        // integer. The bitwise complement operator (~) can be applied to a
        // negative result to produce the index of the first element (if any) that
        // is larger than the given search value.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.BinarySearch"]/*' />
        public static int BinarySearch(Array array, Object value) {
            if (array==null)
                throw new ArgumentNullException("array");
            int lb = array.GetLowerBound(0);
            return BinarySearch(array, lb, array.Length, value, null);
        }
        
        // Searches a section of an array for a given element using a binary search
        // algorithm. Elements of the array are compared to the search value using
        // the IComparable interface, which must be implemented by all
        // elements of the array and the given search value. This method assumes
        // that the array is already sorted according to the IComparable
        // interface; if this is not the case, the result will be incorrect.
        //
        // The method returns the index of the given value in the array. If the
        // array does not contain the given value, the method returns a negative
        // integer. The bitwise complement operator (~) can be applied to a
        // negative result to produce the index of the first element (if any) that
        // is larger than the given search value.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.BinarySearch1"]/*' />
        public static int BinarySearch(Array array, int index, int length, Object value) {
            return BinarySearch(array, index, length, value, null);
        }
        
        // Searches an array for a given element using a binary search algorithm.
        // Elements of the array are compared to the search value using the given
        // IComparer interface. If comparer is null, elements of the
        // array are compared to the search value using the IComparable
        // interface, which in that case must be implemented by all elements of the
        // array and the given search value. This method assumes that the array is
        // already sorted; if this is not the case, the result will be incorrect.
        // 
        // The method returns the index of the given value in the array. If the
        // array does not contain the given value, the method returns a negative
        // integer. The bitwise complement operator (~) can be applied to a
        // negative result to produce the index of the first element (if any) that
        // is larger than the given search value.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.BinarySearch2"]/*' />
        public static int BinarySearch(Array array, Object value, IComparer comparer) {
            if (array==null)
                throw new ArgumentNullException("array");
            int lb = array.GetLowerBound(0);
            return BinarySearch(array, lb, array.Length, value, comparer);
        }
    
        // Searches a section of an array for a given element using a binary search
        // algorithm. Elements of the array are compared to the search value using
        // the given IComparer interface. If comparer is null,
        // elements of the array are compared to the search value using the
        // IComparable interface, which in that case must be implemented by
        // all elements of the array and the given search value. This method
        // assumes that the array is already sorted; if this is not the case, the
        // result will be incorrect.
        // 
        // The method returns the index of the given value in the array. If the
        // array does not contain the given value, the method returns a negative
        // integer. The bitwise complement operator (~) can be applied to a
        // negative result to produce the index of the first element (if any) that
        // is larger than the given search value.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.BinarySearch3"]/*' />
        public static int BinarySearch(Array array, int index, int length, Object value, IComparer comparer) {
            if (array==null) 
                throw new ArgumentNullException("array");
            int lb = array.GetLowerBound(0);
            if (index < lb || length < 0)
                throw new ArgumentOutOfRangeException((index<lb ? "index" : "length"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - index < length)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            if (array.Rank != 1)
                throw new RankException(Environment.GetResourceString("Rank_MultiDimNotSupported"));
            
            if (comparer == null) comparer = Comparer.Default;
            if (comparer == Comparer.Default) {
                int retval;
                int r = TrySZBinarySearch(array, index, length, value, out retval);
                if (r != 0)
                    return retval;
            }

            int lo = index;
            int hi = index + length - 1;
            Object[] objArray = array as Object[];
            if(objArray != null) {
                while (lo <= hi) {
                    int i = (lo + hi) >> 1;
                    int c;
                    try {
                        c = comparer.Compare(objArray[i], value);
                    }
                    catch (Exception e) {
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_IComparerFailed"), e);
                    }
                    if (c == 0) return i;
                    if (c < 0) {
                        lo = i + 1;
                    }
                    else {
                        hi = i - 1;
                    }
                }
            }
            else {
                while (lo <= hi) {
                    int i = (lo + hi) >> 1;
                    int c;
                    try {
                        c = comparer.Compare(array.GetValue(i), value);
                    }
                    catch (Exception e) {
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_IComparerFailed"), e);
                    }
                    if (c == 0) return i;
                    if (c < 0) {
                        lo = i + 1;
                    }
                    else {
                        hi = i - 1;
                    }
                }
            }
            return ~lo;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int TrySZBinarySearch(Array sourceArray, int sourceIndex, int count, Object value, out int retVal);
        
        // CopyTo copies a collection into an Array, starting at a particular
        // index into the array.
        // 
        // This method is to support the ICollection interface, and calls
        // Array.Copy internally.  If you aren't using ICollection explicitly,
        // call Array.Copy to avoid an extra indirection.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.CopyTo"]/*' />
        public virtual void CopyTo(Array array, int index)
        {
            if (array != null && array.Rank != 1)
                    throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
            // Note: Array.Copy throws a RankException and we want a consistent ArgumentException for all the IList CopyTo methods.
            Array.Copy(this, GetLowerBound(0), array, index, Length);
        }

        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.CopyTo1"]/*' />
        [ComVisible(false)]
        public virtual void CopyTo(Array array, long index)
        {
            if (index > Int32.MaxValue || index < Int32.MinValue) 
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_HugeArrayNotSupported"));

            this.CopyTo(array, (int) index);
        }

        
        // GetEnumerator returns an IEnumerator over this Array.  
        // 
        // Currently, only one dimensional arrays are supported.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.GetEnumerator"]/*' />
        public virtual IEnumerator GetEnumerator()
        {
            int lowerBound = GetLowerBound(0);
            if (Rank == 1 && lowerBound == 0)
                return new SZArrayEnumerator(this);
            else
                return new ArrayEnumerator(this, lowerBound, Length);
        }
        
        // Returns the index of the first occurrence of a given value in an array.
        // The array is searched forwards, and the elements of the array are
        // compared to the given value using the Object.Equals method.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IndexOf"]/*' />
        public static int IndexOf(Array array, Object value) {
            if (array==null)
                throw new ArgumentNullException("array");
            int lb = array.GetLowerBound(0);
            return IndexOf(array, value, lb, array.Length);
        }
        
        // Returns the index of the first occurrence of a given value in a range of
        // an array. The array is searched forwards, starting at index
        // startIndex and ending at the last element of the array. The
        // elements of the array are compared to the given value using the
        // Object.Equals method.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IndexOf1"]/*' />
        public static int IndexOf(Array array, Object value, int startIndex) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Array"));
            int lb = array.GetLowerBound(0);
            return IndexOf(array, value, startIndex, array.Length - startIndex + lb);
        }
        
        // Returns the index of the first occurrence of a given value in a range of
        // an array. The array is searched forwards, starting at index
        // startIndex and upto count elements. The
        // elements of the array are compared to the given value using the
        // Object.Equals method.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.IndexOf2"]/*' />
        public static int IndexOf(Array array, Object value, int startIndex, int count) {
            if (array==null)
                throw new ArgumentNullException("array");
            int lb = array.GetLowerBound(0);
            if (startIndex < lb || startIndex > array.Length + lb)
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            if (count < 0 || count > array.Length - startIndex + lb)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));
            if (array.Rank != 1)
                throw new RankException(Environment.GetResourceString("Rank_MultiDimNotSupported"));

            // Try calling a quick native method to handle primitive types.
            int retVal;
            int r = TrySZIndexOf(array, startIndex, count, value, out retVal);
            if (r != 0)
                return retVal;

            Object[] objArray = array as Object[];
            int endIndex = startIndex + count;
            if (objArray != null) {
                if (value == null) {
                    for (int i = startIndex; i < endIndex; i++) {
                        if (objArray[i] == null) return i;
                    }
                }
                else {
                    for (int i = startIndex; i < endIndex; i++) {
                        Object obj = objArray[i];
                        if (obj != null && value.Equals(obj)) return i;
                    }
                }
            }
            else {
                // This is an array of value classes
                BCLDebug.Assert(array.GetType().GetElementType().IsValueType, "array.GetType().GetUnderlyingType().IsValueType");
                if (value==null)
                    return -1;
                for (int i = startIndex; i < endIndex; i++) {
                    Object obj = array.GetValue(i);
                    if (obj != null && value.Equals(obj)) return i;
                }
            }
            // Return one less than the lower bound of the array.  This way,
            // for arrays with a lower bound of -1 we will not return -1 when the
            // item was not found.  And for SZArrays (the vast majority), -1 still
            // works for them.
            return lb-1;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int TrySZIndexOf(Array sourceArray, int sourceIndex, int count, Object value, out int retVal);
        

        // Returns the index of the last occurrence of a given value in an array.
        // The array is searched backwards, and the elements of the array are
        // compared to the given value using the Object.Equals method.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.LastIndexOf"]/*' />
        public static int LastIndexOf(Array array, Object value) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Array"));
            int lb = array.GetLowerBound(0);
            return LastIndexOf(array, value, array.Length - 1 + lb, array.Length);
        }
        
        // Returns the index of the last occurrence of a given value in a range of
        // an array. The array is searched backwards, starting at index
        // startIndex and ending at index 0. The elements of the array are
        // compared to the given value using the Object.Equals method.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.LastIndexOf1"]/*' />
        public static int LastIndexOf(Array array, Object value, int startIndex) {
            if (array == null)
                throw new ArgumentNullException("array");
            int lb = array.GetLowerBound(0);
            return LastIndexOf(array, value, startIndex, startIndex + 1 - lb);
        }
        
        // Returns the index of the last occurrence of a given value in a range of
        // an array. The array is searched backwards, starting at index
        // startIndex and counting uptocount elements. The elements of
        // the array are compared to the given value using the Object.Equals
        // method.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.LastIndexOf2"]/*' />
        public static int LastIndexOf(Array array, Object value, int startIndex, int count) {
            if (array==null)
                throw new ArgumentNullException("array");
            if (array.Length == 0) {
                return -1;
            }
            int lb = array.GetLowerBound(0);
            if (startIndex < lb || startIndex >= array.Length + lb)
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));
            if (count > startIndex - lb + 1)
                throw new ArgumentOutOfRangeException("endIndex", Environment.GetResourceString("ArgumentOutOfRange_EndIndexStartIndex"));
            if (array.Rank != 1)
                throw new RankException(Environment.GetResourceString("Rank_MultiDimNotSupported"));

            // Try calling a quick native method to handle primitive types.
            int retVal;
            int r = TrySZLastIndexOf(array, startIndex, count, value, out retVal);
            if (r != 0)
                return retVal;

            Object[] objArray = array as Object[];
            int endIndex = startIndex - count + 1;
            if (objArray!=null) {
                if (value == null) {
                    for (int i = startIndex; i >= endIndex; i--) {
                        if (objArray[i] == null) return i;
                    }
                }
                else {
                    for (int i = startIndex; i >= endIndex; i--) {
                        Object obj = objArray[i];
                        if (obj != null && value.Equals(obj)) return i;
                    }
                }
            }
            else {
                // This is an array of value classes
                BCLDebug.Assert(array.GetType().GetElementType().IsValueType, "array.GetType().GetUnderlyingType().IsValueType");
                if (value==null)
                    return -1;
                for (int i = startIndex; i >= endIndex; i--) {
                    Object obj = array.GetValue(i);
                    if (obj != null && value.Equals(obj)) return i;
                }
            }
            return lb-1;  // Return lb-1 for arrays with negative lower bounds.
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int TrySZLastIndexOf(Array sourceArray, int sourceIndex, int count, Object value, out int retVal);


        // Reverses all elements of the given array. Following a call to this
        // method, an element previously located at index i will now be
        // located at index length - i - 1, where length is the
        // length of the array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Reverse"]/*' />
        public static void Reverse(Array array) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Array"));
            Reverse(array, array.GetLowerBound(0), array.Length);
        }
        
        // Reverses the elements in a range of an array. Following a call to this
        // method, an element in the range given by index and count
        // which was previously located at index i will now be located at
        // index index + (index + count - i - 1).
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Reverse1"]/*' />
        public static void Reverse(Array array, int index, int length) {
            if (array==null) 
                throw new ArgumentNullException("array");
            if (index < array.GetLowerBound(0) || length < 0)
                throw new ArgumentOutOfRangeException((index<0 ? "index" : "length"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - (index - array.GetLowerBound(0)) < length)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            if (array.Rank != 1)
                throw new RankException(Environment.GetResourceString("Rank_MultiDimNotSupported"));

            bool r = TrySZReverse(array, index, length);
            if (r)
                return;

            int i = index;
            int j = index + length - 1;
            Object[] objArray = array as Object[];
            if (objArray!=null) {
                while (i < j) {
                    Object temp = objArray[i];
                    objArray[i] = objArray[j];
                    objArray[j] = temp;
                    i++;
                    j--;
                }
            }
            else {
                while (i < j) {
                    Object temp = array.GetValue(i);
                    array.SetValue(array.GetValue(j), i);
                    array.SetValue(temp, j);
                    i++;
                    j--;
                }
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool TrySZReverse(Array array, int index, int count);
        
        // Sorts the elements of an array. The sort compares the elements to each
        // other using the IComparable interface, which must be implemented
        // by all elements of the array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Sort"]/*' />
        public static void Sort(Array array) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Array"));
            Sort(array, null, array.GetLowerBound(0), array.Length, null);
        }
    
        // Sorts the elements of two arrays based on the keys in the first array.
        // Elements in the keys array specify the sort keys for
        // corresponding elements in the items array. The sort compares the
        // keys to each other using the IComparable interface, which must be
        // implemented by all elements of the keys array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Sort1"]/*' />
        public static void Sort(Array keys, Array items) {
            if (keys==null)
                throw new ArgumentNullException("keys");
            Sort(keys, items, keys.GetLowerBound(0), keys.Length, null);
        }
        
        // Sorts the elements in a section of an array. The sort compares the
        // elements to each other using the IComparable interface, which
        // must be implemented by all elements in the given section of the array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Sort2"]/*' />
        public static void Sort(Array array, int index, int length) {
            Sort(array, null, index, length, null);
        }
    
        // Sorts the elements in a section of two arrays based on the keys in the
        // first array. Elements in the keys array specify the sort keys for
        // corresponding elements in the items array. The sort compares the
        // keys to each other using the IComparable interface, which must be
        // implemented by all elements of the keys array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Sort3"]/*' />
        public static void Sort(Array keys, Array items, int index, int length) {
            Sort(keys, items, index, length, null);
        }
        
        // Sorts the elements of an array. The sort compares the elements to each
        // other using the given IComparer interface. If comparer is
        // null, the elements are compared to each other using the
        // IComparable interface, which in that case must be implemented by
        // all elements of the array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Sort4"]/*' />
        public static void Sort(Array array, IComparer comparer) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Array"));
            Sort(array, null, array.GetLowerBound(0), array.Length, comparer);
        }
    
        // Sorts the elements of two arrays based on the keys in the first array.
        // Elements in the keys array specify the sort keys for
        // corresponding elements in the items array. The sort compares the
        // keys to each other using the given IComparer interface. If
        // comparer is null, the elements are compared to each other using
        // the IComparable interface, which in that case must be implemented
        // by all elements of the keys array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Sort5"]/*' />
        public static void Sort(Array keys, Array items, IComparer comparer) {
            if (keys==null)
                throw new ArgumentNullException("keys");
            Sort(keys, items, keys.GetLowerBound(0), keys.Length, comparer);
        }
        
        // Sorts the elements in a section of an array. The sort compares the
        // elements to each other using the given IComparer interface. If
        // comparer is null, the elements are compared to each other using
        // the IComparable interface, which in that case must be implemented
        // by all elements in the given section of the array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Sort6"]/*' />
        public static void Sort(Array array, int index, int length, IComparer comparer) {
            Sort(array, null, index, length, comparer);
        }
        
        // Sorts the elements in a section of two arrays based on the keys in the
        // first array. Elements in the keys array specify the sort keys for
        // corresponding elements in the items array. The sort compares the
        // keys to each other using the given IComparer interface. If
        // comparer is null, the elements are compared to each other using
        // the IComparable interface, which in that case must be implemented
        // by all elements of the given section of the keys array.
        // 
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Sort7"]/*' />
        public static void Sort(Array keys, Array items, int index, int length, IComparer comparer) {
            if (keys==null)
                throw new ArgumentNullException("keys");
            if (keys.Rank != 1 || (items != null && items.Rank != 1))
                throw new RankException(Environment.GetResourceString("Rank_MultiDimNotSupported"));
            if (items != null && keys.GetLowerBound(0) != items.GetLowerBound(0))
                throw new ArgumentException(Environment.GetResourceString("Arg_LowerBoundsMustMatch"));
            if (index < keys.GetLowerBound(0) || length < 0)
                throw new ArgumentOutOfRangeException((length<0 ? "length" : "index"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (keys.Length - (index+keys.GetLowerBound(0)) < length || (items != null && index > items.Length - length))
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));


            
            if (length > 1) {
                if (comparer == Comparer.Default || comparer == null) {
                    int r = TrySZSort(keys, items, index, index + length - 1);
                    if (r != 0)
                        return;
                }

                Object[] objKeys = keys as Object[];
                Object[] objItems = null;
                if (objKeys != null)
                    objItems = items as Object[];
                if (objKeys != null && (items==null || objItems != null)) {
                    SorterObjectArray sorter = new SorterObjectArray(objKeys, objItems, comparer);
                    sorter.QuickSort(index, index + length - 1);
                }
                else {
                    SorterGenericArray sorter = new SorterGenericArray(keys, items, comparer);
                    sorter.QuickSort(index, index + length - 1);
                }
            }
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int TrySZSort(Array keys, Array items, int left, int right);







        // Private class used by the Sort methods.
        private class SorterObjectArray
        {
            private Object[] keys;
            private Object[] items;
            private IComparer comparer;
    
    
            public SorterObjectArray(Object[] keys, Object[] items, IComparer comparer) {
                if (comparer == null) comparer = Comparer.Default;
                this.keys = keys;
                this.items = items;
                this.comparer = comparer;
            }
    
            public virtual void QuickSort(int left, int right) {
                // Can use the much faster jit helpers for array access.
                do {
                    int i = left;
                    int j = right;
                    Object x = keys[(i + j) >> 1];
                    do {
                        // Add a try block here to detect IComparers (or their
                        // underlying IComparables, etc) that are bogus.
                        try {
                            while (comparer.Compare(keys[i], x) < 0) i++;
                            while (comparer.Compare(x, keys[j]) < 0) j--;
                        }
                        catch (IndexOutOfRangeException) {
                            throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_BogusIComparer"), x, x.GetType().Name, comparer));
                        }
                        catch (Exception e) {
                            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_IComparerFailed"), e);
                        }
                        BCLDebug.Assert(i>=left && j<=right, "(i>=left && j<=right)  Sort failed - Is your IComparer bogus?");
                        if (i > j) break;
                        if (i < j) {
                            Object key = keys[i];
                            keys[i] = keys[j];
                            keys[j] = key;
                            if (items != null) {
                                Object item = items[i];
                                items[i] = items[j];
                                items[j] = item;
                            }
                        }
                        i++;
                        j--;
                    } while (i <= j);
                    if (j - left <= right - i) {
                        if (left < j) QuickSort(left, j);
                        left = i;
                    }
                    else {
                        if (i < right) QuickSort(i, right);
                        right = j;
                    }
                } while (left < right);
            }
        }
    
        // Private class used by the Sort methods for instances of System.Array.
        // This is slower than the one for Object[], since we can't use the JIT helpers
        // to access the elements.  We must use GetValue & SetValue.
        private class SorterGenericArray
        {
            private Array keys;
            private Array items;
            private IComparer comparer;
    
            public SorterGenericArray(Array keys, Array items, IComparer comparer) {
                if (comparer == null) comparer = Comparer.Default;
                this.keys = keys;
                this.items = items;
                this.comparer = comparer;
            }
    
            public virtual void QuickSort(int left, int right) {
                // Must use slow Array accessors (GetValue & SetValue)
                do {
                    int i = left;
                    int j = right;
                    Object x = keys.GetValue((i + j) >> 1);
                    do {
                        // Add a try block here to detect IComparers (or their
                        // underlying IComparables, etc) that are bogus.
                        try {
                            while (comparer.Compare(keys.GetValue(i), x) < 0) i++;
                            while (comparer.Compare(x, keys.GetValue(j)) < 0) j--;
                        }
                        catch (IndexOutOfRangeException) {
                            throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_BogusIComparer"), x, x.GetType().Name, comparer));
                        }
                        catch (Exception e) {
                            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_IComparerFailed"), e);
                        }
                        BCLDebug.Assert(i>=left && j<=right, "(i>=left && j<=right)  Sort failed - Is your IComparer bogus?");
                        if (i > j) break;
                        if (i < j) {
                            Object key = keys.GetValue(i);
                            keys.SetValue(keys.GetValue(j), i);
                            keys.SetValue(key, j);
                            if (items != null) {
                                Object item = items.GetValue(i);
                                items.SetValue(items.GetValue(j), i);
                                items.SetValue(item, j);
                            }
                        }
                        i++;
                        j--;
                    } while (i <= j);
                    if (j - left <= right - i) {
                        if (left < j) QuickSort(left, j);
                        left = i;
                    }
                    else {
                        if (i < right) QuickSort(i, right);
                        right = j;
                    }
                } while (left < right);
            }
        }
    
        [Serializable] private class SZArrayEnumerator : IEnumerator, ICloneable
        {
            private Array _array;
            private int _index;
            private int _endIndex; // cache array length, since it's a little slow.

            internal SZArrayEnumerator(Array array) {
                BCLDebug.Assert(array.Rank == 1 && array.GetLowerBound(0) == 0, "SZArrayEnumerator only works on single dimension arrays w/ a lower bound of zero.");
                _array = array;
                _index = -1;
                _endIndex = array.Length;
            }

            public virtual Object Clone()
            {
                return MemberwiseClone();
            }

            public virtual bool MoveNext() {
                if (_index < _endIndex) {
                    _index++;
                    return (_index < _endIndex);
                }
                return false;
            }
    
            public virtual Object Current {
                get {
                    if (_index < 0) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                    if (_index >= _endIndex) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                    return _array.GetValue(_index);
                }
            }
    
            public virtual void Reset() {
                _index = -1;
            }
        }
        
        [Serializable] private class ArrayEnumerator : IEnumerator, ICloneable
        {
            private Array array;
            private int index;
            private int endIndex;
            private int startIndex;    // Save for Reset.
            private int[] _indices;    // The current position in a multidim array
            private bool _complete;

            internal ArrayEnumerator(Array array, int index, int count) {
                this.array = array;
                this.index = index - 1;
                startIndex = index;
                endIndex = index + count;
                _indices = new int[array.Rank];
                int checkForZero = 1;  // Check for dimensions of size 0.
                for(int i=0; i<array.Rank; i++) {
                    _indices[i] = array.GetLowerBound(i);
                    checkForZero *= array.GetLength(i);
                }
                // To make MoveNext simpler, decrement least significant index.
                _indices[_indices.Length-1]--;
                _complete = (checkForZero == 0);
            }

            private void IncArray() {
                // This method advances us to the next valid array index,
                // handling all the multiple dimension & bounds correctly.
                // Think of it like an odometer in your car - we start with
                // the last digit, increment it, and check for rollover.  If
                // it rolls over, we set all digits to the right and including 
                // the current to the appropriate lower bound.  Do these overflow
                // checks for each dimension, and if the most significant digit 
                // has rolled over it's upper bound, we're done.
                //
                // @TODO: Figure out if this slower and/or more complex than
                // sticking a private method on Array to access it as a flat
                // structure (ie, reference from 0 to length, ignoring bounds &
                // dimensions).  
                int rank = array.Rank;
                _indices[rank-1]++;
                for(int dim=rank-1; dim>=0; dim--) {
                    if (_indices[dim] > array.GetUpperBound(dim)) {
                        if (dim==0) {
                            _complete = true;
                            break;
                        }
                        for(int j=dim; j<rank; j++)
                            _indices[j] = array.GetLowerBound(j);
                        _indices[dim-1]++;
                    }
                }
            }

            public virtual Object Clone()
            {
                return MemberwiseClone();
            }

            public virtual bool MoveNext() {
                if (_complete) {
                    index = endIndex;
                    return false;
                }
                index++;
                IncArray();
                return !_complete;
            }
    
            public virtual Object Current {
                get {
                    if (index < startIndex) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                    if (_complete) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                    return array.GetValue(_indices);
                }
            }
    
            public virtual void Reset() {
                index = startIndex - 1;
                int checkForZero = 1;
                for(int i=0; i<array.Rank; i++) {
                    _indices[i] = array.GetLowerBound(i);
                    checkForZero *= array.GetLength(i);
                }
                _complete = (checkForZero == 0);
                // To make MoveNext simpler, decrement least significant index.
                _indices[_indices.Length-1]--;
            }
        }


        // if this is an array of value classes and that value class has a default constructor 
        // then this calls this default constructor on every elemen in the value class array.
        // otherwise this is a no-op.  Generally this method is called automatically by the compiler
        /// <include file='doc\Array.uex' path='docs/doc[@for="Array.Initialize"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern void Initialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\argiterator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;

	// This class will not be marked serializable
    /// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator"]/*' />
	// TODO: put this back in [System.Runtime.CompilerServices.NotInGCHeap] 
	[StructLayout(LayoutKind.Auto)]
    public struct ArgIterator
    {
    	// create an arg iterator that points at the first argument that
    	// is not statically declared (that is the first ... arg)
    	// 'arglist' is the value returned by the ARGLIST instruction
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.ArgIterator"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern ArgIterator(RuntimeArgumentHandle arglist);
    
    	// create an arg iterator that points just past 'firstArg'.  
    	// 'arglist' is the value returned by the ARGLIST instruction
    	// This is much like the C va_start macro
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.ArgIterator1"]/*' />
		[MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
    	public unsafe extern ArgIterator(RuntimeArgumentHandle arglist, void* ptr);

    	// Fetch an argument as a typed referece, advance the iterator.
    	// Throws an exception if past end of argument list
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetNextArg"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
    	public extern TypedReference GetNextArg();

        // Alternate version of GetNextArg() intended primarily for IJW code
        // generated by VC's "va_arg()" construct. 
        /// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetNextArg1"]/*' />
        [CLSCompliant(false)]
        public TypedReference GetNextArg(RuntimeTypeHandle rth)
        {
            if (SigPtr != 0)
            {
                // This is an ordinary ArgIterator capable of determining
                // types from a signature. Just do a regular GetNextArg.
                return GetNextArg();
            }
            else
            {
                return InternalGetNextArg(rth);
            }
        }


        [MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
        private extern TypedReference InternalGetNextArg(RuntimeTypeHandle rth);

    	// Invalidate the iterator (va_end)
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.End"]/*' />
    	public void End()
    	{
    		//@todo: Invalidate the iterator.
    	}
    
    	// How many arguments are left in the list 
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetRemainingCount"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern int GetRemainingCount();
    
    	// Gets the type of the current arg, does NOT advance the iterator
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetNextArgType"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern RuntimeTypeHandle GetNextArgType();
    
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return ArgCookie;
    	}
    
    	// Inherited from object
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.Equals"]/*' />
    	public override bool Equals(Object o)
    	{
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_NYI"));
    	}
    
    	private int	ArgCookie;				// Cookie from the EE.
    	private int	SigPtr;					// Pointer to remaining signature.
    	private int	ArgPtr;					// Pointer to remaining args.
    	private int	RemainingArgs;			// # of remaining args.

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			ArgCookie = 0;
			SigPtr = 0;
			ArgPtr = 0;
			RemainingArgs = 0;
		}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\argumentexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ArgumentException
**
** Author: 
**
** Purpose: Exception class for invalid arguments to a method.
**
** Date: March 24, 1998
**
=============================================================================*/

namespace System {
    
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    // The ArgumentException is thrown when an argument does not meet 
    // the contract of the method.  Ideally it should give a meaningful error
    // message describing what was wrong and which parameter is incorrect.
    // 
    /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException"]/*' />
    [Serializable()] public class ArgumentException : SystemException, ISerializable {
        private String m_paramName;
        
        // Creates a new ArgumentException with its message 
        // string set to the empty string. 
        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.ArgumentException"]/*' />
        public ArgumentException() 
            : base(Environment.GetResourceString("Arg_ArgumentException")) {
            SetErrorCode(__HResults.COR_E_ARGUMENT);
        }
        
        // Creates a new ArgumentException with its message 
        // string set to message. 
        // 
        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.ArgumentException1"]/*' />
        public ArgumentException(String message) 
            : base(message) {
            SetErrorCode(__HResults.COR_E_ARGUMENT);
        }
        
        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.ArgumentException2"]/*' />
        public ArgumentException(String message, Exception innerException) 
            : base(message, innerException) {
            SetErrorCode(__HResults.COR_E_ARGUMENT);
        }

        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.ArgumentException3"]/*' />
        public ArgumentException(String message, String paramName, Exception innerException) 
            : base(message, innerException) {
            m_paramName = paramName;
            SetErrorCode(__HResults.COR_E_ARGUMENT);
        }
        
        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.ArgumentException4"]/*' />
        public ArgumentException (String message, String paramName)
        
            : base (message) {
            m_paramName = paramName;
            SetErrorCode(__HResults.COR_E_ARGUMENT);
        }

        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.ArgumentException5"]/*' />
        protected ArgumentException(SerializationInfo info, StreamingContext context) : base(info, context) {
            m_paramName = info.GetString("ParamName");
        }
        
        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.Message"]/*' />
        public override String Message
        {
            get {
                String s = base.Message;
                if (! ((m_paramName == null) ||
                       (m_paramName.Length == 0)) )
                    return s + Environment.NewLine + String.Format(Environment.GetResourceString("Arg_ParamName_Name"), m_paramName);
                else
                    return s;
            }
        }
        
        /*
        public String ToString()
        {
            String s = super.ToString();
            if (m_paramName != null)
                return s + "Parameter name: "+m_paramName+"\tActual value: "+(m_actualValue==null ? "<null>" : m_actualValue.ToString());
            else
                return s;
        }
        */
        
        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.ParamName"]/*' />
        public virtual String ParamName {
            get { return m_paramName; }
        }
    
        /// <include file='doc\ArgumentException.uex' path='docs/doc[@for="ArgumentException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            base.GetObjectData(info, context);
            info.AddValue("ParamName", m_paramName, typeof(String));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\arithmeticexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ArithmeticException
**
** Author: 
**
** Purpose: Exception class for bad arithmetic conditions!
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    // The ArithmeticException is thrown when overflow or underflow
    // occurs.
    // 
    /// <include file='doc\ArithmeticException.uex' path='docs/doc[@for="ArithmeticException"]/*' />
    [Serializable] public class ArithmeticException : SystemException
    {    	
        // Creates a new ArithmeticException with its message string set to
        // the empty string, its HRESULT set to COR_E_ARITHMETIC, 
        // and its ExceptionInfo reference set to null. 
        /// <include file='doc\ArithmeticException.uex' path='docs/doc[@for="ArithmeticException.ArithmeticException"]/*' />
        public ArithmeticException() 
            : base(Environment.GetResourceString("Arg_ArithmeticException")) {
    		SetErrorCode(__HResults.COR_E_ARITHMETIC);
        }
    	
        // Creates a new ArithmeticException with its message string set to
        // message, its HRESULT set to COR_E_ARITHMETIC, 
        // and its ExceptionInfo reference set to null. 
        // 
        /// <include file='doc\ArithmeticException.uex' path='docs/doc[@for="ArithmeticException.ArithmeticException1"]/*' />
        public ArithmeticException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_ARITHMETIC);
        }
    	
        /// <include file='doc\ArithmeticException.uex' path='docs/doc[@for="ArithmeticException.ArithmeticException2"]/*' />
        public ArithmeticException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_ARITHMETIC);
        }

        /// <include file='doc\ArithmeticException.uex' path='docs/doc[@for="ArithmeticException.ArithmeticException3"]/*' />
        protected ArithmeticException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\arraytypemismatchexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ArrayTypeMismatchException
**
** Author: 
**
** Purpose: The arrays are of different primitive types.
**
** Date: March 30, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    // The ArrayMismatchException is thrown when an attempt to store
    // an object of the wrong type within an array occurs.
    // 
    /// <include file='doc\ArrayTypeMismatchException.uex' path='docs/doc[@for="ArrayTypeMismatchException"]/*' />
    [Serializable()] public class ArrayTypeMismatchException : SystemException {
    	
        // Creates a new ArrayMismatchException with its message string set to
        // the empty string, its HRESULT set to COR_E_ARRAYTYPEMISMATCH, 
        // and its ExceptionInfo reference set to null. 
        /// <include file='doc\ArrayTypeMismatchException.uex' path='docs/doc[@for="ArrayTypeMismatchException.ArrayTypeMismatchException"]/*' />
        public ArrayTypeMismatchException() 
            : base(Environment.GetResourceString("Arg_ArrayTypeMismatchException")) {
    		SetErrorCode(__HResults.COR_E_ARRAYTYPEMISMATCH);
        }
    	
        // Creates a new ArrayMismatchException with its message string set to
        // message, its HRESULT set to COR_E_ARRAYTYPEMISMATCH, 
        // and its ExceptionInfo reference set to null. 
        // 
        /// <include file='doc\ArrayTypeMismatchException.uex' path='docs/doc[@for="ArrayTypeMismatchException.ArrayTypeMismatchException1"]/*' />
        public ArrayTypeMismatchException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_ARRAYTYPEMISMATCH);
        }
    	
        /// <include file='doc\ArrayTypeMismatchException.uex' path='docs/doc[@for="ArrayTypeMismatchException.ArrayTypeMismatchException2"]/*' />
        public ArrayTypeMismatchException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_ARRAYTYPEMISMATCH);
        }

        /// <include file='doc\ArrayTypeMismatchException.uex' path='docs/doc[@for="ArrayTypeMismatchException.ArrayTypeMismatchException3"]/*' />
        protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\argumentoutofrangeexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ArgumentOutOfRangeException
**
** Author: Brian Grunkemeyer
**
** Purpose: Exception class for method arguments outside of the legal range.
**
** Date: April 28, 1999
**
=============================================================================*/

namespace System {

	using System;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
    // The ArgumentOutOfRangeException is thrown when an argument 
    // is outside the legal range for that argument.  This may often be caused
    // by 
    // 
    /// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException"]/*' />
    [Serializable()] public class ArgumentOutOfRangeException : ArgumentException, ISerializable {
    	
    	private static String _rangeMessage;
    	private Object m_actualValue;

        private static String RangeMessage {
            get {
                if (_rangeMessage == null)
                    _rangeMessage = Environment.GetResourceString("Arg_ArgumentOutOfRangeException");
                return _rangeMessage;
            }
        }

        // Creates a new ArgumentOutOfRangeException with its message 
        // string set to a default message explaining an argument was out of range.
        /// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException.ArgumentOutOfRangeException"]/*' />
        public ArgumentOutOfRangeException() 
            : base(RangeMessage) {
    		SetErrorCode(__HResults.COR_E_ARGUMENTOUTOFRANGE);
        }
    	
        /// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException.ArgumentOutOfRangeException1"]/*' />
        public ArgumentOutOfRangeException(String paramName) 
            : base(RangeMessage, paramName) {
    		SetErrorCode(__HResults.COR_E_ARGUMENTOUTOFRANGE);
        }
    
        /// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException.ArgumentOutOfRangeException2"]/*' />
        public ArgumentOutOfRangeException(String paramName, String message) 
            : base(message, paramName) {
    		SetErrorCode(__HResults.COR_E_ARGUMENTOUTOFRANGE);
        }
    	
    	// We will not use this in the classlibs, but we'll provide it for
    	// anyone that's really interested so they don't have to stick a bunch
    	// of printf's in their code.
        /// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException.ArgumentOutOfRangeException3"]/*' />
        public ArgumentOutOfRangeException(String paramName, Object actualValue, String message) 
            : base(message, paramName) {
    		m_actualValue = actualValue;
    		SetErrorCode(__HResults.COR_E_ARGUMENTOUTOFRANGE);
        }
    	
    	/// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException.Message"]/*' />
    	public override String Message
    	{
    		get {
    			String s = base.Message;
    			if (m_actualValue != null) {
                    String valueMessage = String.Format(Environment.GetResourceString("ArgumentOutOfRange_ActualValue"), m_actualValue.ToString());
                    if (s == null)
                        return valueMessage;
                    return s + Environment.NewLine + valueMessage;
    			}
    			return s;
    		}
    	}
    	
    	// Gets the value of the argument that caused the exception.
    	// Note - we don't set this anywhere in the class libraries in 
    	// version 1, but it might come in handy for other developers who
    	// want to avoid sticking printf's in their code.
    	/// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException.ActualValue"]/*' />
    	public virtual Object ActualValue {
    		get { return m_actualValue; }
    	}
    
        /// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            base.GetObjectData(info, context);
            info.AddValue("ActualValue", m_actualValue, typeof(Object));
        }

        /// <include file='doc\ArgumentOutOfRangeException.uex' path='docs/doc[@for="ArgumentOutOfRangeException.ArgumentOutOfRangeException4"]/*' />
        protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context) : base(info, context) {
            m_actualValue = info.GetValue("ActualValue", typeof(Object));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\asynccallback.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: AsyncCallbackDelegate
**
** Purpose: Type of callback for async operations
**
===========================================================*/
namespace System {
    /// <include file='doc\AsyncCallback.uex' path='docs/doc[@for="AsyncCallback"]/*' />
	[Serializable()]    
    public delegate void AsyncCallback(IAsyncResult ar);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\bcldebug.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: BCLDebug
**
** Author: Jay Roxe
**
** Purpose: Debugging Macros for use in the Base Class Libraries
**
** Date: November 16, 1999
**
============================================================*/

namespace System {

    using System.IO;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Runtime.CompilerServices;
    using System.Security.Permissions;
    using System.Security;

    [Serializable]
    internal enum LogLevel {
        Trace  = 0,
        Status = 20,
        Warning= 40,
        Error  = 50,
        Panic  = 100,
    }

    internal struct SwitchStructure {
        internal String name;
        internal int    value;
        
        internal SwitchStructure (String n, int v) {
            name = n;
            value = v;
        }
    }

    
    // Only statics, does not need to be marked with the serializable attribute
    internal class BCLDebug {
        internal static bool m_registryChecked=false;
        internal static bool m_perfWarnings;
        internal static bool m_correctnessWarnings;
#if _DEBUG
        internal static bool m_domainUnloadAdded;
#endif
        internal static PermissionSet m_MakeConsoleErrorLoggingWork;

        static SwitchStructure[] switches = {
            new SwitchStructure("NLS",  0x00000001),
            new SwitchStructure("SER",  0x00000002),
            new SwitchStructure("DYNIL",0x00000004),
            new SwitchStructure("REMOTE",0x00000008),
            new SwitchStructure("BINARY",0x00000010),   //Binary Formatter
            new SwitchStructure("SOAP",0x00000020),     // Soap Formatter
            new SwitchStructure("REMOTINGCHANNELS",0x00000040),
            new SwitchStructure("CACHE",0x00000080),
            new SwitchStructure("RESMGRFILEFORMAT", 0x00000100), // .resources files
            new SwitchStructure("PERF", 0x00000200), 
            new SwitchStructure("CORRECTNESS", 0x00000400), 
        };

        static LogLevel[] levelConversions = {
            LogLevel.Panic,
            LogLevel.Error,
            LogLevel.Error,
            LogLevel.Warning,
            LogLevel.Warning,
            LogLevel.Status,
            LogLevel.Status,
            LogLevel.Trace,
            LogLevel.Trace,
            LogLevel.Trace,
            LogLevel.Trace
        };


#if _DEBUG
        internal static void WaitForFinalizers(Object sender, EventArgs e)
        {
            if (!m_registryChecked) {
                CheckRegistry();
            }
            if (m_correctnessWarnings) {
                GC.GetTotalMemory(true);
                GC.WaitForPendingFinalizers();
            }
        }
#endif

        [Conditional("_DEBUG")]
        static public void Assert(bool condition, String message) {
#if _DEBUG
            // Speed up debug builds marginally by avoiding the garbage from
            // concatinating "BCL Assert: " and the message.
            if (!condition)
                System.Diagnostics.Assert.Check(condition, "BCL Assert: "+message, message);
#endif
        }
       
        [Conditional("_LOGGING")]
        static public void Log(String message) {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return;
            if (!m_registryChecked) {
                CheckRegistry();
            }
            System.Diagnostics.Log.Trace(message);
            System.Diagnostics.Log.Trace(Environment.NewLine);
        }
        
        [Conditional("_LOGGING")]
        static public void Log(String switchName, String message) {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return;
            if (!m_registryChecked) {
                CheckRegistry();
            }
            try {
                LogSwitch ls;
                ls = LogSwitch.GetSwitch(switchName);
                if (ls!=null) {
                    System.Diagnostics.Log.Trace(ls,message);
                    System.Diagnostics.Log.Trace(ls,Environment.NewLine);
                }
            } catch (Exception) {
                System.Diagnostics.Log.Trace("Exception thrown in logging." + Environment.NewLine);
                System.Diagnostics.Log.Trace("Switch was: " + ((switchName==null)?"<null>":switchName) + Environment.NewLine);
                System.Diagnostics.Log.Trace("Message was: " + ((message==null)?"<null>":message) + Environment.NewLine);
            }
        }

        //
        // This code gets called during security startup, so we can't go through Marshal to get the values.  This is
        // just a small helper in native code instead of that.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static int GetRegistryValue(out bool loggingEnabled, out bool logToConsole, out int logLevel, out bool perfWarnings, out bool correctnessWarnings);

        private static void CheckRegistry() {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return;
            if (m_registryChecked) {
                return;
            }
            
            m_registryChecked = true;

            bool loggingEnabled;
            bool logToConsole;
            int  logLevel;
            int  facilityValue;
            facilityValue = GetRegistryValue(out loggingEnabled, out logToConsole, out logLevel, out m_perfWarnings, out m_correctnessWarnings);

            // Note we can get into some recursive situations where we call
            // ourseves recursively through the .cctor.  That's why we have the 
            // check for levelConversions == null.
            if (loggingEnabled && levelConversions!=null) {
                try {
                    //The values returned for the logging levels in the registry don't map nicely onto the
                    //values which we support internally (which are an approximation of the ones that 
                    //the System.Diagnostics namespace uses) so we have a quick map.
                    Assert(logLevel>=0 && logLevel<=10, "logLevel>=0 && logLevel<=10");
                    logLevel = (int)levelConversions[logLevel];
                
                    if (facilityValue>0) {
                        for (int i=0; i<switches.Length; i++) {
                            if ((switches[i].value & facilityValue)!=0) {
                                LogSwitch L = new LogSwitch(switches[i].name, switches[i].name, System.Diagnostics.Log.GlobalSwitch);
                                L.MinimumLevel = (LoggingLevels)logLevel;
                            }
                        }
                        System.Diagnostics.Log.GlobalSwitch.MinimumLevel = (LoggingLevels)logLevel;
                        System.Diagnostics.Log.IsConsoleEnabled = logToConsole;
                    }
                    
                } catch (Exception) {
                    //Silently eat any exceptions.
                }
            }
        }

        internal static bool CheckEnabled(String switchName) {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return false;
            if (!m_registryChecked)
                CheckRegistry();
            LogSwitch logSwitch = LogSwitch.GetSwitch(switchName);
            if (logSwitch==null) {
                return false;
            }
            return ((int)logSwitch.MinimumLevel<=(int)LogLevel.Trace);
        }

        private static bool CheckEnabled(String switchName, LogLevel level, out LogSwitch logSwitch) {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
            {
                logSwitch = null;
                return false;
            }
            logSwitch = LogSwitch.GetSwitch(switchName);
            if (logSwitch==null) {
                return false;
            }
            return ((int)logSwitch.MinimumLevel<=(int)level);
        }

        [Conditional("_LOGGING")]
        public static void Log(String switchName, LogLevel level, params Object[]messages) {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return;
            //Add code to check if logging is enabled in the registry.
            LogSwitch logSwitch;

            if (!m_registryChecked) {
                CheckRegistry();
            }

            if (!CheckEnabled(switchName, level, out logSwitch)) {
                return;
            }

            StringBuilder sb = new StringBuilder();

            for (int i=0; i<messages.Length; i++) {
                String s;
                try {
                    if (messages[i]==null) {
                        s = "<null>";
                    } else {
                        s = messages[i].ToString();
                    }
                } catch (Exception) {
                    s = "<unable to convert>";
                }
                sb.Append(s);
            }
            System.Diagnostics.Log.LogMessage((LoggingLevels)((int)level), logSwitch, sb.ToString());
        }

        [Conditional("_LOGGING")]
        public static void Trace(String switchName, params Object[]messages) {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return;
            //Add code to check if logging is enabled in the registry.
            LogSwitch logSwitch;

            if (!m_registryChecked) {
                CheckRegistry();
            }

            if (!CheckEnabled(switchName, LogLevel.Trace, out logSwitch)) {
                return;
            }

            StringBuilder sb = new StringBuilder();

            for (int i=0; i<messages.Length; i++) {
                String s;
                try {
                    if (messages[i]==null) {
                        s = "<null>";
                    } else {
                        s = messages[i].ToString();
                    }
                } catch (Exception) {
                    s = "<unable to convert>";
                }
                sb.Append(s);
            }
            
            sb.Append(Environment.NewLine);
            System.Diagnostics.Log.LogMessage(LoggingLevels.TraceLevel0, logSwitch, sb.ToString());
        }

        [Conditional("_LOGGING")]
        public static void DumpStack(String switchName) {
            LogSwitch logSwitch;

            if (!m_registryChecked) {
                CheckRegistry();
            }

            if (!CheckEnabled(switchName, LogLevel.Trace, out logSwitch)) {
                return;
            }
            
            StackTrace trace = new StackTrace();
            System.Diagnostics.Log.LogMessage(LoggingLevels.TraceLevel0, logSwitch, trace.ToString());
        }

        // For logging errors related to the console - we often can't expect to
        // write to stdout if it doesn't exist.
        [Conditional("_DEBUG")]
        internal static void ConsoleError(String msg)
        {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return;

            // Bonk security - make it work.
            if (m_MakeConsoleErrorLoggingWork == null) {
                PermissionSet perms = new PermissionSet();
                perms.AddPermission(new EnvironmentPermission(PermissionState.Unrestricted));
                perms.AddPermission(new FileIOPermission(FileIOPermissionAccess.AllAccess, Path.GetFullPath(".")));
                m_MakeConsoleErrorLoggingWork = perms;
            }
            m_MakeConsoleErrorLoggingWork.Assert();
                   
            TextWriter err = File.AppendText("ConsoleErrors.log");
            err.WriteLine(msg);
            err.Close();
        }

        // For perf-related asserts.  On a debug build, set the registry key
        // BCLPerfWarnings to non-zero.
        [Conditional("_DEBUG")]
        internal static void Perf(bool expr, String msg)
        {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return;
            if (!m_registryChecked)
                CheckRegistry();
            if (!m_perfWarnings)
                return;

            if (!expr) {
                Log("PERF", "BCL Perf Warning: "+msg);
            }
            System.Diagnostics.Assert.Check(expr, "BCL Perf Warning: Your perf may be less than perfect because...", msg);
        }

        // For correctness-related asserts.  On a debug build, set the registry key
        // BCLCorrectnessWarnings to non-zero.
        [Conditional("_DEBUG")]
        internal static void Correctness(bool expr, String msg)
        {
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return;
            if (!m_registryChecked)
                CheckRegistry();
            if (!m_correctnessWarnings)
                return;

#if _DEBUG
            if (!m_domainUnloadAdded) {
                m_domainUnloadAdded = true;
                AppDomain.CurrentDomain.DomainUnload += new EventHandler(WaitForFinalizers);
            }
#endif

            if (!expr) {
                Log("CORRECTNESS", "BCL Correctness Warning: "+msg);
            }
            System.Diagnostics.Assert.Check(expr, "BCL Correctness Warning: Your program may not work because...", msg);
        }
        
        internal static bool CorrectnessEnabled()
        {
#if WIN32
            if (AppDomain.CurrentDomain.IsUnloadingForcedFinalize())
                return false;
            if (!m_registryChecked)
                CheckRegistry();
            return m_correctnessWarnings;  
#else 
            return false;
#endif // WIN32
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\badimageformatexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  BadImageFormatException
**
** Author: David Mortenson (dmortens)
**
** Purpose: Exception to an invalid dll or executable format.
**
** Date:  May 22, 2000
** 
===========================================================*/
namespace System {
    
    using System;
    using System.Runtime.Serialization;
    using FileLoadException = System.IO.FileLoadException;
    using System.Security.Permissions;
    using SecurityException = System.Security.SecurityException;

    /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException"]/*' />
    [Serializable()] public class BadImageFormatException : SystemException {

        private String _fileName;  // The name of the corrupt PE file.
        private String _fusionLog;  // fusion log (when applicable)

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.BadImageFormatException"]/*' />
        public BadImageFormatException() 
            : base(Environment.GetResourceString("Arg_BadImageFormatException")) {
            SetErrorCode(__HResults.COR_E_BADIMAGEFORMAT);
        }
    
        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.BadImageFormatException1"]/*' />
        public BadImageFormatException(String message) 
            : base(message) {
            SetErrorCode(__HResults.COR_E_BADIMAGEFORMAT);
        }
        
        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.BadImageFormatException2"]/*' />
        public BadImageFormatException(String message, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.COR_E_BADIMAGEFORMAT);
        }

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.BadImageFormatException3"]/*' />
        public BadImageFormatException(String message, String fileName) : base(message)
        {
            SetErrorCode(__HResults.COR_E_BADIMAGEFORMAT);
            _fileName = fileName;
        }

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.BadImageFormatException4"]/*' />
        public BadImageFormatException(String message, String fileName, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.COR_E_BADIMAGEFORMAT);
            _fileName = fileName;
        }

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.Message"]/*' />
        public override String Message
        {
            get {
                SetMessageField();
                return _message;
            }
        }

        private void SetMessageField()
        {
            if (_message == null) {
                if (_fileName == null)
                    _message = Environment.GetResourceString("Arg_BadImageFormatException");

                else
                    _message = FileLoadException.FormatFileLoadExceptionMessage(_fileName, HResult);
            }

        }

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.FileName"]/*' />
        public String FileName {
            get { return _fileName; }
        }

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.ToString"]/*' />
        public override String ToString()
        {
            String s = GetType().FullName + ": " + Message;

            if (_fileName != null && _fileName.Length != 0)
                s += Environment.NewLine + String.Format(Environment.GetResourceString("IO.FileName_Name"), _fileName);
            
            if (InnerException != null)
                s = s + " ---> " + InnerException.ToString();

            if (StackTrace != null)
                s += Environment.NewLine + StackTrace;

            try
            {
                if(FusionLog!=null)
                {
                    if (s==null)
                        s=" ";
                    s+=Environment.NewLine;
                    s+=Environment.NewLine;
                    s+=FusionLog;
                }
            }
            catch(SecurityException)
            {
            
            }

            return s;
        }

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.BadImageFormatException5"]/*' />
        protected BadImageFormatException(SerializationInfo info, StreamingContext context) : base(info, context) {
            // Base class constructor will check info != null.

            _fileName = info.GetString("BadImageFormat_FileName");
            try
            {
                _fusionLog = info.GetString("BadImageFormat_FusionLog");
            }
            catch (Exception)
            {
                _fusionLog = null;
            }

        }

        private BadImageFormatException(String fileName, String fusionLog,int hResult)
            : base(null)
        {
            SetErrorCode(hResult);
            _fileName = fileName;
            _fusionLog=fusionLog;
            SetMessageField();
        }

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.FusionLog"]/*' />
        public String FusionLog {
            [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
            get { return _fusionLog; }
        }

        /// <include file='doc\BadImageFormatException.uex' path='docs/doc[@for="BadImageFormatException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            // Serialize data for our base classes.  base will verify info != null.
            base.GetObjectData(info, context);

            // Serialize data for this class
            info.AddValue("BadImageFormat_FileName", _fileName, typeof(String));
            try
            {
                info.AddValue("BadImageFormat_FusionLog", FusionLog, typeof(String));
            }
            catch (SecurityException)
            {
            }
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\attributetargets.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System {
    
	using System;

    // Enum used to indicate all the elements of the
    // VOS it is valid to attach this element to.
    /// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets"]/*' />
    [Flags,Serializable]
    public enum AttributeTargets
    {
        /// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Assembly"]/*' />
        Assembly      = 0x0001,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Module"]/*' />
		Module        = 0x0002,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Class"]/*' />
		Class         = 0x0004,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Struct"]/*' />
		Struct        = 0x0008,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Enum"]/*' />
		Enum          = 0x0010,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Constructor"]/*' />
		Constructor   = 0x0020,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Method"]/*' />
		Method        = 0x0040,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Property"]/*' />
		Property      = 0x0080,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Field"]/*' />
		Field         = 0x0100,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Event"]/*' />
		Event         = 0x0200,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Interface"]/*' />
		Interface     = 0x0400,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Parameter"]/*' />
		Parameter     = 0x0800,
		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.Delegate"]/*' />
		Delegate      = 0x1000,

        /// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.ReturnValue"]/*' />
        ReturnValue   = 0x2000,

		/// <include file='doc\AttributeTargets.uex' path='docs/doc[@for="AttributeTargets.All"]/*' />
		All           = Assembly | Module   | Class | Struct | Enum      | Constructor | 
                        Method   | Property | Field | Event  | Interface | Parameter   | Delegate | ReturnValue,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\attributeusageattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  AttributeUsageAttribute
**
** Author: Rajesh Chandrashekaran ( rajeshc )
**
** Purpose: The class denotes how to specify the usage of an attribute
**          
** Date:  December 7, 1999
**
===========================================================*/
namespace System {

	using System.Reflection;
	/* By default, attributes are inherited and multiple attributes are not allowed */
    /// <include file='doc\AttributeUsageAttribute.uex' path='docs/doc[@for="AttributeUsageAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true),Serializable()]
    public sealed class AttributeUsageAttribute : Attribute
	{
        internal AttributeTargets m_attributeTarget = AttributeTargets.All; // Defaults to all
        internal bool m_allowMultiple = false; // Defaults to false
        internal bool m_inherited = true; // Defaults to true
    
		internal static AttributeUsageAttribute Default = new AttributeUsageAttribute(AttributeTargets.All);

       //Constructors 
        /// <include file='doc\AttributeUsageAttribute.uex' path='docs/doc[@for="AttributeUsageAttribute.AttributeUsageAttribute"]/*' />
        public AttributeUsageAttribute(AttributeTargets validOn) {
            m_attributeTarget = validOn;
        }
    
	   
       //Properties 
        /// <include file='doc\AttributeUsageAttribute.uex' path='docs/doc[@for="AttributeUsageAttribute.ValidOn"]/*' />
        public AttributeTargets ValidOn 
		{
           get{ return m_attributeTarget; }
	    }
    
        /// <include file='doc\AttributeUsageAttribute.uex' path='docs/doc[@for="AttributeUsageAttribute.AllowMultiple"]/*' />
        public bool AllowMultiple 
		{
            get { return m_allowMultiple; }
            set { m_allowMultiple = value; }
        }
    
        /// <include file='doc\AttributeUsageAttribute.uex' path='docs/doc[@for="AttributeUsageAttribute.Inherited"]/*' />
        public bool Inherited 
		{
            get { return m_inherited; }
            set { m_inherited = value; }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\appdomain.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: AppDomain
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Domains represent an application within the runtime. Objects can 
**          not be shared between domains and each domain can be configured
**          independently. 
**
** Date: April 14, 1999
**
=============================================================================*/

namespace System {
    using System;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Contexts;
    using SecurityManager = System.Security.SecurityManager;
    using System.Security.Permissions;
    using IEvidenceFactory = System.Security.IEvidenceFactory;
    using System.Security.Principal;
    using System.Security.Policy;
    using System.Security;
    using System.Security.Util;
    using System.Collections;
    using StringBuilder = System.Text.StringBuilder;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;   
    using Context = System.Runtime.Remoting.Contexts.Context;
    using System.Reflection.Emit;
    using Message = System.Runtime.Remoting.Messaging.Message;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.IO;
    using BinaryFormatter = System.Runtime.Serialization.Formatters.Binary.BinaryFormatter;
    using AssemblyHashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm;

    /// <include file='doc\AppDomain.uex' path='docs/doc[@for="ResolveEventArgs"]/*' />
    public class ResolveEventArgs : EventArgs
    {
        private String _Name;

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="ResolveEventArgs.Name"]/*' />
        public String Name {
            get {
                return _Name;
            }
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="ResolveEventArgs.ResolveEventArgs"]/*' />
        public ResolveEventArgs(String name)
        {
            _Name = name;
        }
    }

    /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AssemblyLoadEventArgs"]/*' />
    public class AssemblyLoadEventArgs : EventArgs
    {
        private Assembly _LoadedAssembly;

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AssemblyLoadEventArgs.LoadedAssembly"]/*' />
        public Assembly LoadedAssembly {
            get {
                return _LoadedAssembly;
            }
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AssemblyLoadEventArgs.AssemblyLoadEventArgs"]/*' />
        public AssemblyLoadEventArgs(Assembly loadedAssembly)
        {
            _LoadedAssembly = loadedAssembly;
        }
    }


    /// <include file='doc\AppDomain.uex' path='docs/doc[@for="ResolveEventHandler"]/*' />
    [Serializable()]
    public delegate Assembly ResolveEventHandler(Object sender, ResolveEventArgs args);

    /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AssemblyLoadEventHandler"]/*' />
    [Serializable()]
    public delegate void AssemblyLoadEventHandler(Object sender, AssemblyLoadEventArgs args);

    /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain"]/*' />
    [ClassInterface(ClassInterfaceType.None)]
        //[ClassInterface(ClassInterfaceType.AutoDual)]
    public sealed class AppDomain : MarshalByRefObject, _AppDomain, IEvidenceFactory
    {
        // Domain security information
        // These fields initialized from the other side only. (NOTE: order 
        // of these fields cannot be changed without changing the layout in 
        // the EE)
    
        private Hashtable        _LocalStore;
        private AppDomainSetup   _FusionStore;
        private Evidence         _SecurityIdentity;
        private Object[]         _Policies;
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DomainUnload"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public event EventHandler DomainUnload;
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.AssemblyLoad"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public event AssemblyLoadEventHandler AssemblyLoad;
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ProcessExit"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public event EventHandler ProcessExit;
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.TypeResolve"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public event ResolveEventHandler TypeResolve;
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ResourceResolve"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public event ResolveEventHandler ResourceResolve;
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.AssemblyResolve"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public event ResolveEventHandler AssemblyResolve;

        private Context          _DefaultContext;
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.UnhandledException"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public event UnhandledExceptionEventHandler UnhandledException;

        private IPrincipal       _DefaultPrincipal;
        private PrincipalPolicy  _PrincipalPolicy;
        private DomainSpecificRemotingData _RemotingData;
        private int              _dummyField = 0;
        private bool             _HasSetPolicy;

        //internal static string MsKey = "0x002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293";

        
        // this method is required so Object.GetType is not made virtual by the compiler
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.GetType"]/*' />
        public new Type GetType()
        {
            return base.GetType();
        }
        
        
       /**********************************************
        * If an AssemblyName has a public key specified, the assembly is assumed
        * to have a strong name and a hash will be computed when the assembly
        * is saved.
        **********************************************/
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalDefineDynamicAssembly(name, access, null,
                                                 null, null, null, null, ref stackMark);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly1"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            String                  dir)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalDefineDynamicAssembly(name, access, dir,
                                                 null, null, null, null,
                                                 ref stackMark);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly2"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            Evidence                evidence)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalDefineDynamicAssembly(name, access, null,
                                                 evidence, null, null, null,
                                                 ref stackMark);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly3"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            PermissionSet           requiredPermissions,
            PermissionSet           optionalPermissions,
            PermissionSet           refusedPermissions)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalDefineDynamicAssembly(name, access, null, null,
                                                 requiredPermissions,
                                                 optionalPermissions,
                                                 refusedPermissions,
                                                 ref stackMark);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly4"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            String                  dir,
            Evidence                evidence)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalDefineDynamicAssembly(name, access, dir, evidence,
                                                 null, null, null, ref stackMark);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly5"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            String                  dir,
            PermissionSet           requiredPermissions,
            PermissionSet           optionalPermissions,
            PermissionSet           refusedPermissions)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalDefineDynamicAssembly(name, access, dir, null,
                                                 requiredPermissions,
                                                 optionalPermissions,
                                                 refusedPermissions,
                                                 ref stackMark);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly6"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            Evidence                evidence,
            PermissionSet           requiredPermissions,
            PermissionSet           optionalPermissions,
            PermissionSet           refusedPermissions)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalDefineDynamicAssembly(name, access, null,
                                                 evidence,
                                                 requiredPermissions,
                                                 optionalPermissions,
                                                 refusedPermissions,
                                                 ref stackMark);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly7"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            String                  dir,
            Evidence                evidence,
            PermissionSet           requiredPermissions,
            PermissionSet           optionalPermissions,
            PermissionSet           refusedPermissions)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalDefineDynamicAssembly(name, access, dir,
                                                 evidence,
                                                 requiredPermissions,
                                                 optionalPermissions,
                                                 refusedPermissions,
                                                 ref stackMark);
        }


        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DefineDynamicAssembly8"]/*' />
        public AssemblyBuilder DefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            String                  dir,
            Evidence                evidence,
            PermissionSet           requiredPermissions,
            PermissionSet           optionalPermissions,
            PermissionSet           refusedPermissions,
            bool                    isSynchronized)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            AssemblyBuilder assemblyBuilder = InternalDefineDynamicAssembly(name,
                                                                            access,
                                                                            dir,
                                                                            evidence,
                                                                            requiredPermissions,
                                                                            optionalPermissions,
                                                                            refusedPermissions,
                                                                            ref stackMark);
            assemblyBuilder.m_assemblyData.m_isSynchronized = isSynchronized;
            return assemblyBuilder;
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstance"]/*' />
        public ObjectHandle CreateInstance(String assemblyName,
                                           String typeName)
                                         
        {
            // jit does not check for that, so we should do it ...
            if (this == null)
                throw new NullReferenceException();

            if (assemblyName == null)
                throw new ArgumentNullException("assemblyName");

            return Activator.CreateInstance(assemblyName,
                                            typeName);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceFrom"]/*' />
        public ObjectHandle CreateInstanceFrom(String assemblyFile,
                                               String typeName)
                                         
        {
            // jit does not check for that, so we should do it ...
            if (this == null)
                throw new NullReferenceException();

            return Activator.CreateInstanceFrom(assemblyFile,
                                                typeName);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateComInstanceFrom"]/*' />
        public ObjectHandle CreateComInstanceFrom(String assemblyName,
                                                  String typeName)
                                         
        {
            if (this == null)
                throw new NullReferenceException();

            if (assemblyName == null)
                throw new ArgumentNullException("assemblyName");

            return Activator.CreateComInstanceFrom(assemblyName,
                                                   typeName);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateComInstanceFrom1"]/*' />
        public ObjectHandle CreateComInstanceFrom(String assemblyFile,
                                                  String typeName,
                                                  byte[] hashValue, 
                                                  AssemblyHashAlgorithm hashAlgorithm)
                                         
        {
            if (this == null)
                throw new NullReferenceException();

            if (assemblyFile == null)
                throw new ArgumentNullException("assemblyFile");

            return Activator.CreateComInstanceFrom(assemblyFile,
                                                   typeName,
                                                   hashValue, 
                                                   hashAlgorithm);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstance1"]/*' />
        public ObjectHandle CreateInstance(String assemblyName,
                                           String typeName,
                                           Object[] activationAttributes)
                                         
        {
            // jit does not check for that, so we should do it ...
            if (this == null)
                throw new NullReferenceException();

            if (assemblyName == null)
                throw new ArgumentNullException("assemblyName");

            return Activator.CreateInstance(assemblyName,
                                            typeName,
                                            activationAttributes);
        }
                                  
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceFrom1"]/*' />
        public ObjectHandle CreateInstanceFrom(String assemblyFile,
                                               String typeName,
                                               Object[] activationAttributes)
                                               
        {
            // jit does not check for that, so we should do it ...
            if (this == null)
                throw new NullReferenceException();

            return Activator.CreateInstanceFrom(assemblyFile,
                                                typeName,
                                                activationAttributes);
        }
                                         
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstance2"]/*' />
        public ObjectHandle CreateInstance(String assemblyName, 
                                           String typeName, 
                                           bool ignoreCase,
                                           BindingFlags bindingAttr, 
                                           Binder binder,
                                           Object[] args,
                                           CultureInfo culture,
                                           Object[] activationAttributes,
                                           Evidence securityAttributes)
        {
            // jit does not check for that, so we should do it ...
            if (this == null)
                throw new NullReferenceException();
            
            if (assemblyName == null)
                throw new ArgumentNullException("assemblyName");

            return Activator.CreateInstance(assemblyName,
                                            typeName,
                                            ignoreCase,
                                            bindingAttr,
                                            binder,
                                            args,
                                            culture,
                                            activationAttributes,
                                            securityAttributes);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceFrom2"]/*' />
        public ObjectHandle CreateInstanceFrom(String assemblyFile,
                                               String typeName, 
                                               bool ignoreCase,
                                               BindingFlags bindingAttr, 
                                               Binder binder,
                                               Object[] args,
                                               CultureInfo culture,
                                               Object[] activationAttributes,
                                               Evidence securityAttributes)

        {
            // jit does not check for that, so we should do it ...
            if (this == null)
                throw new NullReferenceException();

            return Activator.CreateInstanceFrom(assemblyFile,
                                                typeName,
                                                ignoreCase,
                                                bindingAttr,
                                                binder,
                                                args,
                                                culture,
                                                activationAttributes,
                                                securityAttributes);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Load"]/*' />
        public Assembly Load(AssemblyName assemblyRef)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return Assembly.InternalLoad(assemblyRef, false, null, ref stackMark);
        }
        
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Load1"]/*' />
        public Assembly Load(String assemblyString)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return Assembly.InternalLoad(assemblyString, null, ref stackMark);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Load2"]/*' />
        public Assembly Load(byte[] rawAssembly)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return Assembly.nLoadImage(rawAssembly,
                                       null, // symbol store
                                       null, // evidence
                                       ref stackMark);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Load3"]/*' />
        public Assembly Load(byte[] rawAssembly,
                             byte[] rawSymbolStore)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return Assembly.nLoadImage(rawAssembly,
                                       rawSymbolStore,
                                       null, // evidence
                                       ref stackMark);
        }


        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Load4"]/*' />
        [SecurityPermissionAttribute( SecurityAction.Demand, ControlEvidence = true )]
        public Assembly Load(byte[] rawAssembly,
                             byte[] rawSymbolStore,
                             Evidence securityEvidence)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return Assembly.nLoadImage(rawAssembly,
                                       rawSymbolStore,
                                       securityEvidence,
                                       ref stackMark);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Load5"]/*' />
        public Assembly Load(AssemblyName assemblyRef,
                             Evidence assemblySecurity)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return Assembly.InternalLoad(assemblyRef, false, assemblySecurity, ref stackMark);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Load7"]/*' />
        public Assembly Load(String assemblyString,
                             Evidence assemblySecurity)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return Assembly.InternalLoad(assemblyString, assemblySecurity, ref stackMark);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ExecuteAssembly"]/*' />
        public int ExecuteAssembly(String assemblyFile,
                                   Evidence assemblySecurity)
        {
            return ExecuteAssembly(assemblyFile, assemblySecurity, null);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ExecuteAssembly1"]/*' />
        public int ExecuteAssembly(String assemblyFile)
        {
            return ExecuteAssembly(assemblyFile, null, null);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ExecuteAssembly2"]/*' />
        public int ExecuteAssembly(String assemblyFile,
                                   Evidence assemblySecurity,
                                   String[] args)
        {
            Assembly assembly = Assembly.LoadFrom(assemblyFile, assemblySecurity);
    
            if (args == null)
                args = new String[0];

            return nExecuteAssembly(assembly, args);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ExecuteAssembly3"]/*' />
        public int ExecuteAssembly(String assemblyFile,
                                   Evidence assemblySecurity,
                                   String[] args,
                                   byte[] hashValue, 
                                   AssemblyHashAlgorithm hashAlgorithm)
        {
            Assembly assembly = Assembly.LoadFrom(assemblyFile, 
                                                  assemblySecurity,
                                                  hashValue,
                                                  hashAlgorithm);
            if (args == null)
                args = new String[0];

            return nExecuteAssembly(assembly, args);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CurrentDomain"]/*' />
        public static AppDomain CurrentDomain
        {
            get { return Thread.GetDomain(); }
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Evidence"]/*' />
        public Evidence Evidence
        {
            [SecurityPermissionAttribute( SecurityAction.Demand, ControlEvidence = true )]
            get {
                if (_SecurityIdentity == null)
                    nForceResolve();
                    
                return _SecurityIdentity.Copy();
            }           
        }
     
        internal Evidence InternalEvidence
        {
            get {
                if (_SecurityIdentity == null)
                    nForceResolve();
                    
                return _SecurityIdentity;
            }           
        }
      


        ///<include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.FriendlyName"]/*' />
        public String FriendlyName
        {
            get { return nGetFriendlyName(); }
        } 

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.BaseDirectory"]/*' />
        public String BaseDirectory
        {
            get {
                return FusionStore.ApplicationBase;
            }
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.RelativeSearchPath"]/*' />
        public String RelativeSearchPath
        {
            get { return FusionStore.PrivateBinPath; }
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ShadowCopyFiles"]/*' />
        public bool ShadowCopyFiles
        {
            get {
                String s = FusionStore.ShadowCopyFiles;
                if((s != null) && 
                   (String.Compare(s, "true", true, CultureInfo.InvariantCulture) == 0))
                    return true;
                else
                    return false;
            }
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ToString"]/*' />
        public override String ToString()
        {
            StringBuilder sb = new StringBuilder();
            
            String fn = nGetFriendlyName();
            if (fn != null) {
                sb.Append(Environment.GetResourceString("Loader_Name") + fn);
                sb.Append(Environment.NewLine);
            }
    
            if(_Policies == null || _Policies.Length == 0) 
                sb.Append(Environment.GetResourceString("Loader_NoContextPolicies")
                          + Environment.NewLine);
            else {
                sb.Append(Environment.GetResourceString("Loader_ContextPolicies")
                          + Environment.NewLine);
                for(int i = 0;i < _Policies.Length; i++) {
                    sb.Append(_Policies[i]);
                    sb.Append(Environment.NewLine);
                }
            }
    
            return sb.ToString();
        }
        
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.GetAssemblies"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Assembly[] GetAssemblies();
        
        // this is true when we've nuked the handles etc so really can't do anything
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool IsUnloadingForcedFinalize();

        // this is true when we've just started going through the finalizers and are forcing objects to finalize
        // so must be aware that certain infrastructure may have gone away
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.IsFinalizingForUnload"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern bool IsFinalizingForUnload();

        // Appends the following string to the private path. Valid paths
        // are of the form "bin;util/i386" etc.
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.AppendPrivatePath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public void AppendPrivatePath(String path)
        {
            if(path == null || path.Length == 0)
                return;
            
            String current = FusionStore.Value[(int) AppDomainSetup.LoaderInformation.PrivateBinPathValue];
            StringBuilder appendPath = new StringBuilder();

            if(current != null && current.Length > 0) {
                // See if the last character is a separator
                appendPath.Append(current);
                if((current[current.Length-1] != Path.PathSeparator) &&
                   (path[0] != Path.PathSeparator))
                    appendPath.Append(Path.PathSeparator);
            }
            appendPath.Append(path);

            String result = appendPath.ToString();
            InternalSetPrivateBinPath(result);
        }

        
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.ClearPrivatePath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public void ClearPrivatePath()
        {
            InternalSetPrivateBinPath(String.Empty);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetShadowCopyPath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public void ClearShadowCopyPath()
        {
            InternalSetShadowCopyPath(String.Empty);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetCachePath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public void SetCachePath(String path)
        {
            InternalSetCachePath(path);
        }
            
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetData"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public void SetData(String name, Object data)
        {     
            if (name == null)
                throw new ArgumentNullException("name");

            int key = AppDomainSetup.Locate(name);

            if(key == -1)
                LocalStore[name] = data;
            else {
                // Be sure to call these properties, not Value, since
                // these do more than call Value.
                switch(key) {
                case (int) AppDomainSetup.LoaderInformation.DynamicBaseValue:
                    FusionStore.DynamicBase = (string) data;
                    break;
                case (int) AppDomainSetup.LoaderInformation.DevPathValue:
                    FusionStore.DeveloperPath = (string) data;
                    break;
                case (int) AppDomainSetup.LoaderInformation.ShadowCopyDirectoriesValue:
                    FusionStore.ShadowCopyDirectories = (string) data;
                    break;
                case (int) AppDomainSetup.LoaderInformation.DisallowPublisherPolicyValue:
                    if(data != null)
                        FusionStore.DisallowPublisherPolicy = true;
                    else
                        FusionStore.DisallowPublisherPolicy = false;
                    break;
                case (int) AppDomainSetup.LoaderInformation.DisallowCodeDownloadValue:
                    if(data != null)
                        FusionStore.DisallowCodeDownload = true;
                    else
                        FusionStore.DisallowCodeDownload = false;
                    break;
                case (int) AppDomainSetup.LoaderInformation.DisallowBindingRedirectsValue:
                    if(data != null)
                        FusionStore.DisallowBindingRedirects = true;
                    else
                        FusionStore.DisallowBindingRedirects = false;
                    break;
                default:
                    FusionStore.Value[key] = (string) data;
                    break;
                }
            }
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.GetData"]/*' />
        public Object GetData(string name)
        {
            if(name == null)
                throw new ArgumentNullException("name");

            int key = AppDomainSetup.Locate(name);
            if(key == -1) {
                if(name.Equals(AppDomainSetup.LoaderOptimizationKey))
                    return FusionStore.LoaderOptimization;
                else 
                    return LocalStore[name];
            }
            else {
                // Be sure to call these properties, not Value, so
                // that the appropriate permission demand will be done
                switch(key) {
                case (int) AppDomainSetup.LoaderInformation.ApplicationBaseValue:
                    return FusionStore.ApplicationBase;
                case (int) AppDomainSetup.LoaderInformation.ConfigurationFileValue:
                    return FusionStore.ConfigurationFile;
                case (int) AppDomainSetup.LoaderInformation.DynamicBaseValue:
                    return FusionStore.DynamicBase;
                case (int) AppDomainSetup.LoaderInformation.DevPathValue:
                    return FusionStore.DeveloperPath;
                case (int) AppDomainSetup.LoaderInformation.ApplicationNameValue:
                    return FusionStore.ApplicationName;
                case (int) AppDomainSetup.LoaderInformation.PrivateBinPathValue:
                    return FusionStore.PrivateBinPath;
                case (int) AppDomainSetup.LoaderInformation.PrivateBinPathProbeValue:
                    return FusionStore.PrivateBinPathProbe;
                case (int) AppDomainSetup.LoaderInformation.ShadowCopyDirectoriesValue:
                    return FusionStore.ShadowCopyDirectories;
                case (int) AppDomainSetup.LoaderInformation.ShadowCopyFilesValue:
                    return FusionStore.ShadowCopyFiles;
                case (int) AppDomainSetup.LoaderInformation.CachePathValue:
                    return FusionStore.CachePath;
                case (int) AppDomainSetup.LoaderInformation.LicenseFileValue:
                    return FusionStore.LicenseFile;
                case (int) AppDomainSetup.LoaderInformation.DisallowPublisherPolicyValue:
                    return FusionStore.DisallowPublisherPolicy;
                case (int) AppDomainSetup.LoaderInformation.DisallowCodeDownloadValue:
                    return FusionStore.DisallowCodeDownload;
                default:
#if _DEBUG
                    BCLDebug.Assert(false, "Need to handle new LoaderInformation value in AppDomain.GetData()");
#endif
                    return null;
                }
            }
        }
        
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.GetCurrentThreadId"]/*' />
        [DllImport(Microsoft.Win32.Win32Native.KERNEL32)]
        public static extern int GetCurrentThreadId();

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.Unload"]/*' />
        [SecurityPermissionAttribute( SecurityAction.Demand, ControlAppDomain = true )]
        public static void Unload(AppDomain domain)
        {
            if (domain == null)
                throw new ArgumentNullException("domain");

            try {
                GetDefaultDomain().GetUnloadWorker().Unload(domain);
            }
            catch(Exception e) {
                throw e;    // throw it again to reset stack trace
            }
        }

        // Explicitly set policy for a domain (providing policy hasn't been set
        // previously). Making this call will guarantee that previously loaded
        // assemblies will be granted permissions based on the default machine
        // policy that was in place prior to this call.
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetAppDomainPolicy"]/*' />
        [SecurityPermission(SecurityAction.LinkDemand, ControlDomainPolicy=true)]
        public void SetAppDomainPolicy(PolicyLevel domainPolicy)
        {
            if (domainPolicy == null)
                throw new ArgumentNullException("domainPolicy");

            // Check that policy has not been set previously.
            lock (this) {
                if (_HasSetPolicy)
                    throw new PolicyException(Environment.GetResourceString("Policy_PolicyAlreadySet"));
                _HasSetPolicy = true;
            }

            // Ensure that assemblies that are already loaded (and may not have
            // resolved policy due to lazy initialization) resolve against the
            // old (default) policy before we change anything.
            nForcePolicyResolution();
            
            // Ensure that this AppDomain is resolved against the old/current
            // policy before we change anything.
            PermissionSet grantedSet;
            PermissionSet refusedSet;
            nForceResolve();
            nGetGrantSet( out grantedSet, out refusedSet );

            // Add the new policy level.
            SecurityManager.AddLevel(domainPolicy);
        }

        // Set the default principal object to be attached to threads if they
        // attempt to bind to a principal while executing in this appdomain. The
        // default can only be set once.
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetThreadPrincipal"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public void SetThreadPrincipal(IPrincipal principal)
        {
            if (principal == null)
                throw new ArgumentNullException("principal");
        
            lock (this) {
                // Check that principal has not been set previously.
                if (_DefaultPrincipal != null)
                    throw new PolicyException(Environment.GetResourceString("Policy_PrincipalTwice"));

                _DefaultPrincipal = principal;
            }
        }

        // Similar to the above, but sets the class of principal to be created
        // instead.
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetPrincipalPolicy"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPrincipal)]
        public void SetPrincipalPolicy(PrincipalPolicy policy)
        {
            _PrincipalPolicy = policy;
        }

        // This method gives AppDomain an infinite life time by preventing a lease from being
        // created
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.InitializeLifetimeService"]/*' />
        public override Object InitializeLifetimeService()
        {
            return null;
        }

        // This is useful for requesting execution of some code
        // in another appDomain ... the delegate may be defined 
        // on a marshal-by-value object or a marshal-by-ref or 
        // contextBound object.
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DoCallBack"]/*' />
        public void DoCallBack(CrossAppDomainDelegate callBackDelegate)
        {
            if (callBackDelegate == null)
                throw new ArgumentNullException("callBackDelegate");

            callBackDelegate();        
        }
       
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.DynamicDirectory"]/*' />
        public String DynamicDirectory
        {
            get {
                String dyndir = GetDynamicDir();
                if (dyndir != null)
                    new FileIOPermission( FileIOPermissionAccess.PathDiscovery, dyndir ).Demand();

                return dyndir;
            }
        }
        
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateDomain"]/*' />
        public static AppDomain CreateDomain(String friendlyName,
                                             Evidence securityInfo) // Optional
        {
            return CreateDomain(friendlyName,
                                securityInfo,
                                null);
        }
    
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateDomain1"]/*' />
        public static AppDomain CreateDomain(String friendlyName,
                                             Evidence securityInfo, // Optional
                                             String appBasePath,
                                             String appRelativeSearchPath,
                                             bool shadowCopyFiles)
        {            
            AppDomainSetup info = new AppDomainSetup();
            info.ApplicationBase = appBasePath;
            info.PrivateBinPath = appRelativeSearchPath;
            if(shadowCopyFiles)
                info.ShadowCopyFiles = "true";

            return CreateDomain(friendlyName,
                                securityInfo,
                                info);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateDomain3"]/*' />
        public static AppDomain CreateDomain(String friendlyName)
        {
            return CreateDomain(friendlyName, null, null);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern private String GetDynamicDir();

        // Private helpers called from unmanaged code.

        // Marshal a single object into a serialized blob.
        private static byte[] MarshalObject(Object o)
        {
            CodeAccessPermission.AssertAllPossible();

            return Serialize(o);
        }

        // Marshal two objects into serialized blobs.
        private static byte[] MarshalObjects(Object o1, Object o2, out byte[] blob2)
        {
            CodeAccessPermission.AssertAllPossible();

            byte[] blob1 = Serialize(o1);
            blob2 = Serialize(o2);
            return blob1;
        }

        // Unmarshal a single object from a serialized blob.
        private static Object UnmarshalObject(byte[] blob)
        {
            CodeAccessPermission.AssertAllPossible();

            return Deserialize(blob);
        }

        // Unmarshal two objects from serialized blobs.
        private static Object UnmarshalObjects(byte[] blob1, byte[] blob2, out Object o2)
        {
            CodeAccessPermission.AssertAllPossible();

            Object o1 = Deserialize(blob1);
            o2 = Deserialize(blob2);
            return o1;
        }

        // Helper routines.
        private static byte[] Serialize(Object o)
        {
            if (o == null)
                return null;
            MemoryStream ms = CrossAppDomainSerializer.SerializeObject(o);
            
            return ms.ToArray();
        }

        private static Object Deserialize(byte[] blob)
        {
            if (blob == null)
                return null;
                
            return CrossAppDomainSerializer.DeserializeObject(new MemoryStream(blob));
        }

        private AppDomain() {
            throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Constructor));
        }

        private void Initialize(IDictionary properties)  // Optional
        {
            IDictionaryEnumerator ide = properties.GetEnumerator();
            ide.Reset();
            ide.MoveNext();
            
            do {
                LocalStore[(String) ide.Key] = ide.Value;
            } while (ide.MoveNext());
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern AssemblyBuilder nCreateDynamicAssembly(AssemblyName name,
                               Evidence identity,
                               ref StackCrawlMark stackMark,
                               PermissionSet requiredPermissions,
                               PermissionSet optionalPermissions,
                               PermissionSet refusedPermissions,
                               AssemblyBuilderAccess access);

        internal AssemblyBuilder InternalDefineDynamicAssembly(
            AssemblyName            name,
            AssemblyBuilderAccess   access,
            String                  dir,
            Evidence                evidence,
            PermissionSet           requiredPermissions,
            PermissionSet           optionalPermissions,
            PermissionSet           refusedPermissions,
            ref StackCrawlMark      stackMark)
        {
            if (name == null)
                throw new ArgumentNullException("name");

            // Set the public key from the key pair if one has been provided.
            // (Overwite any public key in the Assembly name, since it's no
            // longer valid to have a disparity).
            if (name.KeyPair != null)
                name.SetPublicKey(name.KeyPair.PublicKey);

            // If the caller is trusted they can supply identity
            // evidence for the new assembly. Otherwise we copy the
            // current grant and deny sets from the caller's assembly,
            // inject them into the new assembly and mark policy as
            // resolved. If/when the assembly is persisted and
            // reloaded, the normal rules for gathering evidence will
            // be used.
            if (evidence != null)
                new SecurityPermission(SecurityPermissionFlag.ControlEvidence).Demand();
    
            AssemblyBuilder assemblyBuilder = nCreateDynamicAssembly(name,
                                                                     evidence,
                                                                     ref stackMark,
                                                                     requiredPermissions,
                                                                     optionalPermissions,
                                                                     refusedPermissions,
                                                                     access);

            assemblyBuilder.m_assemblyData = new AssemblyBuilderData(assemblyBuilder,
                                                                     name.Name,
                                                                     access,
                                                                     dir);
            assemblyBuilder.m_assemblyData.AddPermissionRequests(requiredPermissions,
                                                                 optionalPermissions,
                                                                 refusedPermissions);
            return assemblyBuilder;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int nExecuteAssembly(Assembly assembly, String[] args);

        internal DomainSpecificRemotingData RemotingData
        {
            get 
            { 
                if (_RemotingData == null) {
                    lock(this) {
                        if (_RemotingData == null)
                            _RemotingData = new DomainSpecificRemotingData();
                    }
                }

                return _RemotingData;
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String nGetFriendlyName();
     
        private void OnUnloadEvent()
        {
            if (DomainUnload != null)
                DomainUnload(this, null);
        }
   
        private void OnAssemblyLoadEvent(Assembly LoadedAssembly)
        {
            if (AssemblyLoad != null) {
                AssemblyLoadEventArgs ea = new AssemblyLoadEventArgs(LoadedAssembly);
                AssemblyLoad(this, ea);
            }
        }
    
        private void OnUnhandledExceptionEvent(Object exception, bool isTerminating)
        {
            if (UnhandledException != null) {
                UnhandledExceptionEventArgs ueEvent = new UnhandledExceptionEventArgs(exception, isTerminating);
                UnhandledException(this, ueEvent);
            } 
        }

        private Assembly OnResourceResolveEvent(String resourceName)
        {
            if (ResourceResolve == null)
                return null;

            Delegate[] ds = ResourceResolve.GetInvocationList();
            int len = ds.Length;
            for (int i = 0; i < len; i++) {
                Assembly ret = ((ResolveEventHandler) ds[i])(this, new ResolveEventArgs(resourceName));
                if (ret != null)
                    return ret;              
            }

            return null;
        }
        
        private Assembly OnTypeResolveEvent(String typeName)
        {
            if (TypeResolve == null)
                return null;

            Delegate[] ds = TypeResolve.GetInvocationList();
            int len = ds.Length;
            for (int i = 0; i < len; i++) {
                Assembly ret = ((ResolveEventHandler) ds[i])(this, new ResolveEventArgs(typeName));
                if (ret != null)
                    return ret;              
            }

            return null;
        }
        
        private Assembly OnAssemblyResolveEvent(String assemblyFullName)
        {
            if (AssemblyResolve == null)
                return null;

            Delegate[] ds = AssemblyResolve.GetInvocationList();
            int len = ds.Length;
            for (int i = 0; i < len; i++) {
                Assembly ret = ((ResolveEventHandler) ds[i])(this, new ResolveEventArgs(assemblyFullName));
                if (ret != null)
                    return ret;              
            }

            return null;
        }
    
        private static void OnExitProcess()
        {
            AppDomain defaultDomain = GetDefaultDomain();
            if (defaultDomain.ProcessExit != null)
                defaultDomain.ProcessExit(defaultDomain, null);
        }    

        private AppDomainSetup FusionStore
        {
            get {
#if _DEBUG
                BCLDebug.Assert(_FusionStore != null, 
                                "Fusion store has not been correctly setup in this domain");
#endif
                return _FusionStore;
            }
        }
        
        private Hashtable LocalStore
        {
            get { 
                if (_LocalStore != null)
                    return _LocalStore;
                else {
                    _LocalStore = Hashtable.Synchronized(new Hashtable());
                    return _LocalStore;
                }
            }
        }

        private void ResetBindingRedirects()
        {
            _FusionStore.DisallowBindingRedirects = false;
        }

        // always call this on the default domain so only have one instance created
        // per process
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern UnloadWorker GetUnloadWorker();
        
        // This will throw a CannotUnloadAppDomainException if the appdomain is in 
        // another process.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Int32 GetIdForUnload(AppDomain domain);

        // Used to determine if server object context is valid in
        // x-domain remoting scenarios.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool IsDomainIdValid(Int32 id);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Int32 GetId();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static internal extern AppDomain GetDefaultDomain();

        // This is here for com interop only. You must set your domain
        // explicitly to where the server exists after using this
        // call. If you do not know what that means then dont use this
        // method
        private static Object GetServerObject(Object o) 
        {
            Object ob = null;
            if(o is MarshalByRefObject)
                ob = RemotingServices.GetServerObjectForProxy((MarshalByRefObject) o);

            return ob;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nForcePolicyResolution();

        // Internal routine to retrieve the default principal object. If this is
        // called before the principal has been explicitly set, it will
        // automatically allocate a default principal based on the policy set by
        // SetPrincipalPolicy.
        internal IPrincipal GetThreadPrincipal()
        {
            IPrincipal principal = null;

            lock (this) {
                if (_DefaultPrincipal == null) {
                    switch (_PrincipalPolicy) {
                    case PrincipalPolicy.NoPrincipal:
                        principal = null;
                        break;
                    case PrincipalPolicy.UnauthenticatedPrincipal:
                        principal = new GenericPrincipal(new GenericIdentity("", ""),
                                                         new String[] {""});
                        break;
                    case PrincipalPolicy.WindowsPrincipal:
                        principal = new WindowsPrincipal(WindowsIdentity.GetCurrent());
                        break;
                    default:
                        principal = null;
                        break;
                    }
                }
                else
                    principal = _DefaultPrincipal;

                return principal;
            }
        }

        internal Context GetDefaultContext()
        {
            if (_DefaultContext == null)
            {
                lock(this) {
                    // if it has not been created we ask the Context class to 
                    // create a new default context for this appdomain.
                    if (_DefaultContext == null)
                        _DefaultContext = Context.CreateDefaultContext();
                }
            }
            return _DefaultContext;
        }


        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateDomain4"]/*' />
        [SecurityPermissionAttribute( SecurityAction.Demand, ControlAppDomain = true )]
        public static AppDomain CreateDomain(String friendlyName,
                                             Evidence securityInfo,
                                             AppDomainSetup info)
        {
            if (friendlyName == null)
                throw new ArgumentNullException(Environment.GetResourceString("ArgumentNull_String"));
                
            // If evidence is provided, we check to make sure that is allowed.    
            if (securityInfo != null)
                new SecurityPermission( SecurityPermissionFlag.ControlEvidence ).Demand();

            AppDomain proxy = CreateBasicDomain();
            // move into the appdomain to finish the initialization
            RemotelySetupRemoteDomain(proxy,
                                      friendlyName,
                                      info,
                                      securityInfo,
                                      securityInfo == null ? AppDomain.CurrentDomain.InternalEvidence : null,
                                      AppDomain.CurrentDomain.GetSecurityDescriptor());
            
            return proxy;
        }

        private void SetupFusionStore(AppDomainSetup info)
        {

            StringBuilder config = null;

            // Create the application base and configuration file from the imagelocation
            // passed in or use the Win32 Image name.
            if(info.Value[(int) AppDomainSetup.LoaderInformation.ApplicationBaseValue] == null || 
                info.Value[(int) AppDomainSetup.LoaderInformation.ConfigurationFileValue] == null ) {
                char[] sep = { '\\', '/'};
                String imageLocation = RuntimeEnvironment.GetModuleFileName();

                int i = imageLocation.LastIndexOfAny(sep);
                String appBase = null;
                if(i == -1) 
                    config = new StringBuilder(imageLocation);
                else {
                    appBase = imageLocation.Substring(0, i+1);
                    config = new StringBuilder(imageLocation.Substring(i+1));
                }

                config.Append(AppDomainSetup.ConfigurationExtenstion);
                // If there was no configuration file but we built 
                // the appbase from the module name then add the
                // default configuration file.
                if((info.Value[(int) AppDomainSetup.LoaderInformation.ConfigurationFileValue] == null) &&
                    (config != null))
                    info.ConfigurationFile = config.ToString();

                if((info.Value[(int) AppDomainSetup.LoaderInformation.ApplicationBaseValue] == null) &&
                    (appBase!=null))
                    info.ApplicationBase = appBase;
            }



            // If there is no relative path then check the
            // environment
            if(info.Value[(int) AppDomainSetup.LoaderInformation.PrivateBinPathValue] == null)
                info.PrivateBinPath = Environment.nativeGetEnvironmentVariable(AppDomainSetup.PrivateBinPathEnvironmentVariable);

            // Add the developer path if it exists on this
            // machine.
            info.DeveloperPath = RuntimeEnvironment.GetDeveloperPath();

            // Set up the fusion context
            IntPtr fusionContext = GetFusionContext();
            info.SetupFusionContext(fusionContext);

            // This must be the last action taken.
            _FusionStore = info;
        }


        // used to package up evidence, so it can be serialized
        //   for the call to InternalRemotelySetupRemoteDomain
        [Serializable]
        private class EvidenceCollection
        {
            public Evidence ProvidedSecurityInfo;
            public Evidence CreatorsSecurityInfo;
        }


        // Used to switch into other AppDomain and call SetupRemoteDomain.
        //   We cannot simply call through the proxy, because if there
        //   are any remoting sinks registered, they can add non-mscorlib
        //   objects to the message (causing an assembly load exception when
        //   we try to deserialize it on the other side)
        private static void RemotelySetupRemoteDomain(AppDomain appDomainProxy,
                                                      String friendlyName,
                                                      AppDomainSetup setup,
                                                      Evidence providedSecurityInfo,
                                                      Evidence creatorsSecurityInfo,
                                                      IntPtr parentSecurityDescriptor)
        {
            BCLDebug.Assert(RemotingServices.IsTransparentProxy(appDomainProxy),
                            "Expected a proxy to the AppDomain.");

            // get context and appdomain id            
            int contextId, domainId;
            RemotingServices.GetServerContextAndDomainIdForProxy(
               appDomainProxy, out contextId, out domainId);
                     

            // serialize evidence
            EvidenceCollection evidenceCollection = null;
            if ((providedSecurityInfo != null) ||
                (creatorsSecurityInfo != null)) {
                evidenceCollection = new EvidenceCollection();
                evidenceCollection.ProvidedSecurityInfo = providedSecurityInfo;
                evidenceCollection.CreatorsSecurityInfo = creatorsSecurityInfo;
            }

            bool bNeedGenericFormatter = false;
            char[] serProvidedEvidence = null, serCreatorEvidence = null;
            byte[] serializedEvidence = null;
            
            if (providedSecurityInfo != null) {
                serProvidedEvidence = PolicyManager.MakeEvidenceArray(providedSecurityInfo, true);
                if (serProvidedEvidence == null)
                    bNeedGenericFormatter = true;
            }
            if (creatorsSecurityInfo != null && !bNeedGenericFormatter) {
                serCreatorEvidence = PolicyManager.MakeEvidenceArray(creatorsSecurityInfo, true);
                if (serCreatorEvidence == null)
                    bNeedGenericFormatter = true;
            }
            if (evidenceCollection != null && bNeedGenericFormatter) {
                serProvidedEvidence = serCreatorEvidence = null;
                serializedEvidence =
                    CrossAppDomainSerializer.SerializeObject(evidenceCollection).GetBuffer();                
            }
        
            InternalRemotelySetupRemoteDomain(contextId,
                                              domainId,
                                              friendlyName, 
                                              setup,
                                              parentSecurityDescriptor,
                                              serProvidedEvidence,
                                              serCreatorEvidence,
                                              serializedEvidence);    

        } // RemotelySetupRemoteDomain


        [MethodImplAttribute(MethodImplOptions.NoInlining)]
        private static void InternalRemotelySetupRemoteDomainHelper (String friendlyName,
                                                                     AppDomainSetup setup,
                                                                     IntPtr parentSecurityDescriptor,
                                                                     char[] serProvidedEvidence,
                                                                     char[] serCreatorEvidence,
                                                                     byte[] serializedEvidence)
        {
            AppDomain ad = Thread.CurrentContext.AppDomain;

            ad.SetupFusionStore(new AppDomainSetup(setup));

            // extract evidence
            Evidence providedSecurityInfo = null;
            Evidence creatorsSecurityInfo = null;

            if (serializedEvidence == null) {
                if (serProvidedEvidence != null)
                    providedSecurityInfo = new Evidence(serProvidedEvidence);
                if (serCreatorEvidence != null)
                    creatorsSecurityInfo = new Evidence(serCreatorEvidence);
            }
            else {
                EvidenceCollection evidenceCollection = (EvidenceCollection)
                    CrossAppDomainSerializer.DeserializeObject(new MemoryStream(serializedEvidence));
                providedSecurityInfo  = evidenceCollection.ProvidedSecurityInfo;
                creatorsSecurityInfo  = evidenceCollection.CreatorsSecurityInfo;
            }

            // Set up security
            ad.SetupDomainSecurity(friendlyName,
                                   providedSecurityInfo, 
                                   creatorsSecurityInfo,
                                   parentSecurityDescriptor);
        }

        private static void InternalRemotelySetupRemoteDomain(int contextId, 
                                                              int domainId,
                                                              String friendlyName,
                                                              AppDomainSetup setup,
                                                              IntPtr parentSecurityDescriptor,
                                                              char[] serProvidedEvidence,
                                                              char[] serCreatorEvidence,
                                                              byte[] serializedEvidence)
        {
            bool bNeedToReset = false;

            ContextTransitionFrame frame = new ContextTransitionFrame();

            try {
                // Set the current context to the given default Context
                // (of the new AppDomain).
                Thread.CurrentThread.EnterContextInternal(null, contextId, domainId, ref frame);
                bNeedToReset = true;

                InternalRemotelySetupRemoteDomainHelper(friendlyName, setup, parentSecurityDescriptor,
                                                        serProvidedEvidence, serCreatorEvidence, serializedEvidence);

                // Set the current context to the old context
                Thread.CurrentThread.ReturnToContext(ref frame);
                bNeedToReset = false;
            }
            finally {
                // Restore the old app domain
                if (bNeedToReset)
                    Thread.CurrentThread.ReturnToContext(ref frame);
            }    
        } // InternalSetupRemoteDomain

        // This routine is called from unmanaged code to 
        // set the default fusion context.
        private void SetupDomain(LoaderOptimization policy, String path, String configFile)
        {
            // It is possible that we could have multple threads initializing
            // the default domain. We will just take the winner of these two.
            // (eg. one thread doing a com call and another doing attach for IJW)
            if(_FusionStore == null) {
                lock (this) {
                    if(_FusionStore == null) {
                        AppDomainSetup setup = new AppDomainSetup();
                        if(path != null)
                            setup.Value[(int) AppDomainSetup.LoaderInformation.ApplicationBaseValue] = path;
                        if(configFile != null)
                            setup.Value[(int) AppDomainSetup.LoaderInformation.ConfigurationFileValue] = configFile;

                        // Default fusion context starts with binding redirects turned off.
                        if((policy & LoaderOptimization.DisallowBindings) != 0)
                            setup.DisallowBindingRedirects = true;

                        SetupFusionStore(setup);
                    }
                }
            }

            // Leave only the bits associated with the domain mask
            policy &= LoaderOptimization.DomainMask;

            if(policy != LoaderOptimization.NotSpecified) {
#if _DEBUG
                BCLDebug.Assert(FusionStore.LoaderOptimization == LoaderOptimization.NotSpecified,
                                "It is illegal to change the Loader optimization on a domain");
#endif
                FusionStore.LoaderOptimization = policy;
                UpdateLoaderOptimization((int) FusionStore.LoaderOptimization);
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern IntPtr GetFusionContext();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern IntPtr GetSecurityDescriptor();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern AppDomain CreateBasicDomain();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void SetupDomainSecurity(String friendlyName,
                                                 Evidence providedEvidence,
                                                 Evidence creatorsEvidence,
                                                 IntPtr creatorsSecurityDescriptor);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void UpdateLoaderOptimization(int optimization);

        
        
        private Evidence CreateSecurityIdentity(Evidence rootAssemblyEvidence, Evidence additionalEvidence)
        {
            Evidence evidence;
            
            if (rootAssemblyEvidence != null)
                evidence = rootAssemblyEvidence;
            else
                evidence = new Evidence();

            if (additionalEvidence != null)
                evidence.MergeWithNoDuplicates(additionalEvidence);

            _SecurityIdentity = evidence;
            return _SecurityIdentity;
        }       
       

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis()
        {
            _Policies = null;
        }
#endif

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetShadowCopyPath1"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public void SetShadowCopyPath(String path)
        {
            InternalSetShadowCopyPath(path);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetShadowCopyFiles"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public void SetShadowCopyFiles()
        {
            InternalSetShadowCopyFiles();
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetDynamicBase"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public void SetDynamicBase(String path)
        {
            InternalSetDynamicBase(path);
        }

        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.SetupInformation"]/*' />
        public AppDomainSetup SetupInformation
        {
            get {
                return new AppDomainSetup(FusionStore);
            }
        }

        internal void InternalSetShadowCopyPath(String path)
        {
            IntPtr fusionContext = GetFusionContext();
            AppDomainSetup.UpdateContextProperty(fusionContext, AppDomainSetup.ShadowCopyDirectoriesKey, path);
            FusionStore.ShadowCopyDirectories = path;
        }

        internal void InternalSetShadowCopyFiles()
        {
            IntPtr fusionContext = GetFusionContext();
            AppDomainSetup.UpdateContextProperty(fusionContext, AppDomainSetup.ShadowCopyFilesKey, "true");
            FusionStore.ShadowCopyFiles = "true";
        }

        internal void InternalSetCachePath(String path)
        {
            IntPtr fusionContext = GetFusionContext();
            AppDomainSetup.UpdateContextProperty(fusionContext, AppDomainSetup.CachePathKey, path);
            FusionStore.CachePath = path;
        }

        internal void InternalSetPrivateBinPath(String path)
        {
            IntPtr fusionContext = GetFusionContext();
            AppDomainSetup.UpdateContextProperty(fusionContext, AppDomainSetup.PrivateBinPathKey, path);
            FusionStore.PrivateBinPath = path;
        }
            
        internal void InternalSetDynamicBase(String path)
        {
            IntPtr fusionContext = GetFusionContext();
            FusionStore.DynamicBase = path;

            AppDomainSetup.UpdateContextProperty(fusionContext, AppDomainSetup.DynamicBaseKey, FusionStore.Value[(int) AppDomainSetup.LoaderInformation.DynamicBaseValue]);
        }


        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern String IsStringInterned(String str);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern String GetOrInternString(String str);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nForceResolve();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nGetGrantSet( out PermissionSet granted, out PermissionSet denied );

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool IsTypeUnloading(Type type);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void AddAppBase();

        [MethodImplAttribute(MethodImplOptions.InternalCall)] 
        internal static extern void nUnload(Int32 domainInternal, Thread requestingThread);
           
        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceAndUnwrap"]/*' />
        public Object CreateInstanceAndUnwrap(String assemblyName,
                                              String typeName)                                         
        {
            ObjectHandle oh = CreateInstance(assemblyName, typeName);
            if (oh == null)
                return null;

            return oh.Unwrap();
        } // CreateInstanceAndUnwrap


        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceAndUnwrap1"]/*' />
        public Object CreateInstanceAndUnwrap(String assemblyName, 
                                              String typeName,
                                              Object[] activationAttributes)
        {
            ObjectHandle oh = CreateInstance(assemblyName, typeName, activationAttributes);
            if (oh == null)
                return null; 

            return oh.Unwrap();
        } // CreateInstanceAndUnwrap


        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceAndUnwrap2"]/*' />
        public Object CreateInstanceAndUnwrap(String assemblyName, 
                                              String typeName, 
                                              bool ignoreCase,
                                              BindingFlags bindingAttr, 
                                              Binder binder,
                                              Object[] args,
                                              CultureInfo culture,
                                              Object[] activationAttributes,
                                              Evidence securityAttributes)
        {
            ObjectHandle oh = CreateInstance(assemblyName, typeName, ignoreCase, bindingAttr,
                binder, args, culture, activationAttributes, securityAttributes);
            if (oh == null)
                return null; 
            
            return oh.Unwrap();
        } // CreateInstanceAndUnwrap



        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceFromAndUnwrap"]/*' />
        public Object CreateInstanceFromAndUnwrap(String assemblyName,
                                                  String typeName)
        {
            ObjectHandle oh = CreateInstanceFrom(assemblyName, typeName);
            if (oh == null)
                return null;  

            return oh.Unwrap();                
        } // CreateInstanceAndUnwrap


        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceFromAndUnwrap1"]/*' />
        public Object CreateInstanceFromAndUnwrap(String assemblyName,
                                                  String typeName,
                                                  Object[] activationAttributes)
        {
            ObjectHandle oh = CreateInstanceFrom(assemblyName, typeName, activationAttributes);
            if (oh == null)
                return null; 

            return oh.Unwrap();
        } // CreateInstanceAndUnwrap


        /// <include file='doc\AppDomain.uex' path='docs/doc[@for="AppDomain.CreateInstanceFromAndUnwrap2"]/*' />
        public Object CreateInstanceFromAndUnwrap(String assemblyName, 
                                                  String typeName, 
                                                  bool ignoreCase,
                                                  BindingFlags bindingAttr, 
                                                  Binder binder,
                                                  Object[] args,
                                                  CultureInfo culture,
                                                  Object[] activationAttributes,
                                                  Evidence securityAttributes)
        {
            ObjectHandle oh = CreateInstanceFrom(assemblyName, typeName, ignoreCase, bindingAttr,
                binder, args, culture, activationAttributes, securityAttributes);
            if (oh == null)
                return null; 

            return oh.Unwrap();
        } // CreateInstanceAndUnwrap

        private static AppDomainSetup InternalCreateDomainSetup(String imageLocation)
        {
            int i = imageLocation.LastIndexOf('\\');
            BCLDebug.Assert(i != -1, "invalid image location");

            AppDomainSetup info = new AppDomainSetup();
            info.ApplicationBase = imageLocation.Substring(0, i+1);

            StringBuilder config = new StringBuilder(imageLocation.Substring(i+1));
            config.Append(AppDomainSetup.ConfigurationExtenstion);
            info.ConfigurationFile = config.ToString();

            return info;
        }

        // Used by the validator for testing but not executing an assembly
        private static AppDomain InternalCreateDomain(String imageLocation)
        {
            AppDomainSetup info = InternalCreateDomainSetup(imageLocation);

            return CreateDomain("Validator",
                                null,
                                info);
        }

        private void InternalSetDomainContext(String imageLocation)
        {
            SetupFusionStore(InternalCreateDomainSetup(imageLocation));
        }
    }

    //  CallBacks provide a facility to request execution of some code
    //  in another context/appDomain.
    //  CrossAppDomainDelegate type is defined for appdomain call backs. 
    //  The delegate used to request a callbak through the DoCallBack method
    //  must be of CrossContextDelegate type.
    /// <include file='doc\AppDomain.uex' path='docs/doc[@for="CrossAppDomainDelegate"]/*' />
    public delegate void CrossAppDomainDelegate();    

    // Moved to avoid nested class loading problems in EE.
    internal class UnloadWorker : MarshalByRefObject {
        internal void Unload(AppDomain domain)
        {
            if (! Thread.CurrentThread.IsRunningInDomain(AppDomain.GetIdForUnload(domain))) {
                UnloadWithLock(domain, null);
                return;
            }

            // we can't unload if the current thread is running in the target AD, so spin off
            // a new one that will start in the default domain and will unload it there
            new UnloadThreadWorker().Unload(domain);
        }

        // The requestingThread parm is used for case where need to unload on a separate thread so that
        // we don't abort the requesting thread until all the other threads are out so it can receive
        // notification if the unload failed.
        internal void UnloadWithLock(AppDomain domain, Thread requestingThread)
        {
            // the lock prevents more than one thread from unloading at a time. If someone has already swooped in and
            // unloaded this AD before we get the lock, then GetIdForUnload will throw AppDomainUnloadedException
            lock (this) {
                Int32 domainID = AppDomain.GetIdForUnload(domain);
                AppDomain.nUnload(domainID, requestingThread);

                // This will clear client side identities of any proxies
                // to objects in the unloaded domain that this domain used.
                RemotingServices.DomainUnloaded(domainID);
            }
        }
        // This method gives the UnloadWorker an infinite life time by preventing a lease from being
        // created
        public override Object InitializeLifetimeService()
        {
            return null;
        }

    }

    // Moved to avoid nested class loading problems in EE.
    internal class UnloadThreadWorker   
    {
        AppDomain _domain;
        Exception _unloadException;
        Thread    _requestingThread;

        public void Unload(AppDomain domain)
        {
            _unloadException = null;
            _domain = domain;
            _requestingThread = Thread.CurrentThread;
            Thread thread = new Thread(new ThreadStart(ThreadStart));
            thread.Start();

            // waiting for either completion of unload or abort of our thread. We won't be 
            // aborted unless we are the last one in

            while (true) {
                if (thread.Join(100)) {   
                    // if we didn't get unwound via an exception, then must be because the unload
                    // failed, so throw whatever exception occurred.
                    Message.DebugOut("In UnloadThreadWorker::Unload rethrowing exception " + _unloadException);
#if DISPLAY_UNLOAD_DEBUG_INFO       
                    Console.WriteLine("MID " + Convert.ToString(AppDomain.GetCurrentThreadId(), 16) + " In UnloadThreadWorker::Unload rethrowing exception " + _unloadException);
#endif
                    throw _unloadException;
                }
            }
        }

        public void ThreadStart()
        {
            Message.DebugOut("In UnloadThreadWorker::ThreadStart in AD " + Thread.GetDomain().ToString());
#if DISPLAY_UNLOAD_DEBUG_INFO       
            Console.WriteLine("MID " + Convert.ToString(AppDomain.GetCurrentThreadId(), 16) + " In UnloadThreadWorker::ThreadStart in AD " + Thread.GetDomain().ToString());
#endif
            try {
                // we will be running in the default domain already - EE will assert if not
                AppDomain.CurrentDomain.GetUnloadWorker().UnloadWithLock(_domain, _requestingThread);
            }
            catch(Exception e) {
                Message.DebugOut("In UnloadThreadWorker::ThreadStart caught exception " + e);
#if DISPLAY_UNLOAD_DEBUG_INFO       
                Console.WriteLine("MID " + Convert.ToString(AppDomain.GetCurrentThreadId(), 16) + " In UnloadThreadWorker::ThreadStart caught exception " + e);
#endif
                _unloadException = e;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\boolean.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Boolean
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The boolean class serves as a wrapper for the primitive
** type boolean.
**
** Date:  August 8, 1998
** 
===========================================================*/
namespace System {
    
	using System;
	using System.Globalization;
    // The Boolean class provides the
    // object representation of the boolean primitive type.
	/// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean"]/*' />
    [Serializable()] 
	public struct Boolean : IComparable, IConvertible {
    
      //
      // Member Variables
      //
      private bool m_value;
    
    
      //
      // Public Constants
      //
      
      // The true value. 
      // 
      internal const int True = 1; 
      
      // The false value.
      // 
      internal const int False = 0; 
      
      // The string representation of true.
      // 
      /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.TrueString"]/*' />
      public static readonly String TrueString  = "True";
      
      // The string representation of false.
      // 
      /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.FalseString"]/*' />
      public static readonly String FalseString = "False";

      //
      // Overriden Instance Methods
      //
      /*=================================GetHashCode==================================
      **Args:  None
      **Returns: 1 or 0 depending on whether this instance represents true or false.
      **Exceptions: None
      **Overriden From: Value
      ==============================================================================*/
      // Provides a hash code for this instance.
      /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.GetHashCode"]/*' />
      public override int GetHashCode() {
          return (m_value)?True:False;
      }
    
      /*===================================ToString===================================
      **Args: None
      **Returns:  "True" or "False" depending on the state of the boolean.
      **Exceptions: None.
      ==============================================================================*/
      // Converts the boolean value of this instance to a String.
      /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.ToString"]/*' />
      public override String ToString() {
        if (false == m_value) {
          return FalseString;
        }
        return TrueString;
      }

      /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.ToString1"]/*' />
      public String ToString(IFormatProvider provider) {
        if (false == m_value) {
          return FalseString;
        }
        return TrueString;
      }
    
      // Determines whether two Boolean objects are equal.
      /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.Equals"]/*' />
      public override bool Equals (Object obj) {
        //If it's not a boolean, we're definitely not equal
        if (!(obj is Boolean)) {
          return false;
        }
    
        return (m_value==((Boolean)obj).m_value);
      }
    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. For booleans, false sorts before true.
        // null is considered to be less than any instance.
        // If object is not of type boolean, this method throws an ArgumentException.
        // 
        // Returns a value less than zero if this  object
        // 
        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.CompareTo"]/*' />
        public int CompareTo(Object obj) {
            if (obj==null) {
                return 1;
            }
            if (!(obj is Boolean)) {
                throw new ArgumentException (Environment.GetResourceString("Arg_MustBeBoolean"));
            }
             
            if (m_value==((Boolean)obj).m_value) {
                return 0;
            } else if (m_value==false) {
                return -1;
            }
            return 1;
    
        }
    
      //
      // Static Methods
      // 
    
      // Determines whether a String represents true or false.
      // 
      /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.Parse"]/*' />
      public static bool Parse (String value) {
    	if (value==null) throw new ArgumentNullException("value");
    	// For perf reasons, let's first see if they're equal, then do the
    	// trim to get rid of white space, and check again.
        if (0==String.Compare(value, TrueString,true, CultureInfo.InvariantCulture))
          return true;
        if (0==String.Compare(value,FalseString,true, CultureInfo.InvariantCulture))
          return false;
    	
        value = value.Trim();  // Remove leading & trailing white space.
        if (0==String.Compare(value, TrueString,true, CultureInfo.InvariantCulture))
          return true;
        if (0==String.Compare(value,FalseString,true, CultureInfo.InvariantCulture))
          return false;
        throw new FormatException(Environment.GetResourceString("Format_BadBoolean"));
      }
      
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Boolean;
        }


        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Boolean", "Char"));
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Boolean", "DateTime"));
        }

        /// <include file='doc\Boolean.uex' path='docs/doc[@for="Boolean.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = m_value;	
    	}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\bitconverter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  BitConverter
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Allows developers to view the base data types as 
**          an arbitrary array of bits.
**
** Date:  August 9, 1998
** 
===========================================================*/
namespace System {
    
	using System;
	using System.Runtime.CompilerServices;
    // The BitConverter class contains methods for
    // converting an array of bytes to one of the base data 
    // types, as well as for converting a base data type to an
    // array of bytes.
    // 
	 // Only statics, does not need to be marked with the serializable attribute
    /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter"]/*' />
    public sealed class BitConverter {
    	
    	// This field indicates the "endianess" of the architecture.
    	// The value is set to true if the architecture is
    	// little endian; false if it is big endian.	  
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.IsLittleEndian"]/*' />
        public static readonly bool IsLittleEndian;
    
        static BitConverter() {
            byte [] ba = GetBytes((short)0xF);
            if (ba[0]==0xF) {
                IsLittleEndian=true;
            } else {
                IsLittleEndian=false;
            }
        }
    
        // This class only contains static methods and may not be instantiated.
        private BitConverter() {
        }
    	
        // Converts a byte into an array of bytes with length one.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes"]/*' />
        public static byte[] GetBytes(bool value) {
            byte[] r = new byte[1];
            r[0] = (value ? (byte)Boolean.True : (byte)Boolean.False );
            return r;
        }
    
        // Converts a char into an array of bytes with length two.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern byte[] GetBytes(char value);
      
        // Converts a short into an array of bytes with length
        // two.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern byte[] GetBytes(short value);
      
        // Converts an int into an array of bytes with length 
        // four.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes3"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern byte[] GetBytes(int value);
      
        // Converts a long into an array of bytes with length 
        // eight.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes4"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern byte[] GetBytes(long value);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern byte[] GetUInt16Bytes(ushort value);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern byte[] GetUInt32Bytes(uint value);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern byte[] GetUInt64Bytes(ulong value);
        // Converts an ushort into an array of bytes with
        // length two.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes5"]/*' />
    	 [CLSCompliant(false)]
        public static byte[] GetBytes(ushort value) {
            return GetUInt16Bytes(value);
        }
        
        // Converts an uint into an array of bytes with
        // length four.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes6"]/*' />
    	 [CLSCompliant(false)]
        public static byte[] GetBytes(uint value) {
            return GetUInt32Bytes(value);
        }
        
        // Converts an unsigned long into an array of bytes with
        // length eight.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes7"]/*' />
    	 [CLSCompliant(false)]
        public static byte[] GetBytes(ulong value) {
            return GetUInt64Bytes(value);
        }
      
        // Converts a float into an array of bytes with length 
        // four.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes8"]/*' />
        public unsafe static byte[] GetBytes(float value)
        {
            byte[] bytes = new byte[4];
            fixed(byte* b = bytes)
                *((float*)b) = value;
            return bytes;
        }
      
        // Converts a double into an array of bytes with length 
        // eight.
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.GetBytes9"]/*' />
        public unsafe static byte[] GetBytes(double value)
        {
            byte[] bytes = new byte[8];
            fixed(byte* b = bytes)
                *((double*)b) = value;
            return bytes;
        }
      
        // Converts an array of bytes into a char.  
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToChar"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern char ToChar(byte[] value, int startIndex);
      
        // Converts an array of bytes into a short.  
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToInt16"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern short ToInt16(byte[] value, int startIndex);
      
        // Converts an array of bytes into an int.  
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToInt32"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int ToInt32 (byte[]value, int startIndex);
      
        // Converts an array of bytes into a long.  
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToInt64"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern long ToInt64 (byte[] value, int startIndex);
      
    
        // Converts an array of bytes into an ushort.
        // 
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToUInt16"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
        public static extern ushort ToUInt16(byte[] value, int startIndex);
    
        // Converts an array of bytes into an uint.
        // 
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToUInt32"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
        public static extern uint ToUInt32(byte[] value, int startIndex);
    
        // Converts an array of bytes into an unsigned long.
        // 
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToUInt64"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
        public static extern ulong ToUInt64(byte[] value, int startIndex);
    
        // Converts an array of bytes into a float.  
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToSingle"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern float ToSingle (byte[]value, int startIndex);
      
        // Converts an array of bytes into a double.  
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToDouble"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern double ToDouble (byte []value, int startIndex);
      
        // Converts an array of bytes into a String.  
        // Returns a hyphen-separated list of bytes in hex (ie, "7F-2C-4A").
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToString"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String ToString (byte[] value, int startIndex, int length);
    
        // Converts an array of bytes into a String.  
        // Returns a hyphen-separated list of bytes in hex (ie, "7F-2C-4A").
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToString1"]/*' />
        public static String ToString(byte [] value) {
            if (value == null)
                throw new ArgumentNullException("value");
            return ToString(value, 0, value.Length);
        }
    
        // Converts an array of bytes into a String.  
        // Returns a hyphen-separated list of bytes in hex (ie, "7F-2C-4A").
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToString2"]/*' />
        public static String ToString (byte [] value, int startIndex) {
            if (value == null)
                throw new ArgumentNullException("value");
            return ToString(value, startIndex, value.Length - startIndex);
        }
      
        /*==================================ToBoolean===================================
        **Action:  Convert an array of bytes to a boolean value.  We treat this array 
        **         as if the first 4 bytes were an Int4 an operate on this value.
        **Returns: True if the Int4 value of the first 4 bytes is non-zero.
        **Arguments: value -- The byte array
        **           startIndex -- The position within the array.
        **Exceptions: See ToInt4.
        ==============================================================================*/
        // Converts an array of bytes into a boolean.  
        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.ToBoolean"]/*' />
        public static bool ToBoolean(byte[]value, int startIndex) {
            if (value==null)
                throw new ArgumentNullException("value");
            if (startIndex < 0)
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (startIndex > value.Length - 1)
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_Index"));
    
            return (value[startIndex]==0)?false:true;
        }

        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.DoubleToInt64Bits"]/*' />
        public static unsafe long DoubleToInt64Bits(double value) {
            return *((long *)&value);
        }

        /// <include file='doc\BitConverter.uex' path='docs/doc[@for="BitConverter.Int64BitsToDouble"]/*' />
        public static unsafe double Int64BitsToDouble(long value) {
            return *((double *)&value);
        }

    
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\byte.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Byte
**
** Author: Jay Roxe (jroxe)
**
** Purpose: This class will encapsulate a byte and provide an
**			Object representation of it.
**
** Date: August 3, 1998
** 
===========================================================*/

namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.InteropServices;

    // The Byte class extends the Value class and 
    // provides object representation of the byte primitive type. 
    // 
    /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte"]/*' />
    [Serializable, System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)] public struct Byte : IComparable, IFormattable, IConvertible
    {
        private byte m_value;
    
        // The maximum value that a Byte may represent: 255.
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.MaxValue"]/*' />
        public const byte MaxValue = (byte)0xFF;
    
        // The minimum value that a Byte may represent: 0.
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.MinValue"]/*' />
        public const byte MinValue = 0;
	
    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type byte, this method throws an ArgumentException.
        // 
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (!(value is Byte)) {
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeByte"));
            }
    
            return m_value - (((Byte)value).m_value);
        }
    
        // Determines whether two Byte objects are equal.
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is Byte)) {
                return false;
            }
            return m_value == ((Byte)obj).m_value;
        }
    
        // Gets a hash code for this instance.
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.GetHashCode"]/*' />
        public override int GetHashCode() {
            return m_value;
        }
    
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.Parse"]/*' />
        public static byte Parse(String s) {
            return Parse(s, NumberStyles.Integer, null);
        }
    
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.Parse1"]/*' />
        public static byte Parse(String s, NumberStyles style) {
		   NumberFormatInfo.ValidateParseStyle(style);
		   return Parse(s, style, null);
        }


        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.Parse2"]/*' />
        public static byte Parse(String s, IFormatProvider provider) {
		   return Parse(s, NumberStyles.Integer, provider);
        }

    
    	// Parses an unsigned byte from a String in the given style.  If
    	// a NumberFormatInfo isn't specified, the current culture's 
    	// NumberFormatInfo is assumed.
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.Parse3"]/*' />
        public static byte Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
            NumberFormatInfo.ValidateParseStyle(style);
			int i = Number.ParseInt32(s, style, info);
            if (i < MinValue || i > MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)i;
        }
    
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.ToString"]/*' />
        public override String ToString() {
            return Number.FormatInt32(m_value, null, NumberFormatInfo.CurrentInfo);
        }
    
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.ToString1"]/*' />
        public String ToString(String format) {
            return Number.FormatInt32(m_value, format, NumberFormatInfo.CurrentInfo);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.ToString2"]/*' />
        public String ToString(IFormatProvider provider) {
            return ToString(null, provider);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.ToString3"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatInt32(m_value, format, NumberFormatInfo.GetInstance(provider));
        }
    
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Byte;
        }


        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Byte", "DateTime"));
        }

        /// <include file='doc\Byte.uex' path='docs/doc[@for="Byte.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = m_value;
		}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\cfgparser.cs ===
/*============================================================
 **
 ** Class: CfgParser
 **
 ** Author: Craig Sinclar (craigsi)
 ** Updated: Peter de Jong (pdejong)
 **
 ** Purpose: XMLParser and Tree builder internal to BCL
 **
 ** Date:  October, 29, 1999
 **
 ** Copyright (c) Microsoft, 2000
 **
 ===========================================================*/

//
// These are managed definitions of interfaces used in the shim for XML Parsing
// If you make any change please make a correspoding change in \src\dlls\shim\managedhelper.h
//
//
//

namespace System
{
    using System.Runtime.InteropServices;
    using System.Collections;   
    using System.Runtime.CompilerServices;
    using System.Security.Permissions;
    using System.Security;
	using System.Globalization;

    [Serializable]
    internal enum ConfigEvents
    {
        StartDocument     = 0,
        StartDTD          = StartDocument + 1,
        EndDTD            = StartDTD + 1,
        StartDTDSubset    = EndDTD + 1,
        EndDTDSubset      = StartDTDSubset + 1,
        EndProlog         = EndDTDSubset + 1,
        StartEntity       = EndProlog + 1,
        EndEntity         = StartEntity + 1,
        EndDocument       = EndEntity + 1,
        DataAvailable     = EndDocument + 1,
        LastEvent         = DataAvailable
    }

    [Serializable]
    internal enum ConfigNodeType
    {
        Element = 1,
        Attribute   = Element + 1,
        Pi  = Attribute + 1,
        XmlDecl = Pi + 1,
        DocType = XmlDecl + 1,
        DTDAttribute    = DocType + 1,
        EntityDecl  = DTDAttribute + 1,
        ElementDecl = EntityDecl + 1,
        AttlistDecl = ElementDecl + 1,
        Notation    = AttlistDecl + 1,
        Group   = Notation + 1,
        IncludeSect = Group + 1,
        PCData  = IncludeSect + 1,
        CData   = PCData + 1,
        IgnoreSect  = CData + 1,
        Comment = IgnoreSect + 1,
        EntityRef   = Comment + 1,
        Whitespace  = EntityRef + 1,
        Name    = Whitespace + 1,
        NMToken = Name + 1,
        String  = NMToken + 1,
        Peref   = String + 1,
        Model   = Peref + 1,
        ATTDef  = Model + 1,
        ATTType = ATTDef + 1,
        ATTPresence = ATTType + 1,
        DTDSubset   = ATTPresence + 1,
        LastNodeType    = DTDSubset + 1
    } 

    [Serializable]
    internal enum ConfigNodeSubType
    {
        Version = (int)ConfigNodeType.LastNodeType,
        Encoding    = Version + 1,
        Standalone  = Encoding + 1,
        NS  = Standalone + 1,
        XMLSpace    = NS + 1,
        XMLLang = XMLSpace + 1,
        System  = XMLLang + 1,
        Public  = System + 1,
        NData   = Public + 1,
        AtCData = NData + 1,
        AtId    = AtCData + 1,
        AtIdref = AtId + 1,
        AtIdrefs    = AtIdref + 1,
        AtEntity    = AtIdrefs + 1,
        AtEntities  = AtEntity + 1,
        AtNmToken   = AtEntities + 1,
        AtNmTokens  = AtNmToken + 1,
        AtNotation  = AtNmTokens + 1,
        AtRequired  = AtNotation + 1,
        AtImplied   = AtRequired + 1,
        AtFixed = AtImplied + 1,
        PentityDecl = AtFixed + 1,
        Empty   = PentityDecl + 1,
        Any = Empty + 1,
        Mixed   = Any + 1,
        Sequence    = Mixed + 1,
        Choice  = Sequence + 1,
        Star    = Choice + 1,
        Plus    = Star + 1,
        Questionmark    = Plus + 1,
        LastSubNodeType = Questionmark + 1
    } 


    [Guid("afd0d21f-72f8-4819-99ad-3f255ee5006b"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
            internal interface IConfigHandler {
        void NotifyEvent(ConfigEvents pNode);

        void BeginChildren(int size, 
                           ConfigNodeSubType subType, 
                           ConfigNodeType nType, 
                           int terminal, 
                           [MarshalAs(UnmanagedType.LPWStr)] String text, 
                           int textLength, 
                           int prefixLength);

        void EndChildren(int fEmpty, 
                         int size,
                         ConfigNodeSubType subType, 
                         ConfigNodeType nType,                       
                         int terminal, 
                         [MarshalAs(UnmanagedType.LPWStr)] String text, 
                         int textLength, 
                         int prefixLength);

        void Error(int size,
                   ConfigNodeSubType subType, 
                   ConfigNodeType nType,                   
                   int terminal, 
                   [MarshalAs(UnmanagedType.LPWStr)]String text, 
                   int textLength, 
                   int prefixLength);

        void CreateNode(int size,
                        ConfigNodeSubType subType, 
                        ConfigNodeType nType,                       
                        int terminal, 
                        [MarshalAs(UnmanagedType.LPWStr)]String text, 
                        int textLength, 
                        int prefixLength);

        void CreateAttribute(int size,
                             ConfigNodeSubType subType, 
                             ConfigNodeType nType,                           
                             int terminal, 
                             [MarshalAs(UnmanagedType.LPWStr)]String text, 
                             int textLength, 
                             int prefixLength);
    }

    [Guid("bbd21636-8546-45b3-9664-1ec479893a6f"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IConfigHelper
    {
        void Run(IConfigHandler factory, String fileName);
    }

    internal class ConfigServer
    {
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern IConfigHelper GetHelper();
    }

    // Class used to build a DOM like tree of parsed XML
    internal class ConfigTreeParser : IConfigHandler
    {
        ConfigNode rootNode = null;
        ConfigNode currentNode = null;
        String lastProcessed = null;
        String fileName = null;
        int attributeEntry;
        String key = null;
        String [] treeRootPath = null; // element to start tree
        bool parsing = false;
        int depth = 0;
        int pathDepth = 0;
        int searchDepth = 0;
        bool bNoSearchPath = false;

        internal ConfigNode Parse(String fileName)
        {
            return Parse(fileName, null);
        }

        // NOTE: This parser takes a path eg. /configuration/system.runtime.remoting
        // and will return a node which matches this.
        
        internal ConfigNode Parse(String fileName, String configPath)      
        {
            if (fileName == null)
                throw new ArgumentNullException("fileName");
            this.fileName = fileName;
            if (configPath[0] == '/'){
                treeRootPath = configPath.Substring(1).Split('/');
                pathDepth = treeRootPath.Length - 1;
                bNoSearchPath = false;
            }
            else{
                treeRootPath = new String[1];
                treeRootPath[0] = configPath;
                bNoSearchPath = true;
            }

            (new FileIOPermission( FileIOPermissionAccess.Read, System.IO.Path.GetFullPathInternal( fileName ) )).Demand();
            (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Assert();
            IConfigHelper ch = ConfigServer.GetHelper();
            try
            {
                ch.Run(this, fileName);
            }
            catch(Exception inner) {
                throw new ApplicationException(String.Format(Environment.GetResourceString("XML_Syntax_InvalidSyntaxInFile"),
                                                             fileName,
                                                             lastProcessed),
                                               inner);
            }
            return rootNode;
        }

        public void NotifyEvent(ConfigEvents pNode)
        {
            BCLDebug.Trace("REMOTE", "NotifyEvent "+((Enum)pNode).ToString()+"\n");
        }

        public void BeginChildren(int size,
                                  ConfigNodeSubType subType, 
                                  ConfigNodeType nType,                                   
                                  int terminal, 
                                  [MarshalAs(UnmanagedType.LPWStr)] String text, 
                                  int textLength, 
                                  int prefixLength)
        {
            //Trace("BeginChildren",size,subType,nType,terminal,text,textLength,prefixLength,0);
            if (!parsing &&
                (!bNoSearchPath 
                 && depth == (searchDepth + 1)
                 && String.Compare(text, treeRootPath[searchDepth], false, CultureInfo.InvariantCulture) == 0))
            {
                searchDepth++;
            }
        }

        public void EndChildren(int fEmpty, 
                                int size,
                                ConfigNodeSubType subType, 
                                ConfigNodeType nType,                               
                                int terminal, 
                                [MarshalAs(UnmanagedType.LPWStr)] String text, 
                                int textLength, 
                                int prefixLength)
        {
            lastProcessed = "</"+text+">";          
            if (parsing)
            {
                //Trace("EndChildren",size,subType,nType,terminal,text,textLength,prefixLength,fEmpty);

                if (currentNode == rootNode)
                {
                    // End of section of tree which is parsed
                    parsing = false;
                }

                currentNode = currentNode.Parent;
            }
            else if (nType == ConfigNodeType.Element){
                if(depth == searchDepth && String.Compare(text, treeRootPath[searchDepth - 1], false, CultureInfo.InvariantCulture) == 0)
                {
                    searchDepth--;
                    depth--;
                }
                else 
                    depth--;
            }
            
        }

        public void Error(int size,
                          ConfigNodeSubType subType, 
                          ConfigNodeType nType, 
                          int terminal, 
                          [MarshalAs(UnmanagedType.LPWStr)]String text, 
                          int textLength, 
                          int prefixLength)
        {
            //Trace("Error",size,subType,nType,terminal,text,textLength,prefixLength,0);                        
        }


        public void CreateNode(int size,
                               ConfigNodeSubType subType, 
                               ConfigNodeType nType, 
                               int terminal, 
                               [MarshalAs(UnmanagedType.LPWStr)]String text, 
                               int textLength, 
                               int prefixLength)
        {
            //Trace("CreateNode",size,subType,nType,terminal,text,textLength,prefixLength,0);

            if (nType == ConfigNodeType.Element)
            {
				// New Node
                lastProcessed = "<"+text+">";                           
                if (parsing  
                    || (bNoSearchPath &&
                        String.Compare(text, treeRootPath[0], true, CultureInfo.InvariantCulture) == 0)
                    || (depth == searchDepth && searchDepth == pathDepth && 
                        String.Compare(text, treeRootPath[pathDepth], true, CultureInfo.InvariantCulture) == 0 ))
                    {
                        parsing = true;
                        
                        ConfigNode parentNode = currentNode;
                        currentNode = new ConfigNode(text, parentNode);
                        if (rootNode == null)
                            rootNode = currentNode;
                        else
                            parentNode.AddChild(currentNode);
                    }
                else if (nType == ConfigNodeType.PCData)
                    {
                        // Data node
                        currentNode.Value = text;
                    }
                else 
                    depth++;
            }
            
        }

        public void CreateAttribute(int size,
                                    ConfigNodeSubType subType, 
                                    ConfigNodeType nType,                                   
                                    int terminal, 
                                    [MarshalAs(UnmanagedType.LPWStr)]String text, 
                                    int textLength, 
                                    int prefixLength)
        {
            //Trace("CreateAttribute",size,subType,nType,terminal,text,textLength,prefixLength,0);
            if (parsing)
            {
                // if the value of the attribute is null, the parser doesn't come back, so need to store the attribute when the
                // attribute name is encountered
                if (nType == ConfigNodeType.Attribute)
                {
                    attributeEntry = currentNode.AddAttribute(text, "");
                    key = text;
                }
                else if (nType == ConfigNodeType.PCData)
                {
                    currentNode.ReplaceAttribute(attributeEntry, key, text);
                }
                else
                    throw new ApplicationException(String.Format(Environment.GetResourceString("XML_Syntax_InvalidSyntaxInFile"),fileName,lastProcessed));
            }
        }

        [System.Diagnostics.Conditional("_LOGGING")]        
        private void Trace(String name,
                           int size,
                           ConfigNodeSubType subType, 
                           ConfigNodeType nType,                           
                           int terminal, 
                           [MarshalAs(UnmanagedType.LPWStr)]String text, 
                           int textLength, 
                           int prefixLength, int fEmpty)
        {

            BCLDebug.Trace("REMOTE","Node "+name);
            BCLDebug.Trace("REMOTE","text "+text);
            BCLDebug.Trace("REMOTE","textLength "+textLength);          
            BCLDebug.Trace("REMOTE","size "+size);
            BCLDebug.Trace("REMOTE","subType "+((Enum)subType).ToString());
            BCLDebug.Trace("REMOTE","nType "+((Enum)nType).ToString());
            BCLDebug.Trace("REMOTE","terminal "+terminal);
            BCLDebug.Trace("REMOTE","prefixLength "+prefixLength);          
            BCLDebug.Trace("REMOTE","fEmpty "+fEmpty+"\n");

        }
    }

    // Node in Tree produced by ConfigTreeParser
    internal class ConfigNode
    {
        String m_name = null;
        String m_value = null;
        ConfigNode m_parent = null;
        ArrayList m_children = new ArrayList(5);
        ArrayList m_attributes = new ArrayList(5);

        internal ConfigNode(String name, ConfigNode parent)
        {
            m_name = name;
            m_parent = parent;
        }

        internal String Name
        {
            get {return m_name;}
        }

        internal String Value
        {
            get {return m_value;}
            set {m_value = value;}
        }

        internal ConfigNode Parent
        {
            get {return m_parent;}
        }

        internal ArrayList Children
        {
            get {return m_children;}
        }

        internal ArrayList Attributes
        {
            get {return m_attributes;}
        }

        internal void AddChild(ConfigNode child)
        {
            child.m_parent = this;
            m_children.Add(child);
        }

        internal int AddAttribute(String key, String value)
        {
            m_attributes.Add(new DictionaryEntry(key, value));
            return m_attributes.Count-1;
        }

        internal void ReplaceAttribute(int index, String key, String value)
        {
            m_attributes[index] = new DictionaryEntry(key, value);
        }


        [System.Diagnostics.Conditional("_LOGGING")]
                internal void Trace()
        {
            BCLDebug.Trace("REMOTE","************ConfigNode************");
            BCLDebug.Trace("REMOTE","Name = "+m_name);
            if (m_value != null)
                BCLDebug.Trace("REMOTE","Value = "+m_value);
            if (m_parent != null)
                BCLDebug.Trace("REMOTE","Parent = "+m_parent.Name);
            for (int i=0; i<m_attributes.Count; i++)
            {
                DictionaryEntry de = (DictionaryEntry)m_attributes[i];
                BCLDebug.Trace("REMOTE","Key = "+de.Key+"   Value = "+de.Value);
            }

            for (int i=0; i<m_children.Count; i++)
            {
                ((ConfigNode)m_children[i]).Trace();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\cannotunloadappdomainexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: CannotUnloadAppDomainException
**
** Author: Jennifer Hamilton (jenh)
**
** Purpose: Exception class for failed attempt to unload an AppDomain.
**
** Date: September 15, 2000
**
=============================================================================*/

namespace System {

	using System.Runtime.Serialization;

    /// <include file='doc\CannotUnloadAppDomainException.uex' path='docs/doc[@for="CannotUnloadAppDomainException"]/*' />
    [Serializable()] public class CannotUnloadAppDomainException : SystemException {
        /// <include file='doc\CannotUnloadAppDomainException.uex' path='docs/doc[@for="CannotUnloadAppDomainException.CannotUnloadAppDomainException"]/*' />
        public CannotUnloadAppDomainException() 
            : base(Environment.GetResourceString("Arg_CannotUnloadAppDomainException")) {
    		SetErrorCode(__HResults.COR_E_CANNOTUNLOADAPPDOMAIN);
        }
    
        /// <include file='doc\CannotUnloadAppDomainException.uex' path='docs/doc[@for="CannotUnloadAppDomainException.CannotUnloadAppDomainException1"]/*' />
        public CannotUnloadAppDomainException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_CANNOTUNLOADAPPDOMAIN);
        }
    
        /// <include file='doc\CannotUnloadAppDomainException.uex' path='docs/doc[@for="CannotUnloadAppDomainException.CannotUnloadAppDomainException2"]/*' />
        public CannotUnloadAppDomainException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_CANNOTUNLOADAPPDOMAIN);
        }

        //
        //This constructor is required for serialization.
        //
        /// <include file='doc\CannotUnloadAppDomainException.uex' path='docs/doc[@for="CannotUnloadAppDomainException.CannotUnloadAppDomainException3"]/*' />
        protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\buffer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
    //Only contains static methods.  Does not require serialization
    
	using System;
	using System.Runtime.CompilerServices;
    /// <include file='doc\Buffer.uex' path='docs/doc[@for="Buffer"]/*' />
    public sealed class Buffer
    {
        private Buffer() {
        }
    
    	// Copies from one primitive array to another primitive array without
    	// respecting types.  This calls memmove internally.
        /// <include file='doc\Buffer.uex' path='docs/doc[@for="Buffer.BlockCopy"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void BlockCopy(Array src, int srcOffset,
            Array dst, int dstOffset, int count);

		// A very simple and efficient array copy that assumes all of the
		// parameter validation has already been done.  All counts here are
		// in bytes.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void InternalBlockCopy(Array src, int srcOffset,
            Array dst, int dstOffset, int count);

    	// Gets a particular byte out of the array.  The array must be an
    	// array of primitives.  
    	//
    	// This essentially does the following: 
    	// return ((byte*)array) + index.
    	//
    	/// <include file='doc\Buffer.uex' path='docs/doc[@for="Buffer.GetByte"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern byte GetByte(Array array, int index);
    
    	// Sets a particular byte in an the array.  The array must be an
    	// array of primitives.  
    	//
    	// This essentially does the following: 
    	// *(((byte*)array) + index) = value.
    	//
    	/// <include file='doc\Buffer.uex' path='docs/doc[@for="Buffer.SetByte"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern void SetByte(Array array, int index, byte value);
    
    	// Gets a particular byte out of the array.  The array must be an
    	// array of primitives.  
    	//
    	// This essentially does the following: 
    	// return array.length * sizeof(array.UnderlyingElementType).
    	//
    	/// <include file='doc\Buffer.uex' path='docs/doc[@for="Buffer.ByteLength"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern int ByteLength(Array array);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\char.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Char
**
** Author: Jay Roxe (jroxe)
**
** Purpose: This is the value class representing a Unicode character
** Char methods until we create this functionality.
**
** Date:  August 3, 1998
**
===========================================================*/
namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;

    /// <include file='doc\Char.uex' path='docs/doc[@for="Char"]/*' />
    [Serializable, System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)] public struct Char : IComparable, IConvertible {
      //
      // Member Variables
      //
      internal char m_value;
    
      //
      // Public Constants
      //
      // The maximum character value.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.MaxValue"]/*' />
      public const char MaxValue =  (char) 0xFFFF;
      // The minimum character value.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.MinValue"]/*' />
      public const char MinValue =  (char) 0x00;
	 
      //
      // Private Constants
      //
    
      //
      // Overriden Instance Methods
      //
    
      // Calculate a hashcode for a 2 byte Unicode character.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.GetHashCode"]/*' />
      public override int GetHashCode() {
    	  return (int)m_value | ((int)m_value << 16);
      }
    
      // Used for comparing two boxed Char objects.
      //
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.Equals"]/*' />
      public override bool Equals(Object obj) {
        if (!(obj is Char)) {
          return false;
        }
        return (m_value==((Char)obj).m_value);
      }
    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type Char, this method throws an ArgumentException.
        //
        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value==null) {
                return 1;
            }
            if (!(value is Char)) {
                throw new ArgumentException (Environment.GetResourceString("Arg_MustBeChar"));
            }
    
            return (m_value-((Char)value).m_value);
        }
    
      // Overrides System.Object.ToString.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.ToString"]/*' />
      public override String ToString() {
    	  return Char.ToString(m_value);
      }

      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.ToString2"]/*' />
      public String ToString(IFormatProvider provider) {
    	  return Char.ToString(m_value);
      }

      //
      // Formatting Methods
      //
    
      /*===================================ToString===================================
      **This static methods takes a character and returns the String representation of it.
      ==============================================================================*/
      // Provides a string representation of a character.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.ToString1"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern String ToString(char c);
    
    
        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.Parse"]/*' />
      public static char Parse(String s) {
            if (s==null) {
                throw new ArgumentNullException("s");
            } 
            if (s.Length!=1) {
                throw new FormatException(Environment.GetResourceString("Format_NeedSingleChar"));
            } 
            return s[0];
        }

      //
      // Static Methods
      //
      /*=================================ISDIGIT======================================
      **A wrapper for Char.  Returns a boolean indicating whether    **
      **character c is considered to be a digit.                                    **
      ==============================================================================*/
      // Determines whether a character is a digit.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsDigit"]/*' />
      public static bool IsDigit(char c) {
          return CharacterInfo.IsDigit(c);
      }
    
      /*=================================ISLETTER=====================================
      **A wrapper for Char.  Returns a boolean indicating whether    **
      **character c is considered to be a letter.                                   **
      ==============================================================================*/
      // Determines whether a character is a letter.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsLetter"]/*' />
      public static bool IsLetter(char c) {
          return CharacterInfo.IsLetter(c);
      }
    
      /*===============================ISWHITESPACE===================================
      **A wrapper for Char.  Returns a boolean indicating whether    **
      **character c is considered to be a whitespace character.                     **
      ==============================================================================*/
      // Determines whether a character is whitespace.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsWhiteSpace"]/*' />
      public static bool IsWhiteSpace(char c) {
          return CharacterInfo.IsWhiteSpace(c);
      }
    
    
      /*===================================IsUpper====================================
      **Arguments: c -- the characater to be checked.
      **Returns:  True if c is an uppercase character.
      ==============================================================================*/
      // Determines whether a character is upper-case.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsUpper"]/*' />
      public static bool IsUpper(char c) {
          return CharacterInfo.IsUpper(c);
      }
    
      /*===================================IsLower====================================
      **Arguments: c -- the characater to be checked.
      **Returns:  True if c is an lowercase character.
      ==============================================================================*/
      // Determines whether a character is lower-case.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsLower"]/*' />
      public static bool IsLower(char c) {
          return CharacterInfo.IsLower(c);
      }
    
      /*================================IsPunctuation=================================
      **Arguments: c -- the characater to be checked.
      **Returns:  True if c is an punctuation mark
      ==============================================================================*/
      // Determines whether a character is a punctuation mark.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsPunctuation"]/*' />
      public static bool IsPunctuation(char c){
          return CharacterInfo.IsPunctuation(c);
      }
    
      // Determines whether a character is a letter or a digit.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsLetterOrDigit"]/*' />
      public static bool IsLetterOrDigit(char c) {
            UnicodeCategory uc = CharacterInfo.GetUnicodeCategory(c);
            return (uc == UnicodeCategory.UppercaseLetter 
                 || uc == UnicodeCategory.LowercaseLetter 
                 || uc == UnicodeCategory.TitlecaseLetter 
                 || uc == UnicodeCategory.ModifierLetter 
                 || uc == UnicodeCategory.OtherLetter
                 || uc == UnicodeCategory.DecimalDigitNumber);
      }
    
      /*===================================ToUpper====================================
      **
      ==============================================================================*/
      // Converts a character to upper-case for the specified culture.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.ToUpper"]/*' />
      public static char ToUpper(char c, CultureInfo culture) {
        if (culture==null)
            throw new ArgumentNullException("culture");
        return culture.TextInfo.ToUpper(c);
      }
    
      /*=================================TOUPPER======================================
      **A wrapper for Char.toUpperCase.  Converts character c to its **
      **uppercase equivalent.  If c is already an uppercase character or is not an  **
      **alphabetic, nothing happens.                                                **
      ==============================================================================*/
      // Converts a character to upper-case for the default culture.
      //
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.ToUpper1"]/*' />
      public static char ToUpper(char c) {
        return ToUpper(c, CultureInfo.CurrentCulture);
      }
    
    
      /*===================================ToLower====================================
      **
      ==============================================================================*/
      // Converts a character to lower-case for the specified culture.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.ToLower"]/*' />
      public static char ToLower(char c, CultureInfo culture) {
        if (culture==null)
            throw new ArgumentNullException("culture");
        return culture.TextInfo.ToLower(c);
      }
    
      /*=================================TOLOWER======================================
      **A wrapper for Char.toLowerCase.  Converts character c to its **
      **lowercase equivalent.  If c is already a lowercase character or is not an   **
      **alphabetic, nothing happens.                                                **
      ==============================================================================*/
      // Converts a character to lower-case for the default culture.
      /// <include file='doc\Char.uex' path='docs/doc[@for="Char.ToLower1"]/*' />
      public static char ToLower(char c) {
        return ToLower(c, CultureInfo.CurrentCulture);
      }

        //
        // IValue implementation
        // 
    	
        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Char;
        }


        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Char", "Boolean"));
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Char", "Single"));
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Char", "Double"));
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Char", "Decimal"));
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Char", "DateTime"));
        }

        /// <include file='doc\Char.uex' path='docs/doc[@for="Char.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsControl1"]/*' />
		public static bool IsControl(char c)
		{
			return CharacterInfo.IsControl(c);
		}
		  
		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsControl"]/*' />
		public static bool IsControl(String s, int index) {
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsControl(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsDigit1"]/*' />
		public static bool IsDigit(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsDigit(s[index]);
		}
		
		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsLetter1"]/*' />
		public static bool IsLetter(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsLetter(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsLetterOrDigit1"]/*' />
		public static bool IsLetterOrDigit(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsLetterOrDigit(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsLower1"]/*' />
		public static bool IsLower(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsLower(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsNumber"]/*' />
		public static bool IsNumber(char c)
		{
			return CharacterInfo.IsNumber(c);
		}
		     
		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsNumber1"]/*' />
		public static bool IsNumber(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsNumber(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsPunctuation1"]/*' />
		public static bool IsPunctuation (String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsPunctuation(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsSeparator"]/*' />
		public static bool IsSeparator(char c)
		{
			return CharacterInfo.IsSeparator(c);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsSeparator1"]/*' />
		public static bool IsSeparator(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsSeparator(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsSurrogate"]/*' />
		public static bool IsSurrogate(char c)
		{
			return CharacterInfo.IsSurrogate(c);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsSurrogate1"]/*' />
		public static bool IsSurrogate(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsSurrogate(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsSymbol"]/*' />
		public static bool IsSymbol(char c)
		{
			return CharacterInfo.IsSymbol(c);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsSymbol1"]/*' />
		public static bool IsSymbol(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsSymbol(s[index]);
		}

		
		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsUpper1"]/*' />
		public static bool IsUpper(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsUpper(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.IsWhiteSpace1"]/*' />
		public static bool IsWhiteSpace(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return IsWhiteSpace(s[index]);
		}
		
		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.GetUnicodeCategory"]/*' />
		public static UnicodeCategory GetUnicodeCategory(char c)
		{
			return CharacterInfo.GetUnicodeCategory(c);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.GetUnicodeCategory1"]/*' />
		public static UnicodeCategory GetUnicodeCategory(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return GetUnicodeCategory(s[index]);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.GetNumericValue"]/*' />
		public static double GetNumericValue(char c)
		{
			return CharacterInfo.GetNumericValue(c);
		}

		/// <include file='doc\Char.uex' path='docs/doc[@for="Char.GetNumericValue1"]/*' />
		public static double GetNumericValue(String s, int index)
		{
            if (s==null)
                throw new ArgumentNullException("s");
			if (((uint)index)>=((uint)s.Length)) {
				throw new ArgumentOutOfRangeException("index");
			}
			return GetNumericValue(s[index]);
		}


		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = m_value;
    	}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\attribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Attribute
**
** Author: Rajesh Chandrashekaran (rajeshc)
**
** Purpose: The class used as an attribute to denote that 
**          another class can be used as an attribute.
**
** Date:  December 7, 1999
**
===========================================================*/
namespace System {

    using System;
    using System.Reflection;
    using System.Collections;

    /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute"]/*' />
    [Serializable, AttributeUsageAttribute(AttributeTargets.All, Inherited = true, AllowMultiple=false)] // Base class for all attributes
    public abstract class Attribute {
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.Attribute"]/*' />
        protected Attribute(){}

        // This is a private enum used solely for the purpose of avoiding code repeat for these types

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes8"]/*' />
        public static Attribute[] GetCustomAttributes(MemberInfo element, Type type)
        {
            return GetCustomAttributes(element, type, true);
        }
        
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes"]/*' />
        public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            if (type == null)
                throw new ArgumentNullException("type");
            
            if (!type.IsSubclassOf(typeof(Attribute)) && type != typeof(Attribute))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustHaveAttributeBaseClass"));

            Object[] attributes = null;
            switch(element.MemberType)
            {
                case MemberTypes.Method:            
                    attributes = ((MethodInfo)element).GetCustomAttributes(type, inherit);
                    break;

                case MemberTypes.TypeInfo:
                case MemberTypes.NestedType:
                    attributes = ((Type)element).GetCustomAttributes(type, inherit);
                    break;

                case MemberTypes.Constructor:
                    attributes = ((ConstructorInfo)element).GetCustomAttributes(type, inherit);
                    break;
                    
                case MemberTypes.Field: 
                    attributes = ((FieldInfo)element).GetCustomAttributes(type, inherit);
                    break;

                case MemberTypes.Property:  
                    return InternalGetCustomAttributes((PropertyInfo)element, type, inherit);

                case MemberTypes.Event: 
                    return InternalGetCustomAttributes((EventInfo)element, type, inherit);

                default:
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnsupportedMemberInfoTypes"));
            }
            return (Attribute[])attributes;
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes9"]/*' />
        public static Attribute[] GetCustomAttributes(MemberInfo element)
        {
            return GetCustomAttributes(element, true);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes1"]/*' />
        public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            Object[] attributes = null;
            switch(element.MemberType)
            {
                case MemberTypes.Method:            
                    attributes = ((MethodInfo)element).GetCustomAttributes(s_AttributeType, inherit);
                    break;

                case MemberTypes.TypeInfo:
                case MemberTypes.NestedType:
                    attributes = ((Type)element).GetCustomAttributes(s_AttributeType, inherit);
                    break;

                case MemberTypes.Constructor:
                    attributes = ((ConstructorInfo)element).GetCustomAttributes(s_AttributeType, inherit);
                    break;
                    
                case MemberTypes.Field: 
                    attributes = ((FieldInfo)element).GetCustomAttributes(s_AttributeType, inherit);
                    break;

                case MemberTypes.Property:  
                    return InternalGetCustomAttributes((PropertyInfo)element, s_AttributeType, inherit);

                case MemberTypes.Event: 
                    return InternalGetCustomAttributes((EventInfo)element, s_AttributeType, inherit);

                default:
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnsupportedMemberInfoTypes"));
            }
            return (Attribute[])attributes;
        }
        
        private static Attribute[] InternalGetCustomAttributes(PropertyInfo element, Type type, bool inherit)
        {
            // walk up the hierarchy chain
            Attribute[] attributes = (Attribute[])element.GetCustomAttributes(type, inherit);
            if (inherit) {
                // create the hashtable that keeps track of inherited types
                Hashtable types = new Hashtable(11);
                // create an array list to collect all the requested attibutes
                ArrayList attributeList = new ArrayList();
                CopyToArrayList(attributeList, attributes, types);

                PropertyInfo baseProp = GetParentDefinition(element);
                while (baseProp != null) {
                    attributes = GetCustomAttributes(baseProp, type, false);
                    AddAttributesToList(attributeList, attributes, types);
                    baseProp = GetParentDefinition(baseProp);
                }
                return (Attribute[])attributeList.ToArray(type);
            }
            else
                return attributes;
        }

        private static Attribute[] InternalGetCustomAttributes(EventInfo element, Type type, bool inherit)
        {
            // walk up the hierarchy chain
            Attribute[] attributes = (Attribute[])element.GetCustomAttributes(type, inherit);
            if (inherit) {
                // create the hashtable that keeps track of inherited types
                Hashtable types = new Hashtable(11);
                // create an array list to collect all the requested attibutes
                ArrayList attributeList = new ArrayList();
                CopyToArrayList(attributeList, attributes, types);

                EventInfo baseEvent = GetParentDefinition(element);
                while (baseEvent != null) {
                    attributes = GetCustomAttributes(baseEvent, type, false);
                    AddAttributesToList(attributeList, attributes, types);
                    baseEvent = GetParentDefinition(baseEvent);
                }
                return (Attribute[])attributeList.ToArray(type);
            }
            else
                return attributes;
        }

        //
        // utility functions
        //
        static private void CopyToArrayList(ArrayList attributeList, Attribute[] attributes, Hashtable types) {
            for (int i = 0; i < attributes.Length; i++) {
                attributeList.Add(attributes[i]);
                Type attrType = attributes[i].GetType();
                if (!types.Contains(attrType)) 
                    types[attrType] = InternalGetAttributeUsage(attrType);
            }
        }
        
        static private void AddAttributesToList(ArrayList attributeList, Attribute[] attributes, Hashtable types) {
            for (int i = 0; i < attributes.Length; i++) {
                Type attrType = attributes[i].GetType();
                AttributeUsageAttribute usage = (AttributeUsageAttribute)types[attrType];
                if (usage == null) {
                    // the type has never been seen before if it's inheritable add it to the list
                    usage = InternalGetAttributeUsage(attrType);
                    types[attrType] = usage;
                    if (usage.Inherited) 
                        attributeList.Add(attributes[i]);
                }
                else if (usage.Inherited && usage.AllowMultiple) 
                    // we saw this type already add it only if it is inheritable and it does allow multiple 
                    attributeList.Add(attributes[i]);
            }
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes10"]/*' />
        public static Attribute[]   GetCustomAttributes (ParameterInfo element, Type attributeType)
        {
            return (Attribute[])GetCustomAttributes (element, attributeType, true);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes2"]/*' />
        public static Attribute[]   GetCustomAttributes (ParameterInfo element, Type attributeType, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            
            if (!attributeType.IsSubclassOf(typeof(Attribute)) && attributeType != typeof(Attribute))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustHaveAttributeBaseClass"));

            MemberInfo member = element.Member;
            if (member.MemberType == MemberTypes.Method && inherit) 
                return InternalParamGetCustomAttributes((MethodInfo)member, element, attributeType, inherit);

            return (Attribute[])element.GetCustomAttributes(attributeType, inherit);
        }

        // For ParameterInfo's we need to make sure that we chain through all the MethodInfo's in the inheritance chain that
        // have this ParameterInfo defined. .We pick up all the CustomAttributes for the starting ParameterInfo. We need to pick up only attributes 
        // that are marked inherited from the remainder of the MethodInfo's in the inheritance chain.
        // For MethodInfo's on an interface we do not do an inheritance walk so the default ParameterInfo attributes are returned.
        // For MethodInfo's on a class we walk up the inheritance chain but do not look at the MethodInfo's on the interfaces that the
        // class inherits from and return the respective ParameterInfo attributes
        private static Attribute[] InternalParamGetCustomAttributes(MethodInfo method, ParameterInfo param, Type type, bool inherit)
        {

            ArrayList disAllowMultiple = new ArrayList();
            Object [] objAttr;

            if (type == null)
                type = s_AttributeType;

            objAttr = param.GetCustomAttributes(type, false); 
                
            for (int i=0;i<objAttr.Length;i++)
            {
                Type objType = objAttr[i].GetType();
                AttributeUsageAttribute attribUsage = InternalGetAttributeUsage(objType);
                if (attribUsage.AllowMultiple == false)
                    disAllowMultiple.Add(objType);
            }

            // Get all the attributes that have Attribute as the base class
            Attribute [] ret = null;
            if (objAttr.Length == 0) 
                ret = (Attribute[])Array.CreateInstance(type,0);
            else 
                ret = (Attribute[])objAttr;
            
            if (method.DeclaringType == null) // This is an interface so we are done.
                return ret;
            
            if (!inherit) 
                return ret;
        
            int paramPosition = param.Position;
            method = method.GetParentDefinition();
            
            while (method != null)
            {
                // Find the ParameterInfo on this method
                ParameterInfo [] parameters = method.GetParameters();
                param = parameters[paramPosition]; // Point to the correct ParameterInfo of the method

                objAttr = param.GetCustomAttributes(type, false); 
                
                int count = 0;
                for (int i=0;i<objAttr.Length;i++)
                {
                    Type objType = objAttr[i].GetType();
                    AttributeUsageAttribute attribUsage = InternalGetAttributeUsage(objType);

                    if ((attribUsage.Inherited)
                        && (disAllowMultiple.Contains(objType) == false))
                        {
                            if (attribUsage.AllowMultiple == false)
                                disAllowMultiple.Add(objType);
                            count++;
                        }
                    else
                        objAttr[i] = null;
                }

                // Get all the attributes that have Attribute as the base class
                Attribute [] attributes = (Attribute[])Array.CreateInstance(type,count);
                
                count=0;
                for (int i=0;i<objAttr.Length;i++)
                {
                    if (objAttr[i] != null)
                    {
                        attributes[count] = (Attribute)objAttr[i];
                        count++;
                    }
                }
                
                Attribute [] temp = ret;
                ret = (Attribute[])Array.CreateInstance(type,temp.Length + count);
                Array.Copy(temp,ret,temp.Length);
                
                int offset = temp.Length;

                for (int i=0;i<attributes.Length;i++) 
                    ret[offset + i] = attributes[i];
    
                method = method.GetParentDefinition();
                
            } 

            return ret;
        
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes11"]/*' />
        public static Attribute[]   GetCustomAttributes (Module element, Type attributeType)
        {
            return   GetCustomAttributes (element, attributeType, true);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes3"]/*' />
        public static Attribute[]   GetCustomAttributes (Module element, Type attributeType, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            if (attributeType == null)
                throw new ArgumentNullException("attributeType");

            if (!attributeType.IsSubclassOf(typeof(Attribute)) && attributeType != typeof(Attribute))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustHaveAttributeBaseClass"));

            return (Attribute[])element.GetCustomAttributes(attributeType, inherit);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes12"]/*' />
        public static Attribute[]   GetCustomAttributes (Assembly element, Type attributeType)
        {
            return   GetCustomAttributes (element, attributeType, true);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes4"]/*' />
        public static Attribute[]   GetCustomAttributes (Assembly element, Type attributeType, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            if (attributeType == null)
                throw new ArgumentNullException("attributeType");

            if (!attributeType.IsSubclassOf(typeof(Attribute)) && attributeType != typeof(Attribute))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustHaveAttributeBaseClass"));

            return (Attribute[])element.GetCustomAttributes(attributeType, inherit);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes13"]/*' />
        public static Attribute[] GetCustomAttributes(ParameterInfo element)
        {
            return GetCustomAttributes(element, true);
        }
        
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes5"]/*' />
        public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            MemberInfo member = element.Member;
            if (member.MemberType == MemberTypes.Method && inherit) 
                return InternalParamGetCustomAttributes((MethodInfo)member, element, null, inherit);
            
            return (Attribute[])element.GetCustomAttributes(s_AttributeType, inherit);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes14"]/*' />
        public static Attribute[] GetCustomAttributes(Module element)
        {
            return GetCustomAttributes(element, true);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes6"]/*' />
        public static Attribute[] GetCustomAttributes(Module element, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            return (Attribute[])element.GetCustomAttributes(s_AttributeType, inherit);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes15"]/*' />
        public static Attribute[] GetCustomAttributes(Assembly element)
        {
            return GetCustomAttributes(element, true);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttributes7"]/*' />
        public static Attribute[] GetCustomAttributes(Assembly element, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            return (Attribute[])element.GetCustomAttributes(s_AttributeType, inherit);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefined4"]/*' />
        public static bool IsDefined (MemberInfo    element, Type attributeType)
        {
            return IsDefined(element, attributeType, true);
        }

        // Returns true if a custom attribute subclass of attributeType class/interface with inheritance walk
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefined"]/*' />
        public static bool IsDefined (MemberInfo    element, Type attributeType, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            
            if (!attributeType.IsSubclassOf(typeof(Attribute)) && attributeType != typeof(Attribute))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustHaveAttributeBaseClass"));

            switch(element.MemberType)
            {
                case MemberTypes.Method:            
                    return ((MethodInfo)element).IsDefined(attributeType,inherit);

                case MemberTypes.TypeInfo:
                case MemberTypes.NestedType:
                    return ((Type)element).IsDefined(attributeType,inherit);

                case MemberTypes.Constructor:
                    return ((ConstructorInfo)element).IsDefined(attributeType,false);
                    
                case MemberTypes.Field: 
                    return ((FieldInfo)element).IsDefined(attributeType,false);

                case MemberTypes.Property:  
                    return InternalIsDefined((PropertyInfo)element,attributeType,false);

                case MemberTypes.Event: 
                    return InternalIsDefined((EventInfo)element,attributeType,false);

                default:
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnsupportedMemberInfoTypes"));
            }

        }

        private static bool InternalIsDefined (PropertyInfo element, Type attributeType, bool inherit)
        {
            // walk up the hierarchy chain
            if (element.IsDefined(attributeType, inherit))
                return true;
            
            if (inherit) {
                AttributeUsageAttribute usage = InternalGetAttributeUsage(attributeType);
                if (!usage.Inherited) 
                    return false;
                PropertyInfo baseProp = GetParentDefinition(element);
                while (baseProp != null) {
                    if (baseProp.IsDefined(attributeType, false))
                        return true;
                    baseProp = GetParentDefinition(baseProp);
                }
            }
            return false;
        }

        private static bool InternalIsDefined (EventInfo element, Type attributeType, bool inherit)
        {
            // walk up the hierarchy chain
            if (element.IsDefined(attributeType, inherit))
                return true;
            
            if (inherit) {
                AttributeUsageAttribute usage = InternalGetAttributeUsage(attributeType);
                if (!usage.Inherited) 
                    return false;
                EventInfo baseEvent = GetParentDefinition(element);
                while (baseEvent != null) {
                    if (baseEvent.IsDefined(attributeType, false))
                        return true;
                    baseEvent = GetParentDefinition(baseEvent);
                }
            }
            return false;
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefined5"]/*' />
        public static bool IsDefined (ParameterInfo element, Type attributeType)
        {
            return IsDefined(element, attributeType, true);
        }

        // Returns true is a custom attribute subclass of attributeType class/interface with inheritance walk
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefined1"]/*' />
        public static bool IsDefined (ParameterInfo element, Type attributeType, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            
            if (!attributeType.IsSubclassOf(typeof(Attribute)) && attributeType != typeof(Attribute))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustHaveAttributeBaseClass"));

            MemberInfo member = element.Member;

            switch(member.MemberType)
            {
                case MemberTypes.Method: // We need to climb up the member hierarchy            
                    return InternalParamIsDefined((MethodInfo)member,element,attributeType,inherit);

                case MemberTypes.Constructor:
                    return element.IsDefined(attributeType,false);

                case MemberTypes.Property:
                    return element.IsDefined(attributeType,false);

                default: 
                    BCLDebug.Assert(false,"Invalid type for ParameterInfo member in Attribute class");
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidParamInfo"));
            }
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefined6"]/*' />
        public static bool IsDefined (Module element, Type attributeType)
        {
            return IsDefined(element, attributeType, false);
        }

        // Returns true is a custom attribute subclass of attributeType class/interface with no inheritance walk
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefined2"]/*' />
        public static bool IsDefined (Module element, Type attributeType, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            if (attributeType == null)
                throw new ArgumentNullException("attributeType");

            if (!attributeType.IsSubclassOf(typeof(Attribute)) && attributeType != typeof(Attribute))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustHaveAttributeBaseClass"));

            return element.IsDefined(attributeType,false);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefined7"]/*' />
        public static bool IsDefined (Assembly element, Type attributeType)
        {
            return IsDefined (element, attributeType, true);
        }

        // Returns true is a custom attribute subclass of attributeType class/interface with no inheritance walk
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefined3"]/*' />
        public static bool IsDefined (Assembly element, Type attributeType, bool inherit)
        {
            if (element == null)
                throw new ArgumentNullException("element");

            if (attributeType == null)
                throw new ArgumentNullException("attributeType");

            if (!attributeType.IsSubclassOf(typeof(Attribute)) && attributeType != typeof(Attribute))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustHaveAttributeBaseClass"));

            return element.IsDefined(attributeType, false);
        }


        // For ParameterInfo's we need to make sure that we chain through all the MethodInfo's in the inheritance chain.
        // We pick up all the CustomAttributes for the starting ParameterInfo. We need to pick up only attributes that are marked inherited from the remainder of the ParameterInfo's in the inheritance chain.
        // For MethodInfo's on an interface we do not do an inheritance walk. For ParameterInfo's on a
        // Class we walk up the inheritance chain but do not look at the MethodInfo's on the interfaces that the
        // class inherits from.
        private static bool InternalParamIsDefined(MethodInfo method,ParameterInfo param,Type type, bool inherit)
        {
            if (param.IsDefined(type, false))
                return true;
            
            if (method.DeclaringType == null || !inherit) // This is an interface so we are done.
                return false;
        
            int paramPosition = param.Position;
            method = method.GetParentDefinition();
                        
            while (method != null)
            {
                ParameterInfo [] parameters = method.GetParameters();
                param = parameters[paramPosition]; 

                Object [] objAttr = param.GetCustomAttributes(type, false); 
                                
                for (int i=0;i<objAttr.Length;i++)
                {
                    Type objType = objAttr[i].GetType();
                    AttributeUsageAttribute attribUsage = InternalGetAttributeUsage(objType);

                    if ((objAttr[i] is Attribute) 
                            && (attribUsage.Inherited))
                            return true;
                }
                    
                method = method.GetParentDefinition();
                
            } 

            return false;
        }

        
        // Check if the custom attributes is Inheritable
        private static AttributeUsageAttribute InternalGetAttributeUsage(Type type)
        {
            Object [] obj = type.GetCustomAttributes(s_AttributeUsageType, false); 
            AttributeUsageAttribute attrib;
            if (obj.Length == 1)
                attrib = (AttributeUsageAttribute)obj[0];
            else
            if (obj.Length == 0)
                attrib = AttributeUsageAttribute.Default;
            else
                throw new FormatException(Environment.GetResourceString("Format_AttributeUsage"));
            return attrib;
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttribute4"]/*' />
        public static Attribute   GetCustomAttribute (MemberInfo    element, Type attributeType)
        {
            return   GetCustomAttribute (element, attributeType, true);
        }

        // Returns an Attribute of base class/inteface attributeType on the MemberInfo or null if none exists.
        // throws an AmbiguousMatchException if there are more than one defined.
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttribute"]/*' />
        public static Attribute   GetCustomAttribute (MemberInfo    element, Type attributeType, bool inherit)
        {
            Attribute[] attrib = GetCustomAttributes(element,attributeType,inherit);

            if (attrib.Length == 0)
                return null;

            if (attrib.Length == 1)
                return attrib[0];
            else
                throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.AmbigCust"));
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttribute5"]/*' />
        public static Attribute   GetCustomAttribute (ParameterInfo element, Type attributeType)
        {
            return GetCustomAttribute (element, attributeType, true);
        }

        // Returns an Attribute of base class/inteface attributeType on the ParameterInfo or null if none exists.
        // throws an AmbiguousMatchException if there are more than one defined.
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttribute1"]/*' />
        public static Attribute   GetCustomAttribute (ParameterInfo element, Type attributeType, bool inherit)
        {
            Attribute[] attrib = GetCustomAttributes(element,attributeType,inherit);

            if (attrib.Length == 0)
                return null;

            if (attrib.Length == 1)
                return attrib[0];
            else
                throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.AmbigCust"));
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttribute6"]/*' />
        public static Attribute   GetCustomAttribute (Module        element, Type attributeType)
        {
            return   GetCustomAttribute (element, attributeType, true);
        }

        // Returns an Attribute of base class/inteface attributeType on the Module or null if none exists.
        // throws an AmbiguousMatchException if there are more than one defined.
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttribute2"]/*' />
        public static Attribute   GetCustomAttribute (Module        element, Type attributeType, bool inherit)
        {
            Attribute[] attrib = GetCustomAttributes(element,attributeType,inherit);

            if (attrib.Length == 0)
                return null;

            if (attrib.Length == 1)
                return attrib[0];
            else
                throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.AmbigCust"));
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttribute7"]/*' />
        public static Attribute   GetCustomAttribute (Assembly      element, Type attributeType)
        {
            return   GetCustomAttribute (element, attributeType, true);
        }

        // Returns an Attribute of base class/inteface attributeType on the Assembly or null if none exists.
        // throws an AmbiguousMatchException if there are more than one defined.
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetCustomAttribute3"]/*' />
        public static Attribute   GetCustomAttribute (Assembly      element, Type attributeType, bool inherit)
        {
            Attribute[] attrib = GetCustomAttributes(element,attributeType,inherit);

            if (attrib.Length == 0)
                return null;

            if (attrib.Length == 1)
                return attrib[0];
            else
                throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.AmbigCust"));
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.TypeId"]/*' />
        public virtual Object TypeId {
            get {
                return GetType();
            }
        }
        
        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.Match"]/*' />
        public virtual bool Match(Object obj) {
            return Equals(obj);
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.Equals"]/*' />
        /// <internalonly/>
       public override bool Equals(Object obj){
			 if (obj == null) 
				return false;
 			 
			 BCLDebug.Assert((this.GetType() as RuntimeType) != null,"Only RuntimeType's are supported");
			 RuntimeType thisType = (RuntimeType)this.GetType();

			 BCLDebug.Assert((obj.GetType() as RuntimeType) != null,"Only RuntimeType's are supported");			 
			 RuntimeType thatType = (RuntimeType)obj.GetType();
 
			 if (thatType!=thisType) {
				return false;
			 }
 
			 Object thisObj = (Object)this;
			 Object thisResult, thatResult;
 
			 FieldInfo[] thisFields = thisType.InternalGetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, false);
            
			 for (int i=0; i<thisFields.Length; i++) {
				thisResult = ((RuntimeFieldInfo)thisFields[i]).InternalGetValue(thisObj,false);
				thatResult = ((RuntimeFieldInfo)thisFields[i]).InternalGetValue(obj, false);
    
				if (thisResult == null) {
					 if (thatResult != null)
					  return false;
				}
				else
				if (!thisResult.Equals(thatResult)) {
					return false;
				}
			}
 
            return true;
		}


        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.GetHashCode"]/*' />
        public override int GetHashCode()
        {
			BCLDebug.Assert((this.GetType() as RuntimeType) != null,"Only RuntimeType's are supported");
            RuntimeType runtimeType = (RuntimeType)this.GetType();

            FieldInfo[] fields = runtimeType.InternalGetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, false);
            Object vThis = null;

            for(int i = 0; i < fields.Length; i++) {
                RuntimeFieldInfo runtimeField = fields[i] as RuntimeFieldInfo;
                vThis = runtimeField.InternalGetValue(this, false);

                if (vThis != null)
                    break;
            }

            if (vThis != null)
                return vThis.GetHashCode();

            return runtimeType.GetHashCode();
        }

        /// <include file='doc\Attribute.uex' path='docs/doc[@for="Attribute.IsDefaultAttribute"]/*' />
        public virtual bool IsDefaultAttribute() {
            return false;
        }

        //
        // utility function
        //
        static private PropertyInfo GetParentDefinition(PropertyInfo property) {
            // for the current property get the base class of the getter and the setter, they might be different
            MethodInfo propAccessor = property.GetGetMethod(true); 
            if (propAccessor == null) 
                propAccessor = property.GetSetMethod(true);
            if (propAccessor != null) {
                propAccessor = propAccessor.GetParentDefinition();
                if (propAccessor != null)
                    return propAccessor.DeclaringType.GetProperty(property.Name, property.PropertyType);
            }
            return null;
        }

        static private EventInfo GetParentDefinition(EventInfo ev) {
            MethodInfo add = ev.GetAddMethod(true); 
            if (add != null) {
                add = add.GetParentDefinition();
                if (add != null) 
                    return add.DeclaringType.GetEvent(ev.Name);
            }
            return null;
        }

        private static readonly Type s_AttributeType = typeof(Attribute);
        private static readonly Type s_AttributeUsageType = typeof(AttributeUsageAttribute);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\charenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: CharEnumerator
**
** Author: Jay Roxe
**
** Purpose: Enumerates the characters on a string.  skips range
**          checks.
**
** Date: January 3, 2001
**
============================================================*/
namespace System {

    using System.Collections;

    /// <include file='doc\CharEnumerator.uex' path='docs/doc[@for="CharEnumerator"]/*' />
    [Serializable] public sealed class CharEnumerator : IEnumerator, ICloneable {
        private String str;
        private int index;
        private char currentElement;
						    
        internal CharEnumerator(String str) {
            this.str = str;
            this.index = -1;
        }

        /// <include file='doc\CharEnumerator.uex' path='docs/doc[@for="CharEnumerator.Clone"]/*' />
        public Object Clone() {
            return MemberwiseClone();
        }
    
        /// <include file='doc\CharEnumerator.uex' path='docs/doc[@for="CharEnumerator.MoveNext"]/*' />
        public bool MoveNext() {
            if (index < (str.Length-1)) {
                index++;
                currentElement = str[index];
                return true;
            }
            else
                index = str.Length;
            return false;

        }
    
        /// <include file='doc\CharEnumerator.uex' path='docs/doc[@for="CharEnumerator.IEnumerator.Current"]/*' />
        /// <internalonly/>
        Object IEnumerator.Current {
            get {
                if (index == -1)
                    throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                if (index >= str.Length)
                    throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));                        
                    
                return currentElement;
            }
        }
    
        /// <include file='doc\CharEnumerator.uex' path='docs/doc[@for="CharEnumerator.Current"]/*' />
        public char Current {
            get {
                if (index == -1)
                    throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                if (index >= str.Length)
                    throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));                                            
                return currentElement;
            }
        }

        /// <include file='doc\CharEnumerator.uex' path='docs/doc[@for="CharEnumerator.Reset"]/*' />
        public void Reset() {
            currentElement = (char)0;
            index = -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\contextboundobject.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ContextBoundObject.cool
**
** Author(s):   Tarun Anand    (TarunA)
**              
**
** Purpose: Defines the root type for all context bound types
**          
**          
**
** Date:    Sep 30, 1999
**
===========================================================*/
namespace System {   
    
	using System;
    /// <include file='doc\ContextBoundObject.uex' path='docs/doc[@for="ContextBoundObject"]/*' />
	[Serializable()]
    public abstract class ContextBoundObject : MarshalByRefObject
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\clscompliantattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: CLSCompliantAttribute
**
** Author: Rajesh Chandrashekaran ( rajeshc )
**
** Purpose: Container for assemblies.
**
** Date: Jan 28, 2000
**
=============================================================================*/

namespace System {
    /// <include file='doc\CLSCompliantAttribute.uex' path='docs/doc[@for="CLSCompliantAttribute"]/*' />
    [AttributeUsage (AttributeTargets.All, Inherited=true, AllowMultiple=false),Serializable]  
    public sealed class CLSCompliantAttribute : Attribute 
	{
		private bool m_compliant;

		/// <include file='doc\CLSCompliantAttribute.uex' path='docs/doc[@for="CLSCompliantAttribute.CLSCompliantAttribute"]/*' />
		public CLSCompliantAttribute (bool isCompliant)
		{
			m_compliant = isCompliant;
		}
		/// <include file='doc\CLSCompliantAttribute.uex' path='docs/doc[@for="CLSCompliantAttribute.IsCompliant"]/*' />
		public bool IsCompliant 
		{
			get 
			{
				return m_compliant;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\contextstaticattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:        ContextStaticAttribute.cool
**
** Author(s):   Tarun Anand    (TarunA)
**
** Purpose:     Custom attribute to indicate that the field should be treated 
**              as a static relative to a context.
**          
**
** Date:        Jan 18, 2000
**
===========================================================*/
namespace System {
    
    using System;
    using System.Runtime.Remoting;
    /// <include file='doc\ContextStaticAttribute.uex' path='docs/doc[@for="ContextStaticAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Field, Inherited = false),Serializable] 
    public class  ContextStaticAttribute : Attribute
    {
        /// <include file='doc\ContextStaticAttribute.uex' path='docs/doc[@for="ContextStaticAttribute.ContextStaticAttribute"]/*' />
        public ContextStaticAttribute()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\currenttimezone.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: CurrentTimeZone
**
** Author: Jay Roxe, Yung-Shin Lin
**
** Purpose: 
** This class represents the current system timezone.  It is
** the only meaningful implementation of the TimeZone class 
** available in this version.
**
** The only TimeZone that we support in version 1 is the 
** CurrentTimeZone as determined by the system timezone.
**
** Date: March 20, 2001
**
============================================================*/
namespace System {
    using System;
    using System.Text;
    using System.Threading;
    using System.Collections;
    using System.Globalization;
    using System.Runtime.CompilerServices;

    //
    // Currently, this is the only supported timezone.
    // The values of the timezone is from the current system timezone setting in the
    // control panel.
    //
    [Serializable()]
    internal class CurrentSystemTimeZone : TimeZone {
        // BUGBUG [YSLIN]:
        // One problem is when user changes the current timezone.  We 
        // are not able to update currentStandardName/currentDaylightName/
        // currentDaylightChanges.
        // We need Windows messages (WM_TIMECHANGE) to do this or use
        // RegNotifyChangeKeyValue() to monitor 
        //    
        private const long TicksPerMillisecond = 10000;
        private const long TicksPerSecond = TicksPerMillisecond * 1000;
        private const long TicksPerMinute = TicksPerSecond * 60;

        // The per-year information is cached in in this instance value. As a result it can
        // be cleaned up by CultureInfo.ClearCachedData, which will clear the instance of this object
        private Hashtable m_CachedDaylightChanges = new Hashtable();

        // Standard offset in ticks to the Universal time if
        // no daylight saving is in used.
        // E.g. the offset for PST (Pacific Standard time) should be -8 * 60 * 60 * 1000 * 10000.
        // (1 millisecond = 10000 ticks)
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.ticksOffset"]/*' />
        private long   m_ticksOffset;
        private String m_standardName;
        private String m_daylightName;
             
        internal CurrentSystemTimeZone() {
            m_ticksOffset = nativeGetTimeZoneMinuteOffset() * TicksPerMinute;
            m_standardName = null;
            m_daylightName = null;
        }
    
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="CurrentSystemTimeZone.StandardName"]/*' />
        public override String StandardName {
            get {
                if (m_standardName == null) {
                    m_standardName = nativeGetStandardName();
                }
                return (m_standardName);
            }    
        }

        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="CurrentSystemTimeZone.DaylightName"]/*' />
        public override String DaylightName {
            get {
                if (m_daylightName == null) {
                    m_daylightName = nativeGetDaylightName(); 
                    if (m_daylightName == null) {
                        m_daylightName = this.StandardName;
                    }
                }
                return (m_daylightName);
            }
        }
        

        internal long GetUtcOffsetFromUniversalTime(DateTime time) {
            // Get the daylight changes for the year of the specified time.
            DaylightTime daylightTime = GetDaylightChanges(time.Year);
            // This is the UTC offset for the time (which is based on Universal time), but it is calculated according to local timezone rule.
            long utcOffset = TimeZone.CalculateUtcOffset(time, daylightTime).Ticks + m_ticksOffset;
            long ticks = time.Ticks;
            if (daylightTime.Delta.Ticks != 0) {              
                // This timezone uses daylight saving rules.
                if (m_ticksOffset < 0) {
                    // This deals with GMT-XX timezones (e.g. Pacific Standard time).
                    if ((ticks >= daylightTime.Start.Ticks + daylightTime.Delta.Ticks) && (ticks < daylightTime.Start.Ticks - m_ticksOffset)) {
                        return (utcOffset - daylightTime.Delta.Ticks);
                    }
                    if ((ticks >= daylightTime.End.Ticks) && (ticks < daylightTime.End.Ticks - m_ticksOffset - daylightTime.Delta.Ticks)) {
                        return (utcOffset + daylightTime.Delta.Ticks);
                    }
                } else {
                    // This deals with GMT+XX timezones.                   
                    if ((ticks >= daylightTime.Start.Ticks - m_ticksOffset) && (ticks < daylightTime.Start.Ticks + daylightTime.Delta.Ticks)) {
                        return (utcOffset + daylightTime.Delta.Ticks);
                    }
                    if ((ticks >= daylightTime.End.Ticks - m_ticksOffset - daylightTime.Delta.Ticks) && (ticks < daylightTime.End.Ticks)) {
                        return (utcOffset - daylightTime.Delta.Ticks);
                    }                    
                }
            }
            return (utcOffset);
        }
        
        public override DateTime ToLocalTime(DateTime time) {
            return (new DateTime(time.Ticks + GetUtcOffsetFromUniversalTime(time)));
        }

        
        public override DaylightTime GetDaylightChanges(int year) {
            if (year < 1 || year > 9999) {
                throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 1, 9999));
            }
            
            Object objYear = (Object)year;

            if (!m_CachedDaylightChanges.Contains(objYear)) {
                BCLDebug.Log("Getting TimeZone information for: " + objYear);

                lock (typeof(CurrentSystemTimeZone)) {

                    if (!m_CachedDaylightChanges.Contains(objYear)) {

                        //
                        // rawData is an array of 17 short (16 bit) numbers.
                        // The first 8 numbers contains the 
                        // year/month/day/dayOfWeek/hour/minute/second/millisecond for the starting time of daylight saving time.
                        // The next 8 numbers contains the
                        // year/month/day/dayOfWeek/hour/minute/second/millisecond for the ending time of daylight saving time.
                        // The last short number is the delta to the standard offset in minutes.
                        //
                        short[] rawData = nativeGetDaylightChanges();

                        if (rawData == null) {
                            //
                            // If rawData is null, it means that daylight saving time is not used
                            // in this timezone. So keep currentDaylightChanges as the empty array.
                            //
                            m_CachedDaylightChanges.Add(objYear, new DaylightTime(DateTime.MinValue, DateTime.MinValue, TimeSpan.Zero));
                        } else {
                            DateTime start;
                            DateTime end;
                            TimeSpan delta;

                            //
                            // Store the start of daylight saving time.
                            //

                            start = GetDayOfWeek( year, rawData[1], rawData[2],
                                              rawData[3], 
                                              rawData[4], rawData[5], rawData[6], rawData[7]);

                            //
                            // Store the end of daylight saving time.
                            //
                            end = GetDayOfWeek( year, rawData[9], rawData[10],
                                            rawData[11], 
                                            rawData[12], rawData[13], rawData[14], rawData[15]);            

                            delta = new TimeSpan(rawData[16] * TicksPerMinute);                
                            DaylightTime currentDaylightChanges = new DaylightTime(start, end, delta);
                            m_CachedDaylightChanges.Add(objYear, currentDaylightChanges);
                        }
                    }
                }
            }        

            DaylightTime result = (DaylightTime)m_CachedDaylightChanges[objYear];

            return result;
        }

        public override TimeSpan GetUtcOffset(DateTime time) {
            return new TimeSpan(TimeZone.CalculateUtcOffset(time, GetDaylightChanges(time.Year)).Ticks + m_ticksOffset);
        }

        //
        // Return the (numberOfSunday)th day of week in a particular year/month.
        //
        private static DateTime GetDayOfWeek(int year, int month, int targetDayOfWeek, int numberOfSunday, int hour, int minute, int second, int millisecond) {
            DateTime time;
            
            if (numberOfSunday <= 4) {
                //
                // Get the (numberOfSunday)th Sunday.
                //
                
                time = new DateTime(year, month, 1, hour, minute, second, millisecond);
    
                int dayOfWeek = (int)time.DayOfWeek;
                int delta = targetDayOfWeek - dayOfWeek;
                if (delta < 0) {
                    delta += 7;
                }
                delta += 7 * (numberOfSunday - 1);
    
                if (delta > 0) {
                    time = time.AddDays(delta);
                }
            } else {
                //
                // If numberOfSunday is greater than 4, we will get the last sunday.
                //
                Calendar cal = GregorianCalendar.GetDefaultInstance();            
                time = new DateTime(year, month, cal.GetDaysInMonth(year, month), hour, minute, second, millisecond);
                // This is the day of week for the last day of the month.
                int dayOfWeek = (int)time.DayOfWeek;
                int delta = dayOfWeek - targetDayOfWeek;
                if (delta < 0) {
                    delta += 7;
                }
                
                if (delta > 0) {
                    time = time.AddDays(-delta);
                }
            }
            return (time);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static int nativeGetTimeZoneMinuteOffset();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static String nativeGetDaylightName();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static String nativeGetStandardName();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static short[] nativeGetDaylightChanges();
    } // class CurrentSystemTimeZone
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\contextmarshalexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ContextMarshalException
**
** Author: Chris Brumme (cbrumme)
**
** Purpose: Exception class for attempting to pass an instance through a context
**          boundary, when the formal type and the instance's marshal style are
**          incompatible.
**
** Date: July 6, 1998
**
=============================================================================*/

namespace System {
	using System.Runtime.InteropServices;
	using System.Runtime.Remoting;
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\ContextMarshalException.uex' path='docs/doc[@for="ContextMarshalException"]/*' />
    [Serializable()] public class ContextMarshalException : SystemException {
        /// <include file='doc\ContextMarshalException.uex' path='docs/doc[@for="ContextMarshalException.ContextMarshalException"]/*' />
        public ContextMarshalException() 
            : base(Environment.GetResourceString("Arg_ContextMarshalException")) {
    		SetErrorCode(__HResults.COR_E_CONTEXTMARSHAL);
        }
    
        /// <include file='doc\ContextMarshalException.uex' path='docs/doc[@for="ContextMarshalException.ContextMarshalException1"]/*' />
        public ContextMarshalException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_CONTEXTMARSHAL);
        }
    	
        /// <include file='doc\ContextMarshalException.uex' path='docs/doc[@for="ContextMarshalException.ContextMarshalException2"]/*' />
        public ContextMarshalException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_CONTEXTMARSHAL);
        }

        /// <include file='doc\ContextMarshalException.uex' path='docs/doc[@for="ContextMarshalException.ContextMarshalException3"]/*' />
        protected ContextMarshalException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\console.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Console
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: This class provides access to the standard input, standard output
**          and standard error streams.
**
** Date: March 25, 1999
**
=============================================================================*/
namespace System {
    using System;
    using System.IO;
    using System.Text;
    using System.Globalization;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.Runtime.CompilerServices;

    using System.Runtime.InteropServices;

    // Provides static fields for console input and output.  Use 
    // Console.In for input from the standard input stream (stdin),
    // Console.Out for output to stdout, and Console.Error
    // for output to stderr.  If any of those console streams are 
    // redirected from the command line, these streams will be redirected.
    // A program can also redirect its own output or input with the 
    // SetIn, SetOut, and SetError methods.
    // 
    // The distinction between Console.Out and Console.Error is useful
    // for programs that redirect output to a file or a pipe.  Note that
    // stdout and stderr can be output to different files at the same
    // time from the DOS command line:
    // 
    // someProgram 1> out 2> err
    // 
    //Contains only static data.  Serializable attribute not required.
    /// <include file='doc\Console.uex' path='docs/doc[@for="Console"]/*' />
    public sealed class Console
    {   
        private Console()
        {
            throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Constructor)); 
        }
        
        private const int _DefaultConsoleBufferSize = 256;

        private static TextReader _in;
        private static TextWriter _out;
        private static TextWriter _error;

        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Error"]/*' />
        public static TextWriter Error {
            get { return _error; }
        }

        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.In"]/*' />
        public static TextReader In {
            get {
                // Because most applications don't use stdin, we can delay 
                // initialize it slightly better startup performance.
                if (_in == null) {
                    lock(typeof(Console)) {
                        if (_in == null) {
                            // Set up Console.In
                            Stream s = OpenStandardInput(_DefaultConsoleBufferSize);
                            if (s == Stream.Null) {
                                _in = StreamReader.Null;
                            }
                            else {
                                // To avoid loading about 7 classes, don't call Encoding.GetEncoding(int)
                                Encoding enc = new CodePageEncoding(GetConsoleCPNative());
                                _in = TextReader.Synchronized(new StreamReader(s, enc, false, _DefaultConsoleBufferSize));
                            }
                        }
                    }
                }
                return _in;
            }
        }

        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Out"]/*' />
        public static TextWriter Out {
            get { return _out; }
        }
        
        static Console() {
            // For console apps, the console handles are set to values like 3, 7, 
            // and 11 OR if you've been created via CreateProcess, possibly -1
            // or 0.  -1 is definitely invalid, while 0 is probably invalid.
            // Also note each handle can independently be bad or good.
            // For Windows apps, the console handles are set to values like 3, 7, 
            // and 11 but are invalid handles - you may not write to them.  However,
            // you can still spawn a Windows app via CreateProcess and read stdout
            // and stderr.
            // So, we always need to check each handle independently for validity
            // by trying to write or read to it, unless it is -1.

            // Don't do any security check (from Security folks).  At worst
            // case, all this really wastes is your time with console spew
            // instead of breaking your computer.  For that reason, don't 
            // bother with security checks here.
            
            // Delay initialize Console.In until someone uses it.
            
            // Set up Console.Out
            Encoding outEnc = null;
            Stream s = OpenStandardOutput(_DefaultConsoleBufferSize);
            if (s == Stream.Null) {
#if _DEBUG
                if (CheckOutputDebug())
                    _out = MakeDebugOutputTextWriter("Console.Out: ");
                else
#endif
                    _out = TextWriter.Synchronized(StreamWriter.Null);
            }
            else {
                // To avoid loading about 7 classes, don't call Encoding.GetEncoding(int)
                outEnc = new CodePageEncoding(GetConsoleOutputCPNative());
                StreamWriter stdout = new StreamWriter(s, outEnc, _DefaultConsoleBufferSize);
                stdout.AutoFlush = true;
                stdout.Closable = !IsStreamAConsole(Win32Native.STD_OUTPUT_HANDLE);
                _out = TextWriter.Synchronized(stdout);
            }

            // Set up Console.Error
            s = OpenStandardError(_DefaultConsoleBufferSize);
            if (s == Stream.Null) {
#if _DEBUG
                if (CheckOutputDebug())
                    _error = MakeDebugOutputTextWriter("Console.Error: ");
                else
#endif
                    _error = TextWriter.Synchronized(StreamWriter.Null);
            }
            else {
                if (outEnc == null)
                    outEnc = new CodePageEncoding(GetConsoleOutputCPNative());
                StreamWriter stderr = new StreamWriter(s, outEnc, _DefaultConsoleBufferSize);
                stderr.AutoFlush = true;
                stderr.Closable = !IsStreamAConsole(Win32Native.STD_ERROR_HANDLE);
                _error = TextWriter.Synchronized(stderr);
            }
        }

        private static bool IsStreamAConsole(int stdHandleName)
        {
            // Decide whether the stream is a console device or whether it's a
            // file or pipe for purposes of deciding whether we can safely
            // disallow closing this stream.
            IntPtr handle = Win32Native.GetStdHandle(stdHandleName);
            int type = Win32Native.GetFileType(handle) & 0x7FFF;
            return (type == Win32Native.FILE_TYPE_CHAR);
        }


        // This is ONLY used in debug builds.  If you have a registry key set,
        // it will redirect Console.Out & Error on console-less applications to
        // your debugger's output window.
#if _DEBUG
        private static bool CheckOutputDebug()
        {
            new System.Security.Permissions.RegistryPermission(RegistryPermissionAccess.Read | RegistryPermissionAccess.Write, "HKEY_LOCAL_MACHINE").Assert();
            RegistryKey rk = Registry.LocalMachine;               
            rk = rk.OpenSubKey("Software\\Microsoft\\.NETFramework", false);
            if (rk != null) {
                Object obj = rk.GetValue("ConsoleSpewToDebugger", 0);
                if (obj != null && ((int)obj) != 0) {
                    return true;
                }
                rk.Close();
            }
            return false;
        }
#endif

#if _DEBUG
        private static TextWriter MakeDebugOutputTextWriter(String streamLabel)
        {
            TextWriter output = new __DebugOutputTextWriter(streamLabel);
            output.WriteLine("Output redirected to debugger from a bit bucket.");
            return TextWriter.Synchronized(output);
        }
#endif

        // This method is only exposed via methods to get at the console.
        // We won't use any security checks here.
        private static Stream GetStandardFile(int stdHandleName, FileAccess access, int bufferSize) {
            IntPtr handle = Win32Native.GetStdHandle(stdHandleName);
            // If someone launches a managed process via CreateProcess, stdout
            // stderr, & stdin could independently be set to INVALID_HANDLE_VALUE.
            if (handle == Win32Native.INVALID_HANDLE_VALUE) {
                //BCLDebug.ConsoleError("Console::GetStandardFile for handle "+stdHandleName+" failed, with HRESULT: "+Marshal.GetLastWin32Error()+"  Setting it to null.");
                return Stream.Null;
            }
            // Zero appears to not be a valid handle.  I haven't gotten GetStdHandle
            // to return INVALID_HANDLE_VALUE, as the docs say.
            if (handle == IntPtr.Zero) {
                //BCLDebug.ConsoleError("Console::GetStandardFile for std handle "+stdHandleName+" succeeded but returned 0.  Setting it to null.");
                return Stream.Null;
            }

            // Check whether we can read or write to this handle.
            if (stdHandleName != Win32Native.STD_INPUT_HANDLE && 0==ConsoleHandleIsValidNative(handle)) {
                //BCLDebug.ConsoleError("Console::ConsoleHandleIsValid for std handle "+stdHandleName+" failed, setting it to a null stream");
                return Stream.Null;
            }

            //BCLDebug.ConsoleError("Console::GetStandardFile for std handle "+stdHandleName+" succeeded, returning handle number "+handle.ToString());
            Stream console = new __ConsoleStream(handle, access);
            // Do not buffer console streams, or we can get into situations where
            // we end up blocking waiting for you to hit enter twice.  It was
            // a bad idea & generally redundant.  -- Brian Grunkemeyer, 8/20/2001
            return console;
        }       


        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.OpenStandardError"]/*' />
        public static Stream OpenStandardError() {
            return OpenStandardError(_DefaultConsoleBufferSize);
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.OpenStandardError1"]/*' />
        public static Stream OpenStandardError(int bufferSize) {
            return GetStandardFile(Win32Native.STD_ERROR_HANDLE,
                                   FileAccess.Write, bufferSize);
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.OpenStandardInput"]/*' />
        public static Stream OpenStandardInput() {
            return OpenStandardInput(_DefaultConsoleBufferSize);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.OpenStandardInput1"]/*' />
        public static Stream OpenStandardInput(int bufferSize) {
            return GetStandardFile(Win32Native.STD_INPUT_HANDLE,
                                   FileAccess.Read, bufferSize);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.OpenStandardOutput"]/*' />
        public static Stream OpenStandardOutput() {
            return OpenStandardOutput(_DefaultConsoleBufferSize);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.OpenStandardOutput1"]/*' />
        public static Stream OpenStandardOutput(int bufferSize) {
            return GetStandardFile(Win32Native.STD_OUTPUT_HANDLE,
                                   FileAccess.Write, bufferSize);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.SetIn"]/*' />
        public static void SetIn(TextReader newIn) {
            if (newIn == null)
                throw new ArgumentNullException("newIn");
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

            newIn = TextReader.Synchronized(newIn);
            _in = newIn;
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.SetOut"]/*' />
        public static void SetOut(TextWriter newOut) {
            if (newOut == null)
                throw new ArgumentNullException("newOut");
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            
            newOut = TextWriter.Synchronized(newOut);
            _out = newOut;
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.SetError"]/*' />
        public static void SetError(TextWriter newError) {
            if (newError == null)
                throw new ArgumentNullException("newError");
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
    
            newError = TextWriter.Synchronized(newError);
            _error = newError;
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Read"]/*' />
        public static int Read()
        {
            try {
                return In.Read();
            }
            catch (IOException e) {
                // Assume that this happened because In was an invalid handle.
                if (Marshal.GetHRForException(e) == Win32Native.MakeHRFromErrorCode(Win32Native.ERROR_INVALID_HANDLE)) {
                    // Set in to something that will give us EOF semantics.
                    _in = TextReader.Synchronized(StreamReader.Null);
                }
                else
                    throw;
            }
            return -1;
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.ReadLine"]/*' />
        public static String ReadLine()
        {
            try {
                return In.ReadLine();
            }
            catch (IOException e) {
                // Assume that this happened because In was an invalid handle.
                if (Marshal.GetHRForException(e) == Win32Native.MakeHRFromErrorCode(Win32Native.ERROR_INVALID_HANDLE)) {
                    // Set in to something that will give us EOF semantics.
                    _in = TextReader.Synchronized(StreamReader.Null);
                }
                else
                    throw;
            }
            return null;
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine"]/*' />
        public static void WriteLine()
        {
            Out.WriteLine();
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine1"]/*' />
        public static void WriteLine(bool value)
        {
            Out.WriteLine(value);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine2"]/*' />
        public static void WriteLine(char value)
        {
            Out.WriteLine(value);
        }   
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine3"]/*' />
        public static void WriteLine(char[] buffer)
        {
            Out.WriteLine(buffer);
        }
                   
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine4"]/*' />
        public static void WriteLine(char[] buffer, int index, int count)
        {
            Out.WriteLine(buffer, index, count);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine5"]/*' />
        public static void WriteLine(decimal value)
        {
            Out.WriteLine(value);
        }   

        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine6"]/*' />
        public static void WriteLine(double value)
        {
            Out.WriteLine(value);
        }   
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine7"]/*' />
        public static void WriteLine(float value)
        {
            Out.WriteLine(value);
        }   
           
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine8"]/*' />
        public static void WriteLine(int value)
        {
            Out.WriteLine(value);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine9"]/*' />
        [CLSCompliant(false)]
        public static void WriteLine(uint value)
        {
            Out.WriteLine(value);
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine10"]/*' />
        public static void WriteLine(long value)
        {
            Out.WriteLine(value);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine11"]/*' />
        [CLSCompliant(false)]
        public static void WriteLine(ulong value)
        {
            Out.WriteLine(value);
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine12"]/*' />
        public static void WriteLine(Object value)
        {
            Out.WriteLine(value);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine13"]/*' />
        public static void WriteLine(String value)
        {
            Out.WriteLine(value);
        }
    
    
        //This writes an LPCSTR
    //      __attribute NonCLSCompliantAttribute()
    //      public static void WriteLine(byte *value) {
    //          Out.WriteLine(new String(value));
    //      }
    
    //      __attribute NonCLSCompliantAttribute()
    //      public static void WriteLine(wchar *value) {
    //          Out.WriteLine(new String(value));
    //      }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine14"]/*' />
        public static void WriteLine(String format, Object arg0)
        {
            Out.WriteLine(format, arg0);
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine15"]/*' />
        public static void WriteLine(String format, Object arg0, Object arg1)
        {
            Out.WriteLine(format, arg0, arg1);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine16"]/*' />
        public static void WriteLine(String format, Object arg0, Object arg1, Object arg2)
        {
            Out.WriteLine(format, arg0, arg1, arg2);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine17"]/*' />
        [CLSCompliant(false)] 
        public static void WriteLine(String format, Object arg0, Object arg1, Object arg2,Object arg3, __arglist) 
        {
            Object[]   objArgs;
            int        argCount;
                
            ArgIterator args = new ArgIterator(__arglist);

            //+4 to account for the 4 hard-coded arguments at the beginning of the list.
            argCount = args.GetRemainingCount() + 4;
    
            objArgs = new Object[argCount];
            
            //Handle the hard-coded arguments
            objArgs[0] = arg0;
            objArgs[1] = arg1;
            objArgs[2] = arg2;
            objArgs[3] = arg3;
            
            //Walk all of the args in the variable part of the argument list.
            for (int i=4; i<argCount; i++) {
                objArgs[i] = TypedReference.ToObject(args.GetNextArg());
            }

            Out.WriteLine(format, objArgs);
        }


        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.WriteLine18"]/*' />
        public static void WriteLine(String format, params Object[] arg)
        {
            Out.WriteLine(format, arg);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write"]/*' />
        public static void Write(String format, Object arg0)
        {
            Out.Write(format, arg0);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write1"]/*' />
        public static void Write(String format, Object arg0, Object arg1)
        {
            Out.Write(format, arg0, arg1);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write2"]/*' />
        public static void Write(String format, Object arg0, Object arg1, Object arg2)
        {
            Out.Write(format, arg0, arg1, arg2);
        }

        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write3"]/*' />
        [CLSCompliant(false)] 
        public static void Write(String format, Object arg0, Object arg1, Object arg2, Object arg3, __arglist) 
        {
            Object[]   objArgs;
            int        argCount;
                
            ArgIterator args = new ArgIterator(__arglist);

            //+4 to account for the 4 hard-coded arguments at the beginning of the list.
            argCount = args.GetRemainingCount() + 4;
    
            objArgs = new Object[argCount];
            
            //Handle the hard-coded arguments
            objArgs[0] = arg0;
            objArgs[1] = arg1;
            objArgs[2] = arg2;
            objArgs[3] = arg3;
            
            //Walk all of the args in the variable part of the argument list.
            for (int i=4; i<argCount; i++) {
                objArgs[i] = TypedReference.ToObject(args.GetNextArg());
            }

            Out.Write(format, objArgs);
        }

            
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write4"]/*' />
        public static void Write(String format, params Object[] arg)
        {
            Out.Write(format, arg);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write5"]/*' />
        public static void Write(bool value)
        {
            Out.Write(value);
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write6"]/*' />
        public static void Write(char value)
        {
            Out.Write(value);
        }   
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write7"]/*' />
        public static void Write(char[] buffer)
        {
            Out.Write(buffer);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write8"]/*' />
        public static void Write(char[] buffer, int index, int count)
        {
            Out.Write(buffer, index, count);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write9"]/*' />
        public static void Write(double value)
        {
            Out.Write (value);
        }   
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write10"]/*' />
        public static void Write(decimal value)
        {
            Out.Write (value);
        }   
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write11"]/*' />
        public static void Write(float value)
        {
            Out.Write (value);
        }   
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write12"]/*' />
        public static void Write(int value)
        {
            Out.Write (value);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write13"]/*' />
        [CLSCompliant(false)]
        public static void Write(uint value)
        {
            Out.Write (value);
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write14"]/*' />
        public static void Write(long value)
        {
            Out.Write (value);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write15"]/*' />
        [CLSCompliant(false)]
        public static void Write(ulong value)
        {
            Out.Write (value);
        }
    
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write16"]/*' />
        public static void Write(Object value)
        {
            Out.Write (value);
        }
        
        /// <include file='doc\Console.uex' path='docs/doc[@for="Console.Write17"]/*' />
        public static void Write(String value)
        {
            Out.Write (value);
        }
    
    //      //This writes an LPCSTR
    //      __attribute NonCLSCompliantAttribute()
    //      public static void Write(byte *value) {
    //          Out.Write(new String(value));
    //      }
    
    //      __attribute NonCLSCompliantAttribute()
    //      public static void Write(wchar *value) {
    //          Out.Write(new String(value));
    //      }
        
        // Checks whether stdout or stderr are writable.  Do NOT pass
        // stdin here.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int ConsoleHandleIsValidNative(IntPtr handle);

        // Gets code page for stdin.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int GetConsoleCPNative();
        
        // Gets code page for stdout (and presumably stderr).
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int GetConsoleOutputCPNative();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\currency.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.CompilerServices;
    [Serializable]
	internal struct Currency : IFormattable, IComparable
    {
        // Constant representing the Currency value 0.
        public static readonly Currency Zero = new Currency(0);
    
        // Constant representing the Currency value 1.
        public static readonly Currency One = new Currency(1);
    
        // Constant representing the Currency value -1.
        public static readonly Currency MinusOne = new Currency(-1);
    
        // Constant representing the largest possible Currency value. The
        // value of this constant is 922,337,203,685,477.5807.
        public static readonly Currency MaxValue = new Currency(0x7FFFFFFFFFFFFFFFL, 0);
    
        // Constant representing the smallest possible Currency value. The
        // value of this constant is -922,337,203,685,477.5808.
        public static readonly Currency MinValue = new Currency(unchecked((long)0x8000000000000000L), 0);

		public static readonly Currency Empty = Zero;
    
    	internal const long Scale = 10000;
        private const long MinLong = unchecked((long)0x8000000000000000L) / Scale;
        private const long MaxLong = 0x7FFFFFFFFFFFFFFFL / Scale;
    
        internal long m_value;
    
        // Constructs a zero Currency.
        //public Currency() {
        //    value = 0;
        //}
    
        // Constructs a Currency from an integer value.
        //
        public Currency(int value) {
            m_value = (long)value * Scale;
        }
    
        // Constructs a Currency from an unsigned integer value.
        //
    
    	[CLSCompliant(false)]
        public Currency(uint value) {
            m_value = (long)value * Scale;
        }
    
        // Constructs a Currency from a long value.
        //
        public Currency(long value) {
            if (value < MinLong || value > MaxLong) throw new OverflowException(Environment.GetResourceString("Overflow_Currency"));
            m_value = value * Scale;
        }
    
        // Constructs a Currency from an unsigned long value.
        //
    	[CLSCompliant(false)]
        public Currency(ulong value) {
            if (value > (ulong)MaxLong) throw new OverflowException(Environment.GetResourceString("Overflow_Currency"));
            m_value = (long)(value * (ulong)Scale);
        }
    
        // Constructs a Currency from a float value.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Currency(float value);
    
        // Constructs a Currency from a double value.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Currency(double value);
    
        // Constructs a Currency from a Decimal value.
        //
        public Currency(Decimal value) {
            m_value = Decimal.ToCurrency(value).m_value;
        }
    
        // Constructs a Currency from a long value without scaling. The
        // ignored parameter exists only to distinguish this constructor
        // from the constructor that takes a long.  Used only in the System 
        // package, especially in Variant.
        internal Currency(long value, int ignored) {
            m_value = value;
        }
    
        // Returns the absolute value of the given Currency. If c is
        // positive, the result is c. If c is negative, the result
        // is -c.  If c equals Currency.MinValue, the 
        // result is Currency.MaxValue.
        //
        public static Currency Abs(Currency c) {
            if (c.m_value >= 0) return c;
            if (c.m_value == unchecked((long)0x8000000000000000L)) return Currency.MaxValue;
            return new Currency(-c.m_value, 0);
        }
    
        // Adds two Currency values.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Currency Add(Currency c1, Currency c2);
    
    	
        // Compares two Currency values, returning an integer that indicates their
        // relationship.
        //
        public static int Compare(Currency c1, Currency c2) {
            if (c1.m_value > c2.m_value) return 1;
            if (c1.m_value < c2.m_value) return -1;
            return 0;
        }
    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type Currency, this method throws an ArgumentException.
        // 
    
    	public int CompareTo(Object value)
    	{
    		if (value == null)
    			return 1;
            if (!(value is Currency))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeCurrency"));
    
            return Currency.Compare(this, (Currency)value);
    	}
    	
        // Divides two Currency values, producing a Decimal result.
        //
        public static Decimal Divide(Currency c1, Currency c2) {
            return Decimal.Divide(new Decimal(c1), new Decimal(c2));
        }
    
        // Checks if this Currency is equal to a given object. Returns
        // true if the given object is a boxed Currency and its value
        // is equal to the value of this Currency. Returns false
        // otherwise.
        //
        public override bool Equals(Object value) {
            if (value is Currency) {
                return m_value == ((Currency)value).m_value;
            }
            return false;
        }
    
        // Compares two Currency values for equality. Returns true if
        // the two Currency values are equal, or false if they are
        // not equal.
        //
        public static bool Equals(Currency c1, Currency c2) {
            return c1.m_value == c2.m_value;
        }
    
        // Rounds a Currency to an integer value. The Currency
        // argument is rounded towards negative infinity.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Currency Floor(Currency c);
    
    	public static String Format(Currency value, String format) {
            return Format(value, format, null);
        }
    
        public static String Format(Currency value, String format, NumberFormatInfo info) {
            if (info == null) info = NumberFormatInfo.CurrentInfo;
            return Number.FormatDecimal(ToDecimal(value), format, info);
        }
    
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatDecimal(ToDecimal(this), format, NumberFormatInfo.GetInstance(provider));
        }
    
        // Constructs a Currency from a string. The string must consist of an
        // optional minus sign ("-") followed by a sequence of digits ("0" - "9").
        // The sequence of digits may optionally contain a single decimal point
        // (".") character. Leading and trailing whitespace characters are allowed.
        // 
        // FromString uses the invariant NumberFormatInfo, not the 
        // NumberFormatInfo for the user's current culture.  See Parse for that
        // functionality.
        //
        public static Currency FromString(String s) {
    		return Parse(s, NumberStyles.Currency, NumberFormatInfo.InvariantInfo);
        }
    	
    	// Creates a Currency from an OLE Automation Currency.  This method
    	// applies no scaling to the Currency value, essentially doing a bitwise
    	// copy.
    	// 
    	public static Currency FromOACurrency(long cy)
    	{
    		return new Currency(cy, 0);
    	}
    	
        // Returns the hash code for this Currency.
        //
        public override int GetHashCode() {
            return (int)m_value ^ (int)(m_value >> 32);
        }
    
        // Returns the larger of two Currency values.
        //
        public static Currency Max(Currency c1, Currency c2) {
            return c1.m_value >= c2.m_value? c1: c2;
        }
    
        // Returns the smaller of two Currency values.
        //
        public static Currency Min(Currency c1, Currency c2) {
            return c1.m_value <= c2.m_value? c1: c2;
        }
    
        // Multiplies two Currency values, producing a Decimal
        // result.
        //
        public static Decimal Multiply(Currency c1, Currency c2) {
            return Decimal.Multiply(new Decimal(c1), new Decimal(c2));
        }
    
        // Returns the negated value of the given Currency. If c is
        // non-zero, the result is -c. If c is zero, the result is
        // zero.
        //
        public static Currency Negate(Currency c) {
            if (c.m_value == unchecked((long)0x8000000000000000L)) throw new OverflowException(Environment.GetResourceString("Overflow_NegateTwosCompNum"));
            return new Currency(-c.m_value, 0);
        }
    
        // Constructs a Currency from a string in a culture-sensitive way. 
        // The string must consist of an optional minus sign ("-") followed by a 
        // sequence of digits ("0" - "9"). The sequence of digits may optionally 
        // contain a single decimal point (".") character. Leading and trailing 
        // whitespace characters are allowed.
        //
    	public static Currency Parse(String s) {
            return Parse(s, NumberStyles.Currency, null);
        }
    
        public static Currency Parse(String s, NumberStyles style) {
            return Parse(s, style, null);
        }
    
        public static Currency Parse(String s, NumberStyles style, NumberFormatInfo info) {
            if (info == null) info = NumberFormatInfo.CurrentInfo;
    		return Decimal.ToCurrency(Number.ParseDecimal(s, style, info));
        }
    
        // Rounds a Currency value to a given number of decimal places. The value
        // given by c is rounded to the number of decimal places given by
        // decimals. The decimals argument must be an integer between
        // 0 and 4 inclusive.
        //
        // The operation Currency.Round(c, dec) conceptually
        // corresponds to evaluating Currency.Truncate(c *
        // 10dec + delta) / 10dec, where
        // delta is 0.5 for positive values of c and -0.5 for
        // negative values of c.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Currency Round(Currency c, int decimals);
    
        // Subtracts two Currency values.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Currency Subtract(Currency c1, Currency c2);
    
    	// Creates an OLE Automation Currency from a Currency instance.  This 
    	// method applies no scaling to the Currency value, essentially doing 
    	// a bitwise copy.
    	// 
    	public long ToOACurrency()
    	{
    		return m_value;
    	}
    	
        // Converts a Currency to a Decimal.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal ToDecimal(Currency c);
    
        // Converts a Currency to a double. Since a double has fewer
        // significant digits than a Currency, this operation may produce
        // round-off errors.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern double ToDouble(Currency c);
    
        // Converts a Currency to an integer. The Currency value is
        // rounded towards zero to the nearest integer value, and the result of
        // this operation is returned as an integer.
        //
        public static int ToInt32(Currency c) {
    		// Done this way to avoid truncation from Cy to int - roundoff error.
    		if (c.m_value < Scale*Int32.MinValue || c.m_value > Scale*Int32.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
            return (int) (c.m_value / Scale);
        }
    
        // Converts a Currency to a long. The Currency value is
        // rounded towards zero to the nearest integer value, and the result of
        // this operation is returned as a long.
        //
        public static long ToInt64(Currency c) {
            return c.m_value / Scale;
        }
    
        // Converts a Currency to a float. Since a float has fewer
        // significant digits than a Currency, this operation may produce
        // round-off errors.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern float ToSingle(Currency c);
    
        // Converts this Currency to a string. The resulting string consists
        // of an optional minus sign ("-") followed to a sequence of digits ("0" -
        // "9"), optionally followed by a decimal point (".") and another sequence
        // of digits.
        //
        public override String ToString() {
            return ToString(null, NumberFormatInfo.InvariantInfo);
        }
    
        // Converts a Currency to a string. The resulting string consists of
        // an optional minus sign ("-") followed to a sequence of digits ("0" -
        // "9"), optionally followed by a decimal point (".") and another sequence
        // of digits.
        //
        public static String ToString(Currency c) {
            return Format(c, null, NumberFormatInfo.InvariantInfo);
        }
    
        // Converts a Currency to an unsigned 32 bit integer. The 
        // Currency value is rounded towards zero to the nearest 
        // integer value, and the result of this operation is returned as 
        // a UInt32.
        //
    	
    	[CLSCompliant(false)]
        public static uint ToUInt32(Currency c) {
    		// Done this way to avoid truncation from Cy to int - roundoff error.
    		if (c.m_value < UInt32.MinValue || c.m_value > Scale*UInt32.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
            return (uint) (c.m_value / Scale);
        }
    
        // Converts a Currency to an unsigned 64 bit int. The 
        // Currency value is rounded towards zero to the nearest 
        // integer value, and the result of this operation is returned as 
        // a UInt64.
        //
    
    	[CLSCompliant(false)]
        public static ulong ToUInt64(Currency c) {
    		if (c.m_value < 0)
    			throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
            return (ulong) (c.m_value / Scale);
        }
    
        // Truncates a Currency to an integer value. The Currency
        // argument is rounded towards zero to the nearest integer value,
        // corresponding to removing all digits after the decimal point.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Currency Truncate(Currency c);
    
    	
    	public static implicit operator Currency(byte value) {
            return new Currency(value);
        }
    
    	[CLSCompliant(false)]
        public static implicit operator Currency(sbyte value) {
            return new Currency(value);
        }
    
    	public static implicit operator Currency(short value) {
            return new Currency(value);
        }
    
        public static implicit operator Currency(char value) {
            return new Currency(value);
        }
    
        public static implicit operator Currency(int value) {
            return new Currency(value);
        }
    
    	[CLSCompliant(false)]
        public static implicit operator Currency(uint value) {
            return new Currency(value);
        }
    
    	public static explicit operator Currency(long value) {
            return new Currency(value);
        }
    
    	[CLSCompliant(false)]
        public static explicit operator Currency(ulong value) {
            return new Currency(value);
        }
    
    	public static explicit operator Currency(float value) {
            return new Currency(value);
        }
    
        public static explicit operator Currency(double value) {
            return new Currency(value);
        }
    
        public static explicit operator Currency(Decimal value) {
            return Decimal.ToCurrency(value);
        }
    
        public static explicit operator byte(Currency value) {
    		if (value < Byte.MinValue || value > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
    		return (byte) ToInt32(value);
        }
    
    	[CLSCompliant(false)]
        public static explicit operator sbyte(Currency value) {
    		if (value < (short)SByte.MinValue || value > (short)SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
    		return (sbyte) ToInt32(value);
        }
    
        public static explicit operator short(Currency value) {
    		if (value < Int16.MinValue || value > Int16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
    		return (short) ToInt32(value);
        }
    
    	[CLSCompliant(false)]
        public static explicit operator ushort(Currency value) {
    		if ((long)value < (long)UInt16.MinValue || (long)value > (long)UInt16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
    		return (ushort) ToInt32(value);
        }
    
    	public static explicit operator int(Currency value) {
            return ToInt32(value);
        }
    
        public static explicit operator long(Currency value) {
            return ToInt64(value);
        }
    
        public static explicit operator float(Currency value) {
            return ToSingle(value);
        }
    
        public static explicit operator double(Currency value) {
            return ToDouble(value);
        }
    
        public static Currency operator +(Currency c) {
            return c;
        }
    
        public static Currency operator -(Currency c) {
            return Negate(c);
        }
    
        public static Currency operator +(Currency c1, Currency c2) {
            return Add(c1, c2);
        }
    
        public static Currency operator ++(Currency c) {
            return Add(c, One);
        }
    
        public static Currency operator --(Currency c) {
            return Subtract(c, One);
        }
    
        public static Currency operator -(Currency c1, Currency c2) {
            return Subtract(c1, c2);
        }
    
        public static Currency operator *(Currency c1, Currency c2) {
            return (Currency) Multiply(c1, c2);
        }
    
        public static Currency operator /(Currency c1, Currency c2) {
            return (Currency) Divide(c1, c2);
        }
    
		public static bool operator ==(Currency c1, Currency c2) {
            return c1.m_value == c2.m_value;
        }

		public static bool operator !=(Currency c1, Currency c2) {
            return c1.m_value != c2.m_value;
        }

		public static bool operator <(Currency c1, Currency c2) {
            return c1.m_value < c2.m_value;
        }
		
		public static bool operator <=(Currency c1, Currency c2) {
            return c1.m_value <= c2.m_value;
        }
		
		public static bool operator >(Currency c1, Currency c2) {
            return c1.m_value > c2.m_value;
        }
		
		public static bool operator >=(Currency c1, Currency c2) {
            return c1.m_value >= c2.m_value;
        }

       /* private static bool operator equals(Currency c1, Currency c2) {
            return c1.m_value == c2.m_value;
        }
    
        private static int operator compare(Currency c1, Currency c2) {
            if (c1.m_value > c2.m_value) return 1;
            if (c1.m_value < c2.m_value) return -1;
            return 0;
        }*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\datetime.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
    using System;
    using System.Threading;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using Calendar = System.Globalization.Calendar;

    // This value type represents a date and time.  Every DateTime 
    // object has a private field (Ticks) of type Int64 that stores the 
    // date and time as the number of 100 nanosecond intervals since 
    // 12:00 AM January 1, year 1 A.D. in the proleptic Gregorian Calendar.
    // 
    // For a description of various calendar issues, look at
    // 
    // Calendar Studies web site, at 
    // http://serendipity.nofadz.com/hermetic/cal_stud.htm.
    // 
    // 
    // Warning about 2 digit years
    // As a temporary hack until we get new DateTime <;->; String code,
    // some systems won't be able to round trip dates less than 1930.  This
    // is because we're using OleAut's string parsing routines, which look
    // at your computer's default short date string format, which uses 2 digit
    // years on most computers.  To fix this, go to Control Panel ->; Regional 
    // Settings ->; Date and change the short date style to something like
    // "M/d/yyyy" (specifying four digits for the year).
    // 
    /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime"]/*' />
    [Serializable()] 
    [StructLayout(LayoutKind.Auto)]
    public struct DateTime : IComparable, IFormattable, IConvertible
    {
        // Number of 100ns ticks per time unit
        private const long TicksPerMillisecond = 10000;
        private const long TicksPerSecond = TicksPerMillisecond * 1000;
        private const long TicksPerMinute = TicksPerSecond * 60;
        private const long TicksPerHour = TicksPerMinute * 60;
        private const long TicksPerDay = TicksPerHour * 24;
    
        // Number of milliseconds per time unit
        private const int MillisPerSecond = 1000;
        private const int MillisPerMinute = MillisPerSecond * 60;
        private const int MillisPerHour = MillisPerMinute * 60;
        private const int MillisPerDay = MillisPerHour * 24;
    
        // Number of days in a non-leap year
        private const int DaysPerYear = 365;
        // Number of days in 4 years
        private const int DaysPer4Years = DaysPerYear * 4 + 1;
        // Number of days in 100 years
        private const int DaysPer100Years = DaysPer4Years * 25 - 1;
        // Number of days in 400 years
        private const int DaysPer400Years = DaysPer100Years * 4 + 1;
    
        // Number of days from 1/1/0001 to 12/31/1600
        private const int DaysTo1601 = DaysPer400Years * 4;
        // Number of days from 1/1/0001 to 12/30/1899
        private const int DaysTo1899 = DaysPer400Years * 4 + DaysPer100Years * 3 - 367;
        // Number of days from 1/1/0001 to 12/31/9999
        private const int DaysTo10000 = DaysPer400Years * 25 - 366;
    
        private const long MinTicks = 0;
        private const long MaxTicks = DaysTo10000 * TicksPerDay - 1;
        private const long MaxMillis = (long)DaysTo10000 * MillisPerDay;
    
        private const long FileTimeOffset = DaysTo1601 * TicksPerDay;
        private const long DoubleDateOffset = DaysTo1899 * TicksPerDay;
        // The minimum OA date is 0100/01/01 (Note it's year 100).
        // The maximum OA date is 9999/12/31
        private const long OADateMinAsTicks = (DaysPer100Years - DaysPerYear) * TicksPerDay;
        // All OA dates must be greater than (not >=) OADateMinAsDouble
        private const double OADateMinAsDouble = -657435.0;
        // All OA dates must be less than (not <=) OADateMaxAsDouble
        private const double OADateMaxAsDouble = 2958466.0;
    
        private const int DatePartYear = 0;
        private const int DatePartDayOfYear = 1;
        private const int DatePartMonth = 2;
        private const int DatePartDay = 3;
    
        private static readonly int[] DaysToMonth365 = {
            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
        private static readonly int[] DaysToMonth366 = {
            0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
    
    	/// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.MinValue"]/*' />
        public static readonly DateTime MinValue = new DateTime(MinTicks);
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.MaxValue"]/*' />
        public static readonly DateTime MaxValue = new DateTime(MaxTicks);
            
        //
        // NOTE yslin: Before the time zone is introduced, ticks is based on 1/1/0001 local time.
        // 
        private long ticks;
    
        // Constructs a DateTime from a tick count. The ticks
        // argument specifies the date as the number of 100-nanosecond intervals
        // that have elapsed since 1/1/0001 12:00am.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DateTime"]/*' />
        public DateTime(long ticks) {
            if (ticks < MinTicks || ticks > MaxTicks)
                throw new ArgumentOutOfRangeException("ticks", Environment.GetResourceString("ArgumentOutOfRange_DateTimeBadTicks"));
            this.ticks = ticks;
        }

        private DateTime(long ticksFound, int ignoreMe) {
            this.ticks = ticksFound;
            if ((ulong)ticks>(ulong)MaxTicks) {
                if (ticks>MaxTicks) {
                    ticks = MaxTicks;
                } else {
                    ticks = MinTicks;
                }
            }
        }
    
        // Constructs a DateTime from a given year, month, and day. The
        // time-of-day of the resulting DateTime is always midnight.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DateTime1"]/*' />
        public DateTime(int year, int month, int day) {
            ticks = DateToTicks(year, month, day);
        }
    
        // Constructs a DateTime from a given year, month, and day for
        // the specified calendar. The
        // time-of-day of the resulting DateTime is always midnight.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DateTime2"]/*' />
        public DateTime(int year, int month, int day, Calendar calendar) 
            : this(year, month, day, 0, 0, 0, calendar) {
        }
    
        // Constructs a DateTime from a given year, month, day, hour,
        // minute, and second.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DateTime3"]/*' />
        public DateTime(int year, int month, int day, int hour, int minute, int second) {
            ticks = DateToTicks(year, month, day) + TimeToTicks(hour, minute, second);
        }
    
        // Constructs a DateTime from a given year, month, day, hour,
        // minute, and second for the specified calendar.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DateTime4"]/*' />
        public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar) {
            if (calendar == null)
                throw new ArgumentNullException("calendar");
            ticks = calendar.ToDateTime(year, month, day, hour, minute, second, 0).Ticks;
        }
    
        // Constructs a DateTime from a given year, month, day, hour,
        // minute, and second.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DateTime5"]/*' />
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond) {
            ticks = DateToTicks(year, month, day) + TimeToTicks(hour, minute, second);
            if (millisecond < 0 || millisecond >= MillisPerSecond) {
                throw new ArgumentOutOfRangeException("millisecond", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 0, MillisPerSecond - 1));
            }
            ticks += millisecond * TicksPerMillisecond;
            if (ticks < MinTicks || ticks > MaxTicks)
                throw new ArgumentException(Environment.GetResourceString("Arg_DateTimeRange"));
        }
        
        // Constructs a DateTime from a given year, month, day, hour,
        // minute, and second for the specified calendar.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DateTime6"]/*' />
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar) {
            if (calendar == null)
                throw new ArgumentNullException("calendar");
            ticks = calendar.ToDateTime(year, month, day, hour, minute, second, 0).Ticks;
            if (millisecond < 0 || millisecond >= MillisPerSecond) {
                throw new ArgumentOutOfRangeException("millisecond", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 0, MillisPerSecond - 1));
            }            
            ticks += millisecond * TicksPerMillisecond;
            if (ticks < MinTicks || ticks > MaxTicks)
                throw new ArgumentException(Environment.GetResourceString("Arg_DateTimeRange"));
        }
    
        // Returns the DateTime resulting from adding the given
        // TimeSpan to this DateTime.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Add"]/*' />
        public DateTime Add(TimeSpan value) {
            return new DateTime(ticks + value._ticks);
        }
    
        // Returns the DateTime resulting from adding a fractional number of
        // time units to this DateTime.
        private DateTime Add(double value, int scale) {
            long millis = (long)(value * scale + (value >= 0? 0.5: -0.5));
            if (millis <= -MaxMillis || millis >= MaxMillis) 
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_AddValue"));
            return new DateTime(ticks + millis * TicksPerMillisecond);
        }
    
        // Returns the DateTime resulting from adding a fractional number of
        // days to this DateTime. The result is computed by rounding the
        // fractional number of days given by value to the nearest
        // millisecond, and adding that interval to this DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.AddDays"]/*' />
        public DateTime AddDays(double value) {
            return Add(value, MillisPerDay);
        }
    
        // Returns the DateTime resulting from adding a fractional number of
        // hours to this DateTime. The result is computed by rounding the
        // fractional number of hours given by value to the nearest
        // millisecond, and adding that interval to this DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.AddHours"]/*' />
        public DateTime AddHours(double value) {
            return Add(value, MillisPerHour);
        }
    
        // Returns the DateTime resulting from the given number of
        // milliseconds to this DateTime. The result is computed by rounding
        // the number of milliseconds given by value to the nearest integer,
        // and adding that interval to this DateTime. The value
        // argument is permitted to be negative.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.AddMilliseconds"]/*' />
        public DateTime AddMilliseconds(double value) {
            return Add(value, 1);
        }
    
        // Returns the DateTime resulting from adding a fractional number of
        // minutes to this DateTime. The result is computed by rounding the
        // fractional number of minutes given by value to the nearest
        // millisecond, and adding that interval to this DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.AddMinutes"]/*' />
        public DateTime AddMinutes(double value) {
            return Add(value, MillisPerMinute);
        }
    
        // Returns the DateTime resulting from adding the given number of
        // months to this DateTime. The result is computed by incrementing
        // (or decrementing) the year and month parts of this DateTime by
        // months months, and, if required, adjusting the day part of the
        // resulting date downwards to the last day of the resulting month in the
        // resulting year. The time-of-day part of the result is the same as the
        // time-of-day part of this DateTime.
        //
        // In more precise terms, considering this DateTime to be of the
        // form y / m / d + t, where y is the
        // year, m is the month, d is the day, and t is the
        // time-of-day, the result is y1 / m1 / d1 + t,
        // where y1 and m1 are computed by adding months months
        // to y and m, and d1 is the largest value less than
        // or equal to d that denotes a valid day in month m1 of year
        // y1.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.AddMonths"]/*' />
        public DateTime AddMonths(int months) {
            if (months < -120000 || months > 120000) throw new ArgumentOutOfRangeException("months", Environment.GetResourceString("ArgumentOutOfRange_DateTimeBadMonths"));
            int y = GetDatePart(DatePartYear);
            int m = GetDatePart(DatePartMonth);
            int d = GetDatePart(DatePartDay);
            int i = m - 1 + months;
            if (i >= 0) {
                m = i % 12 + 1;
                y = y + i / 12;
            }
            else {
                m = 12 + (i + 1) % 12;
                y = y + (i - 11) / 12;
            }
            int days = DaysInMonth(y, m);
            if (d > days) d = days;
            return new DateTime(DateToTicks(y, m, d) + ticks % TicksPerDay);
        }
    
        // Returns the DateTime resulting from adding a fractional number of
        // seconds to this DateTime. The result is computed by rounding the
        // fractional number of seconds given by value to the nearest
        // millisecond, and adding that interval to this DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.AddSeconds"]/*' />
        public DateTime AddSeconds(double value) {
            return Add(value, MillisPerSecond);
        }
    
        // Returns the DateTime resulting from adding the given number of
        // 100-nanosecond ticks to this DateTime. The value argument
        // is permitted to be negative.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.AddTicks"]/*' />
        public DateTime AddTicks(long value) {
            return new DateTime(ticks + value);
        }
    
        // Returns the DateTime resulting from adding the given number of
        // years to this DateTime. The result is computed by incrementing
        // (or decrementing) the year part of this DateTime by value
        // years. If the month and day of this DateTime is 2/29, and if the
        // resulting year is not a leap year, the month and day of the resulting
        // DateTime becomes 2/28. Otherwise, the month, day, and time-of-day
        // parts of the result are the same as those of this DateTime.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.AddYears"]/*' />
        public DateTime AddYears(int value) {
            return AddMonths(value * 12);
        }
    
        
    
        // Compares two DateTime values, returning an integer that indicates
        // their relationship.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Compare"]/*' />
        public static int Compare(DateTime t1, DateTime t2) {
            if (t1.ticks > t2.ticks) return 1;
            if (t1.ticks < t2.ticks) return -1;
            return 0;
        }
    
        // Compares this DateTime to a given object. This method provides an
        // implementation of the IComparable interface. The object
        // argument must be another DateTime, or otherwise an exception
        // occurs.  Null is considered less than any instance.
        //
        // Returns a value less than zero if this  object
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) return 1;
            if (!(value is DateTime)) {
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDateTime"));
            }
    
            long t = ((DateTime)value).ticks;
            if (ticks > t) return 1;
            if (ticks < t) return -1;
            return 0;
        }
    
        // Returns the tick count corresponding to the given year, month, and day.
        // Will check the if the parameters are valid.
        private static long DateToTicks(int year, int month, int day) {     
            if (year >= 1 && year <= 9999 && month >= 1 && month <= 12) {
                int[] days = IsLeapYear(year)? DaysToMonth366: DaysToMonth365;
                if (day >= 1 && day <= days[month] - days[month - 1]) {
                    int y = year - 1;
                    int n = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;
                    return n * TicksPerDay;
                }
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_BadYearMonthDay"));
        }
    
        // Return the tick count corresponding to the given hour, minute, second.
        // Will check the if the parameters are valid.
        private static long TimeToTicks(int hour, int minute, int second)
        {
            //TimeSpan.TimeToTicks is a family access function which does no error checking, so
            //we need to put some error checking out here.
            if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >=0 && second < 60)
            {
                return (TimeSpan.TimeToTicks(hour, minute, second));
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_BadHourMinuteSecond"));
        }
    
        // Returns the number of days in the month given by the year and
        // month arguments.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DaysInMonth"]/*' />
        public static int DaysInMonth(int year, int month) {
            if (month < 1 || month > 12) throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_Month"));
            int[] days = IsLeapYear(year)? DaysToMonth366: DaysToMonth365;
            return days[month] - days[month - 1];
        }

        // Converts an OLE Date to a tick count.
        // This function is duplicated in COMDateTime.cpp
        internal static long DoubleDateToTicks(double value) {
            if (value >= OADateMaxAsDouble || value <= OADateMinAsDouble)
                throw new ArgumentException(Environment.GetResourceString("Arg_OleAutDateInvalid"));
            long millis = (long)(value * MillisPerDay + (value >= 0? 0.5: -0.5));
            // The interesting thing here is when you have a value like 12.5 it all positive 12 days and 12 hours from 01/01/1899
            // However if you a value of -12.25 it is minus 12 days but still positive 6 hours, almost as though you meant -11.75 all negative
            // This line below fixes up the millis in the negative case
            if (millis < 0) {
                millis -= (millis % MillisPerDay) * 2;
            }
            
            millis += DoubleDateOffset / TicksPerMillisecond;

            if (millis < 0 || millis >= MaxMillis) throw new ArgumentException(Environment.GetResourceString("Arg_OleAutDateScale"));
            return millis * TicksPerMillisecond;
        }

        // Checks if this DateTime is equal to a given object. Returns
        // true if the given object is a boxed DateTime and its value
        // is equal to the value of this DateTime. Returns false
        // otherwise.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Equals"]/*' />
        public override bool Equals(Object value) {
            if (value is DateTime) {
                return ticks == ((DateTime)value).ticks;
            }
            return false;
        }
    
        // Compares two DateTime values for equality. Returns true if
        // the two DateTime values are equal, or false if they are
        // not equal.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Equals1"]/*' />
        public static bool Equals(DateTime t1, DateTime t2) {
            return t1.ticks == t2.ticks;
        }
    
        // Creates a DateTime from a Windows filetime. A Windows filetime is
        // a long representing the date and time as the number of
        // 100-nanosecond intervals that have elapsed since 1/1/1601 12:00am.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.FromFileTime"]/*' />
        public static DateTime FromFileTime(long fileTime) {
            
            //We do the next operations in ticks instead of taking advantage of the TimeSpan/DateTime
            //operators because the DateTime constructor which takes two parameters silently deals
            //properly with overflows by rounding to max value or minvalue.  The publicly exposed
            //constructors throw an exception.
            DateTime univDT = FromFileTimeUtc(fileTime);
            // We can safely cast TimeZone.CurrentTimeZone to CurrentSystemTimeZone since CurrentTimeZone is a static method in TimeZone class.
            CurrentSystemTimeZone tz = (CurrentSystemTimeZone)TimeZone.CurrentTimeZone;
            long localTicks = univDT.Ticks + tz.GetUtcOffsetFromUniversalTime(univDT);
            return new DateTime(localTicks, 0);
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.FromFileTimeUtc"]/*' />
        public static DateTime FromFileTimeUtc(long fileTime) {
            if (fileTime < 0)
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_FileTimeInvalid"));

            // This is the ticks in Universal time for this fileTime.
            long universalTicks = fileTime + FileTimeOffset;            
            return new DateTime(universalTicks);
        }
    
        // Creates a DateTime from an OLE Automation Date.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.FromOADate"]/*' />
        public static DateTime FromOADate(double d) {
            return new DateTime(DoubleDateToTicks(d));
        }
    
        // Returns the date part of this DateTime. The resulting value
        // corresponds to this DateTime with the time-of-day part set to
        // zero (midnight).
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Date"]/*' />
        public DateTime Date {
            get { return new DateTime(ticks - ticks % TicksPerDay); }
        }
    
        // Returns a given date part of this DateTime. This method is used
        // to compute the year, day-of-year, month, or day part.
        private int GetDatePart(int part) {
            // n = number of days since 1/1/0001
            int n = (int)(ticks / TicksPerDay);
            // y400 = number of whole 400-year periods since 1/1/0001
            int y400 = n / DaysPer400Years;
            // n = day number within 400-year period
            n -= y400 * DaysPer400Years;
            // y100 = number of whole 100-year periods within 400-year period
            int y100 = n / DaysPer100Years;
            // Last 100-year period has an extra day, so decrement result if 4
            if (y100 == 4) y100 = 3;
            // n = day number within 100-year period
            n -= y100 * DaysPer100Years;
            // y4 = number of whole 4-year periods within 100-year period
            int y4 = n / DaysPer4Years;
            // n = day number within 4-year period
            n -= y4 * DaysPer4Years;
            // y1 = number of whole years within 4-year period
            int y1 = n / DaysPerYear;
            // Last year has an extra day, so decrement result if 4
            if (y1 == 4) y1 = 3;
            // If year was requested, compute and return it
            if (part == DatePartYear) {
                return y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1;
            }
            // n = day number within year
            n -= y1 * DaysPerYear;
            // If day-of-year was requested, return it
            if (part == DatePartDayOfYear) return n + 1;
            // Leap year calculation looks different from IsLeapYear since y1, y4,
            // and y100 are relative to year 1, not year 0
            bool leapYear = y1 == 3 && (y4 != 24 || y100 == 3);
            int[] days = leapYear? DaysToMonth366: DaysToMonth365;
            // All months have less than 32 days, so n >> 5 is a good conservative
            // estimate for the month
            int m = n >> 5 + 1;
            // m = 1-based month number
            while (n >= days[m]) m++;
            // If month was requested, return it
            if (part == DatePartMonth) return m;
            // Return 1-based day-of-month
            return n - days[m - 1] + 1;
        }
    
        // Returns the day-of-month part of this DateTime. The returned
        // value is an integer between 1 and 31.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Day"]/*' />
        public int Day {
            get { return GetDatePart(DatePartDay); }
        }
    
        // Returns the day-of-week part of this DateTime. The returned value
        // is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
        // Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
        // Thursday, 5 indicates Friday, and 6 indicates Saturday.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DayOfWeek"]/*' />
        public DayOfWeek DayOfWeek {
            get { return (DayOfWeek)((ticks / TicksPerDay + 1) % 7); }
        }
    
        // Returns the day-of-year part of this DateTime. The returned value
        // is an integer between 1 and 366.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.DayOfYear"]/*' />
        public int DayOfYear {
            get { return GetDatePart(DatePartDayOfYear); }
        }
    
        // Returns the hash code for this DateTime.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.GetHashCode"]/*' />
        public override int GetHashCode() {
            return (int)ticks ^ (int)(ticks >> 32);
        }
    
        // Returns the hour part of this DateTime. The returned value is an
        // integer between 0 and 23.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Hour"]/*' />
        public int Hour {
            get { return (int)((ticks / TicksPerHour) % 24); }
        }
    
        // Returns the millisecond part of this DateTime. The returned value
        // is an integer between 0 and 999.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Millisecond"]/*' />
        public int Millisecond {
            get { return (int)((ticks / TicksPerMillisecond) % 1000); }
        }
    
        // Returns the minute part of this DateTime. The returned value is
        // an integer between 0 and 59.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Minute"]/*' />
        public int Minute {
            get { return (int)((ticks / TicksPerMinute) % 60); }
        }
    
        // Returns the month part of this DateTime. The returned value is an
        // integer between 1 and 12.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Month"]/*' />
        public int Month {
            get { return GetDatePart(DatePartMonth); }
        }
    
        // Returns a DateTime representing the current date and time. The
        // resolution of the returned value depends on the system timer. For
        // Windows NT 3.5 and later the timer resolution is approximately 10ms,
        // for Windows NT 3.1 it is approximately 16ms, and for Windows 95 and 98
        // it is approximately 55ms.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Now"]/*' />
        public static DateTime Now {
            get { return new DateTime(GetSystemFileTime() + FileTimeOffset); }
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.UtcNow"]/*' />
        public static DateTime UtcNow {
            get { 
                long ticks = 0;
                Microsoft.Win32.Win32Native.GetSystemTimeAsFileTime(ref ticks);
                return new DateTime(ticks + FileTimeOffset);
            }
        }
    
        // Returns the second part of this DateTime. The returned value is
        // an integer between 0 and 59.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Second"]/*' />
        public int Second {
            get { return (int)((ticks / TicksPerSecond) % 60); }
        }
    
        // Returns the current date and time in Windows filetime format.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern long GetSystemFileTime();
    
        // Returns the tick count for this DateTime. The returned value is
        // the number of 100-nanosecond intervals that have elapsed since 1/1/0001
        // 12:00am.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Ticks"]/*' />
        public long Ticks {
            get { return ticks; }
        }
    
        // Returns the time-of-day part of this DateTime. The returned value
        // is a TimeSpan that indicates the time elapsed since midnight.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.TimeOfDay"]/*' />
        public TimeSpan TimeOfDay {
            get { return new TimeSpan(ticks % TicksPerDay); }
        }
    
        // Returns a DateTime representing the current date. The date part
        // of the returned value is the current date, and the time-of-day part of
        // the returned value is zero (midnight).
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Today"]/*' />
        public static DateTime Today {
            get {
                long ticks = GetSystemFileTime() + FileTimeOffset;
                return new DateTime(ticks - ticks % TicksPerDay);
            }
        }
    
        // Returns the year part of this DateTime. The returned value is an
        // integer between 1 and 9999.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Year"]/*' />
        public int Year {
            get { return GetDatePart(DatePartYear); }
        }
    
        // Checks whether a given year is a leap year. This method returns true if
        // year is a leap year, or false if not.
        //
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IsLeapYear"]/*' />
        public static bool IsLeapYear(int year) {
            return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
        }
    
        // Constructs a DateTime from a string. The string must specify a
        // date and optionally a time in a culture-specific or universal format.
        // Leading and trailing whitespace characters are allowed.
        // 
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Parse"]/*' />
        public static DateTime Parse(String s) {
            return (Parse(s, null));
        }
    
        // Constructs a DateTime from a string. The string must specify a
        // date and optionally a time in a culture-specific or universal format.
        // Leading and trailing whitespace characters are allowed.
        // 
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Parse1"]/*' />
        public static DateTime Parse(String s, IFormatProvider provider) {
            return (Parse(s, provider, DateTimeStyles.None));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Parse2"]/*' />
        public static DateTime Parse(String s, IFormatProvider provider, DateTimeStyles styles) {
            return (DateTimeParse.Parse(s, DateTimeFormatInfo.GetInstance(provider), styles));
        }
        
        // Constructs a DateTime from a string. The string must specify a
        // date and optionally a time in a culture-specific or universal format.
        // Leading and trailing whitespace characters are allowed.
        // 
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ParseExact"]/*' />
        public static DateTime ParseExact(String s, String format, IFormatProvider provider) {
            return (DateTimeParse.ParseExact(s, format, DateTimeFormatInfo.GetInstance(provider), DateTimeStyles.None));
        }

        // Constructs a DateTime from a string. The string must specify a
        // date and optionally a time in a culture-specific or universal format.
        // Leading and trailing whitespace characters are allowed.
        // 
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ParseExact1"]/*' />
        public static DateTime ParseExact(String s, String format, IFormatProvider provider, DateTimeStyles style) {
            return (DateTimeParse.ParseExact(s, format, DateTimeFormatInfo.GetInstance(provider), style));
        }    

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ParseExact2"]/*' />
        public static DateTime ParseExact(String s, String[] formats, IFormatProvider provider, DateTimeStyles style) {
            DateTime result;
            if (!DateTimeParse.ParseExactMultiple(s, formats, DateTimeFormatInfo.GetInstance(provider), style, out result)) {
                //
                // We can not parse successfully in any of the format provided.
                //
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }
            return (result);
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Subtract"]/*' />
        public TimeSpan Subtract(DateTime value) {
            return new TimeSpan(ticks - value.ticks);
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.Subtract1"]/*' />
        public DateTime Subtract(TimeSpan value) {
            return new DateTime(ticks - value._ticks);
        }
    
        // This function is duplicated in COMDateTime.cpp
        private static double TicksToOADate(long value) {
            /////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////
            /////////////// HACK HACK HACK HACK
            /////////////////////////////////////////////////////////////
            /////////////////////////////////////////////////////////////
            if (value == 0)
                return 0.0;  // Returns OleAut's zero'ed date value.
            if (value < TicksPerDay) // This is a fix for VB. They want the default day to be 1/1/0001 rathar then 12/30/1899.
                value += DoubleDateOffset; // We could have moved this fix down but we would like to keep the bounds check.
            if (value < OADateMinAsTicks)
                throw new OverflowException(Environment.GetResourceString("Arg_OleAutDateInvalid"));
            // Currently, our max date == OA's max date (12/31/9999), so we don't 
            // need an overflow check in that direction.
            long millis = (value  - DoubleDateOffset) / TicksPerMillisecond;
            if (millis < 0) {
                long frac = millis % MillisPerDay;
                if (frac != 0) millis -= (MillisPerDay + frac) * 2;
            }
            return (double)millis / MillisPerDay;
        }
    
        // Converts the DateTime instance into an OLE Automation compatible
        // double date.
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToOADate"]/*' />
        public double ToOADate() {
            return TicksToOADate(ticks);
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToFileTime"]/*' />
        public long ToFileTime() {
            // We must convert the current time to UTC time, but we can't call
            // ToUniversalTime here since we could get something that overflows
            // DateTime.MaxValue.
            long t = this.ticks - FileTimeOffset;
            // Convert to universal time
            t -= TimeZone.CurrentTimeZone.GetUtcOffset(this).Ticks;

            if (t < 0) throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_FileTimeInvalid"));
            return t;
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToFileTimeUtc"]/*' />
        public long ToFileTimeUtc() {
            long t = this.ticks - FileTimeOffset;
            if (t < 0) throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_FileTimeInvalid"));
            return t;
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToLocalTime"]/*' />
        public DateTime ToLocalTime() {
            return TimeZone.CurrentTimeZone.ToLocalTime(this);
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToLongDateString"]/*' />
        public String ToLongDateString() {
            return (ToString("D", null));
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToLongTimeString"]/*' />
        public String ToLongTimeString() {
            return (ToString("T", null));
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToShortDateString"]/*' />
        public String ToShortDateString() {
            return (ToString("d", null));
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToShortTimeString"]/*' />
        public String ToShortTimeString() {
            return (ToString("t", null));
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToString"]/*' />
        public override String ToString() {
            return ToString(null, null); 
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToString3"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }


        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToString1"]/*' />
        public String ToString(IFormatProvider provider) {
            return (ToString(null, provider)); 
        }
         
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return (DateTimeFormat.Format(this, 
                format, DateTimeFormatInfo.GetInstance(provider)));
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.ToUniversalTime"]/*' />
        public DateTime ToUniversalTime() {
            try { 
                return TimeZone.CurrentTimeZone.ToUniversalTime(this);
            } catch (Exception) {
                long tickCount = this.ticks - TimeZone.CurrentTimeZone.GetUtcOffset(this).Ticks;
                if (tickCount>MaxTicks) {
                    return new DateTime(MaxTicks);
                }
                if (tickCount<MinTicks) {
                    return new DateTime(MinTicks);
                }
                throw;
            }
        }
    
            
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorADD"]/*' />
        public static DateTime operator +(DateTime d, TimeSpan t) {
            return new DateTime(d.ticks + t._ticks);
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorSUB"]/*' />
        public static DateTime operator -(DateTime d, TimeSpan t) {
            return new DateTime(d.ticks - t._ticks);
        }
    
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorSUB1"]/*' />
        public static TimeSpan operator -(DateTime d1, DateTime d2) {
            return new TimeSpan(d1.ticks - d2.ticks);
        }
        
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorEQ"]/*' />
        public static bool operator ==(DateTime d1, DateTime d2) {
            return d1.ticks == d2.ticks;
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorNE"]/*' />
        public static bool operator !=(DateTime d1, DateTime d2) {
            return d1.ticks != d2.ticks;
        }
        
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorLT"]/*' />
        public static bool operator <(DateTime t1, DateTime t2) {
            return t1.ticks < t2.ticks;
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorLE"]/*' />
        public static bool operator <=(DateTime t1, DateTime t2) {
            return t1.ticks <= t2.ticks;
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorGT"]/*' />
        public static bool operator >(DateTime t1, DateTime t2) {
            return t1.ticks > t2.ticks;
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.operatorGE"]/*' />
        public static bool operator >=(DateTime t1, DateTime t2) {
            return t1.ticks >= t2.ticks;
        }


        // Returns a string array containing all of the known date and time options for the 
        // current culture.  The strings returned are properly formatted date and 
        // time strings for the current instance of DateTime.
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.GetDateTimeFormats"]/*' />
        public String[] GetDateTimeFormats()
        {
            return (GetDateTimeFormats(CultureInfo.CurrentCulture));
        }

        // Returns a string array containing all of the known date and time options for the 
        // using the information provided by IFormatProvider.  The strings returned are properly formatted date and 
        // time strings for the current instance of DateTime.
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.GetDateTimeFormats1"]/*' />
        public String[] GetDateTimeFormats(IFormatProvider provider)
        {
            return (DateTimeFormat.GetAllDateTimes(this, DateTimeFormatInfo.GetInstance(provider)));
        }
        
    
        // Returns a string array containing all of the date and time options for the 
        // given format format and current culture.  The strings returned are properly formatted date and 
        // time strings for the current instance of DateTime.
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.GetDateTimeFormats2"]/*' />
        public String[] GetDateTimeFormats(char format)
        {
            return (GetDateTimeFormats(format, CultureInfo.CurrentCulture));
        }
        
        // Returns a string array containing all of the date and time options for the 
        // given format format and given culture.  The strings returned are properly formatted date and 
        // time strings for the current instance of DateTime.
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.GetDateTimeFormats3"]/*' />
        public String[] GetDateTimeFormats(char format, IFormatProvider provider)
        {
            return (DateTimeFormat.GetAllDateTimes(this, format, DateTimeFormatInfo.GetInstance(provider)));
        }
        
        //
        // IValue implementation
        // 
        
        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.DateTime;
        }


        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Boolean"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Char"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "SByte"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Byte"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Int16"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "UInt16"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Int32"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "UInt32"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Int64"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "UInt64"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Single"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Double"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "DateTime", "Decimal"));
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            return this;
        }

        /// <include file='doc\DateTime.uex' path='docs/doc[@for="DateTime.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\dbnull.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Void
//	This class represents a Missing Variant
////////////////////////////////////////////////////////////////////////////////
namespace System {
    
	using System;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
    /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull"]/*' />
    [Serializable()] public sealed class DBNull : ISerializable, IConvertible {
    
        //Package private constructor
        private DBNull(){
        }

        private DBNull(SerializationInfo info, StreamingContext context) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DBNullSerial"));
        }
    	
    	/// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.Value"]/*' />
    	public static readonly DBNull Value = new DBNull();
    
        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.GetObjectData"]/*' />
        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            UnitySerializationHolder.GetUnitySerializationInfo(info, UnitySerializationHolder.NullUnity, null, null);
        }
    
        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.ToString"]/*' />
        public override String ToString() {
            return String.Empty;
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.ToString1"]/*' />
        public String ToString(IFormatProvider provider) {
            return String.Empty;
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.DBNull;
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        decimal IConvertible.ToDecimal(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(Environment.GetResourceString("InvalidCast_FromDBNull"));
        }

        /// <include file='doc\DBNull.uex' path='docs/doc[@for="DBNull.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\decimal.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;

    // Implements the Decimal data type. The Decimal data type can
    // represent values ranging from -79,228,162,514,264,337,593,543,950,335 to
    // 79,228,162,514,264,337,593,543,950,335 with 28 significant digits. The
    // Decimal data type is ideally suited to financial calculations that
    // require a large number of significant digits and no round-off errors.
    //
    // The finite set of values of type Decimal are of the form m
    // / 10e, where m is an integer such that
    // -296 < m < 296, and e is an integer
    // between 0 and 28 inclusive.
    //
    // Contrary to the float and double data types, decimal
    // fractional numbers such as 0.1 can be represented exactly in the
    // Decimal representation. In the float and double
    // representations, such numbers are often infinite fractions, making those
    // representations more prone to round-off errors.
    //
    // The Decimal class implements widening conversions from the
    // ubyte, char, short, int, and long types
    // to Decimal. These widening conversions never loose any information
    // and never throw exceptions. The Decimal class also implements
    // narrowing conversions from Decimal to ubyte, char,
    // short, int, and long. These narrowing conversions round
    // the Decimal value towards zero to the nearest integer, and then
    // converts that integer to the destination type. An OverflowException
    // is thrown if the result is not within the range of the destination type.
    //
    // The Decimal class provides a widening conversion from
    // Currency to Decimal. This widening conversion never loses any
    // information and never throws exceptions. The Currency class provides
    // a narrowing conversion from Decimal to Currency. This
    // narrowing conversion rounds the Decimal to four decimals and then
    // converts that number to a Currency. An OverflowException
    // is thrown if the result is not within the range of the Currency type.
    //
    // The Decimal class provides narrowing conversions to and from the
    // float and double types. A conversion from Decimal to
    // float or double may loose precision, but will not loose
    // information about the overall magnitude of the numeric value, and will never
    // throw an exception. A conversion from float or double to
    // Decimal throws an OverflowException if the value is not within
    // the range of the Decimal type.
    /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal"]/*' />
    [StructLayout(LayoutKind.Sequential)]
    [Serializable()] 
    public struct Decimal : IFormattable, IComparable, IConvertible
    {
        // Sign mask for the flags field. A value of zero in this bit indicates a
        // positive Decimal value, and a value of one in this bit indicates a
        // negative Decimal value.
        // 
        // Look at OleAut's DECIMAL_NEG constant to check for negative values
        // in native code.
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.SignMask"]/*' />
        private const int SignMask  = unchecked((int)0x80000000);
    
        // Scale mask for the flags field. This byte in the flags field contains
        // the power of 10 to divide the Decimal value by. The scale byte must
        // contain a value between 0 and 28 inclusive.
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ScaleMask"]/*' />
        private const int ScaleMask = 0x00FF0000;
    
        // Number of bits scale is shifted by.
        private const int ScaleShift = 16;
    
        // Constant representing the Decimal value 0.
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Zero"]/*' />
        public const Decimal Zero = 0m;
    
        // Constant representing the Decimal value 1.
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.One"]/*' />
        public const Decimal One = 1m;
    
        // Constant representing the Decimal value -1.
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.MinusOne"]/*' />
        public const Decimal MinusOne = -1m;
    
        // Constant representing the largest possible Decimal value. The value of
        // this constant is 79,228,162,514,264,337,593,543,950,335.
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.MaxValue"]/*' />
        public const Decimal MaxValue = 79228162514264337593543950335m;
    
        // Constant representing the smallest possible Decimal value. The value of
        // this constant is -79,228,162,514,264,337,593,543,950,335.
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.MinValue"]/*' />
        public const Decimal MinValue = -79228162514264337593543950335m;

    
        // The lo, mid, hi, and flags fields contain the representation of the
        // Decimal value. The lo, mid, and hi fields contain the 96-bit integer
        // part of the Decimal. Bits 0-15 (the lower word) of the flags field are
        // unused and must be zero; bits 16-23 contain must contain a value between
        // 0 and 28, indicating the power of 10 to divide the 96-bit integer part
        // by to produce the Decimal value; bits 24-30 are unused and must be zero;
        // and finally bit 31 indicates the sign of the Decimal value, 0 meaning
        // positive and 1 meaning negative.
        //
        // NOTE: Do not change the order in which these fields are declared. The
        // native methods in this class rely on this particular order.
        private int flags;
        private int hi;
        private int lo;
        private int mid;
    
        // Constructs a zero Decimal.
        //public Decimal() {
        //    lo = 0;
        //    mid = 0;
        //    hi = 0;
        //    flags = 0;
        //}
    
        // Constructs a Decimal from an integer value.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal"]/*' />
        public Decimal(int value) {
            if (value >= 0) {
                flags = 0;
            }
            else {
                flags = SignMask;
                value = -value;
            }
            lo = value;
            mid = 0;
            hi = 0;
        }
    
        // Constructs a Decimal from an unsigned integer value.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal1"]/*' />
    	[CLSCompliant(false)]
        public Decimal(uint value) {
            flags = 0;
            lo = (int) value;
            mid = 0;
            hi = 0;
        }
    
        // Constructs a Decimal from a long value.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal2"]/*' />
        public Decimal(long value) {
            if (value >= 0) {
                flags = 0;
            }
            else {
                flags = SignMask;
                value = -value;
            }
            lo = (int)value;
            mid = (int)(value >> 32);
            hi = 0;
        }
    
        // Constructs a Decimal from an unsigned long value.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal3"]/*' />
    	 [CLSCompliant(false)]
        public Decimal(ulong value) {
            flags = 0;
            lo = (int)value;
            mid = (int)(value >> 32);
            hi = 0;
        }
    
        // Constructs a Decimal from a float value.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal4"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Decimal(float value);
    
        // Constructs a Decimal from a double value.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal5"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Decimal(double value);
    
        // Constructs a Decimal from a Currency value.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal6"]/*' />
        internal Decimal(Currency value) {
            Decimal temp = Currency.ToDecimal(value);
            this.lo = temp.lo;
            this.mid = temp.mid;
            this.hi = temp.hi;
            this.flags = temp.flags;
        }

        // rajeshc: Don't remove these 2 methods below. They are required by the fx team when the are dealing with Currency in their
        // databases
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToOACurrency"]/*' />
        public static long ToOACurrency(Decimal value)
        {
            return new Currency(value).ToOACurrency();
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.FromOACurrency"]/*' />
        public static Decimal FromOACurrency(long cy)
    	{
    		return Currency.ToDecimal(Currency.FromOACurrency(cy));
    	}

    
        // Constructs a Decimal from an integer array containing a binary
        // representation. The bits argument must be a non-null integer
        // array with four elements. bits[0], bits[1], and
        // bits[2] contain the low, middle, and high 32 bits of the 96-bit
        // integer part of the Decimal. bits[3] contains the scale factor
        // and sign of the Decimal: bits 0-15 (the lower word) are unused and must
        // be zero; bits 16-23 must contain a value between 0 and 28, indicating
        // the power of 10 to divide the 96-bit integer part by to produce the
        // Decimal value; bits 24-30 are unused and must be zero; and finally bit
        // 31 indicates the sign of the Decimal value, 0 meaning positive and 1
        // meaning negative.
        //
        // Note that there are several possible binary representations for the
        // same numeric value. For example, the value 1 can be represented as {1,
        // 0, 0, 0} (integer value 1 with a scale factor of 0) and equally well as
        // {1000, 0, 0, 0x30000} (integer value 1000 with a scale factor of 3).
        // The possible binary representations of a particular value are all
        // equally valid, and all are numerically equivalent.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal7"]/*' />
        public Decimal(int[] bits) {
    		if (bits==null)
    			throw new ArgumentNullException("bits");
            if (bits.Length == 4) {
                int f = bits[3];
                if ((f & ~(SignMask | ScaleMask)) == 0 && (f & ScaleMask) <= (28 << 16)) {
                    lo = bits[0];
                    mid = bits[1];
                    hi = bits[2];
                    flags = f;
                    return;
                }
            }
            throw new ArgumentException(Environment.GetResourceString("Arg_DecBitCtor"));
        }
    
        // Constructs a Decimal from its constituent parts.
        // 
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Decimal8"]/*' />
        public Decimal(int lo, int mid, int hi, bool isNegative, byte scale) {
    		if (scale > 28)
    			throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_DecimalScale"));
            this.lo = lo;
            this.mid = mid;
            this.hi = hi;
    		this.flags = ((int)scale) << 16;
    		if (isNegative)
    			this.flags |= SignMask;
    	}
    
        // Constructs a Decimal from its constituent parts.
        private Decimal(int lo, int mid, int hi, int flags) {
            this.lo = lo;
            this.mid = mid;
            this.hi = hi;
            this.flags = flags;
        }
    
        // Returns the absolute value of the given Decimal. If d is
        // positive, the result is d. If d is negative, the result
        // is -d.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Abs"]/*' />
        internal static Decimal Abs(Decimal d) {
            return new Decimal(d.lo, d.mid, d.hi, d.flags & ~SignMask);
        }
    
        // Adds two Decimal values.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Add"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal Add(Decimal d1, Decimal d2);
       	
    	
        // Compares two Decimal values, returning an integer that indicates their
        // relationship.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Compare"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int Compare(Decimal d1, Decimal d2);
    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type Decimal, this method throws an ArgumentException.
        // 
    	/// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.CompareTo"]/*' />
    	public int CompareTo(Object value)
    	{
    		if (value == null)
    			return 1;
            if (!(value is Decimal))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDecimal"));
    
            return Decimal.Compare(this, (Decimal)value);
    	}
    	
        // Divides two Decimal values.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Divide"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal Divide(Decimal d1, Decimal d2);
    
        // Checks if this Decimal is equal to a given object. Returns true
        // if the given object is a boxed Decimal and its value is equal to the
        // value of this Decimal. Returns false otherwise.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Equals"]/*' />
        public override bool Equals(Object value) {
            if (value is Decimal) {
                return Compare(this, (Decimal)value) == 0;
            }
            return false;
        }


        // Returns the hash code for this Decimal.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.GetHashCode"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override int GetHashCode();
    
        // Compares two Decimal values for equality. Returns true if the two
        // Decimal values are equal, or false if they are not equal.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Equals1"]/*' />
        public static bool Equals(Decimal d1, Decimal d2) {
            return Compare(d1, d2) == 0;
        }

           
        // Rounds a Decimal to an integer value. The Decimal argument is rounded
        // towards negative infinity.
        //
    	/// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Floor"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern Decimal Floor(Decimal d);
    

        // Converts this Decimal to a string. The resulting string consists of an
        // optional minus sign ("-") followed to a sequence of digits ("0" - "9"),
        // optionally followed by a decimal point (".") and another sequence of
        // digits.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToString"]/*' />
        public override String ToString() {
            return ToString(null, null);
        }


        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatDecimal(this, format, NumberFormatInfo.GetInstance(provider));
        }

   
        // Converts a string to a Decimal. The string must consist of an optional
        // minus sign ("-") followed by a sequence of digits ("0" - "9"). The
        // sequence of digits may optionally contain a single decimal point (".")
        // character. Leading and trailing whitespace characters are allowed.
        // Parse also allows a currency symbol, a trailing negative sign, and
        // parentheses in the number.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Parse"]/*' />
        public static Decimal Parse(String s) {
            return Parse(s, NumberStyles.Number, null);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Parse1"]/*' />
        public static Decimal Parse(String s, NumberStyles style) {
            return Parse(s, style, null);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Parse2"]/*' />
        public static Decimal Parse(String s, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
            return Number.ParseDecimal(s, NumberStyles.Number, info);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Parse3"]/*' />
        public static Decimal Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
            return Number.ParseDecimal(s, style, info);
        }
    
        /* Returns a binary representation of a <i>Decimal</i>. The return value is an
         * integer array with four elements. Elements 0, 1, and 2 contain the low,
         * middle, and high 32 bits of the 96-bit integer part of the <i>Decimal</i>.
         * Element 3 contains the scale factor and sign of the <i>Decimal</i>: bits 0-15
         * (the lower word) are unused; bits 16-23 contain a value between 0 and
         * 28, indicating the power of 10 to divide the 96-bit integer part by to
         * produce the <i>Decimal</i> value; bits 24-30 are unused; and finally bit 31
         * indicates the sign of the <i>Decimal</i> value, 0 meaning positive and 1
         * meaning negative.
         *
         * @param d A <i>Decimal</i> value.
         * @return An integer array with four elements containing the binary
         * representation of the argument.
         * @see Decimal(int[])
         */
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.GetBits"]/*' />
        public static int[] GetBits(Decimal d) {
            return new int[] {d.lo, d.mid, d.hi, d.flags};
        }

        internal static void GetBytes(Decimal d, byte [] buffer) {
            BCLDebug.Assert((buffer != null && buffer.Length >= 16), "[GetBytes]buffer != null && buffer.Length >= 16");
            buffer[0] = (byte) d.lo;
            buffer[1] = (byte) (d.lo >> 8);
            buffer[2] = (byte) (d.lo >> 16);
            buffer[3] = (byte) (d.lo >> 24);
            
            buffer[4] = (byte) d.mid;
            buffer[5] = (byte) (d.mid >> 8);
            buffer[6] = (byte) (d.mid >> 16);
            buffer[7] = (byte) (d.mid >> 24);

            buffer[8] = (byte) d.hi;
            buffer[9] = (byte) (d.hi >> 8);
            buffer[10] = (byte) (d.hi >> 16);
            buffer[11] = (byte) (d.hi >> 24);
            
            buffer[12] = (byte) d.flags;
            buffer[13] = (byte) (d.flags >> 8);
            buffer[14] = (byte) (d.flags >> 16);
            buffer[15] = (byte) (d.flags >> 24);
        }

        internal static decimal ToDecimal(byte [] buffer) {
            int lo = ((int)buffer[0]) | ((int)buffer[1] << 8) | ((int)buffer[2] << 16) | ((int)buffer[3] << 24);
            int mid = ((int)buffer[4]) | ((int)buffer[5] << 8) | ((int)buffer[6] << 16) | ((int)buffer[7] << 24);
            int hi = ((int)buffer[8]) | ((int)buffer[9] << 8) | ((int)buffer[10] << 16) | ((int)buffer[11] << 24);
            int flags = ((int)buffer[12]) | ((int)buffer[13] << 8) | ((int)buffer[14] << 16) | ((int)buffer[15] << 24);
            return new Decimal(lo,mid,hi,flags);
        }
   
    
        // Returns the larger of two Decimal values.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Max"]/*' />
        internal static Decimal Max(Decimal d1, Decimal d2) {
            return Compare(d1, d2) >= 0? d1: d2;
        }
    
        // Returns the smaller of two Decimal values.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Min"]/*' />
        internal static Decimal Min(Decimal d1, Decimal d2) {
            return Compare(d1, d2) < 0? d1: d2;
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Remainder"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal Remainder(Decimal d1, Decimal d2);

        // Multiplies two Decimal values.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Multiply"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal Multiply(Decimal d1, Decimal d2);
    
        // Returns the negated value of the given Decimal. If d is non-zero,
        // the result is -d. If d is zero, the result is zero.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Negate"]/*' />
        public static Decimal Negate(Decimal d) {
            return new Decimal(d.lo, d.mid, d.hi, d.flags ^ SignMask);
        }
    
        // Rounds a Decimal value to a given number of decimal places. The value
        // given by d is rounded to the number of decimal places given by
        // decimals. The decimals argument must be an integer between
        // 0 and 28 inclusive.
        //
        // The operation Decimal.Round(d, dec) conceptually
        // corresponds to evaluating Decimal.Truncate(d *
        // 10^dec + delta) / 10^dec, where
        // delta is 0.5 for positive values of d and -0.5 for
        // negative values of d.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Round"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal Round(Decimal d, int decimals);
    
        // Subtracts two Decimal values.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Subtract"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal Subtract(Decimal d1, Decimal d2);
    
        // Converts a Decimal to an unsigned byte. The Decimal value is rounded
        // towards zero to the nearest integer value, and the result of this
        // operation is returned as a byte.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToByte"]/*' />
        public static byte ToByte(Decimal value) {
    		uint temp =  ToUInt32(value);
			if (temp < Byte.MinValue || temp > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
			return (byte)temp;

        }
    
        // Converts a Decimal to a signed byte. The Decimal value is rounded
        // towards zero to the nearest integer value, and the result of this
        // operation is returned as a byte.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToSByte"]/*' />
    	 [CLSCompliant(false)]
        public static sbyte ToSByte(Decimal value) {
    		int temp =  ToInt32(value);
			if (temp < SByte.MinValue || temp > SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
			return (sbyte)temp;
        }
    	
        // Converts a Decimal to a short. The Decimal value is
        // rounded towards zero to the nearest integer value, and the result of
        // this operation is returned as a short.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToInt16"]/*' />
        public static short ToInt16(Decimal value) {
    		int temp =  ToInt32(value);
			if (temp < Int16.MinValue || temp > Int16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
			return (short)temp;
        }
    
    
        // Converts a Decimal to a Currency. Since a Currency
        // has fewer significant digits than a Decimal, this operation may
        // produce round-off errors.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToCurrency"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Currency ToCurrency(Decimal d);
    
        // Converts a Decimal to a double. Since a double has fewer significant
        // digits than a Decimal, this operation may produce round-off errors.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToDouble"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern double ToDouble(Decimal d);
    
        // Converts a Decimal to an integer. The Decimal value is rounded towards
        // zero to the nearest integer value, and the result of this operation is
        // returned as an integer.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToInt32"]/*' />
        public static int ToInt32(Decimal d) {
    		if ((d.flags & ScaleMask) != 0) d = Truncate(d);
            if (d.hi == 0 && d.mid == 0) {
                int i = d.lo;
                if (d.flags >= 0) {
                    if (i >= 0) return i;
                }
                else {
                    i = -i;
                    if (i <= 0) return i;
                }
            }
            throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
        }
    
        // Converts a Decimal to a long. The Decimal value is rounded towards zero
        // to the nearest integer value, and the result of this operation is
        // returned as a long.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToInt64"]/*' />
        public static long ToInt64(Decimal d) {
    	    if ((d.flags & ScaleMask) != 0) d = Truncate(d);
            if (d.hi == 0) {
                long l = d.lo & 0xFFFFFFFFL | (long)d.mid << 32;
                if (d.flags >= 0) {
                    if (l >= 0) return l;
                }
                else {
                    l = -l;
                    if (l <= 0) return l;
                }
            }
            throw new OverflowException(Environment.GetResourceString("Overflow_Int64"));
        }
    
        // Converts a Decimal to an ushort. The Decimal 
        // value is rounded towards zero to the nearest integer value, and the 
        // result of this operation is returned as an ushort.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToUInt16"]/*' />
    	 [CLSCompliant(false)]
        public static ushort ToUInt16(Decimal value) {
    		uint temp =  ToUInt32(value);
			if (temp < UInt16.MinValue || temp > UInt16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
			return (ushort)temp;
        }
    
        // Converts a Decimal to an unsigned integer. The Decimal 
        // value is rounded towards zero to the nearest integer value, and the 
        // result of this operation is returned as an unsigned integer.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToUInt32"]/*' />
    	 [CLSCompliant(false)]
        public static uint ToUInt32(Decimal d) {
		    if ((d.flags & ScaleMask) != 0) d = Truncate(d);
            if (d.hi == 0 && d.mid == 0) {
                uint i = (uint) d.lo;
                if (d.flags >= 0 || i == 0) 
					return i;
            }
            throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
        }
    	
        // Converts a Decimal to an unsigned long. The Decimal 
        // value is rounded towards zero to the nearest integer value, and the 
        // result of this operation is returned as a long.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToUInt64"]/*' />
    	 [CLSCompliant(false)]
        public static ulong ToUInt64(Decimal d) {
    	    if ((d.flags & ScaleMask) != 0) d = Truncate(d);
            if (d.hi == 0) {
                ulong l = ((ulong)(uint)d.lo) | ((ulong)(uint)d.mid << 32);
			    if (d.flags >= 0 || l == 0)
	                return l;
            }
            throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
        }
    
        // Converts a Decimal to a float. Since a float has fewer significant
        // digits than a Decimal, this operation may produce round-off errors.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToSingle"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern float ToSingle(Decimal d);

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.ToString3"]/*' />
        public String ToString(IFormatProvider provider) {
            return ToString(null, provider);
        }    
        // Truncates a Decimal to an integer value. The Decimal argument is rounded
        // towards zero to the nearest integer value, corresponding to removing all
        // digits after the decimal point.
        //
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.Truncate"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal Truncate(Decimal d);
    
    	    	
    	/// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal"]/*' />
    	public static implicit operator Decimal(byte value) {
            return new Decimal(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal1"]/*' />
    	[CLSCompliant(false)]
        public static implicit operator Decimal(sbyte value) {
            return new Decimal(value);
        }
    
    	/// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal2"]/*' />
    	public static implicit operator Decimal(short value) {
            return new Decimal(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal3"]/*' />
        [CLSCompliant(false)]
        public static implicit operator Decimal(ushort value) {
            return new Decimal(value);
        }

		/// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal4"]/*' />
		public static implicit operator Decimal(char value) {
            return new Decimal(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal5"]/*' />
        public static implicit operator Decimal(int value) {
            return new Decimal(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal6"]/*' />
    	[CLSCompliant(false)]
        public static implicit operator Decimal(uint value) {
            return new Decimal(value);
        }
    
    	/// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal7"]/*' />
    	public static implicit operator Decimal(long value) {
            return new Decimal(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal8"]/*' />
    	[CLSCompliant(false)]
        public static implicit operator Decimal(ulong value) {
            return new Decimal(value);
        }
        
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal9"]/*' />
        public static explicit operator Decimal(float value) {
            return new Decimal(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDecimal10"]/*' />
        public static explicit operator Decimal(double value) {
            return new Decimal(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorbyte"]/*' />
        public static explicit operator byte(Decimal value) {
            return ToByte(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorsbyte"]/*' />
    	[CLSCompliant(false)]
        public static explicit operator sbyte(Decimal value) {
            return ToSByte(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorchar"]/*' />
		public static explicit operator char(Decimal value) {
            return (char)ToUInt16(value);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorshort"]/*' />
        public static explicit operator short(Decimal value) {
            return ToInt16(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorushort"]/*' />
        [CLSCompliant(false)]
    	public static explicit operator ushort(Decimal value) {
            return ToUInt16(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorint"]/*' />
    	public static explicit operator int(Decimal value) {
            return ToInt32(value);
        }
		
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatoruint"]/*' />
		[CLSCompliant(false)]
		public static explicit operator uint(Decimal value) {
            return ToUInt32(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorlong"]/*' />
        public static explicit operator long(Decimal value) {
            return ToInt64(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorulong"]/*' />
    	[CLSCompliant(false)]
        public static explicit operator ulong(Decimal value) {
            return ToUInt64(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorfloat"]/*' />
    	public static explicit operator float(Decimal value) {
            return ToSingle(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatordouble"]/*' />
        public static explicit operator double(Decimal value) {
            return ToDouble(value);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorADD1"]/*' />
        public static Decimal operator +(Decimal d) {
            return d;
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorSUB1"]/*' />
        public static Decimal operator -(Decimal d) {
            return Negate(d);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorINC"]/*' />
        public static Decimal operator ++(Decimal d) {
            return Add(d, One);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDEC"]/*' />
        public static Decimal operator --(Decimal d) {
            return Subtract(d, One);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorADD2"]/*' />
        public static Decimal operator +(Decimal d1, Decimal d2) {
            return Add(d1, d2);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorSUB2"]/*' />
        public static Decimal operator -(Decimal d1, Decimal d2) {
            return Subtract(d1, d2);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorMUL"]/*' />
        public static Decimal operator *(Decimal d1, Decimal d2) {
            return Multiply(d1, d2);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorDIV"]/*' />
        public static Decimal operator /(Decimal d1, Decimal d2) {
            return Divide(d1, d2);
        }
    
        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorMOD"]/*' />
        public static Decimal operator %(Decimal d1, Decimal d2) {
            return Remainder(d1, d2);
        }
    
        /*private static bool operator equals(Decimal d1, Decimal d2) {
            return Compare(d1, d2) == 0;
        }
    
        private static int operator compare(Decimal d1, Decimal d2) {
            int c = Compare(d1, d2);
            if (c < 0) return -1;
            if (c > 0) return 1;
            return 0;
        }*/

		/// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorEQ"]/*' />
		public static bool operator ==(Decimal d1, Decimal d2) {
            return Compare(d1, d2) == 0;
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorNE"]/*' />
        public static bool operator !=(Decimal d1, Decimal d2) {
            return Compare(d1, d2) != 0;
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorLT"]/*' />
        public static bool operator <(Decimal d1, Decimal d2) {
            return Compare(d1, d2) < 0;
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorLE"]/*' />
        public static bool operator <=(Decimal d1, Decimal d2) {
            return Compare(d1, d2) <= 0;
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorGT"]/*' />
        public static bool operator >(Decimal d1, Decimal d2) {
            return Compare(d1, d2) > 0;
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.operatorGE"]/*' />
        public static bool operator >=(Decimal d1, Decimal d2) {
            return Compare(d1, d2) >= 0;
        }

        //
        // IValue implementation
        //

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Decimal;
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
             return Convert.ToBoolean(this);
        }


        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Decimal", "Char"));
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(this);
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return this;
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Decimal", "DateTime"));
        }

        /// <include file='doc\Decimal.uex' path='docs/doc[@for="Decimal.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\dayofweek.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: DayOfWeek
**
** Author: Jay Roxe
**
** Purpose: Enum for the day of the week.
**
** Date: November 28, 2000
**
============================================================*/
namespace System {

    /// <include file='doc\DayOfWeek.uex' path='docs/doc[@for="DayOfWeek"]/*' />
    [Serializable]
    public enum DayOfWeek {
        /// <include file='doc\DayOfWeek.uex' path='docs/doc[@for="DayOfWeek.Sunday "]/*' />
        Sunday = 0,
        /// <include file='doc\DayOfWeek.uex' path='docs/doc[@for="DayOfWeek.Monday "]/*' />
        Monday = 1,
        /// <include file='doc\DayOfWeek.uex' path='docs/doc[@for="DayOfWeek.Tuesday "]/*' />
        Tuesday = 2,
        /// <include file='doc\DayOfWeek.uex' path='docs/doc[@for="DayOfWeek.Wednesday "]/*' />
        Wednesday = 3,
        /// <include file='doc\DayOfWeek.uex' path='docs/doc[@for="DayOfWeek.Thursday "]/*' />
        Thursday = 4,
        /// <include file='doc\DayOfWeek.uex' path='docs/doc[@for="DayOfWeek.Friday "]/*' />
        Friday = 5,
        /// <include file='doc\DayOfWeek.uex' path='docs/doc[@for="DayOfWeek.Saturday "]/*' />
        Saturday = 6,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\defaultbinder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// This class represents the Default COM+ binder.
//
// Author: darylo
// Date: April 99
//
namespace System {

	using System;
	using System.Reflection;
	using System.Runtime.CompilerServices;
	using CultureInfo = System.Globalization.CultureInfo;
    //Marked serializable even though it has no state.
	[Serializable()]
    internal class DefaultBinder : Binder
    {
    	// This method is passed a set of methods and must choose the best
    	// fit.  The methods all have the same number of arguments and the object
    	// array args.  On exit, this method will choice the best fit method
    	// and coerce the args to match that method.  By match, we mean all primitive
    	// arguments are exact matchs and all object arguments are exact or subclasses
    	// of the target.  If the target OR is an interface, the object must implement
    	// that interface.  There are a couple of exceptions
    	// thrown when a method cannot be returned.  If no method matchs the args and
    	// ArgumentException is thrown.  If multiple methods match the args then 
    	// an AmbiguousMatchException is thrown.
    	// 
    	// The most specific match will be selected.  
    	// 
    	public override MethodBase BindToMethod(BindingFlags bindingAttr,MethodBase[] match,ref Object[] args,ParameterModifier[] modifiers,CultureInfo cultureInfo,String[] names, out Object state)
    	{
    		int i;
    		int j;
 			//Console.WriteLine("DefaultBinder.BindToMethod:" + (int) bindingAttr);
   		
            state = null;
    		if (match == null || match.Length == 0)
    			throw new ArgumentException(Environment.GetResourceString("Arg_EmptyArray"),"match");
    		
    		// We are creating an paramOrder array to act as a mapping
    		//	between the order of the args and the actual order of the
    		//	parameters in the method.  This order may differ because
    		//	named parameters (names) may change the order.  If names
    		//	is not provided, then we assume the default mapping (0,1,...)
    		int[][] paramOrder = new int[match.Length][];
    		for (i=0;i<match.Length;i++) {
                ParameterInfo[] par = match[i].GetParameters();
                // args.Length + 1 takes into account the possibility of a last paramArray that can be omitted
    			paramOrder[i] = new int[(par.Length > args.Length) ? par.Length : args.Length];
    			if (names == null) {
    				// Default mapping
    				for (j=0;j<args.Length;j++)
    					paramOrder[i][j] = j;
    			}
    			else {
    				// Named parameters, reorder the mapping.  If 
    				//	CreateParamOrder fails, it means that the method
    				//	doesn't have a name that matchs one of the named
       				//	parameters so we don't consider it any further.
    				 if (!CreateParamOrder(paramOrder[i],par,names))
    					 match[i] = null;
    			}				
    		}

            Type[] paramArrayTypes = new Type[match.Length];
    		
    		// object that contain a null are treated as
    		//	if they were typeless (but match either object references
    		//	or value classes).  We mark this condition by
    		//	placing a null in the argTypes array.
    		Type[] argTypes = new Type[args.Length];
    		for (i=0;i<args.Length;i++) {
    			if (args[i] != null)
    				argTypes[i] = args[i].GetType();
    		}
    		
    		// Find the method that match...
    		int CurIdx = 0;
			bool defaultValueBinding = ((bindingAttr & BindingFlags.OptionalParamBinding) != 0);
            Type paramArrayType = null;
			//Console.WriteLine("Default Value Binding:" + defaultValueBinding);
    		for (i=0;i<match.Length;i++) {
                paramArrayType = null;
    			// If we have named parameters then we may
    			//	have hole in the match array.
    			if (match[i] == null)
    				continue;
    			
    			// Validate the parameters.
    			ParameterInfo[] par = match[i].GetParameters();
                if (par.Length == 0) {
                    if (args.Length != 0)
                        if ((match[i].CallingConvention & CallingConventions.VarArgs) == 0) 
                            continue;
                    // This is a valid routine so we move it up the match list.
                    paramOrder[CurIdx] = paramOrder[i];
                    match[CurIdx++] = match[i];
                    continue;
                }
                else if (par.Length > args.Length) {
                    // If the number of parameters is greater than the number
                    //	of args then we are in the situation were we may
                    //	be using default values.
                    for (j=args.Length;j<par.Length - 1;j++) {
                        if (par[j].DefaultValue == System.DBNull.Value)
                            break;
                    }
                    if (j != par.Length - 1)
                        continue;		
                    if (par[j].DefaultValue == System.DBNull.Value) {
                        if (!par[j].ParameterType.IsArray) 
                            continue;
                        if (!par[j].IsDefined(typeof(ParamArrayAttribute), true)) 
                            continue;
                        paramArrayType = par[j].ParameterType.GetElementType();
                    }
                }
                else if (par.Length < args.Length) {
                    // test for the ParamArray case
                    int lastArgPos = par.Length - 1;
                    if (!par[lastArgPos].ParameterType.IsArray) 
                        continue;
                    if (!par[lastArgPos].IsDefined(typeof(ParamArrayAttribute), true)) 
                        continue;
                    if (paramOrder[i][lastArgPos] != lastArgPos)
                        continue; 
                    paramArrayType = par[lastArgPos].ParameterType.GetElementType();
                }
                else {
                    int lastArgPos = par.Length - 1;
                    if (par[lastArgPos].ParameterType.IsArray
                            && par[lastArgPos].IsDefined(typeof(ParamArrayAttribute), true)
                            && paramOrder[i][lastArgPos] == lastArgPos)
                        paramArrayType = par[lastArgPos].ParameterType.GetElementType();
                }
                // at this point formal and actual are compatible in arguments number, deal with the type
                Type pCls = null;
                int argsToCheck = (paramArrayType != null) ? par.Length - 1 : args.Length;
    			for (j = 0; j < argsToCheck; j++) {
                    // get the formal type
    				pCls = par[j].ParameterType;
					if (pCls.IsByRef)
						pCls = pCls.GetElementType();

					//Console.WriteLine(argTypes[paramOrder[i][j]] + ":" + pCls);
                    // some easy matching conditons...
                    // the type is the same
    				if (pCls == argTypes[paramOrder[i][j]])
    					continue;
                    // a default value is available
    				if (defaultValueBinding && args[paramOrder[i][j]] == Type.Missing)
    					continue;	
                    // the argument was null, so it matches with everything
    				if (args[paramOrder[i][j]] == null)
    					continue;
                    // the type is Object, so it will match everything
    				if (pCls == typeof(Object))
    					continue;

                    // now do a "classic" type check
    				if (pCls.IsPrimitive) {
    					if (argTypes[paramOrder[i][j]] == null || !CanConvertPrimitiveObjectToType(args[paramOrder[i][j]],(RuntimeType)pCls))
    						break;
    				}
    				else {
    					if (argTypes[paramOrder[i][j]] == null)
    						continue;
						if (!pCls.IsAssignableFrom(argTypes[paramOrder[i][j]])) {
							if (argTypes[paramOrder[i][j]].IsCOMObject) {
								//Console.WriteLine(args[paramOrder[i][j]].GetType());
								if (pCls.IsInstanceOfType(args[paramOrder[i][j]]))
									continue;
							}
    						break;
						}
    				}
    			}
                if (paramArrayType != null && j == par.Length - 1) {
                    // check that the rest of the args are of the type of the paramArray
                    for (; j < args.Length; j++) {
    				    if (paramArrayType.IsPrimitive) {
    					    if (argTypes[j] == null || !CanConvertPrimitiveObjectToType(args[j], (RuntimeType)paramArrayType))
    						    break;
    				    }
    				    else {
    					    if (argTypes[j] == null)
    						    continue;
						    if (!paramArrayType.IsAssignableFrom(argTypes[j])) {
							    if (argTypes[j].IsCOMObject) {
								    //Console.WriteLine(args[paramOrder[i][j]].GetType());
								    if (paramArrayType.IsInstanceOfType(args[j]))
									    continue;
							    }
    						    break;
						    }
    				    }
                    }
                }
    			if (j == args.Length) {
                    // This is a valid routine so we move it up the match list.
    				paramOrder[CurIdx] = paramOrder[i];
                    paramArrayTypes[CurIdx] = paramArrayType;
    				match[CurIdx++] = match[i];
    			}
    		}
    		// If we didn't find a method 
			if (CurIdx == 0)
    			throw new MissingMethodException(Environment.GetResourceString("MissingMember"));

			// If we only found one method.
    		if (CurIdx == 1) {
                if (names != null) {
                    state = new BinderState((int[])paramOrder[0].Clone(), args.Length, paramArrayTypes[0] != null);
                    ReorderParams(paramOrder[0],args);
                }
    			
    			// If the parameters and the args are not the same length or there is a paramArray
    			//	then we need to create a argument array.
    			ParameterInfo[] parms = match[0].GetParameters();			   
                if (parms.Length == args.Length) {
                    if (paramArrayTypes[0] != null) {
                        Object[] objs = new Object[parms.Length];
                        int lastPos = parms.Length - 1;
                        Array.Copy(args, 0, objs, 0, lastPos);
                        objs[lastPos] = Array.CreateInstance(paramArrayTypes[0], 1); 
                        ((Array)objs[lastPos]).SetValue(args[lastPos], 0);
                        args = objs;
                    }
                }
                else if (parms.Length > args.Length) {
                    Object[] objs = new Object[parms.Length];
                    for (i=0;i<args.Length;i++)
                        objs[i] = args[i];
                    for (;i<parms.Length - 1;i++)
                        objs[i] = parms[i].DefaultValue;
                    if (paramArrayTypes[0] != null) 
                        objs[i] = Array.CreateInstance(paramArrayTypes[0], 0); // create an empty array for the 
                    else
                        objs[i] = parms[i].DefaultValue;
                    args = objs;
                }
                else {
                    if ((match[0].CallingConvention & CallingConventions.VarArgs) == 0) {
                        Object[] objs = new Object[parms.Length];
                        int paramArrayPos = parms.Length - 1;
                        Array.Copy(args, 0, objs, 0, paramArrayPos);
                        objs[paramArrayPos] = Array.CreateInstance(paramArrayTypes[0], args.Length - paramArrayPos); 
                        Array.Copy(args, paramArrayPos, (System.Array)objs[paramArrayPos], 0, args.Length - paramArrayPos);
                        args = objs;
                    }
                }
    			return match[0];
    		}
    		
    		// Walk all of the methods looking the most specific method to invoke
    		int currentMin = 0;
    		bool ambig = false;
    		for (i=1;i<CurIdx;i++) {
    			int newMin = FindMostSpecificMethod(match[currentMin], paramOrder[currentMin], match[i], paramOrder[i], argTypes, args);
    			if (newMin == 0)
    				ambig = true;
    			else {
    				if (newMin == 2) {
    					currentMin = i;
    					ambig = false;
    				}
    			}
    		}
    		if (ambig)
    			throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
    		// Reorder (if needed)
    		if (names != null) {
                state = new BinderState((int[])paramOrder[currentMin].Clone(), args.Length, paramArrayTypes[currentMin] != null);
    			ReorderParams(paramOrder[currentMin],args);
            }
    			
    		// If the parameters and the args are not the same length or there is a paramArray
    		//	then we need to create a argument array.
    		ParameterInfo[] parameters = match[currentMin].GetParameters();
            if (parameters.Length == args.Length) {
                if (paramArrayTypes[currentMin] != null) {
                    Object[] objs = new Object[parameters.Length];
                    int lastPos = parameters.Length - 1;
                    Array.Copy(args, 0, objs, 0, lastPos);
                    objs[lastPos] = Array.CreateInstance(paramArrayTypes[currentMin], 1); 
					((Array)objs[lastPos]).SetValue(args[lastPos], 0);
                    args = objs;
                }
            }
            else if (parameters.Length > args.Length) {
                Object[] objs = new Object[parameters.Length];
                for (i=0;i<args.Length;i++)
                    objs[i] = args[i];
                for (;i<parameters.Length - 1;i++)
                    objs[i] = parameters[i].DefaultValue;
                if (paramArrayTypes[currentMin] != null) 
                    objs[i] = Array.CreateInstance(paramArrayTypes[currentMin], 0); // create an empty array for the 
                else
                    objs[i] = parameters[i].DefaultValue;
                args = objs;
            }
            else {
                if ((match[currentMin].CallingConvention & CallingConventions.VarArgs) == 0) {
                    Object[] objs = new Object[parameters.Length];
                    int paramArrayPos = parameters.Length - 1;
                    Array.Copy(args, 0, objs, 0, paramArrayPos);
                    objs[i] = Array.CreateInstance(paramArrayTypes[currentMin], args.Length - paramArrayPos); 
                    Array.Copy(args, paramArrayPos, (System.Array)objs[i], 0, args.Length - paramArrayPos);
                    args = objs;
                }
            }

    		return match[currentMin];
    	}
    
    	
    	// Given a set of fields that match the base criteria, select a field.
    	// if value is null then we have no way to select a field
    	public override FieldInfo BindToField(BindingFlags bindingAttr,FieldInfo[] match, Object value,CultureInfo cultureInfo)
    	{
    		int i;
    		// Find the method that match...
    		int CurIdx = 0;
    		
    		// If we have an empty (FieldGet) then we must be
    		//	ambiguous...
    		Type valueType = value.GetType();
    		if (valueType == null)
    			throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
    			
    		for (i=0;i<match.Length;i++) {
    			Type pCls = match[i].FieldType;
    			if (pCls == valueType) {
    				match[CurIdx++] = match[i];
    				continue;
    			}
                if (value == Empty.Value) {
                    // the object passed in was null which would match any non primitive non value type
                    if (pCls.IsClass) {
                        match[CurIdx++] = match[i];
                        continue;
                    }
                }
    			if (pCls == typeof(Object)) {
    				match[CurIdx++] = match[i];
    				continue;
    			}
    			if (pCls.IsPrimitive) {
    				if (CanConvertPrimitiveObjectToType(value,(RuntimeType)pCls)) {
    					match[CurIdx++] = match[i];
    					continue;
    				}
    			}
    			else {
    				if (pCls.IsAssignableFrom(valueType)) {
    					match[CurIdx++] = match[i];
    					continue;
    				}
    			}
    		}
    		if (CurIdx == 0)
    			throw new ArgumentException(Environment.GetResourceString("MissingField"));
    		if (CurIdx == 1)
    			return match[0];
    		
    		// Walk all of the methods looking the most specific method to invoke
    		int currentMin = 0;
    		bool ambig = false;
    		for (i=1;i<CurIdx;i++) {
    			int newMin = FindMostSpecificField(match[currentMin], match[i], valueType);
    			if (newMin == 0)
    				ambig = true;
    			else {
    				if (newMin == 2) {
    					currentMin = i;
    					ambig = false;
    					currentMin = i;
    				}
    			}
    		}
    		if (ambig)
    			throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
    		return match[currentMin];
    	}
    	
    	// Given a set of methods that match the base criteria, select a method based
    	// upon an array of types.  This method should return null if no method matchs
    	// the criteria.
    	public override MethodBase SelectMethod(BindingFlags bindingAttr,MethodBase[] match,Type[] types,ParameterModifier[] modifiers)
    	{
    		int i;
    		int j;
    		
    		Type[] realTypes = new Type[types.Length];
    		for (i=0;i<types.Length;i++) {
    			realTypes[i] = types[i].UnderlyingSystemType;
    			if (!(realTypes[i] is RuntimeType))
    				throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"types");
    		}
    		types = realTypes;
    		
    		// @TODO: For the moment we don't automatically jump out on exact match.
    		//	This sucks but not much we can do about it...
    		if (match == null || match.Length == 0)
    			throw new ArgumentException(Environment.GetResourceString("Arg_EmptyArray"),"match");
    		
    		// Find all the methods that can be described by the types parameter. 
    		//	Remove all of them that cannot.
    		int CurIdx = 0;
    		for (i=0;i<match.Length;i++) {
				//Console.WriteLine(match[i]);
    			ParameterInfo[] par = match[i].GetParameters();
    			if (par.Length != types.Length)
    				continue;
    			for (j=0;j<types.Length;j++) {
    				Type pCls = par[j]. ParameterType;
					//Console.WriteLine(pCls);
    				if (pCls == types[j])
    					continue;
    				if (pCls == typeof(Object))
    					continue;
    				if (pCls.IsPrimitive) {
    					if (!(types[j].UnderlyingSystemType is RuntimeType) ||
                            !CanConvertPrimitive((RuntimeType)types[j].UnderlyingSystemType,(RuntimeType)pCls.UnderlyingSystemType))
    						break;
    				}
    				else {
    					if (!pCls.IsAssignableFrom(types[j]))
    						break;
    				}
    			}
    			if (j == types.Length)
    				match[CurIdx++] = match[i];
    		}
    		if (CurIdx == 0)
    			return null;
    		if (CurIdx == 1)
    			return match[0];
    		
    		// Walk all of the methods looking the most specific method to invoke
    		int currentMin = 0;
    		bool ambig = false;
    		int[] paramOrder = new int[types.Length];
    		for (i=0;i<types.Length;i++)
    			paramOrder[i] = i;
    		for (i=1;i<CurIdx;i++) {
    			int newMin = FindMostSpecificMethod(match[currentMin], paramOrder, match[i], paramOrder, types, null);
    			if (newMin == 0)
    				ambig = true;
    			else {
    				if (newMin == 2) {
    					currentMin = i;
    					ambig = false;
    					currentMin = i;
    				}
    			}
    		}
    		if (ambig)
    			throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
    		return match[currentMin];
    	}
    	
    	// Given a set of propreties that match the base criteria, select one.
    	public override PropertyInfo SelectProperty(BindingFlags bindingAttr,PropertyInfo[] match,Type returnType,
    				Type[] indexes,ParameterModifier[] modifiers)
    	{
    		int i,j;
    		if (match == null || match.Length == 0)
    			throw new ArgumentException(Environment.GetResourceString("Arg_EmptyArray"),"match");
    			
    		// Find all the properties that can be described by type indexes parameter
    		int CurIdx = 0;
            int indexesLength = (indexes != null) ? indexes.Length : 0;
    		for (i=0;i<match.Length;i++) {
    			ParameterInfo[] par = match[i].GetIndexParameters();
    			if (par.Length != indexesLength)
    				continue;
    				
    			for (j=0;j<indexesLength;j++) {
    				Type pCls = par[j]. ParameterType;
    				
    				// If the classes  exactly match continue
    				if (pCls == indexes[j])
    					continue;
    				if (pCls == typeof(Object))
    					continue;
    				
    				if (pCls.IsPrimitive) {
    					if (!(indexes[j].UnderlyingSystemType is RuntimeType) ||
                            !CanConvertPrimitive((RuntimeType)indexes[j].UnderlyingSystemType,(RuntimeType)pCls.UnderlyingSystemType))
    						break;
    				}
    				else {
    					if (!pCls.IsAssignableFrom(indexes[j]))
    						break;
    				}
    			}
    			if (j == indexesLength) {
                    if (returnType != null) {
                        if (match[i].PropertyType.IsPrimitive) {
    					    if (!(returnType.UnderlyingSystemType is RuntimeType) ||
                                !CanConvertPrimitive((RuntimeType)returnType.UnderlyingSystemType,(RuntimeType)match[i].PropertyType.UnderlyingSystemType))
                                continue;
                        }
                        else {
    					    if (!match[i].PropertyType.IsAssignableFrom(returnType))
    						    continue;
                        }
                    }
    				match[CurIdx++] = match[i];
                }
    		}
    		if (CurIdx == 0)
    			return null;
    		if (CurIdx == 1)
    			return match[0];
    			
    		// Walk all of the properties looking the most specific method to invoke
    		int currentMin = 0;
    		bool ambig = false;
    		int[] paramOrder = new int[indexesLength];
    		for (i=0;i<indexesLength;i++)
    			paramOrder[i] = i;
    		for (i=1;i<CurIdx;i++) {
    			int newMin = FindMostSpecificType(match[currentMin].PropertyType, match[i].PropertyType,returnType);
                if (newMin == 0)
    			    newMin = FindMostSpecific(match[currentMin].GetIndexParameters(),
                                              paramOrder,
                                              match[i].GetIndexParameters(),
                                              paramOrder,
                                              indexes, 
                                              null);
    			if (newMin == 0)
    				ambig = true;
    			else {
    				if (newMin == 2) {
    					ambig = false;
    					currentMin = i;
    				}
    			}
    		}
    		if (ambig)
    			throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
    		return match[currentMin];
    	}
    	
    	// ChangeType
    	// The default binder doesn't support any change type functionality.
    	// This is because the default is built into the low level invoke code.
      	public override Object ChangeType(Object value,Type type,CultureInfo cultureInfo)
      	{
      		throw new NotSupportedException(Environment.GetResourceString("NotSupported_ChangeType"));
      	}
    	
        public override void ReorderArgumentArray(ref Object[] args, Object state)
        {
            BinderState binderState = (BinderState)state;
    		ReorderParams(binderState.m_argsMap, args);
            if (binderState.m_isParamArray) {
                int paramArrayPos = args.Length - 1;
                if (args.Length == binderState.m_originalSize)
                    args[paramArrayPos] = ((Object[])args[paramArrayPos])[0];
                else {
                    // must be args.Length < state.originalSize
                    Object[] newArgs = new Object[args.Length];
                    Array.Copy(args, 0, newArgs, 0, paramArrayPos);
                    for (int i = paramArrayPos, j = 0; i < newArgs.Length; i++, j++) {
                        newArgs[i] = ((Object[])args[paramArrayPos])[j];
                    }
                    args = newArgs;
                }
            }
            else {
                if (args.Length > binderState.m_originalSize) {
                    Object[] newArgs = new Object[binderState.m_originalSize];
                    Array.Copy(args, 0, newArgs, 0, binderState.m_originalSize);
                    args = newArgs;
                }
            }
        }

    	// Return any exact bindings that may exist. (This method is not defined on the
    	//	Binder and is used by RuntimeType.)
    	public static MethodBase ExactBinding(MethodBase[] match,Type[] types,ParameterModifier[] modifiers)
    	{
            if (match==null)
                throw new ArgumentNullException("match");
            MethodBase[] aExactMatches = new MethodBase[match.Length];
            int cExactMatches = 0;

    		for (int i=0;i<match.Length;i++) {
    			ParameterInfo[] par = match[i].GetParameters();
                //TODO: what about varargs?
                if (par.Length == 0) {
                    continue;
                }
    			int j;
    			for (j=0;j<types.Length;j++) {
    				Type pCls = par[j]. ParameterType;
    				
    				// If the classes  exactly match continue
    				if (!pCls.Equals(types[j]))
    					break;
    			}
    			if (j < types.Length)
    				continue;

                // Add the exact match to the array of exact matches.
                aExactMatches[cExactMatches] = match[i];
                cExactMatches++;
    		}

            if (cExactMatches == 0)
    		    return null;

            if (cExactMatches == 1)
                return aExactMatches[0];

            return FindMostDerivedNewSlotMeth(aExactMatches, cExactMatches);
    	}
    	
    	// Return any exact bindings that may exist. (This method is not defined on the
    	//	Binder and is used by RuntimeType.)
    	public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match,Type returnType,Type[] types,ParameterModifier[] modifiers)
    	{
            if (match==null)
                throw new ArgumentNullException("match");

            PropertyInfo bestMatch = null;
            int typesLength = (types != null) ? types.Length : 0;
    		for (int i=0;i<match.Length;i++) {
    			ParameterInfo[] par = match[i].GetIndexParameters();
    			int j;
    			for (j=0;j<typesLength;j++) {
    				Type pCls = par[j].ParameterType;
    				
    				// If the classes  exactly match continue
    				if (pCls != types[j])
    					break;
    			}
    			if (j < typesLength)
    				continue;
                if (returnType != null && returnType != match[i].PropertyType)
                    continue;
                
                if (bestMatch != null)
                    throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));

    			bestMatch = match[i];
    		}
    		return bestMatch;
    	}

    	// 0 = ambiguous, 1 = cur1 is the most specific, 2 = cur2 is most specific
    	private static int FindMostSpecific(ParameterInfo[] p1, int[] paramOrder1,
                                            ParameterInfo[] p2, int[] paramOrder2,
                                            Type[] types, Object[] args)
    	{
    		bool p1Less = false;
    		bool p2Less = false;
    			
    		for (int i=0;i<types.Length;i++) {
                if (args != null && args[i] == Type.Missing) 
                    continue;
    			Type c1 = p1[paramOrder1[i]].ParameterType;
    			Type c2 = p2[paramOrder2[i]].ParameterType;
    			//Console.WriteLine("Param:" + c1 + " - " + c2);
    			//Console.WriteLine("Types:" + types[i]);
    			
    			// If the two types are exact move on...
    			if (c1 == c2)
    				continue;
                else {
                    if (c1 == types[i]) {
                        p1Less = true;
                        continue;
                    }
                    else if (c2 == types[i]) {
                        p2Less = true;
                        continue;
                    }
                }

    			
    			// If the c1 is a primitive 
    			if (c1.IsPrimitive) {
    				// C2 is object we can widden p1 is less however...
    				if (c2 == typeof(Object)) {
    					p1Less = true;
    					continue;
    				}
    				
    				// Unfortunitly, an UInt16 and char can be converted
    				//	both ways...
    				if (c2 == typeof(char) || c2 == typeof(UInt16)) {
    					if (types[i] == c1)
    						p1Less = true;
    					else
    						p2Less = true;
    					continue;
    				}
    				
    				// Check for primitive conversions...
    				if (c2.UnderlyingSystemType is RuntimeType &&
                        CanConvertPrimitive((RuntimeType)c1.UnderlyingSystemType,(RuntimeType)c2.UnderlyingSystemType)) {
    					p1Less = true;
    					continue;
    				}
    			}
    			// Else c1 is an object
    			else {
    				// C2 can be an object, p1 is less
    				if (c2 == typeof(Object)) {
    					p1Less = true;
    					continue;
    				}
    				
    				if (types[i] == null) {
    					bool b = c1.IsAssignableFrom(c2);
    					if (b == c2.IsAssignableFrom(c1))
    						return 0;
    				}
    				// Check for assignment compatibility...
    				if (!c1.IsAssignableFrom(c2)) {
    					p1Less = true;
    					continue;
    				}
    			}
    			// If we got here it means that p2 is less in this situation.
    			// We will set the flag indicating this....
    			p2Less = true;
    		}
    		
    		// Two way p1Less and p2Less can be equal.  All the arguments are the
    		//	same they both equal false, otherwise there were things that both
    		//	were the most specific type on....
    		if (p1Less == p2Less) {
                // it's possible that the 2 methods have same sig and  default param in which case we match the one
                // with the same number of args but only if they were exactly the same (that is p1Less and p2Lees are both false)
                if (!p1Less && p1.Length != p2.Length && args != null) {
                    if (p1.Length == args.Length) 
                        return 1;
                    else if (p2.Length == args.Length) 
                        return 2;
                }
    			return 0;
            }
    		else 
    			return (p1Less == true) ? 1 : 2;
    	}
    	
        //TODO: make others FindMostSpecifcType to rely on this one
        private static int FindMostSpecificType(Type c1, Type c2, Type t)
        {
    		// If the two types are exact move on...
    		if (c1 == c2)
    			return 0;
    		
    		// If the c1 is a primitive 
    		if (c1.IsPrimitive) {
    			// C2 is object we can widden p1 is less however...
    			if (c2 == typeof(Object)) {
    				return 1;
    			}
    			
    			// Unfortunitly, an UInt16 and char can be converted
    			//	both ways...
    			if (c2 == typeof(char) || c2 == typeof(UInt16)) {
    				if (t == c1)
    					return 1;
    				else
    					return 2;
    			}
    			
    			// Check for primitive conversions...
    			if (c2.UnderlyingSystemType is RuntimeType && CanConvertPrimitive((RuntimeType)c1.UnderlyingSystemType,(RuntimeType)c2.UnderlyingSystemType)) {
    				return 1;
    			}
    		}
    		// Else c1 is an object
    		else {
    			// C2 can be an object, p1 is less
    			if (c2 == typeof(Object)) {
    				return 1;
    			}
    			
    			if (t == null) {
    				bool b = c1.IsAssignableFrom(c2);
    				if (b == c2.IsAssignableFrom(c1))
    					return 0;
    			}
    			// Check for assignment compatibility...
    			if (!c1.IsAssignableFrom(c2)) {
    				return 1;;
    			}
    		}
    		// If we got here it means that p2 is less in this situation.
    		return 2;
        }

    	// 0 = ambiguous, 1 = cur1 is the most specific, 2 = cur2 is most specific
        private static int FindMostSpecificMethod(MethodBase m1, int[] paramOrder1,
    								              MethodBase m2, int[] paramOrder2, 
                                                  Type[] types, Object[] args)
        {
            // Find the most specific method based on the parameters.
            int res = FindMostSpecific(m1.GetParameters(), paramOrder1, m2.GetParameters(), paramOrder2, types, args);            

            // If the match was not ambigous then return the result.
            if (res != 0)
                return res;

            // Check to see if the methods have the exact same name and signature.
            if (CompareMethodSigAndName(m1, m2))
            {
                // Determine the depth of the declaring types for both methods.
                int hierarchyDepth1 = GetHierarchyDepth(m1.DeclaringType);
                int hierarchyDepth2 = GetHierarchyDepth(m2.DeclaringType);

                // The most derived method is the most specific one.
                if (hierarchyDepth1 == hierarchyDepth2) {
  	                BCLDebug.Assert(m1.IsStatic != m2.IsStatic, "hierarchyDepth1 == hierarchyDepth2");
                    return 0; 
                }
                else if (hierarchyDepth1 < hierarchyDepth2) 
                    return 2;
                else
                    return 1;
            }

            // The match is ambigous.
            return 0;
        }

    	// 0 = ambiguous, 1 = cur1 is the most specific, 2 = cur2 is most specific
    	private static int FindMostSpecificField(FieldInfo cur1,FieldInfo cur2,Type type)
    	{
    		Type c1 = cur1.GetType();
    		Type c2 = cur2.GetType();
    	
    		if (c1 == c2)
            {
                // Check to see if the fields have the same name.
                if (c1.Name == c2.Name)
                {
                    int hierarchyDepth1 = GetHierarchyDepth(cur1.DeclaringType);
                    int hierarchyDepth2 = GetHierarchyDepth(cur2.DeclaringType);

                    if (hierarchyDepth1 == hierarchyDepth2) {
                        BCLDebug.Assert(cur1.IsStatic != cur2.IsStatic, "hierarchyDepth1 == hierarchyDepth2");
                        return 0; 
                    }
                    else if (hierarchyDepth1 < hierarchyDepth2) 
                        return 2;
                    else
                        return 1;
                }

                // The match is ambigous.
                return 0;
            }
    		
    		// If the c1 is a primitive 
    		if (c1.IsPrimitive) {
    			// C2 is object we can widden p1 is less however...
    			if (c2 == typeof(Object)) 
    				return 1;
    			
    			// Unfortunitly, an UInt16 and char can be converted
    			//	both ways...
    			if (c2 == typeof(char) || c2 == typeof(UInt16)) {
    				if (type == c1)
    					return 1;
    				else
    					return 2;
    			}
    			
    			// Check for primitive conversions...
    			if (c2.UnderlyingSystemType is RuntimeType && CanConvertPrimitive((RuntimeType)c1.UnderlyingSystemType,(RuntimeType)c2.UnderlyingSystemType))
    				return 1;
    		}
    		// Else c1 is an object
    		else {
    			// C2 can be an object, p1 is less
    			if (c2 == typeof(Object))
    				return 1;
    			// Check for assignment compatibility...
    			if (!c1.IsAssignableFrom(c2))
    				return 1;
    		}
    		
    		// If we got here it means that p2 is less in this situation.
    		// We will set the flag indicating this....
    		return 2;
    	}

    	// Whether the methods have the same name and signature
        internal static bool CompareMethodSigAndName(MethodBase m1, MethodBase m2)
        {
            ParameterInfo[] params1 = m1.GetParameters();
            ParameterInfo[] params2 = m2.GetParameters();

            if (params1.Length != params2.Length)
                return false;

            int numParams = params1.Length;
            for (int i = 0; i < numParams; i++)
            {
                if (params1[i].ParameterType != params2[i].ParameterType)
                    return false;
            }

            return true;
        }

        // Returns the depth of the object hierarchy for this type.
        // Note that Object has a depth of 1.
        internal static int GetHierarchyDepth(Type t)
        {
            int depth = 0;

            Type currentType = t;
            do 
            {
                depth++;
                currentType = currentType.BaseType;
            } while (currentType != null);

            return depth;
        }

        // Returns the method declared on the most derived type.
        internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches)
        {
            int deepestHierarchy = 0;
            MethodBase methWithDeepestHierarchy = null;

            for (int i = 0; i < cMatches; i++)
            {
                // Calculate the depth of the hierarchy of the declaring type of the
                // current method.
                int currentHierarchyDepth = GetHierarchyDepth(match[i].DeclaringType);

                // Two methods with the same hierarchy depth are not allowed. This would
                // mean that there are 2 methods with the same name and sig on a given type
                // which is not allowed, unless one of them is vararg...
                if (currentHierarchyDepth == deepestHierarchy) {
                    BCLDebug.Assert(((match[i].CallingConvention & CallingConventions.VarArgs) |
                                    (methWithDeepestHierarchy.CallingConvention & CallingConventions.VarArgs)) != 0, 
                                    "Calling conventions: " + match[i].CallingConvention + " - " + methWithDeepestHierarchy.CallingConvention);
                    throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
                }

                // Check to see if this method is on the most derived class.
                if (currentHierarchyDepth > deepestHierarchy)
                {
                    deepestHierarchy = currentHierarchyDepth;
                    methWithDeepestHierarchy = match[i];
                }
            }

            return methWithDeepestHierarchy;
        }

		// CanConvertPrimitive
		// This will determine if the source can be converted to the target type
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern bool CanConvertPrimitive(RuntimeType source,RuntimeType target);

		// CanConvertPrimitiveObjectToType
		// This method will determine if the primitive object can be converted
		//	to a type.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	static internal extern bool CanConvertPrimitiveObjectToType(Object source,RuntimeType type);
    	
    	// This method will sort the vars array into the mapping order stored
    	//	in the paramOrder array.
    	private static void ReorderParams(int[] paramOrder,Object[] vars)
    	{
    		// This is an O(n) algorithm for sorting the array.
    		// For each position in the paramOrder array we swap the value
    		//	stored there into it's position until we swap position i into i.
    		//	This moves things exactly the number of items out of position.
    		for (int i=0;i<vars.Length;i++) {
    			while (paramOrder[i] != i) {
    				int x = paramOrder[paramOrder[i]];
    				Object v = vars[paramOrder[i]];
    				
    				paramOrder[paramOrder[i]] = paramOrder[i];
    				vars[paramOrder[i]] = vars[i];
    				
    				paramOrder[i] = x;
    				vars[i] = v;
    			}
    		}
    	}
    	
    	// This method will create the mapping between the Parameters and the underlying
    	//	data based upon the names array.  The names array is stored in the same order
    	//	as the values and maps to the parameters of the method.  We store the mapping
    	//	from the parameters to the names in the paramOrder array.  All parameters that
    	//	don't have matching names are then stored in the array in order.
    	private	static bool CreateParamOrder(int[] paramOrder,ParameterInfo[] pars,String[] names)
    	{
    		bool[] used = new bool[pars.Length];
    		
    		// Mark which parameters have not been found in the names list
    		for (int i=0;i<pars.Length;i++)
    			paramOrder[i] = -1;
    		// Find the parameters with names. 
    		for (int i=0;i<names.Length;i++) {
    			int j;
    			for (j=0;j<pars.Length;j++) {
    				if (names[i].Equals(pars[j].Name)) {
    					paramOrder[j] = i;
    					used[i] = true;
    					break;
    				}
    			}
    			// This is an error condition.  The name was not found.  This
    			//	method must not match what we sent.
    			if (j == pars.Length)
    				return false;
    		}
    		
    		// Now we fill in the holes with the parameters that are unused.
    		int pos = 0;
    		for (int i=0;i<pars.Length;i++) {
    			if (paramOrder[i] == -1) {
    				for (;pos<pars.Length;pos++) {
    					if (!used[pos]) {
    						paramOrder[i] = pos;
                            pos++;
    						break;
    					}
    				}
    			}
    		}
    		return true;
    	}

        internal class BinderState {
          internal int[] m_argsMap;
          internal int m_originalSize;
          internal bool m_isParamArray;

          internal BinderState(int[] argsMap, int originalSize, bool isParamArray) {
              m_argsMap = argsMap;
              m_originalSize = originalSize;
              m_isParamArray = isParamArray;
          }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\dividebyzeroexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: DivideByZeroException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Exception class for bad arithmetic conditions!
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\DivideByZeroException.uex' path='docs/doc[@for="DivideByZeroException"]/*' />
    [Serializable()] public class DivideByZeroException : ArithmeticException {
        /// <include file='doc\DivideByZeroException.uex' path='docs/doc[@for="DivideByZeroException.DivideByZeroException"]/*' />
        public DivideByZeroException() 
            : base(Environment.GetResourceString("Arg_DivideByZero")) {
    		SetErrorCode(__HResults.COR_E_DIVIDEBYZERO);
        }
    
        /// <include file='doc\DivideByZeroException.uex' path='docs/doc[@for="DivideByZeroException.DivideByZeroException1"]/*' />
        public DivideByZeroException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_DIVIDEBYZERO);
        }
    
        /// <include file='doc\DivideByZeroException.uex' path='docs/doc[@for="DivideByZeroException.DivideByZeroException2"]/*' />
        public DivideByZeroException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_DIVIDEBYZERO);
        }

        /// <include file='doc\DivideByZeroException.uex' path='docs/doc[@for="DivideByZeroException.DivideByZeroException3"]/*' />
        protected DivideByZeroException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\delegate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {

	using System;
	using System.Reflection;
	using System.Threading;
	using System.Runtime.Serialization;
    using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;
    /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate"]/*' />
	[Serializable()] 
    [ClassInterface(ClassInterfaceType.AutoDual)]
    public abstract class Delegate : ICloneable, ISerializable 
    {       
        // _method is the MethodInfo representing the target, this is set by
        //  InternalCreate.
        private IntPtr _methodPtr;
            
        // _target is the object we will invoke on
        private Object      _target;
            
        //@TODO: remove...
        private RuntimeMethodInfo _method = null;
    
        // In the case of a static method passed to a delegate, this field stores
        // whatever _methodPtr would have stored: and _methodPtr points to a
        // small thunk which removes the "this" pointer before going on
        // to _methodPtrAux.
        private IntPtr _methodPtrAux = IntPtr.Zero;
    
    
    	// This constructor is called from the class generated by the
        //  compiler generated code
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Delegate"]/*' />
        protected Delegate(Object target,String method)
        {
            if (target == null)
                throw new ArgumentNullException("target");
                    if (method == null)
                            throw new ArgumentNullException("method");
            InternalCreate(target,method,false);
        }
            
        // This constructor is called from a class to generate a 
        // delegate based upon a static method name and the Type object
        // for the class defining the method.
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Delegate1"]/*' />
        protected Delegate(Type target,String method)
        {
    		if (target == null)
    			throw new ArgumentNullException("target");
                if (!(target is RuntimeType))
                    throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "target");
    		if (method == null)
    			throw new ArgumentNullException("method");
    		InternalCreateStatic((RuntimeType)target,method);
        }
            
        // Protect the default constructor so you can't build a delegate
        private Delegate() {}


        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.DynamicInvoke"]/*' />
        public Object DynamicInvoke(Object[] args)
        {
            return DynamicInvokeImpl(args);
        }
            
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.DynamicInvokeImpl"]/*' />
        protected virtual Object DynamicInvokeImpl(Object[] args)
        {
            if (_method == null) 
                _method = InternalFindMethodInfo();
            // Use internal version of invoke to avoid access check (performed
            // during delegate creation).
            return _method.InternalInvoke(_target,BindingFlags.Default,null,args,null,false);
        }
                    
            // equals returns true IIF the delegate is not null and has the
            //      same target, method and invocation list as this object
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Equals"]/*' />
        public override bool Equals(Object obj)
        {
            if (obj != null && obj is Delegate) {
                Delegate d = (Delegate) obj;
                if (IsStatic()) {
                    if (_methodPtrAux==d._methodPtrAux) {
                        return true;
                    }
                } else {
                    if (d._target == _target && Method.Equals(d.Method)) {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            if (IsStatic())
                return this._methodPtrAux.ToInt32();
            else
                return this._methodPtr.ToInt32();
        }
    
        // Combine creates a new delegate based upon the contents of the 
        //  delegates passed in.
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Combine"]/*' />
        public static Delegate Combine(Delegate a, Delegate b)
        {
            //@TODO: Should this really check to see that they are both multicast
            //      because it really is an error to try and combine non-multicasts?
            //      Spec says that it returns null and only does the check if a and b
            //      are both null.
                    
                    // boundry conditions -- if either (or both) delegates is null
                    //      return the other.
            if (a == null)
                return b;
            if (b == null)
                return a;
                    
                    // Verify that the types are the same...
            if (a.GetType() != b.GetType())
                throw new ArgumentException(Environment.GetResourceString("Arg_DlgtTypeMis"));
            return  a.CombineImpl(b);
        }
            
        // This method creates a new delegate based upon the passed
        //  array of delegates.
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Combine1"]/*' />
        public static Delegate Combine(Delegate[] delegates)
        {
            if (delegates == null || delegates.Length == 0)
                return null;
                    
            Delegate d = delegates[0];
            for (int i = 1; i < delegates.Length; i++)
                d = Combine(d,delegates[i]);
            return d;
        }
                    
        // Return an array of delegates that represent the invocation list.
        // This is basically THIS for a Delegate.  MulticastDelegates may
        // have multiple members.
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.GetInvocationList"]/*' />
        public virtual Delegate[] GetInvocationList() {
            Delegate[] d = new Delegate[1];
            d[0] = this;
            return d;
        }
            
        // This routine will return the method
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Method"]/*' />
        public MethodInfo Method
        {
            get { 
	                if (_method == null) 
                        _method = InternalFindMethodInfo();
                    return _method;
        }
        }
            
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.GetMethodImpl"]/*' />
        protected virtual MethodInfo GetMethodImpl()
        {
                return Method;
        }
            
        // This routine will return the target
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Target"]/*' />
        public Object Target
        {
			get {return IsStatic() ? null : _target;}
        }
    
    
        
        //A quick test to see if this is a delegate to a static method.
        //@ToDo: Verify with DarylO that this is a sufficient test.
        private bool IsStatic() {
            if (_target is Delegate) {
                return true;
            }
            return false;
        }
            
        // This will remove the value delegate from the source delegate
        //  if it found.
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Remove"]/*' />
        public static Delegate Remove(Delegate source, Delegate value)
        {
            if (source == null)
                return null;
            if (value == null)
                return source;
            return source.RemoveImpl(value);
        }
            
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.RemoveAll"]/*' />
        public static Delegate RemoveAll(Delegate source, Delegate value)
        {
            Delegate newDelegate = null;
            do { 
                newDelegate = source;
                source = Remove(source, value);
            } while (newDelegate != source);
            return newDelegate;
        }
            
        // This is an internal routine that is called to do the combine.  We
        //  use this to do the combine because the Combine routines are static
        //  final methods.  In Delegate, this simply throws a MulticastNotSupportedException
        //  error.  Multicast delegate must implement this.
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.CombineImpl"]/*' />
        protected virtual Delegate CombineImpl(Delegate d)                                                           
        {
            throw new MulticastNotSupportedException(Environment.GetResourceString("Multicast_Combine"));
        }
            
        // This is an internal routine that is called to do the remove.  We use this
        //  to do the remove because Remove is a static final method.  Here we simply
        //  make sure that d is equal to this and return null or this.
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.RemoveImpl"]/*' />
        protected virtual Delegate RemoveImpl(Delegate d)
        {
            if (_target == d._target && Method.Equals(d.Method))
                //if (_target == d._target && _methodPtr == d._methodPtr)
                return null;
            else
                return this;
        }
    
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.Clone"]/*' />
        public virtual Object Clone()
        {
            return MemberwiseClone();
        }
            
            // Create a new delegate given a delegate class, an object and the
            // name of a method.
            // @TODO: We don't handle static methods in this.
            /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.CreateDelegate"]/*' />
            public static Delegate CreateDelegate(Type type,Object target,String method) {
                    if (type == null)
                            throw new ArgumentNullException("type");
                    if (!(type is RuntimeType))
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "type");
                    if (target == null)
                            throw new ArgumentNullException("target");
                    if (method == null)
                            throw new ArgumentNullException("method");
                    Type c = type.BaseType;
                    if (c == null || (c != typeof(Delegate) && c != typeof(MulticastDelegate)))
                            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDelegate"),"type");
                    
                    Delegate d = InternalAlloc((RuntimeType)type);
                    d.InternalCreate(target,method,false);                
                    return d;
            }
            
            // Create a new delegate given a delegate class, an object and the
            // name of a method.
            // @TODO: We don't handle static methods in this.
            /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.CreateDelegate3"]/*' />
            public static Delegate CreateDelegate(Type type,Object target,String method,bool ignoreCase) {
                    if (type == null)
                            throw new ArgumentNullException("type");
                    if (!(type is RuntimeType))
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "type");
                    if (target == null)
                            throw new ArgumentNullException("target");
                    if (method == null)
                            throw new ArgumentNullException("method");
                    Type c = type.BaseType;
                    if (c == null || (c != typeof(Delegate) && c != typeof(MulticastDelegate)))
                            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDelegate"),"type");
                    
                    Delegate d = InternalAlloc((RuntimeType)type);
                    d.InternalCreate(target,method,ignoreCase);                
                    return d;
            }
            
            /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.CreateDelegate1"]/*' />
            public static Delegate CreateDelegate(Type type, Type target, String method) {
                    if (type == null)
                            throw new ArgumentNullException("type");
                    if (!(type is RuntimeType))
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "type");
                    if (target == null)
                        throw new ArgumentNullException("target");
                    if (!(target is RuntimeType))
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "target");
                    if (method == null)
                            throw new ArgumentNullException("method");
                    Type c = type.BaseType;
                    if (c == null || (c != typeof(Delegate) && c != typeof(MulticastDelegate)))
                            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDelegate"),"type");
                    
                    Delegate d = InternalAlloc((RuntimeType)type);
                    d.InternalCreateStatic((RuntimeType)target,method);          
                    return d;
            }
            
            /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.CreateDelegate2"]/*' />
            public static Delegate CreateDelegate(Type type,MethodInfo method) {
                    // Validate the parameters.
                    if (type == null)
                            throw new ArgumentNullException("type");
                    if (!(type is RuntimeType))
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "type");
                    if (method == null)
                            throw new ArgumentNullException("method");
                    if (!(method is RuntimeMethodInfo))
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeMethodInfo"), "method");
                    Type c = type.BaseType;
                    if (c == null || (c != typeof(Delegate) && c != typeof(MulticastDelegate)))
                            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDelegate"),"type");
                    if (!method.IsStatic) 
                            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeStatic"),"method");
                    
                    // Find the Invoke method
                    MethodInfo m = type.GetMethod("Invoke");
                    if (m == null)
                            throw new InvalidProgramException("Didn't find Delegate Invoke method.");
                    if (!(m is RuntimeMethodInfo))
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeMethodInfo"), "type.Invoke");
                    
                    // Initialize the method...
                    Delegate d = InternalAlloc((RuntimeType)type);
                    d.InternalCreateMethod((RuntimeMethodInfo)m,(RuntimeMethodInfo)method);               
                    return d;
            }
            
            // Big cheat to get the internal delegate.
            [MethodImplAttribute(MethodImplOptions.InternalCall)]
            private extern static Delegate InternalAlloc(RuntimeType type);
            
        //  This method is the internal native method that initializes the
        // the delegate.  It will initialize all of the internal fields
        // above.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalCreate(Object target, String method, bool ignoreCase);
            
            // Internal create for a static method 
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalCreateStatic(RuntimeType target, String method);
            
            // Internal create for a static method 
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalCreateMethod(RuntimeMethodInfo invokeMeth,RuntimeMethodInfo targetMethod);
            
            // Internal method to get the reflection method info
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern RuntimeMethodInfo InternalFindMethodInfo();
            
        // InternalCreateMethod will create a delegate based upon the MethodInfo.. 
        // The method must be static


       /* private static bool operator equals(Delegate d1, Delegate d2) {
            if ((Object)d1 == null)
                return (Object)d2 == null;
            return d1.Equals(d2);
        }*/

		/// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.operatorEQ"]/*' />
		public static bool operator ==(Delegate d1, Delegate d2) {
            if ((Object)d1 == null)
                return (Object)d2 == null;
            return d1.Equals(d2);
        }

		/// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.operatorNE"]/*' />
		public static bool operator != (Delegate d1, Delegate d2) {
            if ((Object)d1 == null)
                return (Object)d2 != null;
            return !d1.Equals(d2);
        }
    
        //
        // Implementation of ISerializable
        //
        
        /// <include file='doc\Delegate.uex' path='docs/doc[@for="Delegate.GetObjectData"]/*' />
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (!IsStatic()) {
                DelegateSerializationHolder.GetDelegateSerializationInfo(info, this.GetType(), _target, Method, 0);
            } else { 
                DelegateSerializationHolder.GetDelegateSerializationInfo(info, this.GetType(), null, Method, 0);
            }
        }

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            _methodPtr = IntPtr.Zero;    
            _target = null;
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\double.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Double
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A representation of an IEEE double precision 
**          floating point number.
**
** Date: July 23, 1998
** 
===========================================================*/
namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;

    /// <include file='doc\Double.uex' path='docs/doc[@for="Double"]/*' />
    [Serializable, StructLayout(LayoutKind.Sequential)] public struct Double : IComparable, IFormattable, IConvertible
    {
        internal double m_value;
    
        //
        // Public Constants
        //
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.MinValue"]/*' />
        public const double MinValue = -1.7976931348623157E+308;
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.MaxValue"]/*' />
        public const double MaxValue = 1.7976931348623157E+308;
    	// Real value of Epsilon: 4.9406564584124654e-324 (0x1), but JVC misparses that 
    	// number, giving 2*Epsilon (0x2).
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.Epsilon"]/*' />
        public const double Epsilon  = 4.9406564584124650E-324;
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.NegativeInfinity"]/*' />
        public const double NegativeInfinity = (double)-1.0 / (double)(0.0);
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.PositiveInfinity"]/*' />
        public const double PositiveInfinity = (double)1.0 / (double)(0.0);
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.NaN"]/*' />
        public const double NaN = (double)0.0 / (double)0.0;

        //
        // Native Declarations
        //
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IsInfinity"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool IsInfinity(double d);
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IsPositiveInfinity"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool IsPositiveInfinity(double d);
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IsNegativeInfinity"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool IsNegativeInfinity(double d);

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IsNaN"]/*' />
        public static bool IsNaN(double d)
        {
       // Comparisions of a NaN with another number is always false and hence both conditions will be false.
            if (d < 0d || d >= 0d) {
               return false;
            }
            return true;
        }

    	
        // Compares this object to another object, returning an instance of System.Relation.
        // Null is considered less than any instance.
        //
        // If object is not of type Double, this method throws an ArgumentException.
        // 
        // Returns a value less than zero if this  object
        //
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (value is Double) {
                double d = (double)value;
                if (m_value < d) return -1;
                if (m_value > d) return 1;
    			if (m_value == d) return 0;
    
    			// At least one of the values is NaN.
                // This is busted; NaNs should never compare equal
    			if (IsNaN(m_value))
                    return (IsNaN(d) ? 0 : -1);
                else 
                    return 1;
            }
            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDouble"));
        }
    
        // True if obj is another Double with the same value as the current instance.  This is
        // a method of object equality, that only returns true if obj is also a double.
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is Double)) {
                return false;
            }        
	        double temp = ((Double)obj).m_value;
	        // This code below is written this way for performance reasons i.e the != and == check is intentional.
	        if (temp == m_value) {
		        return true;
	        }
            return IsNaN(temp) && IsNaN(m_value);
        }

        //The hashcode for a double is the absolute value of the integer representation
        //of that double. 
        //
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.GetHashCode"]/*' />
        public unsafe override int GetHashCode() {
            double d = m_value;
            long value = *(long*)(&d);
            return ((int)value) ^ ((int)(value >> 32));
        }


        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.ToString"]/*' />
        public override String ToString() {
            return ToString(null,null);
        }


        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }
    
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatDouble(m_value, format, NumberFormatInfo.GetInstance(provider));
        }
    
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.Parse"]/*' />
        public static double Parse(String s) {
            return Parse(s, NumberStyles.Float| NumberStyles.AllowThousands, null);
        }
    
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.Parse1"]/*' />
        public static double Parse(String s, NumberStyles style) {
            return Parse(s, style, null);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.Parse2"]/*' />
        public static double Parse(String s, IFormatProvider provider) {
            return Parse(s, NumberStyles.Float| NumberStyles.AllowThousands, provider);
        }
    
    	// Parses a double from a String in the given style.  If
    	// a NumberFormatInfo isn't specified, the current culture's 
    	// NumberFormatInfo is assumed.
    	// 
    	// This method will not throw an OverflowException, but will return 
    	// PositiveInfinity or NegativeInfinity for a number that is too 
    	// large or too small.
    	// 
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.Parse3"]/*' />
        public static double Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
            try {
                return Number.ParseDouble(s, style, info);
            } catch (FormatException) {
                //If we caught a FormatException, it may be from one of our special strings.
                //Check the three with which we're concerned and rethrow if it's not one of
                //those strings.
                String sTrim = s.Trim();
                if (sTrim.Equals(info.PositiveInfinitySymbol)) {
                    return PositiveInfinity;
                } 
                if (sTrim.Equals(info.NegativeInfinitySymbol)) {
                    return NegativeInfinity;
                }
                if (sTrim.Equals(info.NaNSymbol)) {
                    return NaN;
                }
                //Rethrow the previous exception;
                throw;
            }
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.TryParse"]/*' />
        public static bool TryParse(String s, NumberStyles style, IFormatProvider provider, out double result) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
            if (s == null || info == null) {
                result = 0;
                return false;
            }
            bool success = Number.TryParseDouble(s, style, info, out result);
            if (!success) {
                String sTrim = s.Trim();
                if (sTrim.Equals(info.PositiveInfinitySymbol)) {
                    result = PositiveInfinity;
                } else if (sTrim.Equals(info.NegativeInfinitySymbol)) {
                    result = NegativeInfinity;
                } else if (sTrim.Equals(info.NaNSymbol)) {
                    result = NaN;
                } else
                    return false; // We really failed
            }
            return true;
        }

    	/// <include file='doc\Double.uex' path='docs/doc[@for="Double.ToString3"]/*' />
    	public String ToString(IFormatProvider provider) {
            return ToString(null, provider);
        }
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Double;
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Double", "Char"));
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Double", "DateTime"));
        }

        /// <include file='doc\Double.uex' path='docs/doc[@for="Double.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\delegateserializationholder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: DelegateSerializationHolder
**
** Author: Jay Roxe
**
** Purpose: Holds a delegate for purposes of serialization since
** they need to be internally allocated and can't be allocated with
** FormatterServices.GetUninitializedObject;
**
** Date: October 3, 1999
**
============================================================*/
namespace System {
    
    using System;
    using System.Reflection;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Serialization;

    [Serializable()]
    internal class DelegateSerializationHolder : IObjectReference, ISerializable {
    
        internal DelegateEntry m_delegateEntry;
    

        // Used for MulticastDelegate
        internal static DelegateEntry GetDelegateSerializationInfo(SerializationInfo info, Type delegateType, Object target, MethodInfo method, int targetIndex)        
        {
            Message.DebugOut("Inside GetDelegateSerializationInfo \n");
            if (method==null) {
                throw new ArgumentNullException("method");
            }
    
            BCLDebug.Assert(!(target is Delegate),"!(target is Delegate)");
            BCLDebug.Assert(info!=null, "[DelegateSerializationHolder.GetDelegateSerializationInfo]info!=null");
    
            Type c = delegateType.BaseType;
            if (c == null || (c != typeof(Delegate) && c != typeof(MulticastDelegate))) {
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDelegate"),"type");
            }
    

             DelegateEntry de = new DelegateEntry(
                                                  delegateType.FullName,
                                                  delegateType.Module.Assembly.FullName,
                                                  target,
                                                  method.ReflectedType.Module.Assembly.FullName,
                                                  method.ReflectedType.FullName,
                                                  method.Name
                                                  );

            if (info.MemberCount == 0)
            {
                info.SetType(typeof(DelegateSerializationHolder));
                info.AddValue("Delegate",de,typeof(DelegateEntry));
            }

            // target can be an object so it needs to be added to the info, or else a fixup is needed
            // when deserializing, and the fixup will occur too late. If it is added directly to the
            // info then the rules of deserialization will guarantee that it will be available when
            // needed

            if (target != null)
            {
                String targetName = "target"+targetIndex;
                info.AddValue(targetName, de.target);
                de.target = targetName;
            }

            return de;
        }
    
    
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DelegateSerHolderSerial"));
        }

        internal DelegateSerializationHolder(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
    
            bool bNewWire = true;
            try
            {
                m_delegateEntry = (DelegateEntry)info.GetValue("Delegate", typeof(DelegateEntry));
            }
            catch(Exception)
            {
                // Old wire format
                m_delegateEntry = OldDelegateWireFormat(info, context);
                bNewWire = false;
            }

            if (bNewWire)
            {
                // retrieve the targets
                DelegateEntry deiter = m_delegateEntry;
                while (deiter != null)
                {
                    if (deiter.target != null)
                    {
                        string stringTarget = deiter.target as string; //need test to pass older wire format
                        if (stringTarget != null)
                            deiter.target = info.GetValue(stringTarget, typeof(Object));
                    }
                    deiter= deiter.delegateEntry;
                }
            }

        }

         private DelegateEntry OldDelegateWireFormat(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }

            String delegateType = info.GetString("DelegateType");
            String delegateAssembly = info.GetString("DelegateAssembly");
            Object target = info.GetValue("Target", typeof(Object));
            String targetTypeAssembly = info.GetString("TargetTypeAssembly");
            String targetTypeName = info.GetString("TargetTypeName");
            String methodName = info.GetString("MethodName");

            return new DelegateEntry(delegateType, delegateAssembly, target, targetTypeAssembly, targetTypeName, methodName);
        }

        public virtual Object GetRealObject(StreamingContext context) 
        {
            Delegate root = GetDelegate(m_delegateEntry);
            MulticastDelegate mdroot = root as MulticastDelegate;

            if (mdroot != null)
            {
                DelegateEntry de = m_delegateEntry.Entry;
                MulticastDelegate previous = mdroot;
                while (de != null)
                {
                    Delegate newdelegate = GetDelegate(de);
                    MulticastDelegate current = newdelegate as MulticastDelegate;
                    if (current != null)
                    {
                        previous.Previous = current;
                        previous = current;
                        de = de.Entry;
                    }
                    else
                    {
                        break;
                    }
                }
            }
    
            return root;
            }

        private Delegate GetDelegate(DelegateEntry de)
        {
            Delegate d;
    
            if (de.methodName==null || de.methodName.Length==0) {
                throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
            }
    
            Assembly assem = FormatterServices.LoadAssemblyFromStringNoThrow(de.assembly);

            if (assem==null) {
                BCLDebug.Trace("SER", "[DelegateSerializationHolder.ctor]: Unable to find assembly for TargetType: ", de.assembly);
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_AssemblyNotFound"), de.assembly));
            }

            Type type = assem.GetTypeInternal(de.type, false, false, false);

            assem = FormatterServices.LoadAssemblyFromStringNoThrow(de.targetTypeAssembly);
            if (assem==null) {
                BCLDebug.Trace("SER", "[DelegateSerializationHolder.ctor]: Unable to find assembly for TargetType: ", de.targetTypeAssembly);
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_AssemblyNotFound"), de.targetTypeAssembly));
        }
    
            Type targetType = assem.GetTypeInternal(de.targetTypeName, false, false, false);

            if (de.target==null && targetType==null) {
                throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
            }
    
            if (type==null) {
                BCLDebug.Trace("SER","[DelegateSerializationHolder.GetRealObject]Missing Type");
                throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
            }
    
            if (targetType==null) {
                throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
            }

            Object target = null;

            if (de.target!=null) { //We have a delegate to a non-static object
                target = RemotingServices.CheckCast(de.target, targetType);
                d=Delegate.CreateDelegate(type, target, de.methodName);
            } else {
                //For a static delegate
                d=Delegate.CreateDelegate(type, targetType, de.methodName);
            }
    
            // We will refuse to create delegates to methods that are non-public.
            MethodInfo mi = d.Method;
            if (mi != null)
            {
                if (!mi.IsPublic)
                {
                    throw new SerializationException(
                        Environment.GetResourceString("Serialization_RefuseNonPublicDelegateCreation"));
                }
            }
    
            return d;
        }

        [Serializable]
        internal class DelegateEntry
        {
            internal String type;
            internal String assembly;
            internal Object target;
            internal String targetTypeAssembly;
            internal String targetTypeName;
            internal String methodName;
            internal DelegateEntry delegateEntry;

            internal DelegateEntry(String type, String assembly, Object target, String targetTypeAssembly, String targetTypeName, String methodName)
            {
                this.type = type;
                this.assembly = assembly;
                this.target = target;
                this.targetTypeAssembly = targetTypeAssembly;
                this.targetTypeName = targetTypeName;
                this.methodName = methodName;
            }

            internal DelegateEntry Entry
            {
                get{return delegateEntry;}
                set{delegateEntry = value;}
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\duplicatewaitobjectexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: DuplicateWaitObjectException
**
** Author: Sanjay Bhansali
**
** Purpose: Exception class for duplicate objects in WaitAll/WaitAny.
**
** Date: January, 2000
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Remoting;
    using System.Runtime.Serialization;

    // The DuplicateWaitObjectException is thrown when an object 
	// appears more than once in the list of objects to WaitAll or WaitAny.
    // 
    /// <include file='doc\DuplicateWaitObjectException.uex' path='docs/doc[@for="DuplicateWaitObjectException"]/*' />
    [Serializable()] public class DuplicateWaitObjectException : ArgumentException {
    	
    	private static String _duplicateWaitObjectMessage = null;

    	private static String DuplicateWaitObjectMessage {
            get {
                if (_duplicateWaitObjectMessage == null)
                    _duplicateWaitObjectMessage = Environment.GetResourceString("Arg_DuplicateWaitObjectException");
                return _duplicateWaitObjectMessage;
            }
        }

        // Creates a new DuplicateWaitObjectException with its message 
        // string set to a default message.
        /// <include file='doc\DuplicateWaitObjectException.uex' path='docs/doc[@for="DuplicateWaitObjectException.DuplicateWaitObjectException"]/*' />
        public DuplicateWaitObjectException() 
            : base(DuplicateWaitObjectMessage) {
    		SetErrorCode(__HResults.COR_E_DUPLICATEWAITOBJECT);
        }
    	
        /// <include file='doc\DuplicateWaitObjectException.uex' path='docs/doc[@for="DuplicateWaitObjectException.DuplicateWaitObjectException1"]/*' />
        public DuplicateWaitObjectException(String parameterName) 
            : base(DuplicateWaitObjectMessage, parameterName) {
    		SetErrorCode(__HResults.COR_E_DUPLICATEWAITOBJECT);
        }
    	
        /// <include file='doc\DuplicateWaitObjectException.uex' path='docs/doc[@for="DuplicateWaitObjectException.DuplicateWaitObjectException2"]/*' />
        public DuplicateWaitObjectException(String parameterName, String message) 
            : base(message, parameterName) {
    		SetErrorCode(__HResults.COR_E_DUPLICATEWAITOBJECT);
        }

        //
        // This constructor is required for serialization
        //
        /// <include file='doc\DuplicateWaitObjectException.uex' path='docs/doc[@for="DuplicateWaitObjectException.DuplicateWaitObjectException3"]/*' />
        protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\dllnotfoundexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: DllNotFoundException
**
** Author: David Mortenson (DMortens)
**
** Purpose: The exception class for some failed P/Invoke calls.
**
** Date: December 11, 2000
**
=============================================================================*/

namespace System {
    
    using System;
    using System.Runtime.Serialization;

    /// <include file='doc\DllNotFoundException.uex' path='docs/doc[@for="DllNotFoundException"]/*' />
    [Serializable] public class DllNotFoundException : TypeLoadException {
        /// <include file='doc\DllNotFoundException.uex' path='docs/doc[@for="DllNotFoundException.DllNotFoundException"]/*' />
        public DllNotFoundException() 
            : base(Environment.GetResourceString("Arg_DllNotFoundException")) {
            SetErrorCode(__HResults.COR_E_DLLNOTFOUND);
        }
    
        /// <include file='doc\DllNotFoundException.uex' path='docs/doc[@for="DllNotFoundException.DllNotFoundException1"]/*' />
        public DllNotFoundException(String message) 
            : base(message) {
            SetErrorCode(__HResults.COR_E_DLLNOTFOUND);
        }
    
        /// <include file='doc\DllNotFoundException.uex' path='docs/doc[@for="DllNotFoundException.DllNotFoundException2"]/*' />
        public DllNotFoundException(String message, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.COR_E_DLLNOTFOUND);
        }

        /// <include file='doc\DllNotFoundException.uex' path='docs/doc[@for="DllNotFoundException.DllNotFoundException3"]/*' />
        protected DllNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\convert.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:   Convert
**
** Author:  Rajesh Chandrashekaran (rajeshc)
**
** Purpose: Home for static conversion methods.
**
** Date:    January 4, 2000
**
===========================================================*/
namespace System {
    using System;
    using System.Globalization;
    using System.Threading;
	using System.Reflection;
	using System.Runtime.CompilerServices;

    // Returns the type code of this object. An implementation of this method
    // must not return TypeCode.Empty (which represents a null reference) or
    // TypeCode.Object (which represents an object that doesn't implement the
    // IConvertible interface). An implementation of this method should return
    // TypeCode.DBNull if the value of this object is a database null. For
    // example, a nullable integer type should return TypeCode.DBNull if the
    // value of the object is the database null. Otherwise, an implementation
    // of this method should return the TypeCode that best describes the
    // internal representation of the object.
    // The Value class provides conversion and querying methods for values. The
    // Value class contains static members only, and it is not possible to create
    // instances of the class.
    //
    // The statically typed conversion methods provided by the Value class are all
    // of the form:
    //
    //    public static XXX ToXXX(YYY value)
    //
    // where XXX is the target type and YYY is the source type. The matrix below
    // shows the set of supported conversions. The set of conversions is symmetric
    // such that for every ToXXX(YYY) there is also a ToYYY(XXX).
    //
    // From:  To: Bol Chr SBy Byt I16 U16 I32 U32 I64 U64 Sgl Dbl Dec Dat Str
    // ----------------------------------------------------------------------
    // Boolean     x       x   x   x   x   x   x   x   x   x   x   x       x
    // Char            x   x   x   x   x   x   x   x   x                   x
    // SByte       x   x   x   x   x   x   x   x   x   x   x   x   x       x
    // Byte        x   x   x   x   x   x   x   x   x   x   x   x   x       x
    // Int16       x   x   x   x   x   x   x   x   x   x   x   x   x       x
    // UInt16      x   x   x   x   x   x   x   x   x   x   x   x   x       x
    // Int32       x   x   x   x   x   x   x   x   x   x   x   x   x       x
    // UInt32      x   x   x   x   x   x   x   x   x   x   x   x   x       x
    // Int64       x   x   x   x   x   x   x   x   x   x   x   x   x       x
    // UInt64      x   x   x   x   x   x   x   x   x   x   x   x   x       x
    // Single      x       x   x   x   x   x   x   x   x   x   x   x       x
    // Double      x       x   x   x   x   x   x   x   x   x   x   x       x
    // Decimal     x       x   x   x   x   x   x   x   x   x   x   x       x
    // DateTime                                                        x   x
    // String      x   x   x   x   x   x   x   x   x   x   x   x   x   x   x
    // ----------------------------------------------------------------------
    //
    // For dynamic conversions, the Value class provides a set of methods of the
    // form:
    //
    //    public static XXX ToXXX(object value)
    //
    // where XXX is the target type (Boolean, Char, SByte, Byte, Int16, UInt16,
    // Int32, UInt32, Int64, UInt64, Single, Double, Decimal, DateTime,
    // or String). The implementations of these methods all take the form:
    //
    //    public static XXX toXXX(object value) {
    //        return value == null? XXX.Default: ((IConvertible)value).ToXXX();
    //    }
    //
    // The code first checks if the given value is a null reference (which is the
    // same as Value.Empty), in which case it returns the default value for type
    // XXX. Otherwise, a cast to IConvertible is performed, and the appropriate ToXXX()
    // method is invoked on the object. An InvalidCastException is thrown if the
    // cast to IConvertible fails, and that exception is simply allowed to propagate out
    // of the conversion method.
        
    // Constant representing the database null value. This value is used in
    // database applications to indicate the absense of a known value. Note
    // that Value.DBNull is NOT the same as a null object reference, which is
    // represented by Value.Empty.
    //
    // The Equals() method of DBNull always returns false, even when the
    // argument is itself DBNull.
    //
    // When passed Value.DBNull, the Value.GetTypeCode() method returns
    // TypeCode.DBNull.
    //
    // When passed Value.DBNull, the Value.ToXXX() methods all throw an
    // InvalidCastException.

    /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert"]/*' />
    public sealed class Convert {
        
        //A typeof operation is fairly expensive (does a system call), so we'll cache these here
        //statically.  These are exactly lined up with the TypeCode, eg. ConvertType[TypeCode.Int16]
        //will give you the type of an Int16.
        internal static readonly Type[] ConvertTypes = {
            typeof(System.Empty),
            typeof(Object),
            typeof(System.DBNull),
            typeof(Boolean),
            typeof(Char),
            typeof(SByte),
            typeof(Byte),
            typeof(Int16),
            typeof(UInt16),
            typeof(Int32),
            typeof(UInt32),
            typeof(Int64),
            typeof(UInt64),
            typeof(Single),
            typeof(Double),
            typeof(Decimal),
            typeof(DateTime),
            typeof(Object), //This is really silly, but TypeCode is discontinuous so we need a placeholder.
            typeof(String)
        };

        static Convert() {
            BCLDebug.Assert(ConvertTypes!=null, "[Convert.cctor]ConvertTypes!=null");
            BCLDebug.Assert(ConvertTypes.Length == ((int)TypeCode.String + 1), "[Convert.cctor]ConvertTypes.Length == ((int)TypeCode.String + 1)");
            BCLDebug.Assert(ConvertTypes[(int)TypeCode.Empty]==typeof(System.Empty),
                            "[Convert.cctor]ConvertTypes[(int)TypeCode.Empty]==typeof(System.Empty)");
            BCLDebug.Assert(ConvertTypes[(int)TypeCode.String]==typeof(String),
                            "[Convert.cctor]ConvertTypes[(int)TypeCode.String]==typeof(System.String)");
            BCLDebug.Assert(ConvertTypes[(int)TypeCode.Int32]==typeof(int),
                            "[Convert.cctor]ConvertTypes[(int)TypeCode.Int32]==typeof(int)");

        }

        private Convert() {
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.DBNull"]/*' />
        public static readonly Object DBNull = System.DBNull.Value;
        
        // Returns the type code for the given object. If the argument is null,
        // the result is TypeCode.Empty. If the argument is not a value (i.e. if
        // the object does not implement IConvertible), the result is TypeCode.Object.
        // Otherwise, the result is the type code of the object, as determined by
        // the object's implementation of IConvertible.
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.GetTypeCode"]/*' />
        public static TypeCode GetTypeCode(object value) {
            if (value == null) return TypeCode.Empty;
            IConvertible temp = value as IConvertible;
            if (temp != null)
            {
                return temp.GetTypeCode();
            }
            return TypeCode.Object;
        }

        // Returns true if the given object is a database null. This operation
        // corresponds to "value.GetTypeCode() == TypeCode.DBNull".
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.IsDBNull"]/*' />
        public static bool IsDBNull(object value) {
            if (value == System.DBNull.Value) return true;
            IConvertible convertible = value as IConvertible;
            return convertible != null? convertible.GetTypeCode() == TypeCode.DBNull: false;
        }

        // Converts the given object to the given type. In general, this method is
        // equivalent to calling the Value.ToXXX(value) method for the given
        // typeCode and boxing the result.
        //
        // The method first checks if the given object implements IConvertible. If not,
        // the only permitted conversion is from a null to TypeCode.Empty, the
        // result of which is null.
        //
        // If the object does implement IConvertible, a check is made to see if the
        // object already has the given type code, in which case the object is
        // simply returned. Otherwise, the appropriate ToXXX() is invoked on the
        // object's implementation of IConvertible.
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ChangeType"]/*' />
        public static Object ChangeType(Object value, TypeCode typeCode) {
            return ChangeType(value, typeCode, Thread.CurrentThread.CurrentCulture);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ChangeType1"]/*' />
        public static Object ChangeType(Object value, TypeCode typeCode, IFormatProvider provider) {
            IConvertible v = value as IConvertible;
            if (v==null) {
                if (value == null && typeCode == TypeCode.Empty) return null;
                throw new InvalidCastException(Environment.GetResourceString("InvalidCast_IConvertible"));
            }

            // This line is invalid for things like Enums that return a TypeCode
            // of Int32, but the object can't actually be cast to an Int32.
            //            if (v.GetTypeCode() == typeCode) return value;
            switch (typeCode) {
            case TypeCode.Boolean:
                return v.ToBoolean(provider);
            case TypeCode.Char:
                return v.ToChar(provider);
            case TypeCode.SByte:
                return v.ToSByte(provider);
            case TypeCode.Byte:
                return v.ToByte(provider);
            case TypeCode.Int16:
                return v.ToInt16(provider);
            case TypeCode.UInt16:
                return v.ToUInt16(provider);
            case TypeCode.Int32:
                return v.ToInt32(provider);
            case TypeCode.UInt32:
                return v.ToUInt32(provider);
            case TypeCode.Int64:
                return v.ToInt64(provider);
            case TypeCode.UInt64:
                return v.ToUInt64(provider);
            case TypeCode.Single:
                return v.ToSingle(provider);
            case TypeCode.Double:
                return v.ToDouble(provider);
            case TypeCode.Decimal:
                return v.ToDecimal(provider);
            case TypeCode.DateTime:
                return v.ToDateTime(provider);
            case TypeCode.String:
                return v.ToString(provider);
            case TypeCode.Object:
                return value;
            case TypeCode.DBNull:
                throw new InvalidCastException(Environment.GetResourceString("InvalidCast_DBNull"));
            case TypeCode.Empty:
                throw new InvalidCastException(Environment.GetResourceString("InvalidCast_Empty"));
            default:
                throw new ArgumentException(Environment.GetResourceString("Arg_UnknownTypeCode"));
            }
        }

        internal static Object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider) {
            BCLDebug.Assert(value!=null, "[Convert.DefaultToType]value!=null");

            if (targetType==null) {
                throw new ArgumentNullException("targetType");
            }
            
            if (value.GetType()==targetType) {
                return value;
            }

            if (targetType==ConvertTypes[(int)TypeCode.Boolean])
                return value.ToBoolean(provider);
            if (targetType==ConvertTypes[(int)TypeCode.Char])
                return value.ToChar(provider);
            if (targetType==ConvertTypes[(int)TypeCode.SByte])
                return value.ToSByte(provider);
            if (targetType==ConvertTypes[(int)TypeCode.Byte])
                return value.ToByte(provider);
            if (targetType==ConvertTypes[(int)TypeCode.Int16]) 
                return value.ToInt16(provider);
            if (targetType==ConvertTypes[(int)TypeCode.UInt16])
                return value.ToUInt16(provider);
            if (targetType==ConvertTypes[(int)TypeCode.Int32])
                return value.ToInt32(provider);
            if (targetType==ConvertTypes[(int)TypeCode.UInt32])
                return value.ToUInt32(provider);
            if (targetType==ConvertTypes[(int)TypeCode.Int64])
                return value.ToInt64(provider);
            if (targetType==ConvertTypes[(int)TypeCode.UInt64])
                return value.ToUInt64(provider);
            if (targetType==ConvertTypes[(int)TypeCode.Single])
                return value.ToSingle(provider);
            if (targetType==ConvertTypes[(int)TypeCode.Double])
                return value.ToDouble(provider);
            if (targetType==ConvertTypes[(int)TypeCode.Decimal])
                return value.ToDecimal(provider);
            if (targetType==ConvertTypes[(int)TypeCode.DateTime])
                return value.ToDateTime(provider);
            if (targetType==ConvertTypes[(int)TypeCode.String]) {
                return value.ToString(provider);
            }
            if (targetType==ConvertTypes[(int)TypeCode.Object])
                return (Object)value;
            if (targetType==ConvertTypes[(int)TypeCode.DBNull])
                throw new InvalidCastException(Environment.GetResourceString("InvalidCast_DBNull"));
            if (targetType==ConvertTypes[(int)TypeCode.Empty]) 
                throw new InvalidCastException(Environment.GetResourceString("InvalidCast_Empty"));
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), value.GetType().FullName, targetType.FullName));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ChangeType2"]/*' />
        public static Object ChangeType(Object value, Type conversionType) {
            return ChangeType(value, conversionType, Thread.CurrentThread.CurrentCulture);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ChangeType3"]/*' />
        public static Object ChangeType(Object value, Type conversionType, IFormatProvider provider) {
            IConvertible ic = value as IConvertible;
            if (ic == null) {
                if (value == null && conversionType == null) return null;
                if (value.GetType()==conversionType) {
                    return value;
                }
                throw new InvalidCastException(Environment.GetResourceString("InvalidCast_IConvertible"));
            }
            if (conversionType==ConvertTypes[(int)TypeCode.Boolean])
                return ic.ToBoolean(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.Char])
                return ic.ToChar(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.SByte])
                return ic.ToSByte(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.Byte])
                return ic.ToByte(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.Int16]) 
                return ic.ToInt16(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.UInt16])
                return ic.ToUInt16(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.Int32])
                return ic.ToInt32(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.UInt32])
                return ic.ToUInt32(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.Int64])
                return ic.ToInt64(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.UInt64])
                return ic.ToUInt64(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.Single])
                return ic.ToSingle(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.Double])
                return ic.ToDouble(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.Decimal])
                return ic.ToDecimal(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.DateTime])
                return ic.ToDateTime(provider);
            if (conversionType==ConvertTypes[(int)TypeCode.String]) {
                return ic.ToString(provider);
            }
            if (conversionType==ConvertTypes[(int)TypeCode.Object])
                return (Object)value;
            return ic.ToType(conversionType, provider);
        }

        // Conversions to Boolean
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean"]/*' />
        public static bool ToBoolean(Object value) {
            return value == null? false: ((IConvertible)value).ToBoolean(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean14"]/*' />
        public static bool ToBoolean(Object value, IFormatProvider provider) {
            return value == null? false: ((IConvertible)value).ToBoolean(provider);
        }


		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean15"]/*' />
		public static bool ToBoolean(bool value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean1"]/*' />
		[CLSCompliant(false)]
        public static bool ToBoolean(sbyte value) {
            return value != 0;
        }

		// To be consistent with IConvertible in the base data types else we get different semantics
		// with widening operations. Without this operator this widen succeeds,with this API the widening throws.
		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean2"]/*' />
		public static bool ToBoolean(char value) {
            return ((IConvertible)value).ToBoolean(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean3"]/*' />
        public static bool ToBoolean(byte value) {
            return value != 0;
        }


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean4"]/*' />
        public static bool ToBoolean(short value) {
            return value != 0;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean5"]/*' />
        [CLSCompliant(false)]   
        public static bool ToBoolean(ushort value) {
            return value != 0;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean6"]/*' />
        public static bool ToBoolean(int value) {
            return value != 0;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean7"]/*' />
        [CLSCompliant(false)]   
        public static bool ToBoolean(uint value) {
            return value != 0;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean8"]/*' />
        public static bool ToBoolean(long value) {
            return value != 0;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean9"]/*' />
        [CLSCompliant(false)]   
        public static bool ToBoolean(ulong value) {
            return value != 0;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean10"]/*' />
        public static bool ToBoolean(String value) {
            if (value == null)
                return false;
            return Boolean.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean16"]/*' />
        public static bool ToBoolean(String value, IFormatProvider provider) {
            if (value == null)
                return false;
            return Boolean.Parse(value);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean11"]/*' />
        public static bool ToBoolean(float value)
		{
			return value != 0;
		}
        
		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean12"]/*' />
 		public static bool ToBoolean(double value)
		{
			return value != 0;
		}

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean17"]/*' />
        public static bool ToBoolean(decimal value)
		{
			return value != 0;
		}

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBoolean18"]/*' />
		public static bool ToBoolean(DateTime value)
		{
			return ((IConvertible)value).ToBoolean(null);
		}
 
		// Disallowed conversions to Boolean
        // public static bool ToBoolean(TimeSpan value)

        // Conversions to Char


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar"]/*' />
        public static char ToChar(object value) {
            return value == null? (char)0: ((IConvertible)value).ToChar(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar11"]/*' />
        public static char ToChar(object value, IFormatProvider provider) {
            return value == null? (char)0: ((IConvertible)value).ToChar(provider);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar18"]/*' />
		public static char ToChar(bool value) {
            return ((IConvertible)value).ToChar(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar12"]/*' />
		public static char ToChar(char value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar1"]/*' />
        [CLSCompliant(false)]
		public static char ToChar(sbyte value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_Char"));
            return (char)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar2"]/*' />
        public static char ToChar(byte value) {
            return (char)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar3"]/*' />
        public static char ToChar(short value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_Char"));
            return (char)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar4"]/*' />
        [CLSCompliant(false)]   
        public static char ToChar(ushort value) {
            return (char)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar5"]/*' />
        public static char ToChar(int value) {
            if (value < 0 || value > Char.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Char"));
            return (char)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar6"]/*' />
        [CLSCompliant(false)]   
        public static char ToChar(uint value) {
            if (value > Char.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Char"));
            return (char)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar13"]/*' />
        public static char ToChar(long value) {
            if (value < 0 || value > Char.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Char"));
            return (char)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar14"]/*' />
        [CLSCompliant(false)]   
        public static char ToChar(ulong value) {
            if (value > Char.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Char"));
            return (char)value;
        }

        //
        // @VariantSwitch
        // Remove FormatExceptions;
        //
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar7"]/*' />
        public static char ToChar(String value) {
            if (value == null) 
                throw new ArgumentNullException("value");
         
            if (value.Length != 1) 
				throw new FormatException(Environment.GetResourceString(ResId.Format_NeedSingleChar));

            return value[0];
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar15"]/*' />
        public static char ToChar(String value, IFormatProvider provider) {
            return ToChar(value);
        }

		// To be consistent with IConvertible in the base data types else we get different semantics
		// with widening operations. Without this operator this widen succeeds,with this API the widening throws.
		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar8"]/*' />
		public static char ToChar(float value)
		{
			return ((IConvertible)value).ToChar(null);
		}

		// To be consistent with IConvertible in the base data types else we get different semantics
		// with widening operations. Without this operator this widen succeeds,with this API the widening throws.
		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar9"]/*' />
		public static char ToChar(double value)
		{
			return ((IConvertible)value).ToChar(null);
		}

		// To be consistent with IConvertible in the base data types else we get different semantics
		// with widening operations. Without this operator this widen succeeds,with this API the widening throws.
	    /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar10"]/*' />
	    public static char ToChar(decimal value)
		{
			return ((IConvertible)value).ToChar(null);
		}

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToChar17"]/*' />
		public static char ToChar(DateTime value)
		{
			return ((IConvertible)value).ToChar(null);
		}


        // Disallowed conversions to Char
        // public static char ToChar(TimeSpan value)
        
        // Conversions to SByte

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(object value) {
            return value == null? (sbyte)0: ((IConvertible)value).ToSByte(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte15"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(object value, IFormatProvider provider) {
            return value == null? (sbyte)0: ((IConvertible)value).ToSByte(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte1"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(bool value) {
            return value? (sbyte)Boolean.True: (sbyte)Boolean.False;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte16"]/*' />
		[CLSCompliant(false)]
		public static sbyte ToSByte(sbyte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte2"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(char value) {
            if (value > SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
            return (sbyte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte3"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(byte value) {
            if (value > SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
            return (sbyte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte4"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(short value) {
            if (value < SByte.MinValue || value > SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
            return (sbyte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte5"]/*' />
        [CLSCompliant(false)]   
        public static sbyte ToSByte(ushort value) {
            if (value > SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
            return (sbyte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte6"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(int value) {
            if (value < SByte.MinValue || value > SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
            return (sbyte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte7"]/*' />
        [CLSCompliant(false)]   
        public static sbyte ToSByte(uint value) {
            if (value > SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
            return (sbyte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte8"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(long value) {
            if (value < SByte.MinValue || value > SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
            return (sbyte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte9"]/*' />
        [CLSCompliant(false)]   
        public static sbyte ToSByte(ulong value) {
            if (value > (ulong)SByte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
            return (sbyte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte10"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(float value) {
            return ToSByte((double)value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte11"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(double value) {
            return ToSByte(ToInt32(value));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte12"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(decimal value) {
            return Decimal.ToSByte(Decimal.Round(value, 0));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte13"]/*' />
		[CLSCompliant(false)]
        public static sbyte ToSByte(String value) {
			if (value == null)
				return 0;
            return SByte.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte17"]/*' />
        [CLSCompliant(false)]
        public static sbyte ToSByte(String value, IFormatProvider provider) {
            return SByte.Parse(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte18"]/*' />
        [CLSCompliant(false)]
		public static sbyte ToSByte(DateTime value)
		{
			return ((IConvertible)value).ToSByte(null);
		}

        // Disallowed conversions to SByte
        // public static sbyte ToSByte(TimeSpan value)

        // Conversions to Byte

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte"]/*' />
        public static byte ToByte(object value) {
            return value == null? (byte)0: ((IConvertible)value).ToByte(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte15"]/*' />
        public static byte ToByte(object value, IFormatProvider provider) {
            return value == null? (byte)0: ((IConvertible)value).ToByte(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte1"]/*' />
        public static byte ToByte(bool value) {
            return value? (byte)Boolean.True: (byte)Boolean.False;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte16"]/*' />
        public static byte ToByte(byte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte2"]/*' />
        public static byte ToByte(char value) {
            if (value > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte3"]/*' />
		[CLSCompliant(false)]
        public static byte ToByte(sbyte value) {
            if (value < Byte.MinValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte4"]/*' />
        public static byte ToByte(short value) {
            if (value < Byte.MinValue || value > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte5"]/*' />
        [CLSCompliant(false)]   
        public static byte ToByte(ushort value) {
            if (value > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte6"]/*' />
        public static byte ToByte(int value) {
            if (value < Byte.MinValue || value > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte7"]/*' />
        [CLSCompliant(false)]   
        public static byte ToByte(uint value) {
            if (value > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte8"]/*' />
        public static byte ToByte(long value) {
            if (value < Byte.MinValue || value > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte9"]/*' />
        [CLSCompliant(false)]   
        public static byte ToByte(ulong value) {
            if (value > Byte.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
            return (byte)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte10"]/*' />
        public static byte ToByte(float value) {
            return ToByte((double)value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte11"]/*' />
        public static byte ToByte(double value) {
            return ToByte(ToInt32(value));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte12"]/*' />
        public static byte ToByte(decimal value) {
            return Decimal.ToByte(Decimal.Round(value, 0));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte13"]/*' />
        public static byte ToByte(String value) {
			if (value == null)
				return 0;
            return Byte.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte17"]/*' />
        public static byte ToByte(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return Byte.Parse(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte18"]/*' />
    	public static byte ToByte(DateTime value)
		{
			return ((IConvertible)value).ToByte(null);
		}


        // Disallowed conversions to Byte
        // public static byte ToByte(TimeSpan value)

        // Conversions to Int16

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt16"]/*' />
        public static short ToInt16(object value) {
            return value == null? (short)0: ((IConvertible)value).ToInt16(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1615"]/*' />
        public static short ToInt16(object value, IFormatProvider provider) {
            return value == null? (short)0: ((IConvertible)value).ToInt16(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt161"]/*' />
        public static short ToInt16(bool value) {
            return value? (short)Boolean.True: (short)Boolean.False;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt162"]/*' />
        public static short ToInt16(char value) {
            if (value > Int16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
            return (short)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt163"]/*' />
		[CLSCompliant(false)]
        public static short ToInt16(sbyte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt164"]/*' />
        public static short ToInt16(byte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt165"]/*' />
        [CLSCompliant(false)]   
        public static short ToInt16(ushort value) {
            if (value > Int16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
            return (short)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt166"]/*' />
        public static short ToInt16(int value) {
            if (value < Int16.MinValue || value > Int16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
            return (short)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt167"]/*' />
        [CLSCompliant(false)]   
        public static short ToInt16(uint value) {
            if (value > Int16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
            return (short)value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1616"]/*' />
		public static short ToInt16(short value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt168"]/*' />
        public static short ToInt16(long value) {
            if (value < Int16.MinValue || value > Int16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
            return (short)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt169"]/*' />
        [CLSCompliant(false)]   
        public static short ToInt16(ulong value) {
            if (value > (ulong)Int16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
            return (short)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1610"]/*' />
        public static short ToInt16(float value) {
            return ToInt16((double)value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1611"]/*' />
        public static short ToInt16(double value) {
            return ToInt16(ToInt32(value));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1612"]/*' />
        public static short ToInt16(decimal value) {
            return Decimal.ToInt16(Decimal.Round(value, 0));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1613"]/*' />
        public static short ToInt16(String value) {
			if (value == null)
				return 0;
            return Int16.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1617"]/*' />
        public static short ToInt16(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return Int16.Parse(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1618"]/*' />
    	public static short ToInt16(DateTime value)
		{
			return ((IConvertible)value).ToInt16(null);
		}


        // Disallowed conversions to Int16
        // public static short ToInt16(TimeSpan value)

        // Conversions to UInt16

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt16"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(object value) {
            return value == null? (ushort)0: ((IConvertible)value).ToUInt16(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1615"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(object value, IFormatProvider provider) {
            return value == null? (ushort)0: ((IConvertible)value).ToUInt16(provider);
        }


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt161"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(bool value) {
            return value? (ushort)Boolean.True: (ushort)Boolean.False;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt162"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(char value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt163"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(sbyte value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
            return (ushort)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt164"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(byte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt165"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(short value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
            return (ushort)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt166"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(int value) {
            if (value < 0 || value > UInt16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
            return (ushort)value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1616"]/*' />
		[CLSCompliant(false)] 
		public static ushort ToUInt16(ushort value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt167"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(uint value) {
            if (value > UInt16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
            return (ushort)value;
        }

		
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt168"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(long value) {
            if (value < 0 || value > UInt16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
            return (ushort)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt169"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(ulong value) {
            if (value > UInt16.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
            return (ushort)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1610"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(float value) {
            return ToUInt16((double)value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1611"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(double value) {
            return ToUInt16(ToInt32(value));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1612"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(decimal value) {
            return Decimal.ToUInt16(Decimal.Round(value, 0));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1613"]/*' />
        [CLSCompliant(false)]   
        public static ushort ToUInt16(String value) {
			if (value == null)
				return 0;
            return UInt16.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1617"]/*' />
        [CLSCompliant(false)]
        public static ushort ToUInt16(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return UInt16.Parse(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1618"]/*' />
        [CLSCompliant(false)]
        public static ushort ToUInt16(DateTime value)
		{
			return ((IConvertible)value).ToUInt16(null);
		}

		// Disallowed conversions to UInt16
        // public static ushort ToUInt16(TimeSpan value)

        // Conversions to Int32

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt32"]/*' />
        public static int ToInt32(object value) {
            return value == null? 0: ((IConvertible)value).ToInt32(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3215"]/*' />
        public static int ToInt32(object value, IFormatProvider provider) {
            return value == null? 0: ((IConvertible)value).ToInt32(provider);
        }


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt321"]/*' />
        public static int ToInt32(bool value) {
            return value? Boolean.True: Boolean.False;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt322"]/*' />
        public static int ToInt32(char value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt323"]/*' />
		[CLSCompliant(false)]
        public static int ToInt32(sbyte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt324"]/*' />
        public static int ToInt32(byte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt325"]/*' />
        public static int ToInt32(short value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt326"]/*' />
        [CLSCompliant(false)]   
        public static int ToInt32(ushort value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt327"]/*' />
        [CLSCompliant(false)]   
        public static int ToInt32(uint value) {
            if (value > Int32.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
            return (int)value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3216"]/*' />
		public static int ToInt32(int value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt328"]/*' />
        public static int ToInt32(long value) {
            if (value < Int32.MinValue || value > Int32.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
            return (int)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt329"]/*' />
        [CLSCompliant(false)]   
        public static int ToInt32(ulong value) {
            if (value > Int32.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
            return (int)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3210"]/*' />
        public static int ToInt32(float value) {
            return ToInt32((double)value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3211"]/*' />
        public static int ToInt32(double value) {
            if (value >= 0) {
                if (value < 2147483647.5) {
                    int result = (int)value;
                    double dif = value - result;
                    if (dif > 0.5 || dif == 0.5 && (result & 1) != 0) result++;
                    return result;
                }
            }
            else {
                if (value >= -2147483648.5) {
                    int result = (int)value;
                    double dif = value - result;
                    if (dif < -0.5 || dif == -0.5 && (result & 1) != 0) result--;
                    return result;
                }
            }
            throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3212"]/*' />
        public static int ToInt32(decimal value) {
            return Decimal.ToInt32(Decimal.Round(value, 0));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3213"]/*' />
        public static int ToInt32(String value) {
			if (value == null)
				return 0;
            return Int32.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3217"]/*' />
        public static int ToInt32(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return Int32.Parse(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3218"]/*' />
    	public static int ToInt32(DateTime value)
		{
			return ((IConvertible)value).ToInt32(null);
		}


        // Disallowed conversions to Int32
        // public static int ToInt32(TimeSpan value)

        // Conversions to UInt32

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt32"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(object value) {
            return value == null? 0: ((IConvertible)value).ToUInt32(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3215"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(object value, IFormatProvider provider) {
            return value == null? 0: ((IConvertible)value).ToUInt32(provider);
        }


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt321"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(bool value) {
            return value? (uint)Boolean.True: (uint)Boolean.False;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt322"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(char value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt323"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(sbyte value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
            return (uint)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt324"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(byte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt325"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(short value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
            return (uint)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt326"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(ushort value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt327"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(int value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
            return (uint)value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3216"]/*' />
		[CLSCompliant(false)] 
		public static uint ToUInt32(uint value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt328"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(long value) {
            if (value < 0 || value > UInt32.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
            return (uint)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt329"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(ulong value) {
            if (value > UInt32.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
            return (uint)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3210"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(float value) {
            return ToUInt32((double)value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3211"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(double value) {
            if (value >= -0.5 && value < 4294967295.5) {
                uint result = (uint)value;
                double dif = value - result;
                if (dif > 0.5 || dif == 0.5 && (result & 1) != 0) result++;
                return result;
            }
            throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3212"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(decimal value) {
            return Decimal.ToUInt32(Decimal.Round(value, 0));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3213"]/*' />
        [CLSCompliant(false)]   
        public static uint ToUInt32(String value) {
			if (value == null)
				return 0;
            return UInt32.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3217"]/*' />
        [CLSCompliant(false)]
        public static uint ToUInt32(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return UInt32.Parse(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3218"]/*' />
		[CLSCompliant(false)]
    	public static uint ToUInt32(DateTime value)
		{
			return ((IConvertible)value).ToUInt32(null);
		}

		// Disallowed conversions to UInt32
        // public static uint ToUInt32(TimeSpan value)

        // Conversions to Int64

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt64"]/*' />
        public static long ToInt64(object value) {
            return value == null? 0: ((IConvertible)value).ToInt64(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6414"]/*' />
        public static long ToInt64(object value, IFormatProvider provider) {
            return value == null? 0: ((IConvertible)value).ToInt64(provider);
        }


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt641"]/*' />
        public static long ToInt64(bool value) {
            return value? Boolean.True: Boolean.False;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6415"]/*' />
        public static long ToInt64(char value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt642"]/*' />
		[CLSCompliant(false)]
        public static long ToInt64(sbyte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt643"]/*' />
        public static long ToInt64(byte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt644"]/*' />
        public static long ToInt64(short value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt645"]/*' />
        [CLSCompliant(false)]   
        public static long ToInt64(ushort value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt646"]/*' />
        public static long ToInt64(int value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt647"]/*' />
        [CLSCompliant(false)]   
        public static long ToInt64(uint value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt648"]/*' />
        [CLSCompliant(false)]   
        public static long ToInt64(ulong value) {
            if (value > Int64.MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int64"));
            return (long)value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6416"]/*' />
		public static long ToInt64(long value) {
            return value;
        }


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt649"]/*' />
        public static long ToInt64(float value) {
            return ToInt64((double)value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6410"]/*' />
        public static long ToInt64(double value) {
            // The correct way to fix this is to use checked((long)(Round(value)) but its code churn.
            // The comparision of a double with Int64.MaxValue (<=) cause the Int64's value to be converted to a double and
            // this causes a loss in precision since a double is only capable of storing values of 2^53 precisely. The
            // convertion cause the Int64.Value to be rounded up first to the nearest power of 2. Then this rounded value of 2^64
            // when converted to a double causes the comparision of value <= Int64.MaxValue to allow a bunch of values to incorrectly pass the condition instead of throwing an overflow exception. See
            // bug 87375 for details.
            if (value >= 0) {
                if (value < Int64.MaxValue) {
                    long result = (long)value;
                    double dif = value - result;
                    if (dif > 0.5 || dif == 0.5 && (result & 1) != 0) result++;
                    return result;
                }
            }
            else {
                if (value > Int64.MinValue) {
                    long result = (long)value;
                    double dif = value - result;
                    if (dif < -0.5 || dif == -0.5 && (result & 1) != 0) result--;
                    return result;
                }
            }
            throw new OverflowException(Environment.GetResourceString("Overflow_Int64"));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6411"]/*' />
        public static long ToInt64(decimal value) {
            return Decimal.ToInt64(Decimal.Round(value, 0));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6412"]/*' />
        public static long ToInt64(string value) {
			if (value == null)
				return 0;
            return Int64.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6417"]/*' />
        public static long ToInt64(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return Int64.Parse(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6418"]/*' />
    	public static long ToInt64(DateTime value)
		{
			return ((IConvertible)value).ToInt64(null);
		}

        // Disallowed conversions to Int64
        // public static long ToInt64(TimeSpan value)

        // Conversions to UInt64

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt64"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(object value) {
            return value == null? 0: ((IConvertible)value).ToUInt64(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6414"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(object value, IFormatProvider provider) {
            return value == null? 0: ((IConvertible)value).ToUInt64(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt641"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(bool value) {
            return value? (ulong)Boolean.True: (ulong)Boolean.False;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6415"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(char value) {
            return value;
        }

	
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt642"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(sbyte value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
            return (ulong)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt643"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(byte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt644"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(short value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
            return (ulong)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt645"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(ushort value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt646"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(int value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
            return (ulong)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt647"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(uint value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt648"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(long value) {
            if (value < 0) throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
            return (ulong)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6416"]/*' />
		[CLSCompliant(false)]   
        public static ulong ToUInt64(UInt64 value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt649"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(float value) {
            return ToUInt64((double)value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6410"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(double value) {
        // The correct way to fix this is to use checked((long)(Round(value)) but its code churn.
        // The comparision of a double with UInt64.MaxValue (<=) cause the Int64's value to be converted to a double and
        // this causes a loss in precision since a double is only capable of storing values of 2^53 precisely. The
        // convertion cause the Int64.Value to be rounded up first to the nearest power of 2. Then this rounded value of 2^64
        // when converted to a double causes the comparision of value <= Int64.MaxValue to allow a bunch of values to incorrectly pass the condition instead of throwing an overflow exception. See
        // bug 87375 for details.
        if (value >= -0.5 && value < UInt64.MaxValue) {
                ulong result = (ulong)value;
                double dif = value - result;
                if (dif > 0.5 || dif == 0.5 && (result & 1) != 0) result++;
                return result;
            }
            throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6411"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(decimal value) {
            return Decimal.ToUInt64(Decimal.Round(value, 0));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6412"]/*' />
        [CLSCompliant(false)]   
        public static ulong ToUInt64(String value) {
			if (value == null)
				return 0;
            return UInt64.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6417"]/*' />
        [CLSCompliant(false)]
        public static ulong ToUInt64(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return UInt64.Parse(value, NumberStyles.Integer, NumberFormatInfo.GetInstance(provider));
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6418"]/*' />
		[CLSCompliant(false)]
    	public static ulong ToUInt64(DateTime value)
		{
			return ((IConvertible)value).ToUInt64(null);
		}

        // Disallowed conversions to UInt64
        // public static ulong ToUInt64(TimeSpan value)

        // Conversions to Single

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle"]/*' />
        public static float ToSingle(object value) {
            return value == null? 0: ((IConvertible)value).ToSingle(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle12"]/*' />
        public static float ToSingle(object value, IFormatProvider provider) {
            return value == null? 0: ((IConvertible)value).ToSingle(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle1"]/*' />
		[CLSCompliant(false)]
        public static float ToSingle(sbyte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle2"]/*' />
        public static float ToSingle(byte value) {
            return value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle13"]/*' />
		public static float ToSingle(char value) {
            return ((IConvertible)value).ToSingle(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle3"]/*' />
        public static float ToSingle(short value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle4"]/*' />
        [CLSCompliant(false)]   
        public static float ToSingle(ushort value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle5"]/*' />
        public static float ToSingle(int value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle6"]/*' />
        [CLSCompliant(false)]   
        public static float ToSingle(uint value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle7"]/*' />
        public static float ToSingle(long value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle8"]/*' />
        [CLSCompliant(false)]   
        public static float ToSingle(ulong value) {
            return value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle14"]/*' />
		public static float ToSingle(float value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle9"]/*' />
        public static float ToSingle(double value) {
            return (float)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle10"]/*' />
        public static float ToSingle(decimal value) {
            return (float)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle11"]/*' />
        public static float ToSingle(String value) {
			if (value == null)
				return 0;
            return Single.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle15"]/*' />
        public static float ToSingle(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return Single.Parse(value, NumberStyles.Float | NumberStyles.AllowThousands, NumberFormatInfo.GetInstance(provider));
        }


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle16"]/*' />
        public static float ToSingle(bool value)
        {
            return value? Boolean.True: Boolean.False;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSingle17"]/*' />
        public static float ToSingle(DateTime value)
		{
			return ((IConvertible)value).ToSingle(null);
		}

        // Disallowed conversions to Single
        // public static float ToSingle(TimeSpan value)

        // Conversions to Double

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble"]/*' />
        public static double ToDouble(object value) {
            return value == null? 0: ((IConvertible)value).ToDouble(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble14"]/*' />
        public static double ToDouble(object value, IFormatProvider provider) {
            return value == null? 0: ((IConvertible)value).ToDouble(provider);
        }


        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble1"]/*' />
		[CLSCompliant(false)]
        public static double ToDouble(sbyte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble2"]/*' />
        public static double ToDouble(byte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble3"]/*' />
        public static double ToDouble(short value) {
            return value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble15"]/*' />
		public static double ToDouble(char value) {
            return ((IConvertible)value).ToDouble(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble4"]/*' />
        [CLSCompliant(false)]   
        public static double ToDouble(ushort value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble5"]/*' />
        public static double ToDouble(int value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble6"]/*' />
        [CLSCompliant(false)]   
        public static double ToDouble(uint value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble7"]/*' />
        public static double ToDouble(long value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble8"]/*' />
        [CLSCompliant(false)]   
        public static double ToDouble(ulong value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble9"]/*' />
        public static double ToDouble(float value) {
            return value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble16"]/*' />
		public static double ToDouble(double value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble10"]/*' />
        public static double ToDouble(decimal value) {
            return (double)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble11"]/*' />
        public static double ToDouble(String value) {
			if (value == null)
				return 0;
            return Double.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble17"]/*' />
        public static double ToDouble(String value, IFormatProvider provider) {
			if (value == null)
				return 0;
            return Double.Parse(value, NumberStyles.Float | NumberStyles.AllowThousands, NumberFormatInfo.GetInstance(provider));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble18"]/*' />
        public static double ToDouble(bool value) {
            return value? Boolean.True: Boolean.False;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDouble19"]/*' />
        public static double ToDouble(DateTime value)
		{
			return ((IConvertible)value).ToDouble(null);
		}

        // Disallowed conversions to Double
        // public static double ToDouble(TimeSpan value)

        // Conversions to Decimal

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal"]/*' />
        public static decimal ToDecimal(object value) {
            return value == null? 0: ((IConvertible)value).ToDecimal(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal13"]/*' />
        public static decimal ToDecimal(object value, IFormatProvider provider) {
            return value == null? 0: ((IConvertible)value).ToDecimal(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal1"]/*' />
		[CLSCompliant(false)]
        public static decimal ToDecimal(sbyte value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal2"]/*' />
        public static decimal ToDecimal(byte value) {
            return value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal14"]/*' />
		public static decimal ToDecimal(char value) {
            return ((IConvertible)value).ToDecimal(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal3"]/*' />
        public static decimal ToDecimal(short value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal4"]/*' />
        [CLSCompliant(false)]   
        public static decimal ToDecimal(ushort value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal5"]/*' />
        public static decimal ToDecimal(int value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal6"]/*' />
        [CLSCompliant(false)]   
        public static decimal ToDecimal(uint value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal7"]/*' />
        public static decimal ToDecimal(long value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal8"]/*' />
        [CLSCompliant(false)]   
        public static decimal ToDecimal(ulong value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal9"]/*' />
        public static decimal ToDecimal(float value) {
            return (decimal)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal10"]/*' />
        public static decimal ToDecimal(double value) {
            return (decimal)value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal11"]/*' />
        public static decimal ToDecimal(String value) {
			if (value == null)
				return 0m;
            return Decimal.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal12"]/*' />
        public static Decimal ToDecimal(String value, IFormatProvider provider) {
			if (value == null)
				return 0m;
            return Decimal.Parse(value, NumberStyles.Number, NumberFormatInfo.GetInstance(provider));
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal15"]/*' />
        public static decimal ToDecimal(decimal value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal16"]/*' />
        public static decimal ToDecimal(bool value) {
            return value? Boolean.True: Boolean.False;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDecimal17"]/*' />
        public static decimal ToDecimal(DateTime value)
		{
			return ((IConvertible)value).ToDecimal(null);
		}

		// Disallowed conversions to Decimal
        // public static decimal ToDecimal(TimeSpan value)

        // Conversions to DateTime

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime17"]/*' />
        public static DateTime ToDateTime(DateTime value) {
            return value;
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime"]/*' />
        public static DateTime ToDateTime(object value) {
            return value == null? DateTime.MinValue: ((IConvertible)value).ToDateTime(null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime1"]/*' />
        public static DateTime ToDateTime(object value, IFormatProvider provider) {
            return value == null? DateTime.MinValue: ((IConvertible)value).ToDateTime(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime2"]/*' />
        public static DateTime ToDateTime(String value) {
			if (value == null)
				return new DateTime(0);
            return DateTime.Parse(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime3"]/*' />
        public static DateTime ToDateTime(String value, IFormatProvider provider) {
			if (value == null)
				return new DateTime(0);
            return DateTime.Parse(value, DateTimeFormatInfo.GetInstance(provider));
        }

		 /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime4"]/*' />
		 [CLSCompliant(false)]
        public static DateTime ToDateTime(sbyte value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime5"]/*' />
        public static DateTime ToDateTime(byte value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime6"]/*' />
        public static DateTime ToDateTime(short value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime7"]/*' />
		[CLSCompliant(false)]
        public static DateTime ToDateTime(ushort value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime8"]/*' />
        public static DateTime ToDateTime(int value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime9"]/*' />
		[CLSCompliant(false)]
        public static DateTime ToDateTime(uint value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime10"]/*' />
        public static DateTime ToDateTime(long value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime11"]/*' />
		[CLSCompliant(false)]
        public static DateTime ToDateTime(ulong value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime12"]/*' />
        public static DateTime ToDateTime(bool value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime13"]/*' />
        public static DateTime ToDateTime(char value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime14"]/*' />
        public static DateTime ToDateTime(float value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime15"]/*' />
        public static DateTime ToDateTime(double value) {
            return ((IConvertible)value).ToDateTime(null);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToDateTime16"]/*' />
        public static DateTime ToDateTime(decimal value) {
            return ((IConvertible)value).ToDateTime(null);
        }

        // Disallowed conversions to DateTime
        // public static DateTime ToDateTime(TimeSpan value)

        // Conversions to String

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString"]/*' />
        public static string ToString(Object value) {
            return ToString(value,null);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString19"]/*' />
        public static string ToString(Object value, IFormatProvider provider) {
            IConvertible ic = value as IConvertible;
            if (ic != null) return ic.ToString(provider);
            return value == null? String.Empty: value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString1"]/*' />
        public static string ToString(bool value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString20"]/*' />
        public static string ToString(bool value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString2"]/*' />
        public static string ToString(char value) {
            return Char.ToString(value);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString21"]/*' />
        public static string ToString(char value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString3"]/*' />
		[CLSCompliant(false)]
        public static string ToString(sbyte value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString22"]/*' />
        [CLSCompliant(false)]
        public static string ToString(sbyte value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString4"]/*' />
        public static string ToString(byte value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString23"]/*' />
        public static string ToString(byte value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString5"]/*' />
        public static string ToString(short value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString24"]/*' />
        public static string ToString(short value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString6"]/*' />
        [CLSCompliant(false)]   
        public static string ToString(ushort value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString25"]/*' />
        [CLSCompliant(false)]
        public static string ToString(ushort value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString7"]/*' />
        public static string ToString(int value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString26"]/*' />
        public static string ToString(int value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString8"]/*' />
        [CLSCompliant(false)]   
        public static string ToString(uint value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString27"]/*' />
        [CLSCompliant(false)]
        public static string ToString(uint value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString9"]/*' />
        public static string ToString(long value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString28"]/*' />
        public static string ToString(long value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString10"]/*' />
        [CLSCompliant(false)]   
        public static string ToString(ulong value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString29"]/*' />
        [CLSCompliant(false)]
        public static string ToString(ulong value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString11"]/*' />
        public static string ToString(float value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString30"]/*' />
        public static string ToString(float value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString12"]/*' />
        public static string ToString(double value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString31"]/*' />
        public static string ToString(double value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString13"]/*' />
        public static string ToString(decimal value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString32"]/*' />
        public static string ToString(Decimal value, IFormatProvider provider) {
            return value.ToString(provider);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString14"]/*' />
        public static string ToString(DateTime value) {
            return value.ToString();
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString33"]/*' />
        public static string ToString(DateTime value, IFormatProvider provider) {
            return value.ToString(provider);
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString34"]/*' />
        public static String ToString(String value) {
            return value;
        }

		/// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString35"]/*' />
        public static String ToString(String value,IFormatProvider provider) {
            return value; // avoid the null check
        }


        //
        // Conversions which understand Base XXX numbers.
        //
        // Parses value in base base.  base can only
        // be 2, 8, 10, or 16.  If base is 16, the number may be preceded
        // by 0x; any other leading or trailing characters cause an error.
        //
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToByte14"]/*' />
        public static byte ToByte (String value, int fromBase) {
            if (fromBase!=2 && fromBase!=8 && fromBase!=10 && fromBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            int r = ParseNumbers.StringToInt(value,fromBase,ParseNumbers.IsTight | ParseNumbers.TreatAsUnsigned);
    		if (r < Byte.MinValue || r > Byte.MaxValue)
    			throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
    		return (byte) r;
        }

        // Parses value in base fromBase.  fromBase can only
        // be 2, 8, 10, or 16.  If fromBase is 16, the number may be preceded
        // by 0x; any other leading or trailing characters cause an error.
        //
            /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToSByte14"]/*' />
        [CLSCompliant(false)]
        public static sbyte ToSByte (String value, int fromBase) {
            if (fromBase!=2 && fromBase!=8 && fromBase!=10 && fromBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            int r = ParseNumbers.StringToInt(value,fromBase,ParseNumbers.IsTight | ParseNumbers.TreatAsI1);
            if (fromBase != 10 && r <= Byte.MaxValue)
                return (sbyte)r;

    		if (r < SByte.MinValue || r > SByte.MaxValue)
    			throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
    		return (sbyte) r;
        }

        // Parses value in base fromBase.  fromBase can only
        // be 2, 8, 10, or 16.  If fromBase is 16, the number may be preceded
        // by 0x; any other leading or trailing characters cause an error.
        //
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt1614"]/*' />
        public static short ToInt16 (String value, int fromBase) {
            if (fromBase!=2 && fromBase!=8 && fromBase!=10 && fromBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            int r = ParseNumbers.StringToInt(value,fromBase,ParseNumbers.IsTight | ParseNumbers.TreatAsI2);
            if (fromBase != 10 && r <= UInt16.MaxValue)
                return (short)r;

    		if (r < Int16.MinValue || r > Int16.MaxValue)
    			throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
    		return (short) r;
        }

        // Parses value in base fromBase.  fromBase can only
        // be 2, 8, 10, or 16.  If fromBase is 16, the number may be preceded
        // by 0x; any other leading or trailing characters cause an error.
        //
            /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt1614"]/*' />
    	[CLSCompliant(false)]
            public static ushort ToUInt16 (String value, int fromBase) {
            if (fromBase!=2 && fromBase!=8 && fromBase!=10 && fromBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            int r = ParseNumbers.StringToInt(value,fromBase,ParseNumbers.IsTight | ParseNumbers.TreatAsUnsigned);
    		if (r < UInt16.MinValue || r > UInt16.MaxValue)
    			throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
    		return (ushort) r;
        }

        // Parses value in base fromBase.  fromBase can only
        // be 2, 8, 10, or 16.  If fromBase is 16, the number may be preceded
        // by 0x; any other leading or trailing characters cause an error.
        //
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt3214"]/*' />
        public static int ToInt32 (String value, int fromBase) {
            if (fromBase!=2 && fromBase!=8 && fromBase!=10 && fromBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            return ParseNumbers.StringToInt(value,fromBase,ParseNumbers.IsTight);
        }

        // Parses value in base fromBase.  fromBase can only
        // be 2, 8, 10, or 16.  If fromBase is 16, the number may be preceded
        // by 0x; any other leading or trailing characters cause an error.
        //
            /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt3214"]/*' />
    	[CLSCompliant(false)]
            public static uint ToUInt32 (String value, int fromBase) {
            if (fromBase!=2 && fromBase!=8 && fromBase!=10 && fromBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            return (uint) ParseNumbers.StringToInt(value,fromBase, ParseNumbers.TreatAsUnsigned | ParseNumbers.IsTight);
        }

        // Parses value in base fromBase.  fromBase can only
        // be 2, 8, 10, or 16.  If fromBase is 16, the number may be preceded
        // by 0x; any other leading or trailing characters cause an error.
        //
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToInt6413"]/*' />
        public static long ToInt64 (String value, int fromBase) {
            if (fromBase!=2 && fromBase!=8 && fromBase!=10 && fromBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            return ParseNumbers.StringToLong(value,fromBase,ParseNumbers.IsTight);
        }

        // Parses value in base fromBase.  fromBase can only
        // be 2, 8, 10, or 16.  If fromBase is 16, the number may be preceded
        // by 0x; any other leading or trailing characters cause an error.
        //
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToUInt6413"]/*' />
    	[CLSCompliant(false)]
        public static ulong ToUInt64 (String value, int fromBase) {
            if (fromBase!=2 && fromBase!=8 && fromBase!=10 && fromBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            return (ulong) ParseNumbers.StringToLong(value,fromBase, ParseNumbers.TreatAsUnsigned | ParseNumbers.IsTight);
        }

        // Convert the byte value to a string in base fromBase
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString15"]/*' />
        public static String ToString (byte value, int toBase) {
            if (toBase!=2 && toBase!=8 && toBase!=10 && toBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            return ParseNumbers.IntToString((int)value, toBase, -1, ' ', ParseNumbers.PrintAsI1);
        }

        // Convert the Int16 value to a string in base fromBase
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString16"]/*' />
        public static String ToString (short value, int toBase) {
            if (toBase!=2 && toBase!=8 && toBase!=10 && toBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            return ParseNumbers.IntToString((int)value, toBase, -1, ' ', ParseNumbers.PrintAsI2);
        }

        // Convert the Int32 value to a string in base toBase
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString17"]/*' />
        public static String ToString (int value, int toBase) {
            if (toBase!=2 && toBase!=8 && toBase!=10 && toBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            return ParseNumbers.IntToString(value, toBase, -1, ' ', 0);
        }

        // Convert the Int64 value to a string in base toBase
        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToString18"]/*' />
        public static String ToString (long value, int toBase) {
            if (toBase!=2 && toBase!=8 && toBase!=10 && toBase!=16) {
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidBase"));
            }
            return ParseNumbers.LongToString(value, toBase, -1, ' ', 0);
        }

        /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBase64String"]/*' />
        public static String ToBase64String(byte[] inArray) {
            if (inArray==null) {
                throw new ArgumentNullException("inArray");
            }
            return ToBase64String(inArray, 0, inArray.Length);
        }

            /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBase64String1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
            public static extern String ToBase64String(byte[] inArray, int offset, int length);

            /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.FromBase64String"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
            public static extern byte[] FromBase64String(String s);

            /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.ToBase64CharArray"]/*' />
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
            public static extern int ToBase64CharArray(byte[] inArray, int offsetIn, int length,char[] outArray, int offsetOut);

            /// <include file='doc\Convert.uex' path='docs/doc[@for="Convert.FromBase64CharArray"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
            public static extern byte[] FromBase64CharArray(char[] inArray, int offset, int length);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\empty.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Void
//	This class represents an empty variant
////////////////////////////////////////////////////////////////////////////////

namespace System {
    
	using System;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
    /// <include file='doc\Empty.uex' path='docs/doc[@for="Empty"]/*' />
    [Serializable()] internal sealed class Empty : ISerializable
    {
        //Package private constructor
        internal Empty() {
        }
    
    	/// <include file='doc\Empty.uex' path='docs/doc[@for="Empty.Value"]/*' />
    	public static readonly Empty Value = new Empty();
    	
    	/// <include file='doc\Empty.uex' path='docs/doc[@for="Empty.ToString"]/*' />
    	public override String ToString()
    	{
    		return String.Empty;
    	}
    
        /// <include file='doc\Empty.uex' path='docs/doc[@for="Empty.GetObjectData"]/*' />
        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            UnitySerializationHolder.GetUnitySerializationInfo(info, UnitySerializationHolder.EmptyUnity, null, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\eventargs.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace System {
    
	using System;
    // The base class for all event classes.
    /// <include file='doc\EventArgs.uex' path='docs/doc[@for="EventArgs"]/*' />
	[Serializable]
    public class EventArgs {
        /// <include file='doc\EventArgs.uex' path='docs/doc[@for="EventArgs.Empty"]/*' />
        public static readonly EventArgs Empty = new EventArgs();
    
        /// <include file='doc\EventArgs.uex' path='docs/doc[@for="EventArgs.EventArgs"]/*' />
        public EventArgs() 
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\eventhandler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace System {
    
	using System;
    /// <include file='doc\EventHandler.uex' path='docs/doc[@for="EventHandler"]/*' />
	 [Serializable()]
    public delegate void EventHandler(Object sender, EventArgs e);}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\entrypointnotfoundexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: EntryPointNotFoundException
**
** Author: Atsushi Kanamori (AtsushiK)
**
** Purpose: The exception class for some failed P/Invoke calls.
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\EntryPointNotFoundException.uex' path='docs/doc[@for="EntryPointNotFoundException"]/*' />
    [Serializable] public class EntryPointNotFoundException : TypeLoadException {
        /// <include file='doc\EntryPointNotFoundException.uex' path='docs/doc[@for="EntryPointNotFoundException.EntryPointNotFoundException"]/*' />
        public EntryPointNotFoundException() 
            : base(Environment.GetResourceString("Arg_EntryPointNotFoundException")) {
            SetErrorCode(__HResults.COR_E_ENTRYPOINTNOTFOUND);
        }
    
        /// <include file='doc\EntryPointNotFoundException.uex' path='docs/doc[@for="EntryPointNotFoundException.EntryPointNotFoundException1"]/*' />
        public EntryPointNotFoundException(String message) 
            : base(message) {
            SetErrorCode(__HResults.COR_E_ENTRYPOINTNOTFOUND);
        }
    
        /// <include file='doc\EntryPointNotFoundException.uex' path='docs/doc[@for="EntryPointNotFoundException.EntryPointNotFoundException2"]/*' />
        public EntryPointNotFoundException(String message, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.COR_E_ENTRYPOINTNOTFOUND);
        }

        /// <include file='doc\EntryPointNotFoundException.uex' path='docs/doc[@for="EntryPointNotFoundException.EntryPointNotFoundException3"]/*' />
        protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\environment.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: Environment
**
** Author: Jay Roxe
**
** Purpose: Provides some basic access to some environment 
** functionality.
**
** Date: March 3, 2000
**
============================================================*/
namespace System {
    using System.IO;
    using System.Security;
    using System.Resources;
    using System.Globalization;
    using System.Collections;
    using System.Security.Permissions;
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Runtime.CompilerServices;

    /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment"]/*' />
    public sealed class Environment {

        // Need somewhere to put mscorlib's ResourceManager, and for now, 
        // this looks good.  Talk to BrianGru before moving - you must update
        // excep.cpp, since we use this field from there.
        internal static ResourceManager SystemResMgr;
        // To avoid infinite loops when calling GetResourceString.  See comments
        // in GetResourceString for these two fields.
        internal static Object m_resMgrLockObject;
        internal static bool m_loadingResource;

        private static String m_machineName;
        private const  int    MaxMachineNameLength = 256;

        private static OperatingSystem m_os;  // Cached OperatingSystem value
        private static OSName m_osname;

        private Environment() {}              // Prevent from begin created

        /*==================================TickCount===================================
        **Action: Gets the number of ticks since the system was started.
        **Returns: The number of ticks since the system was started.
        **Arguments: None
        **Exceptions: None
        ==============================================================================*/
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.TickCount"]/*' />
        public static int TickCount {
            get {
                return nativeGetTickCount();
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int nativeGetTickCount();
        
        // Terminates this process with the given exit code.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void ExitNative(int exitCode);
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.Exit"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void Exit(int exitCode) {
            ExitNative(exitCode);
        }


        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.ExitCode"]/*' />
        public static int ExitCode {
            get {
                return nativeGetExitCode();
            }

            set {
                nativeSetExitCode(value);
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nativeSetExitCode(int exitCode);
    
        // Gets the exit code of the process.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int nativeGetExitCode();


        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.CommandLine"]/*' />
        public static String CommandLine {
            get {
        new EnvironmentPermission(EnvironmentPermissionAccess.Read, "Path").Demand();
                return Win32Native.GetCommandLine();
            }
        }
        
        /*===============================CurrentDirectory===============================
        **Action:  Provides a getter and setter for the current directory.  The original
        **         current directory is the one from which the process was started.  
        **Returns: The current directory (from the getter).  Void from the setter.
        **Arguments: The current directory to which to switch to the setter.
        **Exceptions: 
        ==============================================================================*/
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.CurrentDirectory"]/*' />
        public static String CurrentDirectory {
            get{
                return Directory.GetCurrentDirectory();
            }

            set { 
                Directory.SetCurrentDirectory(value);
            }
        }

        // Returns the system directory (ie, C:\WinNT\System32).
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.SystemDirectory"]/*' />
        public static String SystemDirectory {
            get {
                StringBuilder sb = new StringBuilder(Path.MAX_PATH);
                int r = Win32Native.GetSystemDirectory(sb, Path.MAX_PATH);
                BCLDebug.Assert(r < Path.MAX_PATH, "r < Path.MAX_PATH");
                if (r==0) __Error.WinIOError();
                String path = sb.ToString();
                
                // Do security check
                new FileIOPermission(FileIOPermissionAccess.Read, path).Demand();

                return path;
            }
        }

        
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.ExpandEnvironmentVariables"]/*' />
        public static String ExpandEnvironmentVariables(String name)
        {
            if (name == null)
                throw new ArgumentNullException("name");

            // CONSIDER: This is actually asking for too many permissions.
            // In Whidbey, when we add more granularity to EnvironmentPermission
            // we should ask for either read access to all environment variables
            // or spend a while writing code to find each environment variable.
            new EnvironmentPermission(PermissionState.Unrestricted).Demand();

            // Guess a somewhat reasonable initial size, call the method, then if
            // it fails (ie, the return value is larger than our buffer size),
            // make a new buffer & try again.
            const int initSize = 200;  // A somewhat reasonable default size
            StringBuilder blob = new StringBuilder(initSize);
            int size = Win32Native.ExpandEnvironmentStrings(name, blob, initSize);
            if (size == 0 && name.Length != 0)
                Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());

            if (size > initSize) {
                blob = new StringBuilder(size);
                size = Win32Native.ExpandEnvironmentStrings(name, blob, size);
                if (size == 0)
                    Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
            }

            return blob.ToString();
        }

        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.MachineName"]/*' />
        public static string MachineName {
            get {
                new EnvironmentPermission(PermissionState.Unrestricted).Demand();
                StringBuilder buf = new StringBuilder(MaxMachineNameLength);
                int len = MaxMachineNameLength;
                if (GetComputerName(buf, ref len) == 0)
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ComputerName"));
                return buf.ToString();
            }
        }

        [DllImport(Microsoft.Win32.Win32Native.KERNEL32, CharSet=CharSet.Auto)]
        private extern static int GetComputerName(StringBuilder nameBuffer, ref int bufferSize);

        /*==============================GetCommandLineArgs==============================
        **Action: Gets the command line and splits it appropriately to deal with whitespace,
        **        quotes, and escape characters.
        **Returns: A string array containing your command line arguments.
        **Arguments: None
        **Exceptions: None.
        ==============================================================================*/
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.GetCommandLineArgs"]/*' />
        public static String[] GetCommandLineArgs() {
            new EnvironmentPermission(EnvironmentPermissionAccess.Read, "Path").Demand();
            return GetCommandLineArgsNative();
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String[] GetCommandLineArgsNative();
        
        /*============================GetEnvironmentVariable============================
        **Action:
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String nativeGetEnvironmentVariable(String variable);
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.GetEnvironmentVariable"]/*' />
        public static String GetEnvironmentVariable(String variable)
        {
            if (variable == null)
                throw new ArgumentNullException("variable");
            (new EnvironmentPermission(EnvironmentPermissionAccess.Read, variable)).Demand();
            return nativeGetEnvironmentVariable(variable);
        }
        
        /*===========================GetEnvironmentVariables============================
        **Action: Returns an IDictionary containing all enviroment variables and their values.
        **Returns: An IDictionary containing all environment variables and their values.
        **Arguments: None.
        **Exceptions: None.
        ==============================================================================*/
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern char[] nativeGetEnvironmentCharArray();
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.GetEnvironmentVariables"]/*' />
        public static IDictionary GetEnvironmentVariables()
        {
            new EnvironmentPermission(PermissionState.Unrestricted).Demand();
            
            char[] block = nativeGetEnvironmentCharArray();
            
            Hashtable table = new Hashtable(20);
            
            // Copy strings out, parsing into pairs and inserting into the table.
            // The first few environment variable entries start with an '='!
            // The current working directory of every drive (except for those drives
            // you haven't cd'ed into in your DOS window) are stored in the 
            // environment block (as =C:=pwd) and the program's exit code is 
            // as well (=ExitCode=00000000)  Skip all that start with =.
            // Read docs about Environment Blocks on MSDN's CreateProcess page.
            
            // Format for GetEnvironmentStrings is:
            // (=HiddenVar=value\0 | Variable=value\0)* \0
            // See the description of Environment Blocks in MSDN's
            // CreateProcess page (null-terminated array of null-terminated strings).
            // Note the =HiddenVar's aren't always at the beginning.
            
            // GetEnvironmentCharArray will not return the trailing 0 to terminate
            // the array - we have the array length instead.
            for(int i=0; i<block.Length; i++) {
                int startKey = i;
                // Skip to key
                while(block[i]!='=')
                    i++;
                // Skip over environment variables starting with '='
                if (i-startKey==0) {
                    while(block[i]!=0) 
                        i++;
                    continue;
                }
                String key = new String(block, startKey, i-startKey);
                i++;  // skip over '='
                int startValue = i;
                while(block[i]!=0)  // Read to end of this entry
                    i++;
                String value = new String(block, startValue, i-startValue);
                // skip over 0 handled by for loop's i++
                table[key]=value;
            }
                
            return table;
        }
        
        /*===============================GetLogicalDrives===============================
        **Action: Retrieves the names of the logical drives on this machine in the  form "C:\". 
        **Arguments:   None.
        **Exceptions:  IOException.
        **Permissions: SystemInfo Permission.
        ==============================================================================*/
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.GetLogicalDrives"]/*' />
        public static String[] GetLogicalDrives() {
            new EnvironmentPermission(PermissionState.Unrestricted).Demand();
                                 
            int drives = Win32Native.GetLogicalDrives();
            if (drives==0)
                __Error.WinIOError();
            uint d = (uint)drives;
            int count = 0;
            while (d != 0) {
                if (((int)d & 1) != 0) count++;
                d >>= 1;
            }
            String[] result = new String[count];
            char[] root = new char[] {'A', ':', '\\'};
            d = (uint)drives;
            count = 0;
            while (d != 0) {
                if (((int)d & 1) != 0) {
                    result[count++] = new String(root);
                }
                d >>= 1;
                root[0]++;
            }
            return result;
        }
        
        /*===================================NewLine====================================
        **Action: A property which returns the appropriate newline string for the given
        **        platform.
        **Returns: \r\n on Win32.
        **Arguments: None.
        **Exceptions: None.
        ==============================================================================*/
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.NewLine"]/*' />
        public static String NewLine {
            get {
                return "\r\n";
            }
        }

        
        
        /*===================================Version====================================
        **Action: Returns the COM+ version struct, describing the build number.
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String nativeGetVersion();
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.Version"]/*' />
        public static Version Version {
            get {
                String [] versioninfo = nativeGetVersion().Split(new Char[] {'.',' '});
                                
                BCLDebug.Assert(versioninfo.Length>=4,"versioninfo.Length>=4");
                return new Version(Int32.Parse(versioninfo[0], CultureInfo.InvariantCulture),
                                    Int32.Parse(versioninfo[1], CultureInfo.InvariantCulture),
                                    Int32.Parse(versioninfo[2], CultureInfo.InvariantCulture),
                                    Int32.Parse(versioninfo[3], CultureInfo.InvariantCulture));
            }
        }

        
        /*==================================WorkingSet==================================
        **Action:
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern long nativeGetWorkingSet();
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.WorkingSet"]/*' />
        public static long WorkingSet {
            get {
                new EnvironmentPermission(PermissionState.Unrestricted).Demand();
                return (long)nativeGetWorkingSet();
            }
        }

        
        /*==================================OSVersion===================================
        **Action:
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.OSVersion"]/*' />
        public static OperatingSystem OSVersion {
            get {
                if (m_os==null) { // We avoid the lock since we don't care if two threads will set this at the same time.
                            Microsoft.Win32.Win32Native.OSVERSIONINFO osvi = new Microsoft.Win32.Win32Native.OSVERSIONINFO();
                            bool r = Win32Native.GetVersionEx(osvi);
                            if (!r) {
                                int hr = Marshal.GetLastWin32Error();
                                BCLDebug.Assert(r, "OSVersion's call to GetVersionEx failed.  HR: 0x"+hr.ToString("X")+"  Mail BrianGru the HR & what OS you're using (Whistler Beta 1?)");
                                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_GetVersion"));
                            }
                            PlatformID id;
                            switch (osvi.PlatformId) {
                            case Win32Native.VER_PLATFORM_WIN32_NT:
                                id = PlatformID.Win32NT;
                                break;

                            case Win32Native.VER_PLATFORM_WIN32_WINDOWS:
                                id = PlatformID.Win32Windows;
                                break;
                                
                            case Win32Native.VER_PLATFORM_WIN32s:
                                id = PlatformID.Win32S;
                                break;
                                
                            case Win32Native.VER_PLATFORM_WINCE:
                                id = PlatformID.WinCE;
                                break;

                            default:
                                BCLDebug.Assert(false, "false");
                                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_InvalidPlatformID"));
                            }
                            
                    Version v = new Version(osvi.MajorVersion, osvi.MinorVersion, osvi.BuildNumber, 0);
                    m_os = new OperatingSystem(id, v);
                }
                BCLDebug.Assert(m_os != null, "m_os != null");
                return m_os;
            }
        }


        [Serializable]
        internal enum OSName
        {
            Invalid = 0,
            Unknown = 1,
            Win9x = 0x40,
            Win95 = 1 | Win9x, 
            Win98 = 2 | Win9x,
            WinMe = 3 | Win9x,
            WinNT = 0x80,
            Nt4   = 1 | WinNT,
            Win2k   = 2 | WinNT 
        }

        internal static OSName OSInfo
        {
            get
            {
                if (m_osname == OSName.Invalid) 
                {
                    lock(typeof(Environment)) 
                    {
                        if (m_osname == OSName.Invalid) 
                        {
                            Microsoft.Win32.Win32Native.OSVERSIONINFO osvi = new Microsoft.Win32.Win32Native.OSVERSIONINFO();
                            bool r = Win32Native.GetVersionEx(osvi);
                            if (!r)
                            {
                                BCLDebug.Assert(r, "OSVersion native call failed.");
                                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_GetVersion"));
                            }
                            switch (osvi.PlatformId) 
                                {
                                case Win32Native.VER_PLATFORM_WIN32_NT:
                                    switch(osvi.MajorVersion) 
                                    {
                                        case 5:
                                            m_osname = OSName.Win2k;
                                            break;
                                        case 4:
                                            m_osname = OSName.Nt4;
                                            break;
                                        default:
                                            m_osname = OSName.WinNT;
                                            break;
                                    }
                                    break;
                                
                                case Win32Native.VER_PLATFORM_WIN32_WINDOWS:
                                    switch(osvi.MajorVersion) 
                                    {
                                        case 5:
                                            m_osname = OSName.WinMe;
                                            break;
                                        case 4:
                                            if (osvi.MinorVersion == 0)
                                                m_osname = OSName.Win95;
                                            else
                                                m_osname = OSName.Win98;
                                            break;
                                        default:
                                            m_osname = OSName.Win9x;
                                            break;
                                   }
                                   break;  

                                default:
                                    m_osname = OSName.Unknown; // Unknown OS
                                    break;
                                
                            }
                        }
                    }
                }
                return m_osname;
            }
        }

        
        /*==================================StackTrace==================================
        **Action:
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.StackTrace"]/*' />
        public static String StackTrace {
            get {
                new EnvironmentPermission(PermissionState.Unrestricted).Demand();
                return GetStackTrace(null);
            }
        }

        [ReflectionPermissionAttribute(SecurityAction.Assert, TypeInformation=true)]
        internal static String GetStackTrace(Exception e)
        {
            StackTrace st;
            if (e == null)
                st = new StackTrace(true);
            else
                st = new StackTrace(e,true);
            String newLine = Environment.NewLine;
            StringBuilder sb = new StringBuilder(255);
    
            for (int i = 0; i < st.FrameCount; i++)
            {
                StackFrame sf = st.GetFrame(i);
 
                sb.Append("   at ");
            
                MethodBase method = sf.GetMethod();
                Type t = method.DeclaringType;
                if (t != null)
                {
                    String nameSpace = t.Namespace;
                    if (nameSpace != null)
                    {
                        sb.Append(nameSpace);
                        if (sb != null)
                            sb.Append(".");
                    }

                    sb.Append(t.Name);
                    sb.Append(".");
                }
                sb.Append(method.Name);
                sb.Append("(");

                ParameterInfo[] arrParams = method.GetParameters();

                for (int j = 0; j < arrParams.Length; j++) 
                {
                    String typeName = "<UnknownType>";
                    if (arrParams[j].ParameterType != null)
                        typeName = arrParams[j].ParameterType.Name;

                    sb.Append((j != 0 ? ", " : "") + typeName + " " + arrParams[j].Name);
                }

                sb.Append(")");
         
                if (sf.GetILOffset() != -1)
                {
                    // It's possible we have a debug version of an executable but no PDB.  In
                    // this case, the file name will be null.
                    String fileName = null;
                    
                    try
                    {
                        fileName = sf.GetFileName();
                    }
                    catch (SecurityException)
                    {
                    }

                    if (fileName != null)
                        sb.Append(" in " + fileName + ":line " + sf.GetFileLineNumber());
                }
            
                if (i != st.FrameCount - 1)                 
                    sb.Append(newLine);
            }
            return sb.ToString();
        }

        private static ResourceManager InitResourceManager()
        {
            if (SystemResMgr == null) {
                lock(typeof(Environment)) {
                    if (SystemResMgr == null) {
                        // Do not reorder these two field assignments.
                        m_resMgrLockObject = new Object();
                        SystemResMgr = new ResourceManager("mscorlib", typeof(String).Assembly);
                    }
                }
            }
            return SystemResMgr;
        }
        
        // This should ideally become visible only within mscorlib's Assembly.
        // 
        // Looks up the resource string value for key.
        // 
        internal static String GetResourceString(String key)
        {
            if (SystemResMgr == null)
                InitResourceManager();
            String s;
            // We unfortunately have a somewhat common potential for infinite 
            // loops with mscorlib's ResourceManager.  If "potentially dangerous"
            // code throws an exception, we will get into an infinite loop
            // inside the ResourceManager and this "potentially dangerous" code.
            // Potentially dangerous code includes the IO package, CultureInfo,
            // parts of the loader, some parts of Reflection, Security (including 
            // custom user-written permissions that may parse an XML file at
            // class load time), assembly load event handlers, etc.  Essentially,
            // this is not a bounded set of code, and we need to fix the problem.
            // Fortunately, this is limited to mscorlib's error lookups and is NOT
            // a general problem for all user code using the ResourceManager.
            
            // The solution is to make sure only one thread at a time can call 
            // GetResourceString.  If the same thread comes into GetResourceString
            // twice before returning, we're going into an infinite loop and we
            // should return a bogus string.  -- BrianGru, 6/26/2001
            // @TODO: This is a quick & easy solution, but may not be optimal.
            // Note: typeof(Environment) is used elsewhere - don't lock on it.
            lock(m_resMgrLockObject) {
                if (m_loadingResource) {
                    // This may be bad, depending on how it happens.
                    BCLDebug.Correctness(false, "Infinite recursion during resource lookup.  Resource name: "+key);
                    return "[Resource lookup failed - infinite recursion detected.  Resource name: "+key+']';
                }
                m_loadingResource = true;
                s = SystemResMgr.GetString(key, null);
                m_loadingResource = false;
            }
            BCLDebug.Assert(s!=null, "Managed resource string lookup failed.  Was your resource name misspelled?  Did you rebuild mscorlib after adding a resource to resources.txt?  Debug this w/ cordbg and bug whoever owns the code that called Environment.GetResourceString.  Resource name was: \""+key+"\"");
            return s;
        }

        internal static String GetResourceString(String key, params Object[]values)
        {
            if (SystemResMgr == null)
                InitResourceManager();
            String s;
            // We unfortunately have a somewhat common potential for infinite 
            // loops with mscorlib's ResourceManager.  If "potentially dangerous"
            // code throws an exception, we will get into an infinite loop
            // inside the ResourceManager and this "potentially dangerous" code.
            // Potentially dangerous code includes the IO package, CultureInfo,
            // parts of the loader, some parts of Reflection, Security (including 
            // custom user-written permissions that may parse an XML file at
            // class load time), assembly load event handlers, etc.  Essentially,
            // this is not a bounded set of code, and we need to fix the problem.
            // Fortunately, this is limited to mscorlib's error lookups and is NOT
            // a general problem for all user code using the ResourceManager.
            
            // The solution is to make sure only one thread at a time can call 
            // GetResourceString.  If the same thread comes into GetResourceString
            // twice before returning, we're going into an infinite loop and we
            // should return a bogus string.  -- BrianGru, 6/26/2001
            // @TODO: This is a quick & easy solution, but may not be optimal.
            // Note: typeof(Environment) is used elsewhere - don't lock on it.
            lock(m_resMgrLockObject) {
                if (m_loadingResource)
                    return "[Resource lookup failed - infinite recursion detected.  Resource name: "+key+']';
                m_loadingResource = true;
                s = SystemResMgr.GetString(key, null);
                m_loadingResource = false;
            }
            BCLDebug.Assert(s!=null, "Managed resource string lookup failed.  Was your resource name misspelled?  Did you rebuild mscorlib after adding a resource to resources.txt?  Debug this w/ cordbg and bug whoever owns the code that called Environment.GetResourceString.  Resource name was: \""+key+"\"");
            return String.Format(s, values);
        }

        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.HasShutdownStarted"]/*' />
        public static bool HasShutdownStarted {
            get { return nativeHasShutdownStarted(); }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool nativeHasShutdownStarted();

        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.UserName"]/*' />
        public static string UserName {
            get {
                new EnvironmentPermission(EnvironmentPermissionAccess.Read,"UserName").Demand();

                StringBuilder sb = new StringBuilder(256);
                Win32Native.GetUserName(sb, new int[] {sb.Capacity});
                return sb.ToString();
            }
        }

        private static IntPtr processWinStation;        // Doesn't need to be initialized as they're zero-init.
        private static bool isUserInteractive = true;   

        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.UserInteractive"]/*' />
        public static bool UserInteractive {
            get {
                if ((OSInfo & OSName.WinNT) == OSName.WinNT) { // On WinNT
                    IntPtr hwinsta = Win32Native.GetProcessWindowStation();
                    if (hwinsta != IntPtr.Zero && processWinStation != hwinsta) {
                        int lengthNeeded = 0;
                        Win32Native.USEROBJECTFLAGS flags = new Win32Native.USEROBJECTFLAGS();
                        if (Win32Native.GetUserObjectInformation(hwinsta, Win32Native.UOI_FLAGS, flags, Marshal.SizeOf(flags),ref lengthNeeded)) {
                            if ((flags.dwFlags & Win32Native.WSF_VISIBLE) == 0) {
                                isUserInteractive = false;
                            }
                        }
                        processWinStation = hwinsta;
                    }
                }
                return isUserInteractive;
            }
        }

        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.GetFolderPath"]/*' />
        public static string GetFolderPath(SpecialFolder folder) {
            if (!Enum.IsDefined(typeof(SpecialFolder),folder))
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)folder));
            StringBuilder sb = new StringBuilder(Path.MAX_PATH);
            Win32Native.SHGetFolderPath(IntPtr.Zero, (int) folder, IntPtr.Zero, Win32Native.SHGFP_TYPE_CURRENT, sb);
            String s =  sb.ToString();
            new FileIOPermission( FileIOPermissionAccess.PathDiscovery, s ).Demand();
            return s;
        }
        
        /// <include file='doc\Environment.uex' path='docs/doc[@for="Environment.UserDomainName"]/*' />
        public static string UserDomainName {
                get {
                    new EnvironmentPermission(EnvironmentPermissionAccess.Read,"UserDomainName").Demand();

                    byte[] sid = new byte[1024];
                    int sidLen = sid.Length;
                    StringBuilder domainName = new StringBuilder(1024);
                    int domainNameLen = domainName.Capacity;
                    int peUse;

                    // Note: This doesn't work on Win9x.  We can implement this
                    // functionality on Win9x by writing a 16 bit DLL and 
                    // calling the LAN Manager method NetWkstaGetInfo().  See
                    // http://support.microsoft.com/support/kb/articles/Q155/6/98.asp
                    // We don't have the time to implement this in V1. Hopefully
                    // by the time V2 rolls around, everyone will run Windows XP.
                    bool success = Win32Native.LookupAccountName(null, UserName, sid, ref sidLen, domainName, ref domainNameLen, out peUse);
                    if (!success)  {
                        int hr = Marshal.GetLastWin32Error();
                        if (hr == Win32Native.ERROR_CALL_NOT_IMPLEMENTED)
                            throw new PlatformNotSupportedException(Environment.GetResourceString("PlatformNotSupported_Win9x"));
                        throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_UserDomainName"));
                    }

                    return domainName.ToString();
                }
            }

        
        /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder"]/*' />
        public enum SpecialFolder {
            //  
            //      Represents the file system directory that serves as a common repository for
            //       application-specific data for the current, roaming user. 
            //     A roaming user works on more than one computer on a network. A roaming user's 
            //       profile is kept on a server on the network and is loaded onto a system when the
            //       user logs on. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.ApplicationData"]/*' />
            ApplicationData =  Win32Native.CSIDL_APPDATA,
            //  
            //      Represents the file system directory that serves as a common repository for application-specific data that
            //       is used by all users. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.CommonApplicationData"]/*' />
            CommonApplicationData =  Win32Native.CSIDL_COMMON_APPDATA,
            //  
            //     Represents the file system directory that serves as a common repository for application specific data that
            //       is used by the current, non-roaming user. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.LocalApplicationData"]/*' />
            LocalApplicationData =  Win32Native.CSIDL_LOCAL_APPDATA,
            //  
            //     Represents the file system directory that serves as a common repository for Internet
            //       cookies. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.Cookies"]/*' />
            Cookies =  Win32Native.CSIDL_COOKIES,
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.Desktop"]/*' />
            Desktop = Win32Native.CSIDL_DESKTOP,
            //  
            //     Represents the file system directory that serves as a common repository for the user's
            //       favorite items. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.Favorites"]/*' />
            Favorites =  Win32Native.CSIDL_FAVORITES,
            //  
            //     Represents the file system directory that serves as a common repository for Internet
            //       history items. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.History"]/*' />
            History =  Win32Native.CSIDL_HISTORY,
            //  
            //     Represents the file system directory that serves as a common repository for temporary 
            //       Internet files. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.InternetCache"]/*' />
            InternetCache =  Win32Native.CSIDL_INTERNET_CACHE,
            //  
            //      Represents the file system directory that contains
            //       the user's program groups. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.Programs"]/*' />
            Programs =  Win32Native.CSIDL_PROGRAMS,
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.MyComputer"]/*' />
            MyComputer =  Win32Native.CSIDL_DRIVES,
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.MyMusic"]/*' />
            MyMusic =  Win32Native.CSIDL_MYMUSIC,
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.MyPictures"]/*' />
            MyPictures = Win32Native.CSIDL_MYPICTURES,
            //  
            //     Represents the file system directory that contains the user's most recently used
            //       documents. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.Recent"]/*' />
            Recent =  Win32Native.CSIDL_RECENT,
            //  
            //     Represents the file system directory that contains Send To menu items. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.SendTo"]/*' />
            SendTo =  Win32Native.CSIDL_SENDTO,
            //  
            //     Represents the file system directory that contains the Start menu items. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.StartMenu"]/*' />
            StartMenu =  Win32Native.CSIDL_STARTMENU,
            //  
            //     Represents the file system directory that corresponds to the user's Startup program group. The system
            //       starts these programs whenever any user logs on to Windows NT, or
            //       starts Windows 95 or Windows 98. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.Startup"]/*' />
            Startup =  Win32Native.CSIDL_STARTUP,
            //  
            //     System directory.
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.System"]/*' />
            System =  Win32Native.CSIDL_SYSTEM,
            //  
            //     Represents the file system directory that serves as a common repository for document
            //       templates. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.Templates"]/*' />
            Templates =  Win32Native.CSIDL_TEMPLATES,
            //  
            //     Represents the file system directory used to physically store file objects on the desktop.
            //       This should not be confused with the desktop folder itself, which is
            //       a virtual folder. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.DesktopDirectory"]/*' />
            DesktopDirectory =  Win32Native.CSIDL_DESKTOPDIRECTORY,
            //  
            //     Represents the file system directory that serves as a common repository for documents. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.Personal"]/*' />
            Personal =  Win32Native.CSIDL_PERSONAL,
            //  
            //     Represents the program files folder. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.ProgramFiles"]/*' />
            ProgramFiles =  Win32Native.CSIDL_PROGRAM_FILES,
            //  
            //     Represents the folder for components that are shared across applications. 
            //  
            /// <include file='doc\Environment.uex' path='docs/doc[@for="SpecialFolder.CommonProgramFiles"]/*' />
            CommonProgramFiles =  Win32Native.CSIDL_PROGRAM_FILES_COMMON,
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\flagsattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace System {
    
	using System;
    // Custom attribute to indicate that the enum
    // should be treated as a bitfield (or set of flags).
    // An IDE may use this information to provide a richer
    // development experience.
	/// <include file='doc\FlagsAttribute.uex' path='docs/doc[@for="FlagsAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Enum, Inherited = false),Serializable] 
	public class  FlagsAttribute : Attribute
    {
    	/// <include file='doc\FlagsAttribute.uex' path='docs/doc[@for="FlagsAttribute.FlagsAttribute"]/*' />
    	public FlagsAttribute()
    	{
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\executionengineexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ExecutionEngineException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: The exception class for misc execution engine exceptions.
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {

	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\ExecutionEngineException.uex' path='docs/doc[@for="ExecutionEngineException"]/*' />
    [Serializable()] public sealed class ExecutionEngineException : SystemException {
        /// <include file='doc\ExecutionEngineException.uex' path='docs/doc[@for="ExecutionEngineException.ExecutionEngineException"]/*' />
        public ExecutionEngineException() 
            : base(Environment.GetResourceString("Arg_ExecutionEngineException")) {
    		SetErrorCode(__HResults.COR_E_EXECUTIONENGINE);
        }
    
        /// <include file='doc\ExecutionEngineException.uex' path='docs/doc[@for="ExecutionEngineException.ExecutionEngineException1"]/*' />
        public ExecutionEngineException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_EXECUTIONENGINE);
        }
    
        /// <include file='doc\ExecutionEngineException.uex' path='docs/doc[@for="ExecutionEngineException.ExecutionEngineException2"]/*' />
        public ExecutionEngineException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_EXECUTIONENGINE);
        }

        internal ExecutionEngineException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\formatexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  FormatException
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Exception to designate an illegal argument to FormatMessage.
**
** Date:  February 10, 1998
** 
===========================================================*/
namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\FormatException.uex' path='docs/doc[@for="FormatException"]/*' />
    [Serializable()] public class FormatException : SystemException {
        /// <include file='doc\FormatException.uex' path='docs/doc[@for="FormatException.FormatException"]/*' />
        public FormatException() 
            : base(Environment.GetResourceString("Arg_FormatException")) {
    		SetErrorCode(__HResults.COR_E_FORMAT);
        }
    
        /// <include file='doc\FormatException.uex' path='docs/doc[@for="FormatException.FormatException1"]/*' />
        public FormatException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_FORMAT);
        }
    	
        /// <include file='doc\FormatException.uex' path='docs/doc[@for="FormatException.FormatException2"]/*' />
        public FormatException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_FORMAT);
        }

        /// <include file='doc\FormatException.uex' path='docs/doc[@for="FormatException.FormatException3"]/*' />
        protected FormatException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\enum.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:   Enum
**
** Author:  Rajesh Chandrashekaran (rajeshc)
**
** Purpose: Base class for all enumerated types.
**          Added code for all Enum methods (rajeshc)
** Date:    January 4, 2000
**          Feb 2, 2000
===========================================================*/
namespace System {
    using System.Reflection;
    using System.Text;
    using System.Collections;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Reflection.Emit;
        
    /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum"]/*' />
    [Serializable]
    public abstract class Enum : ValueType, IComparable, IFormattable, IConvertible
    {

        // valueName contains the name of the internal enum value and is defined in ValueType
        private static char [] enumSeperatorCharArray = new char [] {','};
        private const String enumSeperator = ", "; 
		private static Type intType = typeof(int);
		private static Type stringType = typeof(String);

        // Maintains a hashtable that cache's HashEntry's which is a tuple of an array of fieldinfo's and ulong values for perf reasons.
        // We throw away the elements of the Hastable once it hash more than maxHashElements enum types.
        private static Hashtable fieldInfoHash = Hashtable.Synchronized(new Hashtable());
        private const int maxHashElements = 100; // to trim the working set


        private static FieldInfo GetField(Type type, String valueName)
        {
            FieldInfo fld = type.GetField(valueName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
            if (fld == null)
                throw new ArgumentException(Environment.GetResourceString("Arg_EnumMustHaveUnderlyingValueField"));
            return fld;
        }

        private static FieldInfo GetValueField(Type type)
        {
		    FieldInfo[] flds;

		    if (type is RuntimeType)
	        	flds = ((RuntimeType)type).InternalGetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic,false);
	        else
	        	flds = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

		    if ((flds == null) || (flds.Length != 1))
				throw new ArgumentException(Environment.GetResourceString("Arg_EnumMustHaveUnderlyingValueField"));
	            
		    return flds[0];
        }
        
        // Each entry contains a list of sorted pair of enum field names and values, sorted by values
        private class HashEntry
        {
            public HashEntry(String [] names, ulong [] values)
            {
                this.names = names;
                this.values = values;
            }

            public String[] names;
            public ulong [] values;
        }

        private static HashEntry GetHashEntry(Type enumType)
        {
            HashEntry hashEntry = (HashEntry)fieldInfoHash[enumType];
            if (hashEntry == null)
            {
                // To reduce the workingset we dump the hashtable when a threshold number of elements are inserted.
                if (fieldInfoHash.Count > maxHashElements)
                    fieldInfoHash.Clear();

                ulong [] values = null;
                String [] names = null;

                BCLDebug.Assert(enumType.BaseType == typeof(Enum),"Base type must of type Enum");
                if (enumType.BaseType == typeof(Enum))
                    InternalGetEnumValues(enumType, ref values, ref names);
				// if we switch over to EnumBuilder then my guess is this code path will be required.
                else
                {
                    // fall back on reflection for odd cases
                    FieldInfo [] flds;  
                    if (enumType is RuntimeType)
                      flds = ((RuntimeType)enumType).InternalGetFields(BindingFlags.Static | BindingFlags.Public,false);
                    else
                      flds = enumType.GetFields(BindingFlags.Static | BindingFlags.Public);

                    values = new ulong[flds.Length];
                    names = new String[flds.Length];
                    for (int i = 0;i<flds.Length;i++)
                    {
                        names[i] = flds[i].Name;
                        values[i] = ToUInt64(flds[i].GetValue(null));
                    }
                
                    // Insertion Sort these values in ascending order.
                    // We use this O(n^2) algorithm, but it turns out that most of the time the elements are already in sorted order and
                    // the common case performance will be faster than quick sorting this.

                    for (int i = 1; i < values.Length; i++)
                    {
                        int j = i;
                        String tempStr = names[i];
                        ulong val = values[i];
                        bool exchanged = false;

                        // Since the elements are sorted we only need to do one comparision, we keep the check for j inside the loop.
                        while (values[j-1] > val)
                        {
                            names[j] = names[j-1];
                            values[j] = values[j-1];
                            j--;
                            exchanged = true;
                            if (j == 0) 
                                break;
                        }

                        if (exchanged)
                        {
                            names[j] = tempStr;
                            values[j] = val;
                        }
                    }
                }

                hashEntry = new HashEntry(names,values);
                fieldInfoHash[enumType] = hashEntry;
            }
            
            return hashEntry;
            
        }

        // This method will return the Enum value for a field defined
        //  in the enum with a name of value.
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.Parse"]/*' />
        public static Object Parse(Type enumType, String value)
        {
            return Parse(enumType, value, false);
        }
         
        // This method will return the Enum value for an field defined
        //  in the enum with a name of value ignoring the case
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.Parse1"]/*' />
        public static Object Parse(Type enumType, String value, bool ignoreCase)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");

            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");

            if (value == null)
                throw new ArgumentNullException("value");

            value = value.Trim();
            if (value.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustContainEnumInfo"));


            // We have 2 code paths here. One if they are values else if they are Strings.
            // values will have the first character as as number or a sign.
        
            ulong result = 0;
            if (Char.IsDigit(value[0]) || value[0] == '-' || value[0] == '+')
            {
                Type underlyingType = GetUnderlyingType(enumType);
				Object temp;
				try {
					temp = Convert.ChangeType(value, underlyingType, CultureInfo.InvariantCulture);
					return ToObject(enumType,temp);
				}
				catch (FormatException) { // We need to Parse this a String instead. There are cases
										// when you tlbimp enums that can have values of the form "3D".
										// Don't fix this code.
				}
            }
            
            String [] values = value.Split(enumSeperatorCharArray);
                                                
            // Find the field.Lets assume that these are always static classes because the class is 
            //  an enum.
            HashEntry hashEntry = GetHashEntry(enumType);
            String[] names = hashEntry.names;
                                    
            for (int i = 0; i<values.Length;i++)
            {
                values[i] = values[i].Trim(); // We need to remove whitespace characters
                bool success = false;
                for (int j = 0;j<names.Length;j++)
                {
                    if (ignoreCase)
                    {
                        if (String.Compare(names[j], values[i], true, CultureInfo.InvariantCulture) != 0)
                            continue;
                    }
                    else
                    {
                        if (!names[j].Equals(values[i]))
                            continue;
                    }

                    ulong item = hashEntry.values[j];
                    result |= item;
                    success = true;
                    break;
                    
                }

                if (!success)
                    // Not found, throw an argument exception.
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumValueNotFound"),value));
            }

            return ToObject(enumType,result);
         }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.Equals"]/*' />
        public override bool Equals(Object obj)
        {
            Enum that = obj as Enum;
            if (that == null || this.GetType() != obj.GetType())
                return false;
            return this.GetValue().Equals(that.GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return GetValue().GetHashCode();
        }

        private Object GetValue()
        {
            return InternalGetValue();
        }

         // Returns the underlying type of the Enum
         /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.GetUnderlyingType"]/*' />
         public static Type GetUnderlyingType(Type enumType)
         {      
            if (enumType == null)
                throw new ArgumentNullException("enumType");

            // Make this function working for EnumBuilder. Hack for the JScript folks. 
            if (enumType is EnumBuilder)
            {
                return ((EnumBuilder) enumType).UnderlyingSystemType;
            }
                                           
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");

            return InternalGetUnderlyingType(enumType);
          }
         
         
        // GetValues returns all the values defined in the enum.
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.GetValues"]/*' />
        public static Array GetValues(Type enumType)
        {   
            if (enumType == null)
                throw new ArgumentNullException("enumType");

            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
        
            // Get all of the values
            ulong[] values = GetHashEntry(enumType).values;
            
            // Create a generic Array
            Array ret = Array.CreateInstance(enumType, values.Length);
            
            for (int i=0;i<values.Length;i++) {
                Object val = ToObject(enumType,values[i]);
                ret.SetValue(val,i);
            }
            return ret;
        }

    
        // Returns the name of the particular value passed in. If there's no match you get back a null.
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.GetName"]/*' />
        public static String GetName(Type enumType, Object value)
        {   
            if (enumType == null)
                throw new ArgumentNullException("enumType");

            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            

            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");

            if (value == null)
                throw new ArgumentNullException("value");

			Type valueType = value.GetType();
			if (valueType.IsEnum || valueType == intType || valueType == typeof(short) ||
                valueType == typeof(ushort) || valueType == typeof(byte) || valueType == typeof(sbyte) ||
                valueType == typeof(uint) || valueType == typeof(long) || valueType == typeof(ulong)) 
				        return InternalGetValueAsString(enumType,value);
			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnumBaseTypeOrEnum"),"value");

        }

        // Returns the names of the enum fields
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.GetNames"]/*' />
        public static String[] GetNames(Type enumType)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");

            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            

            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
        
            // Get all of the Field names
            String[] ret = GetHashEntry(enumType).names;
                
            // Make a copy since we can't hand out the same array since users can modify them
            String[] retVal = new String[ret.Length];
            Array.Copy(ret,retVal,ret.Length);

            return retVal;
        }

        // value can be one of the base data types - int,sbyte,short,long,uint,byte,ushort,ulong
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject"]/*' />
        public static Object ToObject(Type enumType, Object value)
        {
            if (value == null)
                throw new ArgumentNullException("value");

            // Delegate rest of error checking to the other functions
            TypeCode typeCode = Convert.GetTypeCode(value);
                            
            switch(typeCode)
            {
                case TypeCode.Int32:
                    return ToObject(enumType, (int)value);
                case TypeCode.SByte:
                    return ToObject(enumType, (sbyte)value);
                case TypeCode.Int16:
                    return ToObject(enumType, (short)value);
                case TypeCode.Int64:
                    return ToObject(enumType, (long)value);
                case TypeCode.UInt32:
                    return ToObject(enumType, (uint)value);
                case TypeCode.Byte:
                    return ToObject(enumType, (byte)value);
                case TypeCode.UInt16:
                    return ToObject(enumType, (ushort)value);
                case TypeCode.UInt64:   
                    return ToObject(enumType, (ulong)value);
                    
                default:
                    // All unsigned types will be directly cast               
                    throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnumBaseTypeOrEnum"),"value");
            }
        }
         
         // IsDefined checks to see if the value stored in the object value is
        //  a legal value for the Enum. The values must be of the same type as the
        // underlying enum
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IsDefined"]/*' />
        public static bool IsDefined(Type enumType,Object value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");

            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
        
            if (value == null)
                throw new ArgumentNullException("value");

            // Check if both of them are of the same type
            Type valueType = value.GetType();
             if (!(valueType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"valueType");
            
            Type underlyingType = GetUnderlyingType(enumType);
            
            // If the value is an Enum then we need to extract the underlying value from it
            if (valueType.IsEnum)
            {
                Type valueUnderlyingType = GetUnderlyingType(valueType);
                if (valueType != enumType)
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumAndObjectMustBeSameType"),
                        valueType.ToString(),enumType.ToString()));
                valueType = valueUnderlyingType;
            }
            else
            // The value must be of the same type as the Underlying type of the Enum
            if ( (valueType != underlyingType) && (valueType != stringType))
            {
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumUnderlyingTypeAndObjectMustBeSameType"),
                        valueType.ToString(),underlyingType.ToString()));
            }
        

            // If String is passed in
            if ( valueType == stringType)
            {
                // Get all of the Fields
                String[] names = GetHashEntry(enumType).names;
                for (int i = 0;i<names.Length;i++)
                    if (names[i].Equals((string)value))
                        return true;
                return false;
            }

            ulong [] values = GetHashEntry(enumType).values;

            // Look at the 8 possible enum base classes     
            if (valueType == intType || valueType == typeof(short) ||
                valueType == typeof(ushort) || valueType == typeof(byte) || valueType == typeof(sbyte) ||
                valueType == typeof(uint) || valueType == typeof(long) || valueType == typeof(ulong)) 
            {
                ulong val = ToUInt64(value);
                return (BinarySearch(values,val) >= 0);
            }
                                        
            BCLDebug.Assert(false,"Unknown enum type");
            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_UnknownEnumType"));
        }
         
         // Compares this enum and the object. The have to be of the same type or a ArgumentException is thrown
         // Returns 0 if equal, -1 if less than, or 1 greater then the target
         /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.CompareTo"]/*' />
         public int CompareTo(Object target)
         {
            // Validate the parameters
            if (target == null)
                return 1;
            // Check if both of them are of the same type
            Type thisType = this.GetType();
            Type targetType = target.GetType();

            if ( thisType != targetType)
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumAndObjectMustBeSameType"),
                    targetType.ToString(),thisType.ToString()));

            FieldInfo thisField = GetValueField(thisType);
            FieldInfo targetField = GetValueField(targetType);
            
            // Retrieve the value from the field.
            Object thisResult = ((RuntimeFieldInfo)thisField).InternalGetValue(this,false);
            Object targetResult = ((RuntimeFieldInfo)targetField).InternalGetValue(target,false);

            TypeCode typeCode = this.GetTypeCode();
            
            switch(typeCode)
            {
                case TypeCode.Int32:
                case TypeCode.SByte:
                case TypeCode.Int16:
                case TypeCode.Int64:
                {
                        Int64 result = Convert.ToInt64(thisResult);
                        Int64 compareTo = Convert.ToInt64(targetResult);
                        if (result == compareTo)
                            return 0;
                        if (result < compareTo)
                            return -1;
                        else
                            return 1;
                }
                
                case TypeCode.UInt32:
                case TypeCode.Byte:
                case TypeCode.UInt16:
                case TypeCode.UInt64:
                {
                        UInt64 result = Convert.ToUInt64(thisResult);
                        UInt64 compareTo = Convert.ToUInt64(targetResult);
                        if (result == compareTo)
                            return 0;
                        if (result < compareTo)
                            return -1;
                        else
                            return 1;
                }
                
                default:
                    BCLDebug.Assert(false,"Invalid switch case for CompareTo function");
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_UnknownEnumType"));
            }
                        
         }
        
         
          
            // Internal function that return the enum names given the values
        // eg. If Red = 1 and you pass a 1 you get back "Red".
        private static String InternalGetValueAsString(Type enumType,Object value)
        {           
            //Don't ask for the private fields.  Only .value is private and we don't need that.
            HashEntry hashEntry = GetHashEntry(enumType);

            Type eT = GetUnderlyingType(enumType);

            // Lets break this up based upon the size.  We'll do part as an 64bit value
            //  and part as the 32bit values.
            if (eT == intType || eT == typeof(short) || eT == typeof(long) ||
                eT == typeof(ushort) || eT == typeof(byte) || eT == typeof(sbyte) ||
                    eT == typeof(uint) || eT == typeof(ulong))
             {
                    ulong val = ToUInt64(value);
                    int index = BinarySearch(hashEntry.values,val);
                    if (index >=0)
                        return hashEntry.names[index];
             }  
              
             return null;
        }

        private static String InternalFormattedHexString(Object value)
        {
           TypeCode typeCode = Convert.GetTypeCode(value);

           switch (typeCode)
           {
                case TypeCode.SByte:
                {
                    Byte result = (byte) (sbyte)value;
                    return result.ToString("X2",null);
                }
                                    
                case TypeCode.Byte:
                {
                    Byte result = (byte)value;
                    return result.ToString("X2",null);
                }
                
                case TypeCode.Int16:
                {
                    UInt16 result = (UInt16)(Int16)value;
                    return result.ToString("X4",null);
                }
                
                case TypeCode.UInt16:
                {
                    UInt16 result = (UInt16)value;
                    return result.ToString("X4",null);
                }
                
                case TypeCode.UInt32:
                {
                    UInt32 result = (UInt32)value;
                    return result.ToString("X8",null);
                }
                
                case TypeCode.Int32:
                {
                    UInt32 result = (UInt32)(int)value;
                    return result.ToString("X8",null);
                }
                
                case TypeCode.UInt64:                                           
                {
                    UInt64 result = (UInt64)value;
                    return result.ToString("X16",null);
                }

                
                case TypeCode.Int64:                                            
                {
                    UInt64 result = (UInt64)(Int64)value;
                    return result.ToString("X16",null);
                }
                
                
                // All unsigned types will be directly cast             
                default:
                    BCLDebug.Assert(false,"Invalid Object type in Format");
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_UnknownEnumType"));
            }
        
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.Format"]/*' />
        public static String Format(Type enumType,Object value,String format) 
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");

            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");

            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");

            if (value == null)
                throw new ArgumentNullException("value");

            if (format == null)
                throw new ArgumentNullException("format");

            // Check if both of them are of the same type
            Type valueType = value.GetType();
            if (!(valueType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"valueType");

            Type underlyingType = GetUnderlyingType(enumType);

            // If the value is an Enum then we need to extract the underlying value from it
            if (valueType.IsEnum)
            {
                Type valueUnderlyingType = GetUnderlyingType(valueType);
                if (valueType != enumType)
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumAndObjectMustBeSameType"),
                        valueType.ToString(),enumType.ToString()));
                valueType = valueUnderlyingType;
                value = ((Enum)value).GetValue();
            }
            // The value must be of the same type as the Underlying type of the Enum
            else if (valueType != underlyingType) 
            {
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType"),
                        valueType.ToString(),underlyingType.ToString()));
            }
            
            if (String.Compare(format,"D",true, CultureInfo.InvariantCulture) == 0)
                return value.ToString();
            
            if (String.Compare(format,"X",true, CultureInfo.InvariantCulture) == 0)
                    // Retrieve the value from the field.
                return  InternalFormattedHexString(value);

            if (String.Compare(format,"G",true, CultureInfo.InvariantCulture) == 0)
                return InternalFormat(enumType,value);
        
            if (String.Compare(format,"F",true, CultureInfo.InvariantCulture) == 0)
                return InternalFlagsFormat(enumType, value);
        
            throw new FormatException(Environment.GetResourceString("Format_InvalidEnumFormatSpecification"));
                
        }

        

        // Helper function to silently convert the value to UInt64 from the other base types for enum without throwing an exception.
        // This is need since the Convert functions do overflow checks.
        private static ulong ToUInt64(Object value)
        {
            TypeCode typeCode = Convert.GetTypeCode(value);
            ulong result;
                
            switch(typeCode)
            {
                case TypeCode.SByte:
                case TypeCode.Int16:
                case TypeCode.Int32:
                case TypeCode.Int64:
                      result = (UInt64)Convert.ToInt64(value);                
                      break;
            
                case TypeCode.Byte:
                case TypeCode.UInt16:
                case TypeCode.UInt32:
                case TypeCode.UInt64:   
                    result = Convert.ToUInt64(value);
                    break;

                default:
                  // All unsigned types will be directly cast               
                    BCLDebug.Assert(false,"Invalid Object type in ToUInt64");
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_UnknownEnumType"));
            }
            return result;
        }

        private static String InternalFormat(Type eT,Object value)
        {
            if (!eT.IsDefined(typeof(System.FlagsAttribute), false)) // Not marked with Flags attribute
            {
                // Try to see if its one of the enum values, then we return a String back else the value
                String retval = InternalGetValueAsString(eT,value);
                if (retval == null)
                    return value.ToString();
                else
                    return retval;
            }   
            else // These are flags OR'ed together (We treat everything as unsigned types)
            {
                return InternalFlagsFormat(eT,value);
                         
            }
        }

        private static String InternalFlagsFormat(Type eT,Object value)
        {
            ulong result = ToUInt64(value);
            HashEntry hashEntry = GetHashEntry(eT);
            // These values are sorted by value. Don't change this
            String [] names = hashEntry.names;
            ulong [] values = hashEntry.values;
            
            int index = values.Length - 1;
            StringBuilder retval = new StringBuilder();
            bool firstTime = true;
            ulong saveResult = result;
            
            // We will not optimize this code further to keep it maintainable. There are some boundary checks that can be applied
            // to minimize the comparsions required. This code works the same for the best/worst case. In general the number of
            // items in an enum are sufficiently small and not worth the optimization.
            while (index >= 0)
            {
                if ((index == 0) && (values[index] == 0))
                    break;

                if ((result & values[index]) == values[index])
                {
                    result -= values[index];
                    //@Consider: Consider a different way of concatening instead of inserting at the beginning
                    if (!firstTime)
                        retval.Insert(0,enumSeperator); 

                    retval.Insert(0,names[index]); 
                    firstTime = false;
                }

                index--;
            }   

            // We were unable to represent this number as a bitwise or of valid flags
            if (result != 0)
                return saveResult.ToString();

            // For the case when we have zero
            if (saveResult==0)
            {
                 if (values[0] == 0)
                    return names[0]; // Zero was one of the enum values.
                 else
                    return "0";
            }
            else
               return retval.ToString(); // Return the string representation
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToString"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToString1"]/*' />
        public String ToString(String format, IFormatProvider provider)
        {

            if (format == null || format == String.Empty)
                format = "G";

            if (String.Compare(format,"G",true, CultureInfo.InvariantCulture) == 0) {
                return ToString();
                //              return InternalFormat(this.GetType(), this.GetValue());
            }
            if (String.Compare(format,"D",true, CultureInfo.InvariantCulture) == 0)
                return this.GetValue().ToString();
            
            if (String.Compare(format,"X",true, CultureInfo.InvariantCulture) == 0)
                return this.ToHexString();

            if (String.Compare(format,"F",true, CultureInfo.InvariantCulture) == 0)
                return InternalFlagsFormat(this.GetType(), this.GetValue());
        
            throw new FormatException(Environment.GetResourceString("Format_InvalidEnumFormatSpecification"));
         
        }

        private String ToHexString()
        {
            Type eT = this.GetType();
            FieldInfo thisField = GetValueField(eT);
        
            // Retrieve the value from the field.
            return  InternalFormattedHexString(((RuntimeFieldInfo)thisField).InternalGetValue(this,false));
            
        }

		// Returns the value in a human readable format.  For PASCAL style enums who's value maps directly the name of the field is returned. 
        // For PASCAL style enums who's values do not map directly the decimal value of the field is returned.  
        // For BitFlags (indicated by the Flags custom attribute): If for each bit that is set in the value there is a corresponding constant 
        //(a pure power of 2), then the  OR string (ie "Red | Yellow") is returned. Otherwise, if the value is zero or if you can't create a string that consists of 
        // pure powers of 2 OR-ed together, you return a hex value
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToString2"]/*' />
        public override String ToString()
        {
            Type eT = this.GetType();
            FieldInfo thisField = GetValueField(eT);
            
            // Retrieve the value from the field.
            Object value = ((RuntimeFieldInfo)thisField).InternalGetValue(this, false);
            return InternalFormat(eT,value);
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToString3"]/*' />
        public String ToString(IFormatProvider provider)
        {
            return ToString();
        }
       

        // The following set of method will Box an underlying type
        //  into an Enum
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject1"]/*' />
        [CLSCompliant(false)]
        public static Object ToObject(Type enumType,sbyte value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
            return InternalBoxEnumI4(enumType,value);
        }
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject2"]/*' />
        public static Object ToObject(Type enumType,short value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
            return InternalBoxEnumI4(enumType,value);
        }
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject3"]/*' />
        public static Object ToObject(Type enumType,int value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
            return InternalBoxEnumI4(enumType,value);
        }
        
        // The unsigned integer types
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject4"]/*' />
        public static Object ToObject(Type enumType,byte value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
            return InternalBoxEnumU4(enumType,value);
        }
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject5"]/*' />
        [CLSCompliant(false)]
        public static Object ToObject(Type enumType,ushort value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
            return InternalBoxEnumU4(enumType,value);
        }
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject6"]/*' />
        [CLSCompliant(false)]
        public static Object ToObject(Type enumType,uint value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
            return InternalBoxEnumU4(enumType,value);
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject7"]/*' />
        public static Object ToObject(Type enumType,long value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
            return InternalBoxEnumI8(enumType,value);
        }
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.ToObject8"]/*' />
        [CLSCompliant(false)]
        public static Object ToObject(Type enumType,ulong value)
        {
            if (enumType == null)
                throw new ArgumentNullException("enumType");
            if (!(enumType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"enumType");
            if (!enumType.IsEnum)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
            return InternalBoxEnumU8(enumType,value);
        }

        //
        // IValue implementation
        // 
        
        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            Type enumType = this.GetType();
            Type underlyingType = GetUnderlyingType(enumType);

            if (underlyingType == typeof(Int32)) {
                return TypeCode.Int32;
            }


            if (underlyingType == typeof(sbyte)) {
                return TypeCode.SByte;
            }
            
            if (underlyingType == typeof(Int16)) {
                return TypeCode.Int16;
            }

            if (underlyingType == typeof(Int64)) {
                return TypeCode.Int64;
            }

            if (underlyingType == typeof(UInt32)) {
                return TypeCode.UInt32;
            }

            if (underlyingType == typeof(byte)) {
                return TypeCode.Byte;
            }

            
            if (underlyingType == typeof(UInt16)) {
                return TypeCode.UInt16;
            }
            
            
            if (underlyingType == typeof(UInt64)) {
                return TypeCode.UInt64;
            }

            BCLDebug.Assert(false,"Unknown underlying type.");
            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_UnknownEnumType"));
        }

        private static int BinarySearch(ulong[] array, ulong value) {
            int lo = 0;
            int hi = array.Length-1;
            while (lo <= hi) {
                int i = (lo + hi) >> 1;
                ulong temp = array[i];
                if (value == temp) return i;
                if (temp < value) {
                    lo = i + 1;
                }
                else {
                    hi = i - 1;
                }
            }
            return ~lo;
        }


        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(GetValue());
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Enum", "DateTime"));
        }

        /// <include file='doc\Enum.uex' path='docs/doc[@for="Enum.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static Type InternalGetUnderlyingType(Type enumType); 

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Object InternalGetValue(); 

        // Returns a list of all possible enum values
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static void InternalGetEnumValues(Type enumType, 
                                                         ref ulong[] values, ref String[] names);

        // The native helper routines are here based upon the integer type and size.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static Object InternalBoxEnumI4(Type enumType,int value);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static Object InternalBoxEnumU4(Type enumType,uint value);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static Object InternalBoxEnumI8(Type enumType,long value);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static Object InternalBoxEnumU8(Type enumType,ulong value);
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\gc.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  GC
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Exposes features of the Garbage Collector through
** the class libraries.  This is a class which cannot be
** instantiated.
**
** Date:  November 9, 1998
**
===========================================================*/
namespace System {
    //This class only static members and doesn't require the serializable keyword.

    using System;
    using System.Security.Permissions;
    using System.Reflection;
    using System.Security;
    using System.Threading;
    using System.Runtime.CompilerServices;
    using System.Reflection.Cache;

    /// <include file='doc\GC.uex' path='docs/doc[@for="GC"]/*' />
    public sealed class GC {
    
        // This class contains only static methods and cannot be instantiated.
        private GC() {
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int GetGenerationWR(int handle);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern long nativeGetTotalMemory();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nativeCollectGeneration(int generation);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int nativeGetMaxGeneration();
    
        // Returns the generation that obj is currently in.
        //
        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.GetGeneration"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int GetGeneration(Object obj);
    
        // Forces a collection of all generations from 0 through Generation.
        //
        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.Collect"]/*' />
        public static void Collect(int generation) {
            if (generation<0) {
                throw new ArgumentOutOfRangeException("generation", Environment.GetResourceString("ArgumentOutOfRange_GenericPositive"));
            }
            nativeCollectGeneration(generation);
        }
    
        // Garbage Collect all generations.
        //
        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.Collect1"]/*' />
        public static void Collect() {
            //-1 says to GC all generations.
            nativeCollectGeneration(-1);
        }

        
        // This method DOES NOT DO ANYTHING in and of itself.  It's used to 
        // prevent an object from losing any outstanding references a touch too
        // early.  Users should insert a call to this method near the end of a
        // method where they must keep an object alive for the duration of that
        // method, up until this method is called.  Here's Nick Kramer's example:
        // 
        // "...all you really need is one object with a Finalize method, and a 
        // second object with a Close/Dispose/Done method.  Such as the following 
        // contrived example:
        //
        // class Foo {
        //    Stream stream = ...;
        //    protected void Finalize() { stream.Close(); }
        //    void Problem() { stream.MethodThatSpansGCs(); }
        //    static void Main() { new Foo().Problem(); }
        // }
        // 
        //
        // In this code, Foo will be finalized in the middle of 
        // stream.MethodThatSpansGCs, thus closing a stream still in use."
        //
        // If we insert a call to GC.KeepAlive(this) at the end of Problem(), then
        // Foo doesn't get finalized and the stream says open.
        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.KeepAlive"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void KeepAlive(Object obj);

        // Returns the generation in which wo currently resides.
        //
        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.GetGeneration1"]/*' />
        public static int GetGeneration(WeakReference wo) {
            return GetGenerationWR(wo.m_handle);
        }
    
        // Returns the maximum GC generation.  Currently assumes only 1 heap.
        //
        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.MaxGeneration"]/*' />
        public static int MaxGeneration {
            get { return nativeGetMaxGeneration(); }
        }

        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.WaitForPendingFinalizers"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void WaitForPendingFinalizers();
    
        // Indicates that the system should not call the Finalize() method on
        // an object that would normally require this call.
        // Has the DynamicSecurityMethodAttribute custom attribute to prevent
        // inlining of the caller.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void nativeSuppressFinalize(Object o);

        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.SuppressFinalize"]/*' />
        public static void SuppressFinalize(Object obj)
        {
            if (obj == null)
                throw new ArgumentNullException("obj");
            nativeSuppressFinalize(obj);
        }

        // Indicates that the system should call the Finalize() method on an object
        // for which SuppressFinalize has already been called. The other situation 
        // where calling ReRegisterForFinalize is useful is inside a finalizer that 
        // needs to resurrect itself or an object that it references.
        // Has the DynamicSecurityMethodAttribute custom attribute to prevent
        // inlining of the caller.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nativeReRegisterForFinalize(Object o);
        
        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.ReRegisterForFinalize"]/*' />
        public static void ReRegisterForFinalize(Object obj)
        {
            if (obj == null)
                throw new ArgumentNullException("obj");
            nativeReRegisterForFinalize(obj);
        }

        // Returns the total number of bytes currently in use by live objects in
        // the GC heap.  This does not return the total size of the GC heap, but
        // only the live objects in the GC heap.
        //
        /// <include file='doc\GC.uex' path='docs/doc[@for="GC.GetTotalMemory"]/*' />
        public static long GetTotalMemory(bool forceFullCollection)
        {
            long size = nativeGetTotalMemory();
            if (!forceFullCollection)
                return size;
            // If we force a full collection, we will run the finalizers on all 
            // existing objects and do a collection until the value stabilizes.
            // The value is "stable" when either the value is within 5% of the 
            // previous call to nativeGetTotalMemory, or if we have been sitting
            // here for more than x times (we don't want to loop forever here).
            int reps = 20;  // Number of iterations
            long newSize = size;
            float diff;
            do {
                GC.WaitForPendingFinalizers();
                GC.Collect();
                size = newSize;
                newSize = nativeGetTotalMemory();
                diff = ((float)(newSize - size)) / size;
            } while (reps-- > 0 && !(-.05 < diff && diff < .05));
            return newSize;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern MethodBase nativeGetCurrentMethod(ref StackCrawlMark stackMark);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void SetCleanupCache();

        private static ClearCacheHandler m_cacheHandler;

        internal static event ClearCacheHandler ClearCache {
            add {
                m_cacheHandler+=value;
                SetCleanupCache();
            }
            remove {
                m_cacheHandler-=value;
            }
        }

        //This method is called from native code.  If you update the signature, please also update
        //mscorlib.h and COMUtilNative.cpp
        internal static void FireCacheEvent() {
            BCLDebug.Trace("CACHE", "Called FileCacheEvent");
            if (m_cacheHandler!=null) {
                m_cacheHandler(null, null);
                m_cacheHandler = null;
            }
        }
    }        
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\fieldaccessexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: FieldAccessException
**
** Purpose: The exception class for class loading failures.
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\FieldAccessException.uex' path='docs/doc[@for="FieldAccessException"]/*' />
    [Serializable] public class FieldAccessException : MemberAccessException {
        /// <include file='doc\FieldAccessException.uex' path='docs/doc[@for="FieldAccessException.FieldAccessException"]/*' />
        public FieldAccessException() 
            : base(Environment.GetResourceString("Arg_FieldAccessException")) {
    		SetErrorCode(__HResults.COR_E_FIELDACCESS);
        }
    
        /// <include file='doc\FieldAccessException.uex' path='docs/doc[@for="FieldAccessException.FieldAccessException1"]/*' />
        public FieldAccessException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_FIELDACCESS);
        }
    
        /// <include file='doc\FieldAccessException.uex' path='docs/doc[@for="FieldAccessException.FieldAccessException2"]/*' />
        public FieldAccessException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_FIELDACCESS);
        }

        /// <include file='doc\FieldAccessException.uex' path='docs/doc[@for="FieldAccessException.FieldAccessException3"]/*' />
        protected FieldAccessException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\guid.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
	using System.Text;
	using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;
	using System.Globalization;
    // Represents a Globally Unique Identifier.
		/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid"]/*' />
    [StructLayout(LayoutKind.Sequential)]
    [Serializable]
		public struct Guid : IFormattable, IComparable
    {
		/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.Empty"]/*' />
		public static readonly Guid Empty = new Guid();
    	////////////////////////////////////////////////////////////////////////////////
    	//  Member variables
    	////////////////////////////////////////////////////////////////////////////////
    	private int         _a;
    	private short       _b;
    	private short       _c;
    	private byte       _d;
    	private byte       _e;
    	private byte       _f;
    	private byte       _g;
    	private byte       _h;
    	private byte       _i;
    	private byte       _j;
    	private byte       _k;
    	
    	
    	
    	////////////////////////////////////////////////////////////////////////////////
    	//  Constructors
    	////////////////////////////////////////////////////////////////////////////////
    
    	// Creates a new guid from an array of bytes.
    	// 
    	/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.Guid"]/*' />
    	public Guid(byte[] b)
    	{
    		if (b==null)
    			throw new ArgumentNullException("b");
    		if (b.Length != 16)
    			throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_GuidArrayCtor"), "16"));
    		_a = BitConverter.ToInt32(b, 0);
    		_b = BitConverter.ToInt16(b, 4);
    		_c = BitConverter.ToInt16(b, 6);
    		_d = b[8];
    		_e = b[9];
    		_f = b[10];
    		_g = b[11];
    		_h = b[12];
    		_i = b[13];
    		_j = b[14];
    		_k = b[15];
    	}

		/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.Guid1"]/*' />
		[CLSCompliant(false)]
		public Guid (uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
		{
			_a = (int)a;
    		_b = (short)b;
    		_c = (short)c;
    	    _d = d;
    		_e = e;
    		_f = f;
    		_g = g;
    		_h = h;
    		_i = i;
    		_j = j;
    		_k = k;
		}
    	
    	// Creates a new guid with all contents having value of 0
    	private Guid(bool blank)
    	{
    		// Must initialize value class members even if the native
    		// function reinitializes them.  Compiler appeasement.
    		_a = 0;
    		_b = 0;
    		_c = 0;
    		_d = 0;
    		_e = 0;
    		_f = 0;
    		_g = 0;
    		_h = 0;
    		_i = 0;
    		_j = 0;
    		_k = 0;
    		if (!blank)
    			CompleteGuid();
    	}
    
    	// Creates a new guid based on the value in the string.  The value is made up
    	// of hex digits speared by the dash ("-"). The string may begin and end with
    	// brackets ("{", "}").
    	//
    	// The string must be of the form dddddddd-dddd-dddd-dddd-dddddddddddd. where
    	// d is a hex digit. (That is 8 hex digits, followed by 4, then 4, then 4,
    	// then 12) such as: "CA761232-ED42-11CE-BACD-00AA0057B223"
    	// 
    	/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.Guid2"]/*' />
    	public Guid(String g)
    	{
    		if (g==null)
    			throw new ArgumentNullException("g", "ArgumentNull_String");
    		
    		int startPos=0;
    		long _dTemp;
    		int _dStartTemp = 0;
    		int[] spArray = new int[1];
    		byte []dstartArray;
    		byte []dArray;
    
    		try
    		{
    			// Check if it's of the form dddddddd-dddd-dddd-dddd-dddddddddddd
    			if(g.IndexOf('-', 0) >= 0)
    			{
    				
    				String guidString = g.Trim();  //Remove Whitespace
    
    				// check to see that it's the proper length
    				if (guidString[0]=='{') {
    					if (guidString.Length!=38 || guidString[37]!='}') {
    						throw new FormatException(Environment.GetResourceString("Format_GuidInvLen"));
    					}
    					startPos=1;
    				} 
					else if (guidString[0]=='(') 
					{
						if (guidString.Length!=38 || guidString[37]!=')') 
						{
							throw new FormatException(Environment.GetResourceString("Format_GuidInvLen"));
						}
						startPos=1;
					} 
					else if(guidString.Length != 36) {
    					throw new FormatException(Environment.GetResourceString("Format_GuidInvLen"));
    				}
    				if (guidString[8+startPos] != '-' ||
    					guidString[13+startPos] != '-' ||
    					guidString[18+startPos] != '-' ||
    					guidString[23+startPos] != '-') {
    					throw new FormatException(Environment.GetResourceString("Format_GuidDashes"));
    				}
    				
    				spArray[0]=startPos;
    				_a = TryParse(guidString, spArray,8);
    				spArray[0]++; //Increment past the '-';
    				_b = (short)TryParse(guidString, spArray,4);
    				spArray[0]++; //Increment past the '-';
    				_c = (short)TryParse(guidString, spArray,4);
    				spArray[0]++; //Increment past the '-';
    				_dStartTemp =TryParse(guidString, spArray,4);
    				spArray[0]++; //Increment past the '-';
    				startPos=spArray[0];
    				_dTemp = ParseNumbers.StringToLong(guidString, 16, 0, spArray);
    				if (spArray[0]-startPos!=12) {
    					throw new FormatException(String.Format(Environment.GetResourceString("Format_GuidInvLen")));
    				}
    				dstartArray = BitConverter.GetBytes(_dStartTemp);
    				dArray = BitConverter.GetBytes(_dTemp);
    
    				if (BitConverter.IsLittleEndian) {
    					_d = dstartArray[1];
    					_e = dstartArray[0];
    					_f = dArray[5];
    					_g = dArray[4];
    					_h = dArray[3];
    					_i = dArray[2];
    					_j = dArray[1];
    					_k = dArray[0];
    				} else {
    					_d = dstartArray[0];
    					_e = dstartArray[1];
    					_f = dArray[0];
    					_g = dArray[1];
    					_h = dArray[2];
    					_i = dArray[3];
    					_j = dArray[4];
    					_k = dArray[5];
    				}
    			}
    
    			// Else check if it is of the form
    			// {0xdddddddd,0xdddd,0xdddd,{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd}}
    			else if(g.IndexOf('{', 0) >= 0)
    			{
    				int numStart = 0;
    				int numLen = 0;
    
    				// Convert to lower case
    				//g = g.ToLower();
                    
    				// Eat all of the whitespace
    				g = EatAllWhitespace(g);
    
    				// Check for leading '{'
    				if(g[0] != '{')
    					throw new FormatException(Environment.GetResourceString("Format_GuidBrace"));
    
    				// Check for '0x'
    				if(!IsHexPrefix(g, 1))
    					throw new FormatException(String.Format(Environment.GetResourceString("Format_GuidHexPrefix"), "{0xdddddddd, etc}"));
    
    				// Find the end of this hex number (since it is not fixed length)
    				numStart = 3;
    				numLen = g.IndexOf(',', numStart) - numStart;
    				if(numLen <= 0)
    					throw new FormatException(Environment.GetResourceString("Format_GuidComma"));
    
    				// Read in the number
    				_a = (int) ParseNumbers.StringToInt(g.Substring(numStart, numLen), // first DWORD
    													16,                            // hex
    													ParseNumbers.IsTight);         // tight parsing
    
    				// Check for '0x'
    				if(!IsHexPrefix(g, numStart+numLen+1))
    					throw new FormatException(String.Format(Environment.GetResourceString("Format_GuidHexPrefix"), "{0xdddddddd, 0xdddd, etc}"));
    
    				// +3 to get by ',0x'
    				numStart = numStart + numLen + 3;
    				numLen = g.IndexOf(',', numStart) - numStart;
    				if(numLen <= 0)
    					throw new FormatException(Environment.GetResourceString("Format_GuidComma"));
    
    				// Read in the number
    				_b = (short) ParseNumbers.StringToInt(
    													  g.Substring(numStart, numLen), // first DWORD
    													  16,                            // hex
    													  ParseNumbers.IsTight);         // tight parsing
    
    				// Check for '0x'
    				if(!IsHexPrefix(g, numStart+numLen+1))
    					throw new FormatException(String.Format(Environment.GetResourceString("Format_GuidHexPrefix"), "{0xdddddddd, 0xdddd, 0xdddd, etc}"));
    
    				// +3 to get by ',0x'
    				numStart = numStart + numLen + 3;
    				numLen = g.IndexOf(',', numStart) - numStart;
    				if(numLen <= 0)
    					throw new FormatException(Environment.GetResourceString("Format_GuidComma"));
    
    				// Read in the number
    				_c = (short) ParseNumbers.StringToInt(
    													  g.Substring(numStart, numLen), // first DWORD
    													  16,                            // hex
    													  ParseNumbers.IsTight);         // tight parsing
    
    				// Check for '{'
    				if(g.Length <= numStart+numLen+1 || g[numStart+numLen+1] != '{')
    					throw new FormatException(Environment.GetResourceString("Format_GuidBrace"));
    
    				// Prepare for loop
    				numLen++;
    				byte[] bytes = new byte[8];
    				
    				for(int i = 0; i < 8; i++)
    				{
    					// Check for '0x'
    					if(!IsHexPrefix(g, numStart+numLen+1))
    						throw new FormatException(String.Format(Environment.GetResourceString("Format_GuidHexPrefix"), "{... { ... 0xdd, ...}}"));
    
    					// +3 to get by ',0x' or '{0x' for first case
    					numStart = numStart + numLen + 3;
    
    					// Calculate number length
    					if(i < 7)  // first 7 cases
    					{
    						numLen = g.IndexOf(',', numStart) - numStart;
    					}
    					else       // last case ends with '}', not ','
    					{
    						numLen = g.IndexOf('}', numStart) - numStart;
    					}
    					if(numLen <= 0)
    						throw new FormatException(Environment.GetResourceString("Format_GuidComma"));
    
    					// Read in the number
    					bytes[i] = (byte) Convert.ToInt32(g.Substring(numStart, numLen),16);
    				}
    
    				_d = bytes[0];
    				_e = bytes[1];
    				_f = bytes[2];
    				_g = bytes[3];
    				_h = bytes[4];
    				_i = bytes[5];
    				_j = bytes[6];
    				_k = bytes[7];
    
    				// Check for last '}'
    				if(numStart+numLen+1 >= g.Length || g[numStart+numLen+1] != '}')
    					throw new FormatException(Environment.GetResourceString("Format_GuidEndBrace"));
    				
    				return;
    			}
    			else 
				// Check if it's of the form dddddddddddddddddddddddddddddddd
    			{
    				String guidString = g.Trim();  //Remove Whitespace
    
					if(guidString.Length != 32) {
    					throw new FormatException(Environment.GetResourceString("Format_GuidInvLen"));
    				}

					_a = (int) ParseNumbers.StringToInt(g.Substring(startPos, 8), // first DWORD
    													16,                            // hex
    													ParseNumbers.IsTight);         // tight parsing
					startPos += 8;
					_b = (short) ParseNumbers.StringToInt(g.Substring(startPos, 4), 
    													16,                  
    													ParseNumbers.IsTight);
					startPos += 4;
					_c = (short) ParseNumbers.StringToInt(g.Substring(startPos, 4), 
    													16,                   
    													ParseNumbers.IsTight);
    		   		
					startPos += 4;
    				_dStartTemp =(short) ParseNumbers.StringToInt(g.Substring(startPos, 4), 
    													16,                   
    													ParseNumbers.IsTight);
					startPos += 4;
    				spArray[0] = startPos;
    				_dTemp = ParseNumbers.StringToLong(guidString, 16, startPos, spArray);
    				if (spArray[0]-startPos!=12) {
    					throw new FormatException(String.Format(Environment.GetResourceString("Format_GuidInvLen")));
    				}
    				dstartArray = BitConverter.GetBytes(_dStartTemp);
    				dArray = BitConverter.GetBytes(_dTemp);
    
    				if (BitConverter.IsLittleEndian) {
    					_d = dstartArray[1];
    					_e = dstartArray[0];
    					_f = dArray[5];
    					_g = dArray[4];
    					_h = dArray[3];
    					_i = dArray[2];
    					_j = dArray[1];
    					_k = dArray[0];
    				} else {
    					_d = dstartArray[0];
    					_e = dstartArray[1];
    					_f = dArray[0];
    					_g = dArray[1];
    					_h = dArray[2];
    					_i = dArray[3];
    					_j = dArray[4];
    					_k = dArray[5];
    				}
    			}
    		}
    		catch(IndexOutOfRangeException)
    		{
    			throw new FormatException(Environment.GetResourceString("Format_GuidUnrecognized"));
    		}
    	}
    
    	// Creates a new GUID initialized to the value represented by the arguments.
    	// 
    	/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.Guid3"]/*' />
    	public Guid(int a, short b, short c, byte[] d)
    	{
    		if (d==null)
    			throw new ArgumentNullException("d");
    		// Check that array is not too big
            if(d.Length != 8)
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_GuidArrayCtor"), "8"));
    
    		_a  = a;
    		_b  = b;
    		_c  = c;
    		_d = d[0];
    		_e = d[1];
    		_f = d[2];
    		_g = d[3];
    		_h = d[4];
    		_i = d[5];
    		_j = d[6];
    		_k = d[7];
    	}
    
    	// Creates a new GUID initialized to the value represented by the 
    	// arguments.  The bytes are specified like this to avoid endianness issues.
    	// 
    	/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.Guid4"]/*' />
    	public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
    	{
    		_a = a;
    		_b = b;
    		_c = c;
    		_d = d;
    		_e = e;
    		_f = f;
    		_g = g;
    		_h = h;
    		_i = i;
    		_j = j;
    		_k = k;
    	}
    
    	    	
        private static int TryParse(String str, int []parsePos, int requiredLength) {
            int currStart = parsePos[0];
			int retVal;
			try
			{
				retVal = ParseNumbers.StringToInt(str, 16, 0, parsePos);
			}
			catch (FormatException)
			{
			   throw new FormatException(Environment.GetResourceString("Format_GuidUnrecognized"));
			}
    
            //If we didn't parse enough characters, there's clearly an error.
            if (parsePos[0]-currStart!=requiredLength) {
                throw new FormatException(Environment.GetResourceString("Format_GuidUnrecognized"));
            }
            return retVal;
        }
        
    	private static String EatAllWhitespace(String str)
    	{
            int newLength = 0;
    		char[] chArr = new char[str.Length];
    		char curChar;
    
    		// Now get each char from str and if it is not whitespace add it to chArr
    		for(int i = 0; i < str.Length; i++)
    		{
    			curChar = str[i];
    			if(!Char.IsWhiteSpace(curChar))
    			{
    				chArr[newLength++] = curChar;
    			}
    		}
    
    		// Return a new string based on chArr
    		return new String(chArr, 0, newLength);
    	}
    
    	private static bool IsHexPrefix(String str, int i)
    	{
            if(str[i] == '0' && (Char.ToLower(str[i+1], CultureInfo.InvariantCulture) == 'x'))
                return true;
            else
                return false;
    	}
    
    	
    	// Returns an unsigned byte array containing the GUID.
    	/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.ToByteArray"]/*' />
    	public byte[] ToByteArray()
    	{
    		byte[] g = new byte[16];
    		byte[] tmp = BitConverter.GetBytes(_a);
    		for(int i=0; i<4; i++)
    			g[i] = tmp[i];
    		tmp = BitConverter.GetBytes(_b);
    		for(int i=0; i<2; i++)
    			g[i+4] = tmp[i];
    		tmp = BitConverter.GetBytes(_c);
    		for(int i=0; i<2; i++)
    			g[i+6] = tmp[i];
    
    		g[8] = _d;
    		g[9] = _e;
    		g[10] = _f;
    		g[11] = _g;
    		g[12] = _h;
    		g[13] = _i;
    		g[14] = _j;
    		g[15] = _k;
    		
    		return g;
    	}
    	
    
    	// Returns the guid in "registry" format.
    	/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.ToString"]/*' />
    	public override String ToString()
    	{
            return ToString("D",null);
    	}
    
    	/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return _a ^ (((int)_b << 16) | (int)(ushort)_c) ^ (((int)_f << 24) | _k);
    	}
    
    	// Returns true if and only if the guid represented
    	//  by o is the same as this instance.
    	/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.Equals"]/*' />
    	public override bool Equals(Object o)
    	{
    		Guid g;
    		// Check that o is a Guid first
    		if(o == null || !(o is Guid))
    			return false;
    		else g = (Guid) o;
    
    		// Now compare each of the elements
    		if(g._a != _a)
    			return false;
    		if(g._b != _b)
    			return false;
    		if(g._c != _c)
    			return false;
    		if (g._d != _d)
    			return false;
    		if (g._e != _e)
    			return false;
    		if (g._f != _f)
    			return false;
    		if (g._g != _g)
    			return false;
    		if (g._h != _h)
    			return false;
    		if (g._i != _i)
    			return false;
    		if (g._j != _j)
    			return false;
    		if (g._k != _k)
    			return false;
    		
    		return true;
    	}

        private int GetResult(uint me, uint them) {
            if (me<them) {
                return -1;
            }
            return 1;
        }

        /// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (!(value is Guid)) {
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeGuid"));
            }
            Guid g = (Guid)value;

            if (g._a!=this._a) {
                return GetResult((uint)this._a, (uint)g._a);
            }

            if (g._b!=this._b) {
                return GetResult((uint)this._b, (uint)g._b);
            }

            if (g._c!=this._c) {
                return GetResult((uint)this._c, (uint)g._c);
            }

            if (g._d!=this._d) {
                return GetResult((uint)this._d, (uint)g._d);
            }

            if (g._e!=this._e) {
                return GetResult((uint)this._e, (uint)g._e);
            }

            if (g._f!=this._f) {
                return GetResult((uint)this._f, (uint)g._f);
            }

            if (g._g!=this._g) {
                return GetResult((uint)this._g, (uint)g._g);
            }

            if (g._h!=this._h) {
                return GetResult((uint)this._h, (uint)g._h);
            }

            if (g._i!=this._i) {
                return GetResult((uint)this._i, (uint)g._i);
            }

            if (g._j!=this._j) {
                return GetResult((uint)this._j, (uint)g._j);
            }

            if (g._k!=this._k) {
                return GetResult((uint)this._k, (uint)g._k);
            }
            
            return 0;
        }
    	    	
    	// Compares two Guids by calling Guid.Equals(Guid).
    /*	private static bool operator equals(Guid a, Guid b)
    	{
    		return a.Equals(b);	
    	}*/
    	
		/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.operatorEQ"]/*' />
		public static bool operator ==(Guid a, Guid b)
    	{
    		return a.Equals(b);	
    	}

		/// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.operatorNE"]/*' />
		public static bool operator !=(Guid a, Guid b)
    	{
    		return !a.Equals(b);	
    	}

    	// This will fill in the members of Guid using CoCreateGuid.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern bool CompleteGuid();
    
        // This will create a new guid.  Since we've now decided that constructors should 0-init, 
        // we need a method that allows users to create a guid.
        /// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.NewGuid"]/*' />
        public static Guid NewGuid() {
            return new Guid(false);
        }
    
        /// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }

		private char HexToChar(int a)
		{
			BCLDebug.Assert(a <= 0xf,"argument must be less than 0xf");
			return (char) ((a > 9) ? a - 10 + 0x61 : a + 0x30);
		}

		// IFormattable interface
		// We currently ignore provider
        /// <include file='doc\Guid.uex' path='docs/doc[@for="Guid.ToString2"]/*' />
		public String ToString(String format, IFormatProvider provider)
		{
			if (format == null || format.Length == 0)
				format = "D";

			char[] guidChars;
			int offset = 0;
			byte[] tmp;
			int i;

			if (String.Compare(format,"N",true, CultureInfo.InvariantCulture) == 0)
			{
				guidChars = new char[32];
				tmp = BitConverter.GetBytes(_a);
				for (i = 3; i >= 0; i--)
				{
					guidChars[offset++] = HexToChar((tmp[i]>>4) & 0xf);				
					guidChars[offset++] = HexToChar(tmp[i] & 0xf); 
				}

				tmp = BitConverter.GetBytes(_b);
				for (i = 1; i >= 0; i--)
				{
					guidChars[offset++] = HexToChar((tmp[i]>>4) & 0xf);				
					guidChars[offset++] = HexToChar(tmp[i] & 0xf); 
					
				}

				tmp = BitConverter.GetBytes(_c);
				for (i = 1; i >= 0; i--)
				{
					guidChars[offset++] = HexToChar((tmp[i]>>4) & 0xf);				
					guidChars[offset++] = HexToChar(tmp[i] & 0xf); 
				}

				guidChars[offset++] = HexToChar((_d>>4) & 0xf);
				guidChars[offset++] = HexToChar(_d & 0xf);

				guidChars[offset++] = HexToChar((_e>>4) & 0xf);
				guidChars[offset++] = HexToChar(_e & 0xf);

				guidChars[offset++] = HexToChar((_f>>4) & 0xf);
				guidChars[offset++] = HexToChar(_f & 0xf);

				guidChars[offset++] = HexToChar((_g>>4) & 0xf);
				guidChars[offset++] = HexToChar(_g & 0xf);
				
				guidChars[offset++] = HexToChar((_h>>4) & 0xf);
				guidChars[offset++] = HexToChar(_h & 0xf);

				guidChars[offset++] = HexToChar((_i>>4) & 0xf);
				guidChars[offset++] = HexToChar(_i & 0xf);

				guidChars[offset++] = HexToChar((_j>>4) & 0xf);
				guidChars[offset++] = HexToChar(_j & 0xf);

				guidChars[offset++] = HexToChar((_k>>4) & 0xf);
				guidChars[offset++] = HexToChar(_k & 0xf);
				return new string(guidChars, 0, 32);
			}

			int strLength = 38;
			if (String.Compare(format,"B",true, CultureInfo.InvariantCulture) == 0)
			{
				guidChars = new char[38];
				guidChars[offset++] = '{';
				guidChars[37] = '}';
			}
			else if (String.Compare(format,"P",true, CultureInfo.InvariantCulture) == 0)
			{
				guidChars = new char[38];
				guidChars[offset++] = '(';
				guidChars[37] = ')';
			}
			else if (String.Compare(format,"D",true, CultureInfo.InvariantCulture) == 0)
			{
				guidChars = new char[36];
				strLength = 36;
			}
			else
				throw new FormatException(Environment.GetResourceString("Format_InvalidGuidFormatSpecification"));

			tmp = BitConverter.GetBytes(_a);
			for (i = 3; i >= 0; i--)
			{
				guidChars[offset++] = HexToChar((tmp[i]>>4) & 0xf);				
				guidChars[offset++] = HexToChar(tmp[i] & 0xf); 
			}

			guidChars[offset++] = '-';

			tmp = BitConverter.GetBytes(_b);
			for (i = 1; i >= 0; i--)
			{
				guidChars[offset++] = HexToChar((tmp[i]>>4) & 0xf);				
				guidChars[offset++] = HexToChar(tmp[i] & 0xf); 
				
			}

			guidChars[offset++] = '-';

			tmp = BitConverter.GetBytes(_c);
			for (i = 1; i >= 0; i--)
			{
				guidChars[offset++] = HexToChar((tmp[i]>>4) & 0xf);				
				guidChars[offset++] = HexToChar(tmp[i] & 0xf); 
			}

			guidChars[offset++] = '-';

			guidChars[offset++] = HexToChar((_d>>4) & 0xf);
			guidChars[offset++] = HexToChar(_d & 0xf);

			guidChars[offset++] = HexToChar((_e>>4) & 0xf);
			guidChars[offset++] = HexToChar(_e & 0xf);

			guidChars[offset++] = '-';

			guidChars[offset++] = HexToChar((_f>>4) & 0xf);
			guidChars[offset++] = HexToChar(_f & 0xf);

			guidChars[offset++] = HexToChar((_g>>4) & 0xf);
			guidChars[offset++] = HexToChar(_g & 0xf);
			
			guidChars[offset++] = HexToChar((_h>>4) & 0xf);
			guidChars[offset++] = HexToChar(_h & 0xf);

			guidChars[offset++] = HexToChar((_i>>4) & 0xf);
			guidChars[offset++] = HexToChar(_i & 0xf);

			guidChars[offset++] = HexToChar((_j>>4) & 0xf);
			guidChars[offset++] = HexToChar(_j & 0xf);

			guidChars[offset++] = HexToChar((_k>>4) & 0xf);
			guidChars[offset++] = HexToChar(_k & 0xf);

			return new String(guidChars, 0, strLength);

			
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\iappdomain.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IAppDomain
**
** Author: 
**
** Purpose: Properties and methods exposed to COM
**
** Date:  
** 
===========================================================*/
namespace System {
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using SecurityManager = System.Security.SecurityManager;
    using System.Security.Permissions;
    using IEvidenceFactory = System.Security.IEvidenceFactory;
    using System.Security.Principal;
    using System.Security.Policy;
    using System.Security;
    using System.Security.Util;
    using System.Collections;
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;   
    using System.Runtime.Remoting.Contexts;
    using System.Reflection.Emit;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Messaging;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;

    /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain"]/*' />
    [GuidAttribute("05F696DC-2B29-3663-AD8B-C4389CF2A713")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    [CLSCompliant(false)]
    public interface _AppDomain
    {
        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ToString"]/*' />
        String ToString();

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Equals"]/*' />
        bool Equals (Object other);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.GetHashCode"]/*' />
        int GetHashCode ();

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.GetType"]/*' />
        Type GetType ();

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.InitializeLifetimeService"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        Object InitializeLifetimeService ();

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.GetLifetimeService"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        Object GetLifetimeService ();

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Evidence"]/*' />
        Evidence Evidence { get; }

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DomainUnload"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        event EventHandler DomainUnload;

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.AssemblyLoad"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        event AssemblyLoadEventHandler AssemblyLoad;

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ProcessExit"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        event EventHandler ProcessExit;

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.TypeResolve"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        event ResolveEventHandler TypeResolve;

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ResourceResolve"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        event ResolveEventHandler ResourceResolve;

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.AssemblyResolve"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        event ResolveEventHandler AssemblyResolve;

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.UnhandledException"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        event UnhandledExceptionEventHandler UnhandledException;

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly1"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access,
                                              String                  dir);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly2"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access,
                                              Evidence                evidence);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly3"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access,
                                              PermissionSet           requiredPermissions,
                                              PermissionSet           optionalPermissions,
                                              PermissionSet           refusedPermissions);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly4"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access,
                                              String                  dir,
                                              Evidence                evidence);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly5"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access,
                                              String                  dir,
                                              PermissionSet           requiredPermissions,
                                              PermissionSet           optionalPermissions,
                                              PermissionSet           refusedPermissions);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly6"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access,
                                              Evidence                evidence,
                                              PermissionSet           requiredPermissions,
                                              PermissionSet           optionalPermissions,
                                              PermissionSet           refusedPermissions);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly7"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access,
                                              String                  dir,
                                              Evidence                evidence,
                                              PermissionSet           requiredPermissions,
                                              PermissionSet           optionalPermissions,
                                              PermissionSet           refusedPermissions);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DefineDynamicAssembly8"]/*' />
        AssemblyBuilder DefineDynamicAssembly(AssemblyName            name,
                                              AssemblyBuilderAccess   access,
                                              String                  dir,
                                              Evidence                evidence,
                                              PermissionSet           requiredPermissions,
                                              PermissionSet           optionalPermissions,
                                              PermissionSet           refusedPermissions,
                                              bool                    isSynchronized);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.CreateInstance"]/*' />
        ObjectHandle CreateInstance(String assemblyName,
                                    String typeName);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.CreateInstanceFrom"]/*' />
                                         
        ObjectHandle CreateInstanceFrom(String assemblyFile,
                                        String typeName);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.CreateInstance1"]/*' />
                                         
        ObjectHandle CreateInstance(String assemblyName,
                                    String typeName,
                                    Object[] activationAttributes);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.CreateInstanceFrom1"]/*' />
        ObjectHandle CreateInstanceFrom(String assemblyFile,
                                        String typeName,
                                        Object[] activationAttributes);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.CreateInstance2"]/*' />        
       ObjectHandle CreateInstance(String assemblyName, 
                                   String typeName, 
                                   bool ignoreCase,
                                   BindingFlags bindingAttr, 
                                   Binder binder,
                                   Object[] args,
                                    CultureInfo culture,
                                   Object[] activationAttributes,
                                   Evidence securityAttributes);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.CreateInstanceFrom2"]/*' />
       ObjectHandle CreateInstanceFrom(String assemblyFile,
                                       String typeName, 
                                       bool ignoreCase,
                                       BindingFlags bindingAttr, 
                                       Binder binder,
                                        Object[] args,
                                       CultureInfo culture,
                                       Object[] activationAttributes,
                                       Evidence securityAttributes);

       /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Load"]/*' />
        Assembly Load(AssemblyName assemblyRef);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Load1"]/*' />
        Assembly Load(String assemblyString);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Load2"]/*' />
        Assembly Load(byte[] rawAssembly);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Load3"]/*' />
        Assembly Load(byte[] rawAssembly,
                      byte[] rawSymbolStore);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Load4"]/*' />
        Assembly Load(byte[] rawAssembly,
                      byte[] rawSymbolStore,
                      Evidence securityEvidence);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Load5"]/*' />
        Assembly Load(AssemblyName assemblyRef, 
                      Evidence assemblySecurity);     

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.Load7"]/*' />
        Assembly Load(String assemblyString, 
                      Evidence assemblySecurity);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ExecuteAssembly"]/*' />
        int ExecuteAssembly(String assemblyFile, 
                            Evidence assemblySecurity);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ExecuteAssembly1"]/*' />
        int ExecuteAssembly(String assemblyFile);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ExecuteAssembly2"]/*' />
        int ExecuteAssembly(String assemblyFile, 
                            Evidence assemblySecurity, 
                            String[] args);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.FriendlyName"]/*' />
        String FriendlyName
        { get; }

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.BaseDirectory"]/*' />
        String BaseDirectory
        { get; }

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.RelativeSearchPath"]/*' />
        String RelativeSearchPath
        { get; }

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ShadowCopyFiles"]/*' />
        bool ShadowCopyFiles
        { get; }

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.GetAssemblies"]/*' />
        Assembly[] GetAssemblies();

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.AppendPrivatePath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        void AppendPrivatePath(String path);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ClearPrivatePath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        void ClearPrivatePath();

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.SetShadowCopyPath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        void SetShadowCopyPath (String s);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.ClearShadowCopyPath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        void ClearShadowCopyPath ( );

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.SetCachePath"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        void SetCachePath (String s);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.SetData"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        void SetData(String name, Object data);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.GetData"]/*' />
        Object GetData(string name);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.SetAppDomainPolicy"]/*' />
        [SecurityPermission(SecurityAction.LinkDemand, ControlDomainPolicy=true)]
        void SetAppDomainPolicy(PolicyLevel domainPolicy);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.SetThreadPrincipal"]/*' />
        void SetThreadPrincipal(IPrincipal principal);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.SetPrincipalPolicy"]/*' />
        void SetPrincipalPolicy(PrincipalPolicy policy);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DoCallBack"]/*' />
        void DoCallBack(CrossAppDomainDelegate theDelegate);

        /// <include file='doc\IAppDomain.uex' path='docs/doc[@for="_AppDomain.DynamicDirectory"]/*' />
        String DynamicDirectory
        { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\iasyncresult.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: IAsyncResult
**
** Purpose: Interface to encapsulate the results of an async
**          operation
**
===========================================================*/
namespace System {
    
	using System;
	using System.Threading;
    /// <include file='doc\IAsyncResult.uex' path='docs/doc[@for="IAsyncResult"]/*' />
    public interface IAsyncResult
    {
        /// <include file='doc\IAsyncResult.uex' path='docs/doc[@for="IAsyncResult.IsCompleted"]/*' />
        bool IsCompleted { get; }

        /// <include file='doc\IAsyncResult.uex' path='docs/doc[@for="IAsyncResult.AsyncWaitHandle"]/*' />
        WaitHandle AsyncWaitHandle { get; }


        /// <include file='doc\IAsyncResult.uex' path='docs/doc[@for="IAsyncResult.AsyncState"]/*' />
        Object     AsyncState      { get; }

        /// <include file='doc\IAsyncResult.uex' path='docs/doc[@for="IAsyncResult.CompletedSynchronously"]/*' />
        bool       CompletedSynchronously { get; }
   
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\iappdomainsetup.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IAppDomainSetup
**
** Author: 
**
** Purpose: Properties exposed to COM
**
** Date:  
** 
===========================================================*/
namespace System {

    using System.Runtime.InteropServices;

    /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup"]/*' />
    [GuidAttribute("27FFF232-A7A8-40dd-8D4A-734AD59FCD41")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IAppDomainSetup
    {
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.ApplicationBase"]/*' />
        String ApplicationBase {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.ApplicationName"]/*' />

        String ApplicationName
        {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.CachePath"]/*' />

        String CachePath
        {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.ConfigurationFile"]/*' />

        String ConfigurationFile {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.DynamicBase"]/*' />

        String DynamicBase
        {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.LicenseFile"]/*' />

        String LicenseFile
        {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.PrivateBinPath"]/*' />

        String PrivateBinPath
        {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.PrivateBinPathProbe"]/*' />

        String PrivateBinPathProbe
        {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.ShadowCopyDirectories"]/*' />

        String ShadowCopyDirectories
        {
            get;
            set;
        }
        /// <include file='doc\IAppDomainSetup.uex' path='docs/doc[@for="IAppDomainSetup.ShadowCopyFiles"]/*' />

        String ShadowCopyFiles
        {
            get;
            set;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\icomparable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
    // The IComparable interface is implemented by classes that support an
    // ordering of instances of the class. The ordering represented by
    // IComparable can be used to sort arrays and collections of objects
    // that implement the interface.
    // 
    /// <include file='doc\IComparable.uex' path='docs/doc[@for="IComparable"]/*' />
    public interface IComparable
    {
        /// <include file='doc\IComparable.uex' path='docs/doc[@for="IComparable.CompareTo"]/*' />
	// Interface does not need to be marked with the serializable attribute
        // Compares this object to another object, returning an integer that
        // indicates the relationship. An implementation of this method must return
        // a value less than zero if this is less than object, zero
        // if this is equal to object, or a value greater than zero
        // if this is greater than object.
        // 
        int CompareTo(Object obj);
    }







}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\iconvertible.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {

	using System.Threading;

    // The IValue interface represents an object that contains a value. This
    // interface is implemented by the following types in the System namespace:
    // Boolean, Char, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64,
    // Single, Double, Decimal, DateTime, TimeSpan, and String. The interface may
    // be implemented by other types that are to be considered values. For example,
    // a library of nullable database types could implement IValue.
    //
    // The implementations of IValue provided by the System.XXX value classes
    // simply forward to the appropriate Value.ToXXX(YYY) methods (a description of
    // the Value class follows below). In cases where a Value.ToXXX(YYY) method
    // does not exist (because the particular conversion is not supported), the
    // IValue implementation should simply throw an InvalidCastException.

    /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible"]/*' />
    [CLSCompliant(false)]
    public interface IConvertible
    {
        // Returns the type code of this object. An implementation of this method
        // must not return TypeCode.Empty (which represents a null reference) or
        // TypeCode.Object (which represents an object that doesn't implement the
        // IValue interface). An implementation of this method should return
        // TypeCode.DBNull if the value of this object is a database null. For
        // example, a nullable integer type should return TypeCode.DBNull if the
        // value of the object is the database null. Otherwise, an implementation
        // of this method should return the TypeCode that best describes the
        // internal representation of the object.

        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.GetTypeCode"]/*' />
        TypeCode GetTypeCode();

        // The ToXXX methods convert the value of the underlying object to the
        // given type. If a particular conversion is not supported, the
        // implementation must throw an InvalidCastException. If the value of the
        // underlying object is not within the range of the target type, the
        // implementation must throw an OverflowException.  The 
        // IFormatProvider will be used to get a NumberFormatInfo or similar
        // appropriate service object, and may safely be null.

        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToBoolean"]/*' />
        bool ToBoolean(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToChar"]/*' />
        char ToChar(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToSByte"]/*' />
        sbyte ToSByte(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToByte"]/*' />
        byte ToByte(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToInt16"]/*' />
        short ToInt16(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToUInt16"]/*' />
        ushort ToUInt16(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToInt32"]/*' />
        int ToInt32(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToUInt32"]/*' />
        uint ToUInt32(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToInt64"]/*' />
        long ToInt64(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToUInt64"]/*' />
        ulong ToUInt64(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToSingle"]/*' />
        float ToSingle(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToDouble"]/*' />
        double ToDouble(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToDecimal"]/*' />
        Decimal ToDecimal(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToDateTime"]/*' />
        DateTime ToDateTime(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToString"]/*' />
        String ToString(IFormatProvider provider);
        /// <include file='doc\IConvertible.uex' path='docs/doc[@for="IConvertible.ToType"]/*' />
        Object ToType(Type conversionType, IFormatProvider provider);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\exception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Exception
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: The base class for all exceptional conditions.
**
** Date: March 11, 1998
**
=============================================================================*/

namespace System {
    using System;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using MethodInfo = System.Reflection.MethodInfo;
    using MethodBase = System.Reflection.MethodBase;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System.Security.Permissions;
    using System.Security;
    using System.IO;
    using System.Text;
    using System.Reflection;

        
    /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception"]/*' />
    [ClassInterface(ClassInterfaceType.AutoDual)]
    [Serializable()] 
    public class Exception : ISerializable
    {
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.Exception"]/*' />
        public Exception() {
            _message = null;
            _stackTrace = null;
            HResult = __HResults.COR_E_EXCEPTION;
            _xcode = _COMPlusExceptionCode;
            _xptrs = (IntPtr) 0;
        }
    
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.Exception1"]/*' />
        public Exception(String message) {
            _message = message;
            _stackTrace = null;
            HResult = __HResults.COR_E_EXCEPTION;
            _xcode = _COMPlusExceptionCode;
            _xptrs = (IntPtr) 0;
        }
    
        // Creates a new Exception.  All derived classes should 
        // provide this constructor.
        // Note: the stack trace is not started until the exception 
        // is thrown
        // 
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.Exception2"]/*' />
        public Exception (String message, Exception innerException)
        {
            // TODO: The innerException will be provided by the runtime 
            // in the M9 timeframe, until then, we need this method.
            _message = message;
            _stackTrace = null;
            _innerException = innerException;
            HResult = __HResults.COR_E_EXCEPTION;
            _xcode = _COMPlusExceptionCode;
            _xptrs = (IntPtr) 0;
        }

        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.Exception3"]/*' />
        protected Exception(SerializationInfo info, StreamingContext context) {
            if (info==null)
                throw new ArgumentNullException("info");
    
            _className = info.GetString("ClassName");
            _message = info.GetString("Message");
            _innerException = (Exception)(info.GetValue("InnerException",typeof(Exception)));
            _helpURL = info.GetString("HelpURL");
            _stackTraceString = info.GetString("StackTraceString");
            _remoteStackTraceString = info.GetString("RemoteStackTraceString");
            _remoteStackIndex = info.GetInt32("RemoteStackIndex");

            _exceptionMethodString = (String)(info.GetValue("ExceptionMethod",typeof(String)));
            HResult = info.GetInt32("HResult");
            _source = info.GetString("Source");
    
            if (_className == null || HResult==0)
                throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientState"));
        }
        
        
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.Message"]/*' />
        public virtual String Message {
               get {  
                if (_message == null) {
                    if (_className==null) {
                        _className = GetClassName();
                    }
                    return String.Format(Environment.GetResourceString("Exception_WasThrown"), _className);
                } else {
                    return _message;
                }
            }
        }
    
        
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String GetClassName();
    
        // Retrieves the lowest exception (inner most) for the given Exception.
        // This will traverse exceptions using the innerException property.
        //
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.GetBaseException"]/*' />
        public virtual Exception GetBaseException() 
        {
            Exception inner = InnerException;
            Exception back = this;
            
            while (inner != null) {
                back = inner;
                inner = inner.InnerException;
            }
            
            return back;
        }
        
        // Returns the inner exception contained in this exception
        // 
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.InnerException"]/*' />
        public Exception InnerException {
            get { return _innerException; }
        }
        
            
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern private MethodBase InternalGetMethod(Object stackTrace);
    
    
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.TargetSite"]/*' />
        public MethodBase TargetSite {
            [ReflectionPermissionAttribute(SecurityAction.Demand, TypeInformation=true)]
            get {
                return GetTargetSiteInternal();
            }
        }
    

        // this function is provided as a private helper to avoid the security demand
        private MethodBase GetTargetSiteInternal() {
            if (_exceptionMethod!=null) {
                return _exceptionMethod;
            }
            if (_stackTrace==null && _stackTraceString==null) {
                return null;
            }

            if (_exceptionMethodString!=null) {
                _exceptionMethod = GetExceptionMethodFromString();
            } else {
                _exceptionMethod = InternalGetMethod(_stackTrace);
            }
            return _exceptionMethod;
        }

        // Returns the stack trace as a string.  If no stack trace is
        // available, null is returned.
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.StackTrace"]/*' />
        public virtual String StackTrace {
            get {
                // if no stack trace, try to get one
                if (_stackTraceString!=null) {
                    return _remoteStackTraceString + _stackTraceString;
                }
                if (_stackTrace==null) {
                    return null;
                }
    
                _stackTraceString = Environment.GetStackTrace(this);
                return _remoteStackTraceString + _stackTraceString;
            }
        }
    
        internal void SetErrorCode(int hr)
        {
            HResult = hr;
        }
        
        // Sets the help link for this exception.
        // This should be in a URL/URN form, such as:
        // "file:///C:/Applications/Bazzal/help.html#ErrorNum42"
        // Changed to be a read-write String and not return an exception
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.HelpLink"]/*' />
        public virtual String HelpLink
        {
            get
            {
                return _helpURL;
            }
            set
            {
                _helpURL = value;
            }
        }
    
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.Source"]/*' />
        public virtual String Source {
            [ReflectionPermissionAttribute(SecurityAction.Assert, TypeInformation=true)]
            get { 
                if (_source == null)
                {
                    StackTrace st = new StackTrace(this,true);
                    if (st.FrameCount>0)
                    {
                        StackFrame sf = st.GetFrame(0);
                        MethodBase method = sf.GetMethod();
                        _source = method.DeclaringType.Module.Assembly.nGetSimpleName();
                    }
                }

                return _source;
            }
            set { _source = value; }
        }
        
        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.ToString"]/*' />
        [ReflectionPermissionAttribute(SecurityAction.Assert, TypeInformation=true)]
        public override String ToString() {
            String message = Message;
            String s;
            if (_className==null) {
                _className = GetClassName();
            }

            if (message == null || message.Length <= 0) {
                s = _className;
            }
            else {
                s = _className + ": " + message;
            }

            if (_innerException!=null) {
                s = s + " ---> " + _innerException.ToString() + Environment.NewLine + "   " + Environment.GetResourceString("Exception_EndOfInnerExceptionStack");
            }


            if (StackTrace != null)
                s += Environment.NewLine + StackTrace;

            return s;
        }
    
        private String GetExceptionMethodString() {
            MethodBase methBase = GetTargetSiteInternal();
            if (methBase==null) {
                return null;
            }
            char separator = '\0';
            StringBuilder result = new StringBuilder();
            if (methBase is ConstructorInfo) {
                RuntimeConstructorInfo rci = (RuntimeConstructorInfo)methBase;
                Type t = rci.InternalReflectedClass(false);
                result.Append((int)MemberTypes.Constructor);
                result.Append(separator);
                result.Append(rci.Name);
                result.Append(separator);
                result.Append(t.Assembly.FullName);
                result.Append(separator);
                result.Append(t.FullName);
                result.Append(separator);
                result.Append(rci.ToString());
            } else {
                BCLDebug.Assert(methBase is MethodInfo, "[Exception.GetExceptionMethodString]methBase is MethodInfo");
                RuntimeMethodInfo rmi = (RuntimeMethodInfo)methBase;
                Type t = rmi.InternalReflectedClass(false);
                result.Append((int)MemberTypes.Method);
                result.Append(separator);
                result.Append(rmi.Name);
                result.Append(separator);
                result.Append(t.Assembly.FullName);
                result.Append(separator);
                result.Append(t.FullName);
                result.Append(separator);
                result.Append(rmi.ToString());
            }
            
            return result.ToString();
        }

        private MethodBase GetExceptionMethodFromString() {
            if (_exceptionMethodString==null) {
                return null;
            }
            String[] args = _exceptionMethodString.Split('\0');
            if (args.Length!=5) {
                throw new SerializationException();
            }
            SerializationInfo si = new SerializationInfo(typeof(MemberInfoSerializationHolder), new FormatterConverter());
            si.AddValue("MemberType", (int)Int32.Parse(args[0]), typeof(Int32));
            si.AddValue("Name", args[1], typeof(String));
            si.AddValue("AssemblyName", args[2], typeof(String));
            si.AddValue("ClassName", args[3]);
            si.AddValue("Signature", args[4]);
            StreamingContext sc = new StreamingContext(StreamingContextStates.All);
            return (MethodBase)new MemberInfoSerializationHolder(si, sc).GetRealObject(sc);
        }

        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.GetObjectData"]/*' />
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            if (_className==null) {
                _className=GetClassName();
            }
    
            if (_stackTrace!=null) {
                if (_stackTraceString==null) {
                    _stackTraceString = Environment.GetStackTrace(this);
                }
                if (_exceptionMethod==null) {
                    _exceptionMethod = InternalGetMethod(_stackTrace);
                }
            }

            if (_source == null) {
                _source = Source; // Set the Source information correctly before serialization
            }
    
            info.AddValue("ClassName", _className, typeof(String));
            info.AddValue("Message", _message, typeof(String));
            info.AddValue("InnerException", _innerException, typeof(Exception));
            info.AddValue("HelpURL", _helpURL, typeof(String));
            info.AddValue("StackTraceString", _stackTraceString, typeof(String));
            info.AddValue("RemoteStackTraceString", _remoteStackTraceString, typeof(String));
            info.AddValue("RemoteStackIndex", _remoteStackIndex, typeof(Int32));
            info.AddValue("ExceptionMethod", GetExceptionMethodString(), typeof(String));
            info.AddValue("HResult", HResult);
            info.AddValue("Source", _source, typeof(String));
        }

        // This is used by remoting to preserve the server side stack trace
        // by appending it to the message ... before the exception is rethrown
        // at the client call site.
        internal Exception PrepForRemoting()
        {
            String tmp = null;

            if (_remoteStackIndex == 0)
            {
                tmp = "\nServer stack trace: \n"
                    + StackTrace 
                    + "\n\nException rethrown at ["+_remoteStackIndex+"]: \n";
            }
            else
            {
                tmp = StackTrace 
                    + "\n\nException rethrown at ["+_remoteStackIndex+"]: \n";
            }

            _remoteStackTraceString = tmp;
            _remoteStackIndex++;
            return this;
        }
    
        private String _className;  //Needed for serialization.  Talk to JRoxe before removing.
        private MethodBase _exceptionMethod;  //Needed for serialization.  Talk to JRoxe before removing.
        private String _exceptionMethodString; //Needed for serialization.  Talk to JRoxe before removing.
        internal String _message;
        private Exception _innerException;
        private String _helpURL;
        private Object _stackTrace;
        private String _stackTraceString; //Needed for serialization.  Talk to JRoxe before removing.
        private String _remoteStackTraceString;
        private int _remoteStackIndex;

        // @MANAGED: HResult is used from within the EE!  Rename with care - check VM directory
        internal int _HResult;     // HResult

        /// <include file='doc\Exception.uex' path='docs/doc[@for="Exception.HResult"]/*' />
        protected int HResult
        {
            get
            {
                return _HResult;
            }
            set
            {
                _HResult = value;
            }
        }
        
        private String _source;         // Obscure VB thing.  Do they still need this?
        // WARNING: Don't delete/rename _xptrs and _xcode - used by functions
        // on Marshal class.  Native functions are in COMUtilNative.cpp & AppDomain
        private IntPtr _xptrs;             // Internal EE stuff - ask Jennifer Hamilton
        private int _xcode;             // Internal EE stuff - ask Jennifer Hamilton
        private const int _COMPlusExceptionCode = unchecked((int)0xe0434f4d);   // Win32 exception code for COM+ exceptions

        internal virtual String InternalToString()
        {
            try 
            {
                SecurityPermission sp= new SecurityPermission(SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy);
                sp.Assert();
            }
            catch (Exception) 
            {
            }
            return ToString();
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\icustomformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  ICustomFormatter
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Marks a class as providing special formatting
**
** Date:  July 19, 1999
**
===========================================================*/
namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\ICustomFormatter.uex' path='docs/doc[@for="ICustomFormatter"]/*' />
    public interface ICustomFormatter
    {
    	/// <include file='doc\ICustomFormatter.uex' path='docs/doc[@for="ICustomFormatter.Format"]/*' />
	// Interface does not need to be marked with the serializable attribute
    	String Format (String format, Object arg, IFormatProvider formatProvider);
    	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\icloneable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ICloneable
**
** This interface is implemented by classes that support cloning.
**
===========================================================*/
namespace System {
    
	using System;
    // Defines an interface indicating that an object may be cloned.  Only objects 
    // that implement ICloneable may be cloned. The interface defines a single 
    // method which is called to create a clone of the object.   Object defines a method
    // MemberwiseClone to support default clone operations.
    // 
    /// <include file='doc\ICloneable.uex' path='docs/doc[@for="ICloneable"]/*' />
    public interface ICloneable
    {
    	/// <include file='doc\ICloneable.uex' path='docs/doc[@for="ICloneable.Clone"]/*' />
		// Interface does not need to be marked with the serializable attribute
        // Make a new object which is a copy of the object instanced.  This object may be either
        // deep copy or a shallow copy depending on the implementation of clone.  The default
        // Object support for clone does a shallow copy.
        // 
    	Object Clone();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\idisposable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IDisposable
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Interface for assisting with deterministic finalization.
**
** Date:  September 29, 2000
** 
===========================================================*/
namespace System {
    // IDisposable is an attempt at helping to solve problems with deterministic
    // finalization.  The GC of course doesn't leave any way to deterministically
    // know when a finalizer will run.  This forces classes that hold onto OS
    // resources or some sort of important state (such as a FileStream or a 
    // network connection) to provide a Close or Dispose method so users can 
    // run clean up code deterministically.  We have formalized this into an 
    // interface with one method.  Classes may privately implement IDisposable and
    // provide a Close method instead, if that name is by far the expected name
    // for objects in that domain (ie, you don't Dispose of a FileStream, you Close
    // it).
    //
    // This interface could be theoretically used as a marker by a compiler to 
    // ensure a disposable object has been cleaned up along all code paths if it's 
    // been allocated in that method, though in practice any compiler that 
    // draconian may tick off any number of people.  Perhaps an external tool (like
    // like Purify or BoundsChecker) could do this.  Instead, C# has added a using 
    // clause, which will generate a try/finally statement where the resource 
    // passed into the using clause will always have it's Dispose method called.  
    // Syntax is using(FileStream fs = ...) { .. };
    //
    // Dispose should meet the following conditions:
    // 1) Be safely callable multiple times
    // 2) Release any resources associated with the instance
    // 3) Call the base class's Dispose method, if necessary
    // 4) Suppress finalization of this class to help the GC by reducing the
    //    number of objects on the finalization queue.
    // 5) Dispose shouldn't generally throw exceptions, except for very serious 
    //    errors that are particularly unexpected. (ie, OutOfMemoryException)  
    //    Ideally, nothing should go wrong with your object by calling Dispose.
    //
    // If possible, a class should define a finalizer that calls Dispose.
    // However, in many situations, this is impractical.  For instance, take the
    // classic example of a Stream and a StreamWriter (which has an internal 
    // buffer of data to write to the Stream).  If both objects are collected 
    // before Close or Dispose has been called on either, then the GC may run the
    // finalizer for the Stream first, before the StreamWriter.  At that point, any
    // data buffered by the StreamWriter cannot be written to the Stream.  In this
    // case, it doesn't make much sense to provide a finalizer on the StreamWriter
    // since you cannot solve this problem correctly.  
    /// <include file='doc\IDisposable.uex' path='docs/doc[@for="IDisposable"]/*' />
    public interface IDisposable {
        /// <include file='doc\IDisposable.uex' path='docs/doc[@for="IDisposable.Dispose"]/*' />
        void Dispose();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\iformatprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: IFormatProvider
**
** Author: Jay Roxe
**
** Purpose: Notes a class which knows how to return formatting information
**
** Date: October 25, 2000
**
============================================================*/
namespace System {
    
	using System;
    /// <include file='doc\IFormatProvider.uex' path='docs/doc[@for="IFormatProvider"]/*' />
    public interface IFormatProvider
    {
        /// <include file='doc\IFormatProvider.uex' path='docs/doc[@for="IFormatProvider.GetFormat"]/*' />
	// Interface does not need to be marked with the serializable attribute
        Object GetFormat(Type formatType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\int32.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Int32
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A representation of a 32 bit 2's complement 
**          integer.
**
** Date: July 23, 1998
** 
===========================================================*/
namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.InteropServices;

	/// <include file='doc\Int32.uex' path='docs/doc[@for="Int32"]/*' />
    [Serializable, System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)] 
	public struct Int32 : IComparable, IFormattable, IConvertible
    {
        internal int m_value;
    
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.MaxValue"]/*' />
        public const int MaxValue = 0x7fffffff;
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.MinValue"]/*' />
        public const int MinValue = unchecked((int)0x80000000);
	
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this < object, equal to zero
        // if this == object, and greater than one if this > object.
        // null is considered to be less than any instance.
        // If object is not of type Int32, this method throws an ArgumentException.
        // 
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (value is Int32) {
    			// Need to use compare because subtraction will wrap
    			// to positive for very large neg numbers, etc.
    			int i = (int)value;
                if (m_value < i) return -1;
                if (m_value > i) return 1;
                return 0;
            }
            throw new ArgumentException (Environment.GetResourceString("Arg_MustBeInt32"));
        }
    
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is Int32)) {
                return false;
            }
            return m_value == ((Int32)obj).m_value;
        }

        // The absolute value of the int contained.
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.GetHashCode"]/*' />
        public override int GetHashCode() {
            return m_value;
        }
    	

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.ToString"]/*' />
        public override String ToString() {
            return ToString(null, null);
        }


        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }
    
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatInt32(m_value, format, NumberFormatInfo.GetInstance(provider));
        }
    
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.Parse"]/*' />
        public static int Parse(String s) {
            return Parse(s, NumberStyles.Integer, null);
        }
    
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.Parse1"]/*' />
        public static int Parse(String s, NumberStyles style) {
			NumberFormatInfo.ValidateParseStyle(style);
		    return Parse(s, style, null);
        }

    	// Parses an integer from a String in the given style.  If
    	// a NumberFormatInfo isn't specified, the current culture's 
    	// NumberFormatInfo is assumed.
    	// 
    	/// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.Parse2"]/*' />
    	public static int Parse(String s, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
            return Number.ParseInt32(s, NumberStyles.Integer, info);
        }
    
    	// Parses an integer from a String in the given style.  If
    	// a NumberFormatInfo isn't specified, the current culture's 
    	// NumberFormatInfo is assumed.
    	// 
    	/// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.Parse3"]/*' />
    	public static int Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
			NumberFormatInfo.ValidateParseStyle(style);
            return Number.ParseInt32(s, style, info);
        }
		/// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.ToString3"]/*' />
		public String ToString(IFormatProvider provider) {
            return ToString(null, provider);
        }
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Int32;
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Int32", "DateTime"));
        }

        /// <include file='doc\Int32.uex' path='docs/doc[@for="Int32.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = 0;	
    	}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\indexoutofrangeexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: IndexOutOfRangeException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Exception class for invalid array indices.
**
** Date: March 24, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\IndexOutOfRangeException.uex' path='docs/doc[@for="IndexOutOfRangeException"]/*' />
    [Serializable()] public sealed class IndexOutOfRangeException : SystemException {
        /// <include file='doc\IndexOutOfRangeException.uex' path='docs/doc[@for="IndexOutOfRangeException.IndexOutOfRangeException"]/*' />
        public IndexOutOfRangeException() 
            : base(Environment.GetResourceString("Arg_IndexOutOfRangeException")) {
    		SetErrorCode(__HResults.COR_E_INDEXOUTOFRANGE);
        }
    
        /// <include file='doc\IndexOutOfRangeException.uex' path='docs/doc[@for="IndexOutOfRangeException.IndexOutOfRangeException1"]/*' />
        public IndexOutOfRangeException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_INDEXOUTOFRANGE);
        }
    	
        /// <include file='doc\IndexOutOfRangeException.uex' path='docs/doc[@for="IndexOutOfRangeException.IndexOutOfRangeException2"]/*' />
        public IndexOutOfRangeException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_INDEXOUTOFRANGE);
        }

        internal IndexOutOfRangeException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\int16.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Int16.cool
**
** Author: Jay Roxe (jroxe) and Daryl Olander (darylo)
**
** Purpose: This class will encapsulate a short and provide an
**			Object representation of it.
**
** Date:  August 3, 1998
** 
===========================================================*/

namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.InteropServices;

    /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16"]/*' />
    [Serializable, System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)] public struct Int16 : IComparable, IFormattable, IConvertible
    {
        internal short m_value;
    
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.MaxValue"]/*' />
        public const short MaxValue = (short)0x7FFF;
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.MinValue"]/*' />
        public const short MinValue = unchecked((short)0x8000);
	    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type Int16, this method throws an ArgumentException.
        // 
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
    
            if (value is Int16) {
                return m_value - ((Int16)value).m_value;
            }
    
            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeInt16"));
        }
    
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is Int16)) {
                return false;
            }
            return m_value == ((Int16)obj).m_value;
        }
        
        // Returns a HashCode for the Int16
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.GetHashCode"]/*' />
        public override int GetHashCode() {
            return ((int)((ushort)m_value) | (((int)m_value) << 16));
        }
    

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.ToString"]/*' />
        public override String ToString() {
            return ToString(null,null);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }
    
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            if (m_value<0 && format!=null && format.Length>0 && (format[0]=='X' || format[0]=='x')) {
                uint temp = (uint)(m_value & 0x0000FFFF);
                return Number.FormatUInt32(temp,format, NumberFormatInfo.GetInstance(provider));
            }
            return Number.FormatInt32(m_value, format, NumberFormatInfo.GetInstance(provider));
        }
    
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.Parse"]/*' />
        public static short Parse(String s) {
            return Parse(s, NumberStyles.Integer, null);
        }
    
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.Parse1"]/*' />
        public static short Parse(String s, NumberStyles style) {
			NumberFormatInfo.ValidateParseStyle(style);
            return Parse(s, style, null);
        }


        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.Parse2"]/*' />
        public static short Parse(String s, IFormatProvider provider) {
            return Parse(s, NumberStyles.Integer, provider);
        }


    	/// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.Parse3"]/*' />
    	public static short Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
            NumberFormatInfo.ValidateParseStyle(style);

			int i = Number.ParseInt32(s, style, info);

			// We need this check here since we don't allow signs to specified in hex numbers. So we fixup the result
			// for negative numbers
			if (((style & NumberStyles.AllowHexSpecifier) != 0) && (i <= UInt16.MaxValue)) // We are parsing a hexadecimal number
				return (short)i;
				
			if (i < MinValue || i > MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
		    return (short)i;
        }
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.ToString3"]/*' />
        public String ToString(IFormatProvider provider) {
            return ToString(null, NumberFormatInfo.GetInstance(provider));
        }
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Int16;
        }


        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Int16", "DateTime"));
        }

        /// <include file='doc\Int16.uex' path='docs/doc[@for="Int16.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = 0;
		}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\iformattable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
    /// <include file='doc\IFormattable.uex' path='docs/doc[@for="IFormattable"]/*' />
    public interface IFormattable
    {
        /// <include file='doc\IFormattable.uex' path='docs/doc[@for="IFormattable.ToString"]/*' />
        String ToString(String format, IFormatProvider formatProvider);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\int64.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Int64.cool
**
** Author: Jay Roxe (jroxe) and Daryl Olander (darylo)
**
** Purpose: This class will encapsulate a long and provide an
**			Object representation of it.
**
** Date:  August 3, 1998
** 
===========================================================*/
namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.InteropServices;

	/// <include file='doc\Int64.uex' path='docs/doc[@for="Int64"]/*' />
    [Serializable, System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
	public struct Int64 : IComparable, IFormattable, IConvertible
    {
        internal long m_value;
    
        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.MaxValue"]/*' />
        public const long MaxValue = 0x7fffffffffffffffL;
        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.MinValue"]/*' />
        public const long MinValue = unchecked((long)0x8000000000000000L);

        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type Int64, this method throws an ArgumentException.
        // 
        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (value is Int64) {
    			// Need to use compare because subtraction will wrap
    			// to positive for very large neg numbers, etc.
    			long i = (long)value;
                if (m_value < i) return -1;
                if (m_value > i) return 1;
                return 0;
            }
            throw new ArgumentException (Environment.GetResourceString("Arg_MustBeInt64"));
        }
    
        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is Int64)) {
                return false;
            }
            return m_value == ((Int64)obj).m_value;
        }

        // The value of the lower 32 bits XORed with the uppper 32 bits.
        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.GetHashCode"]/*' />
        public override int GetHashCode() {
            return ((int)m_value ^ (int)(m_value >> 32));
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.ToString"]/*' />
        public override String ToString() {
            return ToString(null, null);
        }
    

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }

    
        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatInt64(m_value, format, NumberFormatInfo.GetInstance(provider));
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.Parse"]/*' />
        public static long Parse(String s) {
            return Parse(s, NumberStyles.Integer, null);
        }
    
        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.Parse1"]/*' />
        public static long Parse(String s, NumberStyles style) {
			NumberFormatInfo.ValidateParseStyle(style);
            return Parse(s, style, null);
        }


        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.Parse2"]/*' />
        public static long Parse(String s, IFormatProvider provider) {
            return Parse(s, NumberStyles.Integer, provider);
        }


    	// Parses a long from a String in the given style.  If
    	// a NumberFormatInfo isn't specified, the current culture's 
    	// NumberFormatInfo is assumed.
    	// 
    	/// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.Parse3"]/*' />
    	public static long Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
			NumberFormatInfo.ValidateParseStyle(style);
            return Number.ParseInt64(s, style, info);
        }
	    /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.ToString3"]/*' />
	    public String ToString(IFormatProvider provider)
        {
            return ToString(null, provider);
        }
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Int64;
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Int64", "DateTime"));
        }

        /// <include file='doc\Int64.uex' path='docs/doc[@for="Int64.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = 0;	
    	}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\internal.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** This file exists to contain module-level custom attributes
**  for the BCL.
**
** Author: Bill Evans (billev)
**
** Date:  March 9, 2000
** 
===========================================================*/
using System.Runtime.InteropServices;

[assembly:Guid("BED7F4EA-1A96-11d2-8F08-00A0C9A6186D")]
[assembly:System.CLSCompliantAttribute(true)]
[assembly:System.Reflection.AssemblyDescriptionAttribute("Common Language Runtime Library")]

// The following attribute are required to ensure COM compatibility.
[assembly:System.Runtime.InteropServices.ComCompatibleVersion(1, 0, 3300, 0)]
[assembly:System.Runtime.InteropServices.TypeLibVersion(1, 10)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\intptr.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  IntPtr
**
** Author: Rajesh Chandrashekaran
**
** Purpose: Platform independent integer
**
** Date: July 21, 2000
** 
===========================================================*/

namespace System {
    
	using System;
	using System.Globalization;
    using System.Runtime.Serialization;
	
    /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr"]/*' />
    [Serializable]
    public struct IntPtr : ISerializable
	{

		unsafe private void* m_value; // The compiler treats void* closest to uint hence explicit casts are required to preserve int behavior
				
        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.Zero"]/*' />
        public static readonly IntPtr Zero = new IntPtr(0);

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.IntPtr"]/*' />
		public unsafe IntPtr(int value)
		{
			m_value = (void *)value;
		}
	
		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.IntPtr1"]/*' />
		public unsafe IntPtr(long value)
		{
			#if WIN32
			    m_value = (void *)checked((int)value);
			#else
				m_value = (void *)value;
			#endif
		}

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.IntPtr2"]/*' />
        [CLSCompliant(false)]
        public unsafe IntPtr(void* value)
        {
            m_value = value;
        }


        private unsafe IntPtr(SerializationInfo info, StreamingContext context) {
            long l = info.GetInt64("value");

            if (Size==4 && (l>Int32.MaxValue || l<Int32.MinValue)) {
                throw new ArgumentException(Environment.GetResourceString("Serialization_InvalidPtrValue"));
            }

            m_value = (void *)l;
        }

        unsafe void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            info.AddValue("value", (long)((int)m_value));
        }

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.Equals"]/*' />
        public unsafe override bool Equals(Object obj) {
			if (obj is IntPtr) {
				return (m_value == ((IntPtr)obj).m_value);
            }
			return false;
		}
    
       	/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.GetHashCode"]/*' />
       	public unsafe override int GetHashCode() {
            return (int)m_value;
        }

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.ToInt32"]/*' />
        public unsafe int ToInt32() {
            #if WIN32
                return (int)m_value;
            #else
                return checked((int) m_value);
            #endif
        }

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.ToInt64"]/*' />
        public unsafe long ToInt64() {
            #if WIN32
                return (long)(int)m_value;
            #else
				return (long)m_value;
			#endif
        }

    	/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.ToString"]/*' />
    	public unsafe override String ToString() {
			#if WIN32
				return ((int)m_value).ToString();
			#else
				return ((long)m_value).ToString();
			#endif
        }

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorIntPtr"]/*' />
        public static explicit operator IntPtr (int value) 
		{
			return new IntPtr(value);
		}

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorIntPtr1"]/*' />
		public static explicit operator IntPtr (long value) 
		{
			return new IntPtr(value);
		}

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorIntPtr2"]/*' />
        [CLSCompliant(false)]
        public static unsafe explicit operator IntPtr (void* value)
        {
            return new IntPtr(value);
        }

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorvoidMUL"]/*' />
        [CLSCompliant(false)]
        public static unsafe explicit operator void* (IntPtr value)
        {
            return value.ToPointer();
        }

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorint"]/*' />
		public unsafe static explicit operator int (IntPtr  value) 
		{
            #if WIN32
                return (int)value.m_value;
            #else
                return checked((int)value.m_value);
            #endif
		}

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorlong"]/*' />
		public unsafe static explicit operator long (IntPtr  value) 
		{
            #if WIN32
                return (long)(int)value.m_value;
            #else
				return (long)value.m_value;
			#endif
		}

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorEQ"]/*' />
		public unsafe static bool operator == (IntPtr value1, IntPtr value2) 
		{
			return value1.m_value == value2.m_value;
		}

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorNE"]/*' />
		public unsafe static bool operator != (IntPtr value1, IntPtr value2) 
		{
			return value1.m_value != value2.m_value;
		}

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.Size"]/*' />
		public static int Size
		{
			get
			{
				#if WIN32
					return 4;
				#else
					return 8;
				#endif
			}
		}
    

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.ToPointer"]/*' />
        [CLSCompliant(false)]
        public unsafe void* ToPointer()
        {
            return m_value;
        }
/*
        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorIntPtr3"]/*' />
        [CLSCompliant(false)]
        public static explicit operator IntPtr (uint value) 
        {
		    return new IntPtr(value);
        }
        
        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorIntPtr4"]/*' />
        [CLSCompliant(false)]
        public static explicit operator IntPtr (ulong value) 
        {
            return new IntPtr(value);
        }

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatoruint"]/*' />
        [CLSCompliant(false)]
        public unsafe static explicit operator uint (IntPtr value)
        {
            return value.ToUInt32();
        }

		/// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.operatorulong"]/*' />
        [CLSCompliant(false)]
        public unsafe static explicit operator ulong (IntPtr value)
        {
            return value.ToUInt64();
        }

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.ToUInt32"]/*' />
        [CLSCompliant(false)]
        public unsafe uint ToUInt32()
        {
            return checked((uint)m_value);
        }

        /// <include file='doc\IntPtr.uex' path='docs/doc[@for="IntPtr.ToUInt64"]/*' />
        [CLSCompliant(false)]
        public unsafe ulong ToUInt64()
        {
            return (ulong)m_value;
        }
*/     
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\invalidprogramexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: InvalidProgramException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: The exception class for programs with invalid IL or bad metadata.
**
** Date: November 21, 2000
**
=============================================================================*/

namespace System {

	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\InvalidProgramException.uex' path='docs/doc[@for="InvalidProgramException"]/*' />
    [Serializable]
    public sealed class InvalidProgramException : SystemException {
        /// <include file='doc\InvalidProgramException.uex' path='docs/doc[@for="InvalidProgramException.InvalidProgramException"]/*' />
        public InvalidProgramException() 
            : base(Environment.GetResourceString("InvalidProgram_Default")) {
    		SetErrorCode(__HResults.COR_E_INVALIDPROGRAM);
        }
    
        /// <include file='doc\InvalidProgramException.uex' path='docs/doc[@for="InvalidProgramException.InvalidProgramException1"]/*' />
        public InvalidProgramException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_INVALIDPROGRAM);
        }
    
        /// <include file='doc\InvalidProgramException.uex' path='docs/doc[@for="InvalidProgramException.InvalidProgramException2"]/*' />
        public InvalidProgramException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_INVALIDPROGRAM);
        }

        internal InvalidProgramException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\invalidcastexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: InvalidCastException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Exception class for bad cast conditions!
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\InvalidCastException.uex' path='docs/doc[@for="InvalidCastException"]/*' />
    [Serializable()] public class InvalidCastException : SystemException {
        /// <include file='doc\InvalidCastException.uex' path='docs/doc[@for="InvalidCastException.InvalidCastException"]/*' />
        public InvalidCastException() 
            : base(Environment.GetResourceString("Arg_InvalidCastException")) {
    		SetErrorCode(__HResults.COR_E_INVALIDCAST);
        }
    
        /// <include file='doc\InvalidCastException.uex' path='docs/doc[@for="InvalidCastException.InvalidCastException1"]/*' />
        public InvalidCastException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_INVALIDCAST);
        }
    	
        /// <include file='doc\InvalidCastException.uex' path='docs/doc[@for="InvalidCastException.InvalidCastException2"]/*' />
        public InvalidCastException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_INVALIDCAST);
        }

        /// <include file='doc\InvalidCastException.uex' path='docs/doc[@for="InvalidCastException.InvalidCastException3"]/*' />
        protected InvalidCastException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\iserviceobjectprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
    using System.Runtime.InteropServices;

    /// <include file='doc\IServiceObjectProvider.uex' path='docs/doc[@for="IServiceProvider"]/*' />
    [ComVisible(false)]
    public interface IServiceProvider
    {
        /// <include file='doc\IServiceObjectProvider.uex' path='docs/doc[@for="IServiceProvider.GetService"]/*' />
	// Interface does not need to be marked with the serializable attribute
        Object GetService(Type serviceType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\math.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Math
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Some floating-point math operations
**
** Date:  July 8, 1998
** 
===========================================================*/
namespace System {
    
    //This class contains only static members and doesn't require serialization.
	using System;
	using System.Runtime.CompilerServices;
    /// <include file='doc\Math.uex' path='docs/doc[@for="Math"]/*' />
    public sealed class Math {
    	
      // Prevent from begin created
      private Math() {}
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.PI"]/*' />
      public const double PI = 3.14159265358979323846;
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.E"]/*' />
      public const double E  = 2.7182818284590452354;
      
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Acos"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Acos(double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Asin"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Asin(double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Atan"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Atan(double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Atan2"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Atan2(double y,double x);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Cos"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Cos (double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sin"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Sin(double a);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Tan"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Tan(double a);
	  /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Cosh"]/*' />
	  [MethodImplAttribute(MethodImplOptions.InternalCall)]
	  public static extern double Cosh(double value);
	  /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sinh"]/*' />
	  [MethodImplAttribute(MethodImplOptions.InternalCall)]
	  public static extern double Sinh(double value);
	  /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Tanh"]/*' />
	  [MethodImplAttribute(MethodImplOptions.InternalCall)]
	  public static extern double Tanh(double value);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Round"]/*' />

      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Round(double a);

	  private static double NegativeZero = BitConverter.Int64BitsToDouble(unchecked((long)0x8000000000000000));

      private const int maxRoundingDigits = 15;
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Round2"]/*' />
      public static double Round(double value, int digits)
      {
           if ((digits < 0) || (digits > maxRoundingDigits))
               throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_RoundingDigits"));
           return InternalRound(value,digits);
      }

      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      private static extern double InternalRound(double value,int digits);


      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Round1"]/*' />
      public static Decimal Round(Decimal d)
	  {
		return Decimal.Round(d,0);
	  }

	  /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Round3"]/*' />
	  public static Decimal Round(Decimal d, int decimals)
	  {
	  	return Decimal.Round(d,decimals);
	  }

	  /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Ceiling"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Ceiling(double a);

      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Floor"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Floor(double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sqrt"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Sqrt(double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Log"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Log (double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Log10"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Log10(double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Exp"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Exp(double d);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Pow"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public static extern double Pow(double x, double y);
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.IEEERemainder"]/*' />
	  public static double IEEERemainder(double x, double y) {
        double val = (x-(y*(Math.Round(x/y))));
	    if (val == 0) {
		    if (x < 0) {
			    return NegativeZero; // this can be turned into a static if people like
		    }
	    }
	    return val;			
	  }

    
      /*================================Abs=========================================
      **Returns the absolute value of it's argument.
      ============================================================================*/
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Abs"]/*' />
      [CLSCompliant(false)]
      public static sbyte Abs(sbyte value) {
        if (value >= 0)
                return value;
        else
                return AbsHelper(value);        
      }

      private static sbyte AbsHelper(sbyte value)
      {
        if (value < 0) {
                if (value == SByte.MinValue)
                        throw new OverflowException(Environment.GetResourceString("Overflow_NegateTwosCompNum"));
                return ((sbyte)(-value));
        }
        return value;
      }
 
           
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Abs1"]/*' />
      public static short Abs(short value) {
        if (value >= 0)
                return value;
        else
                return AbsHelper(value);        
      }
        
      private static short AbsHelper(short value) {
        if (value < 0) {
                if (value == Int16.MinValue)
                        throw new OverflowException(Environment.GetResourceString("Overflow_NegateTwosCompNum"));
                return (short) -value;
        }
        return value;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Abs2"]/*' />
      public static int Abs(int value) {
        if (value >= 0)
                return value;
        else
                return AbsHelper(value);        
      }
        
      private static int AbsHelper(int value) {
        if (value < 0) {
                if (value == Int32.MinValue)
                        throw new OverflowException(Environment.GetResourceString("Overflow_NegateTwosCompNum"));
                return -value;
        }
        return value;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Abs3"]/*' />
      public static long Abs(long value) {
        if (value >= 0)
                return value;
        else
                return AbsHelper(value);        
      }
        
      private static long AbsHelper(long value) {
        if (value < 0) {
                if (value == Int64.MinValue)
                        throw new OverflowException(Environment.GetResourceString("Overflow_NegateTwosCompNum"));
                return -value;
        }
        return value;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Abs4"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      extern public static float Abs(float value);
    	// This is special code to handle NaN (We need to make sure NaN's aren't 
    	// negated).  In Cool, the else clause here should always be taken if 
    	// value is NaN, since the normal case is taken if and only if value < 0.
    	// To illustrate this completely, a compiler has translated this into:
    	// "load value; load 0; bge; ret -value ; ret value".  
    	// The bge command branches for comparisons with the unordered NaN.  So 
    	// it runs the else case, which returns +value instead of negating it. 
    	//  return (value < 0) ? -value : value;
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Abs5"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      extern public static double Abs(double value);
    	// This is special code to handle NaN (We need to make sure NaN's aren't 
    	// negated).  In Cool, the else clause here should always be taken if 
    	// value is NaN, since the normal case is taken if and only if value < 0.
    	// To illustrate this completely, a compiler has translated this into:
    	// "load value; load 0; bge; ret -value ; ret value".  
    	// The bge command branches for comparisons with the unordered NaN.  So 
    	// it runs the else case, which returns +value instead of negating it. 
    	// return (value < 0) ? -value : value;

      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Abs6"]/*' />
      public static Decimal Abs(Decimal value)
	  {
		return Decimal.Abs(value);
	  }
    
      /*================================MAX=========================================
      **Returns the larger of val1 and val2
      ============================================================================*/
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max"]/*' />
      [CLSCompliant(false)]
      public static sbyte Max(sbyte val1, sbyte val2) {
        return (val1>=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max1"]/*' />
      public static byte Max(byte val1, byte val2) {
        return (val1>=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max2"]/*' />
      public static short Max(short val1, short val2) {
        return (val1>=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max3"]/*' />
    	[CLSCompliant(false)]
      public static ushort Max(ushort val1, ushort val2) {
        return (val1>=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max4"]/*' />
      public static int Max(int val1, int val2) {
        return (val1>=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max5"]/*' />
      [CLSCompliant(false)]
      public static uint Max(uint val1, uint val2) {
        return (val1>=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max6"]/*' />
      public static long Max(long val1, long val2) {
        return (val1>=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max7"]/*' />
    	[CLSCompliant(false)]
      public static ulong Max(ulong val1, ulong val2) {
        return (val1>=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max8"]/*' />
      public static float Max(float val1, float val2) {
        if (val1 > val2)
            return val1;

        if (Single.IsNaN(val1))
            return val1;

        return val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max9"]/*' />
      public static double Max(double val1, double val2) {
        if (val1 > val2)
            return val1;

        if (Double.IsNaN(val1))
            return val1;

        return val2;
      }
    
	  /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Max10"]/*' />
	  public static Decimal Max(Decimal val1, Decimal val2) {
        return Decimal.Max(val1,val2);
      }

      /*================================MIN=========================================
      **Returns the smaller of val1 and val2.
      ============================================================================*/
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min"]/*' />
      [CLSCompliant(false)]
      public static sbyte Min(sbyte val1, sbyte val2) {
        return (val1<=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min1"]/*' />
      public static byte Min(byte val1, byte val2) {
        return (val1<=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min2"]/*' />
      public static short Min(short val1, short val2) {
        return (val1<=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min3"]/*' />
      [CLSCompliant(false)]
      public static ushort Min(ushort val1, ushort val2) {
        return (val1<=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min4"]/*' />
      public static int Min(int val1, int val2) {
        return (val1<=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min5"]/*' />
      [CLSCompliant(false)]
      public static uint Min(uint val1, uint val2) {
        return (val1<=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min6"]/*' />
      public static long Min(long val1, long val2) {
        return (val1<=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min7"]/*' />
      [CLSCompliant(false)]
      public static ulong Min(ulong val1, ulong val2) {
        return (val1<=val2)?val1:val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min8"]/*' />
      public static float Min(float val1, float val2) {
        if (val1 < val2)
            return val1;

        if (Single.IsNaN(val1))
            return val1;

        return val2;
      }
    
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min9"]/*' />
     public static double Min(double val1, double val2) {
        if (val1 < val2)
            return val1;

        if (Double.IsNaN(val1))
            return val1;

        return val2;
      }
    
	  /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Min10"]/*' />
	  public static Decimal Min(Decimal val1, Decimal val2) {
        return Decimal.Min(val1,val2);
      }
    
      /*=====================================Log======================================
      **
      ==============================================================================*/
      /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Log1"]/*' />
      public static double Log(double a, double newBase) {
        return (Log(a)/Log(newBase));
      }
    
          
        // Sign function for VB.  Returns -1, 0, or 1 if the sign of the number
        // is negative, 0, or positive.  Throws for floating point NaN's.
        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sign"]/*' />
		[CLSCompliant(false)]
        public static int Sign(sbyte value)
        {
            if (value < 0)
                return -1;
            else if (value > 0)
                return 1;
            else
                return 0;
        }


        // Sign function for VB.  Returns -1, 0, or 1 if the sign of the number
        // is negative, 0, or positive.  Throws for floating point NaN's.
        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sign1"]/*' />
        public static int Sign(short value)
        {
            if (value < 0)
                return -1;
            else if (value > 0)
                return 1;
            else
                return 0;
        }

        // Sign function for VB.  Returns -1, 0, or 1 if the sign of the number
        // is negative, 0, or positive.  Throws for floating point NaN's.
        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sign2"]/*' />
        public static int Sign(int value)
        {
            if (value < 0)
                return -1;
            else if (value > 0)
                return 1;
            else
                return 0;
        }

        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sign3"]/*' />
        public static int Sign(long value)
        {
            if (value < 0)
                return -1;
            else if (value > 0)
                return 1;
            else
                return 0;
        }

		/// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sign4"]/*' />
		public static int Sign (float value) 
		{
			if (value < 0)
                return -1;
            else if (value > 0)
                return 1;
            else if (value == 0)
                return 0;
			throw new ArithmeticException(Environment.GetResourceString("Arithmetic_NaN"));
		}

        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sign5"]/*' />
        public static int Sign(double value)
        {
            if (value < 0)
                return -1;
            else if (value > 0)
                return 1;
            else if (value == 0)
                return 0;
            throw new ArithmeticException(Environment.GetResourceString("Arithmetic_NaN"));
        }

        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.Sign6"]/*' />
        public static int Sign(Decimal value)
        {
            if (value < 0)
                return -1;
            else if (value > 0)
                return 1;
            else
                return 0;
        }

        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.BigMul"]/*' />
        public static long BigMul(int a, int b) {
	        return ((long)a) * b;
        }

        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.DivRem"]/*' />
        public static int DivRem(int a, int b, out int result) {
	        result =  a%b;
            return a/b;
        }

        /// <include file='doc\Math.uex' path='docs/doc[@for="Math.DivRem1"]/*' />
        public static long DivRem(long a, long b, out long result) {
	        result =  a%b;
            return a/b;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\invalidoperationexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: InvalidOperationException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception class for denoting an object was in a state that
** made calling a method illegal.
**
** Date: March 24, 1999
**
=============================================================================*/
namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\InvalidOperationException.uex' path='docs/doc[@for="InvalidOperationException"]/*' />
    [Serializable()] public class InvalidOperationException : SystemException
    {
        /// <include file='doc\InvalidOperationException.uex' path='docs/doc[@for="InvalidOperationException.InvalidOperationException"]/*' />
        public InvalidOperationException() 
            : base(Environment.GetResourceString("Arg_InvalidOperationException")) {
    		SetErrorCode(__HResults.COR_E_INVALIDOPERATION);
        }
        
        /// <include file='doc\InvalidOperationException.uex' path='docs/doc[@for="InvalidOperationException.InvalidOperationException1"]/*' />
        public InvalidOperationException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_INVALIDOPERATION);
        }
    
    	/// <include file='doc\InvalidOperationException.uex' path='docs/doc[@for="InvalidOperationException.InvalidOperationException2"]/*' />
    	public InvalidOperationException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_INVALIDOPERATION);
        }

        /// <include file='doc\InvalidOperationException.uex' path='docs/doc[@for="InvalidOperationException.InvalidOperationException3"]/*' />
        protected InvalidOperationException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\memberaccessexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// MemberAccessException
// Thrown when we try accessing a member that we cannot
// access, due to it being removed, private or something similar.
////////////////////////////////////////////////////////////////////////////////

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    // The MemberAccessException is thrown when trying to access a class
    // member fails.
    // 
    /// <include file='doc\MemberAccessException.uex' path='docs/doc[@for="MemberAccessException"]/*' />
    [Serializable()] public class MemberAccessException : SystemException {
    	
        // Creates a new MemberAccessException with its message string set to
        // the empty string, its HRESULT set to COR_E_MEMBERACCESS, 
        // and its ExceptionInfo reference set to null. 
    	/// <include file='doc\MemberAccessException.uex' path='docs/doc[@for="MemberAccessException.MemberAccessException"]/*' />
    	public MemberAccessException() 
            : base(Environment.GetResourceString("Arg_AccessException")) {
    		SetErrorCode(__HResults.COR_E_MEMBERACCESS);
        }
    	
        // Creates a new MemberAccessException with its message string set to
        // message, its HRESULT set to COR_E_ACCESS, 
        // and its ExceptionInfo reference set to null. 
        // 
        /// <include file='doc\MemberAccessException.uex' path='docs/doc[@for="MemberAccessException.MemberAccessException1"]/*' />
        public MemberAccessException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_MEMBERACCESS);
        }
    	
        /// <include file='doc\MemberAccessException.uex' path='docs/doc[@for="MemberAccessException.MemberAccessException2"]/*' />
        public MemberAccessException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_MEMBERACCESS);
        }

        /// <include file='doc\MemberAccessException.uex' path='docs/doc[@for="MemberAccessException.MemberAccessException3"]/*' />
        protected MemberAccessException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\marshalbyrefobject.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    MarshalByRefObject.cs
**
** Author(s):   Tarun Anand    (TarunA)
**              
**
** Purpose: Defines the root type for all marshal by reference aka
**          AppDomain bound types
**          
**
** Date:    Sep 30, 1999
**
===========================================================*/
namespace System {
    
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Lifetime;
    using System.Runtime.Remoting.Services;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;

    /// <include file='doc\MarshalByRefObject.uex' path='docs/doc[@for="MarshalByRefObject"]/*' />
    [Serializable()]
    public abstract class MarshalByRefObject 
    {
        private Object __identity;        
        
        internal IntPtr GetComIUnknown(bool fIsBeingMarshalled)
        {
            IntPtr pUnk;
            if(RemotingServices.IsTransparentProxy(this))
            {
                pUnk = RemotingServices.GetRealProxy(this).GetCOMIUnknown(fIsBeingMarshalled);
            }
            else
            {
                pUnk = Marshal.GetIUnknownForObject(this);
            }
            return pUnk;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern IntPtr GetComIUnknown(MarshalByRefObject o);

        internal byte[] GetDCOMBuffer()
        {
            return Marshal.GetDCOMBuffer(this);
        }

        // (1) for remote COM objects IsInstance of can't be executed on
        // the proxies, so we need this method to be executed on the 
        // actual object.
        // (2) for remote objects that do not have the complete type information
        // we intercept calls to check the type and execute it on the actual
        // object
        internal bool IsInstanceOfType(Type T)
        {
            return T.IsInstanceOfType(this);
        }

        // for remote COM Objects the late binding methods can't be
        // executed on proxies, so we need this method to execute on
        // the real object
        internal Object InvokeMember(String name,BindingFlags invokeAttr,Binder binder, 
                            Object[] args,ParameterModifier[] modifiers,CultureInfo culture,String[] namedParameters)
        {
            Type t = GetType();
            
            // Sanity check
            if(!t.IsCOMObject)
                throw new InvalidOperationException(Environment.GetResourceString("Arg_InvokeMember"));

            // Call into the runtime to invoke on the COM object.
            return t.InvokeMember(name, invokeAttr, binder, this, args, modifiers, culture, namedParameters);
        }

        // A helper routine to extract the identity either from the marshalbyrefobject base
        // class if it is not a proxy, otherwise from the real proxy.
        // A flag is set to indicate whether the object passed in is a server or a proxy
        internal static Identity GetIdentity(MarshalByRefObject obj, out bool fServer)
        {
            fServer = true;
            Identity id = null;

            if(null != obj)
            {
                if(!RemotingServices.IsTransparentProxy(obj))
                {
                    id = (Identity)obj.__identity;
                }
                else
                {                    
                    // Toggle flag to indicate that we have a proxy
                    fServer = false;
                    id = RemotingServices.GetRealProxy(obj).IdentityObject;
                }
            }

            return id;
        }

        // Another helper that delegates to the helper above
        internal static Identity GetIdentity(MarshalByRefObject obj)
        {
            BCLDebug.Assert(!RemotingServices.IsTransparentProxy(obj), "Use this method for server objects only");

            bool fServer;            
            return GetIdentity(obj, out fServer);
        }

        internal ServerIdentity __RaceSetServerIdentity(ServerIdentity id)
        {
            if (__identity == null)
            {
                if (Interlocked.CompareExchange(ref __identity, id, null)
                    == null)
                {
                    // For strictly MBR types, the TP field in the identity
                    // holds the real server
                    if (!id.IsContextBound)
                    {
                        id.RaceSetTransparentProxy(this);
                    }
                }
            }
            return (ServerIdentity)__identity;
        }


        internal void __ResetServerIdentity()
        {
            __identity = null;
        }
        
       // This method is used return a lifetime service object which
       // is used to control the lifetime policy to the object.
       // For the default Lifetime service this will be an object of typoe ILease.
       // 
        /// <include file='doc\MarshalByRefObject.uex' path='docs/doc[@for="MarshalByRefObject.GetLifetimeService"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public Object GetLifetimeService()
        {
            return LifetimeServices.GetLease(this); 
        }

       // This method is used return lifetime service object. This method
       // can be overridden to return a LifetimeService object with properties unique to
       // this object.
       // For the default Lifetime service this will be an object of type ILease.
       // 
        /// <include file='doc\MarshalByRefObject.uex' path='docs/doc[@for="MarshalByRefObject.InitializeLifetimeService"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public virtual Object InitializeLifetimeService()
        {
            return LifetimeServices.GetLeaseInitial(this);
        }

        /// <include file='doc\MarshalByRefObject.uex' path='docs/doc[@for="MarshalByRefObject.CreateObjRef"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public virtual ObjRef CreateObjRef(Type requestedType)
        {
            if(__identity == null)
            {
                throw new RemotingException(Environment.GetResourceString(
                    "Remoting_NoIdentityEntry"));
            }            
            return new ObjRef(this, requestedType);
        }


        // This is for casting interop ObjRefLite's.
        // ObjRefLite's have been deprecated. These methods are not exposed 
        // through any user APIs and would be removed in the future
        internal bool CanCastToXmlType(String xmlTypeName, String xmlTypeNamespace)
        {
            Type castType = SoapServices.GetInteropTypeFromXmlType(xmlTypeName, xmlTypeNamespace);
            if (castType == null)
            {
                String typeNamespace;
                String assemblyName;
                if (!SoapServices.DecodeXmlNamespaceForClrTypeNamespace(xmlTypeNamespace, 
                        out typeNamespace, out assemblyName))
                    return false;

                String typeName;
                if ((typeNamespace != null) && (typeNamespace.Length > 0))
                    typeName = typeNamespace + "." + xmlTypeName;
                else
                    typeName = xmlTypeName;

                try
                {
                    Assembly asm = Assembly.Load(assemblyName);
                    castType = asm.GetTypeInternal(typeName, false, false, false);
                }
                catch 
                {
                    return false;
                }
            }

            if (castType != null)
                return castType.IsAssignableFrom(this.GetType());

            return false;
        } // CanCastToXmlType

        // helper method for calling CanCastToXmlType
        // ObjRefLite's have been deprecated. These methods are not exposed 
        // through any user APIs and would be removed in the future
        internal static bool CanCastToXmlTypeHelper(Type castType, MarshalByRefObject o)
        {
            if (castType == null)
                throw new ArgumentNullException("castType");
        
            // MarshalByRefObject's can only be casted to MarshalByRefObject's or interfaces.
            if (!castType.IsInterface && !castType.IsMarshalByRef)
                return false;

            // figure out xml type name
            String xmlTypeName = null;
            String xmlTypeNamespace = null;
            if (!SoapServices.GetXmlTypeForInteropType(castType, out xmlTypeName, out xmlTypeNamespace))
            {
                // There's no registered interop type name, so just use the default.
                xmlTypeName = castType.Name;
                xmlTypeNamespace =
                    SoapServices.CodeXmlNamespaceForClrTypeNamespace(
                        castType.Namespace, castType.Module.Assembly.nGetSimpleName());
            }

            return o.CanCastToXmlType(xmlTypeName, xmlTypeNamespace);
        } // CanCastToXmlType
        
    }            
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\missingmethodexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: MissingMethodException
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The exception class for class loading failures.
**
** Date: April 23, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System.Runtime.CompilerServices;
    /// <include file='doc\MissingMethodException.uex' path='docs/doc[@for="MissingMethodException"]/*' />
    [Serializable()] public class MissingMethodException : MissingMemberException, ISerializable {
        /// <include file='doc\MissingMethodException.uex' path='docs/doc[@for="MissingMethodException.MissingMethodException"]/*' />
        public MissingMethodException() 
            : base(Environment.GetResourceString("Arg_MissingMethodException")) {
    		SetErrorCode(__HResults.COR_E_MISSINGMETHOD);
        }
    
        /// <include file='doc\MissingMethodException.uex' path='docs/doc[@for="MissingMethodException.MissingMethodException1"]/*' />
        public MissingMethodException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_MISSINGMETHOD);
        }
    
        /// <include file='doc\MissingMethodException.uex' path='docs/doc[@for="MissingMethodException.MissingMethodException2"]/*' />
        public MissingMethodException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_MISSINGMETHOD);
        }

        /// <include file='doc\MissingMethodException.uex' path='docs/doc[@for="MissingMethodException.MissingMethodException3"]/*' />
        protected MissingMethodException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    
    	/// <include file='doc\MissingMethodException.uex' path='docs/doc[@for="MissingMethodException.Message"]/*' />
    	public override String Message
        {
    		get {
    			if (ClassName == null) {
    				return base.Message;
    			} else {
    				// do any desired fixups to classname here.
                    return String.Format(Environment.GetResourceString("MissingMethod_Name",
                                                                       ClassName + "." + MemberName +
                                                                       (Signature != null ? " " + FormatSignature(Signature) : "")));
    			}
    		}
        }
    
        // Called to format signature
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String FormatSignature(byte [] signature);
    
    
    
        // Called from the EE
        private MissingMethodException(String className, String methodName, byte[] signature)
        {
            ClassName   = className;
            MemberName  = methodName;
            Signature   = signature;
        }
    
        /// <include file='doc\MissingMethodException.uex' path='docs/doc[@for="MissingMethodException.MissingMethodException4"]/*' />
        public MissingMethodException(String className, String methodName)
        {
            ClassName   = className;
            MemberName  = methodName;
        }
    
        // If ClassName != null, Message will construct on the fly using it
        // and the other variables. This allows customization of the
        // format depending on the language environment.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\methodaccessexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: MethodAccessException
**
** Purpose: The exception class for class loading failures.
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\MethodAccessException.uex' path='docs/doc[@for="MethodAccessException"]/*' />
    [Serializable] public class MethodAccessException : MemberAccessException {
        /// <include file='doc\MethodAccessException.uex' path='docs/doc[@for="MethodAccessException.MethodAccessException"]/*' />
        public MethodAccessException() 
            : base(Environment.GetResourceString("Arg_MethodAccessException")) {
    		SetErrorCode(__HResults.COR_E_METHODACCESS);
        }
    
        /// <include file='doc\MethodAccessException.uex' path='docs/doc[@for="MethodAccessException.MethodAccessException1"]/*' />
        public MethodAccessException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_METHODACCESS);
        }
    
        /// <include file='doc\MethodAccessException.uex' path='docs/doc[@for="MethodAccessException.MethodAccessException2"]/*' />
        public MethodAccessException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_METHODACCESS);
        }

        /// <include file='doc\MethodAccessException.uex' path='docs/doc[@for="MethodAccessException.MethodAccessException3"]/*' />
        protected MethodAccessException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\missingmemberexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: MissingMemberException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: The exception class for versioning problems with DLLS.
**
** Date: May 24, 1999
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System.Runtime.CompilerServices;
    /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException"]/*' />
    [Serializable] public class MissingMemberException : MemberAccessException, ISerializable {
        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.MissingMemberException"]/*' />
        public MissingMemberException() 
            : base(Environment.GetResourceString("Arg_MissingMemberException")) {
    		SetErrorCode(__HResults.COR_E_MISSINGMEMBER);
        }
    
        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.MissingMemberException1"]/*' />
        public MissingMemberException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_MISSINGMEMBER);
        }
    
        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.MissingMemberException2"]/*' />
        public MissingMemberException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_MISSINGMEMBER);
        }

        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.MissingMemberException3"]/*' />
        protected MissingMemberException(SerializationInfo info, StreamingContext context) : base (info, context) {
            ClassName = (String)info.GetString("MMClassName");
            MemberName = (String)info.GetString("MMMemberName");
            Signature = (byte[])info.GetValue("MMSignature", typeof(byte[]));
        }
    
    	/// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.Message"]/*' />
    	public override String Message
        {
    		get {
    	        if (ClassName == null) {
    		        return base.Message;
    			} else {
    				// do any desired fixups to classname here.
                    return String.Format(Environment.GetResourceString("MissingMember_Name",
                                                                       ClassName + "." + MemberName +
                                                                       (Signature != null ? " " + FormatSignature(Signature) : "")));
    		    }
    		}
        }
    
        // Called to format signature
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String FormatSignature(byte [] signature);
    
    
    
        // Potentially called from the EE
        private MissingMemberException(String className, String memberName, byte[] signature)
        {
            ClassName   = className;
            MemberName  = memberName;
            Signature   = signature;
        }
    
        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.MissingMemberException4"]/*' />
        public MissingMemberException(String className, String memberName)
        {
            ClassName   = className;
            MemberName  = memberName;
        }
    
        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            base.GetObjectData(info, context);
            info.AddValue("MMClassName", ClassName, typeof(String));
            info.AddValue("MMMemberName", MemberName, typeof(String));
            info.AddValue("MMSignature", Signature, typeof(byte[]));
        }
    
       
        // If ClassName != null, GetMessage will construct on the fly using it
        // and the other variables. This allows customization of the
        // format depending on the language environment.
        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.ClassName"]/*' />
        protected String  ClassName;
        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.MemberName"]/*' />
        protected String  MemberName;
        /// <include file='doc\MissingMemberException.uex' path='docs/doc[@for="MissingMemberException.Signature"]/*' />
        protected byte[]  Signature;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\missingfieldexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: MissingFieldException
**
** Purpose: The exception class for class loading failures.
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System.Runtime.CompilerServices;
    /// <include file='doc\MissingFieldException.uex' path='docs/doc[@for="MissingFieldException"]/*' />
    [Serializable()] public class MissingFieldException : MissingMemberException, ISerializable {
        /// <include file='doc\MissingFieldException.uex' path='docs/doc[@for="MissingFieldException.MissingFieldException"]/*' />
        public MissingFieldException() 
            : base(Environment.GetResourceString("Arg_MissingFieldException")) {
    		SetErrorCode(__HResults.COR_E_MISSINGFIELD);
        }
    
        /// <include file='doc\MissingFieldException.uex' path='docs/doc[@for="MissingFieldException.MissingFieldException1"]/*' />
        public MissingFieldException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_MISSINGFIELD);
        }
    
        /// <include file='doc\MissingFieldException.uex' path='docs/doc[@for="MissingFieldException.MissingFieldException2"]/*' />
        public MissingFieldException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_MISSINGFIELD);
        }

        /// <include file='doc\MissingFieldException.uex' path='docs/doc[@for="MissingFieldException.MissingFieldException3"]/*' />
        protected MissingFieldException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    
    	/// <include file='doc\MissingFieldException.uex' path='docs/doc[@for="MissingFieldException.Message"]/*' />
    	public override String Message
        {
    		get {
    	        if (ClassName == null) {
    		        return base.Message;
    			} else {
    				// do any desired fixups to classname here.
                    return String.Format(Environment.GetResourceString("MissingField_Name",
                                                                       (Signature != null ? FormatSignature(Signature) + " " : "") +
                                                                       ClassName + "." + MemberName));
    		    }
    		}
        }
    
        // Called to format signature
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String FormatSignature(byte [] signature);
    
    
    
        // Called from the EE
        private MissingFieldException(String className, String fieldName, byte[] signature)
        {
            ClassName   = className;
            MemberName  = fieldName;
            Signature   = signature;
        }
    
        /// <include file='doc\MissingFieldException.uex' path='docs/doc[@for="MissingFieldException.MissingFieldException4"]/*' />
        public MissingFieldException(String className, String fieldName)
        {
            ClassName   = className;
            MemberName  = fieldName;
        }
    
        // If ClassName != null, Message will construct on the fly using it
        // and the other variables. This allows customization of the
        // format depending on the language environment.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\multicastnotsupportedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// MulticastNotSupportedException
// This is thrown when you add multiple callbacks to a non-multicast delegate.
////////////////////////////////////////////////////////////////////////////////

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\MulticastNotSupportedException.uex' path='docs/doc[@for="MulticastNotSupportedException"]/*' />
    [Serializable()] public sealed class MulticastNotSupportedException : SystemException {
    	
        /// <include file='doc\MulticastNotSupportedException.uex' path='docs/doc[@for="MulticastNotSupportedException.MulticastNotSupportedException"]/*' />
        public MulticastNotSupportedException() 
            : base(Environment.GetResourceString("Arg_MulticastNotSupportedException")) {
    		SetErrorCode(__HResults.COR_E_MULTICASTNOTSUPPORTED);
        }
    
        /// <include file='doc\MulticastNotSupportedException.uex' path='docs/doc[@for="MulticastNotSupportedException.MulticastNotSupportedException1"]/*' />
        public MulticastNotSupportedException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_MULTICASTNOTSUPPORTED);
        }
    	
    	/// <include file='doc\MulticastNotSupportedException.uex' path='docs/doc[@for="MulticastNotSupportedException.MulticastNotSupportedException2"]/*' />
    	public MulticastNotSupportedException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_MULTICASTNOTSUPPORTED);
        }

        internal MulticastNotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\notfinitenumberexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException"]/*' />
    [Serializable()] public class NotFiniteNumberException : ArithmeticException {
        private double _offendingNumber;	
    
        /// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException.NotFiniteNumberException"]/*' />
        public NotFiniteNumberException() 
            : base(Environment.GetResourceString("Arg_NotFiniteNumberException")) {
    		_offendingNumber = 0;
    		SetErrorCode(__HResults.COR_E_NOTFINITENUMBER);
        }

        /// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException.NotFiniteNumberException1"]/*' />
        public NotFiniteNumberException(double offendingNumber) 
            : base() {
    		_offendingNumber = offendingNumber;
    		SetErrorCode(__HResults.COR_E_NOTFINITENUMBER);
        }

    	/// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException.NotFiniteNumberException2"]/*' />
    	public NotFiniteNumberException(String message) 
    		: base(message) {
    		_offendingNumber = 0;
    		SetErrorCode(__HResults.COR_E_NOTFINITENUMBER);
    	}

    	/// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException.NotFiniteNumberException3"]/*' />
    	public NotFiniteNumberException(String message, double offendingNumber) 
    		: base(message) {
    		_offendingNumber = offendingNumber;
    		SetErrorCode(__HResults.COR_E_NOTFINITENUMBER);
    	}
    
    	/// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException.NotFiniteNumberException4"]/*' />
    	public NotFiniteNumberException(String message, double offendingNumber, Exception innerException) 
    		: base(message, innerException) {
    		_offendingNumber = offendingNumber;
    		SetErrorCode(__HResults.COR_E_NOTFINITENUMBER);
    	}

        /// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException.NotFiniteNumberException5"]/*' />
        protected NotFiniteNumberException(SerializationInfo info, StreamingContext context) : base(info, context) {
            _offendingNumber = info.GetInt32("OffendingNumber");
        }

    	
        /// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException.OffendingNumber"]/*' />
        public double OffendingNumber {
    		get { return _offendingNumber; }
        }

        /// <include file='doc\NotFiniteNumberException.uex' path='docs/doc[@for="NotFiniteNumberException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            base.GetObjectData(info, context);
            info.AddValue("OffendingNumber", _offendingNumber, typeof(Int32));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\multicastdelegate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    using System;
    using System.Reflection;
	using System.Runtime.Serialization;
    
    /// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate"]/*' />
	[Serializable()]
    public abstract class MulticastDelegate : Delegate
    {
    	// This is a pointer to a delegate that is logically the
    	//	delegate before this one.
    	private MulticastDelegate _prev;
    	
    	// This constructor is called from the class generated by the
    	//	compiler generated code (This must match the constructor
    	//	in Delegate
    	/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.MulticastDelegate"]/*' />
    	protected MulticastDelegate(Object target,String method)
    	
    		: base(target,method) {
    	}
    	
    	// This constructor is called from a class to generate a 
    	// delegate based upon a static method name and the Type object
    	// for the class defining the method.
    	/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.MulticastDelegate1"]/*' />
    	protected MulticastDelegate(Type target,String method) : base(target,method) 
		{
    	}

        internal MulticastDelegate Previous
        {
            get{return _prev;}
            set{_prev = value;}
        }
    	
    	// This method will process the full invocation list
    	/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.DynamicInvokeImpl"]/*' />
    	protected override sealed Object DynamicInvokeImpl(Object[] args)
    	{
    		if (_prev != null)
    			_prev.DynamicInvokeImpl(args);
    		return base.DynamicInvokeImpl(args);
    	}

        /// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            int targetIndex=0;
            DelegateSerializationHolder.DelegateEntry de = GetDelegateSerializationInfo(info, context, targetIndex);
        }

        internal DelegateSerializationHolder.DelegateEntry GetDelegateSerializationInfo(SerializationInfo info, StreamingContext context, int targetIndex)
        {
            DelegateSerializationHolder.DelegateEntry de = DelegateSerializationHolder.GetDelegateSerializationInfo(info,  this.GetType(), Target, Method, targetIndex);     
            if (_prev != null)
            {
                DelegateSerializationHolder.DelegateEntry previousde = _prev.GetDelegateSerializationInfo(info, context, ++targetIndex);
                de.Entry = previousde;
            }
            return de;
        }

    	
    	// equals returns true IIF the delegate is not null and has the
    	//	same target, method and invocation list as this object
    	/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.Equals"]/*' />
    	public override sealed bool Equals(Object obj)
    	{
    		if (!base.Equals(obj))
    			return false;
    		if (_prev != null)
    			return _prev.InvocationListEquals(((MulticastDelegate) obj)._prev);
            else
            {   // if we got here, "this" is a Multicast with only one listener.
                if (obj is MulticastDelegate)
                    return ((MulticastDelegate)obj)._prev == null;
                else if (obj is Delegate)
                    return true;
                else
                    return false;
            }
    	}
    	
        // This routine will return the method
    	/*
        public MethodInfo GetMethod()
        {
    		MulticastDelegate d = this;
    		while (d._prev != null)
    			d = d._prev;
            return d.InternalGetMethod();
        }
    	*/
    	
    	// Recursive function which will check for equality of the invocation list.
    	private bool InvocationListEquals(MulticastDelegate d)
    	{
    		if (!base.Equals(d))
    			return false;
    		if (_prev == d._prev)
    			return true;
    		if (_prev == null)
    			return (d._prev == null) ? true : false;
    		return _prev.InvocationListEquals(d._prev);
    	}
    	
    	// This method will combine this delegate with the passed delegate
    	//	to form a new delegate.
    	/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.CombineImpl"]/*' />
    	protected override sealed Delegate CombineImpl(Delegate follow)
    	{
                    // Verify that the types are the same...
            if (this.GetType() != follow.GetType())
                throw new ArgumentException(Environment.GetResourceString("Arg_DlgtTypeMis"));
				
    		// We always clone the delegate because this delegate is
    		//	not changed by combine and remove.  We can safely tack
    		//	the follow delegate onto the end of the copy.
    		MulticastDelegate d = (MulticastDelegate) ((MulticastDelegate) follow).MemberwiseClone();
    		MulticastDelegate root = d;
    		while (d._prev != null) {
    			d._prev = (MulticastDelegate) d._prev.MemberwiseClone();
    			d = d._prev;
    		}
    		d._prev = (MulticastDelegate) this;
    		return root;
    	}
    								   
        // This method currently looks backward on the invocation list
    	//	for an element that has Delegate based equality with value.  (Doesn't
    	//	look at the invocation list.)  If this is found we remove it from
    	//	this list and return a new delegate.  If its not found a copy of the
    	//	current list is returned.
    	/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.RemoveImpl"]/*' />
    	protected override sealed Delegate RemoveImpl(Delegate value)
    	{
    		// There is a special case were we are removing using a delegate as
    		//	the value we need to check for this case
    		//
    		if (!(value is MulticastDelegate)) {
    			if (base.Equals(value))
    				return _prev;
    			return this;
    		}
    		
    		// Look for the delegate...
    		MulticastDelegate v = (MulticastDelegate) value;
    		if (InternalEquals(v)) {
    			int size = v.DelSize();
    			MulticastDelegate p = _prev;
    			while (--size != 0) 
    				p = p._prev;
    			return p;				
    		}
    		
    		MulticastDelegate d = (MulticastDelegate) this.MemberwiseClone();
    		MulticastDelegate root = d;
    		while (d._prev != null && d._prev.InternalEquals(v) != true) {
    			d._prev = (MulticastDelegate) d._prev.MemberwiseClone();
    			d = d._prev;
    		}
    		
    		if (d._prev != null) {
    			int size = v.DelSize();
    			MulticastDelegate p = d._prev._prev;
    			while (--size != 0) 
    				p = p._prev;
    			d._prev = p;
    		}
    		return root;
    	}
    	private int DelSize()
    	{
    		int i=0;
    		MulticastDelegate d = this;
    		while (d != null) {
    			i++;
    			d = d._prev;
    		}
    		return i;
    	}
    		
    	
    	// Stupid helper function to check equality based upon the super class.
    	private bool InternalEquals(Delegate d)
    	{
    		if (!base.Equals(d))
    			return false;
    		if (((MulticastDelegate) d)._prev != null) {
    			if (_prev == null)
    				return false;
    			return _prev.InternalEquals(((MulticastDelegate) d)._prev);
    		}
    		return true;
    	}
    
    	
    	// This method returns the Invocation list of this multicast delegate.
    	/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.GetInvocationList"]/*' />
    	public override sealed Delegate[] GetInvocationList() {
            int i = 0;
    		MulticastDelegate p;
    		
    		// How big is the invocation list?
            for (p = this; p != null; p = p._prev)
    			i++;
    		
    		// Create an array of delegate copies and each
    		//	element into the array (Need to reverse the order and make sure
    		//	we set the _prev to null.
            Delegate[] del = new Delegate[i];
    		for (p = this; p != null; p = p._prev) {
    			del[--i] = (Delegate) p.MemberwiseClone();
    			((MulticastDelegate) del[i])._prev = null;
    		}
            return del;
    	}
    
    /*	private static bool operator equals(MulticastDelegate d1, MulticastDelegate d2) {
    		if ((Object)d1 == null)
    			return (Object)d2 == null;
    		return d1.Equals(d2);
    	}*/

		/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.operatorEQ"]/*' />
		public static bool operator ==(MulticastDelegate d1, MulticastDelegate d2) {
    		if ((Object)d1 == null)
    			return (Object)d2 == null;
    		return d1.Equals(d2);
    	}

		/// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.operatorNE"]/*' />
		public static bool operator !=(MulticastDelegate d1, MulticastDelegate d2) {
    		if ((Object)d1 == null)
    			return (Object)d2 != null;
    		return !d1.Equals(d2);
    	}
    	
	    /// <include file='doc\MulticastDelegate.uex' path='docs/doc[@for="MulticastDelegate.GetHashCode"]/*' />
	    public override sealed int GetHashCode() {
			return base.GetHashCode();
		}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\nonserializedattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: NonSerializedAttribute
**
** Author: Jay Roxe
**
** Purpose: Used to mark a member as being not-serialized
**
** Date: April 13, 2000
**
============================================================*/
namespace System {

    /// <include file='doc\NonSerializedAttribute.uex' path='docs/doc[@for="NonSerializedAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Field, Inherited=true)]
    public sealed class NonSerializedAttribute : Attribute {

        /// <include file='doc\NonSerializedAttribute.uex' path='docs/doc[@for="NonSerializedAttribute.NonSerializedAttribute"]/*' />
        public NonSerializedAttribute() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\notsupportedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: NotSupportedException
**
** Author: Brian Grunkemeyer
**
** Purpose: For methods that should be implemented on subclasses.
**
** Date: September 28, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\NotSupportedException.uex' path='docs/doc[@for="NotSupportedException"]/*' />
    [Serializable()] public class NotSupportedException : SystemException
    {
    	/// <include file='doc\NotSupportedException.uex' path='docs/doc[@for="NotSupportedException.NotSupportedException"]/*' />
    	public NotSupportedException() 
            : base(Environment.GetResourceString("Arg_NotSupportedException")) {
    		SetErrorCode(__HResults.COR_E_NOTSUPPORTED);
        }
    
        /// <include file='doc\NotSupportedException.uex' path='docs/doc[@for="NotSupportedException.NotSupportedException1"]/*' />
        public NotSupportedException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_NOTSUPPORTED);
        }
    	
        /// <include file='doc\NotSupportedException.uex' path='docs/doc[@for="NotSupportedException.NotSupportedException2"]/*' />
        public NotSupportedException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_NOTSUPPORTED);
        }

        /// <include file='doc\NotSupportedException.uex' path='docs/doc[@for="NotSupportedException.NotSupportedException3"]/*' />
        protected NotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\nullreferenceexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: NullReferenceException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Exception class for dereferencing a null reference.
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {   
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\NullReferenceException.uex' path='docs/doc[@for="NullReferenceException"]/*' />
    [Serializable()] public class NullReferenceException : SystemException {
        /// <include file='doc\NullReferenceException.uex' path='docs/doc[@for="NullReferenceException.NullReferenceException"]/*' />
        public NullReferenceException() 
            : base(Environment.GetResourceString("Arg_NullReferenceException")) {
    		SetErrorCode(__HResults.COR_E_NULLREFERENCE);
        }
    
        /// <include file='doc\NullReferenceException.uex' path='docs/doc[@for="NullReferenceException.NullReferenceException1"]/*' />
        public NullReferenceException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_NULLREFERENCE);
        }
    	
        /// <include file='doc\NullReferenceException.uex' path='docs/doc[@for="NullReferenceException.NullReferenceException2"]/*' />
        public NullReferenceException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_NULLREFERENCE);
        }

        /// <include file='doc\NullReferenceException.uex' path='docs/doc[@for="NullReferenceException.NullReferenceException3"]/*' />
        protected NullReferenceException(SerializationInfo info, StreamingContext context) : base(info, context) {}

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\notimplementedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: NotImplementedException
**
** Author: David Mortenson
**
** Purpose: Exception thrown when a requested method or operation is not 
**			implemented.
**
** Date: May 8, 2000
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;

    /// <include file='doc\NotImplementedException.uex' path='docs/doc[@for="NotImplementedException"]/*' />
    [Serializable()] public class NotImplementedException : SystemException
    {
    	/// <include file='doc\NotImplementedException.uex' path='docs/doc[@for="NotImplementedException.NotImplementedException"]/*' />
    	public NotImplementedException() 
            : base(Environment.GetResourceString("Arg_NotImplementedException")) {
    		SetErrorCode(__HResults.E_NOTIMPL);
        }
        /// <include file='doc\NotImplementedException.uex' path='docs/doc[@for="NotImplementedException.NotImplementedException1"]/*' />
        public NotImplementedException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.E_NOTIMPL);
        }
        /// <include file='doc\NotImplementedException.uex' path='docs/doc[@for="NotImplementedException.NotImplementedException2"]/*' />
        public NotImplementedException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.E_NOTIMPL);
        }

        /// <include file='doc\NotImplementedException.uex' path='docs/doc[@for="NotImplementedException.NotImplementedException3"]/*' />
        protected NotImplementedException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\number.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
	using System.Globalization;
	using System.Runtime.CompilerServices;
    // The Number class implements methods for formatting and parsing
    // numeric values. To format and parse numeric values, applications should
    // use the Format and Parse methods provided by the numeric
    // classes (Byte, Int16, Int32, Int64,
    // Single, Double, Currency, and Decimal). Those
    // Format and Parse methods share a common implementation
    // provided by this class, and are thus documented in detail here.
    //
    // Formatting
    //
    // The Format methods provided by the numeric classes are all of the
    // form
    //
    //  public static String Format(XXX value, String format);
    //  public static String Format(XXX value, String format, NumberFormatInfo info);
    //
    // where XXX is the name of the particular numeric class. The methods convert
    // the numeric value to a string using the format string given by the
    // format parameter. If the format parameter is null or
    // an empty string, the number is formatted as if the string "G" (general
    // format) was specified. The info parameter specifies the
    // NumberFormatInfo instance to use when formatting the number. If the
    // info parameter is null or omitted, the numeric formatting information
    // is obtained from the current culture. The NumberFormatInfo supplies
    // such information as the characters to use for decimal and thousand
    // separators, and the spelling and placement of currency symbols in monetary
    // values.
    //
    // Format strings fall into two categories: Standard format strings and
    // user-defined format strings. A format string consisting of a single
    // alphabetic character (A-Z or a-z), optionally followed by a sequence of
    // digits (0-9), is a standard format string. All other format strings are
    // used-defined format strings.
    //
    // A standard format string takes the form Axx, where A is an
    // alphabetic character called the format specifier and xx is a
    // sequence of digits called the precision specifier. The format
    // specifier controls the type of formatting applied to the number and the
    // precision specifier controls the number of significant digits or decimal
    // places of the formatting operation. The following table describes the
    // supported standard formats.
    //
    // 
    // FormatDescription
    //
    // CcCurrency format. The number is
    // converted to a string that represents a currency amount. The conversion is
    // controlled by the currency format information of the NumberFormatInfo
    // used to format the number. The precision specifier indicates the desired
    // number of decimal places. If the precision specifier is omitted, the default
    // currency precision given by the NumberFormatInfo is used.
    //
    // DdDecimal format. This format is
    // supported for integral types only. The number is converted to a string of
    // decimal digits, prefixed by a minus sign if the number is negative. The
    // precision specifier indicates the minimum number of digits desired in the
    // resulting string. If required, the number will be left-padded with zeros to
    // produce the number of digits given by the precision specifier.
    //
    // EeEngineering (scientific) format.
    // The number is converted to a string of the form
    // "-d.ddd...E+ddd" or "-d.ddd...e+ddd", where each
    // 'd' indicates a digit (0-9). The string starts with a minus sign if the
    // number is negative, and one digit always precedes the decimal point. The
    // precision specifier indicates the desired number of digits after the decimal
    // point. If the precision specifier is omitted, a default of 6 digits after
    // the decimal point is used. The format specifier indicates whether to prefix
    // the exponent with an 'E' or an 'e'. The exponent is always consists of a
    // plus or minus sign and three digits.
    //
    // FfFixed point format. The number is
    // converted to a string of the form "-ddd.ddd....", where each
    // 'd' indicates a digit (0-9). The string starts with a minus sign if the
    // number is negative. The precision specifier indicates the desired number of
    // decimal places. If the precision specifier is omitted, the default numeric
    // precision given by the NumberFormatInfo is used.
    //
    // GgGeneral format. The number is
    // converted to the shortest possible decimal representation using fixed point
    // or scientific format. The precision specifier determines the number of
    // significant digits in the resulting string. If the precision specifier is
    // omitted, the number of significant digits is determined by the type of the
    // number being converted (10 for int, 19 for long, 7 for
    // float, 15 for double, 19 for Currency, and 29 for
    // Decimal). Trailing zeros after the decimal point are removed, and the
    // resulting string contains a decimal point only if required. The resulting
    // string uses fixed point format if the exponent of the number is less than
    // the number of significant digits and greater than or equal to -4. Otherwise,
    // the resulting string uses scientific format, and the case of the format
    // specifier controls whether the exponent is prefixed with an 'E' or an
    // 'e'.
    //
    // NnNumber format. The number is
    // converted to a string of the form "-d,ddd,ddd.ddd....", where
    // each 'd' indicates a digit (0-9). The string starts with a minus sign if the
    // number is negative. Thousand separators are inserted between each group of
    // three digits to the left of the decimal point. The precision specifier
    // indicates the desired number of decimal places. If the precision specifier
    // is omitted, the default numeric precision given by the
    // NumberFormatInfo is used.
    //
    // XxHexadecimal format. This format is
    // supported for integral types only. The number is converted to a string of
    // hexadecimal digits. The format specifier indicates whether to use upper or
    // lower case characters for the hexadecimal digits above 9 ('X' for 'ABCDEF',
    // and 'x' for 'abcdef'). The precision specifier indicates the minimum number
    // of digits desired in the resulting string. If required, the number will be
    // left-padded with zeros to produce the number of digits given by the
    // precision specifier.
    //
    // 
    //
    // Some examples of standard format strings and their results are shown in the
    // table below. (The examples all assume a default NumberFormatInfo.)
    //
    // 
    // ValueFormatResult
    // 12345.6789C$12,345.68
    // -12345.6789C($12,345.68)
    // 12345D12345
    // 12345D800012345
    // 12345.6789E1.234568E+004
    // 12345.6789E101.2345678900E+004
    // 12345.6789e41.2346e+004
    // 12345.6789F12345.68
    // 12345.6789F012346
    // 12345.6789F612345.678900
    // 12345.6789G12345.6789
    // 12345.6789G712345.68
    // 123456789G71.234568E8
    // 12345.6789N12,345.68
    // 123456789N4123,456,789.0000
    // 0x2c45ex2c45e
    // 0x2c45eX2C45E
    // 0x2c45eX80002C45E
    // 
    //
    // Format strings that do not start with an alphabetic character, or that start
    // with an alphabetic character followed by a non-digit, are called
    // user-defined format strings. The following table describes the formatting
    // characters that are supported in user defined format strings.
    //
    // 
    // CharacterDescription
    //
    // 0Digit placeholder. If the value being
    // formatted has a digit in the position where the '0' appears in the format
    // string, then that digit is copied to the output string. Otherwise, a '0' is
    // stored in that position in the output string. The position of the leftmost
    // '0' before the decimal point and the rightmost '0' after the decimal point
    // determines the range of digits that are always present in the output
    // string.
    //
    // #Digit placeholder. If the value being
    // formatted has a digit in the position where the '#' appears in the format
    // string, then that digit is copied to the output string. Otherwise, nothing
    // is stored in that position in the output string.
    //
    // .Decimal point. The first '.' character
    // in the format string determines the location of the decimal separator in the
    // formatted value; any additional '.' characters are ignored. The actual
    // character used as a the decimal separator in the output string is given by
    // the NumberFormatInfo used to format the number.
    //
    // ,Thousand separator and number scaling.
    // The ',' character serves two purposes. First, if the format string contains
    // a ',' character between two digit placeholders (0 or #) and to the left of
    // the decimal point if one is present, then the output will have thousand
    // separators inserted between each group of three digits to the left of the
    // decimal separator. The actual character used as a the decimal separator in
    // the output string is given by the NumberFormatInfo used to format the
    // number. Second, if the format string contains one or more ',' characters
    // immediately to the left of the decimal point, or after the last digit
    // placeholder if there is no decimal point, then the number will be divided by
    // 1000 times the number of ',' characters before it is formatted. For example,
    // the format string '0,,' will represent 100 million as just 100. Use of the
    // ',' character to indicate scaling does not also cause the formatted number
    // to have thousand separators. Thus, to scale a number by 1 million and insert
    // thousand separators you would use the format string '#,##0,,'.
    //
    // %Percentage placeholder. The presence of
    // a '%' character in the format string causes the number to be multiplied by
    // 100 before it is formatted. The '%' character itself is inserted in the
    // output string where it appears in the format string.
    //
    // E+E-e+e-Scientific notation.
    // If any of the strings 'E+', 'E-', 'e+', or 'e-' are present in the format
    // string and are immediately followed by at least one '0' character, then the
    // number is formatted using scientific notation with an 'E' or 'e' inserted
    // between the number and the exponent. The number of '0' characters following
    // the scientific notation indicator determines the minimum number of digits to
    // output for the exponent. The 'E+' and 'e+' formats indicate that a sign
    // character (plus or minus) should always precede the exponent. The 'E-' and
    // 'e-' formats indicate that a sign character should only precede negative
    // exponents.
    //
    // \Literal character. A backslash character
    // causes the next character in the format string to be copied to the output
    // string as-is. The backslash itself isn't copied, so to place a backslash
    // character in the output string, use two backslashes (\\) in the format
    // string.
    //
    // 'ABC'"ABC"Literal string. Characters
    // enclosed in single or double quotation marks are copied to the output string
    // as-is and do not affect formatting.
    //
    // ;Section separator. The ';' character is
    // used to separate sections for positive, negative, and zero numbers in the
    // format string.
    //
    // OtherAll other characters are copied to
    // the output string in the position they appear.
    //
    // 
    //
    // For fixed point formats (formats not containing an 'E+', 'E-', 'e+', or
    // 'e-'), the number is rounded to as many decimal places as there are digit
    // placeholders to the right of the decimal point. If the format string does
    // not contain a decimal point, the number is rounded to the nearest
    // integer. If the number has more digits than there are digit placeholders to
    // the left of the decimal point, the extra digits are copied to the output
    // string immediately before the first digit placeholder.
    //
    // For scientific formats, the number is rounded to as many significant digits
    // as there are digit placeholders in the format string.
    //
    // To allow for different formatting of positive, negative, and zero values, a
    // user-defined format string may contain up to three sections separated by
    // semicolons. The results of having one, two, or three sections in the format
    // string are described in the table below.
    //
    // 
    // SectionsResult
    //
    // OneThe format string applies to all
    // values.
    //
    // TwoThe first section applies to positive values
    // and zeros, and the second section applies to negative values. If the number
    // to be formatted is negative, but becomes zero after rounding according to
    // the format in the second section, then the resulting zero is formatted
    // according to the first section.
    //
    // ThreeThe first section applies to positive
    // values, the second section applies to negative values, and the third section
    // applies to zeros. The second section may be left empty (by having no
    // characters between the semicolons), in which case the first section applies
    // to all non-zero values. If the number to be formatted is non-zero, but
    // becomes zero after rounding according to the format in the first or second
    // section, then the resulting zero is formatted according to the third
    // section.
    //
    // 
    //
    // For both standard and user-defined formatting operations on values of type
    // float and double, if the value being formatted is a NaN (Not
    // a Number) or a positive or negative infinity, then regardless of the format
    // string, the resulting string is given by the NaNSymbol,
    // PositiveInfinitySymbol, or NegativeInfinitySymbol property of
    // the NumberFormatInfo used to format the number.
    //
    // Parsing
    //
    // The Parse methods provided by the numeric classes are all of the form
    //
    //  public static XXX Parse(String s);
    //  public static XXX Parse(String s, int style);
    //  public static XXX Parse(String s, int style, NumberFormatInfo info);
    //
    // where XXX is the name of the particular numeric class. The methods convert a
    // string to a numeric value. The optional style parameter specifies the
    // permitted style of the numeric string. It must be a combination of bit flags
    // from the NumberStyles enumeration. The optional info parameter
    // specifies the NumberFormatInfo instance to use when parsing the
    // string. If the info parameter is null or omitted, the numeric
    // formatting information is obtained from the current culture.
    //
    // Numeric strings produced by the Format methods using the Currency,
    // Decimal, Engineering, Fixed point, General, or Number standard formats
    // (the C, D, E, F, G, and N format specifiers) are guaranteed to be parseable
    // by the Parse methods if the NumberStyles.Any style is
    // specified. Note, however, that the Parse methods do not accept
    // NaNs or Infinities.
    //
    //This class contains only static members and does not need to be serializable 
    internal class Number
    {
        private Number() {
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String FormatDecimal(Decimal value, String format, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String FormatDouble(double value, String format, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String FormatInt32(int value, String format, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String FormatUInt32(uint value, String format, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String FormatInt64(long value, String format, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String FormatUInt64(ulong value, String format, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String FormatSingle(float value, String format, NumberFormatInfo info);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Decimal ParseDecimal(String s, NumberStyles style, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern double ParseDouble(String s, NumberStyles style, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool TryParseDouble(String s, NumberStyles style, NumberFormatInfo info,out double result);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern int ParseInt32(String s, NumberStyles style, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern uint ParseUInt32(String s, NumberStyles style, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern long ParseInt64(String s, NumberStyles style, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern ulong ParseUInt64(String s, NumberStyles style, NumberFormatInfo info);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern float ParseSingle(String s, NumberStyles style, NumberFormatInfo info);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\object.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Object
**
** Author: Daryl Olander (darylo)
**
** Object is the root class for all CLR objects.  This class
** defines only the basics.
**
** Date:  January 29, 1998
** 
===========================================================*/

namespace System {
    using System;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using FieldInfo = System.Reflection.FieldInfo;
    using BindingFlags = System.Reflection.BindingFlags;
    using RemotingException = System.Runtime.Remoting.RemotingException;    
// The Object is the root class for all object in the CLR System. Object 
// is the super class for all other CLR objects and provide a set of methods and low level
// services to subclasses.  These services include object synchronization and support for clone
// operations.
// 
 //This class contains no data and does not need to be serializable 
/// <include file='doc\Object.uex' path='docs/doc[@for="Object"]/*' />
[Serializable()]
[ClassInterface(ClassInterfaceType.AutoDual)]
public class Object
{
    // Creates a new instance of an Object.
    /// <include file='doc\Object.uex' path='docs/doc[@for="Object.Object"]/*' />
    public Object()
    {            
    }
    
    [MethodImplAttribute(MethodImplOptions.InternalCall)]
    private extern Type InternalGetType();
    [MethodImplAttribute(MethodImplOptions.InternalCall)]
    private extern Type FastGetExistingType();
    
    
    // Returns a String which represents the object instance.  The default
    // for an object is to return the fully qualified name of the class.
    // 
    /// <include file='doc\Object.uex' path='docs/doc[@for="Object.ToString"]/*' />
    public virtual String ToString()
    {
        return GetType().FullName;
    }
    
    // Returns a boolean indicating if the passed in object obj is 
    // Equal to this.  Equality is defined as object equality for reference
    // types and bitwise equality for value types using a loader trick to
    // replace Equals with EqualsValue for value types).
    // 
     /// <include file='doc\Object.uex' path='docs/doc[@for="Object.Equals"]/*' />
     [MethodImplAttribute(MethodImplOptions.InternalCall)]
     public extern virtual bool Equals(Object obj);

    /// <include file='doc\Object.uex' path='docs/doc[@for="Object.Equals1"]/*' />
    public static bool Equals(Object objA, Object objB) {
        if (objA==objB) {
            return true;
        }
        if (objA==null || objB==null) {
            return false;
        }
        return objA.Equals(objB);
    }

    /// <include file='doc\Object.uex' path='docs/doc[@for="Object.ReferenceEquals"]/*' />
    public static bool ReferenceEquals (Object objA, Object objB) {
        return objA == objB;
    }
    
    // GetHashCode is intended to serve as a hash function for this object.
    // Based on the contents of the object, the hash function will return a suitable
    // value with a relatively random distribution over the various inputs.
    //
    // The default implementation returns the sync block index for this instance.
    // Calling it on the same object multiple times will return the same value, so
    // it will technically meet the needs of a hash function, but it's pretty lame.
    // Objects (& especially value classes) should override this method.
    // 
    /// <include file='doc\Object.uex' path='docs/doc[@for="Object.GetHashCode"]/*' />
    [MethodImplAttribute(MethodImplOptions.InternalCall)]
    public extern virtual int GetHashCode();
    
    // Returns a Type object which represent this object instance.
    // 
    /// <include file='doc\Object.uex' path='docs/doc[@for="Object.GetType"]/*' />
    public Type GetType()
    {
        Type ret;
        ret = FastGetExistingType();

        if (ret == null)
            ret = InternalGetType();
        return ret;
    }

    // Allow an object to free resources before the object is reclaimed by the GC.
    // Note: This defines a protected method called Finalize.
    /// <include file='doc\Object.uex' path='docs/doc[@for="Object.Finalize"]/*' />
    ~Object()
    {
    }
    
    // Returns a new object instance that is a memberwise copy of this 
    // object.  This is always a shallow copy of the instance. The method is protected
    // so that other object may only call this method on themselves.  It is entended to
    // support the ICloneable interface.
    // 
    /// <include file='doc\Object.uex' path='docs/doc[@for="Object.MemberwiseClone"]/*' />
    [MethodImplAttribute(MethodImplOptions.InternalCall)]
    protected extern Object MemberwiseClone();
    
   
    // Sets the value specified in the variant on the field
    // 
    private void FieldSetter(String typeName, String fieldName, Object val)
    {
        // Extract the field info object
        FieldInfo fldInfo = GetFieldInfo(typeName, fieldName);

        if (fldInfo.IsInitOnly)
            throw new FieldAccessException(Environment.GetResourceString("FieldAccess_InitOnly"));

        // Make sure that the value is compatible with the type
        // of field
        System.Runtime.Remoting.Messaging.Message.CoerceArg(val, fldInfo.FieldType);    

        // Set the value            
        fldInfo.SetValue(this, val);
    }
    
    // Gets the value specified in the variant on the field
    // 
    private void FieldGetter(String typeName, String fieldName, ref Object val)
    {
        // Extract the field info object
        FieldInfo fldInfo = GetFieldInfo(typeName, fieldName);

        // Get the value
        val = fldInfo.GetValue(this);            
    }

    // Gets the field info object given the type name and field name.
    // 
    private FieldInfo GetFieldInfo(String typeName, String fieldName)
    {
        Type t = GetType();
        while(null != t)
        {
            if(t.FullName.Equals(typeName))
            {
                break;
            }

            t = t.BaseType;
        }
        
        if (null == t)
        {
            throw new RemotingException(String.Format(
                Environment.GetResourceString("Remoting_BadType"),
                                              typeName));
        }

        FieldInfo fldInfo = t.GetField(fieldName, BindingFlags.Public | 
                                                  BindingFlags.Instance | 
                                                  BindingFlags.IgnoreCase);
        if(null == fldInfo)
        {
            throw new RemotingException(String.Format(
                Environment.GetResourceString("Remoting_BadField"),
                                              fieldName, typeName));            
        }
        
        return fldInfo;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\objectdisposedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    using System;
    using System.Runtime.Serialization;

    /// <include file='doc\ObjectDisposedException.uex' path='docs/doc[@for="ObjectDisposedException"]/*' />
    /// <devdoc>
    ///    <para> The exception that is thrown when accessing an object that was
    ///       disposed.</para>
    /// </devdoc>
    [Serializable()]public class ObjectDisposedException : InvalidOperationException {
        private String objectName;

        /// <include file='doc\ObjectDisposedException.uex' path='docs/doc[@for="ObjectDisposedException.ObjectDisposedException"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ObjectDisposedException'/> class.</para>
        /// </devdoc>
        public ObjectDisposedException(String objectName) : base(String.Format(Environment.GetResourceString("ObjectDisposed_Generic_ObjectName"), objectName)) {
            this.objectName = objectName;
        }

        /// <include file='doc\ObjectDisposedException.uex' path='docs/doc[@for="ObjectDisposedException.ObjectDisposedException2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ObjectDisposedException'/> class.</para>
        /// </devdoc>
        public ObjectDisposedException(String objectName, String message) : base(message) {
            this.objectName = objectName;
        }

        /// <include file='doc\ObjectDisposedException.uex' path='docs/doc[@for="ObjectDisposedException.Message"]/*' />
        /// <devdoc>
        ///    <para>Gets the text for the message for this exception.</para>
        /// </devdoc>
        public override String Message {
            get {
                String name = ObjectName;
                if (name == null || name.Length == 0)
                    return base.Message;
                return base.Message + Environment.NewLine + String.Format(Environment.GetResourceString("ObjectDisposed_ObjectName_Name"), name);
            }
        }

     /// <include file='doc\ObjectDisposedException.uex' path='docs/doc[@for="ObjectDisposedException.ObjectName"]/*' />
        public String ObjectName {
            get { 
                if (objectName == null)
                    return String.Empty;
                return objectName; 
            }
        }

     /// <include file='doc\ObjectDisposedException.uex' path='docs/doc[@for="ObjectDisposedException.ObjectDisposedException3"]/*' />
        protected ObjectDisposedException(SerializationInfo info, StreamingContext context) : base(info, context) {
            objectName = info.GetString("ObjectName");
        }

     /// <include file='doc\ObjectDisposedException.uex' path='docs/doc[@for="ObjectDisposedException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
            info.AddValue("ObjectName",ObjectName,typeof(String));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\obsoleteattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ObsoleteAttribute
**
** Author: Brad Abrams (BradA)
**
** Purpose: Attribute for functions, etc that will be removed.
**
** Date:  September 22, 1999
** 
===========================================================*/
namespace System {
    
	using System;
	using System.Runtime.Remoting;
    // This attribute is attached to members that are not to be used any longer.
    // Message is some human readable explanation of what to use
    // Error indicates if the compiler should treat usage of such a method as an
    //   error. (this would be used if the actual implementation of the obsolete 
    //   method's implementation had changed).
    // 
    // Issue: do we need to be able to localize this message string?
    //   
    /// <include file='doc\ObsoleteAttribute.uex' path='docs/doc[@for="ObsoleteAttribute"]/*' />
    [Serializable(), AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum |
        AttributeTargets.Interface | AttributeTargets.Constructor | AttributeTargets.Method| AttributeTargets.Property  | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Delegate
        , Inherited = false)]
    public sealed class ObsoleteAttribute : Attribute
    {
    	private String _message;
    	private bool _error;
    	
    	/// <include file='doc\ObsoleteAttribute.uex' path='docs/doc[@for="ObsoleteAttribute.ObsoleteAttribute"]/*' />
    	public ObsoleteAttribute ()
    	{
    		_message = null;
    		_error = false;
    	}
    
    	/// <include file='doc\ObsoleteAttribute.uex' path='docs/doc[@for="ObsoleteAttribute.ObsoleteAttribute1"]/*' />
    	public ObsoleteAttribute (String message)
    	{
    		_message = message;
    		_error = false;
    	}
    
    	/// <include file='doc\ObsoleteAttribute.uex' path='docs/doc[@for="ObsoleteAttribute.ObsoleteAttribute2"]/*' />
    	public ObsoleteAttribute (String message, bool error)
    	{
            _message = message;
            _error = error;
    	}
    
        /// <include file='doc\ObsoleteAttribute.uex' path='docs/doc[@for="ObsoleteAttribute.Message"]/*' />
        public String Message {
    		get {return _message;}
    	}
    	
        /// <include file='doc\ObsoleteAttribute.uex' path='docs/doc[@for="ObsoleteAttribute.IsError"]/*' />
        public bool IsError{
    		get {return _error;}
    	}
    	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\oleautbinder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This class represents the Ole Automation binder.

// #define DISPLAY_DEBUG_INFO

namespace System {

	using System;
	using System.Runtime.InteropServices;
    using System.Reflection;
	using CultureInfo = System.Globalization.CultureInfo;    

    // Made serializable in anticipation of this class eventually having state.
	[Serializable()] 
    internal class OleAutBinder : DefaultBinder
    {
    	// ChangeType
    	// This binder uses OLEAUT to change the type of the variant.
      	public override Object ChangeType(Object value, Type type, CultureInfo cultureInfo)
      	{
			Variant myValue = new Variant(value);
    		if (cultureInfo == null)
    			cultureInfo = CultureInfo.CurrentCulture;
    			
    #if DISPLAY_DEBUG_INFO		
    		Console.Write("In OleAutBinder::ChangeType converting variant of type: ");
    		Console.Write(myValue.VariantType);
    		Console.Write(" to type: ");
    		Console.WriteLine(type.Name);
    #endif		
    		
    		// If we are trying to convert to variant then there is nothing to do.
    		if (type == typeof(Variant))
    		{
    #if DISPLAY_DEBUG_INFO		
    			Console.WriteLine("Variant being changed to type variant is always legal");
    #endif		
    			return value;
    		}
	
			// @TODO(DM): Remove this if reflection strips the byref before calling ChangeType.
			if (type.IsByRef)
			{
    #if DISPLAY_DEBUG_INFO		
    			Console.WriteLine("Striping byref from the type to convert to.");
    #endif		
				type = type.GetElementType();
			}

			// If we are trying to convert from an object to another type then we don't
			// need the OLEAUT change type, we can just use the normal COM+ mechanisms.
    		if (!type.IsPrimitive && type.IsInstanceOfType(value))
    		{
    #if DISPLAY_DEBUG_INFO		
    			Console.WriteLine("Source variant can be assigned to destination type");
    #endif		
    			return value;
    		}

            // Handle converting primitives to enums.
		    if (type.IsEnum && value.GetType().IsPrimitive)
		    {
    #if DISPLAY_DEBUG_INFO		
    			Console.WriteLine("Converting primitive to enum");
    #endif		
                return Enum.Parse(type, value.ToString());
		    }

    		// Use the OA variant lib to convert primitive types.
    		try
    		{
    #if DISPLAY_DEBUG_INFO		
    			Console.WriteLine("Using OAVariantLib.ChangeType() to do the conversion");
    #endif		
    			// Specify flags of 0x10 to have BOOL values converted to local language rather
    			// than 0 or -1.
				Object RetObj = Microsoft.Win32.OAVariantLib.ChangeType(myValue, type, 0x10, cultureInfo).ToObject();

    #if DISPLAY_DEBUG_INFO		
    			Console.WriteLine("Object returned from ChangeType is of type: " + RetObj.GetType().Name);
	#endif

				return RetObj;
    		}
    #if DISPLAY_DEBUG_INFO		
    		catch(NotSupportedException e)
	#else
    		catch(NotSupportedException)
    #endif		
    		{
    #if DISPLAY_DEBUG_INFO		
    			Console.Write("Exception thrown: ");
    			Console.WriteLine(e);
    #endif		
    			throw new COMException(Environment.GetResourceString("Interop.COM_TypeMismatch"), unchecked((int)0x80020005));
    		}
      	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\operatingsystem.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:    OperatingSystem
**
** Author:  
**
** Purpose: 
**
** Date:    June 4, 1999
**
===========================================================*/
namespace System {
    /// <include file='doc\OperatingSystem.uex' path='docs/doc[@for="OperatingSystem"]/*' />

    [Serializable()] public sealed class OperatingSystem : ICloneable
    {
        private Version _version;
        private PlatformID _platform;

        /// <include file='doc\OperatingSystem.uex' path='docs/doc[@for="OperatingSystem.OperatingSystem"]/*' />
        private OperatingSystem()
        {
        }

        /// <include file='doc\OperatingSystem.uex' path='docs/doc[@for="OperatingSystem.OperatingSystem1"]/*' />
        public OperatingSystem(PlatformID platform, Version version) {
            if ((Object) version == null)
                throw new ArgumentNullException("version");

            _platform = platform;
            _version = (Version) version.Clone();
        }
    
        /// <include file='doc\OperatingSystem.uex' path='docs/doc[@for="OperatingSystem.Platform"]/*' />
        public PlatformID Platform {
            get { return _platform; }
        }
    
        /// <include file='doc\OperatingSystem.uex' path='docs/doc[@for="OperatingSystem.Version"]/*' />
        public Version Version {
            get { return _version; }
        }
    
        /// <include file='doc\OperatingSystem.uex' path='docs/doc[@for="OperatingSystem.Clone"]/*' />
        public Object Clone() {
            return new OperatingSystem(_platform,
                                       _version);
        }
    
        /// <include file='doc\OperatingSystem.uex' path='docs/doc[@for="OperatingSystem.ToString"]/*' />
        public override String ToString() {
            String os;
            if (_platform == PlatformID.Win32NT)
                os = "Microsoft Windows NT";
            else if (_platform == PlatformID.Win32Windows) {
                if ((_version.Major > 4) ||
                    ((_version.Major == 4) && (_version.Minor > 0)))
                    os = "Microsoft Windows 98";
                else
                    os = "Microsoft Windows 95";
            }
            else if (_platform == PlatformID.Win32S)
                os = "Microsoft Win32S";
            else if (_platform == PlatformID.WinCE)
                os = "Microsoft Windows CE";
            else
                os = "<unknown>";

            return os + " " + _version.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\overflowexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: OverflowException
**
** Author: Jay Roxe (JRoxe)
**
** Purpose: Exception class for Arthimatic Overflows.
**
** Date: August 31, 1998
**
=============================================================================*/

namespace System {
 
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\OverflowException.uex' path='docs/doc[@for="OverflowException"]/*' />
    [Serializable()] public class OverflowException : ArithmeticException {
        /// <include file='doc\OverflowException.uex' path='docs/doc[@for="OverflowException.OverflowException"]/*' />
        public OverflowException() 
            : base(Environment.GetResourceString("Arg_OverflowException")) {
    		SetErrorCode(__HResults.COR_E_OVERFLOW);
        }
    
        /// <include file='doc\OverflowException.uex' path='docs/doc[@for="OverflowException.OverflowException1"]/*' />
        public OverflowException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_OVERFLOW);
        }
    	
        /// <include file='doc\OverflowException.uex' path='docs/doc[@for="OverflowException.OverflowException2"]/*' />
        public OverflowException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_OVERFLOW);
        }

        /// <include file='doc\OverflowException.uex' path='docs/doc[@for="OverflowException.OverflowException3"]/*' />
        protected OverflowException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\outofmemoryexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: OutOfMemoryException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: The exception class for OOM.
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\OutOfMemoryException.uex' path='docs/doc[@for="OutOfMemoryException"]/*' />
    [Serializable()] public class OutOfMemoryException : SystemException {
        /// <include file='doc\OutOfMemoryException.uex' path='docs/doc[@for="OutOfMemoryException.OutOfMemoryException"]/*' />
        public OutOfMemoryException() 
            : base(Environment.GetResourceString("Arg_OutOfMemoryException")) {
    		SetErrorCode(__HResults.COR_E_OUTOFMEMORY);
        }
    
        /// <include file='doc\OutOfMemoryException.uex' path='docs/doc[@for="OutOfMemoryException.OutOfMemoryException1"]/*' />
        public OutOfMemoryException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_OUTOFMEMORY);
        }
    	
        /// <include file='doc\OutOfMemoryException.uex' path='docs/doc[@for="OutOfMemoryException.OutOfMemoryException2"]/*' />
        public OutOfMemoryException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_OUTOFMEMORY);
        }

        /// <include file='doc\OutOfMemoryException.uex' path='docs/doc[@for="OutOfMemoryException.OutOfMemoryException3"]/*' />
        protected OutOfMemoryException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\paramarrayattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ParamArrayAttribute
**
** Author: Rajesh Chandrashekaran ( rajeshc )
**
** Purpose: Container for assemblies.
**
** Date: Mar 01, 2000
**
=============================================================================*/
namespace System
{
//This class contains only static members and does not need to be serializable 
   /// <include file='doc\ParamArrayAttribute.uex' path='docs/doc[@for="ParamArrayAttribute"]/*' />
   [AttributeUsage (AttributeTargets.Parameter, Inherited=true, AllowMultiple=false)]
   public sealed class ParamArrayAttribute : Attribute
   {
      /// <include file='doc\ParamArrayAttribute.uex' path='docs/doc[@for="ParamArrayAttribute.ParamArrayAttribute"]/*' />
      public ParamArrayAttribute () {}  
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\paramarray.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
   
    // A ParamArray presents an array like abstraction over the arguments to
    // a varargs function call.
	using System;
	using System.Runtime.CompilerServices;
	/// <include file='doc\ParamArray.uex' path='docs/doc[@for="ParamArray"]/*' />
    [Serializable,
		Obsolete("This is dead functionality.") ] // TODO put this back in , System.Runtime.CompilerServices.NotInGCHeap] 
	public struct ParamArray
    {
    	//@todo: Modify this to work with arrays.
    //	int[]	Params;
    //	int[]	Types;
    	internal int		i1;
    	internal int		i2;
    	internal int		i3;
    	internal int		i4;
    	internal int		i5;
    	internal int		i6;
    	internal int		i7;
    	internal int		i8;
    	internal int		i9;
    
    	// Create a ParamArray on top of the varargs argument list referenced
    	// by arglist.    
    	/// <include file='doc\ParamArray.uex' path='docs/doc[@for="ParamArray.ParamArray"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern ParamArray(RuntimeArgumentHandle arglist);
    
    	// Return the count of arguments in the array.
    	/// <include file='doc\ParamArray.uex' path='docs/doc[@for="ParamArray.GetCount"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern int GetCount();
    
    	// Return a TypedReference for the ith argument.  This throws an exception if
    	// i is out of bounds.
    	/// <include file='doc\ParamArray.uex' path='docs/doc[@for="ParamArray.GetArg"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
    	public extern TypedReference GetArg(int i);
    
    	/// <include file='doc\ParamArray.uex' path='docs/doc[@for="ParamArray.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return i1;
    	}
    
    	/// <include file='doc\ParamArray.uex' path='docs/doc[@for="ParamArray.Equals"]/*' />
    	public override bool Equals(Object o)
    	{
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_NYI"));
    	}

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			i1 = 0;
    		i2 = 0;
    		i3 = 0;
    		i4 = 0;
    		i5 = 0;
    		i6 = 0;
    		i7 = 0;
    		i8 = 0;
    		i9 = 0;
    	}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\random.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Random.cool
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A random number generator.
**
** Date:  July 8, 1998
** 
===========================================================*/
namespace System {
    
	using System;
    using System.Runtime.CompilerServices;
    /// <include file='doc\Random.uex' path='docs/doc[@for="Random"]/*' />
    [Serializable()] public class Random {
      //
      // Private Constants 
      //
      private const int MBIG =  Int32.MaxValue;
      private const int MSEED = 161803398;
      private const int MZ = 0;
    
      
      //
      // Member Variables
      //
      private int inext, inextp;
      private int[] SeedArray = new int[56];
    
      //
      // Public Constants
      //
    
      //
      // Native Declarations
      //
    
      //
      // Constructors
      //
    
      /// <include file='doc\Random.uex' path='docs/doc[@for="Random.Random"]/*' />
      public Random() 
        : this(Environment.TickCount) {
      }
    
      /// <include file='doc\Random.uex' path='docs/doc[@for="Random.Random1"]/*' />
      public Random(int Seed) {
        int ii;
        int mj, mk;
    
        //Initialize our Seed array.
        //This algorithm comes from Numerical Recipes in C (2nd Ed.)
        mj = MSEED - Math.Abs(Seed);
        SeedArray[55]=mj;
        mk=1;
        for (int i=1; i<55; i++) {  //Apparently the range [1..55] is special (Knuth) and so we're wasting the 0'th position.
          ii = (21*i)%55;
          SeedArray[ii]=mk;
          mk = mj - mk;
          if (mk<0) mk+=MBIG;
          mj=SeedArray[ii];
        }
        for (int k=1; k<5; k++) {
          for (int i=1; i<56; i++) {
    	SeedArray[i] -= SeedArray[1+(i+30)%55];
    	if (SeedArray[i]<0) SeedArray[i]+=MBIG;
          }
        }
        inext=0;
        inextp = 21;
        Seed = 1;
      }
    
      //
      // Package Private Methods
      //
    
      /*====================================Sample====================================
      **Action: Return a new random number [0..1) and reSeed the Seed array.
      **Returns: A double [0..1)
      **Arguments: None
      **Exceptions: None
      ==============================================================================*/
      /// <include file='doc\Random.uex' path='docs/doc[@for="Random.Sample"]/*' />
      protected virtual double Sample() {
          int retVal;
          int locINext = inext;
          int locINextp = inextp;

          if (++locINext >=56) locINext=1;
          if (++locINextp>= 56) locINextp = 1;
          
          retVal = SeedArray[locINext]-SeedArray[locINextp];
          
          if (retVal<0) retVal+=MBIG;
          
          SeedArray[locINext]=retVal;

          inext = locINext;
          inextp = locINextp;
                    
          //Including this division at the end gives us significantly improved
          //random number distribution.
          return (retVal*(1.0/MBIG));
      }
    
      //
      // Public Instance Methods
      // 
    
    
      /*=====================================Next=====================================
      **Returns: An int [0.._int4.MaxValue)
      **Arguments: None
      **Exceptions: None.
      ==============================================================================*/
      /// <include file='doc\Random.uex' path='docs/doc[@for="Random.Next"]/*' />
      public virtual int Next() {
        return (int)(Sample()*Int32.MaxValue);
      }
    
      /*=====================================Next=====================================
      **Returns: An int [minvalue..maxvalue)
      **Arguments: minValue -- the least legal value for the Random number.
      **           maxValue -- the greatest legal return value.
      **Exceptions: None.
      ==============================================================================*/
      /// <include file='doc\Random.uex' path='docs/doc[@for="Random.Next1"]/*' />
      public virtual int Next(int minValue, int maxValue) {
          if (minValue>maxValue) {
              throw new ArgumentOutOfRangeException("minValue",String.Format(Environment.GetResourceString("Argument_MinMaxValue"), "minValue", "maxValue"));
          }
          
          int range = (maxValue-minValue);
    
          //This is the case where we flipped around (e.g. MaxValue-MinValue);
          if (range<0) {
              long longRange = (long)maxValue-(long)minValue;
              return (int)(((long)(Sample()*((double)longRange)))+minValue);
          }
          
          return ((int)(Sample()*(range)))+minValue;
      }
    
    
      /*=====================================Next=====================================
      **Returns: An int [0..maxValue)
      **Arguments: maxValue -- the greatest legal return value.
      **Exceptions: None.
      ==============================================================================*/
      /// <include file='doc\Random.uex' path='docs/doc[@for="Random.Next2"]/*' />
      public virtual int Next(int maxValue) {
          if (maxValue<0) {
              throw new ArgumentOutOfRangeException("maxValue", String.Format(Environment.GetResourceString("ArgumentOutOfRange_MustBePositive"), "maxValue"));
          }
          return (int)(Sample()*maxValue);
      }
    
    
      /*=====================================Next=====================================
      **Returns: A double [0..1)
      **Arguments: None
      **Exceptions: None
      ==============================================================================*/
      /// <include file='doc\Random.uex' path='docs/doc[@for="Random.NextDouble"]/*' />
      public virtual double NextDouble() {
        return Sample();
      }
    
    
      /*==================================NextBytes===================================
      **Action:  Fills the byte array with random bytes [0..0x7f].  The entire array is filled.
      **Returns:Void
      **Arugments:  buffer -- the array to be filled.
      **Exceptions: None
      ==============================================================================*/
      /// <include file='doc\Random.uex' path='docs/doc[@for="Random.NextBytes"]/*' />
      public virtual void NextBytes(byte [] buffer){
        if (buffer==null) throw new ArgumentNullException("buffer");
        for (int i=0; i<buffer.Length; i++) {
          buffer[i]=(byte)(Sample()*(Byte.MaxValue+1)); 
        }
      }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\rankexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: RankException
**
** Author: Brian Grunkemeyer
**
** Purpose: For methods that are passed arrays with the wrong number of
**          dimensions.
**
** Date: April 7, 1999
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\RankException.uex' path='docs/doc[@for="RankException"]/*' />
    [Serializable()] public class RankException : SystemException
    {
    	/// <include file='doc\RankException.uex' path='docs/doc[@for="RankException.RankException"]/*' />
    	public RankException() 
            : base(Environment.GetResourceString("Arg_RankException")) {
    		SetErrorCode(__HResults.COR_E_RANK);
        }
    
        /// <include file='doc\RankException.uex' path='docs/doc[@for="RankException.RankException1"]/*' />
        public RankException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_RANK);
        }
    	
        /// <include file='doc\RankException.uex' path='docs/doc[@for="RankException.RankException2"]/*' />
        public RankException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_RANK);
        }

        /// <include file='doc\RankException.uex' path='docs/doc[@for="RankException.RankException3"]/*' />
        protected RankException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\parsenumbers.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ParseNumbers
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Methods for Parsing numbers and Strings.
** All methods are implemented in native.
**
** Date:  April 7, 1998
** 
===========================================================*/
namespace System {
   
    //This class contains only static members and does not need to be serializable.
	using System;
	using System.Runtime.CompilerServices;
    internal class ParseNumbers {
        internal const int PrintAsI1=0x40;
        internal const int PrintAsI2=0x80;
        internal const int PrintAsI4=0x100;
        internal const int TreatAsUnsigned=0x200;
        internal const int TreatAsI1=0x400;
        internal const int TreatAsI2=0x800;
        internal const int IsTight=0x1000;
        internal static readonly int[] ZeroStart = {0};
      
        //
        //
        // NATIVE METHODS
        // For comments on these methods please see $\src\vm\COMUtilNative.cpp
        //
        public static long StringToLong(System.String s, int radix, int flags) {
            int [] zeroStart = {0};
            return StringToLong(s,radix,flags,zeroStart);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern static long StringToLong(System.String s, int radix, int flags, int[] currPos);
    
        public static long RadixStringToLong(System.String s, int radix, bool isTight) {
            int [] zeroStart = {0};
            return RadixStringToLong(s,radix,isTight,zeroStart);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern static long RadixStringToLong(System.String s, int radix, bool isTight, int[] currPos);
    
    
        public static int StringToInt(System.String s, int radix, int flags) {
            int [] zeroStart = {0};
            return StringToInt(s,radix,flags,zeroStart);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern static int StringToInt(System.String s, int radix, int flags, int[] currPos);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern static String IntToDecimalString(int i);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern static String IntToString(int l, int radix, int width, char paddingChar, int flags);

	// This is a hack to fix fastcalls not liking passing int64 as their first argument
        public static String LongToString(long l, int radix, int width, char paddingChar, int flags)
	{
		return LongToString(radix, width, l, paddingChar, flags);
	}
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static String LongToString(int radix, int width, long l, char paddingChar, int flags);
    }






}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\platformid.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    PlatformID
**
** Author:  Suzanne Cook
**
** Purpose: Defines IDs for supported platforms
**
** Date:    June 4, 1999
**
===========================================================*/
namespace System {

    /// <include file='doc\PlatformID.uex' path='docs/doc[@for="PlatformID"]/*' />
    [Serializable()]
    public enum PlatformID
    {
        /// <include file='doc\PlatformID.uex' path='docs/doc[@for="PlatformID.Win32S"]/*' />
        Win32S        = 0,
        /// <include file='doc\PlatformID.uex' path='docs/doc[@for="PlatformID.Win32Windows"]/*' />
        Win32Windows  = 1,
        /// <include file='doc\PlatformID.uex' path='docs/doc[@for="PlatformID.Win32NT"]/*' />
        Win32NT       = 2,

        /// <include file='doc\PlatformID.uex' path='docs/doc[@for="PlatformID.WinCE"]/*' />
        WinCE         = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtimeargumenthandle.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
    //  This value type is used for constructing System.ArgIterator. 
    // 
    //  SECURITY : m_ptr cannot be set to anything other than null by untrusted
    //  code.  
    // 
    //  This corresponds to EE VARARGS cookie.

	 // Cannot be serialized
    /// <include file='doc\RuntimeArgumentHandle.uex' path='docs/doc[@for="RuntimeArgumentHandle"]/*' />
    public struct RuntimeArgumentHandle
    {
        private IntPtr m_ptr;

 		// This method should never be called.  Its sole purpose is to shut up the compiler
		//	because it warns about private fields that are never used.  Most of these fields
		//	are used in unmanaged code.
#if _DEBUG
		internal IntPtr  NeverCallThis()
		{
			m_ptr = (IntPtr)0;
			BCLDebug.Assert(false,"NeverCallThis");
			return m_ptr;
		}
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\resid.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ResId
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Contains identifiers for each of the resources
**          specified in resources.txt
**
** Date:  July 12, 1999
**
===========================================================*/
namespace System {
    //This class contains only static members and does not need to be serializable.
    using System.Configuration.Assemblies;
    using System;
    internal sealed class ResId {
        // Only statics, does not need to be marked with the serializable attribute
        internal const String Arg_ArrayLengthsDiffer="Arg_ArrayLengthsDiffer";
        internal const String Argument_InvalidNumberOfMembers="Argument_InvalidNumberOfMembers";
        internal const String Argument_UnequalMembers="Argument_UnequalMembers";
        internal const String Argument_SpecifyValueSize="Argument_SpecifyValueSize";
        internal const String Argument_UnmatchingSymScope="Argument_UnmatchingSymScope";
        internal const String Argument_NotInExceptionBlock="Argument_NotInExceptionBlock";
        internal const String Argument_NotExceptionType="Argument_NotExceptionType";
        internal const String Argument_InvalidLabel="Argument_InvalidLabel";
        internal const String Argument_UnclosedExceptionBlock="Argument_UnclosedExceptionBlock";
        internal const String Argument_MissingDefaultConstructor="Argument_MissingDefaultConstructor";
        internal const String Argument_TooManyFinallyClause="Argument_TooManyFinallyClause";
        internal const String Argument_NotInTheSameModuleBuilder="Argument_NotInTheSameModuleBuilder";
        internal const String Argument_BadCurrentLocalVariable="Argument_BadCurrentLocalVariable";
        internal const String Argument_DuplicateModuleName="Argument_DuplicateModuleName";
        internal const String Argument_BadPersistableModuleInTransientAssembly="Argument_BadPersistableModuleInTransientAssembly";
        internal const String Argument_HasToBeArrayClass="Argument_HasToBeArrayClass";
        internal const String Argument_InvalidDirectory="Argument_InvalidDirectory";
        
        internal const String MissingType="MissingType";
        internal const String MissingModule="MissingModule";
    
        internal const String ArgumentOutOfRange_Index="ArgumentOutOfRange_Index";
        internal const String ArgumentOutOfRange_Range="ArgumentOutOfRange_Range";
     
        internal const String ExecutionEngine_YoureHosed="ExecutionEngine_YoureHosed";
    
        internal const String Format_NeedSingleChar="Format_NeedSingleChar";
        internal const String Format_StringZeroLength="Format_StringZeroLength";
    
        internal const String InvalidOperation_EnumEnded="InvalidOperation_EnumEnded";
        internal const String InvalidOperation_EnumFailedVersion="InvalidOperation_EnumFailedVersion";
        internal const String InvalidOperation_EnumNotStarted="InvalidOperation_EnumNotStarted";
        internal const String InvalidOperation_EnumOpCantHappen="InvalidOperation_EnumOpCantHappen";
        internal const String InvalidOperation_InternalState="InvalidOperation_InternalState";
        internal const String InvalidOperation_ModifyRONumFmtInfo="InvalidOperation_ModifyRONumFmtInfo";
        internal const String InvalidOperation_MethodBaked="InvalidOperation_MethodBaked";
        internal const String InvalidOperation_NotADebugModule="InvalidOperation_NotADebugModule";
        internal const String InvalidOperation_MethodHasBody="InvalidOperation_MethodHasBody";
        internal const String InvalidOperation_OpenLocalVariableScope="InvalidOperation_OpenLocalVariableScope";    
        internal const String InvalidOperation_TypeHasBeenCreated="InvalidOperation_TypeHasBeenCreated";
        internal const String InvalidOperation_RefedAssemblyNotSaved="InvalidOperation_RefedAssemblyNotSaved";
        internal const String InvalidOperation_AssemblyHasBeenSaved="InvalidOperation_AssemblyHasBeenSaved";
        internal const String InvalidOperation_ModuleHasBeenSaved="InvalidOperation_ModuleHasBeenSaved";
        internal const String InvalidOperation_CannotAlterAssembly="InvalidOperation_CannotAlterAssembly";
    
        internal const String NotSupported_CannotSaveModuleIndividually="NotSupported_CannotSaveModuleIndividually";
        internal const String NotSupported_Constructor="NotSupported_Constructor";
        internal const String NotSupported_Method="NotSupported_Method";
        internal const String NotSupported_NYI="NotSupported_NYI";
        internal const String NotSupported_DynamicModule="NotSupported_DynamicModule";
        internal const String NotSupported_NotDynamicModule="NotSupported_NotDynamicModule";
        internal const String NotSupported_NotAllTypesAreBaked="NotSupported_NotAllTypesAreBaked";
        internal const String NotSupported_SortedListNestedWrite="NotSupported_SortedListNestedWrite";
    
        
        internal const String Serialization_ArrayInvalidLength="Serialization_ArrayInvalidLength";
        internal const String Serialization_ArrayNoLength="Serialization_ArrayNoLength";
        internal const String Serialization_CannotGetType="Serialization_CannotGetType";
        internal const String Serialization_InsufficientState="Serialization_InsufficientState";
        internal const String Serialization_InvalidID="Serialization_InvalidID";
        internal const String Serialization_MalformedArray="Serialization_MalformedArray";
        internal const String Serialization_MultipleMembers="Serialization_MultipleMembers";
        internal const String Serialization_NoID="Serialization_NoID";
        internal const String Serialization_NoType="Serialization_NoType";
        internal const String Serialization_NoBaseType="Serialization_NoBaseType";
        internal const String Serialization_NullSignature="Serialization_NullSignature";
        internal const String Serialization_UnknownMember="Serialization_UnknownMember";
    
        internal const String WeakReference_NoLongerValid="WeakReference_NoLongerValid";
        internal const String Loader_InvalidPath="Loader_InvalidPath";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\platformnotsupportedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: PlatformNotSupportedException
**
** Author: Rajesh Chandrashekaran
**
** Purpose: To handle features that don't run on particular platforms
**
** Date: September 28, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;

    /// <include file='doc\PlatformNotSupportedException.uex' path='docs/doc[@for="PlatformNotSupportedException"]/*' />
    [Serializable()] public class PlatformNotSupportedException : NotSupportedException
    {
    	/// <include file='doc\PlatformNotSupportedException.uex' path='docs/doc[@for="PlatformNotSupportedException.PlatformNotSupportedException"]/*' />
    	public PlatformNotSupportedException() 
            : base(Environment.GetResourceString("Arg_PlatformNotSupported")) {
    		SetErrorCode(__HResults.COR_E_PLATFORMNOTSUPPORTED);
        }
    
        /// <include file='doc\PlatformNotSupportedException.uex' path='docs/doc[@for="PlatformNotSupportedException.PlatformNotSupportedException1"]/*' />
        public PlatformNotSupportedException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_PLATFORMNOTSUPPORTED);
        }
    	
        /// <include file='doc\PlatformNotSupportedException.uex' path='docs/doc[@for="PlatformNotSupportedException.PlatformNotSupportedException2"]/*' />
        public PlatformNotSupportedException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_PLATFORMNOTSUPPORTED);
        }

        /// <include file='doc\PlatformNotSupportedException.uex' path='docs/doc[@for="PlatformNotSupportedException.PlatformNotSupportedException3"]/*' />
        protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtimefieldhandle.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
    using System;
	using System.Reflection;
	using System.Runtime.Serialization;

    //  This value type is used for making classlib type safe. 
    // 
    //  SECURITY : m_ptr cannot be set to anything other than null by untrusted
    //  code.  
    // 
    //  This corresponds to EE FieldDesc.
    /// <include file='doc\RuntimeFieldHandle.uex' path='docs/doc[@for="RuntimeFieldHandle"]/*' />
	[Serializable()]
    public struct RuntimeFieldHandle : ISerializable
    {
        private IntPtr m_ptr;

        /// <include file='doc\RuntimeFieldHandle.uex' path='docs/doc[@for="RuntimeFieldHandle.Value"]/*' />
        public IntPtr Value {
            get {
                return m_ptr;
            }
        }

		// ISerializable interface
		private RuntimeFieldHandle(SerializationInfo info, StreamingContext context)
		{
			if (info==null) {
                throw new ArgumentNullException("info");
            }
			FieldInfo f = (RuntimeFieldInfo) info.GetValue("FieldObj", typeof(RuntimeFieldInfo));
			if (f==null) {
				BCLDebug.Trace("SER", "[RuntimeFieldHandle.ctor]Null Type returned from GetValue.");
				throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientState"));
			}

			m_ptr = f.FieldHandle.m_ptr;
			if (m_ptr == (IntPtr)0)
			    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientState"));
		}

		/// <include file='doc\RuntimeFieldHandle.uex' path='docs/doc[@for="RuntimeFieldHandle.GetObjectData"]/*' />
		public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
			if (m_ptr == (IntPtr)0)
			    throw new SerializationException(Environment.GetResourceString("Serialization_InvalidFieldState"));
			RuntimeFieldInfo fldInfo = (RuntimeFieldInfo)RuntimeFieldInfo.GetFieldFromHandle(this); 
            BCLDebug.Assert(fldInfo!=null, "[RuntimeFieldHandle.GetObjectData]fldInfo!=null");
		    info.AddValue("FieldObj",fldInfo, typeof(RuntimeFieldInfo));
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtimemethodhandle.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
    using System;
	using System.Reflection;
	using System.Runtime.Serialization;
    using System.Runtime.CompilerServices;
    using System.Security.Permissions;

    //  This value type is used for making classlib type safe. 
    // 
    //  SECURITY : m_ptr cannot be set to anything other than null by untrusted
    //  code.  
    // 
    //  This corresponds to EE MethodDesc.
    /// <include file='doc\RuntimeMethodHandle.uex' path='docs/doc[@for="RuntimeMethodHandle"]/*' />
    [Serializable]
    public struct RuntimeMethodHandle : ISerializable
    {
        private IntPtr m_ptr;

        /// <include file='doc\RuntimeMethodHandle.uex' path='docs/doc[@for="RuntimeMethodHandle.Value"]/*' />
        public IntPtr Value {
            get {
                return m_ptr;
            }
        }

		// ISerializable interface
		private RuntimeMethodHandle(SerializationInfo info, StreamingContext context)
		{
			if (info==null) {
                throw new ArgumentNullException("info");
            }
			MethodInfo m = (RuntimeMethodInfo)info.GetValue("MethodObj", typeof(RuntimeMethodInfo));
			m_ptr = m.MethodHandle.m_ptr;
			if (m_ptr == (IntPtr)0)
			    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientState"));
		}

        /// <include file='doc\RuntimeMethodHandle.uex' path='docs/doc[@for="RuntimeMethodHandle.GetFunctionPointer"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, UnmanagedCode=true)]
        public System.IntPtr GetFunctionPointer()
        {
            return RuntimeMethodHandle.InternalGetFunctionPointer(m_ptr);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern IntPtr InternalGetFunctionPointer(IntPtr pMethodDesc);

		/// <include file='doc\RuntimeMethodHandle.uex' path='docs/doc[@for="RuntimeMethodHandle.GetObjectData"]/*' />
		public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
			if (m_ptr == (IntPtr)0)
			    throw new SerializationException(Environment.GetResourceString("Serialization_InvalidFieldState"));
			RuntimeMethodInfo methodInfo = (RuntimeMethodInfo)RuntimeMethodInfo.GetMethodFromHandle(this); 
		    info.AddValue("MethodObj",methodInfo, typeof(RuntimeMethodInfo));
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\single.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Single
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A wrapper class for the primitive type float.
**
** Date:  August 3, 1998
** 
===========================================================*/
namespace System {

	using System.Globalization;
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;

    /// <include file='doc\Single.uex' path='docs/doc[@for="Single"]/*' />
    [Serializable(), System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)] public struct Single : IComparable, IFormattable, IConvertible
    {
        internal float m_value;
    
        //
        // Public constants
        //
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.MinValue"]/*' />
        public const float MinValue = (float)-3.40282346638528859e+38; 
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.Epsilon"]/*' />
        public const float Epsilon = (float)1.4e-45; 
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.MaxValue"]/*' />
        public const float MaxValue = (float)3.40282346638528859e+38; 
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.PositiveInfinity"]/*' />
        public const float PositiveInfinity = (float)1.0 / (float)0.0;
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.NegativeInfinity"]/*' />
        public const float NegativeInfinity = (float)-1.0 / (float)0.0;
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.NaN"]/*' />
        public const float NaN = (float)0.0 / (float)0.0;
	    
        //
        // Native Declarations
        //
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IsInfinity"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool IsInfinity(float f);
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IsPositiveInfinity"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool IsPositiveInfinity(float f);
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IsNegativeInfinity"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool IsNegativeInfinity(float f);
        
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IsNaN"]/*' />
        public static bool IsNaN(float f) {
        // Comparisions of a NaN with another number is always false and hence both conditions will be false.
            if (f < 0f || f >= 0f) {
               return false;
            }
            return true;
        }
	
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type Single, this method throws an ArgumentException.
        // 
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (value is Single) {
                float f = (float)value;
                if (m_value < f) return -1;
                if (m_value > f) return 1;
    			if (m_value == f) return 0;
    
    			// At least one of the values is NaN.
    			if (IsNaN(m_value))
    				return (IsNaN(f) ? 0 : -1);
    			else // f is NaN.
    				return 1;
    		}           
            throw new ArgumentException (Environment.GetResourceString("Arg_MustBeSingle"));
        }
    
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is Single)) {
                return false;
            }        
	        float temp = ((Single)obj).m_value;
	        if (temp == m_value) {
		        return true;
	        }
            
            return IsNaN(temp) && IsNaN(m_value);
        }

    	/// <include file='doc\Single.uex' path='docs/doc[@for="Single.GetHashCode"]/*' />
    	public unsafe override int GetHashCode() {
            float f = m_value;
            int v = *(int*)(&f);
            return v;
        }
        	
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.ToString"]/*' />
        public override String ToString() {
            return ToString(null, null);
        }


        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatSingle(m_value, format, NumberFormatInfo.GetInstance(provider));
        }
    
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.Parse"]/*' />
        public static float Parse(String s) {
            return Parse(s, NumberStyles.Float | NumberStyles.AllowThousands, null);
        }
    
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.Parse1"]/*' />
        public static float Parse(String s, NumberStyles style) {
            return Parse(s, style, null);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.Parse2"]/*' />
        public static float Parse(String s, IFormatProvider provider) {
            return Parse(s, NumberStyles.Float | NumberStyles.AllowThousands, provider);
        }
    
    	// Parses a float from a String in the given style.  If
    	// a NumberFormatInfo isn't specified, the current culture's 
    	// NumberFormatInfo is assumed.
    	// 
    	// This method will not throw an OverflowException, but will return 
    	// PositiveInfinity or NegativeInfinity for a number that is too 
    	// large or too small.
    	// 
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.Parse3"]/*' />
        public static float Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
            try {
                return Number.ParseSingle(s, style, info);
            } catch (FormatException) {
                //If we caught a FormatException, it may be from one of our special strings.
                //Check the three with which we're concerned and rethrow if it's not one of
                //those strings.
                String sTrim = s.Trim();
                if (sTrim.Equals(info.PositiveInfinitySymbol)) {
                    return PositiveInfinity;
                } 
                if (sTrim.Equals(info.NegativeInfinitySymbol)) {
                    return NegativeInfinity;
                }
                if (sTrim.Equals(info.NaNSymbol)) {
                    return NaN;
                }
                //Rethrow the previous exception;
                throw;
            }
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.ToString3"]/*' />
        public String ToString(IFormatProvider provider) {
            return ToString(null, provider);
        }
    
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.Single;
        }


        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Single", "Char"));
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "Single", "DateTime"));
        }

        /// <include file='doc\Single.uex' path='docs/doc[@for="Single.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = 0;
		}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\sbyte.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SByte
**
** Author: Jay Roxe (jroxe)
**
** Purpose: 
**
** Date:  March 15, 1998
**
===========================================================*/
namespace System {
	using System.Globalization;
	using System;
	using System.Runtime.InteropServices;

    // A place holder class for signed bytes.
    /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte"]/*' />
    [Serializable, CLSCompliant(false), System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
    public struct SByte : IComparable, IFormattable, IConvertible
    {
        private sbyte m_value;
    
        // The maximum value that a Byte may represent: 127.
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.MaxValue"]/*' />
        public const sbyte MaxValue = (sbyte)0x7F;
    
        // The minimum value that a Byte may represent: -128.
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.MinValue"]/*' />
        public const sbyte MinValue = unchecked((sbyte)0x80);

    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type SByte, this method throws an ArgumentException.
        // 
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.CompareTo"]/*' />
        public int CompareTo(Object obj) {
            if (obj == null) {
                return 1;
            }
            if (!(obj is SByte)) {
                throw new ArgumentException (Environment.GetResourceString("Arg_MustBeSByte"));
            }
            return m_value - ((SByte)obj).m_value;
        }
    
        // Determines whether two Byte objects are equal.
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is SByte)) {
                return false;
            }
            return m_value == ((SByte)obj).m_value;
        }
    

        // Gets a hash code for this instance.
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.GetHashCode"]/*' />
        public override int GetHashCode() {
            return ((int)m_value ^ (int)m_value << 8);
        }
    
        	
        // Provides a string representation of a byte.
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.ToString"]/*' />
        public override String ToString() {
            return ToString(null, NumberFormatInfo.CurrentInfo);
        }
    
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            if (m_value<0 && format!=null && format.Length>0 && (format[0]=='X' || format[0]=='x')) {
                uint temp = (uint)(m_value & 0x000000FF);
                return Number.FormatUInt32(temp,format, NumberFormatInfo.GetInstance(provider));
            }
            return Number.FormatInt32(m_value, format, NumberFormatInfo.GetInstance(provider));
        }
    
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.Parse"]/*' />
    	[CLSCompliant(false)]
        public static sbyte Parse(String s) {
            return Parse(s, NumberStyles.Integer, null);
        }
    
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.Parse1"]/*' />
    	[CLSCompliant(false)]
        public static sbyte Parse(String s, NumberStyles style) {
			NumberFormatInfo.ValidateParseStyle(style);	
            return Parse(s, style, null);
        }



        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.Parse2"]/*' />
    	[CLSCompliant(false)]
        public static sbyte Parse(String s, IFormatProvider provider) {
            return Parse(s, NumberStyles.Integer, provider);
        }
    
    	// Parses a signed byte from a String in the given style.  If
    	// a NumberFormatInfo isn't specified, the current culture's 
    	// NumberFormatInfo is assumed.
    	// 
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.Parse3"]/*' />
    	[CLSCompliant(false)]
        public static sbyte Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);

			NumberFormatInfo.ValidateParseStyle(style);	
            int i = Number.ParseInt32(s, style, info);

			if (((style & NumberStyles.AllowHexSpecifier) != 0) && (i <= Byte.MaxValue)) // We are parsing a hexadecimal number
					return (sbyte)i;
						
			if (i < MinValue || i > MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
			return (sbyte)i;
        }
	
	    /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.ToString3"]/*' />
	    public String ToString(IFormatProvider provider) {
            return ToString(null, provider);
        }
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.SByte;
        }


        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "SByte", "DateTime"));
        }

        /// <include file='doc\SByte.uex' path='docs/doc[@for="SByte.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = m_value;	
		}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\serializableattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: SerializableAttribute
**
** Author: Jay Roxe
**
** Purpose: Used to mark a class as being serializable
**
** Date: April 13, 2000
**
============================================================*/
namespace System {

    using System;

    /// <include file='doc\SerializableAttribute.uex' path='docs/doc[@for="SerializableAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Delegate, Inherited = false)]
    public sealed class SerializableAttribute : Attribute {

        /// <include file='doc\SerializableAttribute.uex' path='docs/doc[@for="SerializableAttribute.SerializableAttribute"]/*' />
        public SerializableAttribute() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtimetypehandle.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {

    using System.Runtime.Serialization;
	using System;
    //  This value type is used for making Type.GetTypeFromHandle() type safe. 
    // 
    //  SECURITY : m_ptr cannot be set to anything other than null by untrusted
    //  code.  
    // 
    //  This corresponds to EE TypeHandle.
    /// <include file='doc\RuntimeTypeHandle.uex' path='docs/doc[@for="RuntimeTypeHandle"]/*' />
	 [Serializable()]
    public struct RuntimeTypeHandle : ISerializable
    {
        private IntPtr m_ptr;

        /// <include file='doc\RuntimeTypeHandle.uex' path='docs/doc[@for="RuntimeTypeHandle.Value"]/*' />
        public IntPtr Value {
            get {
                return m_ptr;
            }
        }

		// ISerializable interface
		private RuntimeTypeHandle(SerializationInfo info, StreamingContext context)
		{
			if (info==null) {
                throw new ArgumentNullException("info");
            }
			Type m = (RuntimeType) info.GetValue("TypeObj", typeof(RuntimeType));
			m_ptr = m.TypeHandle.m_ptr;
			if (m_ptr == (IntPtr)0)
			    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientState"));
		}

		/// <include file='doc\RuntimeTypeHandle.uex' path='docs/doc[@for="RuntimeTypeHandle.GetObjectData"]/*' />
		public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
			if (m_ptr == (IntPtr)0)
			    throw new SerializationException(Environment.GetResourceString("Serialization_InvalidFieldState"));
			RuntimeType type = (RuntimeType)Type.GetTypeFromHandle(this); 
            BCLDebug.Assert(type!=null, "[RuntimeTypeHandle.GetObjectData]type!=null");
		    info.AddValue("TypeObj",type,typeof(RuntimeType));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\sharedstatics.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: SharedStatics
**
** Author: Jennifer Hamilton (jenh)
**
** Purpose: Container for statics that are shared across AppDomains.
**
** Date: May 9, 2000
**
=============================================================================*/

namespace System {

    using System.Threading;
    using System.Runtime.Remoting;
    using System.Security;
    using System.Security.Cryptography;
    using System.Security.Util;

    internal sealed class SharedStatics
    {
        // this is declared static but is actually forced to be the same object 
        // for each AppDomain at AppDomain create time.
        internal static SharedStatics _sharedStatics;
        
        // when we create the single object we can construct anything we will need
        // here. If not too many, then just create them all in the constructor, otherwise
        // can have the property check & create. Need to be aware of threading issues 
        // when do so though.
        SharedStatics() {
            _Remoting_Identity_IDGuid = null;
            _Remoting_Identity_IDSeqNum = 0x40; // Reserve initial numbers for well known objects.
        }

        private String _Remoting_Identity_IDGuid;
        public static String Remoting_Identity_IDGuid 
        { 
            get 
            {
                if (_sharedStatics._Remoting_Identity_IDGuid == null)
                {
                    lock (_sharedStatics)
                    {
                        if (_sharedStatics._Remoting_Identity_IDGuid == null)
                        {
                            _sharedStatics._Remoting_Identity_IDGuid = Guid.NewGuid().ToString().Replace('-', '_');
                        }
                    }
                }

                BCLDebug.Assert(_sharedStatics._Remoting_Identity_IDGuid != null,
                                "_sharedStatics._Remoting_Identity_IDGuid != null");
                return _sharedStatics._Remoting_Identity_IDGuid;
            } 
        }

        //REVIEW: do we need this?
        private int _Remoting_Identity_IDSeqNum;
        public static int Remoting_Identity_GetNextSeqNum()
        {
            return Interlocked.Increment(ref _sharedStatics._Remoting_Identity_IDSeqNum);
        }

        private PermissionTokenFactory _Security_PermissionTokenFactory;
        public static PermissionTokenFactory Security_PermissionTokenFactory
        {
            get
            {
                if (_sharedStatics._Security_PermissionTokenFactory == null)
                {
                    lock (_sharedStatics)
                    {
                        if (_sharedStatics._Security_PermissionTokenFactory == null)
                        {
                            _sharedStatics._Security_PermissionTokenFactory =
                                new PermissionTokenFactory( 16 );
                        }
                    }
                }
                return _sharedStatics._Security_PermissionTokenFactory;
            }
        }

        // These next two field/property combos are for the crypto classes
        // to speed things up when you do lots of MD5 and/or SHA1 hash operations.

        private IntPtr _Crypto_SHA1CryptoServiceProviderContext;
        public static IntPtr Crypto_SHA1CryptoServiceProviderContext
        {
            get {
                return _sharedStatics._Crypto_SHA1CryptoServiceProviderContext;
            }
            set {
                if (value == (IntPtr) 0) return;
                if (_sharedStatics._Crypto_SHA1CryptoServiceProviderContext == (IntPtr) 0)
                {
                    lock (_sharedStatics)
                    {
                        if (_sharedStatics._Crypto_SHA1CryptoServiceProviderContext == (IntPtr) 0)
                        {
                            _sharedStatics._Crypto_SHA1CryptoServiceProviderContext = value;
                        }
                    }
                }
            }
        }

        private IntPtr _Crypto_MD5CryptoServiceProviderContext;
        public static IntPtr Crypto_MD5CryptoServiceProviderContext
        {
            get {
                return _sharedStatics._Crypto_MD5CryptoServiceProviderContext;
            }
            set {
                if (value == (IntPtr) 0) return;
                if (_sharedStatics._Crypto_MD5CryptoServiceProviderContext == (IntPtr) 0)
                {
                    lock (_sharedStatics)
                    {
                        if (_sharedStatics._Crypto_MD5CryptoServiceProviderContext == (IntPtr) 0)
                        {
                            _sharedStatics._Crypto_MD5CryptoServiceProviderContext = value;
                        }
                    }
                }
            }
        }

        private IntPtr _Crypto_RNGCryptoServiceProviderContext;
        public static IntPtr Crypto_RNGCryptoServiceProviderContext
        {
            get {
                return _sharedStatics._Crypto_RNGCryptoServiceProviderContext;
            }
            set {
                if (value == IntPtr.Zero) return;
                if (_sharedStatics._Crypto_RNGCryptoServiceProviderContext == IntPtr.Zero)
                {
                    lock (_sharedStatics)
                    {
                        if (_sharedStatics._Crypto_RNGCryptoServiceProviderContext == IntPtr.Zero)
                        {
                            _sharedStatics._Crypto_RNGCryptoServiceProviderContext = value;
                        }
                    }
                }
            }
        }

        private static ConfigId m_currentConfigId;
        public static ConfigId GetNextConfigId()
        {
            ConfigId id;

            lock (_sharedStatics)
            {
                if (m_currentConfigId == 0)
                    m_currentConfigId = ConfigId.Reserved;
                id = m_currentConfigId++;
            }
            
            return id;
        }

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            _sharedStatics = null;
        }
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\specialfolder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using Microsoft.Win32;
namespace System
{
	/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder"]/*' />
	[Serializable]
	public enum SpecialFolder {
		//  
		//      Represents the file system directory that serves as a common repository for
		//       application-specific data for the current, roaming user. 
		//     A roaming user works on more than one computer on a network. A roaming user's 
		//       profile is kept on a server on the network and is loaded onto a system when the
		//       user logs on. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.ApplicationData"]/*' />
		ApplicationData =  Win32Native.CSIDL_APPDATA,
		//  
		//      Represents the file system directory that serves as a common repository for application-specific data that
		//       is used by all users. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.CommonApplicationData"]/*' />
		CommonApplicationData =  Win32Native.CSIDL_COMMON_APPDATA,
		//  
		//     Represents the file system directory that serves as a common repository for application specific data that
		//       is used by the current, non-roaming user. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.LocalApplicationData"]/*' />
		LocalApplicationData =  Win32Native.CSIDL_LOCAL_APPDATA,
		//  
		//     Represents the file system directory that serves as a common repository for Internet
		//       cookies. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.Cookies"]/*' />
		Cookies =  Win32Native.CSIDL_COOKIES,
		//  
		//     Represents the file system directory that serves as a common repository for the user's
		//       favorite items. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.Favorites"]/*' />
		Favorites =  Win32Native.CSIDL_FAVORITES,
		//  
		//     Represents the file system directory that serves as a common repository for Internet
		//       history items. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.History"]/*' />
		History =  Win32Native.CSIDL_HISTORY,
		//  
		//     Represents the file system directory that serves as a common repository for temporary 
		//       Internet files. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.InternetCache"]/*' />
		InternetCache =  Win32Native.CSIDL_INTERNET_CACHE,
		//  
		//      Represents the file system directory that contains
		//       the user's program groups. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.Programs"]/*' />
		Programs =  Win32Native.CSIDL_PROGRAMS,
		//  
		//     Represents the file system directory that contains the user's most recently used
		//       documents. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.Recent"]/*' />
		Recent =  Win32Native.CSIDL_RECENT,
		//  
		//     Represents the file system directory that contains Send To menu items. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.SendTo"]/*' />
		SendTo =  Win32Native.CSIDL_SENDTO,
		//  
		//     Represents the file system directory that contains the Start menu items. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.StartMenu"]/*' />
		StartMenu =  Win32Native.CSIDL_STARTMENU,
		//  
		//     Represents the file system directory that corresponds to the user's Startup program group. The system
		//       starts these programs whenever any user logs on to Windows NT, or
		//       starts Windows 95 or Windows 98. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.Startup"]/*' />
		Startup =  Win32Native.CSIDL_STARTUP,
		//  
		//     System directory.
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.System"]/*' />
		System =  Win32Native.CSIDL_SYSTEM,
		//  
		//     Represents the file system directory that serves as a common repository for document
		//       templates. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.Templates"]/*' />
		Templates =  Win32Native.CSIDL_TEMPLATES,
		//  
		//     Represents the file system directory used to physically store file objects on the desktop.
		//       This should not be confused with the desktop folder itself, which is
		//       a virtual folder. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.DesktopDirectory"]/*' />
		DesktopDirectory =  Win32Native.CSIDL_DESKTOPDIRECTORY,
		//  
		//     Represents the file system directory that serves as a common repository for documents. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.Personal"]/*' />
		Personal =  Win32Native.CSIDL_PERSONAL,
		//  
		//     Represents the program files folder. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.ProgramFiles"]/*' />
		ProgramFiles =  Win32Native.CSIDL_PROGRAM_FILES,
		//  
		//     Represents the folder for components that are shared across applications. 
		//  
		/// <include file='doc\SpecialFolder.uex' path='docs/doc[@for="SpecialFolder.CommonProgramFiles"]/*' />
		CommonProgramFiles =  Win32Native.CSIDL_PROGRAM_FILES_COMMON,
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\systemexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
 
	using System;
	using System.Runtime.Serialization;
	/// <include file='doc\SystemException.uex' path='docs/doc[@for="SystemException"]/*' />
    [Serializable()] 
	public class SystemException : Exception
    {
        /// <include file='doc\SystemException.uex' path='docs/doc[@for="SystemException.SystemException"]/*' />
        public SystemException() 
            : base(Environment.GetResourceString("Arg_SystemException")) {
    		SetErrorCode(__HResults.COR_E_SYSTEM);
        }
        
        /// <include file='doc\SystemException.uex' path='docs/doc[@for="SystemException.SystemException1"]/*' />
        public SystemException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_SYSTEM);
        }
    	
        /// <include file='doc\SystemException.uex' path='docs/doc[@for="SystemException.SystemException2"]/*' />
        public SystemException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_SYSTEM);
        }

        /// <include file='doc\SystemException.uex' path='docs/doc[@for="SystemException.SystemException3"]/*' />
        protected SystemException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\stackoverflowexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: StackOverflowException
**
** Author: Derek Yenzer (dereky)
**
** Purpose: The exception class for stack overflow.
**
** Date: March 25, 1998
**
=============================================================================*/

namespace System {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\StackOverflowException.uex' path='docs/doc[@for="StackOverflowException"]/*' />
    [Serializable()] public sealed class StackOverflowException : SystemException {
        /// <include file='doc\StackOverflowException.uex' path='docs/doc[@for="StackOverflowException.StackOverflowException"]/*' />
        public StackOverflowException() 
            : base(Environment.GetResourceString("Arg_StackOverflowException")) {
    		SetErrorCode(__HResults.COR_E_STACKOVERFLOW);
        }
    
        /// <include file='doc\StackOverflowException.uex' path='docs/doc[@for="StackOverflowException.StackOverflowException1"]/*' />
        public StackOverflowException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_STACKOVERFLOW);
        }
    	
        /// <include file='doc\StackOverflowException.uex' path='docs/doc[@for="StackOverflowException.StackOverflowException2"]/*' />
        public StackOverflowException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_STACKOVERFLOW);
        }

        internal StackOverflowException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\string.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  String
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Contains headers for the String class.  Actual implementations
** are in String.cpp
**
** Date:  March 15, 1998
**
===========================================================*/
namespace System {
	using System.Text;
	using System;
	using System.Globalization;
	using System.Threading;
	using System.Collections;
	using System.Runtime.CompilerServices;
	using va_list = System.ArgIterator;
    using __UnmanagedMemoryStream = System.IO.__UnmanagedMemoryStream;
    //
    // For Information on these methods, please see COMString.cpp
    //
    // The String class represents a static string of characters.  Many of
    // the String methods perform some type of transformation on the current
    // instance and return the result as a new String. All comparison methods are
    // implemented as a part of String.  As with arrays, character positions
    // (indices) are zero-based.
    //
    /// <include file='doc\String.uex' path='docs/doc[@for="String"]/*' />
    [Serializable] public sealed class String : IComparable, ICloneable, IConvertible, IEnumerable {
        
        //
        //NOTE NOTE NOTE NOTE
        //These fields map directly onto the fields in an EE StringObject.  See object.h for the layout.
        //Don't change these fields or add any new fields without first talking to JRoxe.
        //
        [NonSerialized]private int  m_arrayLength;
        [NonSerialized]private int  m_stringLength;
        [NonSerialized]private char m_firstChar;

        //private static readonly char FmtMsgMarkerChar='%';
        //private static readonly char FmtMsgFmtCodeChar='!';
        //These are defined in Com99/src/vm/COMStringCommon.h and must be kept in sync.
        private const int TrimHead = 0;
        private const int TrimTail = 1;
        private const int TrimBoth = 2;
    
        // The Empty constant holds the empty string value.
        //We need to call the String constructor so that the compiler doesn't mark this as a literal.
        //Marking this as a literal would mean that it doesn't show up as a field which we can access 
        //from native.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Empty"]/*' />
        public static readonly String Empty = "";
    
        //
        //Native Static Methods
        //
    
        // Joins an array of strings together as one string with a separator between each original string.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Join"]/*' />
        public static String Join (String separator, String[] value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return Join(separator, value, 0, value.Length);
        }
    
        // Joins an array of strings together as one string with a separator between each original string.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Join1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String Join (String separator, String[] value, int startIndex, int count);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeCompareOrdinal(String strA, String strB, bool bIgnoreCase);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeCompareOrdinalEx(String strA, int indexA, String strB, int indexB, int count);
        //This will not work in case-insensitive mode for any character greater than 0x80.  
        //We'll throw an ArgumentException.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe internal static extern int nativeCompareOrdinalWC(String strA, char *strBChars, bool bIgnoreCase, out bool success);


        //
        // This is a helper method for the security team.  They need to uppercase some strings (guaranteed to be less 
        // than 0x80) before security is fully initialized.  Without security initialized, we can't grab resources (the nlp's)
        // from the assembly.  This provides a workaround for that problem and should NOT be used anywhere else.
        //
        internal static String SmallCharToUpper(String strA) {
            String newString = FastAllocateString(strA.Length);
            nativeSmallCharToUpper(strA, newString);
            return newString;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nativeSmallCharToUpper(String strIn, String strOut);

        // This is a helper method for the security team.  They need to construct strings from a char[]
        // within their homebrew XML parser.  They guarantee that the char[] they pass in isn't null and
        // that the provided indices are valid so we just stuff real fast.
        internal static String CreateFromCharArray( char[] array, int start, int count )
        {
            String newString = FastAllocateString( count );
            FillStringArray( newString, 0, array, start, count );
            return newString;
        }

        //
        //
        // NATIVE INSTANCE METHODS
        //
        //
    
        //
        // Search/Query methods
        //
    
        // Determines whether two strings match.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Equals"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override bool Equals(Object obj);
    
        // Determines whether two strings match.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Equals1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern bool Equals(String value);
    
        // Determines whether two Strings match.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Equals2"]/*' />
        public static bool Equals(String a, String b) {
    		if ((Object)a==(Object)b) {
                return true;
            }
    
            if ((Object)a==null || (Object)b==null) {
                return false;
            }
    
            return a.Equals(b);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.operatorEQ"]/*' />
        public static bool operator == (String a, String b) {
           return String.Equals(a, b);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.operatorNE"]/*' />
        public static bool operator != (String a, String b) {
           return !String.Equals(a, b);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern char InternalGetChar(int index);
    
        // Gets the character at a specified position.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.this"]/*' />
        [System.Runtime.CompilerServices.IndexerName("Chars")]
        public char this[int index] {
            get { return InternalGetChar(index); }
        }

        // Converts a substring of this string to an array of characters.  Copies the
        // characters of this string beginning at position startIndex and ending at
        // startIndex + length - 1 to the character array buffer, beginning
        // at bufferStartIndex.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.CopyTo"]/*' />
        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)
		{
		    if (destination == null) 
                throw new ArgumentNullException("destination");
		    if (count < 0)
				throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NegativeCount"));
		    if (sourceIndex < 0)
				throw new ArgumentOutOfRangeException("sourceIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
		    if (count > Length - sourceIndex)
				throw new ArgumentOutOfRangeException("sourceIndex", Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
		    if (destinationIndex > destination.Length-count || destinationIndex < 0)
				throw new ArgumentOutOfRangeException("destinationIndex", Environment.GetResourceString("ArgumentOutOfRange_IndexCount"));
			InternalCopyTo(sourceIndex, destination, destinationIndex, count);
		}

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalCopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void CopyToByteArray(int sourceIndex, byte[] destination, int destinationIndex, int charCount);
    
        // Returns the entire string as an array of characters.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.ToCharArray"]/*' />
        public char[] ToCharArray() {
            return ToCharArray(0,Length);
        }
    
        // Returns a substring of this string as an array of characters.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.ToCharArray1"]/*' />
        public char[] ToCharArray(int startIndex, int length)
		{
			// Range check everything.
			if (startIndex < 0 || startIndex > Length || startIndex > Length - length)
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
			if (length < 0)
                throw new ArgumentOutOfRangeException("length", Environment.GetResourceString("ArgumentOutOfRange_Index"));

			char[] chars = new char[length];
	        InternalCopyTo(startIndex, chars, 0, length);
			return chars;
		}
    
        // Gets a hash code for this string.  If strings A and B are such that A.Equals(B), then
        // they will return the same hash code.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.GetHashCode"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override int GetHashCode();
    
        // Gets the length of this string
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Length"]/*' />
        public int Length {
            get { return InternalLength(); }
        }
    
		/// This is a EE implemented function so that the JIT can recognise is specially
		/// and eliminate checks on character fetchs.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int InternalLength();
    
        ///<internalonly/>
		internal int ArrayLength {
			get { return (m_arrayLength); }
		}

        // Used by StringBuilder
        internal int Capacity {
			get { return (m_arrayLength - 1); }
		}

        // Creates an array of strings by splitting this string at each
        // occurence of a separator.  The separator is searched for, and if found,
        // the substring preceding the occurence is stored as the first element in
        // the array of strings.  We then continue in this manner by searching
        // the substring that follows the occurence.  On the other hand, if the separator
        // is not found, the array of strings will contain this instance as its only element.
        // If the separator is null
        // whitespace (i.e., Character.IsWhitespace) is used as the separator.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Split"]/*' />
        public String [] Split(params char [] separator) {
            return Split(separator, Int32.MaxValue);
        }
    
        // Creates an array of strings by splitting this string at each
        // occurence of a separator.  The separator is searched for, and if found,
        // the substring preceding the occurence is stored as the first element in
        // the array of strings.  We then continue in this manner by searching
        // the substring that follows the occurence.  On the other hand, if the separator
        // is not found, the array of strings will contain this instance as its only element.
        // If the spearator is the empty string (i.e., String.Empty), then
        // whitespace (i.e., Character.IsWhitespace) is used as the separator.
        // If there are more than count different strings, the last n-(count-1)
        // elements are concatenated and added as the last String.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Split1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern String[] Split(char[] separator, int count);
    
    
        // Returns a substring of this string.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Substring"]/*' />
        public String Substring (int startIndex) {
            return this.Substring (startIndex, Length-startIndex);
        }
    
        // Returns a substring of this string.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Substring1"]/*' />
        public String Substring (int startIndex, int length) {
            
            int thisLength = Length;
            
            //Bounds Checking.
            if (startIndex<0) {
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_StartIndex"));
            }

            if (length<0) {
                throw new ArgumentOutOfRangeException("length", Environment.GetResourceString("ArgumentOutOfRange_NegativeLength"));
            } 

            if (startIndex > thisLength-length) {
                throw new ArgumentOutOfRangeException("length", Environment.GetResourceString("ArgumentOutOfRange_IndexLength"));
            }

            String s = FastAllocateString(length);
            FillSubstring(s, 0, this, startIndex, length);

            return s;
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern String TrimHelper(char[] trimChars, int trimType);
    
        //This should really live on System.Globalization.CharacterInfo.  However,
        //Trim gets called by security while resgen is running, so we can't run
        //CharacterInfo's class initializer (which goes to native and looks for a 
        //resource table that hasn't yet been attached to the assembly when resgen
        //runs.  
        internal static readonly char[] WhitespaceChars =   
            { (char) 0x9, (char) 0xA, (char) 0xB, (char) 0xC, (char) 0xD, (char) 0x20, (char) 0xA0,
              (char) 0x2000, (char) 0x2001, (char) 0x2002, (char) 0x2003, (char) 0x2004, (char) 0x2005,
              (char) 0x2006, (char) 0x2007, (char) 0x2008, (char) 0x2009, (char) 0x200A, (char) 0x200B,
              (char) 0x3000, (char) 0xFEFF };
    
        // Removes a string of characters from the ends of this string.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Trim"]/*' />
        public String Trim(params char[] trimChars) {
            if (null==trimChars || trimChars.Length == 0) {
                trimChars=WhitespaceChars;
            }
            return TrimHelper(trimChars,TrimBoth);
        }
    
        // Removes a string of characters from the beginning of this string.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.TrimStart"]/*' />
        public String TrimStart(params char[] trimChars) {
            if (null==trimChars || trimChars.Length == 0) {
                trimChars=WhitespaceChars;
            }
            return TrimHelper(trimChars,TrimHead);
        }
    
    
        // Removes a string of characters from the end of this string.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.TrimEnd"]/*' />
        public String TrimEnd(params char[] trimChars) {
            if (null==trimChars || trimChars.Length == 0) {
                trimChars=WhitespaceChars;
            }
            return TrimHelper(trimChars,TrimTail);
        }
    
    
        // Creates a new string with the characters copied in from ptr. If
        // ptr is null, a string initialized to ";<;No Object>;"; (i.e.,
        // String.NullString) is created.
        //
        // Issue: This method is only accessible from VC.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.String"]/*' />
    	[CLSCompliant(false), MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe public extern String(char *value);
        /// <include file='doc\String.uex' path='docs/doc[@for="String.String1"]/*' />
    	[CLSCompliant(false), MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe public extern String(char *value, int startIndex, int length);
    
       /// <include file='doc\String.uex' path='docs/doc[@for="String.String2"]/*' />
    	[CLSCompliant(false), MethodImplAttribute(MethodImplOptions.InternalCall)]
       unsafe public extern String(sbyte *value);
        /// <include file='doc\String.uex' path='docs/doc[@for="String.String3"]/*' />
    	[CLSCompliant(false), MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe public extern String(sbyte *value, int startIndex, int length);

        /// <include file='doc\String.uex' path='docs/doc[@for="String.String4"]/*' />
    	[CLSCompliant(false), MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe public extern String(sbyte *value, int startIndex, int length, Encoding enc);
                
        unsafe static private String CreateString(sbyte *value, int startIndex, int length, Encoding enc) {
            if (enc == null)
                return new String(value, startIndex, length); // default to ANSI
            if (length < 0)
                throw new ArgumentOutOfRangeException("length",Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (startIndex < 0) {
                throw new ArgumentOutOfRangeException("startIndex",Environment.GetResourceString("ArgumentOutOfRange_StartIndex"));
            }
            if ((value + startIndex) < value) {
                // overflow check
                throw new ArgumentOutOfRangeException("startIndex",Environment.GetResourceString("ArgumentOutOfRange_PartialWCHAR"));
            }
            byte [] b = new byte[length];
            __UnmanagedMemoryStream.memcpy((byte*)value, startIndex, b, 0, length);
            return enc.GetString(b);
        }

        // For ASCIIEncoding::GetString()
        unsafe static internal String CreateStringFromASCII(byte[] bytes, int startIndex, int length) {
            BCLDebug.Assert(bytes != null, "need a byte[].");
            BCLDebug.Assert(startIndex >= 0 && (startIndex < bytes.Length || bytes.Length == 0), "startIndex >= 0 && startIndex < bytes.Length");
            BCLDebug.Assert(length >= 0 && length <= bytes.Length - startIndex, "length >= 0 && length <= bytes.Length - startIndex");
            if (length == 0)
                return String.Empty;
            String s = FastAllocateString(length);
            fixed(char* pChars = &s.m_firstChar) {
                for(int i=0; i<length; i++) 
                    pChars[i] = (char) (bytes[i+startIndex] & 0x7f);
            }
            return s;
        }

        // For Latin1Encoding::GetString()
        unsafe static internal String CreateStringFromLatin1(byte[] bytes, int startIndex, int length) {
            BCLDebug.Assert(bytes != null, "need a byte[].");
            BCLDebug.Assert(startIndex >= 0 && (startIndex < bytes.Length || bytes.Length == 0), "startIndex >= 0 && startIndex < bytes.Length");
            BCLDebug.Assert(length >= 0 && length <= bytes.Length - startIndex, "length >= 0 && length <= bytes.Length - startIndex");
            if (length == 0)
                return String.Empty;
            String s = FastAllocateString(length);
            fixed(char* pChars = &s.m_firstChar) {
                for(int i=0; i<length; i++) 
                    pChars[i] = (char) (bytes[i+startIndex] );
            }
            return s;
        }        
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static String FastAllocateString(int length);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static void FillString(String dest, int destPos, String src);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static void FillStringChecked(String dest, int destPos, String src);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static void FillStringEx(String dest, int destPos, String src,int srcLength);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static void FillStringArray(String dest, int stringStart, char[] array, int charStart, int count);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static void FillSubstring(String dest, int destPos, String src, int startPos, int count);


    
        // Creates a new string from the characters in a subarray.  The new string will
        // be created from the characters in value between startIndex and
        // startIndex + length - 1.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.String7"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern String(char [] value, int startIndex, int length);
    
        // Creates a new string from the characters in a subarray.  The new string will be
        // created from the characters in value.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.String5"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern String(char [] value);
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.String6"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern String(char c, int count);

    
        //
        //
        // INSTANCE METHODS
        //
        //
    
        // Provides a culture-correct string comparison. StrA is compared to StrB
        // to determine whether it is lexicographically less, equal, or greater, and then returns
        // either a negative integer, 0, or a positive integer; respectively.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Compare"]/*' />
        public static int Compare(String strA, String strB) {
            return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, strB, CompareOptions.None);
        }
    
        // Provides a culture-correct string comparison. strA is compared to strB
        // to determine whether it is lexicographically less, equal, or greater, and then a
        // negative integer, 0, or a positive integer is returned; respectively.
        // The case-sensitive option is set by ignoreCase
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Compare1"]/*' />
        public static int Compare(String strA, String strB, bool ignoreCase) {
            if (ignoreCase) {
                return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, strB, CompareOptions.IgnoreCase);
            }
            return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, strB, CompareOptions.None);
        }
    
        // Provides a culture-correct string comparison. strA is compared to strB
        // to determine whether it is lexicographically less, equal, or greater, and then a
        // negative integer, 0, or a positive integer is returned; respectively.
        // The case-sensitive option is set by ignoreCase, and the culture is set
        // by culture
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Compare2"]/*' />
        public static int Compare(String strA, String strB, bool ignoreCase, CultureInfo culture) {
            if (culture==null) {
                throw new ArgumentNullException("culture");
            }
    
            if (ignoreCase) {
                return culture.CompareInfo.Compare(strA, strB, CompareOptions.IgnoreCase);
            }
            return culture.CompareInfo.Compare(strA, strB, CompareOptions.None);
        }
    
        // Determines whether two string regions match.  The substring of strA beginning
        // at indexA of length count is compared with the substring of strB
        // beginning at indexB of the same length.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Compare3"]/*' />
        public static int Compare(String strA, int indexA, String strB, int indexB, int length) {
		    int lengthA = length;
		    int lengthB = length;

			if (strA!=null) {
				if (strA.Length - indexA < lengthA) {
				  lengthA = (strA.Length - indexA);
				}
			}

			if (strB!=null) {
				if (strB.Length - indexB < lengthB) {
					lengthB = (strB.Length - indexB);
				}
			}
            return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, indexA, lengthA, strB, indexB, lengthB, CompareOptions.None);
        }
    
    
        // Determines whether two string regions match.  The substring of strA beginning
        // at indexA of length count is compared with the substring of strB
        // beginning at indexB of the same length.  Case sensitivity is determined by the ignoreCase boolean.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Compare4"]/*' />
        public static int Compare(String strA, int indexA, String strB, int indexB, int length, bool ignoreCase) {
		    int lengthA = length;
		    int lengthB = length;

			if (strA!=null) {
				if (strA.Length - indexA < lengthA) {
				  lengthA = (strA.Length - indexA);
				}
			}

			if (strB!=null) {
				if (strB.Length - indexB < lengthB) {
					lengthB = (strB.Length - indexB);
				}
			}

            if (ignoreCase) {
                return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, indexA, lengthA, strB, indexB, lengthB, CompareOptions.IgnoreCase);
            }
            return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, indexA, lengthA, strB, indexB, lengthB, CompareOptions.None);
        }
    
        // Determines whether two string regions match.  The substring of strA beginning
        // at indexA of length length is compared with the substring of strB
        // beginning at indexB of the same length.  Case sensitivity is determined by the ignoreCase boolean,
        // and the culture is set by culture.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Compare5"]/*' />
        public static int Compare(String strA, int indexA, String strB, int indexB, int length, bool ignoreCase, CultureInfo culture) {
            if (culture==null) {
                throw new ArgumentNullException("culture");
            }

			int lengthA = length;
		    int lengthB = length;

			if (strA!=null) {
				if (strA.Length - indexA < lengthA) {
				  lengthA = (strA.Length - indexA);
				}
			}

			if (strB!=null) {
				if (strB.Length - indexB < lengthB) {
					lengthB = (strB.Length - indexB);
				}
			}
    
            if (ignoreCase) {
                return culture.CompareInfo.Compare(strA,indexA,lengthA, strB, indexB, lengthB,CompareOptions.IgnoreCase);
            } else {
                return culture.CompareInfo.Compare(strA,indexA,lengthA, strB, indexB, lengthB,CompareOptions.None);
            }
        }
    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. This method returns a value less than 0 if this is less than value, 0
        // if this is equal to value, or a value greater than 0
        // if this is greater than value.  Strings are considered to be
        // greater than all non-String objects.  Note that this means sorted 
        // arrays would contain nulls, other objects, then Strings in that order.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
    			return 1;
            }
            
            if (!(value is String)) {
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeString"));
            }

            return String.Compare(this,(String)value);
        }
    
        // Determines the sorting relation of StrB to the current instance.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.CompareTo1"]/*' />
        public int CompareTo(String strB) {
            if (strB==null) {
                return 1;
            }
            return CultureInfo.CurrentCulture.CompareInfo.Compare(this, strB, 0);
        }
    
        // Compares strA and strB using an ordinal (code-point) comparison.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.CompareOrdinal"]/*' />
        public static int CompareOrdinal(String strA, String strB) {
    		if (strA == null || strB == null) {
                if ((Object)strA==(Object)strB) { //they're both null;
                    return 0;
                }
                return (strA==null)? -1 : 1; //-1 if A is null, 1 if B is null.
            }
            
            return nativeCompareOrdinal(strA, strB, false);
        }
    
        // Compares strA and strB using an ordinal (code-point) comparison.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.CompareOrdinal1"]/*' />
        public static int CompareOrdinal(String strA, int indexA, String strB, int indexB, int length) {
    		if (strA == null || strB == null) {
                if ((Object)strA==(Object)strB) { //they're both null;
                    return 0;
                }
    
                return (strA==null)? -1 : 1; //-1 if A is null, 1 if B is null.
            }
    
            return nativeCompareOrdinalEx(strA, indexA, strB, indexB, length);
        }
    
    
        // Determines whether a specified string is a suffix of the the current instance.
        //
        // The case-sensitive and culture-sensitive option is set by options,
        // and the default culture is used.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.EndsWith"]/*' />
        public bool EndsWith(String value) {
            if (null==value) {
                throw new ArgumentNullException("value");
            }
            int valueLen = value.Length;
            int thisLen = this.Length;
            if (valueLen>thisLen) {
                return false;
            }
            return (0==Compare(this, thisLen-valueLen, value, 0, valueLen));
        }

		internal bool EndsWith(char value) {
            int thisLen = this.Length;
            if (thisLen != 0) {
                if (this[thisLen - 1] == value)
					return true;
            }
            return false;
        }
    
    
        // Returns the index of the first occurance of value in the current instance.
        // The search starts at startIndex and runs thorough the next count characters.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOf"]/*' />
        public int IndexOf(char value) {
            return IndexOf(value, 0, this.Length);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOf1"]/*' />
        public int IndexOf(char value, int startIndex) {
            return IndexOf(value, startIndex, this.Length - startIndex);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOf2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern int IndexOf(char value, int startIndex, int count);
    
        // Returns the index of the first occurance of any character in value in the current instance.
        // The search starts at startIndex and runs to endIndex-1. [startIndex,endIndex).
        //
        
		/// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOfAny1"]/*' />
        public int IndexOfAny(char [] anyOf) {
            return IndexOfAny(anyOf,0, this.Length);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOfAny2"]/*' />
        public int IndexOfAny(char [] anyOf, int startIndex) {
            return IndexOfAny(anyOf, startIndex, this.Length - startIndex);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOfAny3"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern int IndexOfAny(char [] anyOf, int startIndex, int count);
    
    
        // Determines the position within this string of the first occurence of the specified
        // string, according to the specified search criteria.  The search begins at
        // the first character of this string, it is case-sensitive and culture-sensitive,
        // and the default culture is used.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOf6"]/*' />
        public int IndexOf(String value) {
            return CultureInfo.CurrentCulture.CompareInfo.IndexOf(this,value);
        }
    
        // Determines the position within this string of the first occurence of the specified
        // string, according to the specified search criteria.  The search begins at
        // startIndex, it is case-sensitive and culture-sensitve, and the default culture is used.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOf7"]/*' />
        public int IndexOf(String value, int startIndex){
            return CultureInfo.CurrentCulture.CompareInfo.IndexOf(this,value,startIndex);
        }
    
        // Determines the position within this string of the first occurence of the specified
        // string, according to the specified search criteria.  The search begins at
        // startIndex, ends at endIndex and the default culture is used.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.IndexOf8"]/*' />
        public int IndexOf(String value, int startIndex, int count){
            if (startIndex + count > this.Length) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            return CultureInfo.CurrentCulture.CompareInfo.IndexOf(this, value, startIndex, count, CompareOptions.None);
        }
    
    
        // Returns the index of the last occurance of value in the current instance.
        // The search starts at startIndex and runs to endIndex. [startIndex,endIndex].
        // The character at position startIndex is included in the search.  startIndex is the larger
        // index within the string.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOf"]/*' />
        public int LastIndexOf(char value) {
            return LastIndexOf(value, this.Length-1, this.Length);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOf1"]/*' />
        public int LastIndexOf(char value, int startIndex){
            return LastIndexOf(value,startIndex,startIndex + 1);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOf2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern int LastIndexOf(char value, int startIndex, int count);
    
        // Returns the index of the last occurance of any character in value in the current instance.
        // The search starts at startIndex and runs to endIndex. [startIndex,endIndex].
        // The character at position startIndex is included in the search.  startIndex is the larger
        // index within the string.
        //
        
		/// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOfAny1"]/*' />
        public int LastIndexOfAny(char [] anyOf) {
            return LastIndexOfAny(anyOf,this.Length-1,this.Length);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOfAny2"]/*' />
        public int LastIndexOfAny(char [] anyOf, int startIndex) {
            return LastIndexOfAny(anyOf,startIndex,startIndex + 1);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOfAny3"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern int LastIndexOfAny(char [] anyOf, int startIndex, int count);
    
    
        // Returns the index of the last occurance of any character in value in the current instance.
        // The search starts at startIndex and runs to endIndex. [startIndex,endIndex].
        // The character at position startIndex is included in the search.  startIndex is the larger
        // index within the string.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOf6"]/*' />
        public int LastIndexOf(String value) {
            return LastIndexOf(value, this.Length-1,this.Length);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOf7"]/*' />
        public int LastIndexOf(String value, int startIndex) {
            return LastIndexOf(value, startIndex, startIndex + 1);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.LastIndexOf8"]/*' />
        public int LastIndexOf(String value, int startIndex, int count) {
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));
            }
            return CultureInfo.CurrentCulture.CompareInfo.LastIndexOf(this, value, startIndex, count, CompareOptions.None);
        }
    
    
        //
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.PadLeft"]/*' />
        public String PadLeft(int totalWidth) {
            return PadHelper(totalWidth, ' ', false);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.PadLeft1"]/*' />
        public String PadLeft(int totalWidth, char paddingChar) {
            return PadHelper(totalWidth, paddingChar, false);
        }
        
        /// <include file='doc\String.uex' path='docs/doc[@for="String.PadRight"]/*' />
        public String PadRight(int totalWidth) {
            return PadHelper(totalWidth, ' ', true);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.PadRight1"]/*' />
        public String PadRight(int totalWidth, char paddingChar) {
            return PadHelper(totalWidth, paddingChar, true);
        }
    
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String PadHelper(int totalWidth, char paddingChar, bool isRightPadded);
    
        // Determines whether a specified string is a prefix of the current instance
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.StartsWith"]/*' />
        public bool StartsWith(String value) {
            if (null==value) {
                throw new ArgumentNullException("value");
            }
            if (this.Length<value.Length) {
                return false;
            }
            return (0==Compare(this,0, value,0, value.Length));
        }
    
        // Creates a copy of this string in lower case.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.ToLower"]/*' />
        public String ToLower() {
            return this.ToLower(CultureInfo.CurrentCulture);
        }
    
        // Creates a copy of this string in lower case.  The culture is set by culture.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.ToLower1"]/*' />
        public String ToLower(CultureInfo culture) {
            if (culture==null) {
                throw new ArgumentNullException("culture");
            }
            return culture.TextInfo.ToLower(this);
        }
    
        // Creates a copy of this string in upper case.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.ToUpper"]/*' />
        public String ToUpper() {
            return this.ToUpper(CultureInfo.CurrentCulture);
        }
    
        // Creates a copy of this string in upper case.  The culture is set by culture.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.ToUpper1"]/*' />
        public String ToUpper(CultureInfo culture) {
            if (culture==null) {
                throw new ArgumentNullException("culture");
            }
            return culture.TextInfo.ToUpper(this);
        }
    
        // Returns this string.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.ToString"]/*' />
        public override String ToString() {
            return this;
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.ToString1"]/*' />
        public String ToString(IFormatProvider provider) {
            return this;
        }
    
        // Method required for the ICloneable interface.
        // There's no point in cloning a string since they're immutable, so we simply return this.
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Clone"]/*' />
        public Object Clone() {
            return this;
        }
    
    
        // Trims the whitespace from both ends of the string.  Whitespace is defined by
        // CharacterInfo.WhitespaceChars.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Trim1"]/*' />
        public String Trim() {
            return this.Trim(WhitespaceChars);
        }
    
        //
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Insert"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern String Insert(int startIndex, String value);
    
        // Replaces all instances of oldChar with newChar.
        //
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Replace"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern String Replace (char oldChar, char newChar);

	// This method contains the same functionality as StringBuilder Replace. The only difference is that
	// a new String has to be allocated since Strings are immutable
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Replace1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern String Replace (String oldValue, String newValue);
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Remove"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern String Remove(int startIndex, int count);
    
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Format"]/*' />
        public static String Format(String format, Object arg0) {
            return Format(null, format, new Object[] {arg0});
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Format1"]/*' />
        public static String Format(String format, Object arg0, Object arg1) {
            return Format(null, format, new Object[] {arg0, arg1});
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Format2"]/*' />
        public static String Format(String format, Object arg0, Object arg1, Object arg2) {
            return Format(null, format, new Object[] {arg0, arg1, arg2});
        }

    
		// Add this method in as a breaking change
		/*[CLSCompliant(false)] 
        public static String Format(String format, Object arg0, Object arg1, Object arg2, Object arg3, ...) {
            Object[]   objArgs;
            int        argCount;
    
            ArgIterator args = new ArgIterator(__args);

            //+4 to account for the 4 hard-coded arguments at the beginning of the list.
            argCount = args.GetRemainingCount() + 4;
    
            objArgs = new Object[argCount];
            
            //Handle the hard-coded arguments
            objArgs[0] = arg0;
            objArgs[1] = arg1;
            objArgs[2] = arg2;
            objArgs[3] = arg3;
                
            //Walk all of the args in the variable part of the argument list.
            for (int i=4; i<argCount; i++) {
                objArgs[i] = TypedReference.ToObject(args.GetNextArg());
            }

            return Format(format, objArgs, null);
        }*/

        /// <include file='doc\String.uex' path='docs/doc[@for="String.Format3"]/*' />
        public static String Format(String format, params Object[] args) {
            return Format(null, format, args);
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Format4"]/*' />
        public static String Format( IFormatProvider provider, String format, params Object[] args) {
            if (format == null || args == null) 
                throw new ArgumentNullException((format==null)?"format":"args");
            StringBuilder sb = new StringBuilder(format.Length + args.Length * 8);
            sb.AppendFormat(provider,format,args);
            return sb.ToString();
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Copy"]/*' />
        public static String Copy (String str) {
            if (str==null) {
                throw new ArgumentNullException("str");
            }

            int length = str.Length;

            String result = FastAllocateString(length);
            FillString(result, 0, str);
            return result;
        }

        // Used by StringBuilder to avoid data corruption
        internal static String InternalCopy (String str) {
            int length = str.Length;
            String result = FastAllocateString(length);
            FillStringEx(result, 0, str, length); // The underlying's String can changed length is StringBuilder
            return result;
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat"]/*' />
        public static String Concat(Object arg0) {
            if (arg0==null) {
                return String.Empty;
            }
            return arg0.ToString();
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat1"]/*' />
        public static String Concat(Object arg0, Object arg1) {
            if (arg0==null) {
                arg0 = String.Empty;
            }
    
            if (arg1==null) {
                arg1 = String.Empty;
            }
            return Concat(arg0.ToString(), arg1.ToString());
        }
    
        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat2"]/*' />
        public static String Concat(Object arg0, Object arg1, Object arg2) {
            if (arg0==null) {
                arg0 = String.Empty;
            }
    
            if (arg1==null) {
                arg1 = String.Empty;
            }
    
            if (arg2==null) {
                arg2 = String.Empty;
            }
    
            return Concat(arg0.ToString(), arg1.ToString(), arg2.ToString());
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat3"]/*' />
		[CLSCompliant(false)] 
        public static String Concat(Object arg0, Object arg1, Object arg2, Object arg3, __arglist) 
		{
            Object[]   objArgs;
            int        argCount;
            
            ArgIterator args = new ArgIterator(__arglist);

            //+4 to account for the 4 hard-coded arguments at the beginning of the list.
            argCount = args.GetRemainingCount() + 4;
    
            objArgs = new Object[argCount];
            
            //Handle the hard-coded arguments
            objArgs[0] = arg0;
            objArgs[1] = arg1;
            objArgs[2] = arg2;
            objArgs[3] = arg3;
            
            //Walk all of the args in the variable part of the argument list.
            for (int i=4; i<argCount; i++) {
                objArgs[i] = TypedReference.ToObject(args.GetNextArg());
            }

            return Concat(objArgs);
        }


        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat4"]/*' />
        public static String Concat(params Object[] args) {
            if (args==null) {
                throw new ArgumentNullException("args");
            }
    
            String[] sArgs = new String[args.Length];
            int totalLength=0;
            
            for (int i=0; i<args.Length; i++) {
                object value = args[i];
                sArgs[i] = ((value==null)?(String.Empty):(value.ToString()));
                totalLength += sArgs[i].Length;
                // check for overflow
                if (totalLength < 0) {
                    throw new OutOfMemoryException();
                }
            }
            return ConcatArray(sArgs, totalLength);
        }


        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat5"]/*' />
        public static String Concat(String str0, String str1) {
			if (str0 == null) {
                if (str1==null) {
                    return String.Empty;
                }
                return str1;
            }

            if (str1==null) {
                return str0;
            }

            int str0Length = str0.Length;
            
            String result = FastAllocateString(str0Length + str1.Length);
            
            FillStringChecked(result, 0,        str0);
            FillStringChecked(result, str0Length, str1);
            
            return result;
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat6"]/*' />
        public static String Concat(String str0, String str1, String str2) {
            if (str0==null && str1==null && str2==null) {
                return String.Empty;
            }

            if (str0==null) {
                str0 = String.Empty;
            }

            if (str1==null) {
                str1 = String.Empty;
            }

            if (str2 == null) {
                str2 = String.Empty;
            }

            int totalLength = str0.Length + str1.Length + str2.Length;

            String result = FastAllocateString(totalLength);
            FillStringChecked(result, 0, str0);
            FillStringChecked(result, str0.Length, str1);
            FillStringChecked(result, str0.Length + str1.Length, str2);

            return result;
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat7"]/*' />
        public static String Concat(String str0, String str1, String str2, String str3) {
            if (str0==null && str1==null && str2==null && str3==null) {
                return String.Empty;
            }

            if (str0==null) {
                str0 = String.Empty;
            }

            if (str1==null) {
                str1 = String.Empty;
            }

            if (str2 == null) {
                str2 = String.Empty;
            }
            
            if (str3 == null) {
                str3 = String.Empty;
            }

            int totalLength = str0.Length + str1.Length + str2.Length + str3.Length;

            String result = FastAllocateString(totalLength);
            FillStringChecked(result, 0, str0);
            FillStringChecked(result, str0.Length, str1);
            FillStringChecked(result, str0.Length + str1.Length, str2);
            FillStringChecked(result, str0.Length + str1.Length + str2.Length, str3);

            return result;
        }

        private static String ConcatArray(String[] values, int totalLength) {
            String result =  FastAllocateString(totalLength);
            int currPos=0;

            for (int i=0; i<values.Length; i++) {
                BCLDebug.Assert((currPos + values[i].Length <= totalLength), 
                                "[String.ConcatArray](currPos + values[i].Length <= totalLength)");

                FillStringChecked(result, currPos, values[i]);
                currPos+=values[i].Length;
            }

            return result;
        }

        private static String[] CopyArrayOnNull(String[] values, out int totalLength) {
            totalLength = 0;
            
            String[] outValues = new String[values.Length];
            
            for (int i=0; i<values.Length; i++) {
                outValues[i] = ((values[i]==null)?String.Empty:values[i]);
                totalLength += outValues[i].Length;
            }
            return outValues;
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.Concat8"]/*' />
        public static String Concat(params String[] values) {
            int totalLength=0;

            if (values==null) {
                throw new ArgumentNullException("values");
            }

            // Always make a copy to prevent changing the array on another thread.
            String[] internalValues = new String[values.Length];
            
            for (int i = 0; i< values.Length; i++) {
                string value = values[i];
                internalValues[i] = ((value==null)?(String.Empty):(value));
                totalLength += internalValues[i].Length;
                // check for overflow
                if (totalLength < 0) {
                    throw new OutOfMemoryException();
                }
            }
            
            return ConcatArray(internalValues, totalLength);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.Intern"]/*' />
        public static String Intern(String str) {
            if (str==null) {
                throw new ArgumentNullException("str");
            }
            return Thread.GetDomain().GetOrInternString(str);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IsInterned"]/*' />
        public static String IsInterned(String str) {
            if (str==null) {
                throw new ArgumentNullException("str");
            }
            return Thread.GetDomain().IsStringInterned(str);
        }


        //
        // IValue implementation
        // 
    	
        /// <include file='doc\String.uex' path='docs/doc[@for="String.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.String;
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
		[CLSCompliant(false)]
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            return Convert.ToDateTime(this, provider);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		// Is this a string that can be compared quickly (that is it has only characters > 0x80 
		// and not a - or '
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool IsFastSort();
        
        ///<internalonly/>
		unsafe internal void SetChar(int index, char value)
		{
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif

			//Bounds check and then set the actual bit.
			if ((UInt32)index >= (UInt32)Length)
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));

			fixed (char *p = &this.m_firstChar) {
				// Set the character.
				p[index] = value;
            }
        }

#if _DEBUG
		// Only used in debug build. Insure that the HighChar state information for a string is not set as known
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
		private extern bool ValidModifiableString();
#endif

        ///<internalonly/>
		unsafe internal void AppendInPlace(char value,int currentLength)
		{
            BCLDebug.Assert(currentLength < m_arrayLength, "[String.AppendInPlace(char)currentLength < m_arrayLength");
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif

			fixed (char *p = &this.m_firstChar)
			{
				// Append the character.
				p[currentLength] = value;
				p[++currentLength] = '\0';
                m_stringLength = currentLength;
			}
		}


        ///<internalonly/>
		unsafe internal void AppendInPlace(char value, int repeatCount, int currentLength)
		{
            BCLDebug.Assert(currentLength+repeatCount < m_arrayLength, "[String.AppendInPlace]currentLength+repeatCount < m_arrayLength");
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif
            
            int newLength = currentLength + repeatCount;


			fixed (char *p = &this.m_firstChar)
			{
                int i;
                for (i=currentLength; i<newLength; i++) {
                    p[i] = value;
                }
                p[i] = '\0';
			}
            this.m_stringLength = newLength; 
		}

        ///<internalonly/>
       internal unsafe void AppendInPlace(String value, int currentLength) {
            BCLDebug.Assert(value!=null, "[String.AppendInPlace]value!=null");
            BCLDebug.Assert(value.Length + currentLength < this.m_arrayLength, "[String.AppendInPlace]Length is wrong.");
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif
            
            FillString(this, currentLength, value);
            SetLength(currentLength + value.Length);
            NullTerminate();	
        }
        
        internal void AppendInPlace(String value, int startIndex, int count, int currentLength) {
            BCLDebug.Assert(value!=null, "[String.AppendInPlace]value!=null");
            BCLDebug.Assert(count + currentLength < this.m_arrayLength, "[String.AppendInPlace]count + currentLength < this.m_arrayLength");
            BCLDebug.Assert(count>=0, "[String.AppendInPlace]count>=0");
            BCLDebug.Assert(startIndex>=0, "[String.AppendInPlace]startIndex>=0");
            BCLDebug.Assert(startIndex <= (value.Length - count), "[String.AppendInPlace]startIndex <= (value.Length - count)");
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif
            
            FillSubstring(this, currentLength, value, startIndex, count);
            SetLength(currentLength + count);
            NullTerminate();
        }

        internal unsafe void AppendInPlace(char *value, int count,int currentLength) {
            BCLDebug.Assert(value!=null, "[String.AppendInPlace]value!=null");
            BCLDebug.Assert(count + currentLength < this.m_arrayLength, "[String.AppendInPlace]count + currentLength < this.m_arrayLength");
            BCLDebug.Assert(count>=0, "[String.AppendInPlace]count>=0");
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif
            fixed(char *p = &this.m_firstChar) {
                int i;
                for (i=0; i<count; i++) {
                    p[currentLength+i] = value[i];
                }
            }
            SetLength(currentLength + count);
            NullTerminate();
        }


        ///<internalonly/>
        internal unsafe void AppendInPlace(char[] value, int start, int count, int currentLength) {
            BCLDebug.Assert(value!=null, "[String.AppendInPlace]value!=null");
            BCLDebug.Assert(count + currentLength < this.m_arrayLength, "[String.AppendInPlace]Length is wrong.");
            BCLDebug.Assert(value.Length-count>=start, "[String.AppendInPlace]value.Length-count>=start");
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif

            FillStringArray(this, currentLength, value, start, count);
            this.m_stringLength = (currentLength + count); 
            this.NullTerminate();
        }


        ///<internalonly/>
        unsafe internal void ReplaceCharInPlace(char oldChar, char newChar, int startIndex, int count,int currentLength) {
            BCLDebug.Assert(startIndex>=0, "[String.ReplaceCharInPlace]startIndex>0");
            BCLDebug.Assert(startIndex<=currentLength, "[String.ReplaceCharInPlace]startIndex>=Length");
            BCLDebug.Assert((startIndex<=currentLength-count), "[String.ReplaceCharInPlace]count>0 && startIndex<=currentLength-count");
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif

            int endIndex = startIndex+count;

            fixed (char *p = &this.m_firstChar) {
                for (int i=startIndex;i<endIndex; i++) {
                    if (p[i]==oldChar) {
                        p[i]=newChar;
                    }
                }
            }
        }


        ///<internalonly/>
        internal static String GetStringForStringBuilder(String value, int capacity) {
            BCLDebug.Assert(value!=null, "[String.GetStringForStringBuilder]value!=null");
            BCLDebug.Assert(capacity>=value.Length,  "[String.GetStringForStringBuilder]capacity>=value.Length");
            
            String newStr = FastAllocateString(capacity);
            if (value.Length==0) {
                newStr.m_stringLength=0;
                newStr.m_firstChar='\0';
                return newStr;
            }
            FillString(newStr, 0, value);
            newStr.m_stringLength = value.m_stringLength;
            return newStr;
        }

        ///<internalonly/>
        private unsafe void NullTerminate() {
            fixed(char *p = &this.m_firstChar) {
                p[m_stringLength] = '\0';
            }
        }

        ///<internalonly/>
        unsafe internal void ClearPostNullChar() {
            int newLength = Length+1;
            if (newLength<m_arrayLength) {
                fixed(char *p = &this.m_firstChar) {
                    p[newLength] = '\0';
                }
            }
        }

        ///<internalonly/>
        internal void SetLength(int newLength) {
            BCLDebug.Assert(newLength <= m_arrayLength, "newLength<=m_arrayLength");
            m_stringLength = newLength;
        }

        

        /// <include file='doc\String.uex' path='docs/doc[@for="String.GetEnumerator"]/*' />
        public CharEnumerator GetEnumerator() {
            BCLDebug.Perf(false, "Avoid using String's CharEnumerator until C# special cases foreach on String - use the indexed property on String instead.");
            return new CharEnumerator(this);
        }

        /// <include file='doc\String.uex' path='docs/doc[@for="String.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            BCLDebug.Perf(false, "Avoid using String's CharEnumerator until C# special cases foreach on String - use the indexed property on String instead.");
    		return new CharEnumerator(this);
        }

    	//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_arrayLength = 0;
			m_stringLength = 0;
			m_firstChar = m_firstChar;
		}
#endif

        internal unsafe void InternalSetCharNoBoundsCheck(int index, char value) {
            fixed (char *p = &this.m_firstChar) {
				p[index] = value;
            }
        }

         // Copies the source String (byte buffer) to the destination IntPtr memory allocated with len bytes.
        internal unsafe static void InternalCopy(String src, IntPtr dest,int len)
        {
            if (len == 0)
                return;
            fixed(char* charPtr = &src.m_firstChar) {
                byte* srcPtr = (byte*) charPtr;
                byte* dstPtr = (byte*) dest.ToPointer();
                System.IO.__UnmanagedMemoryStream.memcpyimpl(srcPtr, dstPtr, len);
            }
	    }

        // memcopies characters inside a String. 
        internal unsafe static void InternalMemCpy(String src, int srcOffset, String dst, int destOffset, int len)
        { 
            if (len == 0)
                return;
            fixed(char* srcPtr = &src.m_firstChar) {
                fixed(char* dstPtr = &dst.m_firstChar) {
                    System.IO.__UnmanagedMemoryStream.memcpyimpl((byte*)(srcPtr + srcOffset), (byte*)(dstPtr + destOffset), len);
                }
            }
	    }

        
/*      internal unsafe static void revmemcpyimpl(byte* src, byte* dest, int len) {
            dest += len;
            src += len;
            while (len-- > 0) {
                dest--;
                src--;
                *dest = *src;
            }
        }      
*/

        internal unsafe static void revmemcpyimpl(byte* src, byte* dest, int len) {
            if (len == 0)
                return;

            dest += len;
            src += len;
            
            if (((long)src & 3) != 0)
            {
                do{
                    dest--;
                    src--;
                    len--;
                    *dest = *src;
                } while (len > 0 && ((long)src & 3) != 0);
            }
            
            if (len >= 16){
                len -= 16;
                do{
                    dest -= (byte*)16;
                    src -= (byte*)16;
                    ((int*)dest)[3] = ((int*)src)[3];
                    ((int*)dest)[2] = ((int*)src)[2];
                    ((int*)dest)[1] = ((int*)src)[1];
                    ((int*)dest)[0] = ((int*)src)[0];
                    
                } while ((len -= 16) >= 0);
            }
            if ((len & 8) > 0) {
                dest -= (byte*)8;
                src -= (byte*)8;
                ((int*)dest)[1] = ((int*)src)[1];
                ((int*)dest)[0] = ((int*)src)[0];
            }
            if ((len & 4) > 0) {
                dest -= (byte*)4;
                src -= (byte*)4;
                ((int*)dest)[0] = ((int*)src)[0];
            }
            if ((len & 2) != 0) {
                dest -= (byte*)2;
                src -= (byte*)2;
                ((short*)dest)[0] = ((short*)src)[0];
            }
            if ((len & 1) != 0) {
                dest--;
                src--;
                *dest = *src;
            }
        }        




        // Copies the source String (byte buffer) to the destination IntPtr memory allocated with len bytes.
        internal unsafe static void InternalCopy(String src, byte[] dest,int len)
        {
            if (len == 0)
                return;
            fixed(char* charPtr = &src.m_firstChar) {
                fixed(byte* destPtr = dest) {
                    byte* srcPtr = (byte*) charPtr;
                    System.IO.__UnmanagedMemoryStream.memcpyimpl(srcPtr, destPtr, len);
                }
            }
	    }

        internal unsafe void InsertInPlace(int index, String value, int repeatCount, int currentLength, int requiredLength) {
            BCLDebug.Assert(requiredLength  < m_arrayLength, "[String.InsertString] requiredLength  < m_arrayLength");
            BCLDebug.Assert(index + value.Length * repeatCount < m_arrayLength, "[String.InsertString] index + value.Length * repeatCount < m_arrayLength");
#if _DEBUG
			BCLDebug.Assert(ValidModifiableString(), "Modifiable string must not have highChars flags set");
#endif
              //Copy the old characters over to make room and then insert the new characters.
            fixed(char* srcPtr = &this.m_firstChar) {
                fixed(char* valuePtr = &value.m_firstChar) {
                   revmemcpyimpl((byte*)(srcPtr + index),(byte*)(srcPtr + index + value.Length * repeatCount), (currentLength - index) * sizeof(char));
                   for (int i=0; i<repeatCount; i++) {
                        System.IO.__UnmanagedMemoryStream.memcpyimpl((byte*)valuePtr, (byte*)(srcPtr + index + i * value.Length), value.Length * sizeof(char));
                   }
                }
                srcPtr[requiredLength] = '\0';
            }
            this.m_stringLength = requiredLength; 
        }


        // This code is ifdef'ed out so we can refer to this in V2.  We believe
        // this is an interesting idea, but probably not something we want to
        // do in V1.  Patrick was concerned about tracking down all sorts of
        // heap corruption and potential problems with the concurrent GC.
#if MOTHBALL
        /*
        // Used in StringBuilder's FakeByteArray optimization.  Be VERY VERY
        // careful with this method since its purpose is to adjust the size of
        // an object on the GC heap.  It is VERY easy to accidentally corrupt
        // the heap this way.  -- BrianGru, 3/16/2001
        internal void SetArrayLengthDangerousForGC(int newCapacity) {
            BCLDebug.Assert(m_arrayLength > m_stringLength && newCapacity <= m_arrayLength, "Capacity must be at least one greater than the string length and can't be larger than current array length!");
            m_arrayLength = newCapacity;
        }
        */
#endif // MOTHBALL
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\timespan.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
	using System.Text;
	using System;

    // TimeSpan represents a duration of time.  A TimeSpan can be negative
    // or positive.
    // 
    // TimeSpan is internally represented as a number of milliseconds.  While
    // this maps well into units of time such as hours and days, any
    // periods longer than that aren't representable in a nice fashion.
    // For instance, a month can be between 28 and 31 days, while a year
    // can contain 365 or 364 days.  A decade can have between 1 and 3 leapyears,
    // depending on when you map the TimeSpan into the calendar.  This is why
    // we do not provide Years() or Months().
    // 
    /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan"]/*' />
    [Serializable] public struct TimeSpan : IComparable
    {
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TicksPerMillisecond"]/*' />
        public const long TicksPerMillisecond = 10000;
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TicksPerSecond"]/*' />
        public const long TicksPerSecond = TicksPerMillisecond * 1000;
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TicksPerMinute"]/*' />
        public const long TicksPerMinute = TicksPerSecond * 60;
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TicksPerHour"]/*' />
        public const long TicksPerHour = TicksPerMinute * 60;
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TicksPerDay"]/*' />
        public const long TicksPerDay = TicksPerHour * 24;
    
        private const int MillisPerSecond = 1000;
        private const int MillisPerMinute = MillisPerSecond * 60;
        private const int MillisPerHour = MillisPerMinute * 60;
        private const int MillisPerDay = MillisPerHour * 24;
    
    	private const long MaxSeconds = Int64.MaxValue / TicksPerSecond;
    	private const long MinSeconds = Int64.MinValue / TicksPerSecond;
    	
		private const long MaxMilliSeconds = Int64.MaxValue / TicksPerMillisecond;
    	private const long MinMilliSeconds = Int64.MinValue / TicksPerMillisecond;
    	

        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Zero"]/*' />
        public static readonly TimeSpan Zero = new TimeSpan(0);
    
    	/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.MaxValue"]/*' />
    	public static readonly TimeSpan MaxValue = new TimeSpan(Int64.MaxValue);
    	/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.MinValue"]/*' />
    	public static readonly TimeSpan MinValue = new TimeSpan(Int64.MinValue);
    
    	// internal so that DateTime doesn't have to call an extra get
    	// method for some arithmetic operations.
        internal long _ticks;
    
        //public TimeSpan() {
        //    _ticks = 0;
        //}
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TimeSpan"]/*' />
        public TimeSpan(long ticks) {
            this._ticks = ticks;
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TimeSpan1"]/*' />
        public TimeSpan(int hours, int minutes, int seconds) {
            _ticks = TimeToTicks(hours, minutes, seconds);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TimeSpan2"]/*' />
        public TimeSpan(int days, int hours, int minutes, int seconds)
			: this(days,hours,minutes,seconds,0)
		{
        }

		/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TimeSpan3"]/*' />
		public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds) 
		{
			decimal totalMilliSeconds = ((decimal)days * 3600 * 24 + hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds;	
			if (totalMilliSeconds > MaxMilliSeconds || totalMilliSeconds < MinMilliSeconds)
				throw new ArgumentOutOfRangeException(Environment.GetResourceString("Overflow_TimeSpanTooLong"));
			_ticks =  (long)totalMilliSeconds * TicksPerMillisecond;
		}
    
    	/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Ticks"]/*' />
    	public long Ticks {
    		get { return _ticks; }
    	}
    
    	/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Days"]/*' />
    	public int Days {
    		get { return (int)(_ticks / TicksPerDay); }	
    	}
    	
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Hours"]/*' />
        public int Hours {
    		get { return (int)((_ticks / TicksPerHour) % 24); }
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Milliseconds"]/*' />
        public int Milliseconds {
    		get { return (int)((_ticks / TicksPerMillisecond) % 1000); }
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Minutes"]/*' />
        public int Minutes {
            get { return (int)((_ticks / TicksPerMinute) % 60); }
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Seconds"]/*' />
        public int Seconds {
            get { return (int)((_ticks / TicksPerSecond) % 60); }
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TotalDays"]/*' />
        public double TotalDays {
            get { return ((double)_ticks) / (double)TicksPerDay; }
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TotalHours"]/*' />
        public double TotalHours {
            get { return (double)_ticks / (double)TicksPerHour; }
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TotalMilliseconds"]/*' />
        public double TotalMilliseconds {
            get { 
				double temp = (double)_ticks / (double)TicksPerMillisecond; 
				if (temp > MaxMilliSeconds)
					return (double)MaxMilliSeconds;

				if (temp < MinMilliSeconds)
					return (double)MinMilliSeconds;
				
				return temp;
			}
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TotalMinutes"]/*' />
        public double TotalMinutes {
            get { return (double)_ticks / (double)TicksPerMinute; }
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.TotalSeconds"]/*' />
        public double TotalSeconds {
    		get { return (double)_ticks / (double)TicksPerSecond; }
        }
    
    	/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Add"]/*' />
    	public TimeSpan Add(TimeSpan ts) {
    		long result = _ticks + ts._ticks;
    		// Overflow if signs of operands was identical and result's
    		// sign was opposite.
    		// >> 63 gives the sign bit (either 64 1's or 64 0's).
    		if ((_ticks >> 63 == ts._ticks >> 63) && (_ticks >> 63 != result >> 63))
    			throw new OverflowException(Environment.GetResourceString("Overflow_TimeSpanTooLong"));
            return new TimeSpan(result);
        }
    
        	
        // Compares two TimeSpan values, returning an integer that indicates their
        // relationship.
        //
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Compare"]/*' />
        public static int Compare(TimeSpan t1, TimeSpan t2) {
            if (t1._ticks > t2._ticks) return 1;
            if (t1._ticks < t2._ticks) return -1;
            return 0;
        }
    
        // Returns a value less than zero if this  object
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) return 1;
            if (!(value is TimeSpan)) 
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeTimeSpan"));
            long t = ((TimeSpan)value)._ticks;
            if (_ticks > t) return 1;
            if (_ticks < t) return -1;
            return 0;
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.FromDays"]/*' />
        public static TimeSpan FromDays(double value) {
            return Interval(value, MillisPerDay);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Duration"]/*' />
        public TimeSpan Duration() {
    		if (_ticks==TimeSpan.MinValue._ticks)
    			throw new OverflowException(Environment.GetResourceString("Overflow_NegateTwosCompNum"));
            return new TimeSpan(_ticks >= 0? _ticks: -_ticks);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Equals"]/*' />
        public override bool Equals(Object value) {
            if (value is TimeSpan) {
                return _ticks == ((TimeSpan)value)._ticks;
            }
            return false;
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Equals1"]/*' />
        public static bool Equals(TimeSpan t1, TimeSpan t2) {
            return t1._ticks == t2._ticks;
        }

        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.GetHashCode"]/*' />
        public override int GetHashCode() {
            return (int)_ticks ^ (int)(_ticks >> 32);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.FromHours"]/*' />
        public static TimeSpan FromHours(double value) {
            return Interval(value, MillisPerHour);
        }
    
        private static TimeSpan Interval(double value, int scale) {
			if (Double.IsNaN(value))
				throw new ArgumentException(Environment.GetResourceString("Arg_CannotBeNaN"));
    		double tmp = value * scale;
            long millis = (long)(tmp + (value >= 0? 0.5: -0.5));
    		// When value is NaN or -Inf, it becomes Int64.MinValue,
    		// and for +Inf it becomes Int64.MaxValue.  The overflow check works.
    		// Scale is always positive, which simplifies 1 of the 2 overflow checks
    		if ((millis > Int64.MaxValue / TicksPerMillisecond) || (millis < Int64.MinValue / TicksPerMillisecond)
    			|| (tmp < 0 && value > 0) || (tmp > 0 && value < 0))
    			throw new OverflowException(Environment.GetResourceString("Overflow_TimeSpanTooLong"));
            return new TimeSpan(millis * TicksPerMillisecond);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.FromMilliseconds"]/*' />
        public static TimeSpan FromMilliseconds(double value) {
            return Interval(value, 1);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.FromMinutes"]/*' />
        public static TimeSpan FromMinutes(double value) {
            return Interval(value, MillisPerMinute);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Negate"]/*' />
        public TimeSpan Negate() {
    		if (_ticks==TimeSpan.MinValue._ticks)
    			throw new OverflowException(Environment.GetResourceString("Overflow_NegateTwosCompNum"));
            return new TimeSpan(-_ticks);
        }
    
    	// Constructs a TimeSpan from a string.  Leading and trailing white 
    	// space characters are allowed.
    	// 
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Parse"]/*' />
        public static TimeSpan Parse(String s) {
            return new TimeSpan(new StringParser().Parse(s, true));
        }
    	
    	/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.FromSeconds"]/*' />
    	public static TimeSpan FromSeconds(double value) {
            return Interval(value, MillisPerSecond);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.Subtract"]/*' />
        public TimeSpan Subtract(TimeSpan ts) {
    		long result = _ticks - ts._ticks;
    		// Overflow if signs of operands was different and result's
    		// sign was opposite from the first argument's sign.
    		// >> 63 gives the sign bit (either 64 1's or 64 0's).
    		if ((_ticks >> 63 != ts._ticks >> 63) && (_ticks >> 63 != result >> 63))
    			throw new OverflowException(Environment.GetResourceString("Overflow_TimeSpanTooLong"));
            return new TimeSpan(result);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.FromTicks"]/*' />
        public static TimeSpan FromTicks(long value) {
            return new TimeSpan(value);
        }
    
        internal static long TimeToTicks(int hour, int minute, int second) {
    		// totalSeconds is bounded by 2^31 * 2^12 + 2^31 * 2^8 + 2^31, 
    		// which is less than 2^44, meaning we won't overflow totalSeconds.
    		long totalSeconds = (long)hour * 3600 + (long)minute * 60 + (long)second;
    		if (totalSeconds > MaxSeconds || totalSeconds < MinSeconds)
    			throw new ArgumentOutOfRangeException(Environment.GetResourceString("Overflow_TimeSpanTooLong"));
    		return totalSeconds * TicksPerSecond;
        }
    
        private String IntToString(int n, int digits) {
            return ParseNumbers.IntToString(n, 10, digits, '0', 0);
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.ToString"]/*' />
        public override String ToString() {
            StringBuilder sb = new StringBuilder();
            int day = (int)(_ticks / TicksPerDay);
            long time = _ticks % TicksPerDay;
            if (_ticks < 0) {
                sb.Append("-");
                day = -day;
                time = -time;
            }
            if (day != 0) {
                sb.Append(day);
                sb.Append(".");
            }
            sb.Append(IntToString((int)(time / TicksPerHour % 24), 2));
            sb.Append(":");
            sb.Append(IntToString((int)(time / TicksPerMinute % 60), 2));
            sb.Append(":");
            sb.Append(IntToString((int)(time / TicksPerSecond % 60), 2));
            int t = (int)(time % TicksPerSecond);
            if (t != 0) {
                sb.Append(".");
                sb.Append(IntToString(t, 7));
            }
            return sb.ToString();
        }
       	
    	/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorSUB1"]/*' />
    	public static TimeSpan operator -(TimeSpan t) {
    		if (t._ticks==TimeSpan.MinValue._ticks)
    			throw new OverflowException(Environment.GetResourceString("Overflow_NegateTwosCompNum"));
            return new TimeSpan(-t._ticks);
        }

        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorSUB2"]/*' />
        public static TimeSpan operator -(TimeSpan t1, TimeSpan t2) {
    		return t1.Subtract(t2);
    	}

        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorADD1"]/*' />
    	public static TimeSpan operator +(TimeSpan t) {
            return t;
        }
    
        /// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorADD2"]/*' />
        public static TimeSpan operator +(TimeSpan t1, TimeSpan t2) {
    		return t1.Add(t2);
        }
    
		/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorEQ"]/*' />
		public static bool operator ==(TimeSpan t1, TimeSpan t2) {
            return t1._ticks == t2._ticks;
        }

		/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorNE"]/*' />
		public static bool operator !=(TimeSpan t1, TimeSpan t2) {
            return t1._ticks != t2._ticks;
        }

		/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorLT"]/*' />
		public static bool operator <(TimeSpan t1, TimeSpan t2) {
            return t1._ticks < t2._ticks;
        }

		/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorLE"]/*' />
		public static bool operator <=(TimeSpan t1, TimeSpan t2) {
            return t1._ticks <= t2._ticks;
        }

		/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorGT"]/*' />
		public static bool operator >(TimeSpan t1, TimeSpan t2) {
            return t1._ticks > t2._ticks;
        }

		/// <include file='doc\TimeSpan.uex' path='docs/doc[@for="TimeSpan.operatorGE"]/*' />
		public static bool operator >=(TimeSpan t1, TimeSpan t2) {
            return t1._ticks >= t2._ticks;
        }
    
		[Serializable()]
        private class StringParser
        {
            private String str;
            private char ch;
            private int pos;
            private int len;
    
            internal static void Error() {
                throw new FormatException(Environment.GetResourceString("Format_InvalidString"));
            }
    
            internal static void OverflowError() {
                throw new OverflowException(Environment.GetResourceString("Overflow_TimeSpanTooLong"));
            }
    
    		internal void NextChar() {
                if (pos < len) pos++;
                ch = pos < len? str[pos]: (char) 0;
            }
    
            internal char NextNonDigit() {
                int i = pos;
                while (i < len) {
                    char ch = str[i];
                    if (ch < '0' || ch > '9') return ch;
                    i++;
                }
                return (char) 0;
            }
    
            internal long Parse(String s, bool allowWhiteSpace) {
                if (s == null) throw new ArgumentNullException("s");
                str = s;
                len = s.Length;
                pos = -1;
                NextChar();
    			if (allowWhiteSpace)
    				SkipBlanks();
                bool negative = false;
                if (ch == '-') {
                    negative = true;
                    NextChar();
                }
                long time;
                if (NextNonDigit() == ':') {
                    time = ParseTime();
                }
                else {
                    time = ParseInt((int)(0x7FFFFFFFFFFFFFFFL / TicksPerDay)) * TicksPerDay;
                    if (ch == '.') {
                        NextChar();
                        time += ParseTime();
                    }
                }
                if (negative) {
                    time = -time;
    				// Allow -0 as well
                    if (time > 0) OverflowError();
                }
                else {
                    if (time < 0) OverflowError();
                }
    			if (allowWhiteSpace)
    	            SkipBlanks();
                if (pos < len) Error();
                return time;
            }
    
            internal int ParseInt(int max) {
                int i = 0;
                int p = pos;
                while (ch >= '0' && ch <= '9') {
                    if ((i & 0xF0000000) != 0) OverflowError();
                    i = i * 10 + ch - '0';
                    if (i < 0) OverflowError();
                    NextChar();
                }
                if (p == pos) Error();
    			if (i > max) OverflowError();
                return i;
            }
    
            internal long ParseTime() {
                long time = ParseInt(23) * TicksPerHour;
                if (ch != ':') Error();
                NextChar();
                time += ParseInt(59) * TicksPerMinute;
                if (ch == ':') {
                    NextChar();
                    time += ParseInt(59) * TicksPerSecond;
                    if (ch == '.') {
                        NextChar();
                        int f = (int)TicksPerSecond;
                        while (f > 1 && ch >= '0' && ch <= '9') {
                            f /= 10;
                            time += (ch - '0') * f;
                            NextChar();
                        }
                    }
                }
                return time;
            }
    
            internal void SkipBlanks() {
                while (ch == ' ' || ch == '\t') NextChar();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threadattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** File: ThreadsAttributes.cool
**
** Author: 
**
** Purpose: For Threads-related custom attributes.
**
** Date: July, 2000
**
=============================================================================*/


namespace System {

    /// <include file='doc\ThreadAttributes.uex' path='docs/doc[@for="STAThreadAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Method)]  
    public sealed class STAThreadAttribute : Attribute
    {
        /// <include file='doc\ThreadAttributes.uex' path='docs/doc[@for="STAThreadAttribute.STAThreadAttribute"]/*' />
        public STAThreadAttribute()
        {
        }
    }

    /// <include file='doc\ThreadAttributes.uex' path='docs/doc[@for="MTAThreadAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Method)]  
    public sealed class MTAThreadAttribute : Attribute
    {
        /// <include file='doc\ThreadAttributes.uex' path='docs/doc[@for="MTAThreadAttribute.MTAThreadAttribute"]/*' />
        public MTAThreadAttribute()
        {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\threadstaticattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:        ThreadStaticAttribute.cool
**
** Author(s):   Tarun Anand    (TarunA)
**
** Purpose:     Custom attribute to indicate that the field should be treated 
**              as a static relative to a thread.
**          
**
** Date:        Jan 18, 2000
**
===========================================================*/
namespace System {
    
    using System;

    /// <include file='doc\ThreadStaticAttribute.uex' path='docs/doc[@for="ThreadStaticAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Field, Inherited = false),Serializable()] 
    public class  ThreadStaticAttribute : Attribute
    {
        /// <include file='doc\ThreadStaticAttribute.uex' path='docs/doc[@for="ThreadStaticAttribute.ThreadStaticAttribute"]/*' />
        public ThreadStaticAttribute()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\typecode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The TypeCode enum represents the type code of an object. To obtain the
// TypeCode for a given object, use the Value.GetTypeCode() method. The
// TypeCode.Empty value represents a null object reference. The TypeCode.Object
// value represents an object that doesn't implement the IValue interface. The
// TypeCode.DBNull value represents the database null, which is distinct and
// different from a null reference. The other type codes represent values that
// use the given simple type encoding.
//
// Note that when an object has a given TypeCode, there is no guarantee that
// the object is an instance of the corresponding System.XXX value class. For
// example, an object with the type code TypeCode.Int32 might actually be an
// instance of a nullable 32-bit integer type (with a value that isn't the
// database null).
//
// There are no type codes for "Missing", "Error", "IDispatch", and "IUnknown".
// These types of values are instead represented as classes. When the type code
// of an object is TypeCode.Object, a further instance-of check can be used to
// determine if the object is one of these values.
namespace System {
    /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode"]/*' />
	[Serializable]
    public enum TypeCode {
        /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Empty"]/*' />
        Empty = 0,          // Null reference
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Object"]/*' />
            Object = 1,         // Instance that isn't a value
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.DBNull"]/*' />
            DBNull = 2,         // Database null value
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Boolean"]/*' />
            Boolean = 3,        // Boolean
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Char"]/*' />
            Char = 4,           // Unicode character
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.SByte"]/*' />
            SByte = 5,          // Signed 8-bit integer
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Byte"]/*' />
            Byte = 6,           // Unsigned 8-bit integer
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Int16"]/*' />
            Int16 = 7,          // Signed 16-bit integer
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.UInt16"]/*' />
            UInt16 = 8,         // Unsigned 16-bit integer
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Int32"]/*' />
            Int32 = 9,          // Signed 32-bit integer
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.UInt32"]/*' />
            UInt32 = 10,        // Unsigned 32-bit integer
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Int64"]/*' />
            Int64 = 11,         // Signed 64-bit integer
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.UInt64"]/*' />
            UInt64 = 12,        // Unsigned 64-bit integer
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Single"]/*' />
            Single = 13,        // IEEE 32-bit float
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Double"]/*' />
            Double = 14,        // IEEE 64-bit double
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.Decimal"]/*' />
            Decimal = 15,       // Decimal
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.DateTime"]/*' />
            DateTime = 16,      // DateTime
            /// <include file='doc\TypeCode.uex' path='docs/doc[@for="TypeCode.String"]/*' />
            String = 18,        // Unicode character string
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\typeinitializationexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: TypeInitializationException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: The exception class to wrap exceptions thrown by
**          a type's class initializer (.cctor).  This is sufficiently
**          distinct from a TypeLoadException, which means we couldn't
**          find the type.
**
** Date: May 10, 2000
**
=============================================================================*/
using System;
using System.Runtime.Serialization;

namespace System {
    /// <include file='doc\TypeInitializationException.uex' path='docs/doc[@for="TypeInitializationException"]/*' />
	[Serializable()] 
    public sealed class TypeInitializationException : SystemException {
        private String _typeName;

		// This exception is not creatable without specifying the
		//	inner exception.
    	private TypeInitializationException()
	        : base(Environment.GetResourceString("TypeInitialization_Default")) {
    		SetErrorCode(__HResults.COR_E_TYPEINITIALIZATION);
    	}

		// This is called from within the runtime.  I believe this is necessary
        // for Interop only, though it's not particularly useful.
        private TypeInitializationException(String message) : base(message) {
    		SetErrorCode(__HResults.COR_E_TYPEINITIALIZATION);
        }
    	
        /// <include file='doc\TypeInitializationException.uex' path='docs/doc[@for="TypeInitializationException.TypeInitializationException"]/*' />
        public TypeInitializationException(String fullTypeName, Exception innerException) : base(String.Format(Environment.GetResourceString("TypeInitialization_Type"), fullTypeName), innerException) {
            _typeName = fullTypeName;
    		SetErrorCode(__HResults.COR_E_TYPEINITIALIZATION);
        }

        internal TypeInitializationException(SerializationInfo info, StreamingContext context) : base(info, context) {
            _typeName = info.GetString("TypeName");
        }

        /// <include file='doc\TypeInitializationException.uex' path='docs/doc[@for="TypeInitializationException.TypeName"]/*' />
        public String TypeName
        {
            get {
                if (_typeName == null) {
                    return String.Empty;
                }
                return _typeName;
            }
        }

        /// <include file='doc\TypeInitializationException.uex' path='docs/doc[@for="TypeInitializationException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
            info.AddValue("TypeName",TypeName,typeof(String));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtimetype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// __RuntimeType is the basic Type object representing classes as found in the
//      system.  This type is never creatable by users, only by the system itself.  
//      The internal structure is known about by the runtime. __RuntimeXXX classes 
//      are created only once per object in the system and support == comparisions.
//
// Author: darylo
// Date: March 98
//
namespace System {

    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Reflection.Cache;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;    
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using StackCrawlMark = System.Threading.StackCrawlMark;
    using Thread = System.Threading.Thread;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;
    using System.Security.Permissions;

    [Serializable()]
    internal sealed class RuntimeType : Type, ISerializable, ICloneable
    {
        // This integer points to an internal data structure
        //  within the runtime.  Don't modify its value.
        // (maps to ReflectClassBaseObject in unmanaged world)
        private int _pData = 0;
    
        // This enum must stay in sync with the DispatchWrapperType enum defined 
        // in MLInfo.h
        [Flags]
        private enum DispatchWrapperType : int
        {
            Unknown         = 0x00000001,
            Dispatch        = 0x00000002,
            Record          = 0x00000004,
            Error           = 0x00000008,
            Currency        = 0x00000010,
            SafeArray       = 0x00010000
        }

        // Prevent from begin created
        internal RuntimeType() {throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Constructor));}
        
        internal const int LookupMask                 = 0x000000FF;
        internal const int BinderAccessMask           = 0x0000FF00;
        internal const int BinderNonCreateInstance    = 0x00003D00;
        internal const int BinderGetSetProperty       = 0x00003000;
        internal const int BinderSetInvokeProperty    = 0x00002100;
        internal const int BinderGetSetField          = 0x00000C00;
        internal const int BinderSetInvokeField       = 0x00000900;
        internal const int BinderNonFieldGetSet       = 0x00FFF300;
        internal const BindingFlags ClassicBindingMask  = BindingFlags.InvokeMethod | BindingFlags.GetProperty |
                                                          BindingFlags.SetProperty | BindingFlags.PutDispProperty | BindingFlags.PutRefDispProperty;

        internal const String DISPIDName = "[DISPID";

        public override MemberTypes MemberType {
                get {
                    return (!IsNestedTypeImpl()) ?
                        MemberTypes.TypeInfo :
                        MemberTypes.NestedType;
                }
        }
       
        ////////////////////////////////////////////////////////////////////////////////
        // This is a static method that returns a Class based upon the name of the class
        // (this name needs to be fully qualified with the package name and is
        // case-sensitive).   If the module containing the class is not loaded, we will
        // access the meta data directly, without loading the class.  If an instance of
        // the class is created using a constructor this will cause the module to be
        // loaded.
        // skip = number of frames to skip when verifying access to the requested type.
        //
        ////
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Type GetTypeImpl(String typeName, bool throwOnError, 
                                                bool ignoreCase, ref StackCrawlMark stackMark,
                                                ref bool isAssemblyLoading);
        
        // This routine will check that a class can be cast to another class
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool CanCastTo(RuntimeType From, RuntimeType To);
    
        ////////////////////////////////////////////////////////////////////////////////
        // This will return a class based upon the progID.  This is provided for 
        // COM classic support.  Program ID's are not used in COM+ because they 
        // have been superceded by namespace.  (This routine is called this instead 
        // of getClass() because of the name conflict with the first method above.)
        //
        //   param progID:     the progID of the class to retrieve
        //   param server:     the server from which to load the type.
        //   returns:          the class object associated to the progID
        ////
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Type GetTypeFromProgIDImpl(String progID, String server, bool throwOnError);
    
        ////////////////////////////////////////////////////////////////////////////////
        // This will return a class based upon the CLSID.  This is provided for 
        // COM classic support.  
        //
        //   param CLSID:      the CLSID of the class to retrieve
        //   param server:     the server from which to load the type.
        //   returns:          the class object associated to the CLSID
        ////
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Type GetTypeFromCLSIDImpl(Guid clsid, String server, bool throwOnError);

        // Property representing the GUID associated with a class.
        public override Guid GUID {
            get {return InternalGetGUID();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Guid InternalGetGUID();
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int InternalIsContextful();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int InternalHasProxyAttribute();
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InvalidateCachedNestedType();              
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int InternalIsMarshalByRef();
        
        protected override bool IsContextfulImpl() {return InternalIsContextful() != 0;}

        protected override bool IsMarshalByRefImpl() {return InternalIsMarshalByRef() != 0;}

        internal override bool HasProxyAttributeImpl() {return InternalHasProxyAttribute() != 0;}
        
        // Description of the Binding Process.
        // We must invoke a method that is accessable and for which the provided
        // parameters have the most specific match.  A method may be called if
        // 1. The number of parameters in the method declaration equals the number of 
        //  arguments provided to the invocation
        // 2. The type of each argument can be converted by the binder to the
        //  type of the type of the parameter.
        //  
        // The binder will find all of the matching methods.  These method are found based
        // upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
        // of methods is filtered by the name, number of arguments and a set of search modifiers
        // defined in the Binder.
        // 
        // After the method is selected, it will be invoked.  Accessability is checked
        // at that point.  The search may be control which set of methods are searched based
        // upon the accessibility attribute associated with the method.
        // 
        // The BindToMethod method is responsible for selecting the method to be invoked.
        // For the default binder, the most specific method will be selected.
        // 
        // This will invoke a specific member...
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override Object InvokeMember(String name,
                                            BindingFlags invokeAttr,
                                            Binder binder,
                                            Object target,
                                            Object[] args,
                                            ParameterModifier[] modifiers,
                                            CultureInfo culture,
                                            String[] namedParameters)
        {
            // Did we specify an access type?
            //Console.WriteLine("InvokeAttr:" + (int) invokeAttr);
            if ((invokeAttr & (BindingFlags) BinderAccessMask) == 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_NoAccessSpec"),"invokeAttr");
            // Did we specify an CreateInstance and another access type?
            if ((invokeAttr & BindingFlags.CreateInstance) != 0 && 
                (invokeAttr & (BindingFlags) BinderNonCreateInstance) != 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_CreatInstAccess"),"invokeAttr");
            // If they didn't specify a lookup, then we will provide the default lookup.
            if ((invokeAttr & (BindingFlags) LookupMask) == 0) {
                invokeAttr |= BindingFlags.Instance | BindingFlags.Public;
                if ((invokeAttr & BindingFlags.CreateInstance) == 0) 
                    invokeAttr |= BindingFlags.Static;
            }
            // if the number of names is bigger than the number of args we have a problem
            if (namedParameters != null && ((args == null && namedParameters.Length != 0) || (args != null && namedParameters.Length > args.Length)))
                throw new ArgumentException(Environment.GetResourceString("Arg_NamedParamTooBig"),"namedParameters");


            // If the target is a COM object then invoke it using IDispatch.
            if (target != null && target.GetType().IsCOMObject)
            {
                // Validate the arguments.
                if ((invokeAttr & ClassicBindingMask) == 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_COMAccess"),"invokeAttr");
                if ((invokeAttr & BindingFlags.GetProperty) != 0 && (invokeAttr & ClassicBindingMask & ~(BindingFlags.GetProperty | BindingFlags.InvokeMethod)) != 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_PropSetGet"),"invokeAttr");
                if ((invokeAttr & BindingFlags.InvokeMethod) != 0 && (invokeAttr & ClassicBindingMask & ~(BindingFlags.GetProperty | BindingFlags.InvokeMethod)) != 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_PropSetInvoke"),"invokeAttr");
                if ((invokeAttr & BindingFlags.SetProperty) != 0 && (invokeAttr & ClassicBindingMask & ~BindingFlags.SetProperty) != 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_COMPropSetPut"),"invokeAttr");
                if ((invokeAttr & BindingFlags.PutDispProperty) != 0 && (invokeAttr & ClassicBindingMask & ~BindingFlags.PutDispProperty) != 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_COMPropSetPut"),"invokeAttr");
                if ((invokeAttr & BindingFlags.PutRefDispProperty) != 0 && (invokeAttr & ClassicBindingMask & ~BindingFlags.PutRefDispProperty) != 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_COMPropSetPut"),"invokeAttr");

                if(!RemotingServices.IsTransparentProxy(target))
                {
                    // The name cannot be null for calls on COM objects.
                    if (name == null)
                        throw new ArgumentNullException("name");

                    // If the user specified a null culture then pick up the current culture from the thread.
                    if (culture == null)
                        culture = Thread.CurrentThread.CurrentCulture;

                    // Call into the runtime to invoke on the COM object.
                    if (modifiers != null)
                        return InvokeDispMethod(name,invokeAttr,target,args,modifiers[0]._byRef,culture.LCID,namedParameters);       
                    else
                        return InvokeDispMethod(name,invokeAttr,target,args,null,culture.LCID,namedParameters);
                    }
                else
                {
                    // For transparent proxies over COM object we invoke using a method 
                    // defined on MarshalByRefObject so that the method gets executed 
                    // remotely.

                    return ((MarshalByRefObject)target).InvokeMember(name, 
                                                                     invokeAttr, 
                                                                     binder, 
                                                                     args, 
                                                                     modifiers, 
                                                                     culture, 
                                                                     namedParameters);
                }
            }
                
            if (namedParameters != null)
                for (int i=0;i<namedParameters.Length;i++)
                    if (namedParameters[i] == null)
                        throw new ArgumentException(Environment.GetResourceString("Arg_NamedParamNull"),"namedParameters");
            
            // The number of arguments to the method.  We will only match
            //  arguments that match directly.
            int argCnt = (args != null) ? args.Length : 0;
            
            // Without a binder we need to do use the default binder...
            if (binder == null)
                binder = DefaultBinder;

            bool bDefaultBinder = (binder == DefaultBinder);
            
            if ((invokeAttr & BindingFlags.CreateInstance) != 0) 
                return Activator.CreateInstance(this,invokeAttr,binder,args,culture);
                        
            // When calling on a managed component, we consider both PutDispProperty and 
            // PutRefDispProperty to be equivalent to SetProperty.
            if ((invokeAttr & (BindingFlags.PutDispProperty | BindingFlags.PutRefDispProperty)) != 0)
                invokeAttr |= BindingFlags.SetProperty;

            // For fields, methods and properties the name must be specified.
            if (name == null)
                throw new ArgumentNullException("name");
                
            MethodInfo[] props=null;
            MethodInfo[] meths=null;
            
            // We will narrow down the search to a field first...
            FieldInfo selFld=null;
                
            // if we are looking for the default member, find it...
            if (name.Length == 0 || name.Equals("[DISPID=0]")) {
                name = GetDefaultMemberName();
                if (name == null) {
                    // in InvokeMember we always pretend there is a default member if none is provided and we make it ToString
                    name = "ToString";
                }
            }
            
            // Make sure they are not trying to invoke a DISPID
            //@TODO: Do we really care?  This should fail.
            //if (name.Length >= DISPIDName.Length && String.CompareOrdinal(DISPIDName,0,name,0,DISPIDName.Length) == 0)
            //    throw new ArgumentException(Environment.GetResourceString("Arg_Dispid"),"name");
        
                
            // Fields
            if ((invokeAttr & BindingFlags.GetField) != 0 ||
                (invokeAttr & BindingFlags.SetField) != 0) {
                FieldInfo[] flds=null;
                // validate the set/get stuff
                if (((invokeAttr & (BindingFlags) BinderGetSetField) ^ (BindingFlags) BinderGetSetField) == 0) 
                    throw new ArgumentException(Environment.GetResourceString("Arg_FldSetGet"),"invokeAttr");
                if (((invokeAttr & (BindingFlags) BinderSetInvokeField) ^ (BindingFlags)BinderSetInvokeField) == 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_FldSetInvoke"),"invokeAttr");

                bool fieldGet = ((invokeAttr & BindingFlags.GetField) != 0);
                if (fieldGet) {
                    if ((invokeAttr & BindingFlags.SetProperty) != 0)
                        throw new ArgumentException(Environment.GetResourceString("Arg_FldGetPropSet"),"invokeAttr");
                }
                else {
                    if ((invokeAttr & BindingFlags.GetProperty) != 0)
                        throw new ArgumentException(Environment.GetResourceString("Arg_FldSetPropGet"),"invokeAttr");
                }

                        
                flds = GetMemberField(name,invokeAttr, false);

                // We are only doing a field/set get
                if (flds != null) {
                    if (flds.Length != 1) {
                        Object o;
                        if (fieldGet)
                            o = Empty.Value;
                        else {
                            if (args == null) 
                                throw new ArgumentNullException("args");
                            o = args[0];
                        }
                        selFld = binder.BindToField(invokeAttr,flds,o,culture);
                    }
                    else {
                        selFld = flds[0];
                    }
                }
                        
                        
                // If we are only set/get field we leave here with errors...
                if ((invokeAttr & (BindingFlags) BinderNonFieldGetSet) == 0) {
                    if (flds == null)
                        throw new MissingFieldException(FullName, name);
                    if (flds.Length == 1)
                        selFld = flds[0];
                    else
                        if (selFld == null)
                            throw new MissingFieldException(FullName, name);
                }
                
                // If we can continue we leave if we found a field.  Fields
                //  now have the highest priority.
                if (selFld != null) {
                    //Console.WriteLine(selFld.FieldType.Name);
                    //Console.WriteLine("argCnt:" + argCnt);
            
                    // For arrays we are going to see if they are trying to access the array
                    if (selFld.FieldType.IsArray || selFld.FieldType == typeof(System.Array)) {
                        int idxCnt;
                        if ((invokeAttr & BindingFlags.GetField) != 0) {
                            idxCnt = argCnt;                                                        
                        }
                        else {
                            idxCnt = argCnt - 1;
                        }
                        if (idxCnt > 0) {
                            // Verify that all of the index values are ints
                            int[] idx = new int[idxCnt];
                            for (int i=0;i<idxCnt;i++) {
                                try 
                                {
                                    idx[i] = ((IConvertible)args[i]).ToInt32(null);
                                }
                                catch (InvalidCastException)
                                {
                                    throw new ArgumentException(Environment.GetResourceString("Arg_IndexMustBeInt"));
                                }
                            }
                            
                            // Set or get the value...
                            Array a = (Array) selFld.GetValue(target);
                            
                            // Set or get the value in the array
                            if ((invokeAttr & BindingFlags.GetField) != 0) {
                                return a.GetValue(idx);
                            }
                            else {
                                a.SetValue(args[idxCnt],idx);
                                return null;
                            }                                               
                        }
                    }
                    else {
                        // This is not an array so we validate that the arg count is correct.
                        if ((invokeAttr & BindingFlags.GetField) != 0 && argCnt != 0)
                            throw new ArgumentException(Environment.GetResourceString("Arg_FldGetArgErr"),"invokeAttr");
                        if ((invokeAttr & BindingFlags.SetField) != 0 && argCnt != 1)
                            throw new ArgumentException(Environment.GetResourceString("Arg_FldSetArgErr"),"invokeAttr");
                    }
                        
                            // Set the field...
                    if (fieldGet)
                        return selFld.GetValue(target);
                    else {
                        selFld.SetValue(target,args[0],invokeAttr,binder,culture);
                        return null;
                    }
                }
            }
                    
         
            // Properties
            MethodBase invokeMethod;
            bool useCache = false;

            // Note that when we add something to the cache, we are careful to ensure
            // that the actual args matches the parameters of the method.  Otherwise,
            // some default argument processing has occurred.  We don't want anyone
            // else with the same (insufficient) number of actual arguments to get a
            // cache hit because then they would bypass the default argument processing
            // and the invocation would fail.

            if (bDefaultBinder && namedParameters == null && argCnt < 6)
                useCache = true;

            if (useCache)
            {
                invokeMethod = nGetMethodFromCache (name, invokeAttr, argCnt, args);
                if (invokeMethod != null)
                    return ((MethodInfo) invokeMethod).Invoke(target,invokeAttr,binder,args,culture);
            }
            
            if ((invokeAttr & BindingFlags.GetProperty) != 0 ||
                (invokeAttr & BindingFlags.SetProperty) != 0) {
                if (((invokeAttr & (BindingFlags) BinderGetSetProperty) ^ (BindingFlags) BinderGetSetProperty) == 0) 
                    throw new ArgumentException(Environment.GetResourceString("Arg_PropSetGet"),"invokeAttr");
                if (((invokeAttr & (BindingFlags) BinderSetInvokeProperty) ^ (BindingFlags) BinderSetInvokeProperty) == 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_PropSetInvoke"),"invokeAttr");
                bool propGet = ((invokeAttr & BindingFlags.GetProperty) != 0);
                if (propGet) {
                    if ((invokeAttr & BindingFlags.SetField) != 0)
                        throw new ArgumentException(Environment.GetResourceString("Arg_FldSetPropGet"),"invokeAttr");
                }
                else {
                    if ((invokeAttr & BindingFlags.GetField) != 0)
                        throw new ArgumentException(Environment.GetResourceString("Arg_FldGetPropSet"),"invokeAttr");
                }
                        
                props = GetMemberProperties(name,invokeAttr,argCnt, false);
                        
            }
        
            if ((invokeAttr & BindingFlags.InvokeMethod) != 0) {
                meths = GetMemberMethod(name, invokeAttr, CallingConventions.Any, null, argCnt, false);
            }
            
            if (meths == null && props == null)
                throw new MissingMethodException(FullName, name);

            // if either props or meths is null then we simply work with
            //  the other one.  (One must be non-null because of the if statement above)
            if (props == null) {
                if (argCnt == 0 && meths[0].GetParameters().Length == 0 && (invokeAttr & BindingFlags.OptionalParamBinding) == 0)
                {
                    if (useCache && argCnt == meths[0].GetParameters().Length)
                        nAddMethodToCache(name,invokeAttr,argCnt,args,meths[0]);
                    return meths[0].Invoke(target,invokeAttr,binder,args,culture);
                }
                else {
                    if (args == null)
                        args = new Object[0];
                    Object state = null;
                    invokeMethod = binder.BindToMethod(invokeAttr,meths,ref args,modifiers,culture,namedParameters, out state);
                    if (invokeMethod == null)
                        throw new MissingMethodException(FullName, name);
                    if (useCache && argCnt == invokeMethod.GetParameters().Length)
                        nAddMethodToCache(name,invokeAttr,argCnt,args,invokeMethod);
                    Object result = ((MethodInfo) invokeMethod).Invoke(target,invokeAttr,binder,args,culture);
                    if (state != null)
                        binder.ReorderArgumentArray(ref args, state);
                    return result;
                }
            }
            
            if (meths == null) {
                if (argCnt == 0 && props[0].GetParameters().Length == 0 && (invokeAttr & BindingFlags.OptionalParamBinding) == 0)
                {
                    if (useCache && argCnt == props[0].GetParameters().Length)
                        nAddMethodToCache(name,invokeAttr,argCnt,args,props[0]);
                    return props[0].Invoke(target,invokeAttr,binder,args,culture);
                }
                else {
                    if (args == null)
                        args = new Object[0];
                    Object state = null;
                    invokeMethod = binder.BindToMethod(invokeAttr,props,ref args,modifiers,culture,namedParameters, out state);
                    if (invokeMethod == null)
                        throw new MissingMethodException(FullName, name);
                    if (useCache && argCnt == invokeMethod.GetParameters().Length)
                        nAddMethodToCache(name,invokeAttr,argCnt,args,invokeMethod);
                    Object result = ((MethodInfo) invokeMethod).Invoke(target,invokeAttr,binder,args,culture);
                    if (state != null)
                        binder.ReorderArgumentArray(ref args, state);
                    return result;
                }
            }
            
            // Now we have both methods and properties...
            MethodInfo[] p = new MethodInfo[props.Length + meths.Length];
            Array.Copy(meths,p,meths.Length);
            Array.Copy(props,0,p,meths.Length,props.Length);
                
            if (args == null)
                args = new Object[0];
            Object binderState = null;
            invokeMethod = binder.BindToMethod(invokeAttr,p,ref args,modifiers,culture,namedParameters, out binderState);
            if (invokeMethod == null)
                throw new MissingMethodException(FullName, name);
            if (useCache && argCnt == invokeMethod.GetParameters().Length)
                nAddMethodToCache(name,invokeAttr,argCnt,args,invokeMethod);
            Object res = ((MethodInfo) invokeMethod).Invoke(target,invokeAttr,binder,args,culture);
            if (binderState != null) {
                binder.ReorderArgumentArray(ref args, binderState);
            }
            return res;
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern MethodBase nGetMethodFromCache(String name,BindingFlags invokeAttr, int argCnt, Object[] args);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void nAddMethodToCache(String name,BindingFlags invokeAttr, int argCnt, Object[] args, MethodBase invokeMethod);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern MethodInfo[] GetMemberMethod(String name,
                                                     BindingFlags invokeAttr,
                                                     CallingConventions callConv,
                                                     Type[] argTypes,
                                                     int argCnt, 
                                                     bool verifyAccess);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern MethodInfo[] GetMemberProperties(String name,BindingFlags invokeAttr,int argCnt, bool verifyAccess);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern FieldInfo[] GetMemberField(String name,BindingFlags invokeAttr, bool verifyAccess);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern ConstructorInfo[] GetMemberCons(BindingFlags invokeAttr,
                                                        CallingConventions callConv,
                                                        Type[] types, 
                                                        int argCnt, 
                                                        bool verifyAccess, 
                                                        /*bool isDefaultBinder, */
                                                        out bool isDelegate);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern PropertyInfo[] GetMatchingProperties(String name,BindingFlags invokeAttr,int argCnt,
                                                             RuntimeType returnType, bool verifyAccess);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Object InvokeDispMethod(String name,BindingFlags invokeAttr,Object target,Object[] args,
                bool[] byrefModifiers,int culture,String[] namedParameters);
        
        // CreateInstance will create a new instance of an object by finding the
        // constructor that matchs the arguments and then invoking that constructor.
        //public override Object CreateInstance(BindingFlags bindingAttr,Binder binder,Variant[] args,CultureInfo culture,
        //    Object[] activationAttributes)
        //{
        //    return CreateInstanceImpl(bindingAttr,binder,args,culture,activationAttributes);
        //}

        //  @TODO The ativationAttributes on this methods are NYI TarunA
        internal Object CreateInstanceImpl(BindingFlags bindingAttr,
                                           Binder binder,
                                           Object[] args,
                                           CultureInfo culture,
            Object[] activationAttributes)
        {
            Object server = null;
            try
            {
                try
                {
                    // Store the activation attributes in thread local storage.
                    // These attributes are later picked up by specialized 
                    // activation services like remote activation services to
                    // influence the activation.
                    // @see RemotingServices.Activate
                    if(null != activationAttributes)
                    {
                        ActivationServices.PushActivationAttributes(this,activationAttributes);
                    }
                    
                    if (args == null) 
                        args = new Object[0];
                    int argCnt = args.Length;
                    // Without a binder we need to do use the default binder...
                    if (binder == null)
                        binder = DefaultBinder;

                    // deal with the __COMObject case first. It is very special because from a reflection point of view it has no ctors
                    // so a call to GetMemberCons would fail
                    if (argCnt == 0 && (bindingAttr & BindingFlags.Public) != 0 && (bindingAttr & BindingFlags.Instance) != 0
                        && (IsGenericCOMObjectImpl() || IsSubclassOf(RuntimeType.valueType))) {
                        server = CreateInstanceImpl(((bindingAttr & BindingFlags.NonPublic) != 0) ? false : true);
                    }
                    else {
                        bool isDelegate;
                        MethodBase[] cons = GetMemberCons(bindingAttr,
                            CallingConventions.Any,
                            null,
                            argCnt,
                            false, 
                            /*binder == DefaultBinder, */
                            out isDelegate);
                        if (cons == null){
                            // Null out activation attributes before throwing exception
                            if(null != activationAttributes)
                            {
                                ActivationServices.PopActivationAttributes(this);
                                activationAttributes = null;
                            }
                            throw new MissingMethodException(String.Format(Environment.GetResourceString("MissingConstructor_Name"), FullName));
                        }
                        
                        // It would be strange to have an argCnt of 0 and more than
                        //  one constructor.
                        if (argCnt == 0 && cons.Length == 1 && (bindingAttr & BindingFlags.OptionalParamBinding) == 0) 
                            server = Activator.CreateInstance(this, true);
                        else
                        {
                            //      MethodBase invokeMethod = binder.BindToMethod(cons,args,null,null,culture);
                            MethodBase invokeMethod;
                            Object state;
                            invokeMethod = binder.BindToMethod(bindingAttr,cons,ref args,null,culture,null, out state);
                            if (invokeMethod == null){
                                // Null out activation attributes before throwing exception
                                if(null != activationAttributes)
                                {
                                    ActivationServices.PopActivationAttributes(this);
                                    activationAttributes = null;
                                }
                                throw new MissingMethodException(String.Format(Environment.GetResourceString("MissingConstructor_Name"), FullName));
                            }
                            
                            // If we're creating a delegate, we're about to call a
                            // constructor taking an integer to represent a target
                            // method. Since this is very difficult (and expensive)
                            // to verify, we're just going to demand UnmanagedCode
                            // permission before allowing this. Partially trusted
                            // clients can instead use Delegate.CreateDelegate,
                            // which allows specification of the target method via
                            // name or MethodInfo.
                            if (isDelegate)
                                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

                            server = ((ConstructorInfo) invokeMethod).Invoke(bindingAttr,binder,args,culture);
                            if (state != null)
                                binder.ReorderArgumentArray(ref args, state);
                        }                    
                    }
                }                    
                finally
                {
                    // Reset the TLS to null
                    if(null != activationAttributes)
                    {
                        ActivationServices.PopActivationAttributes(this);
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }
            
            return server;                                
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Object CreateInstanceImpl(bool publicOnly);

        // Module Property associated with a class.
        public override Module Module {
            get {return InternalGetModule();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Module InternalGetModule();
        
        // Assembly Property associated with a class.
        public override Assembly Assembly {
            get {return InternalGetAssembly();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Assembly InternalGetAssembly();
            
        // A class handle is a unique integer value associated with
        // each class.  The handle is unique during the process life time.
        public override RuntimeTypeHandle TypeHandle {
            get {return InternalGetClassHandle();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern RuntimeTypeHandle InternalGetClassHandle();
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static RuntimeTypeHandle InternalGetTypeHandleFromObject(Object o);
       
        // Given a class handle, this will return the class for that handle.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Type GetTypeFromHandleImpl(RuntimeTypeHandle handle);
    
        // Return the name of the class.  The name does not contain the namespace.
        public override String Name {
            get {return InternalGetName();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetName();
    
        public override int GetHashCode() {
            // Rather than return the sync block index for this type, why not return our
            // internal int?  A pointer to a ReflectClass should be good enough.
            return _pData;
        }
        
        // Return the name of the class.  The name does not contain the namespace.
        public override String ToString(){
            return InternalGetProperlyQualifiedName();
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetProperlyQualifiedName();
                           
        // Return the fully qualified name.  The name does contain the namespace.
        public override String FullName {
            get {
                String s;
                if ((s = TypeNameCache.GetCache().GetTypeName(_pData))!=null) {
                    BCLDebug.Assert(s.Equals(InternalGetFullName()), "[RuntimeType.FullName]Type name caching is screwed up.");
                    return s;
                }
                s = InternalGetFullName();
                TypeNameCache.GetCache().AddValue(_pData, s);
                return s;
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetFullName();
    
        // Return the name of the type including the assembly from which it came.
        // This name can be persisted and used to reload the type at a later
        // time.
        public override String AssemblyQualifiedName {
            get { return InternalGetAssemblyQualifiedName(); }
        }
            
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetAssemblyQualifiedName();
    

        // Return the name space. 
        public override String Namespace {
            get {return InternalGetNameSpace();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetNameSpace();
    
        // Return the class that declared this Field.
        public override Type DeclaringType {
            get {
                return (!IsNestedTypeImpl()) ? null : InternalGetNestedDeclaringType();
            }
        }

        // Return the class that was used to obtain this field.
        // @todo: fix this to return the actual reflected type when and if we 
        //        make the flatten hierarchy binding flags work on nested types.
        public override Type ReflectedType {
            get {
                return (!IsNestedTypeImpl()) ? null : InternalGetNestedDeclaringType();
            }
        }

        // Returns the base class for a class.  If this is an interface or has
        // no base class null is returned.  Object is the only Type that does not 
        // have a base class.  
        public override Type BaseType {
            get {return InternalGetSuperclass();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type InternalGetSuperclass();
        
        
        public override int GetArrayRank() {
            if (IsArray)
                return InternalGetArrayRank();
            else
                throw new ArgumentException(Environment.GetResourceString("Argument_HasToBeArrayClass") );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int InternalGetArrayRank();

        // Return the requested Constructor.
        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr,
                                                              Binder binder,
                                                              CallingConventions callConvention, 
                                                              Type[] types,
                                                              ParameterModifier[] modifiers)
        {
            return GetConstructorImplInternal(bindingAttr, binder, callConvention, types, modifiers, true);
        }   
    
        internal ConstructorInfo GetConstructorImplInternal(BindingFlags bindingAttr,
                                                            Binder binder,
                                                            CallingConventions callConvention, 
                                                            Type[] types,
                                                            ParameterModifier[] modifiers, 
                                                            bool verifyAccess)
        {
    
            // Must provide some types (Type[0] for nothing)
            if (types == null)
                throw new ArgumentNullException("types");
            
            if (binder == null)
                binder = DefaultBinder;
            
            int argCnt = types.Length;
            bool isDelegate;
            MethodBase[] cons = GetMemberCons(bindingAttr, 
                                              callConvention, 
                                              types,
                                              argCnt, 
                                              verifyAccess, 
                                              /*binder == DefaultBinder, */
                                              out isDelegate);
            if (cons == null)
                return null;
            
            if (argCnt == 0 && cons.Length == 1) { 
                ParameterInfo[] pars = cons[0].GetParameters();
                if (pars == null || pars.Length == 0) {
                    return (ConstructorInfo) cons[0];
                }
            }
            if ((bindingAttr & BindingFlags.ExactBinding) != 0)
                return (ConstructorInfo) System.DefaultBinder.ExactBinding(cons,types,modifiers);
            
            return (ConstructorInfo) binder.SelectMethod(bindingAttr,cons,types,modifiers);
        }   

        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
        {
            return GetConstructorsInternal(bindingAttr, true);
        }

        // GetConstructors()
        // This routine will return an array of all constructors supported by the class
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern ConstructorInfo[] GetConstructorsInternal(BindingFlags bindingAttr, bool verifyAccess);
        
        
        protected override MethodInfo GetMethodImpl(String name,
                                                    BindingFlags bindingAttr,
                                                    Binder binder,
                                                    CallingConventions callConvention, 
                                                    Type[] types,
                                                    ParameterModifier[] modifiers)
        {       
            return GetMethodImplInternal(name, bindingAttr, binder, callConvention, types, modifiers, true);                  
        }

        internal MethodInfo GetMethodImplInternal(String name,
                                                  BindingFlags bindingAttr,
                                                  Binder binder,
                                                  CallingConventions callConvention, 
                                                  Type[] types,
                                                  ParameterModifier[] modifiers, 
                                                  bool verifyAccess)
        {       
            if (binder == null)
                binder = DefaultBinder;
            
            // If the types array is null that means we don't care about the arguments to the method, we will simply
            //  return the one that matchs or throw an argument error...
            int argCnt = (types != null) ? types.Length : -1;
            MethodBase[] meths = GetMemberMethod(name, 
                                                 bindingAttr, 
                                                 callConvention, 
                                                 types, 
                                                 argCnt,
                                                 verifyAccess);
            // at this point a proper filter with respect to BindingAttributes and calling convention already happened
            if (meths == null)
                return null;
            if (argCnt <= 0) {
                // either no args or a method with 0 args was specified
                if (meths.Length == 1)
                    return (MethodInfo) meths[0];
                else if (argCnt < 0) {
                    // There are multiple methods with the same name. Check to see if they are all
                    // new slots with the same name and sig.
                    foreach(MethodBase m in meths) {
                        if (!System.DefaultBinder.CompareMethodSigAndName(m, meths[0]))
                            // One of the methods is not a new slot. So the match is ambigous.
                            throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
                        }

                    // All the methods are new slots with the same name and sig so return the most derived one.
                    return (MethodInfo) System.DefaultBinder.FindMostDerivedNewSlotMeth(meths, meths.Length);
                }
            }   
            
            return (MethodInfo) binder.SelectMethod(bindingAttr,meths,types,modifiers);                  
        }

                // This method 
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
                public extern override MethodInfo[] GetMethods(BindingFlags bindingAttr);
   
        // GetField
        // Get Field will return a specific field based upon name
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override FieldInfo GetField(String name, BindingFlags bindingAttr);
    
        // GetFields
        // Get fields will return a full array of fields implemented by a class
        public override FieldInfo[] GetFields(BindingFlags bindingAttr) {
            return InternalGetFields(bindingAttr, true);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern FieldInfo[] InternalGetFields(BindingFlags bindingAttr, bool requiresAccessCheck);

        // GetInterface
        // This method will return an interface (as a class) based upon
        //  the passed in name.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override Type GetInterface(String name, bool ignoreCase);
        
        // GetInterfaces
        // This method will return all of the interfaces implemented by a 
        //  class
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override Type[] GetInterfaces();
            
        // GetEvent
        // This method will return a event by name if it is found.
        //  null is returned if the event is not found
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override EventInfo GetEvent(String name,BindingFlags bindingAttr);
        
        // GetEvents
        // This method will return an array of EventInfo.  If there are not Events
        //  an empty array will be returned.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override EventInfo[] GetEvents(BindingFlags bindingAttr);
        
        // Return a property based upon the passed criteria.  The nameof the
        // parameter must be provided.  
        protected override PropertyInfo GetPropertyImpl(String name,BindingFlags bindingAttr,Binder binder,
                Type returnType, Type[] types, ParameterModifier[] modifiers)
        {
            if (binder == null)
                binder = DefaultBinder;
            
            int argCnt = (types != null) ? types.Length : -1;
            PropertyInfo[] props = GetMatchingProperties(name,bindingAttr,argCnt,null,true);
            if (props == null)
                return null;
            
            if (argCnt <= 0) {
                // no arguments
                if (props.Length == 1) {
                    if (returnType != null && returnType != props[0].PropertyType)
                        return null;
                return props[0];
                }
                else {
                    if (returnType == null)
                        // if we are here we have no args or property type to select over and we have more than one property with that name
                    throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
            }
            }
            
            if ((bindingAttr & BindingFlags.ExactBinding) != 0)
                return System.DefaultBinder.ExactPropertyBinding(props,returnType,types,modifiers);
            return binder.SelectProperty(bindingAttr,props,returnType,types,modifiers);
        }
        
        //
        
        // GetProperties
        // This method will return an array of all of the properties defined
        //  for a Type.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override PropertyInfo[] GetProperties(BindingFlags bindingAttr);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override Type[] GetNestedTypes(BindingFlags bindingAttr);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override Type GetNestedType(String name, BindingFlags bindingAttr);
   
        // GetMember
        // This method will return all of the members which match the specified string
        // passed into the method
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override MemberInfo[] GetMember(String name,MemberTypes type,BindingFlags bindingAttr);
        
        // GetMembers
        // This will return a Member array of all of the members of a class
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override MemberInfo[] GetMembers(BindingFlags bindingAttr);
            
    
        /////////////////////////// ICustomAttributeProvider Interface
       // Return an array of all of the custom attributes
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCustomAttributes(this, null, inherit);
        }

        // Return a custom attribute identified by Type
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            attributeType = attributeType.UnderlyingSystemType;
            if (!(attributeType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            return CustomAttribute.GetCustomAttributes(this, attributeType, inherit);
        }

       // Returns true if one or more instance of attributeType is defined on this member. 
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            return CustomAttribute.IsDefined(this, attributeType, inherit);
        }
        
    ////////////////////////////////////////////////////////////////////////////////
    //
    // Attributes
    //
    //   The attributes are all treated as read-only properties on a class.  Most of
    //  these boolean properties have flag values defined in this class and act like
    //  a bit mask of attributes.  There are also a set of boolean properties that
    //  relate to the classes relationship to other classes and to the state of the
    //  class inside the runtime.
    //
    ////////////////////////////////////////////////////////////////////////////////
        
        // Internal routine to get the attributes.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        protected extern override TypeAttributes GetAttributeFlagsImpl();
        
        // Internal routine to determine if this class represents an Array
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        protected extern override bool IsArrayImpl();

        // Protected routine to determine if this class is a ByRef
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        protected extern override bool IsByRefImpl();
        
        // Internal routine to determine if this class represents a primitive type
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        protected extern override bool IsPrimitiveImpl();
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        protected extern override bool IsPointerImpl();

        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        protected extern override bool IsCOMObjectImpl();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool IsGenericCOMObjectImpl();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool IsNestedTypeImpl();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Type InternalGetNestedDeclaringType();            
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern public override Type GetElementType();

        protected override bool HasElementTypeImpl()
        {
            return (IsArray | IsPointer | IsByRef);
        }
       
        // IsLoaded
        // This indicates if the class has been loaded into the runtime.
        // @TODO: This is always true at the moment because everything is loaded.
        //  Reflection of Module will change this at some point
        internal override bool IsLoaded()
        {
            return true;
        }
        
        // Return the underlying Type that represents the IReflect Object.  For expando object,
        // this is the (Object) IReflectInstance.GetType().  For Type object it is this.
        public override Type UnderlyingSystemType {
            get {return this;}
        }
    
        //
        // ISerializable Implementation
        //
        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            UnitySerializationHolder.GetUnitySerializationInfo(info, UnitySerializationHolder.RuntimeTypeUnity, 
                                                                      this.FullName, 
                                                                      Assembly.GetAssembly(this));
        }
    
        //
        // ICloneable Implementation
        // 
    
        // RuntimeType's are unique in the system, so the only thing that we should do to clone them is
        // return the current instance.
        public Object Clone() {
            return this;
        }
        
        // This method will determine if the object supports the
        // interface represented by this type.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool SupportsInterface(Object o);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetTypeDefTokenHelper();
        internal override int InternalGetTypeDefToken() 
        { 
            return InternalGetTypeDefTokenHelper();
        }

        // GetInterfaceMap
        // This method will return an interface mapping for the interface
        //  requested.  It will throw an argument exception if the Type doesn't
        //  implement the interface.
        public override InterfaceMapping GetInterfaceMap(Type interfaceType)
        {
            if (interfaceType == null)
                throw new ArgumentNullException("interfaceType");
            if (!interfaceType.IsInterface)
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeInterface"),"interfaceType");
            if (!(interfaceType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "interfaceType");
            return InternalGetInterfaceMap((RuntimeType)interfaceType);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern InterfaceMapping InternalGetInterfaceMap(RuntimeType interfaceType);

        private Object ForwardCallToInvokeMember(String memberName, BindingFlags flags, Object target, int[] aWrapperTypes, ref MessageData msgData)
        {
            ParameterModifier[] aParamMod = null;
            Object ret = null;

            // Allocate a new message
            Message reqMsg = new Message();
            reqMsg.InitFields(msgData);

            // Retrieve the required information from the message object.
            MethodInfo meth = (MethodInfo)reqMsg.GetMethodBase();
            Object[] aArgs = reqMsg.Args;
            int cArgs = aArgs.Length;

            // Retrieve information from the method we are invoking on.
            ParameterInfo[] aParams = meth.GetParameters();

            // If we have arguments, then set the byref flags to true for byref arguments. 
            // We also wrap the arguments that require wrapping.
            if (cArgs > 0)
            {
                ParameterModifier paramMod = new ParameterModifier(cArgs);
                for (int i = 0; i < cArgs; i++)
                {
                    if (aParams[i].ParameterType.IsByRef)
                        paramMod[i] = true;
                }

                aParamMod = new ParameterModifier[1];
                aParamMod[0] = paramMod;

                if (aWrapperTypes != null)
                    WrapArgsForInvokeCall(aArgs, aWrapperTypes);
            }
            
            // If the method has a void return type, then set the IgnoreReturn binding flag.
            if (meth.ReturnType == typeof(void))
                flags |= BindingFlags.IgnoreReturn;

            try
            {
                // Invoke the method using InvokeMember().
                ret = InvokeMember(memberName, flags, null, target, aArgs, aParamMod, null, null);
            }
            catch (TargetInvocationException e)
            {
                // For target invocation exceptions, we need to unwrap the inner exception and
                // re-throw it.
                throw e.InnerException;
            }

            // Convert each byref argument that is not of the proper type to
            // the parameter type using the OleAutBinder.
            for (int i = 0; i < cArgs; i++)
            {
                if (aParamMod[0][i])
                {
                    // The parameter is byref.
                    Type paramType = aParams[i].ParameterType.GetElementType();
                    if (paramType != aArgs[i].GetType())
                        aArgs[i] = ForwardCallBinder.ChangeType(aArgs[i], paramType, null);
                }
            }

            // If the return type is not of the proper type, then convert it
            // to the proper type using the OleAutBinder.
            if (ret != null)
            {
                Type retType = meth.ReturnType;
                if (retType != ret.GetType())
                    ret = ForwardCallBinder.ChangeType(ret, retType, null);
            }

            // Propagate the out parameters
            RealProxy.PropagateOutParameters(reqMsg, aArgs, ret);

            // Return the value returned by the InvokeMember call.
            return ret;
        }

        private void WrapArgsForInvokeCall(Object[] aArgs, int[] aWrapperTypes)
        {
            int cArgs = aArgs.Length;
            for (int i = 0; i < cArgs; i++)
            {
                if (aWrapperTypes[i] != 0)
                {
                    if (((DispatchWrapperType)aWrapperTypes[i] & DispatchWrapperType.SafeArray) != 0)
                    {
                        Type wrapperType = null;

                        // Determine the type of wrapper to use.
                        switch ((DispatchWrapperType)aWrapperTypes[i] & ~DispatchWrapperType.SafeArray)
                        {
                            case DispatchWrapperType.Unknown:
                                wrapperType = typeof(UnknownWrapper);
                                break;
                            case DispatchWrapperType.Dispatch:
                                wrapperType = typeof(DispatchWrapper);
                                break;
                            case DispatchWrapperType.Error:   
                                wrapperType = typeof(ErrorWrapper);
                                break;
                            case DispatchWrapperType.Currency:
                                wrapperType = typeof(CurrencyWrapper);
                                break;
                            default:
                                BCLDebug.Assert(false, "[RuntimeType.WrapArgsForInvokeCall]Invalid safe array wrapper type specified.");
                                break;
                        }

                        // Allocate the new array of wrappers.
                        Array oldArray = (Array)aArgs[i];
                        int numElems = oldArray.Length;
                        Object[] newArray = (Object[])Array.CreateInstance(wrapperType, numElems);

                        // Retrieve the ConstructorInfo for the wrapper type.
                        ConstructorInfo wrapperCons = wrapperType.GetConstructor(new Type[] {typeof(Object)});
                    
                        // Wrap each of the elements of the array.
                        for (int currElem = 0; currElem < numElems; currElem++)
                            newArray[currElem] = wrapperCons.Invoke(new Object[] {oldArray.GetValue(currElem)});                                                                         

                        // Update the argument.
                        aArgs[i] = newArray;
                    }
                    else
                    {                           
                        // Determine the wrapper to use and then wrap the argument.
                        switch ((DispatchWrapperType)aWrapperTypes[i])
                        {
                            case DispatchWrapperType.Unknown:
                                aArgs[i] = new UnknownWrapper(aArgs[i]);
                                break;
                            case DispatchWrapperType.Dispatch:
                                aArgs[i] = new DispatchWrapper(aArgs[i]);
                                break;
                            case DispatchWrapperType.Error:   
                                aArgs[i] = new ErrorWrapper(aArgs[i]);
                                break;
                            case DispatchWrapperType.Currency:
                                aArgs[i] = new CurrencyWrapper(aArgs[i]);
                                break;
                            default:
                                BCLDebug.Assert(false, "[RuntimeType.WrapArgsForInvokeCall]Invalid wrapper type specified.");
                                break;
                        }
                    }
                }
            }
        }

        private OleAutBinder ForwardCallBinder 
        {
            get 
            {
                // Synchronization is not required.
                if (s_ForwardCallBinder == null)
                    s_ForwardCallBinder = new OleAutBinder();
                return s_ForwardCallBinder;
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public override extern bool IsSubclassOf(Type c);

        internal override TypeCode GetTypeCodeInternal()
        {
            RuntimeType type = this;
            int corType = SignatureHelper.GetCorElementTypeFromClass(type);
            switch (corType) {
            case SignatureHelper.ELEMENT_TYPE_BOOLEAN:
                return TypeCode.Boolean;
            case SignatureHelper.ELEMENT_TYPE_CHAR:  
                return TypeCode.Char;
            case SignatureHelper.ELEMENT_TYPE_I1:  
                return TypeCode.SByte;
            case SignatureHelper.ELEMENT_TYPE_U1:
                return TypeCode.Byte;
            case SignatureHelper.ELEMENT_TYPE_I2:  
                return TypeCode.Int16;
            case SignatureHelper.ELEMENT_TYPE_U2:  
                return TypeCode.UInt16;
            case SignatureHelper.ELEMENT_TYPE_I4:  
                return TypeCode.Int32;
            case SignatureHelper.ELEMENT_TYPE_U4:  
                return TypeCode.UInt32;
            case SignatureHelper.ELEMENT_TYPE_I8: 
                return TypeCode.Int64;
            case SignatureHelper.ELEMENT_TYPE_U8:  
                return TypeCode.UInt64;
            case SignatureHelper.ELEMENT_TYPE_R4:  
                return TypeCode.Single;
            case SignatureHelper.ELEMENT_TYPE_R8: 
                return TypeCode.Double;
            case SignatureHelper.ELEMENT_TYPE_STRING:  
                return TypeCode.String;
            case SignatureHelper.ELEMENT_TYPE_VALUETYPE:
                if (type == Convert.ConvertTypes[(int)TypeCode.Decimal])
                    return TypeCode.Decimal;
                if (type == Convert.ConvertTypes[(int)TypeCode.DateTime])
                    return TypeCode.DateTime;
                if (type.IsEnum)
                    return Type.GetTypeCode(Enum.GetUnderlyingType(type));
                break;
            }
            if (type == Convert.ConvertTypes[(int)TypeCode.DBNull])
                return TypeCode.DBNull;
            if (type == Convert.ConvertTypes[(int)TypeCode.String])
                return TypeCode.String;

            return TypeCode.Object;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static Type GetTypeInternal(String typeName, 
                                                    bool throwOnError, 
                                                    bool ignoreCase, 
                                                    bool publicOnly);

        private static readonly Type valueType = typeof(System.ValueType);

        private static OleAutBinder s_ForwardCallBinder;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\typeloadexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: TypeLoadException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: The exception class for type loading failures.
**
** Date: August 3, 1999
**
=============================================================================*/
namespace System {
    
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;   
    using System.Runtime.CompilerServices;

    /// <include file='doc\TypeLoadException.uex' path='docs/doc[@for="TypeLoadException"]/*' />
    [Serializable()]
    public class TypeLoadException : SystemException, ISerializable {

        /// <include file='doc\TypeLoadException.uex' path='docs/doc[@for="TypeLoadException.TypeLoadException"]/*' />
        public TypeLoadException() 
            : base(Environment.GetResourceString("Arg_TypeLoadException")) {
            SetErrorCode(__HResults.COR_E_TYPELOAD);
        }
    
        /// <include file='doc\TypeLoadException.uex' path='docs/doc[@for="TypeLoadException.TypeLoadException1"]/*' />
        public TypeLoadException(String message) 
            : base(message) {
            SetErrorCode(__HResults.COR_E_TYPELOAD);
        }
    
        /// <include file='doc\TypeLoadException.uex' path='docs/doc[@for="TypeLoadException.TypeLoadException2"]/*' />
        public TypeLoadException(String message, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.COR_E_TYPELOAD);
        }
    
        /// <include file='doc\TypeLoadException.uex' path='docs/doc[@for="TypeLoadException.Message"]/*' />
        public override String Message
        {
            get {
                SetMessageField();
                return _message;
            }
        }
    
        private void SetMessageField()
        {
            if (_message == null) {
                if ((ClassName == null) &&
                    (ResourceId == 0))
                    _message = Environment.GetResourceString("Arg_TypeLoadException");

                else
                    _message = FormatTypeLoadExceptionMessage(ClassName, AssemblyName, MessageArg, ResourceId);
            }

        }

        /// <include file='doc\TypeLoadException.uex' path='docs/doc[@for="TypeLoadException.TypeName"]/*' />
        public String TypeName
        {
            get {
                if (ClassName == null)
                    return String.Empty;

                return ClassName;
            }
        }
    
        // This is called from inside the EE. 
        private TypeLoadException(String className,
                                  String assemblyName,
                                  String messageArg,
                                  int    resourceId)
        : base(null)
        {
            SetErrorCode(__HResults.COR_E_TYPELOAD);
            ClassName  = className;
            AssemblyName = assemblyName;
            MessageArg = messageArg;
            ResourceId = resourceId;

            // Set the _message field eagerly, debuggers look  this field to 
            // display error info. They don't call the Message property.
            SetMessageField();   
        }

        /// <include file='doc\TypeLoadException.uex' path='docs/doc[@for="TypeLoadException.TypeLoadException3"]/*' />
        protected TypeLoadException(SerializationInfo info, StreamingContext context) : base(info, context) {
            if (info == null)
                throw new ArgumentNullException("info");

            ClassName =  info.GetString("TypeLoadClassName");
            AssemblyName = info.GetString("TypeLoadAssemblyName");
            MessageArg = info.GetString("TypeLoadMessageArg");
            ResourceId = info.GetInt32("TypeLoadResourceID");
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern String FormatTypeLoadExceptionMessage(String className,
                                                                    String assemblyName,
                                                                    String messageArg,
                                                                    int resourceId);
    
        //We can rely on the serialization mechanism on Exception to handle most of our needs, but
        //we need to add a few fields of our own.
        /// <include file='doc\TypeLoadException.uex' path='docs/doc[@for="TypeLoadException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info == null)
                throw new ArgumentNullException("info");

            base.GetObjectData(info, context);
            info.AddValue("TypeLoadClassName", ClassName, typeof(String));
            info.AddValue("TypeLoadAssemblyName", AssemblyName, typeof(String));
            info.AddValue("TypeLoadMessageArg", MessageArg, typeof(String));
            info.AddValue("TypeLoadResourceID", ResourceId);
        }
    
        // If ClassName != null, GetMessage will construct on the fly using it
        // and ResourceId (mscorrc.dll). This allows customization of the
        // class name format depending on the language environment.
        private String  ClassName;
        private String  AssemblyName;
        private String  MessageArg;
        internal int    ResourceId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\timezone.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: TimeZone
**
** Author: Jay Roxe, Yung-Shin Lin
**
** Purpose: 
** This class is used to represent a TimeZone.  It
** has methods for converting a DateTime to UTC from local time
** and to local time from UTC and methods for getting the 
** standard name and daylight name of the time zone.  
**
** The only TimeZone that we support in version 1 is the 
** CurrentTimeZone as determined by the system timezone.
**
** Date: March 20, 2001
**
============================================================*/
namespace System {
    using System;
    using System.Text;
    using System.Threading;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone"]/*' />
    [Serializable]
    public abstract class TimeZone {
        private static TimeZone currentTimeZone = null;

        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.TimeZone"]/*' />
        protected TimeZone() {
        }
    
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.CurrentTimeZone"]/*' />
        public static TimeZone CurrentTimeZone {
            get {
                //Grabbing the cached value is required at the top of this function so that
                //we don't incur a race condition with the ResetTimeZone method below.
                TimeZone tz = currentTimeZone;
                if (tz == null) {
                    lock(typeof(TimeZone)) {
                        if (currentTimeZone == null) {
                            currentTimeZone = new CurrentSystemTimeZone();
                        }
                        tz = currentTimeZone;
                    }
                }
                return (tz);
            }
        }

        //This method is called by CultureInfo.ClearCachedData in response to control panel
        //change events.  It must be synchronized because otherwise there is a race condition 
        //with the CurrentTimeZone property above.
        internal static void ResetTimeZone() {
            if (currentTimeZone!=null) {
                lock(typeof(TimeZone)) {
                    currentTimeZone = null;
                }
            }
        }
    
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.StandardName"]/*' />
        public abstract String StandardName {
            get;
        }
    
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.DaylightName"]/*' />
        public abstract String DaylightName {
            get;
        }

        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.GetUtcOffset"]/*' />
        public abstract TimeSpan GetUtcOffset(DateTime time);

        //
        // Converts the specified datatime to the Universal time base on the current timezone 
        //
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.ToUniversalTime"]/*' />
        public virtual DateTime ToUniversalTime(DateTime time) {
            return (time - GetUtcOffset(time));
        }

        //
        // Convert the specified datetime value from UTC to the local time based on the time zone.
        //
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.ToLocalTime"]/*' />
        public virtual DateTime ToLocalTime(DateTime time) {
            return (time + GetUtcOffset(time));
        }
       
        // Return an array of DaylightTime which reflects the daylight saving periods in a particular year.
        // We currently only support having one DaylightSavingTime per year.
        // If daylight saving time is not used in this timezone, null will be returned.
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.GetDaylightChanges"]/*' />
        public abstract DaylightTime GetDaylightChanges(int year);

        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.IsDaylightSavingTime"]/*' />    
        public virtual bool IsDaylightSavingTime(DateTime time) {
            return (IsDaylightSavingTime(time, GetDaylightChanges(time.Year)));
        }
  
        // Check if the specified time is in a daylight saving time.  Allows the user to
        // specify the array of Daylight Saving Times.
        /// <include file='doc\TimeZone.uex' path='docs/doc[@for="TimeZone.IsDaylightSavingTime1"]/*' />
        public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes) {
            return CalculateUtcOffset(time, daylightTimes)!=TimeSpan.Zero;
        }
      
        //
        // NOTENOTE: Implementation detail
        // In the transition from standard time to daylight saving time, 
        // if we convert local time to Universal time, we can have the
        // following (take PST as an example):
        //      Local               Universal       UTC Offset
        //      -----               ---------       ----------
        //      01:00AM             09:00           -8:00
        //      02:00 (=> 03:00)    10:00           -8:00   [This time doesn't actually exist, but it can be created from DateTime]
        //      03:00               10:00           -7:00
        //      04:00               11:00           -7:00
        //      05:00               12:00           -7:00
        //      
        //      So from 02:00 - 02:59:59, we should return the standard offset, instead of the daylight saving offset.
        //
        // In the transition from daylight saving time to standard time,
        // if we convert local time to Universal time, we can have the
        // following (take PST as an example):
        //      Local               Universal       UTC Offset
        //      -----               ---------       ----------
        //      01:00AM             08:00           -7:00
        //      02:00 (=> 01:00)    09:00           -8:00   
        //      02:00               10:00           -8:00
        //      03:00               11:00           -8:00
        //      04:00               12:00           -8:00
        //      
        //      So in this case, the 02:00 does exist after the first 2:00 rolls back to 01:00. We don't need to special case this.
        //      But note that there are two 01:00 in the local time.
        
        //
        // And imagine if the daylight saving offset is negative (although this does not exist in real life)
        // In the transition from standard time to daylight saving time, 
        // if we convert local time to Universal time, we can have the
        // following (take PST as an example, but the daylight saving offset is -01:00):
        //      Local               Universal       UTC Offset
        //      -----               ---------       ----------
        //      01:00AM             09:00           -8:00
        //      02:00 (=> 01:00)    10:00           -9:00
        //      02:00               11:00           -9:00
        //      03:00               12:00           -9:00
        //      04:00               13:00           -9:00
        //      05:00               14:00           -9:00
        //      
        //      So in this case, the 02:00 does exist after the first 2:00 rolls back to 01:00. We don't need to special case this.
        //
        // In the transition from daylight saving time to standard time,
        // if we convert local time to Universal time, we can have the
        // following (take PST as an example, bug daylight saving offset is -01:00):
        //
        //      Local               Universal       UTC Offset
        //      -----               ---------       ----------
        //      01:00AM             10:00           -9:00
        //      02:00 (=> 03:00)    11:00           -9:00
        //      03:00               11:00           -8:00
        //      04:00               12:00           -8:00
        //      05:00               13:00           -8:00
        //      06:00               14:00           -8:00
        //      
        //      So from 02:00 - 02:59:59, we should return the daylight saving offset, instead of the standard offset.
        //
        internal static TimeSpan CalculateUtcOffset(DateTime time, DaylightTime daylightTimes) {
            if (daylightTimes==null) {
                return TimeSpan.Zero;
            }

            DateTime startTime;
            DateTime endTime;

            if (daylightTimes.Delta.Ticks > 0) {
                startTime = daylightTimes.Start + daylightTimes.Delta;
                endTime = daylightTimes.End;
            } else {
                startTime = daylightTimes.Start;
                endTime = daylightTimes.End - daylightTimes.Delta;
            }

            if (startTime > endTime) {
                // In southern hemisphere, the daylight saving time starts later in the year, and ends in the beginning of next year.
                // Note, the summer in the southern hemisphere begins late in the year.
                if (time < endTime || time >= startTime) { 
                    return daylightTimes.Delta;
                }
            }
            else if (time>=startTime && time<endTime) {
                // In northern hemisphere, the daylight saving time starts in the middle of the year.
                return daylightTimes.Delta;
            }

            return TimeSpan.Zero;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\typedreference.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {

    // TypedReference is basically only ever seen on the call stack, and in param arrays.
    //	These are blob that must be delt with by the compiler.
    using System;
	using System.Reflection;
	using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
	using FieldInfo = System.Reflection.FieldInfo;
    using System.Security.Permissions;

    /// <include file='doc\TypedReference.uex' path='docs/doc[@for="TypedReference"]/*' />
	[CLSCompliant(false)] // TODO put this back in , System.Runtime.CompilerServices.NotInGCHeap] 
    public struct TypedReference
    {
    	private int Value;
    	private int Type;
    
		/// <include file='doc\TypedReference.uex' path='docs/doc[@for="TypedReference.MakeTypedReference"]/*' />
		[CLSCompliant(false)]	
        [ReflectionPermission(SecurityAction.LinkDemand, MemberAccess=true)]
		public static TypedReference MakeTypedReference(Object target,FieldInfo[] flds) {
			if (target == null)
				throw new ArgumentNullException("target");
			if (flds == null)
				throw new ArgumentNullException("flds");
			if (flds.Length == 0)
				throw new ArgumentException(Environment.GetResourceString("Arg_ArrayZeroError"));
            else {
                FieldInfo[] fields = new FieldInfo[flds.Length];
                for(int i = 0; i < flds.Length; i++) {
                    fields[i] = flds[i];
                    if (!(fields[i] is RuntimeFieldInfo)) 
                        throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeFieldInfo"));
                    else if (fields[i].IsInitOnly || fields[i].IsStatic) 
                        throw new ArgumentException(Environment.GetResourceString("Argument_TypedReferenceInvalidField"));
                }
                return InternalMakeTypedReferences(target,fields);
            }
		}
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		private static extern TypedReference InternalMakeTypedReferences(Object target,FieldInfo[] flds);

    	/// <include file='doc\TypedReference.uex' path='docs/doc[@for="TypedReference.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
			if (Type == 0)
				return 0;
			else
    			return __reftype(this).GetHashCode();
    	}
    
    	/// <include file='doc\TypedReference.uex' path='docs/doc[@for="TypedReference.Equals"]/*' />
    	public override bool Equals(Object o)
    	{
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_NYI"));
    	}

		/// <include file='doc\TypedReference.uex' path='docs/doc[@for="TypedReference.ToObject"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
		public extern static Object ToObject(TypedReference value);

		/// <include file='doc\TypedReference.uex' path='docs/doc[@for="TypedReference.GetTargetType"]/*' />
		public static Type GetTargetType (TypedReference value)
		{
			return __reftype(value);
		}

		/// <include file='doc\TypedReference.uex' path='docs/doc[@for="TypedReference.TargetTypeToken"]/*' />
		public static RuntimeTypeHandle TargetTypeToken (TypedReference value)
		{
			return __reftype(value).TypeHandle;
		}

		//	This may cause the type to be changed.
		/// <include file='doc\TypedReference.uex' path='docs/doc[@for="TypedReference.SetTypedReference"]/*' />
        [CLSCompliant(false)]	
		public static void SetTypedReference (TypedReference target, Object value)
    	{
			if (value == null)
				throw new ArgumentNullException("value");

			Type thisType = GetTargetType(target);
			Type thatType = value.GetType();
			if (!thisType.IsAssignableFrom(thatType))
				value = Convert.ChangeType(value, thisType, CultureInfo.InvariantCulture);

			// Directly make the assignment. Types are compatible				
    		InternalObjectToTypedReference(target,value,thisType.TypeHandle);
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern static void InternalObjectToTypedReference(TypedReference byrefValue,Object value,RuntimeTypeHandle typeHandle);
   	
	
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\typeunloadedexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: TypeUnloadedException
**
** Author: Jennifer Hamilton (jenh)
**
** Purpose: Exception class for attempt to access an unloaded class
**
** Date: March 17, 1998
**
=============================================================================*/

namespace System {
    
	using System.Runtime.Serialization;

    /// <include file='doc\TypeUnloadedException.uex' path='docs/doc[@for="TypeUnloadedException"]/*' />
    [Serializable()] public class TypeUnloadedException : SystemException {
        /// <include file='doc\TypeUnloadedException.uex' path='docs/doc[@for="TypeUnloadedException.TypeUnloadedException"]/*' />
        public TypeUnloadedException() 
	        : base(Environment.GetResourceString("Arg_TypeUnloadedException")) {
    		SetErrorCode(__HResults.COR_E_TYPEUNLOADED);
        }
    
        /// <include file='doc\TypeUnloadedException.uex' path='docs/doc[@for="TypeUnloadedException.TypeUnloadedException1"]/*' />
        public TypeUnloadedException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_TYPEUNLOADED);
        }
    
        /// <include file='doc\TypeUnloadedException.uex' path='docs/doc[@for="TypeUnloadedException.TypeUnloadedException2"]/*' />
        public TypeUnloadedException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_TYPEUNLOADED);
        }

        //
        // This constructor is required for serialization;
        //
        /// <include file='doc\TypeUnloadedException.uex' path='docs/doc[@for="TypeUnloadedException.TypeUnloadedException3"]/*' />
        protected TypeUnloadedException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\type.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Type is the root of all reflection and the Object that represents
//  a type inside the system.  Type is an abstract base class that allows multiple
//      implementations.  The system will always provide the subclass __RuntimeType.
//      In Reflection all of the __RuntimeXXX classes are created only once per object
//      in the system and support == comparisions.
//
// Author: darylo
// Date: March 98
//
namespace System {

    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Reflection.Cache;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Security.Permissions;
    using CultureInfo = System.Globalization.CultureInfo;
    using SignatureHelper = System.Reflection.Emit.SignatureHelper;
    using StackCrawlMark = System.Threading.StackCrawlMark;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;

    /// <include file='doc\Type.uex' path='docs/doc[@for="Type"]/*' />
    [Serializable()]
    [ClassInterface(ClassInterfaceType.AutoDual)]
    public abstract class Type : MemberInfo, IReflect
    {

        // Member filters
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.FilterAttribute"]/*' />
        public static readonly MemberFilter FilterAttribute;  
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.FilterName"]/*' />
        public static readonly MemberFilter FilterName;
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.FilterNameIgnoreCase"]/*' />
        public static readonly MemberFilter FilterNameIgnoreCase;
    
        // mark a parameter as a missing parameter.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Missing"]/*' />
        public static readonly Object Missing = System.Reflection.Missing.Value;

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Delimiter"]/*' />
        public static readonly char Delimiter = '.'; 
    
        // EmptyTypes is used to indicate that we are looking for someting without any parameters.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.EmptyTypes"]/*' />
        public readonly static Type[] EmptyTypes        = new Type[0];

        // The Default binder.  We create a single one and expose that.
        private static Binder defaultBinder;
        
        // Because the current compiler doesn't support static delegates
        //  the _Filters object is an object that we create to contain all of
        //  the filters.
        //private static final Type _filterClass = new RuntimeType();
        static Type() {
            __Filters _filterClass = new __Filters();
            FilterAttribute = new MemberFilter(_filterClass.FilterAttribute);
            FilterName = new MemberFilter(_filterClass.FilterName);
            FilterNameIgnoreCase = new MemberFilter(_filterClass.FilterIgnoreCase);
        }

        // Prevent from begin created, and allow subclass
        //      to create.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Type"]/*' />
        protected Type() {}
        
        
        // MemberInfo Methods....
        // The Member type Field.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.MemberType"]/*' />
        public override MemberTypes MemberType {
                get {return System.Reflection.MemberTypes.TypeInfo;}
        }
                                                  
        // Return the class that declared this Field.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.DeclaringType"]/*' />
        public override Type DeclaringType {
                get {return this;}
        }
        
        // Return the class that was used to obtain this field.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.ReflectedType"]/*' />
        public override Type ReflectedType {
                get {return this;}
        }
                                                          
        ////////////////////////////////////////////////////////////////////////////////
        // This is a static method that returns a Class based upon the name of the class
        // (this name needs to be fully qualified with the package name and is
        // case-sensitive by default).
        ////  
        
        /************** PLEASE NOTE - THE GETTYPE METHODS NEED TO BE INTERNAL CALLS
        // EE USES THE ECALL FRAME TO FIND WHO THE CALLER IS. THIS"LL BREAK IF A METHOD BODY IS ADDED */
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetType"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Type GetType(String typeName, bool throwOnError, bool ignoreCase);

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetType1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Type GetType(String typeName, bool throwOnError);

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetType2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Type GetType(String typeName);
        /****************************/
    
        ////////////////////////////////////////////////////////////////////////////////
        // This will return a class based upon the progID.  This is provided for 
        // COM classic support.  Program ID's are not used in COM+ because they 
        // have been superceded by namespace.  (This routine is called this instead 
        // of getClass() because of the name conflict with the first method above.)
        //
        //   param progID:     the progID of the class to retrieve
        //   returns:          the class object associated to the progID
        ////
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromProgID"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Type GetTypeFromProgID(String progID)
        {
                return RuntimeType.GetTypeFromProgIDImpl(progID, null, false);
        }

        ////////////////////////////////////////////////////////////////////////////////
        // This will return a class based upon the progID.  This is provided for 
        // COM classic support.  Program ID's are not used in COM+ because they 
        // have been superceded by namespace.  (This routine is called this instead 
        // of getClass() because of the name conflict with the first method above.)
        //
        //   param progID:     the progID of the class to retrieve
        //   returns:          the class object associated to the progID
        ////
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromProgID1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Type GetTypeFromProgID(String progID, bool throwOnError)
        {
                return RuntimeType.GetTypeFromProgIDImpl(progID, null, throwOnError);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromProgID2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Type GetTypeFromProgID(String progID, String server)
        {
                return RuntimeType.GetTypeFromProgIDImpl(progID, server, false);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromProgID3"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static Type GetTypeFromProgID(String progID, String server, bool throwOnError)
        {
                return RuntimeType.GetTypeFromProgIDImpl(progID, server, throwOnError);
        }

        ////////////////////////////////////////////////////////////////////////////////
        // This will return a class based upon the CLSID.  This is provided for 
        // COM classic support.  
        //
        //   param CLSID:      the CLSID of the class to retrieve
        //   returns:          the class object associated to the CLSID
        ////
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromCLSID"]/*' />
        [ReflectionPermissionAttribute(SecurityAction.LinkDemand, Flags=ReflectionPermissionFlag.TypeInformation)]
        public static Type GetTypeFromCLSID(Guid clsid)
        {
                return RuntimeType.GetTypeFromCLSIDImpl(clsid, null, false);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromCLSID1"]/*' />
        [ReflectionPermissionAttribute(SecurityAction.LinkDemand, Flags=ReflectionPermissionFlag.TypeInformation)]
        public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError)
        {
                return RuntimeType.GetTypeFromCLSIDImpl(clsid, null, throwOnError);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromCLSID2"]/*' />
        [ReflectionPermissionAttribute(SecurityAction.LinkDemand, Flags=ReflectionPermissionFlag.TypeInformation)]
        public static Type GetTypeFromCLSID(Guid clsid, String server)
        {
                return RuntimeType.GetTypeFromCLSIDImpl(clsid, server, false);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromCLSID3"]/*' />
        [ReflectionPermissionAttribute(SecurityAction.LinkDemand, Flags=ReflectionPermissionFlag.TypeInformation)]
        public static Type GetTypeFromCLSID(Guid clsid, String server, bool throwOnError)
        {
                return RuntimeType.GetTypeFromCLSIDImpl(clsid, server, throwOnError);
        }
        
        // GetTypeCode
        // This method will return a TypeCode for the passed
        //  type.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeCode"]/*' />
        public static TypeCode GetTypeCode(Type type)
        {
            if (type == null)
                return TypeCode.Empty;
            return type.GetTypeCodeInternal();
        }

        internal virtual TypeCode GetTypeCodeInternal()
        {
            Type type = this;
            if (type is SymbolType)
                return TypeCode.Object;
                
            if (type is TypeBuilder)
            {
                TypeBuilder typeBuilder = (TypeBuilder) type;
                if (typeBuilder.IsEnum == false)
                    return TypeCode.Object;
                    
                // if it is an Enum, just let the underlyingSystemType do the work
            }
            
            if (type != type.UnderlyingSystemType)
                return Type.GetTypeCode(type.UnderlyingSystemType);
            
            return TypeCode.Object;
        }

        // Property representing the GUID associated with a class.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GUID"]/*' />
        public abstract Guid GUID {
            get;
        }

        // Return the Default binder used by the system.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.DefaultBinder"]/*' />
        static public Binder DefaultBinder {
            get {
                // Allocate the default binder if it hasn't been allocated yet.
                if (defaultBinder == null)
                {
                    lock(typeof(Type))
                    {
                        if (defaultBinder == null)
                            defaultBinder = new DefaultBinder();
                    }
                }
                return defaultBinder;
            }
        }
            
       // Description of the Binding Process.
       // We must invoke a method that is accessable and for which the provided
       // parameters have the most specific match.  A method may be called if
       // 1. The number of parameters in the method declaration equals the number of 
       //      arguments provided to the invocation
       // 2. The type of each argument can be converted by the binder to the
       //      type of the type of the parameter.
       //      
       // The binder will find all of the matching methods.  These method are found based
       // upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
       // of methods is filtered by the name, number of arguments and a set of search modifiers
       // defined in the Binder.
       // 
       // After the method is selected, it will be invoked.  Accessability is checked
       // at that point.  The search may be control which set of methods are searched based
       // upon the accessibility attribute associated with the method.
       // 
       // The BindToMethod method is responsible for selecting the method to be invoked.
       // For the default binder, the most specific method will be selected.
       // 
       // This will invoke a specific member...

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.InvokeMember"]/*' />
        abstract public Object InvokeMember(String name,BindingFlags invokeAttr,Binder binder,Object target,
                                    Object[] args, ParameterModifier[] modifiers,CultureInfo culture,String[] namedParameters);
    
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.InvokeMember1"]/*' />
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public Object InvokeMember(String name,BindingFlags invokeAttr,Binder binder, Object target, Object[] args, CultureInfo culture)
        {
                return InvokeMember(name,invokeAttr,binder,target,args,null,culture,null);
        }
    
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.InvokeMember2"]/*' />
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public Object InvokeMember(String name,BindingFlags invokeAttr,Binder binder, Object target, Object[] args)
        {
                return InvokeMember(name,invokeAttr,binder,target,args,null,null,null);
        }
   
 
        // Module Property associated with a class.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Module"]/*' />
        public abstract Module Module {
            get;
        }
            
        // Assembly Property associated with a class.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Assembly"]/*' />
        public abstract Assembly Assembly {
            get;
        }
            
        // A class handle is a unique integer value associated with
        // each class.  The handle is unique during the process life time.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.TypeHandle"]/*' />
        public abstract RuntimeTypeHandle TypeHandle {
            get;
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeHandle"]/*' />
        public static RuntimeTypeHandle GetTypeHandle(Object o) {
            if (o == null) 
                throw new ArgumentNullException("o");
            return o.GetType().TypeHandle;
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeFromHandle"]/*' />
        public static Type GetTypeFromHandle(RuntimeTypeHandle handle)
        {
            return RuntimeType.GetTypeFromHandleImpl(handle);
        }
    
                                               
        // Return the fully qualified name.  The name does contain the namespace.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.FullName"]/*' />
        public abstract String FullName {
            get;
        }
    
        // Return the name space of the class.  
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Namespace"]/*' />
        public abstract String Namespace {
            get;
        }
    
        // @TODO: Next integration make this method abstract
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.AssemblyQualifiedName"]/*' />
        public abstract String AssemblyQualifiedName {
            get;
        }
            
        // @TODO: Next integration make this method abstract
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetArrayRank"]/*' />
        public virtual int GetArrayRank() {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_SubclassOverride"));
        }
        
        // Returns the base class for a class.  If this is an interface or has
        // no base class null is returned.  Object is the only Type that does not 
        // have a base class.  
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.BaseType"]/*' />
        public abstract Type BaseType {
            get;
        }
            
         
        // GetConstructor
        // This method will search for the specified constructor.  For constructors,
        //  unlike everything else, the default is to not look for static methods.  The
        //  reason is that we don't typically expose the class initializer.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetConstructor"]/*' />
        public ConstructorInfo GetConstructor(BindingFlags bindingAttr,
                                              Binder binder,
                                              CallingConventions callConvention, 
                                              Type[] types,
                                              ParameterModifier[] modifiers)
        {               
           // Must provide some types (Type[0] for nothing)
            if (types == null)
                throw new ArgumentNullException("types");
            for (int i=0;i<types.Length;i++)
                if (types[i] == null)
                    throw new ArgumentNullException("types");
            return GetConstructorImpl(bindingAttr, binder, callConvention, types, modifiers);
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetConstructor1"]/*' />
        public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
        {
            if (types == null)
                throw new ArgumentNullException("types");
            for (int i=0;i<types.Length;i++)
                if (types[i] == null)
                    throw new ArgumentNullException("types");
            return GetConstructorImpl(bindingAttr, binder, CallingConventions.Any, types, modifiers);
        }
            
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetConstructor2"]/*' />
        public ConstructorInfo GetConstructor(Type[] types)
        {
                // The arguments are checked in the called version of GetConstructor.
                return GetConstructor(BindingFlags.Public | BindingFlags.Instance, null, types, null);
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetConstructorImpl"]/*' />
        abstract protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr,
                                                              Binder binder,
                                                              CallingConventions callConvention, 
                                                              Type[] types,
                                                              ParameterModifier[] modifiers);
    
        // GetConstructors()
        // This routine will return an array of all constructors supported by the class.
        //  Unlike everything else, the default is to not look for static methods.  The
        //  reason is that we don't typically expose the class initializer.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetConstructors"]/*' />
        public ConstructorInfo[] GetConstructors() {
            return GetConstructors(BindingFlags.Public | BindingFlags.Instance);
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetConstructors1"]/*' />
        abstract public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.TypeInitializer"]/*' />
        public ConstructorInfo TypeInitializer {
            get {
                return GetConstructorImpl(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic,
                                          null,
                                          CallingConventions.Any,
                                          Type.EmptyTypes,
                                          null);
            }
        }
            
        // Return a method based upon the passed criteria.  The name of the method
        // must be provided, and exception is thrown if it is not.  The bindingAttr
        // parameter indicates if non-public methods should be searched.  The types
        // array indicates the types of the parameters being looked for.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethod"]/*' />
        public MethodInfo GetMethod(String name,
                                    BindingFlags bindingAttr,
                                    Binder binder,
                                    CallingConventions callConvention,
                                    Type[] types,
                                    ParameterModifier[] modifiers)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            if (types == null)
                throw new ArgumentNullException("types");
            for (int i = 0; i < types.Length; i++)
                if (types[i] == null)
                    throw new ArgumentNullException("types");
            return GetMethodImpl(name, bindingAttr, binder, callConvention, types, modifiers);
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethod1"]/*' />
        public MethodInfo GetMethod(String name,
                                    BindingFlags bindingAttr,
                                    Binder binder,
                                    Type[] types,
                                    ParameterModifier[] modifiers)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            if (types == null)
                throw new ArgumentNullException("types");
            for (int i = 0; i < types.Length; i++)
                if (types[i] == null)
                    throw new ArgumentNullException("types");
            return GetMethodImpl(name, bindingAttr, binder, CallingConventions.Any, types, modifiers);
        }
            
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethod2"]/*' />
        public MethodInfo GetMethod(String name, Type[] types, ParameterModifier[] modifiers)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            if (types == null)
                throw new ArgumentNullException("types");
            for (int i=0;i<types.Length;i++)
                if (types[i] == null)
                    throw new ArgumentNullException("types");
            return GetMethodImpl(name, Type.DefaultLookup, null, CallingConventions.Any, types, modifiers);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethod3"]/*' />
        public MethodInfo GetMethod(String name,Type[] types)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            if (types == null)
                throw new ArgumentNullException("types");
            for (int i=0;i<types.Length;i++)
                if (types[i] == null)
                    throw new ArgumentNullException("types");
            return GetMethodImpl(name, Type.DefaultLookup, null, CallingConventions.Any, types, null);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethod4"]/*' />
        public MethodInfo GetMethod(String name, BindingFlags bindingAttr)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            return GetMethodImpl(name, bindingAttr, null, CallingConventions.Any, null, null);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethod5"]/*' />
        public MethodInfo GetMethod(String name)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            return GetMethodImpl(name, Type.DefaultLookup, null, CallingConventions.Any, null, null);
        }
                
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethodImpl"]/*' />
        abstract protected MethodInfo GetMethodImpl(String name,
                                                    BindingFlags bindingAttr,
                                                    Binder binder,
                                                    CallingConventions callConvention, 
                                                    Type[] types,
                                                    ParameterModifier[] modifiers);
    
        // GetMethods
        // This routine will return all the methods implemented by the class
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethods"]/*' />
        public MethodInfo[] GetMethods() {
            return GetMethods(Type.DefaultLookup);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMethods1"]/*' />
        abstract public MethodInfo[] GetMethods(BindingFlags bindingAttr);
    
        // GetField
        // Get Field will return a specific field based upon name
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetField"]/*' />
        abstract public FieldInfo GetField(String name, BindingFlags bindingAttr);
    
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetField1"]/*' />
        public FieldInfo GetField(String name) {
            return GetField(name, Type.DefaultLookup);
        }
    
        // GetFields
        // Get fields will return a full array of fields implemented by a class
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetFields"]/*' />
        public FieldInfo[] GetFields() {
            return GetFields(Type.DefaultLookup);
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetFields1"]/*' />
        abstract public FieldInfo[] GetFields(BindingFlags bindingAttr);
        
        // GetInterface
        // This method will return an interface (as a class) based upon
        //  the passed in name.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetInterface"]/*' />
        public Type GetInterface(String name) {
            return GetInterface(name,false);
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetInterface1"]/*' />
        abstract public Type GetInterface(String name, bool ignoreCase);
        
        // GetInterfaces
        // This method will return all of the interfaces implemented by a 
        //  class
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetInterfaces"]/*' />
        abstract public Type[] GetInterfaces();
        
        // FindInterfaces
        // This method will filter the interfaces supported the class
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.FindInterfaces"]/*' />
        public virtual Type[] FindInterfaces(TypeFilter filter,Object filterCriteria)
        {
            if (filter == null)
                throw new ArgumentNullException("filter");
            Type[] c = GetInterfaces();
            int cnt = 0;
            for (int i = 0;i<c.Length;i++) {
                if (!filter(c[i],filterCriteria))
                    c[i] = null;
                else
                    cnt++;
            }
            if (cnt == c.Length)
                return c;
            
            Type[] ret = new Type[cnt];
            cnt=0;
            for (int i=0;i<c.Length;i++) {
                if (c[i] != null)
                    ret[cnt++] = c[i];
            }
            return ret;
        }
        
        // GetEvent
        // This method will return a event by name if it is found.
        //  null is returned if the event is not found
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetEvent"]/*' />
        public EventInfo GetEvent(String name) {
            return GetEvent(name,Type.DefaultLookup);
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetEvent1"]/*' />
        abstract public EventInfo GetEvent(String name,BindingFlags bindingAttr);
        
        // GetEvents
        // This method will return an array of EventInfo.  If there are not Events
        //  an empty array will be returned.
        //@TODO: These need to be virtualized correctly
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetEvents"]/*' />
        virtual public EventInfo[] GetEvents() {
            return GetEvents(Type.DefaultLookup);
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetEvents1"]/*' />
        abstract public EventInfo[] GetEvents(BindingFlags bindingAttr);
            
        // Return a property based upon the passed criteria.  The nameof the
        // parameter must be provided.  
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperty"]/*' />
        public PropertyInfo GetProperty(String name,BindingFlags bindingAttr,Binder binder, 
                        Type returnType, Type[] types, ParameterModifier[] modifiers)
        {
                if (name == null)
                        throw new ArgumentNullException("name");
                if (types == null)
                        throw new ArgumentNullException("types");
                return GetPropertyImpl(name,bindingAttr,binder,returnType,types,modifiers);
        }
                
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperty1"]/*' />
        public PropertyInfo GetProperty(String name, Type returnType, Type[] types,ParameterModifier[] modifiers)
        {
                if (name == null)
                        throw new ArgumentNullException("name");
                if (types == null)
                        throw new ArgumentNullException("types");
                return GetPropertyImpl(name,Type.DefaultLookup,null,returnType,types,modifiers);
        }
                
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperty2"]/*' />
        public PropertyInfo GetProperty(String name, BindingFlags bindingAttr)
        {
                if (name == null)
                        throw new ArgumentNullException("name");
                return GetPropertyImpl(name,bindingAttr,null,null,null,null);
        }
                
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperty3"]/*' />
        public PropertyInfo GetProperty(String name, Type returnType, Type[] types)
        {
                if (name == null)
                        throw new ArgumentNullException("name");
                if (types == null)
                        throw new ArgumentNullException("types");
                return GetPropertyImpl(name,Type.DefaultLookup,null,returnType,types,null);
        }
                
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperty4"]/*' />
        public PropertyInfo GetProperty(String name, Type[] types)
        {
                if (name == null)
                        throw new ArgumentNullException("name");
                if (types == null)
                        throw new ArgumentNullException("types");
                return GetPropertyImpl(name,Type.DefaultLookup,null,null,types,null);
        }
                
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperty5"]/*' />
        public PropertyInfo GetProperty(String name, Type returnType)
        {
                if (name == null)
                        throw new ArgumentNullException("name");
                if (returnType == null)
                        throw new ArgumentNullException("returnType");
                return GetPropertyImpl(name,Type.DefaultLookup,null,returnType,null,null);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperty6"]/*' />
        public PropertyInfo GetProperty(String name)
        {
                if (name == null)
                        throw new ArgumentNullException("name");
                return GetPropertyImpl(name,Type.DefaultLookup,null,null,null,null);
        }
            
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetPropertyImpl"]/*' />
        abstract protected PropertyInfo GetPropertyImpl(String name, BindingFlags bindingAttr,Binder binder,
                        Type returnType, Type[] types, ParameterModifier[] modifiers);
        
        // GetProperties
        // This method will return an array of all of the properties defined
        //  for a Type.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperties"]/*' />
        abstract public PropertyInfo[] GetProperties(BindingFlags bindingAttr);
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetProperties1"]/*' />
        public PropertyInfo[] GetProperties()
        {
            return GetProperties(Type.DefaultLookup);
        }

        // GetNestedTypes()
        // This set of method will return any nested types that are found inside
        //  of the type.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetNestedTypes"]/*' />
        public Type[] GetNestedTypes()
        {
            return GetNestedTypes(Type.DefaultLookup);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetNestedTypes1"]/*' />
        abstract public Type[] GetNestedTypes(BindingFlags bindingAttr);

        // GetNestedType()
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetNestedType"]/*' />
        public Type GetNestedType(String name)
        {
            return GetNestedType(name,Type.DefaultLookup);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetNestedType1"]/*' />
        abstract public Type GetNestedType(String name, BindingFlags bindingAttr);
   
        // GetMember
        // This method will return all of the members which match the specified string
        // passed into the method
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMember"]/*' />
        public MemberInfo[] GetMember(String name) {
            return GetMember(name,Type.DefaultLookup);
        }

        //@TODO: Make this non abstract and make the following
        //  method abstract
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMember1"]/*' />
        virtual public MemberInfo[] GetMember(String name, BindingFlags bindingAttr)
        {
            return GetMember(name,MemberTypes.All,bindingAttr);
        }

        //@TODO: This needs to become Abstract
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMember2"]/*' />
        virtual public MemberInfo[] GetMember(String name, MemberTypes type, BindingFlags bindingAttr)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_SubclassOverride"));
        }
        
        // GetMembers
        // This will return a Member array of all of the members of a class
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMembers"]/*' />
        public MemberInfo[] GetMembers() {
            return GetMembers(Type.DefaultLookup);
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetMembers1"]/*' />
        abstract public MemberInfo[] GetMembers(BindingFlags bindingAttr);
        
        // GetDefaultMembers
        // This will return a MemberInfo that has been marked with the
        //      DefaultMemberAttribute
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetDefaultMembers"]/*' />
        public virtual MemberInfo[] GetDefaultMembers()
        {
            // See if we have cached the default member name
            String defaultMember = (String)this.Cache[CacheObjType.DefaultMember];

            if (defaultMember == null) {
                // Get all of the custom attributes
                Object[] attrs = GetCustomAttributes(typeof(DefaultMemberAttribute), true);
                // We assume that there is only one DefaultMemberAttribute (Allow multiple = false)
                if (attrs.Length > 1)
                    throw new ExecutionEngineException(Environment.GetResourceString("ExecutionEngine_InvalidAttribute"));
                if (attrs.Length == 0)
                    return new MemberInfo[0];
                defaultMember = ((DefaultMemberAttribute)attrs[0]).MemberName;
                this.Cache[CacheObjType.DefaultMember] = defaultMember;
            }
                
            MemberInfo[] members = GetMember(defaultMember);
            if (members == null)
                members = new MemberInfo[0];
            return members;
        }
        
        internal virtual String GetDefaultMemberName() {
                // See if we have cached the default member name
                String defaultMember = (String)this.Cache[CacheObjType.DefaultMember];

                if (defaultMember == null)
                {
                    Object[] attrs = GetCustomAttributes(typeof(DefaultMemberAttribute), true);
                    // We assume that there is only one DefaultMemberAttribute (Allow multiple = false)
                    if (attrs.Length > 1)
                            throw new ExecutionEngineException(Environment.GetResourceString("ExecutionEngine_InvalidAttribute"));
                    if (attrs.Length == 0)
                            return null;
                    defaultMember = ((DefaultMemberAttribute)attrs[0]).MemberName;
                    this.Cache[CacheObjType.DefaultMember] = defaultMember;
                }
                return defaultMember;
        }
        
        // FindMembers
        // This will return a filtered version of the member information
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.FindMembers"]/*' />
        public virtual MemberInfo[] FindMembers(MemberTypes memberType,BindingFlags bindingAttr,MemberFilter filter,Object filterCriteria)
        {
            // Define the work arrays
            MethodInfo[] m = null;
            ConstructorInfo[] c = null;
            FieldInfo[] f = null;
            PropertyInfo[] p = null;
            EventInfo[] e = null;
            Type[] t = null;
            
            int i = 0;
            int cnt = 0;            // Total Matchs
            
            // Check the methods
            if ((memberType & System.Reflection.MemberTypes.Method) != 0) {
                m = GetMethods(bindingAttr);
                if (filter != null) {
                    for (i=0;i<m.Length;i++)
                        if (!filter(m[i],filterCriteria))
                            m[i] = null;
                        else
                            cnt++;
                } else {
                    cnt+=m.Length;
                }
            }
            
            // Check the constructors
            if ((memberType & System.Reflection.MemberTypes.Constructor) != 0) {
                c = GetConstructors(bindingAttr);
                if (filter != null) {
                    for (i=0;i<c.Length;i++)
                        if (!filter(c[i],filterCriteria))
                            c[i] = null;
                        else
                            cnt++;
                } else {
                    cnt+=c.Length;
                }
            }
            
            // Check the fields
            if ((memberType & System.Reflection.MemberTypes.Field) != 0) {
                f = GetFields(bindingAttr);
                if (filter != null) {
                    for (i=0;i<f.Length;i++)
                        if (!filter(f[i],filterCriteria))
                            f[i] = null;
                        else
                            cnt++;
                } else {
                    cnt+=f.Length;
                }
            }
            
            // Check the Properties
            if ((memberType & System.Reflection.MemberTypes.Property) != 0) {
                p = GetProperties(bindingAttr);
                if (filter != null) {
                    for (i=0;i<p.Length;i++)
                        if (!filter(p[i],filterCriteria))
                            p[i] = null;
                        else
                            cnt++;
                } else {
                    cnt+=p.Length;
                }
            }
            
            // Check the Events
            if ((memberType & System.Reflection.MemberTypes.Event) != 0) {
                e = GetEvents();
                if (filter != null) {
                    for (i=0;i<e.Length;i++)
                        if (!filter(e[i],filterCriteria))
                            e[i] = null;
                        else
                            cnt++;
                } else {
                    cnt+=e.Length;
                }
            }
            
            // Check the Types
            if ((memberType & System.Reflection.MemberTypes.NestedType) != 0) {
                t = GetNestedTypes(bindingAttr);
                if (filter != null) {
                    for (i=0;i<t.Length;i++)
                        if (!filter(t[i],filterCriteria))
                            t[i] = null;
                        else
                            cnt++;
                } else {
                    cnt+=t.Length;
                }
            }
            
            // Allocate the Member Info
            MemberInfo[] ret = new MemberInfo[cnt];
            
            // Copy the Methods
            cnt = 0;
            if (m != null) {
                for (i=0;i<m.Length;i++)
                    if (m[i] != null)
                        ret[cnt++] = m[i];
            }
            
            // Copy the Constructors
            if (c != null) {
                for (i=0;i<c.Length;i++)
                    if (c[i] != null)
                        ret[cnt++] = c[i];
            }
            
            // Copy the Fields
            if (f != null) {
                for (i=0;i<f.Length;i++)
                    if (f[i] != null)
                        ret[cnt++] = f[i];
            }
            
            // Copy the Properties
            if (p != null) {
                for (i=0;i<p.Length;i++)
                    if (p[i] != null)
                        ret[cnt++] = p[i];
            }
            
            // Copy the Events
            if (e != null) {
                for (i=0;i<e.Length;i++)
                    if (e[i] != null)
                        ret[cnt++] = e[i];
            }
            
            // Copy the Types
            if (t != null) {
                for (i=0;i<t.Length;i++)
                    if (t[i] != null)
                        ret[cnt++] = t[i];
            }
            
            return ret;
        }
    
    ////////////////////////////////////////////////////////////////////////////////
    //
    // Attributes
    //
    //   The attributes are all treated as read-only properties on a class.  Most of
    //  these boolean properties have flag values defined in this class and act like
    //  a bit mask of attributes.  There are also a set of boolean properties that
    //  relate to the classes relationship to other classes and to the state of the
    //  class inside the runtime.
    //
    ////////////////////////////////////////////////////////////////////////////////
    
        // The attribute property on the Type.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Attributes"]/*' />
        public TypeAttributes Attributes     {
                get {return GetAttributeFlagsImpl();}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsNotPublic"]/*' />
        public bool IsNotPublic {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsPublic"]/*' />
        public bool IsPublic {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.VisibilityMask) == TypeAttributes.Public);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsNestedPublic"]/*' />
        public bool IsNestedPublic {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPublic);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsNestedPrivate"]/*' />
        public bool IsNestedPrivate {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsNestedFamily"]/*' />
        public bool IsNestedFamily {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamily);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsNestedAssembly"]/*' />
        public bool IsNestedAssembly {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.VisibilityMask) == TypeAttributes.NestedAssembly);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsNestedFamANDAssem"]/*' />
        public bool IsNestedFamANDAssem {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamANDAssem);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsNestedFamORAssem"]/*' />
        public bool IsNestedFamORAssem{
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamORAssem);}
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsAutoLayout"]/*' />
        public bool IsAutoLayout {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.LayoutMask) == TypeAttributes.AutoLayout);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsLayoutSequential"]/*' />
        public bool IsLayoutSequential {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.LayoutMask) == TypeAttributes.SequentialLayout);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsExplicitLayout"]/*' />
        public bool IsExplicitLayout {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.LayoutMask) == TypeAttributes.ExplicitLayout);}
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsClass"]/*' />
        public bool IsClass {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Class && !IsSubclassOf(Type.valueType));}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsInterface"]/*' />
        public bool IsInterface {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Interface);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsValueType"]/*' />
        public bool IsValueType {
                get {return IsValueTypeImpl();}
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsAbstract"]/*' />
        public bool IsAbstract {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.Abstract) != 0);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsSealed"]/*' />
        public bool IsSealed {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.Sealed) != 0);}
        }       
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsEnum"]/*' />
        public bool IsEnum {
                get {return IsSubclassOf(Type.enumType);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsSpecialName"]/*' />
        public bool IsSpecialName {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.SpecialName) != 0);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsImport"]/*' />
        public bool IsImport {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.Import) != 0);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsSerializable"]/*' />
        public bool IsSerializable {
                get {return (((GetAttributeFlagsImpl() & TypeAttributes.Serializable) != 0) ||
                             (this.QuickSerializationCastCheck()));}
        }
        private bool QuickSerializationCastCheck() {
            Type c = this.UnderlyingSystemType;
            while (c!=null) {
                if (c==typeof(Enum) || c==typeof(Delegate)) {
                    return true;
                }
                c = c.BaseType;
            }
            return false;
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsAnsiClass"]/*' />
        public bool IsAnsiClass {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.StringFormatMask) == TypeAttributes.AnsiClass);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsUnicodeClass"]/*' />
        public bool IsUnicodeClass {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.StringFormatMask) == TypeAttributes.UnicodeClass);}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsAutoClass"]/*' />
        public bool IsAutoClass {
                get {return ((GetAttributeFlagsImpl() & TypeAttributes.StringFormatMask) == TypeAttributes.AutoClass);}
        }
                
        // These are not backed up by attributes.  Instead they are implemented
        //      based internally.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsArray"]/*' />
        public bool IsArray {
                get {return IsArrayImpl();}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsByRef"]/*' />
        public bool IsByRef {
                get {return IsByRefImpl();}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsPointer"]/*' />
        public bool IsPointer {
                get {return IsPointerImpl();}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsPrimitive"]/*' />
        public bool IsPrimitive {
                get {return IsPrimitiveImpl();}
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsCOMObject"]/*' />
        public bool IsCOMObject {
                get {return IsCOMObjectImpl();}
        }
        internal bool IsGenericCOMObject {
                get {
                    if (this is RuntimeType) 
                        return ((RuntimeType)this).IsGenericCOMObjectImpl();
                    else
                        return false;
                }
        }
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.HasElementType"]/*' />
        public bool HasElementType {
            get {return HasElementTypeImpl();}
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsContextful"]/*' />
        public bool IsContextful {
                get {return IsContextfulImpl();}
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsMarshalByRef"]/*' />
        public bool IsMarshalByRef {
            get {return IsMarshalByRefImpl();}
        }

        internal bool HasProxyAttribute {
                get {return HasProxyAttributeImpl();}
        }
                       
        // Protected routine to determine if this class represents a value class
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsValueTypeImpl"]/*' />
        protected virtual bool IsValueTypeImpl() {
            Type type = this;
            if (type == Type.valueType || type == Type.enumType) 
                return false;
            return IsSubclassOf(Type.valueType);
        }

        // Protected routine to get the attributes.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetAttributeFlagsImpl"]/*' />
        abstract protected TypeAttributes GetAttributeFlagsImpl();
            
        // Protected routine to determine if this class represents an Array
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsArrayImpl"]/*' />
        abstract protected bool IsArrayImpl();

        // Protected routine to determine if this class is a ByRef
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsByRefImpl"]/*' />
        abstract protected bool IsByRefImpl();

        // Protected routine to determine if this class is a Pointer
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsPointerImpl"]/*' />
        abstract protected bool IsPointerImpl();
            
        // Protected routine to determine if this class represents a primitive type
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsPrimitiveImpl"]/*' />
        abstract protected bool IsPrimitiveImpl();
            
        // Protected routine to determine if this class represents a COM object
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsCOMObjectImpl"]/*' />
        abstract protected bool IsCOMObjectImpl();
    
        // Protected routine to determine if this class is contextful
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsContextfulImpl"]/*' />
        protected virtual bool IsContextfulImpl(){
            return typeof(ContextBoundObject).IsAssignableFrom(this);
        }
    

        // Protected routine to determine if this class is marshaled by ref
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsMarshalByRefImpl"]/*' />
        protected virtual bool IsMarshalByRefImpl(){
            return typeof(MarshalByRefObject).IsAssignableFrom(this);
        }

        internal virtual bool HasProxyAttributeImpl()
        {
            // We will override this in RuntimeType
            return false;
        }

    
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetElementType"]/*' />
        abstract public Type GetElementType();
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.HasElementTypeImpl"]/*' />
        abstract protected bool HasElementTypeImpl();

        // Return the underlying Type that represents the IReflect Object.  For expando object,
        // this is the (Object) IReflectInstance.GetType().  For Type object it is this.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.UnderlyingSystemType"]/*' />
        public abstract Type UnderlyingSystemType {
            get;
        }
        
        // IsLoaded
        // This indicates if the class has been loaded into the runtime.
        // @TODO: This is always true at the moment because everything is loaded.
        //  Reflection of Module will change this at some point
        internal virtual bool IsLoaded()
        {
            return true;
        }
    
        // Returns true of this class is a true subclass of c.  Everything 
        // else returns false.  If this class and c are the same class false is
        // returned.
        // 
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsSubclassOf"]/*' />
        public virtual bool IsSubclassOf(Type c)
        {
            Type p = this;
            if (p == c)
                return false;
            while (p != null) {
                if (p == c)
                    return true;
                p = p.BaseType;
            }
            return false;
        }
        
        // Returns true if the object passed is assignable to an instance of this class.
        // Everything else returns false. 
        // 
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsInstanceOfType"]/*' />
        public virtual bool IsInstanceOfType(Object o) 
        {
                if (o == null)
                        return false;

                // For transparent proxies we have to check the cast
                // using remoting specific facilities.
                if(RemotingServices.IsTransparentProxy(o)) {
                    return (null != RemotingServices.CheckCast(o, this));
                }

                if (IsInterface && o.GetType().IsCOMObject) {
                        if (this is RuntimeType)
                                return ((RuntimeType) this).SupportsInterface(o);
                }

            return IsAssignableFrom(o.GetType());
        }
        
        // Returns true if an instance of Type c may be assigned
        // to an instance of this class.  Return false otherwise.
        // 
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.IsAssignableFrom"]/*' />
        public virtual bool IsAssignableFrom(Type c)
        {
            if (c == null)
                return false;
            
            try {
                RuntimeType fromType = c.UnderlyingSystemType as RuntimeType;
                RuntimeType toType = this.UnderlyingSystemType as RuntimeType;
                if (fromType == null || toType == null) 
                {
                    // special case for TypeBuilder
                    TypeBuilder fromTypeBuilder = c as TypeBuilder;                    
                    if (fromTypeBuilder == null) 
                    {
                        return false;
                    }
                    
                    if (TypeBuilder.IsTypeEqual(this, c))
                        return true;
                        
                    // If fromTypeBuilder is a subclass of this class, then c can be cast to this type.
                    if (fromTypeBuilder.IsSubclassOf(this))
                        return true;
                
                    if (this.IsInterface == false)
                    {
                        return false;
                    }
                                                                                  
                    // now is This type a base type on one of the interface impl?
                    Type[] interfaces = fromTypeBuilder.GetInterfaces();
                    for (int i = 0; i < interfaces.Length; i++)
                    {
                        if (TypeBuilder.IsTypeEqual(interfaces[i], this))
                            return true;
                        if (interfaces[i].IsSubclassOf(this))
                            return true;
                    }
                    return false;
                }
                bool b = RuntimeType.CanCastTo(fromType, toType);
                return b;
            }
            catch (ArgumentException) {}
            
            // Check for interfaces
            if (IsInterface) {
                Type[] ifaces = c.GetInterfaces();
                for (int i=0;i<ifaces.Length;i++)
                    if (this == ifaces[i])
                        return true;
            }
            // Check the class relationship
            else {
                while (c != null) {
                    if (c == this)
                        return true;
                    c = c.BaseType;
                }
            }
            return false;
        }
        
        // ToString
        // Print the String Representation of the Type
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.ToString"]/*' />
        public override String ToString()
        {
            return "Type: "+Name;
        }
            
        // This method will return an array of classes based upon the array of 
        // types.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetTypeArray"]/*' />
        public static Type[] GetTypeArray(Object[] args) {
                if (args == null)
                        throw new ArgumentNullException("args");
                Type[] cls = new Type[args.Length];
                for (int i=0;i<cls.Length;i++)
                        cls[i] = args[i].GetType();
                return cls;
        }
        
        // Internal routine to TypeDef token.This rountine is called to update the 
        // runtime assembly information.
        internal virtual int InternalGetTypeDefToken()
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_SubclassOverride"));
        }
        
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Equals"]/*' />
        public override bool Equals(Object o) {
                if (o == null)
                        return false;
                if (!(o is Type))
                        return false;
                return (this.UnderlyingSystemType == ((Type) o).UnderlyingSystemType);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.Equals1"]/*' />
        public bool Equals(Type o) {
                if (o == null)
                        return false;
                return (this.UnderlyingSystemType == o.UnderlyingSystemType);
        }

        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            Type SystemType = UnderlyingSystemType;
            if (SystemType != this)
                return SystemType.GetHashCode();
            return base.GetHashCode();
        }

        
        // GetInterfaceMap
        // This method will return an interface mapping for the interface
        //  requested.  It will throw an argument exception if the Type doesn't
        //  implemenet the interface.
        /// <include file='doc\Type.uex' path='docs/doc[@for="Type.GetInterfaceMap"]/*' />
        public virtual InterfaceMapping GetInterfaceMap(Type interfaceType)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_SubclassOverride"));
        }

//          private static SerializableAttribute MarkerAttribute = new SerializableAttribute(false);
//          internal SerializableAttribute GetSerializableAttribute() {
//              SerializableAttribute attrib = (SerializableAttribute)Cache[CacheObjType.SerializableAttribute];
//              if (attrib == MarkerAttribute) {
//                  return null; //This indicates that it makes no statement
//              }
//              if (attrib==null) {
//                  Object[] foundAttribs = this.GetCustomAttributes(typeof(SerializableAttribute), false);
                    
//                  BCLDebug.Assert(foundAttribs.Length<2,
//                                  "[Assembly.TypesSerializableByDefault]Found more than one instance of the serializable attribute.");
                    
//                  if (foundAttribs.Length==0) {
//                      Cache[CacheObjType.SerializableAttribute] = MarkerAttribute;
//                      return null;
//                  } else {
//                      BCLDebug.Assert(foundAttribs[0] is SerializableAttribute, 
//                                      "[Assembly.TypesSerializableByDefault]Found attribute was not serializable attribute.");
                        
//                      attrib = (SerializableAttribute)foundAttribs[0];
//                      Cache[CacheObjType.SerializableAttribute] = attrib;
//                  }
//              }
//              return attrib;
//          }
                

        // This is used by Remoting
        internal static Type ResolveTypeRelativeTo(String typeName, Type serverType)
        {
            return ResolveTypeRelativeTo(typeName, 0, typeName.Length, serverType);          
        } // ResolveTypeRelativeTo

        // This is used by Remoting
        internal static Type ResolveTypeRelativeTo(String typeName, int offset, int count, Type serverType)        
        {
            Type type = ResolveTypeRelativeToBaseTypes(typeName, offset, count, serverType);
            if (type == null)
            {
                // compare against the interface list
                // GetInterfaces() returns a complete list of interfaces this type supports
                Type[] interfaces = serverType.GetInterfaces();
                foreach (Type iface in interfaces)
                {
                    String ifaceTypeName = iface.FullName;
                    if (ifaceTypeName.Length == count)
                    {
                        if (String.CompareOrdinal(typeName, offset, ifaceTypeName, 0, count) == 0)
                        {
                            return iface;
                        }                
                    }
                }
            }

            return type;
        } // ResolveTypeRelativeTo

        // This is used by Remoting
        internal static Type ResolveTypeRelativeToBaseTypes(String typeName, int offset, int count, Type serverType)        
        {
            // typeName is excepted to contain the full type name
            // offset is the start of the full type name within typeName
            // count us the number of characters in the full type name
            // serverType is the type of the server object

            if ((typeName == null) || (serverType == null))
                return null;

            String serverTypeName = serverType.FullName;
            if (serverTypeName.Length == count)
            {
                if (String.CompareOrdinal(typeName, offset, serverTypeName, 0, count) == 0)
                {
                    return serverType;
                }                
            }

            return ResolveTypeRelativeToBaseTypes(typeName, offset, count, serverType.BaseType); 
        } // ResolveTypeRelativeTo



        // private convenience data
        private const BindingFlags DefaultLookup = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;
        private static readonly Type valueType = typeof(System.ValueType);
        private static readonly Type enumType = typeof(System.Enum);
        private static readonly Type objectType = typeof(System.Object);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\uint32.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  UInt32
**
** Author: Brian Grunkemeyer (BrianGru) and Jay Roxe (jroxe) 
**
** Purpose: This class will encapsulate an uint and 
**          provide an Object representation of it.
**
** Date:  March 4, 1999
** 
===========================================================*/
namespace System {
	using System.Globalization;
	using System;
	using System.Runtime.InteropServices;

    // * Wrapper for unsigned 32 bit integers.
    /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32"]/*' />
    [Serializable, CLSCompliant(false), System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)] 
    public struct UInt32 : IComparable, IFormattable, IConvertible
    {
        private uint m_value;

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.MaxValue"]/*' />
        public const uint MaxValue = (uint)0xffffffff;
        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.MinValue"]/*' />
        public const uint MinValue = 0U;
	
    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type UInt32, this method throws an ArgumentException.
        // 
        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (value is UInt32) {
    			// Need to use compare because subtraction will wrap
    			// to positive for very large neg numbers, etc.
    			uint i = (uint)value;
                if (m_value < i) return -1;
                if (m_value > i) return 1;
                return 0;
            }
            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeUInt32"));
        }
    
        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is UInt32)) {
                return false;
            }
            return m_value == ((UInt32)obj).m_value;
        }

        // The absolute value of the int contained.
        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.GetHashCode"]/*' />
        public override int GetHashCode() {
            return ((int) m_value);
        }
    
        // The base 10 representation of the number with no extra padding.
        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.ToString"]/*' />
        public override String ToString() {
            return ToString(null, null);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatUInt32(m_value, format, NumberFormatInfo.GetInstance(provider));
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.Parse"]/*' />
    	[CLSCompliant(false)]
        public static uint Parse(String s) {
            return Parse(s, NumberStyles.Integer, null);
        }
    	
        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.Parse1"]/*' />
    	[CLSCompliant(false)]
        public static uint Parse(String s, NumberStyles style) {
			NumberFormatInfo.ValidateParseStyle(style);
            return Parse(s, style, null);
        }


        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.Parse2"]/*' />
    	[CLSCompliant(false)]
        public static uint Parse(String s, IFormatProvider provider) {
            return Parse(s, NumberStyles.Integer, provider);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.Parse3"]/*' />
    	[CLSCompliant(false)]
        public static uint Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
			NumberFormatInfo.ValidateParseStyle(style);
            return Number.ParseUInt32(s, style, info);
        }

		/// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.ToString3"]/*' />
		public String ToString(IFormatProvider provider) {
            return ToString(null, NumberFormatInfo.GetInstance(provider));
        }
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.UInt32;
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "UInt32", "DateTime"));
        }

        /// <include file='doc\UInt32.uex' path='docs/doc[@for="UInt32.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            m_value = 0;
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\uint64.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  UInt64
**
** Author: Brian Grunkemeyer (BrianGru) and Jay Roxe (jroxe) 
**         and Daryl Olander (darylo)
**
** Purpose: This class will encapsulate an unsigned long and 
**          provide an Object representation of it.
**
** Date:  March 4, 1999
** 
===========================================================*/
namespace System {
	using System.Globalization;
	using System;
	using System.Runtime.InteropServices;

    // Wrapper for unsigned 64 bit integers.
    /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64"]/*' />
    [Serializable, CLSCompliant(false), System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
    public struct UInt64 : IComparable, IFormattable, IConvertible
    {
        private ulong m_value;
    
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.MaxValue"]/*' />
        public const ulong MaxValue = (ulong) 0xffffffffffffffffL;
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.MinValue"]/*' />
        public const ulong MinValue = 0x0;
	    
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type UInt64, this method throws an ArgumentException.
        // 
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (value is UInt64) {
    			// Need to use compare because subtraction will wrap
    			// to positive for very large neg numbers, etc.
    			ulong i = (ulong)value;
                if (m_value < i) return -1;
                if (m_value > i) return 1;
                return 0;
            }
            throw new ArgumentException (Environment.GetResourceString("Arg_MustBeUInt64"));
        }
    
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is UInt64)) {
                return false;
            }
            return m_value == ((UInt64)obj).m_value;
        }

        // The value of the lower 32 bits XORed with the uppper 32 bits.
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.GetHashCode"]/*' />
        public override int GetHashCode() {
            return ((int)m_value) ^ (int)(m_value >> 32);
        }

        // The base-10 representation of the number with no extra padding.
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.ToString"]/*' />
        public override String ToString() {
            return ToString(null,null);
        }
    
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatUInt64(m_value, format, NumberFormatInfo.GetInstance(provider));
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.Parse"]/*' />
    	[CLSCompliant(false)]
        public static ulong Parse(String s) {
            return Parse(s, NumberStyles.Integer, null);
        }
    
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.Parse1"]/*' />
    	[CLSCompliant(false)]
        public static ulong Parse(String s, NumberStyles style) {
           NumberFormatInfo.ValidateParseStyle(style);
		   return Parse(s, style, null);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.Parse3"]/*' />
        [CLSCompliant(false)]
        public static ulong Parse(string s, IFormatProvider provider) {
            return Parse(s, NumberStyles.Integer, provider);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.Parse2"]/*' />
    	[CLSCompliant(false)]
        public static ulong Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
			NumberFormatInfo.ValidateParseStyle(style);
            return Number.ParseUInt64(s, style, info);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.ToString3"]/*' />
        public String ToString(IFormatProvider provider) {
            return ToString(null, provider);
        }
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.UInt64;
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return Convert.ToUInt16(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "UInt64", "DateTime"));
        }

        /// <include file='doc\UInt64.uex' path='docs/doc[@for="UInt64.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
		   return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = 0;
		}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\unhandledexceptioneventhandler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace System {
   
    using System;
    /// <include file='doc\UnhandledExceptionEventHandler.uex' path='docs/doc[@for="UnhandledExceptionEventHandler"]/*' />
     [Serializable()]
    public delegate void UnhandledExceptionEventHandler(Object sender, UnhandledExceptionEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\unauthorizedaccessexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  UnauthorizedAccessException
**
** Author: Brian Grunkemeyer
**
** Purpose: An exception for OS 'access denied' types of 
**          errors, including IO and limited security types 
**          of errors.
**
** Date: August 9, 2000
** 
===========================================================*/

using System;
using System.Runtime.Serialization;

namespace System {
    // The UnauthorizedAccessException is thrown when access errors 
    // occur from IO or other OS methods.  
    /// <include file='doc\UnauthorizedAccessException.uex' path='docs/doc[@for="UnauthorizedAccessException"]/*' />
    [Serializable()]
    public class UnauthorizedAccessException : SystemException {
    	/// <include file='doc\UnauthorizedAccessException.uex' path='docs/doc[@for="UnauthorizedAccessException.UnauthorizedAccessException"]/*' />
    	public UnauthorizedAccessException() 
            : base(Environment.GetResourceString("Arg_UnauthorizedAccessException")) {
    		SetErrorCode(__HResults.COR_E_UNAUTHORIZEDACCESS);
        }
    	
        /// <include file='doc\UnauthorizedAccessException.uex' path='docs/doc[@for="UnauthorizedAccessException.UnauthorizedAccessException1"]/*' />
        public UnauthorizedAccessException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_UNAUTHORIZEDACCESS);
        }
    	
        /// <include file='doc\UnauthorizedAccessException.uex' path='docs/doc[@for="UnauthorizedAccessException.UnauthorizedAccessException2"]/*' />
        public UnauthorizedAccessException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_UNAUTHORIZEDACCESS);
        }

        /// <include file='doc\UnauthorizedAccessException.uex' path='docs/doc[@for="UnauthorizedAccessException.UnauthorizedAccessException3"]/*' />
        protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\uint16.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  UInt16
**
** Author: Brian Grunkemeyer (BrianGru) and Jay Roxe (jroxe) 
**         and Daryl Olander (darylo)
**
** Purpose: This class will encapsulate a short and provide an
**			Object representation of it.
**
** Date:  March 4, 1999
** 
===========================================================*/
namespace System {
	using System.Globalization;
	using System;
	using System.Runtime.InteropServices;

    // Wrapper for unsigned 16 bit integers.
    /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16"]/*' />
    [Serializable, CLSCompliant(false), System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)] 
    public struct UInt16 : IComparable, IFormattable, IConvertible
    {
        private ushort m_value;
    
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.MaxValue"]/*' />
        public const ushort MaxValue = (ushort)0xFFFF;
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.MinValue"]/*' />
        public const ushort MinValue = 0;
		    
        
        // Compares this object to another object, returning an integer that
        // indicates the relationship. 
        // Returns a value less than zero if this  object
        // null is considered to be less than any instance.
        // If object is not of type UInt16, this method throws an ArgumentException.
        // 
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.CompareTo"]/*' />
        public int CompareTo(Object value) {
            if (value == null) {
                return 1;
            }
            if (value is UInt16) {
                return ((int)m_value - (int)(((UInt16)value).m_value));
            }
            throw new ArgumentException(Environment.GetResourceString("Arg_MustBeUInt16"));
        }
    
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is UInt16)) {
                return false;
            }
            return m_value == ((UInt16)obj).m_value;
        }

        // Returns a HashCode for the UInt16
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.GetHashCode"]/*' />
        public override int GetHashCode() {
            return (int)m_value;
        }

        // Converts the current value to a String in base-10 with no extra padding.
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.ToString"]/*' />
        public override String ToString() {
            return ToString(null, null);
        }


        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.ToString1"]/*' />
        public String ToString(String format) {
            return ToString(format, null);
        }
        
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.ToString2"]/*' />
        public String ToString(String format, IFormatProvider provider) {
            return Number.FormatUInt32(m_value, format, NumberFormatInfo.GetInstance(provider));
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.Parse"]/*' />
    	[CLSCompliant(false)]
        public static ushort Parse(String s) {
            return Parse(s, NumberStyles.Integer, null);
        }
    	
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.Parse1"]/*' />
    	[CLSCompliant(false)]
        public static ushort Parse(String s, NumberStyles style) {
			NumberFormatInfo.ValidateParseStyle(style);
            return Parse(s, style, null);
        }


        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.Parse2"]/*' />
    	[CLSCompliant(false)]
        public static ushort Parse(String s, IFormatProvider provider) {
            return Parse(s, NumberStyles.Integer, provider);
        }
    	
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.Parse3"]/*' />
    	[CLSCompliant(false)]
        public static ushort Parse(String s, NumberStyles style, IFormatProvider provider) {
            NumberFormatInfo info = NumberFormatInfo.GetInstance(provider);
			NumberFormatInfo.ValidateParseStyle(style);
            uint i = Number.ParseUInt32(s, style, info);
            if (i > MaxValue) throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
            return (ushort)i;
        }
		
		/// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.ToString3"]/*' />
		public String ToString(IFormatProvider provider)
        {
            return ToString(null, provider);
        }
        //
        // IValue implementation
        // 
    	
        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.GetTypeCode"]/*' />
        public TypeCode GetTypeCode() {
            return TypeCode.UInt16;
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToBoolean"]/*' />
        /// <internalonly/>
        bool IConvertible.ToBoolean(IFormatProvider provider) {
            return Convert.ToBoolean(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToChar"]/*' />
        /// <internalonly/>
        char IConvertible.ToChar(IFormatProvider provider) {
            return Convert.ToChar(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToSByte"]/*' />
        /// <internalonly/>
        sbyte IConvertible.ToSByte(IFormatProvider provider) {
            return Convert.ToSByte(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToByte"]/*' />
        /// <internalonly/>
        byte IConvertible.ToByte(IFormatProvider provider) {
            return Convert.ToByte(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToInt16"]/*' />
        /// <internalonly/>
        short IConvertible.ToInt16(IFormatProvider provider) {
            return Convert.ToInt16(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToUInt16"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ushort IConvertible.ToUInt16(IFormatProvider provider) {
            return m_value;
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToInt32"]/*' />
        /// <internalonly/>
        int IConvertible.ToInt32(IFormatProvider provider) {
            return Convert.ToInt32(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToUInt32"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        uint IConvertible.ToUInt32(IFormatProvider provider) {
            return Convert.ToUInt32(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToInt64"]/*' />
        /// <internalonly/>
        long IConvertible.ToInt64(IFormatProvider provider) {
            return Convert.ToInt64(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToUInt64"]/*' />
        /// <internalonly/>
        [CLSCompliant(false)]
        ulong IConvertible.ToUInt64(IFormatProvider provider) {
            return Convert.ToUInt64(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToSingle"]/*' />
        /// <internalonly/>
        float IConvertible.ToSingle(IFormatProvider provider) {
            return Convert.ToSingle(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToDouble"]/*' />
        /// <internalonly/>
        double IConvertible.ToDouble(IFormatProvider provider) {
            return Convert.ToDouble(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToDecimal"]/*' />
        /// <internalonly/>
        Decimal IConvertible.ToDecimal(IFormatProvider provider) {
            return Convert.ToDecimal(m_value);
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToDateTime"]/*' />
        /// <internalonly/>
        DateTime IConvertible.ToDateTime(IFormatProvider provider) {
            throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), "UInt16", "DateTime"));
        }

        /// <include file='doc\UInt16.uex' path='docs/doc[@for="UInt16.IConvertible.ToType"]/*' />
        /// <internalonly/>
        Object IConvertible.ToType(Type type, IFormatProvider provider) {
            return Convert.DefaultToType((IConvertible)this, type, provider);
        }

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			m_value = 0;
		}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\uintptr.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  UIntPtr
**
** Author: Rajesh Chandrashekaran
**
** Purpose: Platform independent integer
**
** Date: July 21, 2000
** 
===========================================================*/

namespace System {
    
	using System;
	using System.Globalization;
    using System.Runtime.Serialization;
	
    /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr"]/*' />
	[Serializable(),CLSCompliant(false)] 
    public struct UIntPtr : ISerializable
	{

		unsafe private void* m_value;

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.Zero"]/*' />
        public static readonly UIntPtr Zero = new UIntPtr(0);

				
		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.UIntPtr"]/*' />
		public unsafe UIntPtr(uint value)
		{
			m_value = (void *)value;
		}
	
		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.UIntPtr1"]/*' />
		public unsafe UIntPtr(ulong value)
		{
   				#if WIN32
			        m_value = (void *)checked((uint)value);
				#else
					m_value = (void *)value;
				#endif
		}

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.UIntPtr2"]/*' />
        [CLSCompliant(false)]
        public unsafe UIntPtr(void* value)
        {
            m_value = value;
        }

        private unsafe UIntPtr(SerializationInfo info, StreamingContext context) {
            ulong l = info.GetUInt64("value");

            if (Size==4 && l>UInt32.MaxValue) {
                throw new ArgumentException(Environment.GetResourceString("Serialization_InvalidPtrValue"));
            }

            m_value = (void *)l;
        }

        unsafe void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            info.AddValue("value", (ulong)m_value);
        }

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.Equals"]/*' />
        public unsafe override bool Equals(Object obj) {
			if (obj is UIntPtr) {
				return (m_value == ((UIntPtr)obj).m_value);
            }
			return false;
		}
    
       	/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.GetHashCode"]/*' />
       	public unsafe override int GetHashCode() {
			return (int)m_value & 0x7fffffff;
        }

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.ToUInt32"]/*' />
        public unsafe uint ToUInt32() {
        #if WIN32
			return (uint)m_value;
		#else
			return checked((uint)m_value);
		#endif
        }

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.ToUInt64"]/*' />
        public unsafe ulong ToUInt64() {
            return (ulong)m_value;
        }
      
    	/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.ToString"]/*' />
    	public unsafe override String ToString() {
		#if WIN32
			return ((uint)m_value).ToString();
		#else
			return ((ulong)m_value).ToString();
		#endif
        }


        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorUIntPtr"]/*' />
        public static explicit operator UIntPtr (uint value) 
		{
			return new UIntPtr(value);
		}

		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorUIntPtr1"]/*' />
		public static explicit operator UIntPtr (ulong value) 
		{
			return new UIntPtr(value);
		}
	
		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatoruint"]/*' />
		public unsafe static explicit operator uint (UIntPtr  value) 
		{
            #if WIN32
			    return (uint)value.m_value;
		    #else
			    return checked((uint)value.m_value);
		    #endif

		}

		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorulong"]/*' />
		public unsafe static explicit operator ulong (UIntPtr  value) 
		{
			return (ulong)value.m_value;
		}

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorUIntPtr2"]/*' />
        [CLSCompliant(false)]
        public static unsafe explicit operator UIntPtr (void* value)
        {
            return new UIntPtr(value);
        }

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorvoidMUL"]/*' />
        [CLSCompliant(false)]
        public static unsafe explicit operator void* (UIntPtr value)
        {
            return value.ToPointer();
        }


		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorEQ"]/*' />
		public unsafe static bool operator == (UIntPtr value1, UIntPtr value2) 
		{
			return value1.m_value == value2.m_value;
		}

		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorNE"]/*' />
		public unsafe static bool operator != (UIntPtr value1, UIntPtr value2) 
		{
			return value1.m_value != value2.m_value;
		}

		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.Size"]/*' />
		public static int Size
		{
			get
			{
				#if WIN32
					return 4;
				#else
					return 8;
				#endif
			}
		}
       
        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.ToPointer"]/*' />
        [CLSCompliant(false)]
        public unsafe void* ToPointer()
        {
            return m_value;
        }

/*
        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorUIntPtr3"]/*' />
        public static explicit operator UIntPtr (int value) 
        {
		    return new UIntPtr(value);
        }
        
        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorUIntPtr4"]/*' />
        public static explicit operator UIntPtr (long value) 
        {
            return new UIntPtr(value);
        }

		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorint"]/*' />
        public unsafe static explicit operator int (UIntPtr value)
        {
            return value.ToInt32();
        }

		/// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.operatorlong"]/*' />
        public unsafe static explicit operator long (UIntPtr value)
        {
            return value.ToInt64();
        }

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.ToInt32"]/*' />
        public unsafe int ToInt32()
        {
            return (int)checked((uint)m_value);
        }

        /// <include file='doc\UIntPtr.uex' path='docs/doc[@for="UIntPtr.ToInt64"]/*' />
        public unsafe long ToInt64()
        {
            #if WIN32
                return (long)(int)m_value;
            #else
                return (long)m_value;
            #endif
        }
*/
 	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\unhandledexceptioneventargs.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace System {
    
    using System;
    
    /// <include file='doc\UnhandledExceptionEventArgs.uex' path='docs/doc[@for="UnhandledExceptionEventArgs"]/*' />
    [Serializable()]
    public class UnhandledExceptionEventArgs : EventArgs {
        private Object _Exception;
        private bool _IsTerminating;

        /// <include file='doc\UnhandledExceptionEventArgs.uex' path='docs/doc[@for="UnhandledExceptionEventArgs.UnhandledExceptionEventArgs"]/*' />
        public UnhandledExceptionEventArgs(Object exception, bool isTerminating) {
            _Exception = exception;
            _IsTerminating = isTerminating;
        }
        /// <include file='doc\UnhandledExceptionEventArgs.uex' path='docs/doc[@for="UnhandledExceptionEventArgs.ExceptionObject"]/*' />
        public Object ExceptionObject { get { return _Exception; } }
        /// <include file='doc\UnhandledExceptionEventArgs.uex' path='docs/doc[@for="UnhandledExceptionEventArgs.IsTerminating"]/*' />
        public bool IsTerminating { get { return _IsTerminating; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\version.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    Version
**
** Author:  
**
** Purpose: 
**
** Date:    June 4, 1999
**
===========================================================*/
namespace System {

    using CultureInfo = System.Globalization.CultureInfo;

    // A Version object contains four hierarchical numeric components: major, minor,
    // build and revision.  Build and revision may be unspecified, which is represented 
    // internally as a -1.  By definition, an unspecified component matches anything 
    // (both unspecified and specified), and an unspecified component is "less than" any
    // specified component.

    /// <include file='doc\Version.uex' path='docs/doc[@for="Version"]/*' />
    [Serializable]
    public sealed class Version : ICloneable, IComparable
    {
        // AssemblyName depends on the order staying the same
        private int _Major;
        private int _Minor;
        private int _Build = -1;
        private int _Revision = -1;
    
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Version"]/*' />
        public Version(int major, int minor, int build, int revision) {
            if (major < 0) 
              throw new ArgumentOutOfRangeException("major",Environment.GetResourceString("ArgumentOutOfRange_Version"));

            if (minor < 0) 
              throw new ArgumentOutOfRangeException("minor",Environment.GetResourceString("ArgumentOutOfRange_Version"));

            if (build < 0)
              throw new ArgumentOutOfRangeException("build",Environment.GetResourceString("ArgumentOutOfRange_Version"));
            
            if (revision < 0) 
              throw new ArgumentOutOfRangeException("revision",Environment.GetResourceString("ArgumentOutOfRange_Version"));
            
            _Major = major;
            _Minor = minor;
            _Build = build;
            _Revision = revision;
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Version1"]/*' />
        public Version(int major, int minor, int build) {
            if (major < 0) 
                throw new ArgumentOutOfRangeException("major",Environment.GetResourceString("ArgumentOutOfRange_Version"));

            if (minor < 0) 
              throw new ArgumentOutOfRangeException("minor",Environment.GetResourceString("ArgumentOutOfRange_Version"));

            if (build < 0) 
              throw new ArgumentOutOfRangeException("build",Environment.GetResourceString("ArgumentOutOfRange_Version"));

            
            _Major = major;
            _Minor = minor;
            _Build = build;
        }
    
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Version2"]/*' />
        public Version(int major, int minor) {
            if (major < 0) 
                throw new ArgumentOutOfRangeException("major",Environment.GetResourceString("ArgumentOutOfRange_Version"));

            if (minor < 0) 
                throw new ArgumentOutOfRangeException("minor",Environment.GetResourceString("ArgumentOutOfRange_Version"));
            
            _Major = major;
            _Minor = minor;
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Version3"]/*' />
        public Version(String version) {
            if ((Object) version == null)
                throw new ArgumentNullException("version");

            String[] parsedComponents = version.Split(new char[] {'.'});
            int parsedComponentsLength = parsedComponents.Length;
            if ((parsedComponentsLength < 2) || (parsedComponentsLength > 4)) throw new ArgumentException(Environment.GetResourceString("Arg_VersionString"));
            _Major = Int32.Parse(parsedComponents[0], CultureInfo.InvariantCulture);
            if (_Major < 0) 
              throw new ArgumentOutOfRangeException("version",Environment.GetResourceString("ArgumentOutOfRange_Version"));

            _Minor = Int32.Parse(parsedComponents[1], CultureInfo.InvariantCulture);
            if (_Minor < 0) 
              throw new ArgumentOutOfRangeException("version",Environment.GetResourceString("ArgumentOutOfRange_Version"));

            parsedComponentsLength -= 2;
            if (parsedComponentsLength > 0) {
                _Build = Int32.Parse(parsedComponents[2], CultureInfo.InvariantCulture);
                if (_Build < 0) 
                  throw new ArgumentOutOfRangeException("build",Environment.GetResourceString("ArgumentOutOfRange_Version"));

                parsedComponentsLength--;
                if (parsedComponentsLength > 0) {
                    _Revision = Int32.Parse(parsedComponents[3], CultureInfo.InvariantCulture);
                    if (_Revision < 0)
                      throw new ArgumentOutOfRangeException("revision",Environment.GetResourceString("ArgumentOutOfRange_Version"));
                }
            }
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Version4"]/*' />
        public Version() 
        {
            _Major = 0;
            _Minor = 0;
        }

        // Properties for setting and getting version numbers
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Major"]/*' />
        public int Major {
            get { return _Major; }
        }
    
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Minor"]/*' />
        public int Minor {
            get { return _Minor; }
        }
    
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Build"]/*' />
        public int Build {
            get { return _Build; }
        }
    
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Revision"]/*' />
        public int Revision {
            get { return _Revision; }
        }
     
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Clone"]/*' />
        public Object Clone() {
            Version v = new Version();
            v._Major = _Major;
            v._Minor = _Minor;
            v._Build = _Build;
            v._Revision = _Revision;
            return(v);
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.CompareTo"]/*' />
        public int CompareTo(Object version)
        {
            if (version == null)
                return 1;

            if (!(version is Version))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeVersion"));

            Version v = (Version) version;

            if (this._Major != v._Major)
                if (this._Major > v._Major)
                    return 1;
                else
                    return -1;

            if (this._Minor != v._Minor)
                if (this._Minor > v._Minor)
                    return 1;
                else
                    return -1;

            if (this._Build != v._Build)
                if (this._Build > v._Build)
                    return 1;
                else
                    return -1;

            if (this._Revision != v._Revision)
                if (this._Revision > v._Revision)
                    return 1;
                else
                    return -1;

            return 0;
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (((Object) obj == null) ||
                (!(obj is Version)))
                return false;

            Version v = (Version) obj;
            // check that major, minor, build & revision numbers match
            if ((this._Major != v._Major) || 
                (this._Minor != v._Minor) || 
                (this._Build != v._Build) ||
                (this._Revision != v._Revision))
                return false;

            return true;
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            // Let's assume that most version numbers will be pretty small and just
            // OR some lower order bits together.

            int accumulator = 0;

            accumulator |= (this._Major & 0x0000000F) << 28;
            accumulator |= (this._Minor & 0x000000FF) << 20;
            accumulator |= (this._Build & 0x000000FF) << 12;
            accumulator |= (this._Revision & 0x00000FFF);

            return accumulator;
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.ToString"]/*' />
        public override String ToString() {
            if (_Build == -1) return(ToString(2));
            if (_Revision == -1) return(ToString(3));
            return(ToString(4));
        }
        
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.ToString1"]/*' />
        public String ToString(int fieldCount) {
            switch (fieldCount) {
            case 0: 
                return(String.Empty);
            case 1: 
                return(String.Concat(_Major));
            case 2: 
                return(String.Concat(_Major,".",_Minor));
            default:
                if (_Build == -1)
                    throw new ArgumentException(String.Format(Environment.GetResourceString("ArgumentOutOfRange_Bounds_Lower_Upper"), "0", "2"), "fieldCount");
                if (fieldCount == 3)
                    return( _Major + "." + _Minor + "." + _Build );

                if (_Revision == -1)
                    throw new ArgumentException(String.Format(Environment.GetResourceString("ArgumentOutOfRange_Bounds_Lower_Upper"), "0", "3"), "fieldCount");

                if (fieldCount == 4)
                    return( Major + "." + _Minor + "." + _Build + "." + _Revision );

                throw new ArgumentException(String.Format(Environment.GetResourceString("ArgumentOutOfRange_Bounds_Lower_Upper"), "0", "4"), "fieldCount");
            }
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.operatorEQ"]/*' />
        public static bool operator ==(Version v1, Version v2) {
            if ((Object) v1 == null) {
                if ((Object) v2 == null)
                    return true;
                else
                    return false;
            }
            if ((Object) v2 == null)
               return false;

            return v1.Equals(v2);
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.operatorNE"]/*' />
        public static bool operator !=(Version v1, Version v2) {
            return !(v1 == v2);
        }

        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.operatorLT"]/*' />
        public static bool operator <(Version v1, Version v2) {
            if ((Object) v1 == null)
                throw new ArgumentNullException("v1");
            return (v1.CompareTo(v2) < 0);
        }
        
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.operatorLE"]/*' />
        public static bool operator <=(Version v1, Version v2) {
            if ((Object) v1 == null)
                throw new ArgumentNullException("v1");
            return (v1.CompareTo(v2) <= 0);
        }
        
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.operatorGT"]/*' />
        public static bool operator >(Version v1, Version v2) {
            return (v2 < v1);
        }
        
        /// <include file='doc\Version.uex' path='docs/doc[@for="Version.operatorGE"]/*' />
        public static bool operator >=(Version v1, Version v2) {
            return (v2 <= v1);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\unityserializationholder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: UnitySerializationHolder
**
** Author: Jay Roxe
**
** Purpose: Holds classes (Empty, Null, Missing) for which we
** guarantee that there is only ever one instance of.
**
** Date: October 3, 1999
**
============================================================*/
namespace System {
    
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System.Reflection;

    [Serializable()]
    internal class UnitySerializationHolder : ISerializable, IObjectReference {
    
        //
        // There's one of these constants for each supported unity type.
        // To add a new type, add the constant here and modify GetRealObject.
        // We currently only support types that take 0 or 1 args to create.  
        // MemberInfos are more complex and are handled in the 
        // MemberInfoSerializationHolder.
        //
        internal const int EmptyUnity       = 0x0001;
        internal const int NullUnity        = 0x0002;
        internal const int MissingUnity     = 0x0003;
        internal const int RuntimeTypeUnity = 0x0004;
        internal const int ModuleUnity      = 0x0005;
        internal const int AssemblyUnity    = 0x0006;
    
        internal String m_data;
        internal String m_assemName;
        internal int m_unityType;
        
        // A helper method that returns the SerializationInfo that a class utilizing 
        // UnitySerializationHelper should return from a call to GetObjectData.  It contains
        // the unityType (defined above) and any optional data (used only for the reflection
        // types.)
        internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType, String data, Assembly assem) {
            BCLDebug.Trace("SER", "UnitySerializationHolder: Adding [" , data , "] with type: ", unityType);
            BCLDebug.Assert(info!=null, "[UnitySerializationHolder.GetUnitySerializationInfo]info!=null");
            info.SetType(typeof(UnitySerializationHolder));
            info.AddValue("Data", data, typeof(String));
            info.AddValue("UnityType", unityType);

            String assemName;
            if (assem==null) {
                assemName = String.Empty;
            } else {
                assemName = assem.FullName;
            }

            info.AddValue("AssemblyName", assemName);
        }
    

        internal UnitySerializationHolder(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            m_data      = info.GetString("Data");
            m_unityType = info.GetInt32("UnityType");
            m_assemName = info.GetString("AssemblyName");
            BCLDebug.Trace("SER", "UnitySerializationHolder: Retreiving [", m_data, "] with type: ", m_unityType, " in assembly: ", m_assemName);   
        }

        // This class is designed to be used only in reflection and is not itself serializable.
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnitySerHolder"));
        }
    
        // GetRealObject uses the data we have in m_data and m_unityType to do a lookup on the correct 
        // object to return.  We have specific code here to handle the different types which we support.
        // The reflection types (Assembly, Module, and Type) have to be looked up through their static
        // accessors by name.
        public virtual Object GetRealObject(StreamingContext context) {
            Assembly assem;

            BCLDebug.Trace("SER", "[GetRealObject] UnityType:", m_unityType);

            switch (m_unityType) {
            case EmptyUnity:
                BCLDebug.Trace("SER", "[GetRealObject]Returning Empty.Value");
                BCLDebug.Trace("SER", "[GetRealObject]Empty's value is: ", Empty.Value, "||");
                return Empty.Value;
            case NullUnity:
                return DBNull.Value;
            case MissingUnity:
                return Missing.Value;
            case RuntimeTypeUnity:
                if (m_data==null || m_data.Length==0 || m_assemName==null) {
                    BCLDebug.Trace("SER","UnitySerializationHolder.GetRealObject Type. Data is: ", m_data);
                    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
                }
                if (m_assemName.Length==0) {
                    return RuntimeType.GetTypeInternal(m_data, false, false, false);
                }
                
                assem = FormatterServices.LoadAssemblyFromStringNoThrow(m_assemName);
                if (assem==null) {
                    BCLDebug.Trace("SER", "UnitySerializationHolder.GetRealObject Type. AssemblyName is: ", m_assemName, " but we can't load it.");
                    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
                }
                
                Type t = assem.GetTypeInternal(m_data, false, false, false);

                return t;
            case ModuleUnity:
                if (m_data==null || m_data.Length==0 || m_assemName==null) {
                    BCLDebug.Trace("SER", "UnitySerializationHolder.GetRealObject Module. Data is: ", m_data);
                    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
                }
                assem = FormatterServices.LoadAssemblyFromStringNoThrow(m_assemName);
                if (assem==null) {
                    BCLDebug.Trace("SER", "UnitySerializationHolder.GetRealObject Module. AssemblyName is: ", m_assemName, " but we can't load it.");
                    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
                }
                
                Module namedModule = assem.GetModule(m_data);
                if (namedModule==null)
                    throw new SerializationException(Environment.GetResourceString("Serialization_UnableToFindModule"));
                return namedModule;

            case AssemblyUnity:
                if (m_data==null || m_data.Length==0 || m_assemName==null) {
                    BCLDebug.Log("UnitySerializationHolder.GetRealObject.  Assembly. Data is: " + ((m_data==null)?"<null>":m_data));
                    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
                }
                assem = FormatterServices.LoadAssemblyFromStringNoThrow(m_assemName);
                if (assem==null) {
                    BCLDebug.Trace("SER", "UnitySerializationHolder.GetRealObject Module. AssemblyName is: ", m_assemName, " but we can't load it.");
                    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientDeserializationState"));
                }
 
                return assem;

            default:
                //This should never happen because we only use the class internally.
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidUnity"));
            }
        }
    }
           
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\valuetype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:   ValueType
**
** Author:  Brian Grunkemeyer (BrianGru)
**
** Purpose: Base class for all value classes.
**
** Date:    January 4, 2000
**
===========================================================*/
namespace System {
    using System;
    using System.Reflection;
    using System.Runtime.CompilerServices;

    /// <include file='doc\ValueType.uex' path='docs/doc[@for="ValueType"]/*' />
    [Serializable]
    public abstract class ValueType {

        /// <include file='doc\ValueType.uex' path='docs/doc[@for="ValueType.Equals"]/*' />
        public override bool Equals (Object obj) {
            BCLDebug.Perf(false, "ValueType::Equals is not fast.  "+this.GetType().FullName+" should override Equals(Object)");
            if (null==obj) {
                return false;
            }
            RuntimeType thisType = (RuntimeType)this.GetType();
            RuntimeType thatType = (RuntimeType)obj.GetType();

            if (thatType!=thisType) {
                return false;
            }

            Object thisObj = (Object)this;
            Object thisResult, thatResult;

            // if there are no GC references in this object we can avoid reflection 
            // and do a fast memcmp
            if (CanCompareBits(this))       // remove the 'false &&' when 39384 is resolved. 
                return FastEqualsCheck(thisObj, obj);

            FieldInfo[] thisFields = thisType.InternalGetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, false);
            
            for (int i=0; i<thisFields.Length; i++) {
                thisResult = ((RuntimeFieldInfo)thisFields[i]).InternalGetValue(thisObj,false);
                thatResult = ((RuntimeFieldInfo)thisFields[i]).InternalGetValue(obj, false);
                
                if (thisResult == null) {
                    if (thatResult != null)
                        return false;
                }
                else
                if (!thisResult.Equals(thatResult)) {
                    return false;
                }
            }

            return true;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool CanCompareBits(Object obj);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool FastEqualsCheck(Object a, Object b);

        /*=================================GetHashCode==================================
        **Action: Our algorithm for returning the hashcode is a little bit complex.  We look
        **        for the first non-static field and get it's hashcode.  If the type has no
        **        non-static fields, we return the hashcode of the type.  We can't take the
        **        hashcode of a static member because if that member is of the same type as
        **        the original type, we'll end up in an infinite loop.
        **Returns: The hashcode for the type.
        **Arguments: None.
        **Exceptions: None.
        ==============================================================================*/
        /// <include file='doc\ValueType.uex' path='docs/doc[@for="ValueType.GetHashCode"]/*' />
        public override int GetHashCode() {
            // Note that for correctness, we can't use any field of the value type
            // since that field may be mutable in some way.  If we use that field
            // and the value changes, we may not be able to look up that type in a
            // hash table.  For correctness, we need to use something unique to
            // the type of this object.  Yes, this sucks.  -- Brian G., 12/6/2000

            // HOWEVER, we decided that the perf of returning a constant value (such as
            // the hash code for the type) would be too big of a perf hit.  We're willing
            // to deal with less than perfect results, and people should still be
            // encouraged to override GetHashCode.  Yes, this also sucks.  -- Brian G., 2/20/2001

            BCLDebug.Correctness(!(this is System.Collections.DictionaryEntry), "Calling GetHashCode on DictionaryEntry is dumb and probably wrong.");
            BCLDebug.Perf(false, "ValueType::GetHashCode is not fast.  Perhaps "+this.GetType().FullName+" should override GetHashCode()");

            RuntimeType thisType = (RuntimeType)this.GetType();
            FieldInfo[] thisFields = thisType.InternalGetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, false);
            if (thisFields.Length>0) {
                for (int i=0; i<thisFields.Length; i++) {
                    Object obj = ((Object)(((RuntimeFieldInfo)thisFields[i]).InternalGetValue((Object)this,false)));
                    if (obj != null)
                        return obj.GetHashCode();
                }
            }
            // Using the method table pointer is about 4x faster than getting the
            // sync block index for the Type object.
            return GetMethodTablePtrAsInt(this);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int GetMethodTablePtrAsInt(Object obj);

        /// <include file='doc\ValueType.uex' path='docs/doc[@for="ValueType.ToString"]/*' />
        public override String ToString() {
            Type thisType = this.GetType();
            return thisType.FullName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\void.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Void
//	This class represents the void return type
////////////////////////////////////////////////////////////////////////////////

namespace System {
   
	using System;
    /// <include file='doc\Void.uex' path='docs/doc[@for="Void"]/*' />
    [Serializable]
    public struct Void 
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\_localdatastoremgr.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: LocalDataStoreMgr
**
** Author: David Mortenson (dmortens)
**
** Purpose: Class that manages stores of local data. This class is used in 
**          cooperation with the LocalDataStore class.
**
** Date: March 25, 1999
**
=============================================================================*/
namespace System {
    
    using System;
    using System.Collections;

	// This is a cheesy internal helper class that is used to make sure memory
	// is actually being accessed and not some cached copy of a field in a
	// register.
	// WARNING: If we every do type analysis to eliminate virtual functions,
	// this will break.
	// This class will not be marked serializable
	internal class LdsSyncHelper
	{
		internal virtual int Get(ref int slot)
		{
			return slot;
		}
	}

	// This class is an encapsulation of a slot so that it is managed in a secure fashion.
	// It is constructed by the LocalDataStoreManager, holds the slot and the manager
	// and cleans up when it is finalized.
	// This class will not be marked serializable
	/// <include file='doc\_LocalDataStoreMgr.uex' path='docs/doc[@for="LocalDataStoreSlot"]/*' />
	public sealed class LocalDataStoreSlot
	{
		private static LdsSyncHelper m_helper = new LdsSyncHelper();

		private LocalDataStoreMgr m_mgr;
		private int m_slot;

		// Construct the object to encapsulate the slot.
		internal LocalDataStoreSlot(LocalDataStoreMgr mgr, int slot)
		{
			m_mgr = mgr;
			m_slot = slot;
		}

		// Accessors for the two fields of this class.
		internal LocalDataStoreMgr Manager
		{
			get
			{
				return m_mgr;
			}
		}
		internal int Slot
		{
			get
			{
				return m_slot;
			}
		}

		// This is used to make sure we are actually reading and writing to
		// memory to fetch the slot (rather than possibly using a value
		// cached in a register).
		internal bool IsValid()
		{
			return m_helper.Get(ref m_slot) != -1;
		}

		// Release the slot reserved by this object when this object goes away.
		// There is  a race condition that can happen in the face of
		// resurrection where another thread is fetching values or assigning
		// while the finalizer thread is here.  We are counting on the fact
		// that code that fetches values calls IsValid after fetching a value
		// and before giving it to anyone.  See LocalDataStore for the other 
		// half of this.  We are also counting on code that sets values locks
		// the manager.
		/// <include file='doc\_LocalDataStoreMgr.uex' path='docs/doc[@for="LocalDataStoreSlot.Finalize"]/*' />
        ~LocalDataStoreSlot()
		{
			int slot = m_slot;

			// This lock fixes synchronization with the assignment of values.
			lock (m_mgr)
			{
				// Mark the slot as free.
				m_slot = -1;

				m_mgr.FreeDataSlot(slot);
			}
		}
	}

	// This class will not be marked serializable
    internal class LocalDataStoreMgr
    {
    	private const byte DataSlotOccupied				= 0x01;

    	private const int InitialSlotTableSize			= 64;
    	private const int SlotTableDoubleThreshold		= 512;
    	private const int LargeSlotTableSizeIncrease	= 128;
    
        /*=========================================================================
        ** Create a data store to be managed by this manager and add it to the
		** list. The initial size of the new store matches the number of slots
		** allocated in this manager.
        =========================================================================*/
    	public LocalDataStore CreateLocalDataStore()
    	{
        	// Create a new local data store.
        	LocalDataStore Store = new LocalDataStore(this, m_SlotInfoTable.Length);
        		
	        lock(this) {
        		// Add the store to the array list and return it.
        		m_ManagedLocalDataStores.Add(Store);
        	}
       		return Store;
	    }

        /*=========================================================================
		 * Remove the specified store from the list of managed stores..
        =========================================================================*/
    	public void DeleteLocalDataStore(LocalDataStore store)
		{
	        lock(this) {
        		// Remove the store to the array list and return it.
        		m_ManagedLocalDataStores.Remove(store);
        	}
		}

        /*=========================================================================
        ** Allocates a data slot by finding an available index and wrapping it
		** an object to prevent clients from manipulating it directly, allowing us
		** to make assumptions its integrity.
        =========================================================================*/
    	public LocalDataStoreSlot AllocateDataSlot()
    	{
	        lock(this) {
        		int i;		
        		LocalDataStoreSlot slot;

        		// Retrieve the current size of the table.
        		int SlotTableSize = m_SlotInfoTable.Length;

				// Check if there are any slots left.
				if (m_FirstAvailableSlot < SlotTableSize)
				{
					// Save the first available slot.
					slot = new LocalDataStoreSlot(this, m_FirstAvailableSlot);
       				m_SlotInfoTable[m_FirstAvailableSlot] = DataSlotOccupied;

					// Find the next available slot.
					for (i=m_FirstAvailableSlot+1; i < SlotTableSize; ++i)
	        			if (0 == (m_SlotInfoTable[i] & DataSlotOccupied))
							break;

					// Save the new "first available slot".
					m_FirstAvailableSlot = i;

					// Return the slot index.
					return slot;
				}

        		// The table is full so we need to increase its size.
        		int NewSlotTableSize;
        		if (SlotTableSize < SlotTableDoubleThreshold)
        		{
        			// The table is still relatively small so double it.
        			NewSlotTableSize = SlotTableSize * 2;
        		}
        		else
        		{
        			// The table is relatively large so simply increase its size by a given amount.
        			NewSlotTableSize = SlotTableSize + LargeSlotTableSizeIncrease;
        		}

        		// Allocate the new slot info table.
        		byte[] NewSlotInfoTable = new byte[NewSlotTableSize];

        		// Copy the old array into the new one.
        		Array.Copy(m_SlotInfoTable, NewSlotInfoTable, SlotTableSize);
        		m_SlotInfoTable = NewSlotInfoTable;

        		// SlotTableSize is the index of the first empty slot in the expanded table.
				slot = new LocalDataStoreSlot(this, SlotTableSize);
        		m_SlotInfoTable[SlotTableSize] = DataSlotOccupied;
				m_FirstAvailableSlot = SlotTableSize + 1;

        		// Return the selected slot
        		return slot;			
        	}
	    }
    	
        /*=========================================================================
		** Allocate a slot and associate a name with it.
        =========================================================================*/
    	public LocalDataStoreSlot AllocateNamedDataSlot(String name)
    	{
	        lock(this)
			{
        		// Allocate a normal data slot.
				LocalDataStoreSlot slot = AllocateDataSlot();

        		// Insert the association between the name and the data slot number
				// in the hash table.
        		m_KeyToSlotMap.Add(name, slot);
        		return slot;
        	}
		}

        /*=========================================================================
		** Retrieve the slot associated with a name, allocating it if no such
		** association has been defined.
        =========================================================================*/
    	public LocalDataStoreSlot GetNamedDataSlot(String name)
    	{
	        lock(this)
			{
        		// Lookup in the hashtable to try find a slot for the name.
        		LocalDataStoreSlot slot = (LocalDataStoreSlot) m_KeyToSlotMap[name];
        		
        		// If the name is not yet in the hashtable then add it.
        		if (null == slot)
        			return AllocateNamedDataSlot(name);
        		
        		// The name was in the hashtable so return the associated slot.
        		return slot;
        	}
		}

        /*=========================================================================
		** Eliminate the association of a name with a slot.  The actual slot will
		** be reclaimed when the finalizer for the slot object runs.
        =========================================================================*/
    	public void FreeNamedDataSlot(String name)
    	{
	        lock(this)
			{
        		// Remove the name slot association from the hashtable.
        		m_KeyToSlotMap.Remove(name);
        	}
		}

        /*=========================================================================
        ** Free's a previously allocated data slot on ALL the managed data stores.
        =========================================================================*/
    	internal void FreeDataSlot(int slot)
    	{
	        lock(this) {
        		// Go thru all the managed stores and set the data on the specified slot to 0.
        		for (int i=0; i < m_ManagedLocalDataStores.Count; i++)
        		{
        			((LocalDataStore)m_ManagedLocalDataStores[i]).SetDataInternal(
        			                                                  slot, 
        			                                                  null, 
        			                                                  false);
                }        			                                                    
    			        		
        		// Mark the slot as being no longer occupied. 
        		m_SlotInfoTable[slot] = 0;
				if (slot < m_FirstAvailableSlot)
					m_FirstAvailableSlot = slot;
        	}
	    }

        /*=========================================================================
        ** Return the number of allocated slots in this manager.
        =========================================================================*/
	    public void ValidateSlot(LocalDataStoreSlot slot)
	    {
            // Make sure the slot was allocated for this store.
	        if (slot==null || slot.Manager != this)
                throw new ArgumentException(Environment.GetResourceString("Argument_ALSInvalidSlot"));
        }

        /*=========================================================================
        ** Return the number of allocated slots in this manager.
        =========================================================================*/
	    internal int GetSlotTableLength()
	    {
	            return m_SlotInfoTable.Length;
        }

    	private byte[] m_SlotInfoTable = new byte[InitialSlotTableSize];
		private int m_FirstAvailableSlot = 0;
    	private ArrayList m_ManagedLocalDataStores = new ArrayList();
    	private Hashtable m_KeyToSlotMap = new Hashtable();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\weakreference.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: WeakReference
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A wrapper for establishing a WeakReference to an Object.
**
** Date:  November 4, 1998
** 
===========================================================*/
namespace System {
    
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System.Runtime.InteropServices;
    using System.Threading;
    /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference"]/*' />
    [Serializable()] public class WeakReference : ISerializable {
    
        //@Consider:  m_handle is actually a hack to represent an OBJEcTHANDLE
        //        which is a pointer.  this class should be replaced with 
        //        a managed native class.
        internal int m_handle;
        internal bool m_IsLongReference;
    
        // Creates a new WeakReference that keeps track of target.
        // Assumes a Short Weak Reference (ie TrackResurrection is false.)
        //
        /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference.WeakReference"]/*' />
        public WeakReference(Object target) 
            : this(target, false) {
        }
    
        //Creates a new WeakReference that keeps track of target.
        //
        /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference.WeakReference1"]/*' />
        public WeakReference(Object target, bool trackResurrection) {
            m_IsLongReference=trackResurrection;
            m_handle = GCHandle.InternalAlloc(target,
                            trackResurrection ? GCHandleType.WeakTrackResurrection : GCHandleType.Weak);
        }


        /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference.WeakReference2"]/*' />
        protected WeakReference(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            Object temp = info.GetValue("TrackedObject",typeof(Object));
            m_IsLongReference = info.GetBoolean("TrackResurrection");
            m_handle = GCHandle.InternalAlloc(temp,
                                              m_IsLongReference ? GCHandleType.WeakTrackResurrection : GCHandleType.Weak);
        }
    
        //Determines whether or not this instance of WeakReference still refers to an object
        //that has not been collected.
        //
        /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference.IsAlive"]/*' />
        public virtual bool IsAlive {
            get {
                int h = m_handle;
                if (h == 0)
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));
                return (GCHandle.InternalGet(h)!=null);
            }
        }
    
        //Returns a boolean indicating whether or not we're tracking objects until they're collected (true)
        //or just until they're finalized (false).
        //
        /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference.TrackResurrection"]/*' />
        public virtual bool TrackResurrection {
            get { return m_IsLongReference; }
        }
    
        //Gets the Object stored in the handle if it's accessible.
        // Or sets it.
        //
        /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference.Target"]/*' />
        public virtual Object Target {
            get {
                int h = m_handle;
                if (h == 0)
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));
                Object o = GCHandle.InternalGet(h);

                // Check m_handle once more.  There is a race when this object is
                // finalized.  If the handle has gone to null, we have to fail
                // this call.
                if (m_handle == 0) {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));
                } else {
                    return o;
                }
            }
            set {
                int h = m_handle;
                if (h == 0)
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));

                // There is a race w/ finalization where m_handle gets set to
                // NULL and the WeakReference becomes invalid.  Here we have to 
                // do the following in order:
                //
                // 1.  Get the old object value
                // 2.  Get m_handle
                // 3.  HndInterlockedCompareExcahnge(m_handle, newValue, oldValue);
                //
                // If the interlocked-cmp-exchange fails, then either we lost a race
                // with another updater, or we lost a race w/ the finalizer.  In
                // either case, we can just let the other guy win.
                //
                Object oldValue = GCHandle.InternalGet(h);
                h = m_handle;  
                if (h == 0)
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HandleIsNotInitialized"));
                GCHandle.InternalCompareExchange(h, value, oldValue, false /* isPinned */);
            }
        }
    
        // Free all system resources associated with this reference.
        //
        /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference.Finalize"]/*' />
        ~WeakReference() {
            int old_handle = m_handle;
            if (old_handle != 0) {
                if (old_handle == Interlocked.CompareExchange (ref m_handle, 0, old_handle)) 
                    GCHandle.InternalFree(old_handle);
            }
        }
    
        /// <include file='doc\WeakReference.uex' path='docs/doc[@for="WeakReference.GetObjectData"]/*' />
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            info.AddValue("TrackedObject", Target, typeof(Object));
            info.AddValue("TrackResurrection", m_IsLongReference);
        }
    
    }        

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\__comobject.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  __ComObject
**
** Author: Raja Krishnaswamy (rajak)
**
** __ComObject is the root class for all COM wrappers.  This class
** defines only the basics. This class is used for wrapping COM objects
** accessed from COM+
**
** Date:  January 29, 1998
** 
===========================================================*/
namespace System {
    
    using System;
    using System.Collections;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Reflection;

    internal class __ComObject : MarshalByRefObject
    {
        private IntPtr m_wrap;
        private Hashtable m_ObjectToDataMap;

        /*============================================================
        ** default constructor
        ** can't instantiate this directly
        =============================================================*/
        private __ComObject ()
        {
        }

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            m_wrap=m_wrap;
        }
#endif
        internal IntPtr GetIUnknown(out bool fIsURTAggregated)
        {
            fIsURTAggregated = !GetType().IsDefined(typeof(ComImportAttribute), false);
            return System.Runtime.InteropServices.Marshal.GetIUnknownForObject(this);
        }

        //====================================================================
        // This method retrieves the data associated with the specified
        // key if any such data exists for the current __ComObject.
        //====================================================================
        internal Object GetData(Object key)
        {
            Object data = null;

            // Synchronize access to the map.
            lock(this)
            {
                // If the map hasn't been allocated, then there can be no data for the specified key.
                if (m_ObjectToDataMap != null)
                {
                    // Look up the data in the map.
                    data = m_ObjectToDataMap[key];
                }
            }

            return data;
        }
        
        //====================================================================
        // This method sets the data for the specified key on the current 
        // __ComObject.
        //====================================================================
        internal bool SetData(Object key, Object data)
        {
            bool bAdded = false;

            // Synchronize access to the map.
            lock(this)
            {
                // If the map hasn't been allocated yet, allocate it.
                if (m_ObjectToDataMap == null)
                    m_ObjectToDataMap = new Hashtable();

                // If there isn't already data in the map then add it.
                if (m_ObjectToDataMap[key] == null)
                {
                    m_ObjectToDataMap[key] = data;
                    bAdded = true;
                }
            }

            return bAdded;
        }

        //====================================================================
        // This method is called from within the EE and releases all the 
        // cached data for the __ComObject.
        //====================================================================
        internal void ReleaseAllData()
        {
            // Synchronize access to the map.
            lock(this)
            {

                // If the map hasn't been allocated, then there is nothing to do.
                if (m_ObjectToDataMap != null)
                {
                    foreach (Object o in m_ObjectToDataMap.Values)
                    {
                        // If the object implements IDisposable, then call Dispose on it.
                        IDisposable DisposableObj = o as IDisposable;
                        if (DisposableObj != null)
                            DisposableObj.Dispose();

                        // If the object is a derived from __ComObject, then call Marshal.ReleaseComObject on it.
                        __ComObject ComObj = o as __ComObject;
                        if (ComObj != null)
                            Marshal.ReleaseComObject(ComObj);
                    }

                    // Set the map to null to indicate it has been cleaned up.
                    m_ObjectToDataMap = null;
                }
            }
        }

        //====================================================================
        // This method is called from within the EE and is used to handle
        // calls on methods of event interfaces.
        //====================================================================
        internal Object GetEventProvider(Type t)
        {
            // Check to see if we already have a cached event provider for this type.
            Object EvProvider = GetData(t);
            if (EvProvider == null)
            {
                // Create the event provider for the specified type.
                EvProvider = Activator.CreateInstance(t, Activator.ConstructorDefault | BindingFlags.NonPublic, null, new Object[]{this}, null);

                // Attempt to cache the wrapper on the object.
                if (!SetData(t, EvProvider))
                {
                    // Dispose the event provider if it implements IDisposable.
                    IDisposable DisposableEvProv = EvProvider as IDisposable;
                    if (DisposableEvProv != null)
                        DisposableEvProv.Dispose();

                    // Another thead already cached the wrapper so use that one instead.
                    EvProvider = GetData(t);
                }
            }

            return EvProvider;
        }

        internal int ReleaseSelf()
        {
            return Marshal.nReleaseComObject(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\_localdatastore.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: LocalDataStore
**
** Author: David Mortenson (dmortens)
**
** Purpose: Class that stores local data. This class is used in cooperation
**          with the _LocalDataStoreMgr class.
**
** Date: March 25, 1999
**
=============================================================================*/

namespace System {
    
    using System;

    // This class will not be marked serializable
    internal class LocalDataStore
    {       
        /*=========================================================================
        ** DON'T CHANGE THESE UNLESS YOU MODIFY LocalDataStoreBaseObject in vm\object.h
        =========================================================================*/
        private Object[] m_DataTable;
        private LocalDataStoreMgr m_Manager;
        private int DONT_USE_InternalStore = 0; // pointer

        /*=========================================================================
        ** Initialize the data store.
        =========================================================================*/
        public LocalDataStore(LocalDataStoreMgr mgr, int InitialCapacity)
        {
            if (null == mgr)
                throw new ArgumentNullException("mgr");
            
            // Store the manager of the local data store.       
            m_Manager = mgr;
            
            // Allocate the array that will contain the data.
            m_DataTable = new Object[InitialCapacity];
        }
    
        /*=========================================================================
        ** Retrieves the value from the specified slot.
        =========================================================================*/
        public Object GetData(LocalDataStoreSlot slot)
        {
            Object o = null;

            // Validate the slot.
            m_Manager.ValidateSlot(slot);

            // Cache the slot index to avoid synchronization issues.
            int slotIdx = slot.Slot;

            if (slotIdx >= 0)
            {
                // Delay expansion of m_DataTable if we can
                if (slotIdx >= m_DataTable.Length)
                    return null;

                // Retrieve the data from the given slot.
                o = m_DataTable[slotIdx];
            }

            // Check if the slot has become invalid.
            if (!slot.IsValid())
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_SlotHasBeenFreed"));
            return o;
        }
    
        /*=========================================================================
        ** Sets the data in the specified slot.
        =========================================================================*/
        public void SetData(LocalDataStoreSlot slot, Object data)
        {
            // Validate the slot.
            m_Manager.ValidateSlot(slot);

            // I can't think of a way to avoid the race described in the
            // LocalDataStoreSlot finalizer method without a lock.
            lock (m_Manager)
            {
                if (!slot.IsValid())
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_SlotHasBeenFreed"));

                // Do the actual set operation.
                SetDataInternal(slot.Slot, data, true /*bAlloc*/ );
            }
        }
        
        /*=========================================================================
        ** This method does the actual work of setting the data. 
        =========================================================================*/
        internal void SetDataInternal(int slot, Object data, bool bAlloc)
        {               
            // We try to delay allocate the dataTable (in cases like the manager clearing a 
            // just-freed slot in all stores            
            if (slot >= m_DataTable.Length)
            {
                if (!bAlloc)
                    return;
                SetCapacity(m_Manager.GetSlotTableLength());
            }

            // Set the data on the given slot.
            m_DataTable[slot] = data;            
        }

		/*=========================================================================
		** Method used to set the capacity of the local data store.
		=========================================================================*/
		private void SetCapacity(int capacity)
		{
			// Validate that the specified capacity is larger than the current one.
			if (capacity < m_DataTable.Length)
			throw new ArgumentException(Environment.GetResourceString("Argument_ALSInvalidCapacity"));
		            
			// Allocate the new data table.
			Object[] NewDataTable = new Object[capacity];
		            
			// Copy all the objects into the new table.
			Array.Copy(m_DataTable, NewDataTable, m_DataTable.Length);
		            
			// Save the new table.
			m_DataTable = NewDataTable;
		}        
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\__filters.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// __Filters.cool
//
// This class defines the delegate methods for the COM+ implemented filters.
//
// Author: darylo
// Date: July 98
//

namespace System {
	using System;
	using System.Reflection;
	using System.Globalization;
	[Serializable()]
    internal class __Filters {
    	
    	// Filters...
    	// The following are the built in filters defined for this class.  These
    	//	should really be defined as static methods.  They are used in as delegates
    	//	which currently doesn't support static methods.  We will change this 
    	//	once the compiler supports delegates.
    	
    	// FilterAttribute
    	//	This method will search for a member based upon the attribute passed in.
    	//	filterCriteria -- an Int32 representing the attribute
    	internal virtual bool FilterAttribute(MemberInfo m,Object filterCriteria)
    	{
    		// Check that the criteria object is an Integer object
    		if (filterCriteria == null)
    			throw new InvalidFilterCriteriaException(Environment.GetResourceString("RFLCT.FltCritInt"));
    
    		switch (m.MemberType) 
    		{
    		case MemberTypes.Constructor:
    		case MemberTypes.Method: {

    			MethodAttributes criteria = 0;
				try {
					int i = (int) filterCriteria;
					criteria = (MethodAttributes) i;
				}
				catch (Exception) {
     				throw new InvalidFilterCriteriaException(Environment.GetResourceString("RFLCT.FltCritInt"));
				}

    			
    			MethodAttributes attr;
    			if (m.MemberType == MemberTypes.Method)
    				attr = ((MethodInfo) m).Attributes;
    			else
    				attr = ((ConstructorInfo) m).Attributes;
    				
    			if (((criteria & MethodAttributes.MemberAccessMask) != 0) && (attr & MethodAttributes.MemberAccessMask) != (criteria & MethodAttributes.MemberAccessMask))
    				return false;
    			if (((criteria & MethodAttributes.Static) != 0) && (attr & MethodAttributes.Static) == 0)
    				return false;
    			if (((criteria & MethodAttributes.Final) != 0) && (attr & MethodAttributes.Final) == 0)
    				return false;
    			if (((criteria & MethodAttributes.Virtual) != 0) && (attr & MethodAttributes.Virtual) == 0)
    				return false;
    			if (((criteria & MethodAttributes.Abstract) != 0) && (attr & MethodAttributes.Abstract) == 0)
    				return false;
    			if (((criteria & MethodAttributes.SpecialName)  != 0) && (attr & MethodAttributes.SpecialName) == 0)
    				return false;
    			return true;
    		}
    		case MemberTypes.Field: 
    		{
    			FieldAttributes criteria = 0;
				try {
					int i = (int) filterCriteria;
					criteria = (FieldAttributes) i;
				}
				catch (Exception) {
     				throw new InvalidFilterCriteriaException(Environment.GetResourceString("RFLCT.FltCritInt"));
				}

				FieldAttributes attr = ((FieldInfo) m).Attributes;
    			if (((criteria & FieldAttributes.FieldAccessMask) != 0) && (attr & FieldAttributes.FieldAccessMask) != (criteria & FieldAttributes.FieldAccessMask))
    				return false;
    			if (((criteria & FieldAttributes.Static) != 0) && (attr & FieldAttributes.Static) == 0)
    				return false;
    			if (((criteria & FieldAttributes.InitOnly) != 0) && (attr & FieldAttributes.InitOnly) == 0)
    				return false;
    			if (((criteria & FieldAttributes.Literal) != 0) && (attr & FieldAttributes.Literal) == 0)
    				return false;
    			if (((criteria & FieldAttributes.NotSerialized) != 0) && (attr & FieldAttributes.NotSerialized) == 0)
    				return false;
    			if (((criteria & FieldAttributes.PinvokeImpl) != 0) && (attr & FieldAttributes.PinvokeImpl) == 0)
    				return false;
    			return true;
    		}
    		}
    
    		return false;
    	}
    	// FilterName
    	// This method will filter based upon the name.  A partial wildcard
    	//	at the end of the string is supported.
    	//	filterCriteria -- This is the string name
    	internal virtual bool FilterName(MemberInfo m,Object filterCriteria)
    	{
    		// Check that the criteria object is a String object
    		if(filterCriteria == null || !(filterCriteria is String))
    			throw new InvalidFilterCriteriaException(Environment.GetResourceString("RFLCT.FltCritString"));
    
    		// At the moment this fails if its done on a single line....
    		String str = ((String) filterCriteria);
    		str = str.Trim();
    
            String name = m.Name;
            // hack to skip the get the nested class name only, as opposed to the mangled one
            if (m.MemberType == MemberTypes.NestedType) 
                name = name.Substring(name.LastIndexOf('+') + 1);
    		// Check to see if this is a prefix or exact match requirement
    		if (str.Length > 0 && str[str.Length - 1] == '*') {
    			str = str.Substring(0, str.Length - 1);
    			return (name.StartsWith(str));
    		}
    
    		return (name.Equals(str));
    	}
    	
    	// FilterIgnoreCase
    	// This delegate will do a name search but does it with the
    	//	ignore case specified.
    	internal virtual bool FilterIgnoreCase(MemberInfo m,Object filterCriteria)
    	{
    		// Check that the criteria object is a String object
    		if(filterCriteria == null || !(filterCriteria is String))
    			throw new InvalidFilterCriteriaException(Environment.GetResourceString("RFLCT.FltCritString"));
    
    		String str = (String) filterCriteria;
    		str = str.Trim();
    
            String name = m.Name;
            // hack to skip the get the nested class name only, as opposed to the mangled one
            if (m.MemberType == MemberTypes.NestedType) 
                name = name.Substring(name.LastIndexOf('+') + 1);
    		// Check to see if this is a prefix or exact match requirement
    		if (str.Length > 0 && str[str.Length - 1] == '*') {
    			str = str.Substring(0, str.Length - 1);
                return (String.Compare(name,0,str,0,str.Length,true,CultureInfo.InvariantCulture)==0);
    		}
    
    		return (String.Compare(str,name, true, CultureInfo.InvariantCulture) == 0);
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\bitarray.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: BitArray
**
** Author: Brian Grunkemeyer (BrianGru), Rajesh Chandrashekaran (rajeshc)
**         Original implementation by Derek Yenzer
**
** Purpose: The BitArray class manages a compact array of bit values.
**
** Date: October 5, 1999
**
=============================================================================*/
namespace System.Collections {
    // @Consider: is _ShrinkThreshold (256) ints the correct threshold for shrinking?
	using System;
    // A vector of bits.  Use this to store bits efficiently, without having to do bit 
    // shifting yourself.
    /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray"]/*' />
    [Serializable()] public sealed class BitArray : ICollection, ICloneable {
    	private BitArray() {
    	}
    	
        /*=========================================================================
        ** Allocates space to hold length bit values. All of the values in the bit
        ** array are set to false.
        **
        ** Exceptions: ArgumentException if length < 0.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.BitArray"]/*' />
        public BitArray(int length) 
            : this(length, false) {
        }
    
        /*=========================================================================
        ** Allocates space to hold length bit values. All of the values in the bit
        ** array are set to defaultValue.
        **
        ** Exceptions: ArgumentOutOfRangeException if length < 0.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.BitArray1"]/*' />
        public BitArray(int length, bool defaultValue) {
            if (length < 0) {
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
    
            m_array = new int[(length + 31) / 32];
            m_length = length;
    
            int fillValue = defaultValue ? unchecked(((int)0xffffffff)) : 0;
            for (int i = 0; i < m_array.Length; i++) {
                m_array[i] = fillValue;
            }

			_version = 0;
        }
    
        /*=========================================================================
        ** Allocates space to hold the bit values in bytes. bytes[0] represents
        ** bits 0 - 7, bytes[1] represents bits 8 - 15, etc. The LSB of each byte
        ** represents the lowest index value; bytes[0] & 1 represents bit 0,
        ** bytes[0] & 2 represents bit 1, bytes[0] & 4 represents bit 2, etc.
        **
        ** Exceptions: ArgumentException if bytes == null.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.BitArray2"]/*' />
        public BitArray(byte[] bytes) {
            if (bytes == null) {
                throw new ArgumentNullException("bytes");
            }
    
            m_array = new int[(bytes.Length + 3) / 4];
            m_length = bytes.Length * 8;
    
            int i = 0;
            int j = 0;
            while (bytes.Length - j >= 4) {
                m_array[i++] = (bytes[j] & 0xff) |
                              ((bytes[j + 1] & 0xff) << 8) |
                              ((bytes[j + 2] & 0xff) << 16) |
                              ((bytes[j + 3] & 0xff) << 24);
                j += 4;
            }
    
            BCLDebug.Assert(bytes.Length - j >= 0, "BitArray byteLength problem");
            BCLDebug.Assert(bytes.Length - j < 4, "BitArray byteLength problem #2");
    
            switch (bytes.Length - j) {
                case 3:
                    m_array[i] = ((bytes[j + 2] & 0xff) << 16);
                    goto case 2;
                    // fall through
                case 2:
                    m_array[i] |= ((bytes[j + 1] & 0xff) << 8);
                    goto case 1;
                    // fall through
                case 1:
                    m_array[i] |= (bytes[j] & 0xff);
		    break;
            }

			_version = 0;
        }

		/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.BitArray3"]/*' />
		public BitArray(bool[] values) {
            if (values == null) {
                throw new ArgumentNullException("values");
            }
    
            m_array = new int[(values.Length + 31) / 32];
            m_length = values.Length;
    
            for (int i = 0;i<values.Length;i++)	{
				if (values[i])
					m_array[i/32] |= (1 << (i%32));
			}

			_version = 0;

        }
    
        /*=========================================================================
        ** Allocates space to hold the bit values in values. values[0] represents
        ** bits 0 - 31, values[1] represents bits 32 - 63, etc. The LSB of each
        ** integer represents the lowest index value; values[0] & 1 represents bit
        ** 0, values[0] & 2 represents bit 1, values[0] & 4 represents bit 2, etc.
        **
        ** Exceptions: ArgumentException if values == null.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.BitArray4"]/*' />
        public BitArray(int[] values) {
            if (values == null) {
                throw new ArgumentNullException("values");
            }
    
            m_array = new int[values.Length];
            m_length = values.Length * 32;
    
            Array.Copy(values, m_array, values.Length);

			_version = 0;
        }
    
        /*=========================================================================
        ** Allocates a new BitArray with the same length and bit values as bits.
        **
        ** Exceptions: ArgumentException if bits == null.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.BitArray5"]/*' />
        public BitArray(BitArray bits) {
            if (bits == null) {
                throw new ArgumentNullException("bits");
            }
    
            m_array = new int[(bits.m_length + 31) / 32];
            m_length = bits.m_length;
    
            Array.Copy(bits.m_array, m_array, (bits.m_length + 31) / 32);

			_version = bits._version;
        }

		/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.this"]/*' />
		public bool this[int index] {
                get {
                    return Get(index);
                }
                set {
                    Set(index,value);
		        }
         }
    
        /*=========================================================================
        ** Returns the bit value at position index.
        **
        ** Exceptions: ArgumentOutOfRangeException if index < 0 or
        **             index >= GetLength().
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.Get"]/*' />
        public bool Get(int index) {
            if (index < 0 || index >= m_length) {
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
    
            return (m_array[index / 32] & (1 << (index % 32))) != 0;
        }
    
        /*=========================================================================
        ** Sets the bit value at position index to value.
        **
        ** Exceptions: ArgumentOutOfRangeException if index < 0 or
        **             index >= GetLength().
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.Set"]/*' />
        public void Set(int index, bool value) {
            if (index < 0 || index >= m_length) {
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
    
            if (value) {
                m_array[index / 32] |= (1 << (index % 32));
            } else {
                m_array[index / 32] &= ~(1 << (index % 32));
            }

			_version++;
        }
    
        /*=========================================================================
        ** Sets all the bit values to value.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.SetAll"]/*' />
        public void SetAll(bool value) {
            int fillValue = value ? unchecked(((int)0xffffffff)) : 0;
            int ints = (m_length + 31) / 32;
            for (int i = 0; i < ints; i++) {
                m_array[i] = fillValue;
            }

			_version++;
        }
    
        /*=========================================================================
        ** Returns a reference to the current instance ANDed with value.
        **
        ** Exceptions: ArgumentException if value == null or
        **             value.Length != this.Length.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.And"]/*' />
        public BitArray And(BitArray value) {
            if (value==null)
                throw new ArgumentNullException("value");
            if (m_length != value.m_length)
                throw new ArgumentException(Environment.GetResourceString("Arg_ArrayLengthsDiffer"));
    
            int ints = (m_length + 31) / 32;
            for (int i = 0; i < ints; i++) {
                m_array[i] &= value.m_array[i];
            }
    
			_version++;
            return this;
        }
    
        /*=========================================================================
        ** Returns a reference to the current instance ORed with value.
        **
        ** Exceptions: ArgumentException if value == null or
        **             value.Length != this.Length.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.Or"]/*' />
        public BitArray Or(BitArray value) {
            if (value==null)
                throw new ArgumentNullException("value");
            if (m_length != value.m_length)
                throw new ArgumentException(Environment.GetResourceString("Arg_ArrayLengthsDiffer"));
    
            int ints = (m_length + 31) / 32;
            for (int i = 0; i < ints; i++) {
                m_array[i] |= value.m_array[i];
            }
    
			_version++;
            return this;
        }
    
        /*=========================================================================
        ** Returns a reference to the current instance XORed with value.
        **
        ** Exceptions: ArgumentException if value == null or
        **             value.Length != this.Length.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.Xor"]/*' />
        public BitArray Xor(BitArray value) {
            if (value==null)
                throw new ArgumentNullException("value");
            if (m_length != value.m_length)
                throw new ArgumentException(Environment.GetResourceString("Arg_ArrayLengthsDiffer"));
    
            int ints = (m_length + 31) / 32;
            for (int i = 0; i < ints; i++) {
                m_array[i] ^= value.m_array[i];
            }
			
			_version++;
            return this;
        }
    
        /*=========================================================================
        ** Inverts all the bit values. On/true bit values are converted to
        ** off/false. Off/false bit values are turned on/true. The current instance
        ** is updated and returned.
        =========================================================================*/
        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.Not"]/*' />
        public BitArray Not() {
            int ints = (m_length + 31) / 32;
            for (int i = 0; i < ints; i++) {
                m_array[i] = ~m_array[i];
            }
    
			_version++;
            return this;
        }


        /// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.Length"]/*' />
        public int Length {
            get { return m_length; }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                }

                int newints = (value + 31) / 32;
                if (newints > m_array.Length || newints + _ShrinkThreshold < m_array.Length) {
                    // grow or shrink (if wasting more than _ShrinkThreshold ints)
                    int[] newarray = new int[newints];
                    Array.Copy(m_array, newarray, newints > m_array.Length ? m_array.Length : newints);
                    m_array = newarray;
                }
                
                if (value > m_length) {
                    // clear high bit values in the last int
                    int last = ((m_length + 31) / 32) - 1;
                    int bits = m_length % 32;
                    if (bits > 0) {
                        m_array[last] &= (1 << bits) - 1;
                    }
                    
                    // clear remaining int values
                    Array.Clear(m_array, last + 1, newints - last - 1);
                }
                
                m_length = value;
				_version++;
            }
        }

		// ICollection implementation
		/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.CopyTo"]/*' />
		public void CopyTo(Array array, int index)
		{
			if (array == null)
				throw new ArgumentNullException("array");

			if (index < 0)
				throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));

            if (array.Rank != 1)
                throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
				

			if (array is int[])
			{
				Array.Copy(m_array, 0, array, index, (m_length + 31) / 32);
			}
			else if (array is byte[])
			{
				if ((array.Length - index) < (m_length + 7)/8)
					 throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

				byte [] b = (byte[])array;
				for (int i = 0; i<(m_length + 7)/8;i++)
					b[index + i] = (byte)((m_array[i/4] >> ((i%4)*8)) & 0x000000FF); // Shift to bring the required byte to LSB, then mask
			}
			else if (array is bool[])
			{
				if (array.Length - index < m_length)
					 throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

				bool [] b = (bool[])array;
				for (int i = 0;i<m_length;i++)
					b[index + i] = ((m_array[i/32] >> (i%32)) & 0x00000001) != 0;
			}
			else
				throw new ArgumentException(Environment.GetResourceString("Arg_BitArrayTypeUnsupported"));
 		}
		
		/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.Count"]/*' />
		public int Count
    	{ 
			get
			{
				return m_length;
			}
		}

		/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.Clone"]/*' />
		public Object Clone()
		{
            BitArray bitArray = new BitArray(m_array);
            bitArray._version = _version;
            bitArray.m_length = m_length;
            return bitArray;
		}
    	
    	/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.SyncRoot"]/*' />
    	public Object SyncRoot
    	{
			 get
			 {
				return this;
			 }
		}
    
		/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.IsReadOnly"]/*' />
		public bool IsReadOnly 
		{ 
			get
			{
				return false;
			}
		}

  
    	/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.IsSynchronized"]/*' />
    	public bool IsSynchronized
    	{ 
			get
			{
				return false;
			}
		}

		/// <include file='doc\BitArray.uex' path='docs/doc[@for="BitArray.GetEnumerator"]/*' />
		public IEnumerator GetEnumerator()
		{
			return new BitArrayEnumeratorSimple(this);
		}

		  // For a straightforward enumeration of the entire ArrayList, 
        // this is faster, because it's smaller.  Patrick showed
        // this with a benchmark.
        [Serializable()] private class BitArrayEnumeratorSimple : IEnumerator, ICloneable
        {
            private BitArray bitarray;
            private int index;
			private int version;
			private bool currentElement;
			   
            internal BitArrayEnumeratorSimple(BitArray bitarray) {
                this.bitarray = bitarray;
                this.index = -1;
				version = bitarray._version;
	        }

            public Object Clone() {
                return MemberwiseClone();
            }
                
			public virtual bool MoveNext() {
				if (version != bitarray._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                if (index < (bitarray.Count-1)) {
                    index++;
					currentElement = bitarray.Get(index);
					return true;
				}
				else
					index = bitarray.Count;
                
                return false;
            }
    
            public virtual Object Current {
                get {
                    if (index == -1)
                        throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
					if (index >= bitarray.Count)
                        throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded)); 
                    return currentElement;
                }
            }
    
            public void Reset() {
				if (version != bitarray._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                index = -1;
            }
        }
    
        private int[] m_array;
        private int m_length;
		private int _version;
    
        private const int _ShrinkThreshold = 256;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\__hresults.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//=============================================================================
//
// Class: __HResults
//
// Author: Automatically generated
//
// Purpose: Define HResult constants. Every exception has one of these.
//
// Date: 98/08/31 11:57:11 AM
//
//===========================================================================*/
namespace System {
    // Note: FACILITY_URT is defined as 0x13 (0x8013xxxx).  Within that
    // range, 0x1yyy is for Runtime errors (used for Security, Metadata, etc).
    // In that subrange, 0x15zz and 0x16zz have been allocated for classlib-type 
    // HResults. Also note that some of our HResults have to map to certain 
    // COM HR's, etc.
    
    // Another arbitrary decision...  Feel free to change this, as long as you
    // renumber the HResults yourself (and update rexcep.h).
    // Reflection will use 0x1600 -> 0x1620.  IO will use 0x1620 -> 0x1640.
    // Security will use 0x1640 -> 0x1660
    
    // There are __HResults files in the IO, Remoting, Reflection & 
    // Security/Util directories as well, so choose your HResults carefully.
    
    using System;
    internal sealed class __HResults
    {
       public const int E_FAIL = unchecked((int)0x80004005); 
       public const int E_POINTER = unchecked((int)0x80004003); 
       public const int E_NOTIMPL = unchecked((int)0x80004001); 
       public const int COR_E_AMBIGUOUSMATCH = unchecked((int)0x8000211D); 
       public const int COR_E_APPDOMAINUNLOADED = unchecked((int)0x80131014); 
       public const int COR_E_APPLICATION = unchecked((int)0x80131600); 
       public const int COR_E_ARGUMENT = unchecked((int)0x80070057); 
       public const int COR_E_ARGUMENTOUTOFRANGE = unchecked((int)0x80131502); 
       public const int COR_E_ARITHMETIC = unchecked((int)0x80070216); 
       public const int COR_E_ARRAYTYPEMISMATCH = unchecked((int)0x80131503);      
       public const int COR_E_BADIMAGEFORMAT = unchecked((int)0x8007000B);     
       public const int COR_E_TYPEUNLOADED = unchecked((int)0x80131013); 
       public const int COR_E_CANNOTUNLOADAPPDOMAIN = unchecked((int)0x80131015); 
       public const int COR_E_COMEMULATE = unchecked((int)0x80131535); 
       public const int COR_E_CONTEXTMARSHAL = unchecked((int)0x80131504); 
       public const int COR_E_CUSTOMATTRIBUTEFORMAT = unchecked((int)0x80131605); 
       public const int COR_E_DIVIDEBYZERO = unchecked((int)0x80020012); // DISP_E_DIVBYZERO
       public const int COR_E_DUPLICATEWAITOBJECT = unchecked((int)0x80131529);
       public const int COR_E_EXCEPTION = unchecked((int)0x80131500); 
       public const int COR_E_EXECUTIONENGINE = unchecked((int)0x80131506); 
       public const int COR_E_FIELDACCESS = unchecked((int)0x80131507); 
       public const int COR_E_FORMAT = unchecked((int)0x80131537); 
       public const int COR_E_INDEXOUTOFRANGE = unchecked((int)0x80131508); 
       public const int COR_E_INVALIDCAST = unchecked((int)0x80004002); 
       public const int COR_E_INVALIDCOMOBJECT = unchecked((int)0x80131527);
       public const int COR_E_INVALIDFILTERCRITERIA = unchecked((int)0x80131601); 
       public const int COR_E_INVALIDOLEVARIANTTYPE = unchecked((int)0x80131531);   
       public const int COR_E_INVALIDOPERATION = unchecked((int)0x80131509); 
       public const int COR_E_INVALIDPROGRAM = unchecked((int)0x8013153A); 
       public const int COR_E_MARSHALDIRECTIVE = unchecked((int)0x80131535); 
       public const int COR_E_MEMBERACCESS = unchecked((int)0x8013151A); 
       public const int COR_E_METHODACCESS = unchecked((int)0x80131510); 
       public const int COR_E_MISSINGFIELD = unchecked((int)0x80131511); 
       public const int COR_E_MISSINGMANIFESTRESOURCE = unchecked((int)0x80131532);
       public const int COR_E_MISSINGMEMBER = unchecked((int)0x80131512);
       public const int COR_E_MISSINGMETHOD = unchecked((int)0x80131513); 
       public const int COR_E_MULTICASTNOTSUPPORTED = unchecked((int)0x80131514); 
       public const int COR_E_NOTFINITENUMBER = unchecked((int)0x80131528);
       public const int COR_E_PLATFORMNOTSUPPORTED = unchecked((int)0x80131539); 
       public const int COR_E_NOTSUPPORTED = unchecked((int)0x80131515); 
       public const int COR_E_NULLREFERENCE = unchecked((int)0x80004003); 
       public const int COR_E_OUTOFMEMORY = unchecked((int)0x8007000E); 
       public const int COR_E_OVERFLOW = unchecked((int)0x80131516); 
       public const int COR_E_RANK = unchecked((int)0x80131517); 
       public const int COR_E_REFLECTIONTYPELOAD    = unchecked((int)0x80131602); 
       public const int COR_E_SAFEARRAYRANKMISMATCH = unchecked((int)0x80131538); 
       public const int COR_E_SAFEARRAYTYPEMISMATCH = unchecked((int)0x80131533); 
       public const int COR_E_SECURITY = unchecked((int)0x8013150A); 
       public const int COR_E_SERIALIZATION = unchecked((int)0x8013150C);
       public const int COR_E_STACKOVERFLOW = unchecked((int)0x800703E9); 
       public const int COR_E_SYNCHRONIZATIONLOCK = unchecked((int)0x80131518); 
       public const int COR_E_SYSTEM = unchecked((int)0x80131501); 
       public const int COR_E_TARGET = unchecked((int)0x80131603); 
       public const int COR_E_TARGETINVOCATION = unchecked((int)0x80131604); 
       public const int COR_E_TARGETPARAMCOUNT = unchecked((int)0x8002000e);
       public const int COR_E_THREADABORTED = unchecked((int)0x80131530); 
       public const int COR_E_THREADINTERRUPTED = unchecked((int)0x80131519); 
       public const int COR_E_THREADSTATE = unchecked((int)0x80131520); 
       public const int COR_E_THREADSTOP = unchecked((int)0x80131521); 
       public const int COR_E_TYPEINITIALIZATION = unchecked((int)0x80131534); 
       public const int COR_E_TYPELOAD = unchecked((int)0x80131522); 
       public const int COR_E_ENTRYPOINTNOTFOUND = unchecked((int)0x80131523); 
       public const int COR_E_DLLNOTFOUND = unchecked((int)0x80131524); 
       public const int COR_E_UNAUTHORIZEDACCESS = unchecked((int)0x80070005); 
       public const int COR_E_UNSUPPORTEDFORMAT = unchecked((int)0x80131523); 
       public const int COR_E_VERIFICATION = unchecked((int)0x8013150D); 
       public const int CORSEC_E_MIN_GRANT_FAIL = unchecked((int)0x80131417);
       public const int CORSEC_E_NO_EXEC_PERM = unchecked((int)0x80131418);
       public const int CORSEC_E_POLICY_EXCEPTION = unchecked((int)0x80131416);
       public const int CORSEC_E_XMLSYNTAX = unchecked((int)0x80131418);
       public const int NTE_FAIL = unchecked((int)0x80090020); 
       public const int CORSEC_E_CRYPTO = unchecked((int)0x80131430);
       public const int CORSEC_E_CRYPTO_UNEX_OPER = unchecked((int)0x80131431);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\caseinsensitivehashcodeprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: CaseInsensitiveHashCodeProvider
**
** Author: Jay Roxe, Rajesh Chandrashekaran
**
** Purpose: Designed to support hashtables which require 
** case-insensitive behavior while still maintaining case,
** this provides an efficient mechanism for getting the 
** hashcode of the string ignoring case.
**
** Date: February 13, 2000
**
============================================================*/
namespace System.Collections {
//This class does not contain members and does not need to be serializable
    using System;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\CaseInsensitiveHashCodeProvider.uex' path='docs/doc[@for="CaseInsensitiveHashCodeProvider"]/*' />
    [Serializable]
    public class CaseInsensitiveHashCodeProvider : IHashCodeProvider {
        private TextInfo m_text;
        private static CaseInsensitiveHashCodeProvider m_InvariantCaseInsensitiveHashCodeProvider = null;

        /// <include file='doc\CaseInsensitiveHashCodeProvider.uex' path='docs/doc[@for="CaseInsensitiveHashCodeProvider.CaseInsensitiveHashCodeProvider"]/*' />
        public CaseInsensitiveHashCodeProvider() {
            m_text = CultureInfo.CurrentCulture.TextInfo;
        }

        /// <include file='doc\CaseInsensitiveHashCodeProvider.uex' path='docs/doc[@for="CaseInsensitiveHashCodeProvider.CaseInsensitiveHashCodeProvider1"]/*' />
        public CaseInsensitiveHashCodeProvider(CultureInfo culture) {
            if (culture==null) {
                throw new ArgumentNullException("culture");
            }
            m_text = culture.TextInfo;
        }

        /// <include file='doc\CaseInsensitiveHashCodeProvider.uex' path='docs/doc[@for="CaseInsensitiveHashCodeProvider.Default"]/*' />
		public static CaseInsensitiveHashCodeProvider Default
		{
			get
			{
				return new CaseInsensitiveHashCodeProvider();
			}
		}
        
        /// <include file='doc\CaseInsensitiveHashCodeProvider.uex' path='docs/doc[@for="CaseInsensitiveHashCodeProvider.DefaultInvariant"]/*' />
      	public static CaseInsensitiveHashCodeProvider DefaultInvariant
		{ 
			get
			{
                if (m_InvariantCaseInsensitiveHashCodeProvider == null) {
				    m_InvariantCaseInsensitiveHashCodeProvider = new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture);
                }
                return m_InvariantCaseInsensitiveHashCodeProvider;
			}
		}

        /// <include file='doc\CaseInsensitiveHashCodeProvider.uex' path='docs/doc[@for="CaseInsensitiveHashCodeProvider.GetHashCode"]/*' />
        public int GetHashCode(Object obj) {
            if (obj==null) {
                throw new ArgumentNullException("obj");
            }

            String s = obj as String;
            if (s==null) {
                return obj.GetHashCode();
            }

            if (s.IsFastSort()) {
                return TextInfo.GetDefaultCaseInsensitiveHashCode(s);
            } else {
                return m_text.GetCaseInsensitiveHashCode(s);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\caseinsensitivecomparer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: CaseInsensitiveComparer
**
** Author: Rajesh Chandrashekaran
**
** Date: May 17, 2000
**
============================================================*/
namespace System.Collections {
//This class does not contain members and does not need to be serializable
    using System;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\CaseInsensitiveComparer.uex' path='docs/doc[@for="CaseInsensitiveComparer"]/*' />
    [Serializable]
    public class CaseInsensitiveComparer : IComparer {
        private CompareInfo m_compareInfo;
        private static CaseInsensitiveComparer m_InvariantCaseInsensitiveComparer;
        
        /// <include file='doc\CaseInsensitiveComparer.uex' path='docs/doc[@for="CaseInsensitiveComparer.CaseInsensitiveComparer"]/*' />
        public CaseInsensitiveComparer() {
            m_compareInfo = CultureInfo.CurrentCulture.CompareInfo;
        }

        /// <include file='doc\CaseInsensitiveComparer.uex' path='docs/doc[@for="CaseInsensitiveComparer.CaseInsensitiveComparer1"]/*' />
        public CaseInsensitiveComparer(CultureInfo culture) {
            if (culture==null) {
                throw new ArgumentNullException("culture");
            }
            m_compareInfo = culture.CompareInfo;
        }

		/// <include file='doc\CaseInsensitiveComparer.uex' path='docs/doc[@for="CaseInsensitiveComparer.Default"]/*' />
		public static CaseInsensitiveComparer Default
		{ 
			get
			{
				return new CaseInsensitiveComparer();
			}
		}
		
        /// <include file='doc\CaseInsensitiveComparer.uex' path='docs/doc[@for="CaseInsensitiveComparer.DefaultInvariant"]/*' />
      	public static CaseInsensitiveComparer DefaultInvariant
		{ 
			get
			{
                if (m_InvariantCaseInsensitiveComparer == null) {
				    m_InvariantCaseInsensitiveComparer = new CaseInsensitiveComparer(CultureInfo.InvariantCulture);
                }
                return m_InvariantCaseInsensitiveComparer;
			}
		}
	
		// Behaves exactly like Comparer.Default.Compare except that the comparision is case insensitive
    	// Compares two Objects by calling CompareTo.  If a == 
    	// b,0 is returned.  If a implements 
    	// IComparable, a.CompareTo(b) is returned.  If a 
    	// doesn't implement IComparable and b does, 
    	// -(b.CompareTo(a)) is returned, otherwise an 
    	// exception is thrown.
    	// 
		/// <include file='doc\CaseInsensitiveComparer.uex' path='docs/doc[@for="CaseInsensitiveComparer.Compare"]/*' />
		public int Compare(Object a, Object b) {
            String sa = a as String;
            String sb = b as String;
			if (sa != null && sb != null)
				return m_compareInfo.Compare(sa, sb, CompareOptions.IgnoreCase);
			else
				return Comparer.Default.Compare(a,b);
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\variant.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Variant
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The CLR implementation of Variant.
**
** Date:  September 28, 1998
** 
===========================================================*/
namespace System {

	using System;
	using System.Reflection;
	using System.Threading;
    using System.Runtime.InteropServices;
    using System.Globalization;
	using System.Runtime.CompilerServices;

    [Serializable()]
    [StructLayout(LayoutKind.Auto)]
    internal struct Variant {
    
        //Do Not change the order of these fields.  
        //They are mapped to the native VariantData * data structure.
        private int m_flags;
        private int m_data1;
        private int m_data2;
        private Object m_objref;
        

        // The following will call the internal routines to initalize the 
        //	native side of variant.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static void InitVariant();
        static Variant() {
            InitVariant();
        }

        private static Type _voidPtr = null;
        
        // The following bits have been taken up as follows
        // bits 0-15    - Type code
        // bit  16      - Array
        // bits 19-23   - Enums
        // bits 24-31   - Optional VT code (for roundtrip VT preservation)
        
        
        //What are the consequences of making this an enum?
        ///////////////////////////////////////////////////////////////////////
        // If you update this, update the corresponding stuff in OAVariantLib.cool,
        // COMOAVariant.cpp (2 tables, forwards and reverse), and perhaps OleVariant.h
        ///////////////////////////////////////////////////////////////////////
        internal const int CV_EMPTY=0x0;
        internal const int CV_VOID=0x1;
        internal const int CV_BOOLEAN=0x2;
        internal const int CV_CHAR=0x3;
        internal const int CV_I1=0x4;
        internal const int CV_U1=0x5;
        internal const int CV_I2=0x6;
        internal const int CV_U2=0x7;
        internal const int CV_I4=0x8;
        internal const int CV_U4=0x9;
        internal const int CV_I8=0xa;
        internal const int CV_U8=0xb;
        internal const int CV_R4=0xc;
        internal const int CV_R8=0xd;
        internal const int CV_STRING=0xe;
        internal const int CV_PTR=0xf;
        internal const int CV_DATETIME = 0x10;
        internal const int CV_TIMESPAN = 0x11;
        internal const int CV_OBJECT=0x12;
        internal const int CV_DECIMAL = 0x13;
        internal const int CV_CURRENCY = 0x14;
    	internal const int CV_ENUM=0x15;
        internal const int CV_MISSING=0x16;
        internal const int CV_NULL=0x17;
        internal const int CV_LAST=0x18;
    
        internal const int TypeCodeBitMask=0xffff;
        internal const int VTBitMask=unchecked((int)0xff000000);
        internal const int VTBitShift=24;
        internal const int ArrayBitMask	=0x10000;
    	
    	// Enum enum and Mask
    	internal const int EnumI1			=0x100000;
    	internal const int EnumU1			=0x200000;
    	internal const int EnumI2			=0x300000;
    	internal const int EnumU2			=0x400000;
    	internal const int EnumI4			=0x500000;
    	internal const int EnumU4			=0x600000;
    	internal const int EnumI8			=0x700000;
    	internal const int EnumU8			=0x800000;
    	internal const int EnumMask		=0xF00000;
          
    	internal static readonly Type [] ClassTypes = {
            typeof(System.Empty),
            typeof(void),
            typeof(Boolean),
            typeof(Char),
            typeof(SByte),
            typeof(Byte),
            typeof(Int16),
            typeof(UInt16),
            typeof(Int32),
            typeof(UInt32),
            typeof(Int64),
            typeof(UInt64),
            typeof(Single),
            typeof(Double),
            typeof(String),
            typeof(void),			// ptr for the moment
            typeof(DateTime),
            typeof(TimeSpan),
            typeof(Object),
            typeof(Decimal),
            typeof(Currency),
            typeof(Object),		// Treat enum as Object
            typeof(System.Reflection.Missing),
            typeof(System.DBNull),
        };
    
        internal static readonly Variant Empty = new Variant();
        internal static readonly Variant Missing = new Variant(Variant.CV_MISSING, Type.Missing, 0, 0);
        internal static readonly Variant DBNull = new Variant(Variant.CV_NULL, System.DBNull.Value, 0, 0);
    
        //
        // Native Methods
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern double GetR8FromVar();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern float  GetR4FromVar();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void   SetFieldsR4(float val);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void   SetFieldsR8(double val);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void SetFieldsObject(Object val);
    
    	// Use this function instead of an ECALL - saves about 150 clock cycles
    	// by avoiding the ecall transition and because the JIT inlines this.
    	// Ends up only taking about 1/8 the time of the ECALL version.
    	internal long GetI8FromVar()
    	{
    		return ((long)m_data2<<32 | ((long)m_data1 & 0xFFFFFFFFL));
    	}
    	
        //
        // Constructors
        //
    
        internal Variant(int flags, Object or, int data1, int data2) {
            m_flags = flags;
            m_objref=or;
            m_data1=data1;
            m_data2=data2;
        }
        
        public Variant(bool val) {
            m_objref= null;
            m_flags = CV_BOOLEAN;
            m_data1 = (val)?Boolean.True:Boolean.False;
            m_data2 = 0;
        }
    
    	[CLSCompliant(false)]
        public Variant(sbyte val) {
            m_objref=null;
            m_flags=CV_I1;
            m_data1=(int)val;
    		m_data2=(int)(((long)val)>>32);
    	}
    
    
        public Variant(byte val) {
            m_objref=null;
            m_flags=CV_U1;
            m_data1=(int)val;
            m_data2=0;
        }
        
        public Variant(short val) {
            m_objref=null;
            m_flags=CV_I2;
            m_data1=(int)val;
    		m_data2=(int)(((long)val)>>32);
        }
        
    	[CLSCompliant(false)]
        public Variant(ushort val) {
            m_objref=null;
            m_flags=CV_U2;
            m_data1=(int)val;
            m_data2=0;
        }
    	
    	public Variant(char val) {
            m_objref=null;
            m_flags=CV_CHAR;
            m_data1=(int)val;
            m_data2=0;
        }
    
        public Variant(int val) {
            m_objref=null;
            m_flags=CV_I4;
            m_data1=val;
    		m_data2=val >> 31;
        }
    	
    	[CLSCompliant(false)]
    	public Variant(uint val) {
            m_objref=null;
            m_flags=CV_U4;
            m_data1=(int)val;
    		m_data2=0;
        }
    	
    	public Variant(long val) {
            m_objref=null;
            m_flags=CV_I8;
    		m_data1 = (int)val;
    		m_data2 = (int)(val >> 32);
        }
    
    	[CLSCompliant(false)]
    	public Variant(ulong val) {
            m_objref=null;
            m_flags=CV_U8;
    		m_data1 = (int)val;
            m_data2 = (int)(val >> 32);
        }
    	
    	public Variant(float val) {
            m_objref=null;
            m_flags=CV_R4;
            m_data1=0;
            m_data2=0;
            SetFieldsR4(val);
        }
    
        public Variant(double val) {
            m_objref=null;
            m_flags=CV_R8;
            m_data1=0;
            m_data2=0;
            SetFieldsR8(val);
        }
    
        public Variant(DateTime val) {
            m_objref=null;
            m_flags=CV_DATETIME;
            ulong ticks = (ulong)val.Ticks;
            m_data1 = (int)ticks;
            m_data2 = (int)(ticks>>32);
        }
    
        public Variant(Currency val) {
            m_objref=null;
            m_flags=CV_CURRENCY;
            ulong temp = (ulong)val.m_value;
            m_data1 = (int)temp;
            m_data2 = (int)(temp>>32);
        }
    
        public Variant(Decimal val) {
            m_objref = (Object)val;
            m_flags = CV_DECIMAL;
            m_data1=0;
            m_data2=0;
        }
    
        public Variant(Object obj) {
            m_data1=0;
            m_data2=0;

            VarEnum vt = VarEnum.VT_EMPTY;
    
            if (obj is String) {
                m_flags=CV_STRING;
                m_objref=obj;
                return;
            }
			
			if (obj == null) {
				this = Empty;
				return;
			}
 			if (obj == System.DBNull.Value) {
				this = DBNull;
				return;
			}
 			if (obj == Type.Missing) {
				this = Missing;
				return;
			}
            
            if (obj is Array) {
                m_flags=CV_OBJECT | ArrayBitMask;
                m_objref=obj;
                return;
            }

            // Compiler appeasement
            m_flags = CV_EMPTY;
            m_objref = null;

            // Check to see if the object passed in is a wrapper object.
            if (obj is UnknownWrapper)
			{
                vt = VarEnum.VT_UNKNOWN;
                obj = ((UnknownWrapper)obj).WrappedObject;
			}
			else if (obj is DispatchWrapper)
			{
                vt = VarEnum.VT_DISPATCH;
                obj = ((DispatchWrapper)obj).WrappedObject;
			}
            else if (obj is ErrorWrapper)
			{
                vt = VarEnum.VT_ERROR;
                obj = (Object)(((ErrorWrapper)obj).ErrorCode);
                BCLDebug.Assert(obj != null, "obj != null");
			}			
			else if (obj is CurrencyWrapper)
			{
                vt = VarEnum.VT_CY;
                obj = (Object)(((CurrencyWrapper)obj).WrappedObject);
                BCLDebug.Assert(obj != null, "obj != null");
			}		

            if (obj != null)
            {
                SetFieldsObject(obj);
            }

			// If the object passed in is one of the wrappers then set the VARIANT type.
            if (vt != VarEnum.VT_EMPTY)
				m_flags |= ((int)vt << VTBitShift);
        }

		
    	[CLSCompliant(false)]
		unsafe public Variant(void* voidPointer,Type pointerType) {
    		if (pointerType == null)
    			throw new ArgumentNullException("pointerType");
    		if (!pointerType.IsPointer)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBePointer"),"pointerType");

			m_objref = pointerType;
    		m_flags=CV_PTR;
            m_data1=(int)voidPointer;
            m_data2=0;

		}
		
    	
    	// The Enum Constructors...
     	public Variant(byte val, Type enumType)
    	{
    		if (enumType == null)
    			throw new ArgumentNullException("enumType");
    		if (!enumType.IsEnum)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
    		enumType = enumType.UnderlyingSystemType;
    		if (!(enumType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    		
    		m_objref = enumType;
    		m_flags=CV_ENUM | EnumU1;
            m_data1=(int)val;
            m_data2=0;
    	}
    	
    	[CLSCompliant(false)]
     	public Variant(sbyte val, Type enumType)
    	{
    		if (enumType == null)
    			throw new ArgumentNullException("enumType");
    		if (!enumType.IsEnum)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
    		enumType = enumType.UnderlyingSystemType;
    		if (!(enumType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    			
    		m_objref = enumType;
    		m_flags=CV_ENUM | EnumI1;
            m_data1=(int)val;
    		m_data2=(int)(((long)val)>>32);
    	}
    	
     	public Variant(short val, Type enumType)
    	{
    		if (enumType == null)
    			throw new ArgumentNullException("enumType");
    		if (!enumType.IsEnum)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
    		enumType = enumType.UnderlyingSystemType;
    		if (!(enumType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    			
    		m_objref = enumType;
    		m_flags=CV_ENUM | EnumI2;
            m_data1=(int)val;
    		m_data2=(int)(((long)val)>>32);
    	}
    	
    	[CLSCompliant(false)]
     	public Variant(ushort val, Type enumType)
    	{
    		if (enumType == null)
    			throw new ArgumentNullException("enumType");
    		if (!enumType.IsEnum)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
    		enumType = enumType.UnderlyingSystemType;
    		if (!(enumType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    			
    		m_objref = enumType;
    		m_flags=CV_ENUM | EnumU2;
            m_data1=(int)val;
            m_data2=0;
    	}
    	
    	public Variant(int val, Type enumType)
    	{
    		if (enumType == null)
    			throw new ArgumentNullException("enumType");
    		if (!enumType.IsEnum)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
    		enumType = enumType.UnderlyingSystemType;
    		if (!(enumType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    			
    		m_objref = enumType;
    		m_flags=CV_ENUM | EnumI4;
    		m_data1=val;
    		m_data2=val >> 31;
    	}
    	
    	[CLSCompliant(false)]
    	public Variant(uint val, Type enumType)
    	{
    		if (enumType == null)
    			throw new ArgumentNullException("enumType");
    		if (!enumType.IsEnum)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
    		enumType = enumType.UnderlyingSystemType;
    		if (!(enumType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    			
    		m_objref = enumType;
    		m_flags=CV_ENUM | EnumU4;
    		m_data1=(int)val;
    		m_data2=0;
    	}
    	
    	public Variant(long val, Type enumType)
    	{
    		if (enumType == null)
    			throw new ArgumentNullException("enumType");
    		if (!enumType.IsEnum)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
    		enumType = enumType.UnderlyingSystemType;
    		if (!(enumType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    			
    		m_objref = enumType;
    		m_flags=CV_ENUM | EnumI8;
            m_data1=(int)val;
            m_data2=(int)(((long)val)>>32);
    	}
    	
    	[CLSCompliant(false)]
    	public Variant(ulong val, Type enumType)
    	{
    		if (enumType == null)
    			throw new ArgumentNullException("enumType");
    		if (!enumType.IsEnum)
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnum"),"enumType");
    		enumType = enumType.UnderlyingSystemType;
    		if (!(enumType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    			
    		m_objref = enumType;
    		m_flags=CV_ENUM | EnumU8;
    		m_data1 = (int)val;
    		m_data2 = (int)(val >> 32);
    	}
    	
    	// IsNullObjectReference will return true when the Variant is CV_OBJECT and contains
    	//	a null
        public  bool IsNullObjectReference {
    		get {
                return ((m_flags&TypeCodeBitMask) == CV_OBJECT && m_objref == null);
            }
    	}

    
        //
        // Variant Information Methods
        //
        public bool IsEmpty {
            get { return CVType == CV_EMPTY; }
        }

        public bool IsMissing {
            get { return CVType == CV_MISSING; }
        }

        public bool IsDBNull {
            get { return CVType == CV_NULL; }
        }


        public Type VariantType {
    		get {
    			//Console.WriteLine("VFlags:" + (m_flags&TypeCodeBitMask));
    			if ((m_flags&TypeCodeBitMask)==CV_OBJECT) {
    				return (m_objref != null) ? m_objref.GetType() : ClassTypes[CV_OBJECT];
    	        }
    			// For enums, the object will be a type.  We return that type.
    			if ((m_flags&TypeCodeBitMask)==CV_ENUM) {
    				return (Type) m_objref;
    			}
    		    return ClassTypes[m_flags&TypeCodeBitMask];
    		}
        }
    	
    
        //This is a family-only accessor for the CVType.
        //This is never to be exposed externally.
        internal int CVType {
            get {
                return (m_flags&TypeCodeBitMask);
            }
        }
    	internal int EnumType {
            get {
                return (m_flags&EnumMask);
            }
    	}

    	internal int MapEnumToCVType(int enumType)
    	{
    		switch (enumType) {
    		case EnumU1:
    			return CV_U1;
    		case EnumI1:
    			return CV_I1;
    		case EnumI2:
    			return CV_I2;
    		case EnumU2:
    			return CV_U2;
    		case EnumI4:
    			return CV_I4;
    		case EnumU4:
    			return CV_U4;
    		case EnumI8:
    			return CV_I8;
    		case EnumU8:
    			return CV_U8;
    		}
            throw new NotSupportedException(String.Format(Environment.GetResourceString("NotSupported_UnknownEnumType"), EnumType));
    	}
        
    
    	internal static int GetCVTypeFromClass(Type ctype) {
            int cvtype=-1;
    		if (ctype.IsEnum)
    			return CV_ENUM;
			if (ctype.IsPointer)
				return CV_PTR;
            for (int i=0; i<CV_LAST; i++) {
                if (ctype == ClassTypes[i]) {
                    cvtype=i;
                    break;
                }
            }
    
    		// Return -1 on failure - for the case where we ChangeType from
    		// CV_OBJECT into an unknown type that is a subclass of m_objref's
    		// type, we don't want an exception thrown here.
            return cvtype;
        }
    
        //
        // Conversion Methods
        //
        public bool ToBoolean() {
            switch (CVType) {
            case CV_BOOLEAN:
                return (m_data1!=0);
            case CV_I1:
            case CV_U1:
            case CV_I2:
    		case CV_U2:
            case CV_I4:
    		case CV_U4:
                return (m_data1!=0);
            case CV_I8:
    		case CV_U8:
                return (m_data1!=0 || m_data2!=0);
            case CV_STRING:
                return Boolean.Parse((String)m_objref);
            case CV_EMPTY:
                return false;
    		case CV_ENUM:
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Boolean"));
            }
        }
    
        public byte ToByte() {
    		int cvType = CVType;
    		if (cvType == CV_ENUM)
    			cvType = MapEnumToCVType(EnumType);
    		
            switch (cvType) {
            case CV_BOOLEAN:
            case CV_U1:
                return (byte)m_data1;
            case CV_I1:
            case CV_I2:
    		case CV_U2:
    		case CV_CHAR:
            case CV_I4:
                if (m_data1 < Byte.MinValue || m_data1 > Byte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
                return (byte)m_data1;
    		case CV_U4:
    			uint u4val = (uint) m_data1;
                if (u4val > Byte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
                return (byte)u4val;
            case CV_I8:
                long i8val = GetI8FromVar();
                if (i8val < Byte.MinValue || i8val > Byte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
                return (byte)i8val;
    		case CV_U8:
    			ulong u8val = (ulong) GetI8FromVar();
                if (u8val > Byte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
                return (byte)u8val;
            case CV_R4:
                float f = GetR4FromVar();
                if (f < Byte.MinValue || f > Byte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
                return (byte)f;
            case CV_R8:
                double d = GetR8FromVar();
                if (d < Byte.MinValue || d > Byte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Byte"));
                return (byte)d;
            case CV_STRING:
                return Byte.Parse((String)m_objref);
            case CV_EMPTY:
                return (byte)0;
            case CV_DECIMAL:
                return Decimal.ToByte((Decimal)m_objref);
            case CV_CURRENCY:
                return (byte)(new Currency(GetI8FromVar(), 0));
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Byte"));
            }
        }
    
    	[CLSCompliant(false)]
        public sbyte ToSByte() {
    		int cvType = CVType;
    		if (cvType == CV_ENUM)
    			cvType = MapEnumToCVType(EnumType);
    		
            switch (cvType) {
            case CV_BOOLEAN:
            case CV_I1:
                return (sbyte)m_data1;
            case CV_I2:
            case CV_I4:
                if (m_data1 < SByte.MinValue || m_data1 > SByte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
                return (sbyte)m_data1;
    		case CV_U8:
    			if (m_data2 != 0 || (uint) m_data1 > SByte.MaxValue)
    				throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
                return (sbyte)(uint)m_data1;
    		case CV_U1:
    		case CV_U2:
    		case CV_U4:
    		case CV_CHAR:
                if ((uint)m_data1 > SByte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
                return (sbyte)(uint)m_data1;
            case CV_I8:
                long i8 = GetI8FromVar();
                if (i8 < SByte.MinValue || i8 > SByte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
                return (sbyte)i8;
            case CV_R4:
                float f = GetR4FromVar();
                if (f < SByte.MinValue || f > SByte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
                return (sbyte)f;
            case CV_R8:
                double d = GetR8FromVar();
                if (d < SByte.MinValue || d > SByte.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_SByte"));
                return (sbyte)d;
            case CV_STRING:
                return SByte.Parse((String)m_objref);
            case CV_EMPTY:
                return (sbyte)0;
            case CV_DECIMAL:
                return Decimal.ToSByte((Decimal)m_objref);
            case CV_CURRENCY:
                return (sbyte) (new Currency(GetI8FromVar(), 0));
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "SByte"));
            }
        }
        
        public char ToChar() {
            switch (CVType) {
    		case CV_U1:
            case CV_CHAR:
    		case CV_U2:
                return (char)m_data1;
    		case CV_I1:
    		case CV_I2:
            case CV_I4:
                if (m_data1 < Char.MinValue || m_data1 > Char.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Char"));
                return (char)m_data1;
    		case CV_U4:
                if (m_data1 > Char.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Char"));
                return (char)m_data1;
            case CV_STRING:
                if (m_objref==null)
                    throw new InvalidCastException(Environment.GetResourceString("InvalidCast_VarToCharNullStr"));
    			int len = ((String)m_objref).Length;
    			if (len > 1)
    				throw new FormatException(Environment.GetResourceString(ResId.Format_NeedSingleChar));
    			else if (len==1)
                    return ((String)m_objref)[0];
    			else 
    				throw new FormatException(Environment.GetResourceString(ResId.Format_StringZeroLength));
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Char"));
            }
        }
    
        public short ToInt16() {
    		int cvType = CVType;
    		if (cvType == CV_ENUM)
    			cvType = MapEnumToCVType(EnumType);
    		
            switch (cvType) {
            case CV_BOOLEAN:
            case CV_I1:
            case CV_U1:
            case CV_I2:
                return (short)m_data1;
    		case CV_U2:
    		case CV_CHAR:
    			if ((ushort)m_data1 > Int16.MaxValue)
    				throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
    			return (short)(ushort) m_data1;
    		case CV_U4:
    			if ((uint)m_data1 > Int16.MaxValue)
    				throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
    			return (short)(uint) m_data1;
            case CV_I4:
                if (m_data1 < Int16.MinValue || m_data1 > Int16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
                return (short)m_data1;
            case CV_I8:
                long l = GetI8FromVar();
                if (l < Int16.MinValue || l > Int16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
                return (short)l;
            case CV_U8:
                ulong ul = (ulong)GetI8FromVar();
                if (ul > (ulong)Int16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
                return (short)ul;
            case CV_R4:
                float f = GetR4FromVar();
                if (f < Int16.MinValue || f > Int16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
                return (short)f;
            case CV_R8:
                double d = GetR8FromVar();
                if (d < Int16.MinValue || d > Int16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int16"));
                return (short)d;
            case CV_STRING:
                return Int16.Parse((String)m_objref);
            case CV_EMPTY:
                return (short)0;
            case CV_DECIMAL:
                return Decimal.ToInt16((Decimal)m_objref);
            case CV_CURRENCY:
                return (short)(new Currency(GetI8FromVar(), 0));
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Int16"));
            }
        }
    
    	[CLSCompliant(false)]
        public ushort ToUInt16() {
    		int cvType = CVType;
    		if (cvType == CV_ENUM)
    			cvType = MapEnumToCVType(EnumType);
    		
            switch (cvType) {
            case CV_BOOLEAN:
            case CV_I1:
            case CV_I2:
    			if (m_data1 < 0)
    				throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
                return (ushort)m_data1;
    		case CV_U1:
    		case CV_U2:
    		case CV_CHAR:
    			return (ushort) m_data1;
    		case CV_U4:
    			if ((uint)m_data1 > UInt16.MaxValue)
    				throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
    			return (ushort)m_data1;
            case CV_I4:
                if (m_data1 < UInt16.MinValue || m_data1 > UInt16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
                return (ushort)m_data1;
            case CV_I8:
                long l = GetI8FromVar();
                if (l < UInt16.MinValue || l > UInt16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
                return (ushort)l;
            case CV_U8:
                ulong ul = (ulong)GetI8FromVar();
                if (ul > UInt16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
                return (ushort)ul;
            case CV_R4:
                float f = GetR4FromVar();
                if (f < UInt16.MinValue || f > UInt16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
                return (ushort)f;
            case CV_R8:
                double d = GetR8FromVar();
                if (d < UInt16.MinValue || d > UInt16.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
                return (ushort)d;
            case CV_STRING:
                return UInt16.Parse((String)m_objref);
            case CV_EMPTY:
                return (ushort)0;
            case CV_DECIMAL:
    			return Decimal.ToUInt16((Decimal)m_objref);
            case CV_CURRENCY:
    			uint uic = Currency.ToUInt32(new Currency(GetI8FromVar(), 0));
    			if (uic > UInt16.MaxValue)
    				throw new OverflowException(Environment.GetResourceString("Overflow_UInt16"));
    			return (ushort)uic;
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "UInt16"));
            }
        }
    	
    	public int ToInt32() {
    		int cvType = CVType;
    		if (cvType == CV_ENUM)
    			cvType = MapEnumToCVType(EnumType);
    		
            switch (cvType) {
            case CV_BOOLEAN:
            case CV_I1:
            case CV_U1:
            case CV_CHAR:
            case CV_I2:
    		case CV_U2:
            case CV_I4:
                return m_data1;
    		case CV_U4:
    			if (m_data1 < 0)  // sign bit will be set if it's greater than Int32.MaxValue
    				throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
    			return m_data1;
            case CV_I8:
                long l = GetI8FromVar();
                if (l < Int32.MinValue || l > Int32.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
                return (int)l;
            case CV_U8:
    			// Don't have to worry about sign extension.  Keep numbers small & positive.
                if (m_data2 != 0 || m_data1 < 0)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
                return m_data1;
            case CV_R4:
                float f = GetR4FromVar();
    			// floats can't represent Int32.MaxValue (they do I4.Max + 1),
    			// so for max comparison, cast to a double to get around problem.
                if (f < Int32.MinValue || ((double)f) > ((double)Int32.MaxValue))
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
                return (int)f;
            case CV_R8:
                double d = GetR8FromVar();
                if (d < Int32.MinValue || d > Int32.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int32"));
                return (int)d;
            case CV_STRING:
                return Int32.Parse((String)m_objref);
            case CV_EMPTY:
                return 0;
            case CV_DECIMAL:
                return Decimal.ToInt32((Decimal) m_objref);
            case CV_CURRENCY:
                return Currency.ToInt32(new Currency(GetI8FromVar(), 0));
			case CV_PTR:
				return m_data1; 
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Int32"));
            }
        }
    	
    	[CLSCompliant(false)]
    	public uint ToUInt32() {
    		int cvType = CVType;
    		if (cvType == CV_ENUM)
    			cvType = MapEnumToCVType(EnumType);
    		
            switch (cvType) {
    		case CV_BOOLEAN:
            case CV_U1:
            case CV_CHAR:
    		case CV_U2:
            case CV_U4:
                return (uint) m_data1;
    		case CV_I1:
    		case CV_I2:
    		case CV_I4:
    			if (m_data1 < 0)
    				throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
    			return (uint) m_data1;
            case CV_I8:
                long l = GetI8FromVar();
                if (l < UInt32.MinValue || l > UInt32.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
                return (uint)l;
            case CV_U8:
    			// Don't have to worry about sign extension.
                if (m_data2 != 0)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
                return (uint)m_data1;
            case CV_R4:
                float f = GetR4FromVar();
    			// floats can't represent Int32.MaxValue (they do I4.Max + 1),
    			// so for max comparison, cast to a double to get around problem.
                if (f < UInt32.MinValue || ((double)f) > ((double)UInt32.MaxValue))
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
                return (uint)f;
            case CV_R8:
                double d = GetR8FromVar();
                if (d < UInt32.MinValue || d > UInt32.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt32"));
                return (uint)d;
            case CV_STRING:
                return UInt32.Parse((String)m_objref);
            case CV_EMPTY:
                return (uint)0;
            case CV_DECIMAL:
                return Decimal.ToUInt32((Decimal) m_objref);
            case CV_CURRENCY:
                return Currency.ToUInt32(new Currency(GetI8FromVar(), 0));
            case CV_PTR:
                return (uint) m_data1;
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "UInt32"));
            }
        }
    	
        public long ToInt64() {
    		int cvType = CVType;
    		if (cvType == CV_ENUM)
    			cvType = MapEnumToCVType(EnumType);
    		
            switch (cvType) {
            case CV_BOOLEAN:
            case CV_I1:
            case CV_U1:
            case CV_I2:
            case CV_I4:
                return (long)m_data1;
    		case CV_U2:
    		case CV_U4:
    			return (long)(uint)m_data1;
            case CV_I8:
                return GetI8FromVar();
            case CV_U8:
    			long l = GetI8FromVar();
    			// If sign bit is set, this was greater than Int64.MaxValue
    			if (l<0)
    				throw new OverflowException(Environment.GetResourceString("Overflow_Int64"));
    			return l;
            case CV_R4:
                float f = GetR4FromVar();
                if (f < (float) Int64.MinValue || f > (float) Int64.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int64"));
                return (long)f;
            case CV_R8:
                double d = GetR8FromVar();
                if (d < (double) Int64.MinValue || d > (double) Int64.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_Int64"));
                return (long)d;
            case CV_STRING:
                return Int64.Parse((String)m_objref);
            case CV_EMPTY:
                return 0;
            case CV_DECIMAL:
                return Decimal.ToInt64((Decimal)m_objref);
            case CV_CURRENCY:
                return Currency.ToInt64(new Currency(GetI8FromVar(), 0));
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Int64"));
            }
        }
        
    	[CLSCompliant(false)]
        public ulong ToUInt64() {
    		int cvType = CVType;
    		if (cvType == CV_ENUM)
    			cvType = MapEnumToCVType(EnumType);
    		
            switch (cvType) {
            case CV_BOOLEAN:
            case CV_I1:
            case CV_I2:
            case CV_I4:
    			if (m_data1 < 0)
    				throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
                return (ulong)m_data1;
            case CV_U1:
    		case CV_U2:
    		case CV_U4:
    			return (ulong)(uint)m_data1;
            case CV_I8:
    			long l = GetI8FromVar();
    			if (l < 0)
    				throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
                return (ulong) l;
            case CV_U8:
                return (ulong)GetI8FromVar();
            case CV_R4:
                float f = GetR4FromVar();
                if (f < (float) UInt64.MinValue || f > (float) UInt64.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
                return (ulong)f;
            case CV_R8:
                double d = GetR8FromVar();
                if (d < (double) UInt64.MinValue || d > (double) UInt64.MaxValue)
                    throw new OverflowException(Environment.GetResourceString("Overflow_UInt64"));
                return (ulong)d;
            case CV_STRING:
                return UInt64.Parse((String)m_objref);
            case CV_EMPTY:
                return (ulong)0;
            case CV_DECIMAL:
                return Decimal.ToUInt64((Decimal)m_objref);
            case CV_CURRENCY:
                return Currency.ToUInt64(new Currency(GetI8FromVar(), 0));
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_TIMESPAN:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "UInt64"));
            }
        }
    
    	public float ToSingle() {
            switch (CVType) {
            case CV_I1:
            case CV_U1:
            case CV_I2:
            case CV_I4:
                return (float)m_data1;
            case CV_U2:
            case CV_U4:
                return (float)(uint)m_data1;
            case CV_I8:
                return (float)GetI8FromVar();
            case CV_U8:
                return (float)(ulong)GetI8FromVar();
            case CV_R4:
                return GetR4FromVar();
            case CV_R8:
                double d = GetR8FromVar();
    			if (d < Single.MinValue || d > Single.MaxValue)
    				throw new OverflowException(Environment.GetResourceString("Overflow_Single"));
    			return (float)d;
            case CV_STRING:
                return Single.Parse((String)m_objref);
            case CV_EMPTY:
                return (float)0.0;
            case CV_DECIMAL:
                return Decimal.ToSingle((Decimal)m_objref);
            case CV_CURRENCY:
                return Currency.ToSingle(new Currency(GetI8FromVar(), 0));
            case CV_DATETIME:
            case CV_OBJECT:
            case CV_TIMESPAN:
    		case CV_ENUM:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Single"));
            }
        }
    
        public double ToDouble() {
            switch (CVType) {
            case CV_I1:
            case CV_U1:
            case CV_I2:
            case CV_I4:
                return (double)m_data1;
    		case CV_U2:
    		case CV_U4:
    			return (double)(uint)m_data1;
            case CV_I8:
                return (double)GetI8FromVar();
            case CV_U8:
                return (double)(ulong)GetI8FromVar();
            case CV_R4:
                return (double)GetR4FromVar();
            case CV_R8:
                return GetR8FromVar();
            case CV_STRING:
                return Double.Parse((String)m_objref);
            case CV_EMPTY:
                return 0.0;
            case CV_DECIMAL:
                return Decimal.ToDouble((Decimal)m_objref);
            case CV_CURRENCY:
                return Currency.ToDouble(new Currency(GetI8FromVar(), 0));
            case CV_DATETIME:
            case CV_TIMESPAN:
            case CV_OBJECT:
    		case CV_ENUM:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Double"));
            }
        }
    
        public override String ToString() {
            switch (CVType) {
            case CV_EMPTY:
                return System.Empty.Value.ToString();
            case CV_BOOLEAN:
                return ((m_data1!=0)?true:false).ToString();
            case CV_I1:
                return ((sbyte)m_data1).ToString();
            case CV_U1:
                return ((byte)m_data1).ToString();
            case CV_CHAR:
                return ((char)m_data1).ToString();
            case CV_I2:
                return ((short)m_data1).ToString();
            case CV_U2:
                return ((ushort)m_data1).ToString();
            case CV_I4:
                return (m_data1).ToString();
            case CV_U4:
                return ((uint)m_data1).ToString();
            case CV_I8:
                return (GetI8FromVar()).ToString();
            case CV_U8:
                return ((ulong)GetI8FromVar()).ToString();
            case CV_R4:
                return (GetR4FromVar()).ToString();
            case CV_R8:
                return (GetR8FromVar()).ToString();
            case CV_STRING:
                return (String)m_objref;
            case CV_MISSING:
            case CV_NULL:
            case CV_DECIMAL:
            case CV_OBJECT:
                if (m_objref==null) {
                    return String.Empty;
                }
                return m_objref.ToString();
            case CV_DATETIME:
                return new DateTime(GetI8FromVar()).ToString();
            case CV_TIMESPAN:
                return new TimeSpan(GetI8FromVar()).ToString();
            case CV_CURRENCY:
                return (new Currency(GetI8FromVar(), 0)).ToString();
    		case CV_ENUM:
    			return ((Enum)this.ToObject()).ToString();
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "String"));
            }
        }
    
        public DateTime ToDateTime() {
            switch (CVType) {
            case CV_DATETIME:
                // This is the correct thing to do, since DateTime is 
                // currently stored as an I8.
                return new DateTime(GetI8FromVar());
            case CV_STRING:
                return DateTime.Parse((String)m_objref, CultureInfo.InvariantCulture);
            case CV_EMPTY:
                return DateTime.MinValue;
            case CV_R8:
            case CV_U1:
            case CV_I1:
            case CV_I2:
            case CV_I4:
            case CV_I8:
            case CV_R4:
            case CV_BOOLEAN:
            case CV_CHAR:
            case CV_OBJECT:
            case CV_TIMESPAN:
            case CV_DECIMAL:
            case CV_CURRENCY:
    		case CV_ENUM:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "DateTime"));
            }
        }
    
        public TimeSpan ToTimeSpan() {
            switch (CVType) {
            case CV_TIMESPAN:
                return new TimeSpan(GetI8FromVar());
            case CV_STRING:
                return TimeSpan.Parse((String)m_objref);
            case CV_EMPTY:
                return TimeSpan.Zero;
            case CV_U1:
            case CV_I1:
            case CV_I2:
            case CV_I4:
            case CV_I8:
            case CV_BOOLEAN:
            case CV_R4:
            case CV_R8:
            case CV_CHAR:
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_DECIMAL:
            case CV_CURRENCY:
    		case CV_ENUM:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "TimeSpan"));
            }
        }
    
        public Decimal ToDecimal() {
            switch (CVType) {
            case CV_DECIMAL:
                return (Decimal) m_objref;
            case CV_R8:
                return new Decimal(GetR8FromVar());
            case CV_STRING:
                return Decimal.Parse((String)m_objref, CultureInfo.InvariantCulture);
            case CV_U1:
            case CV_I1:
            case CV_I2:
    		case CV_U2:
            case CV_I4:
                return new Decimal(m_data1);
    		case CV_U4:
                return new Decimal((uint)m_data1);
            case CV_I8:
                return new Decimal(GetI8FromVar());
    		case CV_U8:
    			return new Decimal((ulong)GetI8FromVar());
            case CV_R4:
                return new Decimal(GetR4FromVar());
    		case CV_CURRENCY:
    			return new Decimal(new Currency(GetI8FromVar(), 0));
            case CV_EMPTY:
                return new Decimal(0.0);
            case CV_CHAR:
            case CV_OBJECT:
    		case CV_ENUM:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Decimal"));
            }
        }
    
        public Currency ToCurrency() {
            switch (CVType) {
            case CV_CURRENCY:
                // Special constructor - it essentially casts the bits to a Currency
                return new Currency(GetI8FromVar(), 0);
            case CV_R8:
                return new Currency(GetR8FromVar());
            case CV_STRING:
                return Currency.FromString((String)m_objref);
            case CV_U1:
            case CV_I1:
            case CV_I2:
    		case CV_U2:
            case CV_I4:
    		case CV_U4:
                return new Currency(m_data1);
            case CV_I8:
                return new Currency(GetI8FromVar());
            case CV_U8:
                return new Currency((ulong)GetI8FromVar());
            case CV_R4:
                return new Currency(GetR4FromVar());
    		case CV_DECIMAL:
    			return Decimal.ToCurrency((Decimal)m_objref);
            case CV_EMPTY:
                return new Currency(0.0);
            case CV_CHAR:
            case CV_OBJECT:
    		case CV_ENUM:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Currency"));
            }
        }
    
        public Object ToObject() {
            switch (CVType) {
            case CV_EMPTY:
				return null;
            case CV_BOOLEAN:
                return (Object)(m_data1!=0);
            case CV_I1:
                return (Object)((sbyte)m_data1);
            case CV_U1:
                return (Object)((byte)m_data1);
            case CV_CHAR:
                return (Object)((char)m_data1);
            case CV_I2:
                return (Object)((short)m_data1);
            case CV_U2:
                return (Object)((ushort)m_data1);
            case CV_I4:
                return (Object)(m_data1);
            case CV_U4:
                return (Object)((uint)m_data1);
            case CV_I8:
                return (Object)(GetI8FromVar());
            case CV_U8:
                return (Object)((ulong)GetI8FromVar());
            case CV_R4:
                return (Object)(GetR4FromVar());
            case CV_R8:
                return (Object)(GetR8FromVar());
            case CV_DATETIME:
                return new DateTime(GetI8FromVar());
            case CV_TIMESPAN:
                return new TimeSpan(GetI8FromVar());
            case CV_CURRENCY:
                return new Currency(GetI8FromVar(), 0);
    		case CV_ENUM:
    			return BoxEnum();
            case CV_MISSING:
				return Type.Missing;
            case CV_NULL:
				return System.DBNull.Value;
            case CV_DECIMAL:
            case CV_STRING:
            case CV_OBJECT:
            default:
                return m_objref;
            }
        }
    
        unsafe public Variant ChangeType(Type ctype) {
    		if (ctype==null)
    			throw new ArgumentNullException("ctype", Environment.GetResourceString("ArgumentNull_Type"));
    		ctype = ctype.UnderlyingSystemType;
    		if (!(ctype is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
    		
            switch (GetCVTypeFromClass(ctype)) {
            case CV_BOOLEAN:
                return new Variant(ToBoolean());
            case CV_I1:
                return new Variant(ToSByte());
            case CV_U1:
                return new Variant(ToByte());
            case CV_CHAR:
                return new Variant(ToChar());
            case CV_I2:
                return new Variant(ToInt16());
            case CV_U2:
    			return new Variant(ToUInt16());
            case CV_I4:
                return new Variant(ToInt32());
            case CV_U4:
    			return new Variant(ToUInt32());
            case CV_I8:
                return new Variant(ToInt64());
            case CV_U8:
                return new Variant(ToUInt64());
            case CV_R4:
                return new Variant(ToSingle());
            case CV_R8:
                return new Variant(ToDouble());
            case CV_STRING:
                return new Variant(ToString());
            case CV_DATETIME:
                return new Variant(ToDateTime());
            case CV_TIMESPAN:
                return new Variant(ToTimeSpan());
            case CV_DECIMAL:
                return new Variant(ToDecimal());
            case CV_CURRENCY:
                return new Variant(ToCurrency());
    		case CV_ENUM:
    			return new Variant(ToInt64(),ctype);
            case CV_OBJECT:
                return new Variant(ToObject());
			case CV_PTR:
				if (CVType == CV_PTR) {
					if (_voidPtr == null)
                        _voidPtr = typeof(void*);
					if (ctype != m_objref &&
						ctype != _voidPtr)
						throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ((Type) m_objref).Name, "Pointer"));
				}
				return CreatePointer(ctype);

            default:
    			// Handle case where a Variant of type foo is created,
    			// and user passes in foo.class to ChangeType.
    			if (CVType == CV_OBJECT && ctype.IsInstanceOfType(m_objref))
    				return new Variant(m_objref);
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, ctype.Name));
            }
        }

		unsafe private Variant CreatePointer(Type t)
		{
			return new Variant(ToPointer(),t);
		}
    
        public override bool Equals(Object obj) {
    		int cvtype = CVType;
            if (obj==null) 
                return CVType == CV_OBJECT && m_objref==null;
    		
    		if (cvtype == CV_ENUM) {
    			if (obj.GetType() != m_objref)
    				return false;
    			cvtype = MapEnumToCVType(EnumType);
    		}
    		else 
    			if (cvtype!=CV_OBJECT && obj.GetType() != ClassTypes[cvtype])
    			    return false;
    		
            switch (cvtype) {
            case CV_BOOLEAN:
                // m_data1 != Boolean.False returns true or false as a boolean.
                // the cast from obj to boolean gives us two booleans, then it's
                // a simple == operator.
                return ((bool)obj)==(m_data1!=Boolean.False);
            case CV_I1:
                return ((sbyte)m_data1==(SByte)obj);
            case CV_U1:
                return ((byte)m_data1==(Byte)obj);
            case CV_CHAR:
                return (char)m_data1==(Char)obj;
            case CV_I2:
                return ((short)m_data1==(Int16)obj);
            case CV_U2:
                return ((ushort)m_data1==(UInt16)obj);
            case CV_I4:
                return (m_data1==(int)obj);
            case CV_U4:
                return ((uint)m_data1==(UInt32)obj);
            case CV_I8:
                long l = (long) obj;
                return l == GetI8FromVar();
            case CV_U8:
                ulong ul = (ulong) obj;
                return ul == (ulong)GetI8FromVar();
            case CV_DATETIME:
                return ((DateTime)obj).Equals(new DateTime(GetI8FromVar()));
            case CV_TIMESPAN:
                return ((TimeSpan)obj).Equals(new TimeSpan(GetI8FromVar()));
            case CV_CURRENCY:
                return ((Currency)obj).Equals(new Currency(GetI8FromVar(), 0));
            case CV_R4:
                return ((float)obj==GetR4FromVar());
            case CV_R8:
                return ((double)obj==GetR8FromVar());
            case CV_STRING:
            case CV_DECIMAL:
            case CV_OBJECT:
                // If we have a null objref, it is equal to another object
                // iff the other object is null.
                if (m_objref==null)
                    return (obj==null);
                return m_objref.Equals(obj);
            case CV_EMPTY:
            case CV_MISSING:
                // Missing is a "flag" Variant that can't be directly instantiated.
                // Therefore two missings are always equal.
                return true;
            case CV_NULL:
                // Spec now says database NULL's never equal one another.
                return false;
            default:
                return false;
            }
        }
    	
        public bool Equals(Variant v) {
    		int cvtype = CVType;
    		if (cvtype == CV_ENUM) {
    			if (v.CVType != CV_ENUM || v.m_objref != m_objref)
    				return false;
    			cvtype = MapEnumToCVType(EnumType);
    		}
    		else {
    
    			if (v.CVType != cvtype) {
    			    return false;
    			}
    		}
    
            switch (cvtype) {
            case CV_BOOLEAN:
                return m_data1==v.m_data1;
            case CV_I1:
    		case CV_U1:
                return ((byte)m_data1==(byte)v.m_data1);
            case CV_I2:
    		case CV_U2:
    		case CV_CHAR:
                return ((short)m_data1==(short)v.m_data1);
            case CV_I4:
    		case CV_U4:
                return (m_data1==v.m_data1);
            case CV_I8:
    		case CV_U8:
            case CV_DATETIME:
            case CV_TIMESPAN:
            case CV_CURRENCY:
                // Bitwise equality is correct for all these types.
                return (m_data1==v.m_data1 && m_data2==v.m_data2);
            case CV_R4:
                // For R4 and R8, must compare as fp values to handle Not-a-Number.
                return GetR4FromVar()==v.GetR4FromVar();
            case CV_R8:
                // For R4 and R8, must compare as fp values to handle Not-a-Number.
                return GetR8FromVar()==v.GetR8FromVar();
            case CV_STRING:
            case CV_DECIMAL:
            case CV_OBJECT:
                // If we have a null objref, it is equal to another object
                // iff the other object is null.
                if (m_objref==null)
                    return (v.m_objref==null);
                return m_objref.Equals(v.m_objref);
            case CV_EMPTY:
            case CV_MISSING:
                // Missing is a "flag" Variant that can't be directly instantiated.
                // Therefore two missings are always equal.
                return true;
            case CV_NULL:
                // Spec now says database NULL's never equal one another.
                return false;
            default:
                return false;
            }
        }
    
    	public override int GetHashCode() {
            switch (CVType) {
            case CV_BOOLEAN:
            case CV_I1:
            case CV_U1:
            case CV_CHAR:
            case CV_I2:
    		case CV_U2:
            case CV_I4:
    		case CV_U4:
    		case CV_ENUM:
                return m_data1;
            case CV_I8:
    		case CV_U8:
                return m_data1 ^ m_data2;
            case CV_DATETIME:
                return (new DateTime(GetI8FromVar())).GetHashCode();
            case CV_TIMESPAN:
                return (new TimeSpan(GetI8FromVar())).GetHashCode();
            case CV_CURRENCY:
                return (new Currency(GetI8FromVar(), 0)).GetHashCode();
            case CV_R4:
                return m_data1;
            case CV_R8:
                return m_data1 ^ m_data2;
            case CV_STRING:
            case CV_DECIMAL:
            case CV_OBJECT:
                if (m_objref==null)
                    return 0;
                return m_objref.GetHashCode();
            case CV_EMPTY:
            case CV_MISSING:
            case CV_NULL:
                //Null and Missing are both "flag" Variants that can't be directly instantiated.
                return 0;
            default:
                return -1;
            }
        }

		// ToPointer.
        [CLSCompliant(false)]
		public unsafe void* ToPointer()
		{
            switch (CVType) {
            case CV_EMPTY:
				return (void*) 0;
			case CV_PTR:
				return (void*) m_data1;

            case CV_TIMESPAN:
            case CV_STRING:
            case CV_U1:
            case CV_I1:
            case CV_I2:
            case CV_I4:
            case CV_I8:
            case CV_BOOLEAN:
            case CV_R4:
            case CV_R8:
            case CV_CHAR:
            case CV_OBJECT:
            case CV_DATETIME:
            case CV_DECIMAL:
            case CV_CURRENCY:
    		case CV_ENUM:
            default:
                throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_FromTo"), ClassTypes[CVType].Name, "Pointer"));
            }
  		}
        	
		// Take a TypedByRef and convert it to a Variant
        [CLSCompliant(false)]
    	public static Variant TypedByRefToVariant(TypedReference byrefValue)
    	{
    		return InternalTypedByRefToVariant(byrefValue);
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern static Variant InternalTypedByRefToVariant(TypedReference byrefValue);
    	
		// Take a variant and attempt to assign it to the TypedByRef
		//	This may cause the type to be changed.
        [CLSCompliant(false)]
        public static void VariantToTypedByRef(TypedReference byrefValue,Variant v)
    	{
    		InternalVariantToTypedByRef(byrefValue,v);
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern static Variant InternalVariantToTypedByRef(TypedReference byrefValue,Variant v);
    	
    	
       /* private static bool operator equals(Variant v1, Variant v2)
        {
            return v1.Equals(v2);
        }*/

		public static bool operator ==(Variant v1, Variant v2)
        {
            return v1.Equals(v2);
        }

		public static bool operator !=(Variant v1, Variant v2)
        {
            return !(v1.Equals(v2));
        }
    	
		
        public static implicit operator Variant (bool value)
        {
            return new Variant (value);
        }
    
        public static implicit operator Variant (byte value)
        {
            return new Variant (value);
        }
    
    	[CLSCompliant(false)]
        public static implicit operator Variant(sbyte value)
        {
            return new Variant (value);
        }
    	
        public static implicit operator Variant(short value) 
        {
            return new Variant (value);
        }
    	
    	[CLSCompliant(false)]
        public static implicit operator Variant(ushort value) 
        {
            return new Variant (value);
        }
    
    	public static implicit operator Variant(char value) 
        {
            return new Variant (value);
        }
    	
        public static implicit operator Variant(int value)
        {
            return new Variant (value);
        }
    	
    	[CLSCompliant(false)]
        public static implicit operator Variant(uint value)
        {
            return new Variant (value);
        }
    
    	public static implicit operator Variant(long value) 
        {
            return new Variant (value);
        }
    	
    	[CLSCompliant(false)]
        public static implicit operator Variant(ulong value)
        {
            return new Variant (value);
        }
    
    	public static implicit operator Variant(float value) 
        {
            return new Variant (value);
        }
    	
        public static implicit operator Variant(double value) 
        {
            return new Variant (value);
        }
    	
        public static implicit operator Variant(String value) 
        {
            return new Variant (value);
        }
    	
        public static implicit operator Variant(DateTime value) 
        {
            return new Variant (value);
        }
    	
        public static implicit operator Variant(TimeSpan value) 
        {
            return new Variant (value);
        }
    	
        public static implicit operator Variant(Decimal value) 
        {
            return new Variant (value);
        }
    	
        public static implicit operator Variant(Currency value) 
        {
            return new Variant (value);
        }
    	
        public static explicit operator byte(Variant value) 
        {
            return value.ToByte();
        }
    	
        public static explicit operator bool(Variant value) 
        {
            return value.ToBoolean();
        }
    
    	[CLSCompliant(false)]
        public static explicit operator sbyte(Variant value) 
        {
            return value.ToSByte();
        }
    	
        public static explicit operator short(Variant value) 
        {
            return value.ToInt16();
        }
    	
    	[CLSCompliant(false)]
        public static explicit operator ushort(Variant value) 
        {
            return value.ToUInt16();
        }
    
    	public static explicit operator char(Variant value) 
        {
            return value.ToChar();
        }
    
        public static explicit operator int(Variant value) 
        {
            return value.ToInt32();
        }
    	
    	[CLSCompliant(false)]
        public static explicit operator uint(Variant value) 
        {
            return value.ToUInt32();
        }
    
    	public static explicit operator long(Variant value) 
        {
            return value.ToInt64();
        }
    	
    	[CLSCompliant(false)]
        public static explicit operator ulong(Variant value) 
        {
            return value.ToUInt64();
        }
    
        public static explicit operator float(Variant value) 
        {
            return value.ToSingle();
        }
    	
        public static explicit operator double(Variant value) 
        {
            return value.ToDouble();
        }
    	
        public static explicit operator DateTime(Variant value) 
        {
            return value.ToDateTime();
        }
    	
        public static explicit operator TimeSpan(Variant value) 
        {
            return value.ToTimeSpan();
        }
    	
        public static explicit operator Decimal(Variant value) 
        {
            return value.ToDecimal();
        }
    	
        public static explicit operator Currency(Variant value) 
        {
            return value.ToCurrency();
        }
    	
        public static explicit operator String(Variant value) 
        {
            return value.ToString();
        }
		
        
    	// This routine will return an boxed enum.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern Object BoxEnum();



        // Helper code for marshaling managed objects to VARIANT's (we use
        // managed variants as an intermediate type.
        internal static void MarshalHelperConvertObjectToVariant(Object o, ref Variant v)
        {
            IConvertible ic = System.Runtime.Remoting.RemotingServices.IsTransparentProxy(o) ? null : o as IConvertible;
            if (o == null)
            {
                v = Empty;
            }
            else if (ic == null)
            {
                // This path should eventually go away. But until
                // the work is done to have all of our wrapper types implement
                // IConvertible, this is a cheapo way to get the work done.
                v = new Variant(o);
            }
            else
            {
                IFormatProvider provider = CultureInfo.InvariantCulture;
                switch (ic.GetTypeCode())
                {
                    case TypeCode.Empty:
                        v = Empty;
                        break;

                    case TypeCode.Object:
                        v = new Variant((Object)o);
                        break;

                    case TypeCode.DBNull:
                        v = DBNull;
                        break;

                    case TypeCode.Boolean:
                        v = new Variant(ic.ToBoolean(provider));
                        break;

                    case TypeCode.Char:
                        v = new Variant(ic.ToChar(provider));
                        break;

                    case TypeCode.SByte:
                        v = new Variant(ic.ToSByte(provider));
                        break;

                    case TypeCode.Byte:
                        v = new Variant(ic.ToByte(provider));
                        break;

                    case TypeCode.Int16:
                        v = new Variant(ic.ToInt16(provider));
                        break;

                    case TypeCode.UInt16:
                        v = new Variant(ic.ToUInt16(provider));
                        break;

                    case TypeCode.Int32:
                        v = new Variant(ic.ToInt32(provider));
                        break;

                    case TypeCode.UInt32:
                        v = new Variant(ic.ToUInt32(provider));
                        break;

                    case TypeCode.Int64:
                        v = new Variant(ic.ToInt64(provider));
                        break;

                    case TypeCode.UInt64:
                        v = new Variant(ic.ToUInt64(provider));
                        break;

                    case TypeCode.Single:
                        v = new Variant(ic.ToSingle(provider));
                        break;

                    case TypeCode.Double:
                        v = new Variant(ic.ToDouble(provider));
                        break;

                    case TypeCode.Decimal:
                        v = new Variant(ic.ToDecimal(provider));
                        break;

                    case TypeCode.DateTime:
                        v = new Variant(ic.ToDateTime(provider));
                        break;

                    case TypeCode.String:
                        v = new Variant(ic.ToString(provider));
                        break;

                    default:
                        throw new NotSupportedException(String.Format(Environment.GetResourceString("NotSupported_UnknownTypeCode"), ic.GetTypeCode()));
                }
            }
        }

        // Helper code for marshaling VARIANTS to managed objects (we use
        // managed variants as an intermediate type.
        internal static Object MarshalHelperConvertVariantToObject(ref Variant v)
        {
            return v.ToObject();
        }

        // Helper code: on the back propagation path where a VT_BYREF VARIANT*
        // is marshaled to a "ref Object", we use this helper to force the
        // updated object back to the original type.
        internal static void MarshalHelperCastVariant(Object pValue, int vt, ref Variant v)
        {
            IConvertible iv = pValue as IConvertible;
            if (iv == null)
            {
				switch (vt)
				{
					case 9: /*VT_DISPATCH*/
						v = new Variant(new DispatchWrapper(pValue));
						break;

					case 12: /*VT_VARIANT*/
						v = new Variant(pValue);
						break;

					case 13: /*VT_UNKNOWN*/
						v = new Variant(new UnknownWrapper(pValue));
						break;

                    case 36: /*VT_RECORD*/
                        v = new Variant(pValue);
                        break;

					case 8: /*VT_BSTR*/
                        if (pValue == null)
                        {
                            v = new Variant(null);
                            v.m_flags = CV_STRING;
                        }
                        else
                        {
    						throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_CannotCoerceByRefVariant")));
                        }
                        break;

					default:
    					throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_CannotCoerceByRefVariant")));
				}
            }
			else
			{
				IFormatProvider provider = CultureInfo.InvariantCulture;
				switch (vt)
				{
					case 0: /*VT_EMPTY*/
						v = Empty;
						break;

					case 1: /*VT_NULL*/
						v = DBNull;
						break;

					case 2: /*VT_I2*/
						v = new Variant(iv.ToInt16(provider));
						break;

					case 3: /*VT_I4*/
						v = new Variant(iv.ToInt32(provider));
						break;

					case 4: /*VT_R4*/
						v = new Variant(iv.ToSingle(provider));
						break;

					case 5: /*VT_R8*/
						v = new Variant(iv.ToDouble(provider));
						break;

					case 6: /*VT_CY*/
						v = new Variant(new CurrencyWrapper(iv.ToDecimal(provider)));
						break;

					case 7: /*VT_DATE*/
						v = new Variant(iv.ToDateTime(provider));
						break;

					case 8: /*VT_BSTR*/
						v = new Variant(iv.ToString(provider));
						break;

					case 9: /*VT_DISPATCH*/
						v = new Variant(new DispatchWrapper((Object)iv));
						break;

					case 10: /*VT_ERROR*/
						v = new Variant(new ErrorWrapper(iv.ToInt32(provider)));
						break;

					case 11: /*VT_BOOL*/
						v = new Variant(iv.ToBoolean(provider));
						break;

					case 12: /*VT_VARIANT*/
						v = new Variant((Object)iv);
						break;

					case 13: /*VT_UNKNOWN*/
						v = new Variant(new UnknownWrapper((Object)iv));
						break;

					case 14: /*VT_DECIMAL*/
						v = new Variant(iv.ToDecimal(provider));
						break;

					// case 15: /*unused*/
					//  NOT SUPPORTED

					case 16: /*VT_I1*/
						v = new Variant(iv.ToSByte(provider));
						break;

					case 17: /*VT_UI1*/
						v = new Variant(iv.ToByte(provider));
						break;

					case 18: /*VT_UI2*/
						v = new Variant(iv.ToUInt16(provider));
						break;

					case 19: /*VT_UI4*/
						v = new Variant(iv.ToUInt32(provider));
						break;

					case 20: /*VT_I8*/
						v = new Variant(iv.ToInt64(provider));
						break;

					case 21: /*VT_UI8*/
						v = new Variant(iv.ToUInt64(provider));
						break;

					case 22: /*VT_INT*/
						v = new Variant(iv.ToInt32(provider));
						break;

					case 23: /*VT_UINT*/
						v = new Variant(iv.ToUInt32(provider));
						break;

					default:
    					throw new InvalidCastException(String.Format(Environment.GetResourceString("InvalidCast_CannotCoerceByRefVariant")));
				}
			}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\collectionbase.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

namespace System.Collections {
    using System;

    // Useful base class for typed read/write collections where items derive from object
    /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase"]/*' />
    [Serializable]
    public abstract class CollectionBase : IList {
        ArrayList list;

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.InnerList"]/*' />
        protected ArrayList InnerList { 
            get { 
                if (list == null)
                    list = new ArrayList();
                return list;
            }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.List"]/*' />
        protected IList List {
            get { return (IList)this; }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.Count"]/*' />
        public int Count {
            get {
				return list == null ? 0 : list.Count;
            }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.Clear"]/*' />
        public void Clear() {
            OnClear();
            InnerList.Clear();
            OnClearComplete();
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.RemoveAt"]/*' />
        public void RemoveAt(int index) {
            if (index < 0 || index >= InnerList.Count)
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_Index"));
            Object temp = InnerList[index];
            OnValidate(temp);
            OnRemove(index, temp);
            InnerList.RemoveAt(index);
            OnRemoveComplete(index, temp);
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.IList.IsReadOnly"]/*' />
        bool IList.IsReadOnly {
            get { return InnerList.IsReadOnly; }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.IList.IsFixedSize"]/*' />
        bool IList.IsFixedSize {
            get { return InnerList.IsFixedSize; }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.ICollection.IsSynchronized"]/*' />
        bool ICollection.IsSynchronized {
            get { return InnerList.IsSynchronized; }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.ICollection.SyncRoot"]/*' />
        Object ICollection.SyncRoot {
            get { return InnerList.SyncRoot; }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.ICollection.CopyTo"]/*' />
        void ICollection.CopyTo(Array array, int index) {
            InnerList.CopyTo(array, index);
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.IList.this"]/*' />
        Object IList.this[int index] {
            get { 
                if (index < 0 || index >= InnerList.Count)
                    throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_Index"));
                return InnerList[index]; 
            }
            set { 
                if (index < 0 || index >= InnerList.Count)
                    throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_Index"));
                OnValidate(value);
                Object temp = InnerList[index];
                OnSet(index, temp, value); 
                InnerList[index] = value; 
                try {
                    OnSetComplete(index, temp, value);
                }
                catch (Exception) {
                    InnerList[index] = temp; 
                    throw;
                }
            }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.IList.Contains"]/*' />
        bool IList.Contains(Object value) {
            return InnerList.Contains(value);
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.IList.Add"]/*' />
        int IList.Add(Object value) {
            OnValidate(value);
            OnInsert(InnerList.Count, value);
            int index = InnerList.Add(value);
            try {
                OnInsertComplete(index, value);
            }
            catch (Exception) {
                InnerList.RemoveAt(index);
                throw;
            }
            return index;
        }

       
        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.IList.Remove"]/*' />
        void IList.Remove(Object value) {
            OnValidate(value);
            int index = InnerList.IndexOf(value);
            if (index < 0) throw new ArgumentException(Environment.GetResourceString("Arg_RemoveArgNotFound"));
            OnRemove(index, value);
            InnerList.RemoveAt(index);
            OnRemoveComplete(index, value);
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.IList.IndexOf"]/*' />
        int IList.IndexOf(Object value) {
            return InnerList.IndexOf(value);
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.IList.Insert"]/*' />
        void IList.Insert(int index, Object value) {
            if (index < 0 || index > InnerList.Count)
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_Index"));
            OnValidate(value);
            OnInsert(index, value);
            InnerList.Insert(index, value);
            try {
                OnInsertComplete(index, value);
            }
            catch (Exception) {
                InnerList.RemoveAt(index);
                throw;
            }
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return InnerList.GetEnumerator();
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnSet"]/*' />
        protected virtual void OnSet(int index, Object oldValue, Object newValue) { 
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnInsert"]/*' />
        protected virtual void OnInsert(int index, Object value) { 
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnClear"]/*' />
        protected virtual void OnClear() { 
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnRemove"]/*' />
        protected virtual void OnRemove(int index, Object value) { 
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnValidate"]/*' />
        protected virtual void OnValidate(Object value) { 
            if (value == null) throw new ArgumentNullException("value");
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnSetComplete"]/*' />
        protected virtual void OnSetComplete(int index, Object oldValue, Object newValue) { 
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnInsertComplete"]/*' />
        protected virtual void OnInsertComplete(int index, Object value) { 
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnClearComplete"]/*' />
        protected virtual void OnClearComplete() { 
        }

        /// <include file='doc\CollectionBase.uex' path='docs/doc[@for="CollectionBase.OnRemoveComplete"]/*' />
        protected virtual void OnRemoveComplete(int index, Object value) { 
        }
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\comparer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Comparer
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Default IComparer implementation.
**
** Date:  October 9, 1999
** 
===========================================================*/
namespace System.Collections {
    
	using System;
    using System.Globalization;
    /// <include file='doc\Comparer.uex' path='docs/doc[@for="Comparer"]/*' />
    [Serializable]
    public sealed class Comparer : IComparer
    {
        private CompareInfo m_compareInfo;   
        /// <include file='doc\Comparer.uex' path='docs/doc[@for="Comparer.Default"]/*' />
        public static readonly Comparer Default = new Comparer();
        /// <include file='doc\Comparer.uex' path='docs/doc[@for="Comparer.DefaultInvariant"]/*' />
        public static readonly Comparer DefaultInvariant = new Comparer(CultureInfo.InvariantCulture);
    
        private Comparer() {
            m_compareInfo = null;
        }

        /// <include file='doc\Comparer.uex' path='docs/doc[@for="Comparer.Comparer1"]/*' />
        public Comparer(CultureInfo culture) {
            if (culture==null) {
                throw new ArgumentNullException("culture");
            }
            m_compareInfo = culture.CompareInfo;
        }
    
    	// Compares two Objects by calling CompareTo.  If a == 
    	// b,0 is returned.  If a implements 
    	// IComparable, a.CompareTo(b) is returned.  If a 
    	// doesn't implement IComparable and b does, 
    	// -(b.CompareTo(a)) is returned, otherwise an 
    	// exception is thrown.
    	// 
        /// <include file='doc\Comparer.uex' path='docs/doc[@for="Comparer.Compare"]/*' />
        public int Compare(Object a, Object b) {
            if (a == b) return 0;
            if (a == null) return -1;
            if (b == null) return 1;
            if (m_compareInfo != null) {
                String sa = a as String;
                String sb = b as String;
			    if (sa != null && sb != null)
				    return m_compareInfo.Compare(sa, sb);
            }
            IComparable ia = a as IComparable;
    		if (ia != null)
    			return ia.CompareTo(b);
            IComparable ib = b as IComparable;
    		if (ib != null)
                return -ib.CompareTo(a);
    		throw new ArgumentException(Environment.GetResourceString("Argument_ImplementIComparable"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\idictionary.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IDictionary
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Base interface for all dictionarys.
**
** Date:  September 21, 1999
** 
===========================================================*/
namespace System.Collections {
	using System;

    // An IDictionary is a possibly unordered set of key-value pairs.
    // Keys can be any non-null object.  Values can be any object.
    // You can look up a value in an IDictionary via the default indexed
    // property, Items.  
    /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary"]/*' />
    public interface IDictionary : ICollection
    {
        /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.this"]/*' />
	// Interfaces are not serializable
        // The Item property provides methods to read and edit entries 
        // in the Dictionary.
        Object this[Object key] {
            get;
            set;
        }
    
        // Returns a collections of the keys in this dictionary.
        /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.Keys"]/*' />
        ICollection Keys {
            get;
        }
    
        // Returns a collections of the values in this dictionary.
        /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.Values"]/*' />
        ICollection Values {
            get;
        }
    
        // Returns whether this dictionary contains a particular key.
        //
        /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.Contains"]/*' />
        bool Contains(Object key);
    
        // Adds a key-value pair to the dictionary.
        // 
        /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.Add"]/*' />
        void Add(Object key, Object value);
    
        // Removes all pairs from the dictionary.
        /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.Clear"]/*' />
        void Clear();
		/// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.IsReadOnly"]/*' />
    
		bool IsReadOnly 
        { get; }
	    /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.IsFixedSize"]/*' />

	    bool IsFixedSize
        { get; }

        // Returns an IDictionaryEnumerator for this dictionary.
        /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.GetEnumerator"]/*' />
        new IDictionaryEnumerator GetEnumerator();
    
        // Removes a particular key from the dictionary.
        //
        /// <include file='doc\IDictionary.uex' path='docs/doc[@for="IDictionary.Remove"]/*' />
        void Remove(Object key);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\icollection.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  ICollection
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Base interface for all collections.
**
** Date:  June 11, 1999
** 
===========================================================*/
namespace System.Collections {
    using System;

    // Base interface for all collections, defining enumerators, size, and 
    // synchronization methods.
    /// <include file='doc\ICollection.uex' path='docs/doc[@for="ICollection"]/*' />
    public interface ICollection : IEnumerable
    {
		// Interfaces are not serialable
    	// CopyTo copies a collection into an Array, starting at a particular
    	// index into the array.
    	// 
    	/// <include file='doc\ICollection.uex' path='docs/doc[@for="ICollection.CopyTo"]/*' />
    	void CopyTo(Array array, int index);
    	
    	// Number of items in the collections.
    	/// <include file='doc\ICollection.uex' path='docs/doc[@for="ICollection.Count"]/*' />
    	int Count
    	{ get; }
    	
    	
    	// SyncRoot will return an Object to use for synchronization (thread safety).  
    	// In the absense of a GetSynchronized() method on a collection, 
    	// the expected usage for SyncRoot would look like this:
    	// 
    	// 
    	// ICollection col = ...
    	// synchronized (col.SyncRoot) {
    	//     // Some operation on the collection, which is now thread safe.
    	// }
    	// 
    	// 
    	// The system-provided collections have a method called GetSynchronized()
    	// which will create a synchronized wrapper for the collection.  All access
    	// to the collection that you want to be thread-safe should go through that 
    	// wrapper collection.
    	// 
    	// For collections with no publically available underlying store, the expected
    	// implementation is to simply return this.  Note that the this
    	// pointer may not be sufficient for collections that wrap other collections;  
    	// those should return the underlying collection's SyncRoot property.
    	/// <include file='doc\ICollection.uex' path='docs/doc[@for="ICollection.SyncRoot"]/*' />
    	Object SyncRoot
    	{ get; }
            
    	// Is this collection synchronized (i.e., thread-safe)?  If you want a synchronized
    	// collection, you can use SyncRoot as an object to synchronize your collection with.
    	// If you're using one of the collections in System.Collections, you could call
    	// GetSynchronized() to get a synchronized wrapper around the underlying
    	// collection.
    	/// <include file='doc\ICollection.uex' path='docs/doc[@for="ICollection.IsSynchronized"]/*' />
    	bool IsSynchronized
    	{ get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\arraylist.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ArrayList
**
** Author: Rajesh Chandrashekaran (rajeshc)
**
** Purpose: Implements a dynamically sized List as an array,
**          and provides many convenience methods for treating
**          an array as an IList.
**
** Date:   October, 1999
** 
===========================================================*/
namespace System.Collections {
	using System;

    // Implements a variable-size List that uses an array of objects to store the
    // elements. A ArrayList has a capacity, which is the allocated length
    // of the internal array. As elements are added to a ArrayList, the capacity
    // of the ArrayList is automatically increased as required by reallocating the
    // internal array.
    // 
    // By Anders Hejlsberg
    // version 1.00 8/13/98
    /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList"]/*' />
    [Serializable()] public class ArrayList : IList, ICloneable
    {
        private Object[] _items;
        private int _size;
        private int _version;
    
        private const int _defaultCapacity = 16;
    
        // Note: this constructor is a bogus constructor that does nothing
        // and is for use only with SyncArrayList.
        internal ArrayList( bool trash )
        {
        }

        // Constructs a ArrayList. The list is initially empty and has a capacity
        // of zero. Upon adding the first element to the list the capacity is
        // increased to 16, and then increased in multiples of two as required.
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.ArrayList"]/*' />
        public ArrayList() {
            _items = new Object[_defaultCapacity];
        }
    
        // Constructs a ArrayList with a given initial capacity. The list is
        // initially empty, but will have room for the given number of elements
        // before any reallocations are required.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.ArrayList1"]/*' />
         public ArrayList(int capacity) {
            if (capacity < 0) throw new ArgumentOutOfRangeException("capacity", Environment.GetResourceString("ArgumentOutOfRange_SmallCapacity"));
    		_items = new Object[capacity];
        }
    
        // Constructs a ArrayList, copying the contents of the given collection. The
        // size and capacity of the new list will both be equal to the size of the
        // given collection.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.ArrayList2"]/*' />
        public ArrayList(ICollection c) {
    		if (c==null)
    			throw new ArgumentNullException("c", Environment.GetResourceString("ArgumentNull_Collection"));
            _items = new Object[c.Count];
            AddRange(c);
        }
    
        // Gets and sets the capacity of this list.  The capacity is the size of
        // the internal array used to hold items.  When set, the internal 
        // array of the list is reallocated to the given capacity.
        // 
    	 /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Capacity"]/*' />
    	 public virtual int Capacity {
    		get { return _items.Length; }
    		set {
    			if (value != _items.Length) {
    				if (value < _size) throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_SmallCapacity"));
    				if (value > 0) {
    					Object[] newItems = new Object[value];
    	                if (_size > 0) Array.Copy(_items, 0, newItems, 0, _size);
    		            _items = newItems;
    			    }
    				else {
    	                _items = new Object[_defaultCapacity];
    		        }
    			}
    		}
        }
    
        // Read-only property describing how many elements are in the List.
    	/// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Count"]/*' />
    	public virtual int Count {
    		get { return _size; }
    	}

		/// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.IsFixedSize"]/*' />
		public virtual bool IsFixedSize {
    		get { return false; }
    	}

		    
        // Is this ArrayList read-only?
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.IsReadOnly"]/*' />
        public virtual bool IsReadOnly {
            get { return false; }
        }

        // Is this ArrayList synchronized (thread-safe)?
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.IsSynchronized"]/*' />
        public virtual bool IsSynchronized {
            get { return false; }
        }
    
        // Synchronization root for this object.
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.SyncRoot"]/*' />
        public virtual Object SyncRoot {
            get { return this; }
        }
    
    	// Sets or Gets the element at the given index.
        // 
    	/// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.this"]/*' />
    	public virtual Object this[int index] {
    		get {
    			if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
    			return _items[index];
    		}
    		set {
    			if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
    			_items[index] = value;
    			_version++;
    		}
    	}
    
        // Creates a ArrayList wrapper for a particular IList.  This does not
        // copy the contents of the IList, but only wraps the ILIst.  So any
        // changes to the underlying list will affect the ArrayList.  This would
        // be useful if you want to Reverse a subrange of an IList, or want to
        // use a generic BinarySearch or Sort method without implementing one yourself.
        // However, since these methods are generic, the performance may not be
        // nearly as good for some operations as they would be on the IList itself.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Adapter"]/*' />
        public static ArrayList Adapter(IList list) {
            if (list==null)
                throw new ArgumentNullException("list");
            return new IListWrapper(list);
        }
    	
        // Adds the given object to the end of this list. The size of the list is
        // increased by one. If required, the capacity of the list is doubled
        // before adding the new element.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Add"]/*' />
        public virtual int Add(Object value) {
            if (_size == _items.Length) EnsureCapacity(_size + 1);
            _items[_size] = value;
            _version++;
            return _size++;
        }
    
        // Adds the elements of the given collection to the end of this list. If
        // required, the capacity of the list is increased to twice the previous
        // capacity or the new size, whichever is larger.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.AddRange"]/*' />
        public virtual void AddRange(ICollection c) {
            InsertRange(_size, c);
        }
    
        // Searches a section of the list for a given element using a binary search
        // algorithm. Elements of the list are compared to the search value using
        // the given IComparer interface. If comparer is null, elements of
        // the list are compared to the search value using the IComparable
        // interface, which in that case must be implemented by all elements of the
        // list and the given search value. This method assumes that the given
        // section of the list is already sorted; if this is not the case, the
        // result will be incorrect.
        //
        // The method returns the index of the given value in the list. If the
        // list does not contain the given value, the method returns a negative
        // integer. The bitwise complement operator (~) can be applied to a
        // negative result to produce the index of the first element (if any) that
        // is larger than the given search value. This is also the index at which
        // the search value should be inserted into the list in order for the list
        // to remain sorted.
        // 
        // The method uses the Array.BinarySearch method to perform the
        // search.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.BinarySearch"]/*' />
        public virtual int BinarySearch(int index, int count, Object value, IComparer comparer) {
    		if (index < 0 || count < 0)
    			throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (_size - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
    		return Array.BinarySearch(_items, index, count, value, comparer);
        }
    
		/// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.BinarySearch1"]/*' />
		public virtual int BinarySearch(Object value)
		{
			return BinarySearch(0,Count,value,null);
		}

		/// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.BinarySearch2"]/*' />
		public virtual int BinarySearch(Object value, IComparer comparer)
		{
			return BinarySearch(0,Count,value,comparer);
		}

	
        // Clears the contents of ArrayList.
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Clear"]/*' />
        public virtual void Clear() {
			Array.Clear(_items, 0, _size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references.
			_size = 0;
			_version++;
        }
    
        // Clones this ArrayList, doing a shallow copy.  (A copy is made of all
        // Object references in the ArrayList, but the Objects pointed to 
        // are not cloned).
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Clone"]/*' />
        public virtual Object Clone()
        {
            ArrayList la = new ArrayList(_size);
            la._size = _size;
            la._version = _version;
            Array.Copy(_items, 0, la._items, 0, _size);
            return la;
        }
    
    
        // Contains returns true if the specified element is in the ArrayList.
        // It does a linear, O(n) search.  Equality is determined by calling
        // item.Equals().
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Contains"]/*' />
        public virtual bool Contains(Object item) {
            if (item==null) {
                for(int i=0; i<_size; i++)
                    if (_items[i]==null)
                        return true;
                return false;
            }
            else {
                for(int i=0; i<_size; i++)
                    if (item.Equals(_items[i]))
                        return true;
                return false;
            }
        }
    
        // Copies this ArrayList into array, which must be of a 
        // compatible array type.  
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.CopyTo"]/*' />
        public virtual void CopyTo(Array array) {
            CopyTo(array, 0);
        }

        // Copies this ArrayList into array, which must be of a 
        // compatible array type.  
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.CopyTo1"]/*' />
        public virtual void CopyTo(Array array, int arrayIndex) {
            if ((array != null) && (array.Rank != 1))
                throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
    		// Delegate rest of error checking to Array.Copy.
            Array.Copy(_items, 0, array, arrayIndex, _size);
        }
    
        // Copies a section of this list to the given array at the given index.
        // 
        // The method uses the Array.Copy method to copy the elements.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.CopyTo2"]/*' />
        public virtual void CopyTo(int index, Array array, int arrayIndex, int count) {
            if (_size - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            if ((array != null) && (array.Rank != 1))
                throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
    		// Delegate rest of error checking to Array.Copy.
    		Array.Copy(_items, index, array, arrayIndex, count);
        }

        // Ensures that the capacity of this list is at least the given minimum
        // value. If the currect capacity of the list is less than min, the
        // capacity is increased to twice the current capacity or to min,
        // whichever is larger.
        private void EnsureCapacity(int min) {
            if (_items.Length < min) {
                int newCapacity = _items.Length == 0? 16: _items.Length * 2;
                if (newCapacity < min) newCapacity = min;
                Capacity = newCapacity;
            }
        }
    
        // Returns a list wrapper that is fixed at the current size.  Operations
        // that add or remove items will fail, however, replacing items is allowed.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.FixedSize"]/*' />
        public static IList FixedSize(IList list) {
            if (list==null)
                throw new ArgumentNullException("list");
            return new FixedSizeList(list);
        }

        // Returns a list wrapper that is fixed at the current size.  Operations
        // that add or remove items will fail, however, replacing items is allowed.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.FixedSize1"]/*' />
        public static ArrayList FixedSize(ArrayList list) {
            if (list==null)
                throw new ArgumentNullException("list");
            return new FixedSizeArrayList(list);
        }
    
        // Returns an enumerator for this list with the given
        // permission for removal of elements. If modifications made to the list 
        // while an enumeration is in progress, the MoveNext and 
        // GetObject methods of the enumerator will throw an exception.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.GetEnumerator"]/*' />
        public virtual IEnumerator GetEnumerator() {
    		return new ArrayListEnumeratorSimple(this);
        }
    
        // Returns an enumerator for a section of this list with the given
        // permission for removal of elements. If modifications made to the list 
        // while an enumeration is in progress, the MoveNext and 
        // GetObject methods of the enumerator will throw an exception.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.GetEnumerator1"]/*' />
        public virtual IEnumerator GetEnumerator(int index, int count) {
    		if (index < 0 || count < 0)
    			throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (_size - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
    		return new ArrayListEnumerator(this, index, count);
        }
    
        // Returns the index of the first occurrence of a given value in a range of
        // this list. The list is searched forwards from beginning to end.
        // The elements of the list are compared to the given value using the
        // Object.Equals method.
        // 
        // This method uses the Array.IndexOf method to perform the
        // search.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.IndexOf"]/*' />
        public virtual int IndexOf(Object value) {
            return Array.IndexOf(_items, value, 0, _size);
        }
    
        // Returns the index of the first occurrence of a given value in a range of
        // this list. The list is searched forwards, starting at index
        // startIndex and ending at count number of elements. The
        // elements of the list are compared to the given value using the
        // Object.Equals method.
        // 
        // This method uses the Array.IndexOf method to perform the
        // search.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.IndexOf1"]/*' />
        public virtual int IndexOf(Object value, int startIndex) {
    		if (startIndex > _size)
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            return Array.IndexOf(_items, value, startIndex, _size - startIndex);
        }

        // Returns the index of the first occurrence of a given value in a range of
        // this list. The list is searched forwards, starting at index
        // startIndex and upto count number of elements. The
        // elements of the list are compared to the given value using the
        // Object.Equals method.
        // 
        // This method uses the Array.IndexOf method to perform the
        // search.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.IndexOf2"]/*' />
        public virtual int IndexOf(Object value, int startIndex, int count) {
    		if (startIndex + count > _size) throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));
            return Array.IndexOf(_items, value, startIndex, count);
        }
    
        // Inserts an element into this list at a given index. The size of the list
        // is increased by one. If required, the capacity of the list is doubled
        // before inserting the new element.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Insert"]/*' />
        public virtual void Insert(int index, Object value) {
    		// Note that insertions at the end are legal.
            if (index < 0 || index > _size) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_ArrayListInsert"));
            if (_size == _items.Length) EnsureCapacity(_size + 1);
            if (index < _size) {
                Array.Copy(_items, index, _items, index + 1, _size - index);
            }
            _items[index] = value;
            _size++;
            _version++;
        }
    
        // Inserts the elements of the given collection at a given index. If
        // required, the capacity of the list is increased to twice the previous
        // capacity or the new size, whichever is larger.  Ranges may be added
        // to the end of the list by setting index to the ArrayList's size.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.InsertRange"]/*' />
        public virtual void InsertRange(int index, ICollection c) {
    		if (c==null)
    			throw new ArgumentNullException("c", Environment.GetResourceString("ArgumentNull_Collection"));
            if (index < 0 || index > _size) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            int count = c.Count;
            if (count > 0) {
                EnsureCapacity(_size + count);
                if (index < _size) {
                    Array.Copy(_items, index, _items, index + count, _size - index);
                }
    			// Hack hack hack
    			// If we're inserting a ArrayList into itself, we want to be able to deal with that.
    			if (this == c.SyncRoot) {
    				// Copy first part of _items to insert location
    				Array.Copy(_items, 0, _items, index, index);
    				// Copy last part of _items back to inserted location
    				Array.Copy(_items, index+count, _items, index*2, _size-index);
    			}
    			else
    				c.CopyTo(_items, index);
                _size += count;
                _version++;
            }
        }
    
        // Returns the index of the last occurrence of a given value in a range of
        // this list. The list is searched backwards, starting at the end 
        // and ending at the first element in the list. The elements of the list 
        // are compared to the given value using the Object.Equals method.
        // 
        // This method uses the Array.LastIndexOf method to perform the
        // search.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.LastIndexOf"]/*' />
        public virtual int LastIndexOf(Object value)
        {
            return LastIndexOf(value, _size - 1, _size);
        }

        // Returns the index of the last occurrence of a given value in a range of
        // this list. The list is searched backwards, starting at index
        // startIndex and ending at the first element in the list. The 
        // elements of the list are compared to the given value using the 
        // Object.Equals method.
        // 
        // This method uses the Array.LastIndexOf method to perform the
        // search.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.LastIndexOf1"]/*' />
        public virtual int LastIndexOf(Object value, int startIndex)
        {
    		if (startIndex >= _size)
                throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            return LastIndexOf(value, startIndex, startIndex + 1);
        }

        // Returns the index of the last occurrence of a given value in a range of
        // this list. The list is searched backwards, starting at index
        // startIndex and upto count elements. The elements of
        // the list are compared to the given value using the Object.Equals
        // method.
        // 
        // This method uses the Array.LastIndexOf method to perform the
        // search.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.LastIndexOf2"]/*' />
        public virtual int LastIndexOf(Object value, int startIndex, int count) {
			if (_size == 0)
				return -1;
    		if (startIndex < 0 || count < 0)
    			throw new ArgumentOutOfRangeException((startIndex<0 ? "startIndex" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (startIndex >= _size || count > startIndex + 1) 
    			throw new ArgumentOutOfRangeException((startIndex>=_size ? "startIndex" : "count"), Environment.GetResourceString("ArgumentOutOfRange_BiggerThanCollection"));
            return Array.LastIndexOf(_items, value, startIndex, count);
        }
    
        // Returns a read-only IList wrapper for the given IList.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.ReadOnly"]/*' />
        public static IList ReadOnly(IList list) {
            if (list==null)
                throw new ArgumentNullException("list");
            return new ReadOnlyList(list);
        }

        // Returns a read-only ArrayList wrapper for the given ArrayList.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.ReadOnly1"]/*' />
        public static ArrayList ReadOnly(ArrayList list) {
            if (list==null)
                throw new ArgumentNullException("list");
            return new ReadOnlyArrayList(list);
        }
    
        // Removes the element at the given index. The size of the list is
        // decreased by one.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Remove"]/*' />
        public virtual void Remove(Object obj) {
            int index = IndexOf(obj);
            BCLDebug.Correctness(index >= 0 || !(obj is Int32), "You passed an Int32 to Remove that wasn't in the ArrayList.\r\nDid you mean RemoveAt?  int: "+obj+"  Count: "+Count);
            if (index >=0) 
                RemoveAt(index);
        }
    
        // Removes the element at the given index. The size of the list is
        // decreased by one.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.RemoveAt"]/*' />
        public virtual void RemoveAt(int index) {
            if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            _size--;
            if (index < _size) {
                Array.Copy(_items, index + 1, _items, index, _size - index);
            }
            _items[_size] = null;
            _version++;
        }
    
        // Removes a range of elements from this list.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.RemoveRange"]/*' />
        public virtual void RemoveRange(int index, int count) {
    		if (index < 0 || count < 0)
    			throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (_size - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
    		if (count > 0) {
                int i = _size;
                _size -= count;
                if (index < _size) {
                    Array.Copy(_items, index + count, _items, index, _size - index);
                }
                while (i > _size) _items[--i] = null;
                _version++;
            }
        }
    
        // Returns an IList that contains count copies of value.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Repeat"]/*' />
        public static ArrayList Repeat(Object value, int count) {
            // @CONSIDER: If it turns out this is ABSOLUTELY performance critical
            // (instead of simply lame), we can write another inner class that 
            // implements IList and write a special enumerator for it, etc.
            // That's a reasonable amount of complexity though for what we think
            // will be a very rarely used method.

			if (count < 0)
				throw new ArgumentOutOfRangeException("count",Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));

            ArrayList list = new ArrayList((count>_defaultCapacity)?count:_defaultCapacity);
            for(int i=0; i<count; i++)
                list.Add(value);
            return list;
        }

        // Reverses the elements in this list.
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Reverse"]/*' />
        public virtual void Reverse() {
            Reverse(0, Count);
        }
    
        // Reverses the elements in a range of this list. Following a call to this
        // method, an element in the range given by index and count
        // which was previously located at index i will now be located at
        // index index + (index + count - i - 1).
        // 
        // This method uses the Array.Reverse method to reverse the
        // elements.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Reverse1"]/*' />
        public virtual void Reverse(int index, int count) {
    		if (index < 0 || count < 0)
    			throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (_size - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            Array.Reverse(_items, index, count);
			_version++;
        }
    
        // Sets the elements starting at the given index to the elements of the
        // given collection.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.SetRange"]/*' />
        public virtual void SetRange(int index, ICollection c) {
    		if (c==null) throw new ArgumentNullException("c", Environment.GetResourceString("ArgumentNull_Collection"));
            int count = c.Count;
            if (index < 0 || index > _size - count) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
    		
            if (count > 0) {
                c.CopyTo(_items, index);
                _version++;
            }
        }
    
		/// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.GetRange"]/*' />
		public virtual ArrayList GetRange(int index, int count) {
			if (index < 0 || count < 0)
				throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
			if (_size - index < count)
				throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
             return new Range(this,index, count);
        }

        // Sorts the elements in this list.  Uses the default comparer and 
        // Array.Sort.
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Sort"]/*' />
        public virtual void Sort()
        {
            Sort(0, Count, Comparer.Default);
        }

        // Sorts the elements in this list.  Uses Array.Sort with the
        // provided comparer.
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Sort1"]/*' />
        public virtual void Sort(IComparer comparer)
        {
            Sort(0, Count, comparer);
        }

        // Sorts the elements in a section of this list. The sort compares the
        // elements to each other using the given IComparer interface. If
        // comparer is null, the elements are compared to each other using
        // the IComparable interface, which in that case must be implemented by all
        // elements of the list.
        // 
        // This method uses the Array.Sort method to sort the elements.
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Sort2"]/*' />
        public virtual void Sort(int index, int count, IComparer comparer) {
    		if (index < 0 || count < 0)
    			throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (_size - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    		
            Array.Sort(_items, index, count, comparer);
			_version++;
        }
    
        // Returns a thread-safe wrapper around an IList.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Synchronized"]/*' />
        public static IList Synchronized(IList list) {
            if (list==null)
                throw new ArgumentNullException("list");
            return new SyncIList(list);
        }
    
        // Returns a thread-safe wrapper around a ArrayList.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.Synchronized1"]/*' />
        public static ArrayList Synchronized(ArrayList list) {
            if (list==null)
                throw new ArgumentNullException("list");
            return new SyncArrayList(list);
        }
    
        // ToArray returns a new Object array containing the contents of the ArrayList.
        // This requires copying the ArrayList, which is an O(n) operation.
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.ToArray"]/*' />
        public virtual Object[] ToArray() {
            Object[] array = new Object[_size];
            Array.Copy(_items, 0, array, 0, _size);
            return array;
        }
    
        // ToArray returns a new array of a particular type containing the contents 
        // of the ArrayList.  This requires copying the ArrayList and potentially
        // downcasting all elements.  This copy may fail and is an O(n) operation.
        // Internally, this implementation calls Array.Copy.
        //
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.ToArray1"]/*' />
        public virtual Array ToArray(Type type) {
            if (type==null)
                throw new ArgumentNullException("type");
            Array array = Array.CreateInstance(type, _size);
            Array.Copy(_items, 0, array, 0, _size);
            return array;
        }
    
        // Sets the capacity of this list to the size of the list. This method can
        // be used to minimize a list's memory overhead once it is known that no
        // new elements will be added to the list. To completely clear a list and
        // release all memory referenced by the list, execute the following
        // statements:
        // 
        // list.Clear();
        // list.TrimToSize();
        // 
        /// <include file='doc\ArrayList.uex' path='docs/doc[@for="ArrayList.TrimToSize"]/*' />
        public virtual void TrimToSize() {
            Capacity = _size;
        }
    
    
        // This class wraps an IList, exposing it as a ArrayList
        // Note this requires reimplementing half of ArrayList...
        [Serializable()]
        private class IListWrapper : ArrayList
        {
            private IList _list;
            
            internal IListWrapper(IList list) {
                _list = list;
            }
    
             public override int Capacity {
                get { return _list.Count; }
                set {
                    if (value < _list.Count) throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_SmallCapacity"));
                }
    		}
    
            public override int Count { 
    			get { return _list.Count; }
    		}
    
    		public override bool IsReadOnly { 
    			get { return _list.IsReadOnly; }
    		}

			public override bool IsFixedSize {
    			get { return _list.IsFixedSize; }
    		}

		
    		public override bool IsSynchronized { 
    			get { return _list.IsSynchronized; }
    		}
            
             public override Object this[int index] {
                get {
                    return _list[index];
                }
                set {
                    _list[index] = value;
                }
            }
    
            public override Object SyncRoot {
                get { return _list.SyncRoot; }
            }
            
            public override int Add(Object obj) {
                return _list.Add(obj);
            }
        
            public override void AddRange(ICollection c) {
                InsertRange(Count, c);
            }
    
			// Other overloads with automatically work
            public override int BinarySearch(int index, int count, Object value, IComparer comparer) 
            {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (_list.Count - index < count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				if (comparer == null)
					comparer = Comparer.Default;
                
                int lo = index;
                int hi = index + count - 1;
                int mid;
                while (lo <= hi) {
                    mid = (lo+hi)/2;
                    int r = comparer.Compare(value, _list[mid]);
                    if (r == 0)
                        return mid;
                    if (r < 0)
                        hi = mid-1;
                    else 
                        lo = mid+1;
                }
                // return bitwise complement of the first element greater than value.
                // Since hi is less than lo now, ~lo is the correct item.
                return ~lo;
            }
	
            public override void Clear() {
                _list.Clear();
            }
    
            public override Object Clone() {
                // This does not do a shallow copy of _list into a ArrayList!
                // This clones the IListWrapper, creating another wrapper class!
                return new IListWrapper(_list);
            }
    
            public override bool Contains(Object obj) {
                return _list.Contains(obj);
            }
    
            public override void CopyTo(Array array, int index) {
                _list.CopyTo(array, index);
            }
    
            public override void CopyTo(int index, Array array, int arrayIndex, int count) {
                if (array==null)
                    throw new ArgumentNullException("array");
                if (index < 0 || arrayIndex < 0)
                    throw new ArgumentOutOfRangeException((index < 0) ? "index" : "arrayIndex", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (array.Length - arrayIndex < count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
                if (_list.Count - index < count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
                if (array.Rank != 1)
                    throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
                
                for(int i=index; i<index+count; i++)
                    array.SetValue(_list[i], arrayIndex++);
            }
    
            public override IEnumerator GetEnumerator() {
                return _list.GetEnumerator();
            }
    
            public override IEnumerator GetEnumerator(int index, int count) {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (_list.Count - index < count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
                return new IListWrapperEnumWrapper(this, index, count);
            }
    
            public override int IndexOf(Object value) {
                return _list.IndexOf(value);
            }

			public override int IndexOf(Object value, int startIndex) {
                return IndexOf(value, startIndex, _list.Count - startIndex);
            }
    
            public override int IndexOf(Object value, int startIndex, int count) {
				if (startIndex < 0 || startIndex >= _list.Count) throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
                if (count < 0 || startIndex > _list.Count - count) throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));
    
				int endIndex = startIndex + count;
                if (value == null) {
                    for(int i=startIndex; i<endIndex; i++)
                        if (_list[i] == null)
                            return i;
                    return -1;
                } else {
                    for(int i=startIndex; i<endIndex; i++)
                        if (value.Equals(_list[i]))
                            return i;
                    return -1;
                }
			}
    
            public override void Insert(int index, Object obj) {
                _list.Insert(index, obj);
            }
    
            public override void InsertRange(int index, ICollection c) {
                if (c==null)
                    throw new ArgumentNullException("c", Environment.GetResourceString("ArgumentNull_Collection"));
                if (index < 0 || index > _list.Count) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));            
    
                IEnumerator en = c.GetEnumerator();
                while(en.MoveNext()) {
                    _list.Insert(index++, en.Current);
                }
            }
    
			public override int LastIndexOf(Object value) {
		         return LastIndexOf(value,_list.Count - 1, _list.Count);
            }

			public override int LastIndexOf(Object value, int startIndex) {
                return LastIndexOf(value, startIndex, startIndex + 1);
            }

            public override int LastIndexOf(Object value, int startIndex, int count) {
				if (_list.Count == 0)
					return -1;
   
				if (startIndex < 0 || startIndex >= _list.Count) throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
                if (count < 0 || count > startIndex + 1) throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));

				int endIndex = startIndex - count + 1;
                if (value == null) {
                    for(int i=startIndex; i >= endIndex; i--)
                        if (_list[i] == null)
                            return i;
                    return -1;
                } else {
                    for(int i=startIndex; i >= endIndex; i--)
                        if (value.Equals(_list[i]))
                            return i;
                    return -1;
                }
            }
    
            public override void Remove(Object value) {
                _list.Remove(value);
            }
    
            public override void RemoveAt(int index) {
                _list.RemoveAt(index);
            }
    
            public override void RemoveRange(int index, int count) {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (_list.Count - index < count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
                
                while(count > 0) {
                    _list.RemoveAt(index);
                    count--;
                }
            }
    
            public override void Reverse(int index, int count) {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (_list.Count - index < count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
				int i = index;
				int j = index + count - 1;
                while (i < j)
				{
                    Object tmp = _list[i];
                    _list[i++] = _list[j];
                    _list[j--] = tmp;
                }
            }
    
            public override void SetRange(int index, ICollection c) {
                if (c==null)
                    throw new ArgumentNullException("c", Environment.GetResourceString("ArgumentNull_Collection"));
                if (index < 0 || index >= _list.Count) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));            
                if (_list.Count - index < c.Count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
                IEnumerator en = c.GetEnumerator();
                while(en.MoveNext()) {
                    _list[index++] = en.Current;
                }
            }
    
			public override ArrayList GetRange(int index, int count) {
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (_list.Count - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				 return new Range(this,index, count);
			}

            public override void Sort(int index, int count, IComparer comparer) {
                if (index < 0 || count < 0)
                    throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (_list.Count - index < count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
                
                Object [] array = new Object[count];
                CopyTo(index, array, 0, count);
                Array.Sort(array, 0, count, comparer);
                for(int i=0; i<count; i++)
                    _list[i+index] = array[i];
            }


			public override Object[] ToArray() {
                Object[] array = new Object[Count];
				_list.CopyTo(array, 0);
				return array;
            }

			public override Array ToArray(Type type)
			{
				if (type==null)
					throw new ArgumentNullException("type");
				Array array = Array.CreateInstance(type, _list.Count);
				_list.CopyTo(array, 0);
				return array;
			}

			public override void TrimToSize()
			{
				// Can't really do much here...
			}
    
            // This is the enumerator for an IList that's been wrapped in another
            // class that implements all of ArrayList's methods.
            [Serializable()]
            private class IListWrapperEnumWrapper : IEnumerator, ICloneable
            {
                private IEnumerator _en;
                private int _remaining;
                private int _initialStartIndex;   // for reset
                private int _initialCount;        // for reset
                private bool _firstCall;       // firstCall to MoveNext
    
                private IListWrapperEnumWrapper()
                {
                }

                internal IListWrapperEnumWrapper(IListWrapper listWrapper, int startIndex, int count) 
                {
                    _en = listWrapper.GetEnumerator();
                    _initialStartIndex = startIndex;
                    _initialCount = count;
                    while(startIndex-- > 0 && _en.MoveNext());
                    _remaining = count;
                    _firstCall = true;
                }

                public virtual Object Clone() {
                    // We must clone the underlying enumerator, I think.
                    IListWrapperEnumWrapper clone = new IListWrapperEnumWrapper();
                    clone._en = (IEnumerator) ((ICloneable)_en).Clone();
                    clone._initialStartIndex = _initialStartIndex;
                    clone._initialCount = _initialCount;
                    clone._remaining = _remaining;
                    clone._firstCall = _firstCall;
                    return clone;
                }

                public virtual bool MoveNext() {
                    if (_firstCall) {
                        _firstCall = false;
                        return _remaining > 0 && _en.MoveNext();
                    }
                    if (_remaining < 0)
                        return false;
                    bool r = _en.MoveNext();
                    return r && _remaining-- > 0;
                }
                
                public virtual Object Current {
                    get {
                        if (_firstCall)
                            throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                        if (_remaining < 0)
                            throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                        return _en.Current;
                    }
                }
    
                public virtual void Reset() {
                    _en.Reset();
                    int startIndex = _initialStartIndex;
                    while(startIndex-- > 0 && _en.MoveNext());
                    _remaining = _initialCount;
                    _firstCall = true;
                }
            }
        }
    
    
        [Serializable()]
        private class SyncArrayList : ArrayList
        {
            private ArrayList _list;
            private Object _root;

            internal SyncArrayList(ArrayList list)
                : base( false )
            {
                _list = list;
                _root = list.SyncRoot;
            }
    
            public override int Capacity {
                get {
                    lock(_root) {
                        return _list.Capacity;
                    }
                }
                set {
                    lock(_root) {
                        _list.Capacity = value;
                    }
                }
            }
    
    		public override int Count { 
    			get { lock(_root) { return _list.Count; } }
    		}
    
    		public override bool IsReadOnly {
    			get { return _list.IsReadOnly; }
    		}

			public override bool IsFixedSize {
    			get { return _list.IsFixedSize; }
    		}

		            
    		public override bool IsSynchronized { 
    			get { return true; }
    		}
            
             public override Object this[int index] {
                get {
                    lock(_root) {
                        return _list[index];
                    }
                }
                set {
                    lock(_root) {
                        _list[index] = value;
                    }
                }
            }
    
            public override Object SyncRoot {
                get { return _root; }
            }
    
            public override int Add(Object value) {
                lock(_root) {
                    return _list.Add(value);
                }
            }
    
            public override void AddRange(ICollection c) {
                lock(_root) {
                    _list.AddRange(c);
                }
            }

			// Other base class overloads of BinarySearch will call into this override and do the locking
            public override int BinarySearch(int index, int count, Object value, IComparer comparer) {
                lock(_root) {
                    return _list.BinarySearch(index, count, value, comparer);
                }
            }

            public override void Clear() {
                lock(_root) {
                    _list.Clear();
                }
            }

			public override Object Clone() {
                lock(_root) {
                    return new SyncArrayList((ArrayList)_list.Clone());
                }
            }
    
            public override bool Contains(Object item) {
                lock(_root) {
                    return _list.Contains(item);
                }
            }
    
            public override void CopyTo(Array array, int index) {
                lock(_root) {
                    _list.CopyTo(array, index);
                }
            }
    
            public override void CopyTo(int index, Array array, int arrayIndex, int count) {
                lock(_root) {
                    _list.CopyTo(index, array, arrayIndex, count);
                }
            }
    
            public override IEnumerator GetEnumerator() {
                lock(_root) {
                    return _list.GetEnumerator();
                }
            }
    
            public override IEnumerator GetEnumerator(int index, int count) {
                lock(_root) {
                    return _list.GetEnumerator(index, count);
                }
            }
    
            public override int IndexOf(Object value) {
                lock(_root) {
                    return _list.IndexOf(value);
                }
            }

            public override int IndexOf(Object value, int startIndex) {
                lock(_root) {
                    return _list.IndexOf(value, startIndex);
                }
            }
    
            public override int IndexOf(Object value, int startIndex, int count) {
                lock(_root) {
                    return _list.IndexOf(value, startIndex, count);
                }
            }
    
            public override void Insert(int index, Object value) {
                lock(_root) {
                    _list.Insert(index, value);
                }
            }
    
            public override void InsertRange(int index, ICollection c) {
                lock(_root) {
                    _list.InsertRange(index, c);
                }
            }
    
            public override int LastIndexOf(Object value) {
                lock(_root) {
                    return _list.LastIndexOf(value);
                }
            }

            public override int LastIndexOf(Object value, int startIndex) {
                lock(_root) {
                    return _list.LastIndexOf(value, startIndex);
                }
            }

            public override int LastIndexOf(Object value, int startIndex, int count) {
                lock(_root) {
                    return _list.LastIndexOf(value, startIndex, count);
                }
            }
    
            public override void Remove(Object value) {
                lock(_root) {
                    _list.Remove(value);
                }
            }
    
            public override void RemoveAt(int index) {
                lock(_root) {
                    _list.RemoveAt(index);
                }
            }
    
            public override void RemoveRange(int index, int count) {
                lock(_root) {
                    _list.RemoveRange(index, count);
                }
            }
    
            public override void Reverse(int index, int count) {
                lock(_root) {
                    _list.Reverse(index, count);
                }
            }
    
            public override void SetRange(int index, ICollection c) {
                lock(_root) {
                    _list.SetRange(index, c);
                }
            }

			public override ArrayList GetRange(int index, int count) {
                lock(_root) {
                    return _list.GetRange(index, count);
                }
            }
    
            public override void Sort(int index, int count, IComparer comparer) {
                lock(_root) {
                    _list.Sort(index, count, comparer);
                }
            }
    
            public override Object[] ToArray() {
                lock(_root) {
                    return _list.ToArray();
                }
            }
    
            public override Array ToArray(Type type) {
                lock(_root) {
                    return _list.ToArray(type);
                }
            }
    
            public override void TrimToSize() {
                lock(_root) {
                    _list.TrimToSize();
                }
            }
        }
    
    
        [Serializable()]
        private class SyncIList : IList
        {
            private IList _list;
            private Object _root;
    
            internal SyncIList(IList list) {
                _list = list;
                _root = list.SyncRoot;
            }
    
    		public virtual int Count { 
    			get { lock(_root) { return _list.Count; } }
    		}
    
    		public virtual bool IsReadOnly {
    			get { return _list.IsReadOnly; }
    		}

			public virtual bool IsFixedSize {
    			get { return _list.IsFixedSize; }
    		}

			
    		public virtual bool IsSynchronized { 
    			get { return true; }
    		}
            
             public virtual Object this[int index] {
                get {
                    lock(_root) {
                        return _list[index];
                    }
                }
                set {
                    lock(_root) {
                        _list[index] = value;
                    }
                }
            }
    
            public virtual Object SyncRoot {
                get { return _root; }
            }
    
            public virtual int Add(Object value) {
                lock(_root) {
                    return _list.Add(value);
                }
            }
			     
    
            public virtual void Clear() {
                lock(_root) {
                    _list.Clear();
                }
            }
    
            public virtual bool Contains(Object item) {
                lock(_root) {
                    return _list.Contains(item);
                }
            }
    
            public virtual void CopyTo(Array array, int index) {
                lock(_root) {
                    _list.CopyTo(array, index);
                }
            }
    
            public virtual IEnumerator GetEnumerator() {
                lock(_root) {
                    return _list.GetEnumerator();
                }
            }
    
            public virtual int IndexOf(Object value) {
                lock(_root) {
                    return _list.IndexOf(value);
                }
            }
    
            public virtual void Insert(int index, Object value) {
                lock(_root) {
                    _list.Insert(index, value);
                }
            }
    
            public virtual void Remove(Object value) {
                lock(_root) {
                    _list.Remove(value);
                }
            }
    
            public virtual void RemoveAt(int index) {
                lock(_root) {
                    _list.RemoveAt(index);
                }
            }
        }
    
        [Serializable()] private class FixedSizeList : IList
        {
            private IList _list;
    
            internal FixedSizeList(IList l) {
                _list = l;
            }
    
            public virtual int Count { 
    			get { return _list.Count; }
    		}
    
    		public virtual bool IsReadOnly {
    			get { return _list.IsReadOnly; }
    		}

			public virtual bool IsFixedSize {
    			get { return true; }
    		}

	   		public virtual bool IsSynchronized { 
    			get { return _list.IsSynchronized; }
    		}
            
             public virtual Object this[int index] {
                get {
                    return _list[index];
                }
                set {
                    _list[index] = value;
                }
            }
    
            public virtual Object SyncRoot {
                get { return _list.SyncRoot; }
            }
            
            public virtual int Add(Object obj) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
            public virtual void Clear() {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
            public virtual bool Contains(Object obj) {
                return _list.Contains(obj);
            }
    
            public virtual void CopyTo(Array array, int index) {
                _list.CopyTo(array, index);
            }
    
            public virtual IEnumerator GetEnumerator() {
                return _list.GetEnumerator();
            }
    
            public virtual int IndexOf(Object value) {
                return _list.IndexOf(value);
            }
    
            public virtual void Insert(int index, Object obj) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
            public virtual void Remove(Object value) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
            public virtual void RemoveAt(int index) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
        }

        [Serializable()] private class FixedSizeArrayList : ArrayList
        {
            private ArrayList _list;
    
            internal FixedSizeArrayList(ArrayList l) {
                _list = l;
            }
    
            public override int Count { 
    			get { return _list.Count; }
    		}
    
    		public override bool IsReadOnly {
    			get { return _list.IsReadOnly; }
    		}

			public override bool IsFixedSize {
    			get { return true; }
    		}

			public override bool IsSynchronized { 
    			get { return _list.IsSynchronized; }
    		}
            
             public override Object this[int index] {
                get {
                    return _list[index];
                }
                set {
                    _list[index] = value;
                }
            }
    
            public override Object SyncRoot {
                get { return _list.SyncRoot; }
            }
            
            public override int Add(Object obj) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
            public override void AddRange(ICollection c) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
            public override int BinarySearch(int index, int count, Object value, IComparer comparer) {
                return _list.BinarySearch(index, count, value, comparer);
            }

			public override int Capacity {
    			get { return _list.Capacity; }
    			set { throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection")); }
    		}

            public override void Clear() {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
			public override Object Clone() {
			    FixedSizeArrayList arrayList = new FixedSizeArrayList(_list);
				arrayList._list = (ArrayList)_list.Clone();
				return arrayList;
           	}

            public override bool Contains(Object obj) {
                return _list.Contains(obj);
            }
    
            public override void CopyTo(Array array, int index) {
                _list.CopyTo(array, index);
            }
    
            public override void CopyTo(int index, Array array, int arrayIndex, int count) {
                _list.CopyTo(index, array, arrayIndex, count);
            }

            public override IEnumerator GetEnumerator() {
                return _list.GetEnumerator();
            }
    
            public override IEnumerator GetEnumerator(int index, int count) {
                return _list.GetEnumerator(index, count);
            }

            public override int IndexOf(Object value) {
                return _list.IndexOf(value);
            }

            public override int IndexOf(Object value, int startIndex) {
                return _list.IndexOf(value, startIndex);
            }

            public override int IndexOf(Object value, int startIndex, int count) {
                return _list.IndexOf(value, startIndex, count);
            }
    
            public override void Insert(int index, Object obj) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
            public override void InsertRange(int index, ICollection c) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }

            public override int LastIndexOf(Object value) {
                return _list.LastIndexOf(value);
            }

            public override int LastIndexOf(Object value, int startIndex) {
                return _list.LastIndexOf(value, startIndex);
            }

            public override int LastIndexOf(Object value, int startIndex, int count) {
                return _list.LastIndexOf(value, startIndex, count);
            }

            public override void Remove(Object value) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
    
            public override void RemoveAt(int index) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }

            public override void RemoveRange(int index, int count) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }

            public override void SetRange(int index, ICollection c) {
                _list.SetRange(index, c);
            }

			public override ArrayList GetRange(int index, int count) {
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (Count - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
                 return new Range(this,index, count);
            }
    
			public override void Reverse(int index, int count) {
                _list.Reverse(index, count);
            }

            public override void Sort(int index, int count, IComparer comparer) {
                _list.Sort(index, count, comparer);
            }

            public override Object[] ToArray() {
                return _list.ToArray();
            }
    
            public override Array ToArray(Type type) {
                return _list.ToArray(type);
            }
    
            public override void TrimToSize() {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FixedSizeCollection"));
            }
        }
    
        [Serializable()] private class ReadOnlyList : IList
        {
            private IList _list;
    
            internal ReadOnlyList(IList l) {
                _list = l;
            }
    
            public virtual int Count { 
    			get { return _list.Count; }
    		}
    
    		public virtual bool IsReadOnly {
    			get { return true; }
    		}

			public virtual bool IsFixedSize {
    			get { return true; }
    		}

			public virtual bool IsSynchronized { 
    			get { return _list.IsSynchronized; }
    		}
            
             public virtual Object this[int index] {
                get {
                    return _list[index];
                }
                set {
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
                }
            }
    
            public virtual Object SyncRoot {
                get { return _list.SyncRoot; }
            }
            
            public virtual int Add(Object obj) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
    
            public virtual void Clear() {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
    
            public virtual bool Contains(Object obj) {
                return _list.Contains(obj);
            }
    
            public virtual void CopyTo(Array array, int index) {
                _list.CopyTo(array, index);
            }
    
            public virtual IEnumerator GetEnumerator() {
                return _list.GetEnumerator();
            }
    
            public virtual int IndexOf(Object value) {
                return _list.IndexOf(value);
            }
    
            public virtual void Insert(int index, Object obj) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }

            public virtual void Remove(Object value) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
    
            public virtual void RemoveAt(int index) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
        }

        [Serializable()] private class ReadOnlyArrayList : ArrayList
        {
            private ArrayList _list;
    
            internal ReadOnlyArrayList(ArrayList l) {
                _list = l;
            }
    
            public override int Count { 
    			get { return _list.Count; }
    		}
    
    		public override bool IsReadOnly {
    			get { return true; }
    		}

			public override bool IsFixedSize {
    			get { return true; }
    		}

			public override bool IsSynchronized { 
    			get { return _list.IsSynchronized; }
    		}
            
             public override Object this[int index] {
                get {
                    return _list[index];
                }
                set {
                    throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
                }
            }
    
            public override Object SyncRoot {
                get { return _list.SyncRoot; }
            }
            
            public override int Add(Object obj) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
    
            public override void AddRange(ICollection c) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
    
            public override int BinarySearch(int index, int count, Object value, IComparer comparer) {
                return _list.BinarySearch(index, count, value, comparer);
            }


			public override int Capacity {
    			get { return _list.Capacity; }
    			set { throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection")); }
    		}

            public override void Clear() {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }

			public override Object Clone() {
			    ReadOnlyArrayList arrayList = new ReadOnlyArrayList(_list);
				arrayList._list = (ArrayList)_list.Clone();
				return arrayList;
           	}
    
            public override bool Contains(Object obj) {
                return _list.Contains(obj);
            }
    
            public override void CopyTo(Array array, int index) {
                _list.CopyTo(array, index);
            }
    
            public override void CopyTo(int index, Array array, int arrayIndex, int count) {
                _list.CopyTo(index, array, arrayIndex, count);
            }

            public override IEnumerator GetEnumerator() {
                return _list.GetEnumerator();
            }
    
            public override IEnumerator GetEnumerator(int index, int count) {
                return _list.GetEnumerator(index, count);
            }

            public override int IndexOf(Object value) {
                return _list.IndexOf(value);
            }

            public override int IndexOf(Object value, int startIndex) {
                return _list.IndexOf(value, startIndex);
            }

            public override int IndexOf(Object value, int startIndex, int count) {
                return _list.IndexOf(value, startIndex, count);
            }
    
            public override void Insert(int index, Object obj) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
    
            public override void InsertRange(int index, ICollection c) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }

            public override int LastIndexOf(Object value) {
                return _list.LastIndexOf(value);
            }

            public override int LastIndexOf(Object value, int startIndex) {
                return _list.LastIndexOf(value, startIndex);
            }

            public override int LastIndexOf(Object value, int startIndex, int count) {
                return _list.LastIndexOf(value, startIndex, count);
            }

            public override void Remove(Object value) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
    
            public override void RemoveAt(int index) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }

            public override void RemoveRange(int index, int count) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }

            public override void SetRange(int index, ICollection c) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
    
			public override ArrayList GetRange(int index, int count) {
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (Count - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
                 return new Range(this,index, count);
            }

			public override void Reverse(int index, int count) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }

            public override void Sort(int index, int count, IComparer comparer) {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }

            public override Object[] ToArray() {
                return _list.ToArray();
            }
    
            public override Array ToArray(Type type) {
                return _list.ToArray(type);
            }
    
            public override void TrimToSize() {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_ReadOnlyCollection"));
            }
        }

    
        // Implements an enumerator for a ArrayList. The enumerator uses the
        // internal version number of the list to ensure that no modifications are
        // made to the list while an enumeration is in progress.
        [Serializable()] private class ArrayListEnumerator : IEnumerator, ICloneable
        {
            private ArrayList list;
            private int index;
            private int endIndex;       // Where to stop.
            private int version;
			private Object currentElement;
            private int startIndex;     // Save this for Reset.
    
            internal ArrayListEnumerator(ArrayList list, int index, int count) {
                this.list = list;
                this.index = index;
                endIndex = index + count;
                version = list._version;
                startIndex = index;
                currentElement = list;
            }

            public Object Clone() {
                return MemberwiseClone();
            }
    
            public virtual bool MoveNext() {
				if (version != list._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                if (index < endIndex) {
                    currentElement = list[index];
					index++;
                    return true;
				}
                else 
				{
					index = endIndex + 1;
					currentElement = list;
				}
				
                return false;
            }
    
            public virtual Object Current {
                get {
                    Object temp = currentElement; // Make sure we never return the internal list in a multi-threaded scenario
                    if (temp == list) {
                        if (index <= startIndex) 
                            throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                        else
	    			        throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                    }
                    return temp;
                }
            }
       
	        public virtual void Reset() {
                if (version != list._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                index = startIndex;
				currentElement = list;
            }
        }


		// Implementation of a generic list subrange. An instance of this class
		// is returned by the default implementation of List.GetRange.
		[Serializable()]private class Range: ArrayList
		{
			private ArrayList _baseList;
			private int _baseIndex;
			private int _baseSize;
			private int _baseVersion;
			
			internal Range(ArrayList list, int index, int count) {
				_baseList = list;
				_baseIndex = index;
				_baseSize = count;
				_baseVersion = list._version;
			}

			private void InternalUpdateRange()
			{
				if (_baseVersion != _baseList._version)
					throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_UnderlyingArrayListChanged"));
			}


			public override int Add(Object value) {
				InternalUpdateRange();
				_baseList.Insert(_baseIndex + _baseSize, value);
				_baseVersion++;
				return _baseSize++;
			}

			public override void AddRange(ICollection c) {
				InternalUpdateRange();
				_baseList.InsertRange(_baseIndex + _baseSize, c);
				_baseVersion++;
				_baseSize += c.Count;
			}

			// Other overloads with automatically work 
			public override int BinarySearch(int index, int count, Object value, IComparer comparer) {
				InternalUpdateRange();
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (_baseSize - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				int i = _baseList.BinarySearch(_baseIndex + index, count, value, comparer);
				if (i >= 0) return i - _baseIndex;
				return i + _baseIndex;
			}

			public override int Capacity {
                get {
                    return _baseList.Capacity;
                }
             
                set {
                   	 if (value < Count) throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_SmallCapacity"));
	            }
            }
    

			public override void Clear() {
				InternalUpdateRange();
				if (_baseSize != 0)
				{
					_baseList.RemoveRange(_baseIndex, _baseSize);
					_baseVersion++;
					_baseSize = 0;
				}
			}

			public override Object Clone() {
				InternalUpdateRange();
                Range arrayList = new Range(_baseList,_baseIndex,_baseSize);
				arrayList._baseList = (ArrayList)_baseList.Clone();
				return arrayList;
            }

			public override bool Contains(Object item) {
			  InternalUpdateRange();
			  if (item==null) {
					for(int i=0; i<_baseSize; i++)
						if (_baseList[_baseIndex + i]==null)
							return true;
					return false;
				}
				else {
					for(int i=0; i<_baseSize; i++)
						if (item.Equals(_baseList[_baseIndex + i]))
							return true;
					return false;
				}
            }
    
			public override void CopyTo(Array array, int index) {
				InternalUpdateRange();
				if (array==null)
                    throw new ArgumentNullException("array");
                if (array.Rank != 1)
                    throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
                if (index < 0)
					throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (array.Length - index < _baseSize)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
                Array.Copy(_baseList._items, _baseIndex, array, index, _baseSize);
             }

			public override void CopyTo(int index, Array array, int arrayIndex, int count) {
				InternalUpdateRange();
				if (array==null)
                    throw new ArgumentNullException("array");
                if (array.Rank != 1)
                    throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
                if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (array.Length - arrayIndex < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				if (_baseSize - index < count)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    			Array.Copy(_baseList._items, _baseIndex + index, array, arrayIndex, count);
			}

			public override int Count {
				get {
				 InternalUpdateRange();
				 return _baseSize; 
				}
			}

			public override bool IsReadOnly {
    			get { return _baseList.IsReadOnly; }
    		}

			public override bool IsFixedSize {
    			get { return _baseList.IsFixedSize; }
    		}

			public override bool IsSynchronized {
    			get { return _baseList.IsSynchronized; }
    		}
								
			public override IEnumerator GetEnumerator() {
				return GetEnumerator(0,_baseSize);
            }

			public override IEnumerator GetEnumerator(int index, int count) {
				InternalUpdateRange();
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (_baseSize - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				return _baseList.GetEnumerator(_baseIndex + index, count);
			}

			public override ArrayList GetRange(int index, int count) {
				InternalUpdateRange();
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (_baseSize - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				return new Range(this, index, count);
			}

			public override Object SyncRoot {
				get {
					return _baseList.SyncRoot;
				}
			}
        

			public override int IndexOf(Object value) {
				InternalUpdateRange();
				int i = _baseList.IndexOf(value, _baseIndex, _baseSize);
				if (i >= 0) return i - _baseIndex;
				return -1;
			}

			public override int IndexOf(Object value, int startIndex) {
				InternalUpdateRange();
				if (startIndex < 0)
					throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (startIndex > _baseSize)
					throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));

				int i = _baseList.IndexOf(value, _baseIndex + startIndex, _baseSize - startIndex);
				if (i >= 0) return i - _baseIndex;
				return -1;
			}
			
			public override int IndexOf(Object value, int startIndex, int count) {
				InternalUpdateRange();
				if (startIndex < 0 || startIndex > _baseSize)
					throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
					
				if (count < 0 || (startIndex > _baseSize - count))
					throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));

				int i = _baseList.IndexOf(value, _baseIndex + startIndex, count);
				if (i >= 0) return i - _baseIndex;
				return -1;
			}

			public override void Insert(int index, Object value) {
				InternalUpdateRange();
				if (index < 0 || index > _baseSize) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
				_baseList.Insert(_baseIndex + index, value);
				_baseVersion++;
				_baseSize++;
			}

			public override void InsertRange(int index, ICollection c) {
				InternalUpdateRange();
				if (index < 0 || index > _baseSize) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
				_baseList.InsertRange(_baseIndex + index, c);
				_baseVersion++;
				_baseSize += c.Count;
			}

			public override int LastIndexOf(Object value) {
            	InternalUpdateRange();
				int i = _baseList.LastIndexOf(value, _baseIndex + _baseSize - 1, _baseSize);
				if (i >= 0) return i - _baseIndex;
				return -1;
			}

            public override int LastIndexOf(Object value, int startIndex) {
            	return LastIndexOf(value, startIndex, startIndex + 1);
			}

			public override int LastIndexOf(Object value, int startIndex, int count) {
				InternalUpdateRange();
				if (_baseSize == 0)
					return -1;
   
				if (startIndex >= _baseSize)
					throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_Index"));
				if (startIndex < 0)
					throw new ArgumentOutOfRangeException("startIndex", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				
				int i = _baseList.LastIndexOf(value, _baseIndex + startIndex, count);
				if (i >= 0) return i - _baseIndex;
				return -1;
			}

			// Don't need to override Remove

			public override void RemoveAt(int index) {
				InternalUpdateRange();
				if (index < 0 || index >= _baseSize) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
				_baseList.RemoveAt(_baseIndex + index);
				_baseVersion++;
				_baseSize--;
			}

			public override void RemoveRange(int index, int count) {
				InternalUpdateRange();
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (_baseSize - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				_baseList.RemoveRange(_baseIndex + index, count);
				_baseVersion++;
				_baseSize -= count;
			}

			public override void Reverse(int index, int count) {
				InternalUpdateRange();
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (_baseSize - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				_baseList.Reverse(_baseIndex + index, count);
				_baseVersion++;
			}


			public override void SetRange(int index, ICollection c) {
				InternalUpdateRange();
				if (index < 0 || index >= _baseSize) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
				_baseList.SetRange(_baseIndex + index, c);
				_baseVersion++;
			}

			public override void Sort(int index, int count, IComparer comparer) {
				InternalUpdateRange();
				if (index < 0 || count < 0)
					throw new ArgumentOutOfRangeException((index<0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
				if (_baseSize - index < count)
					throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
				_baseList.Sort(_baseIndex + index, count, comparer);
				_baseVersion++;
			}

			public override Object this[int index] {
                get {
					InternalUpdateRange();
					if (index < 0 || index >= _baseSize) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
						return _baseList[_baseIndex + index];
                }
                set {
					InternalUpdateRange();
					if (index < 0 || index >= _baseSize) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
                    _baseList[_baseIndex + index] = value;
					_baseVersion++;
                }
            }

			public override Object[] ToArray() {
				InternalUpdateRange();
				Object[] array = new Object[_baseSize];
				Array.Copy(_baseList._items, _baseIndex, array, 0, _baseSize);
				return array;
			}

			public override Array ToArray(Type type) {
				InternalUpdateRange();
				if (type==null)
					throw new ArgumentNullException("type");
				Array array = Array.CreateInstance(type, _baseSize);
				Array.Copy(_baseList._items, _baseIndex, array, 0, _baseSize);
				return array;
			}

			public override void TrimToSize() {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_RangeCollection"));
            }
		}

        // For a straightforward enumeration of the entire ArrayList, 
        // this is faster, because it's smaller.  Patrick showed
        // this with a benchmark.
        [Serializable()] private class ArrayListEnumeratorSimple : IEnumerator, ICloneable
        {
            private ArrayList list;
            private int index;
            private int version;
			private Object currentElement;
						    
            internal ArrayListEnumeratorSimple(ArrayList list) {
                this.list = list;
                this.index = -1;
                version = list._version;
                currentElement = list;
			}

            public Object Clone() {
                return MemberwiseClone();
            }
    
            public virtual bool MoveNext() {
                if (version != list._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                if (index < (list.Count-1)) {
					index++;
					currentElement = list[index];
                    return true;
                }
                else {
                    currentElement = list;
                    index = list.Count;
                }
                return false;

            }
    
            public virtual Object Current {
                get {
                    Object temp = currentElement;
                    if (temp == list) {
                        if (index == -1)
                            throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
					    else
                            throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));                        
                    }
                    return temp;
                }
            }
    
            public virtual void Reset() {
                if (version != list._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
				currentElement = list;
                index = -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\icomparer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IComparer
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Interface for comparing two Objects.
**
** Date:  September 25, 1999
** 
===========================================================*/
namespace System.Collections {
    
	using System;
    // The IComparer interface implements a method that compares two objects. It is
    // used in conjunction with the Sort and BinarySearch methods on
    // the Array and List classes.
    // 
	// Interfaces are not serializable
    /// <include file='doc\IComparer.uex' path='docs/doc[@for="IComparer"]/*' />
    public interface IComparer {
        // Compares two objects. An implementation of this method must return a
        // value less than zero if x is less than y, zero if x is equal to y, or a
        // value greater than zero if x is greater than y.
        // 
        /// <include file='doc\IComparer.uex' path='docs/doc[@for="IComparer.Compare"]/*' />
        int Compare(Object x, Object y);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\dictionaryentry.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  DictionaryEntry
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Return Value for IDictionaryEnumerator::GetEntry
**
** Date:  September 20, 1999
** 
===========================================================*/
namespace System.Collections {
    
	using System;
    // A DictionaryEntry holds a key and a value from a dictionary.
    // It is returned by IDictionaryEnumerator::GetEntry().
    /// <include file='doc\DictionaryEntry.uex' path='docs/doc[@for="DictionaryEntry"]/*' />
    [Serializable()] public struct DictionaryEntry
    {
        /// <include file='doc\DictionaryEntry.uex' path='docs/doc[@for="DictionaryEntry._key"]/*' />
        private Object _key;
        /// <include file='doc\DictionaryEntry.uex' path='docs/doc[@for="DictionaryEntry._value"]/*' />
        private Object _value;
    
        // Constructs a new DictionaryEnumerator by setting the Key
        // and Value fields appropriately.
        //
        /// <include file='doc\DictionaryEntry.uex' path='docs/doc[@for="DictionaryEntry.DictionaryEntry"]/*' />
        public DictionaryEntry(Object key, Object value)
        {
            if (key==null)
                throw new ArgumentNullException("key");
            _key = key;
            _value = value;
        }

		/// <include file='doc\DictionaryEntry.uex' path='docs/doc[@for="DictionaryEntry.Key"]/*' />
		public Object Key
		{
			get
			{
				return _key;
			}

            set {
				if (value == null)
					throw new ArgumentNullException("value");
                _key = value;
            }
		}

		/// <include file='doc\DictionaryEntry.uex' path='docs/doc[@for="DictionaryEntry.Value"]/*' />
		public Object Value
		{
			get {
				return _value;
			}

            set {
                _value = value;
            }
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\dictionarybase.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

namespace System.Collections {

    using System;

    // Useful base class for typed read/write collections where items derive from object
    /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase"]/*' />
    [Serializable]
    public abstract class DictionaryBase : IDictionary {
        Hashtable hashtable;

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.InnerHashtable"]/*' />
        protected Hashtable InnerHashtable { 
            get { 
                if (hashtable == null)
                    hashtable = new Hashtable();
                return hashtable;
            }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.Dictionary"]/*' />
        protected IDictionary Dictionary {
            get { return (IDictionary) this; }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.Count"]/*' />
        public int Count {
            // to avoid newing inner list if no items are ever added
            get { return hashtable == null ? 0 : hashtable.Count; }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IDictionary.IsReadOnly"]/*' />
        bool IDictionary.IsReadOnly {
            get { return InnerHashtable.IsReadOnly; }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IDictionary.IsFixedSize"]/*' />
        bool IDictionary.IsFixedSize {
            get { return InnerHashtable.IsFixedSize; }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.ICollection.IsSynchronized"]/*' />
        bool ICollection.IsSynchronized {
            get { return InnerHashtable.IsSynchronized; }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IDictionary.Keys"]/*' />
        ICollection IDictionary.Keys {
            get {
                return InnerHashtable.Keys;
            }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.ICollection.SyncRoot"]/*' />
        Object ICollection.SyncRoot {
            get { return InnerHashtable.SyncRoot; }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IDictionary.Values"]/*' />
        ICollection IDictionary.Values {
            get {
                return InnerHashtable.Values;
            }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.CopyTo"]/*' />
        public void CopyTo(Array array, int index) {
            InnerHashtable.CopyTo(array, index);
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IDictionary.this"]/*' />
        object IDictionary.this[object key] {
            get {
                OnGet(key, InnerHashtable[key]);
                return InnerHashtable[key]; 
            }
            set { 
                OnValidate(key, value);
                Object temp = InnerHashtable[key];
                OnSet(key, temp, value); 
                InnerHashtable[key] = value; 
                try {
                    OnSetComplete(key, temp, value); 
                }
                catch (Exception) {
                   InnerHashtable[key] = temp; 
                   throw;
                }
            }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IDictionary.Contains"]/*' />
        bool IDictionary.Contains(object key) {
            return InnerHashtable.Contains(key);
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IDictionary.Add"]/*' />
        void IDictionary.Add(object key, object value) {
            OnValidate(key, value);
            OnInsert(key, value); 
            InnerHashtable.Add(key, value);
            try {
                OnInsertComplete(key, value);
            }
            catch (Exception) {
                InnerHashtable.Remove(key);
                throw;
            }
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.Clear"]/*' />
        public void Clear() {
            OnClear();
            InnerHashtable.Clear();
            OnClearComplete();
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IDictionary.Remove"]/*' />
        void IDictionary.Remove(object key) {
            Object temp = InnerHashtable[key];
            OnValidate(key, temp);
            OnRemove(key, temp);
            InnerHashtable.Remove(key);
            OnRemoveComplete(key, temp);
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.GetEnumerator"]/*' />
        public IDictionaryEnumerator GetEnumerator() {
            return InnerHashtable.GetEnumerator();
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.IEnumerable.GetEnumerator"]/*' />
        IEnumerator IEnumerable.GetEnumerator() {
            return InnerHashtable.GetEnumerator();
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnGet"]/*' />
        protected virtual object OnGet(object key, object currentValue) {
            return currentValue;
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnSet"]/*' />
        protected virtual void OnSet(object key, object oldValue, object newValue) { 
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnInsert"]/*' />
        protected virtual void OnInsert(object key, object value) { 
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnClear"]/*' />
        protected virtual void OnClear() { 
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnRemove"]/*' />
        protected virtual void OnRemove(object key, object value) { 
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnValidate"]/*' />
        protected virtual void OnValidate(object key, object value) {
        }
        
        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnSetComplete"]/*' />
        protected virtual void OnSetComplete(object key, object oldValue, object newValue) { 
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnInsertComplete"]/*' />
        protected virtual void OnInsertComplete(object key, object value) { 
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnClearComplete"]/*' />
        protected virtual void OnClearComplete() { 
        }

        /// <include file='doc\DictionaryBase.uex' path='docs/doc[@for="DictionaryBase.OnRemoveComplete"]/*' />
        protected virtual void OnRemoveComplete(object key, object value) { 
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\hashtable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Hashtable
**
** Author: Brian Grunkemeyer (BrianGru), Rajesh Chandrashekaran (rajeshc)
**
** Purpose: Hash table implementation
**
** Date:  September 25, 1999
** 
===========================================================*/
namespace System.Collections {
    using System;
    using System.Runtime.Serialization;
    
    // The Hashtable class represents a dictionary of associated keys and 
    // values with constant lookup time.
    // 
    // Objects used as keys in a hashtable must implement the GetHashCode
    // and Equals methods (or they can rely on the default implementations
    // inherited from Object if key equality is simply reference
    // equality). Furthermore, the GetHashCode and Equals methods of
    // a key object must produce the same results given the same parameters 
    // for the entire time the key is present in the hashtable. In practical 
    // terms, this means that key objects should be immutable, at least for 
    // the time they are used as keys in a hashtable.
    // 
    // When entries are added to a hashtable, they are placed into
    // buckets based on the hashcode of their keys. Subsequent lookups of
    // keys will use the hashcode of the keys to only search a particular 
    // bucket, thus substantially reducing the number of key comparisons 
    // required to find an entry. A hashtable's maximum load factor, which 
    // can be specified when the hashtable is instantiated, determines the 
    // maximum ratio of hashtable entries to hashtable buckets. Smaller load 
    // factors cause faster average lookup times at the cost of increased 
    // memory consumption. The default maximum load factor of 1.0 generally 
    // provides the best balance between speed and size. As entries are added 
    // to a hashtable, the hashtable's actual load factor increases, and when 
    // the actual load factor reaches the maximum load factor value, the 
    // number of buckets in the hashtable is automatically increased by 
    // approximately a factor of two (to be precise, the number of hashtable 
    // buckets is increased to the smallest prime number that is larger than 
    // twice the current number of hashtable buckets).
    // 
    // Each object provides their own hash function, accessed by calling
    // GetHashCode().  However, one can write their own object 
    // implementing IHashCodeProvider and pass it to a constructor on
    // the Hashtable.  That hash function would be used for all objects in 
    // the table.
    // 
    // This Hashtable is implemented to support multiple concurrent readers 
    // and one concurrent writer without using any synchronization primitives.
    // All read methods essentially must protect themselves from a resize 
    // occuring while they are running.  This was done by enforcing an 
    // ordering on inserts & removes, as well as removing some member variables 
    // and special casing the expand code to work in a temporary array instead 
    // of the live bucket array.  All inserts must set a bucket's value and 
    // key before setting the hash code & collision field.  All removes must 
    // clear the hash code & collision field, then the key then value field 
    // (at least value should be set last).
    // 
    // By Brian Grunkemeyer, algorithm by Patrick Dussud.
    // Version 1.30 2/20/2000
    /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable"]/*' />
    [Serializable()] public class Hashtable : IDictionary, ISerializable, IDeserializationCallback, ICloneable
    {
        /*
          Implementation Notes:
    
          This Hashtable uses double hashing.  There are hashsize buckets in
          the table, and each bucket can contain 0 or 1 element.  We a bit to 
          mark whether there's been a collision when we inserted multiple 
          elements (ie, an inserted item was hashed at least a second time and 
          we probed this bucket, but it was already in use).  Using the 
          collision bit, we can terminate lookups & removes for elements that 
          aren't in the hash table more quickly.  We steal the most 
          significant bit from the hash code to store the collision bit.

          Our hash function is of the following form:
    
          h(key, n) = h1(key) + n*h2(key)
    
          where n is the number of times we've hit a collided bucket and 
          rehashed (on this particular lookup).  Here are our hash functions:
    
          h1(key) = GetHash(key);  // default implementation calls key.GetHashCode();
          h2(key) = 1 + (((h1(key) >> 5) + 1) % (hashsize - 1));
    
          The h1 can return any number.  h2 must return a number between 1 and
          hashsize - 1 that is relatively prime to hashsize (not a problem if 
          hashsize is prime).  (Knuth's Art of Computer Programming, Vol. 3, 
          p. 528-9)

          If this is true, then we are guaranteed to visit every bucket in 
          exactly hashsize probes, since the least common multiple of hashsize 
          and h2(key) will be hashsize * h2(key).  (This is the first number 
          where adding h2 to h1 mod hashsize will be 0 and we will search the 
          same bucket twice).
          
          We previously used a different h2(key, n) that was not constant.  
          That is a horrifically bad idea, unless you can prove that series 
          will never produce any identical numbers that overlap when you mod 
          them by hashsize, for all subranges from i to i+hashsize, for all i.  
          It's not worth investigating, since there was no clear benefit from 
          using that hash function, and it was broken.
    
          For efficiency reasons, we've implemented this by storing h1 and h2 
          in a temporary, and setting a variable called seed equal to h1.  We 
          do a probe, and if we collided, we simply add h2 to seed each time 
          through the loop.
    
          A good test for h2() is to subclass Hashtable, provide your own 
          implementation of GetHash() that returns a constant, then add many 
          items to the hash table.  Make sure Count equals the number of items 
          you inserted.

          Note that when we remove an item from the hash table, we set the key
          equal to buckets, if there was a collision in this bucket.  
          Otherwise we'd either wipe out the collision bit, or we'd still have 
          an item in the hash table.

          -- Brian Grunkemeyer, 10/28/1999
        */
    
        // Table of prime numbers to use as hash table sizes. Each entry is the
        // smallest prime number larger than twice the previous entry.
        private readonly static int[] primes = {
            11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,
            1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,
            17519,21023,25229,30293,36353,43627,52361,62851,75431,90523, 108631, 130363, 
            156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403,
            968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 
            4999559, 5999471, 7199369 
        };
    
        private const String LoadFactorName = "LoadFactor";
        private const String VersionName = "Version";
        private const String ComparerName = "Comparer";
        private const String HashCodeProviderName = "HashCodeProvider";
        private const String HashSizeName = "HashSize";  // Must save buckets.Length
        private const String KeysName = "Keys";
        private const String ValuesName = "Values";
        
    
        private bool Primep (int candidate) {
            if ((candidate & 1) != 0) {
                for (int divisor = 3; divisor < (int)Math.Sqrt (candidate); divisor+=2){
                    if ((candidate % divisor) == 0)
                        return false;
                }
                return true;
            }
            else {
                return (candidate == 2);
            }
        }
    
    
        private int GetPrime(int minSize) {
            if (minSize < 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_HTCapacityOverflow"));
            for (int i = 0; i < primes.Length; i++) {
                int size = primes[i];
                if (size >= minSize) return size;
            }
            //outside of our predefined table. 
            //compute the hard way. 
            for (int j = ((minSize - 2) | 1);j < Int32.MaxValue;j+=2) {
                if (Primep (j))
                    return j;
            }
            return minSize;
        }

        // Deleted entries have their key set to buckets
      
        // The hash table data.
		 // This cannot be serialised
        private struct bucket {
            public Object key;
            public Object val;
            public int hash_coll;   // Store hash code; sign bit means there was a collision.
        }
    
        private bucket[] buckets;
    
        // The total number of entries in the hash table.
        private  int count;

        // The total number of collision bits set in the hashtable
        private int occupancy;
        
        private  int loadsize;
        private  float loadFactor;

        private int version;
        private ICollection keys;
        private ICollection values;

		private IHashCodeProvider _hcp;  // An object that can dispense hash codes.
		private IComparer _comparer;

        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.hcp"]/*' />
		protected IHashCodeProvider hcp
		{
			get
			{
				return _hcp;
			}
			set
			{
				_hcp = value;
			}
		}
		
		
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.comparer"]/*' />
        protected IComparer comparer
		{
			get
			{
				return _comparer;
			}
			set
			{
				_comparer = value;
			}
		}
		

        private SerializationInfo m_siInfo; //A temporary variable which we need during deserialization.
    	
        // Constructs a new hashtable. The hashtable is created with an initial
        // capacity of zero and a load factor of 1.0.
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable"]/*' />
        public Hashtable() : this(0, 1.0f) {
        }
    
        // Constructs a new hashtable with the given initial capacity and a load
        // factor of 1.0. The capacity argument serves as an indication of
        // the number of entries the hashtable will contain. When this number (or
        // an approximation) is known, specifying it in the constructor can
        // eliminate a number of resizing operations that would otherwise be
        // performed when elements are added to the hashtable.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable1"]/*' />
        public Hashtable(int capacity) : this(capacity, 1.0f) {
        }
    
        // Constructs a new hashtable with the given initial capacity and load
        // factor. The capacity argument serves as an indication of the
        // number of entries the hashtable will contain. When this number (or an
        // approximation) is known, specifying it in the constructor can eliminate
        // a number of resizing operations that would otherwise be performed when
        // elements are added to the hashtable. The loadFactor argument
        // indicates the maximum ratio of hashtable entries to hashtable buckets.
        // Smaller load factors cause faster average lookup times at the cost of
        // increased memory consumption. A load factor of 1.0 generally provides
        // the best balance between speed and size.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable2"]/*' />
        public Hashtable(int capacity, float loadFactor) : this(capacity, loadFactor, null, null) {
        }
    
        // Constructs a new hashtable with the given initial capacity and load
        // factor. The capacity argument serves as an indication of the
        // number of entries the hashtable will contain. When this number (or an
        // approximation) is known, specifying it in the constructor can eliminate
        // a number of resizing operations that would otherwise be performed when
        // elements are added to the hashtable. The loadFactor argument
        // indicates the maximum ratio of hashtable entries to hashtable buckets.
        // Smaller load factors cause faster average lookup times at the cost of
        // increased memory consumption. A load factor of 1.0 generally provides
        // the best balance between speed and size.  The hcp argument
        // is used to specify an Object that will provide hash codes for all
        // the Objects in the table.  Using this, you can in effect override
        // GetHashCode() on each Object using your own hash function.  The 
        // comparer argument will let you specify a custom function for
        // comparing keys.  By specifying user-defined objects for hcp
        // and comparer, users could make a hash table using strings
        // as keys do case-insensitive lookups.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable3"]/*' />
        public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer) {
    		if (capacity < 0)
    			throw new ArgumentOutOfRangeException("capacity", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (!(loadFactor >= 0.1f && loadFactor <= 1.0f))
                throw new ArgumentOutOfRangeException("loadFactor", String.Format(Environment.GetResourceString("ArgumentOutOfRange_HashtableLoadFactor"), .1, 1.0));
    
            // Based on perf work, .72 is the optimal load factor for this table.  
    		this.loadFactor = 0.72f * loadFactor;
    
    		int hashsize = GetPrime ((int)(capacity / this.loadFactor));
    		buckets = new bucket[hashsize];
    
    		loadsize = (int)(this.loadFactor * hashsize);
    		if (loadsize >= hashsize)
    		  loadsize = hashsize-1;
    
    		this.hcp = hcp;
    		this.comparer = comparer;
        }
    
    	// Constructs a new hashtable using a custom hash function
    	// and a custom comparison function for keys.  This will enable scenarios
    	// such as doing lookups with case-insensitive strings.
    	// 
    	/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable4"]/*' />
    	public Hashtable(IHashCodeProvider hcp, IComparer comparer) : this(0, 1.0f, hcp, comparer) {
    	}
    	
    	// Constructs a new hashtable using a custom hash function
    	// and a custom comparison function for keys.  This will enable scenarios
    	// such as doing lookups with case-insensitive strings.
    	// 
    	/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable5"]/*' />
    	public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer)  	
    		: this(capacity, 1.0f, hcp, comparer) {
    	}
    
        // Constructs a new hashtable containing a copy of the entries in the given
        // dictionary. The hashtable is created with a load factor of 1.0.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable6"]/*' />
        public Hashtable(IDictionary d) : this(d, 1.0f) {
        }
        
        // Constructs a new hashtable containing a copy of the entries in the given
        // dictionary. The hashtable is created with the given load factor.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable7"]/*' />
        public Hashtable(IDictionary d, float loadFactor) 
    		: this(d, loadFactor, null, null) {
        }

		/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable8"]/*' />
		public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer) 
			: this(d, 1.0f, hcp, comparer)	{
		}

		/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable9"]/*' />
		public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer) 
    		: this((d != null ? d.Count : 0), loadFactor, hcp, comparer) {
    		if (d==null)
    			throw new ArgumentNullException("d", Environment.GetResourceString("ArgumentNull_Dictionary"));
			
            IDictionaryEnumerator e = d.GetEnumerator();
            while (e.MoveNext()) Add(e.Key, e.Value);
        }
        
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Hashtable10"]/*' />
        protected Hashtable(SerializationInfo info, StreamingContext context) {
            //We can't do anything with the keys and values until the entire graph has been deserialized
            //and we have a resonable estimate that GetHashCode is not going to fail.  For the time being,
            //we'll just cache this.  The graph is not valid until OnDeserialization has been called.
            //@ToDo [JRoxe]: Assert that m_siInfo is null in every accessor function.
            m_siInfo = info; 
        }

        // Computes the hash function:  H(key, i) = h1(key) + i*h2(key, hashSize).
        // The out parameter seed is h1(key), while the out parameter 
        // incr is h2(key, hashSize).  Callers of this function should 
        // add incr each time through a loop.
        private uint InitHash(Object key, int hashsize, out uint seed, out uint incr) {
            // Hashcode must be positive.  Also, we must not use the sign bit, since
            // that is used for the collision bit.
            uint hashcode = (uint) GetHash(key) & 0x7FFFFFFF;
            seed = (uint) hashcode;
            // Restriction: incr MUST be between 1 and hashsize - 1, inclusive for
            // the modular arithmetic to work correctly.  This guarantees you'll
            // visit every bucket in the table exactly once within hashsize 
            // iterations.  Violate this and it'll cause obscure bugs forever.
            // If you change this calculation for h2(key), update putEntry too!
            incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)hashsize - 1)));
            return hashcode;
        }

        // Adds an entry with the given key and value to this hashtable. An
        // ArgumentException is thrown if the key is null or if the key is already
        // present in the hashtable.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Add"]/*' />
        public virtual void Add(Object key, Object value) {
            Insert(key, value, true);
        }
    
        // Removes all entries from this hashtable.
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Clear"]/*' />
        public virtual void Clear() {
    	  if (count == 0)
    		return;
    
    	  for (int i = 0; i < buckets.Length; i++){
    		buckets[i].hash_coll = 0;
    		buckets[i].key = null;
    		buckets[i].val = null;
    	  }
    
    	  count = 0;
          occupancy = 0;
        }
    
        // Clone returns a virtually identical copy of this hash table.  This does
        // a shallow copy - the Objects in the table aren't cloned, only the references
        // to those Objects.
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Clone"]/*' />
        public virtual Object Clone()
        {
			bucket[] lbuckets = buckets;
            Hashtable ht = new Hashtable(count,hcp,comparer);
            ht.version = version;
			ht.loadFactor = loadFactor;
			ht.count = 0;
			
			int bucket = lbuckets.Length;
			while (bucket > 0) {
                    bucket--;
                    Object keyv = lbuckets[bucket].key;
                    if ((keyv!= null) && (keyv != lbuckets)) {
						ht[keyv] = lbuckets[bucket].val;
                  }
            }
			
            return ht;
        }
                        
        // Checks if this hashtable contains the given key.
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Contains"]/*' />
        public virtual bool Contains(Object key) {
            return ContainsKey(key);
        }
        
        // Checks if this hashtable contains an entry with the given key.  This is
        // an O(1) operation.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.ContainsKey"]/*' />
        public virtual bool ContainsKey(Object key) {
            if (key == null) {
                throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));
            }

            uint seed;
            uint incr;
            // Take a snapshot of buckets, in case another thread resizes table
            bucket[] lbuckets = buckets;
            uint hashcode = InitHash(key, lbuckets.Length, out seed, out incr);
            int  ntry = 0;
            
            bucket b;
            do {
                int bucketNumber = (int) (seed % (uint)lbuckets.Length);
                b = lbuckets[bucketNumber];
                if (b.key == null) {
                    return false;
                }
                if (((b.hash_coll &  0x7FFFFFFF) == hashcode) && 
                    KeyEquals (b.key, key))
                    return true;
                seed += incr;
            } while (b.hash_coll < 0 && ++ntry < lbuckets.Length);
            return false;
        }
    
    
        
        // Checks if this hashtable contains an entry with the given value. The
        // values of the entries of the hashtable are compared to the given value
        // using the Object.Equals method. This method performs a linear
        // search and is thus be substantially slower than the ContainsKey
        // method.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.ContainsValue"]/*' />
        public virtual bool ContainsValue(Object value) {
            if (value == null) {
                for (int i = buckets.Length; --i >= 0;) {
    			  if (buckets[i].key != null && buckets[i].val == null)
    				return true;
                }
            }
            else {
    		  for (int i = buckets.Length; --i >= 0;) {
                  Object val = buckets[i].val;
                  if (val!=null && value.Equals(val)) return true;
    		  }
    		}
            return false;
        }
    
        // Copies the keys of this hashtable to a given array starting at a given
        // index. This method is used by the implementation of the CopyTo method in
        // the KeyCollection class.
        private void CopyKeys(Array array, int arrayIndex) {
            bucket[] lbuckets = buckets;
            for (int i = lbuckets.Length; --i >= 0;) {
    		  Object keyv = lbuckets[i].key;
    		  if ((keyv != null) && (keyv != buckets)){
    			array.SetValue(keyv, arrayIndex++);
    		  }
            }
        }

        // Copies the keys of this hashtable to a given array starting at a given
        // index. This method is used by the implementation of the CopyTo method in
        // the KeyCollection class.
        private void CopyEntries(Array array, int arrayIndex) {
            bucket[] lbuckets = buckets;
            for (int i = lbuckets.Length; --i >= 0;) {
    		  Object keyv = lbuckets[i].key;
    		  if ((keyv != null) && (keyv != buckets)){
				DictionaryEntry entry = new DictionaryEntry(keyv,lbuckets[i].val);
    			array.SetValue(entry, arrayIndex++);
    		  }
            }
        }
        
    	// Copies the values in this hash table to an array at
    	// a given index.  Note that this only copies values, and not keys.
    	/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.CopyTo"]/*' />
    	public virtual void CopyTo(Array array, int arrayIndex)
    	{
    		if (array == null)
    			throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Array"));
            if (array.Rank != 1)
                throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
    		if (arrayIndex < 0) 
    			throw new ArgumentOutOfRangeException("arrayIndex", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - arrayIndex < count)
                throw new ArgumentException(Environment.GetResourceString("Arg_ArrayPlusOffTooSmall"));
    		CopyEntries(array, arrayIndex);
    	}
    	
        // Copies the values of this hashtable to a given array starting at a given
        // index. This method is used by the implementation of the CopyTo method in
        // the ValueCollection class.
        private void CopyValues(Array array, int arrayIndex) {
            bucket[] lbuckets = buckets;
            for (int i = lbuckets.Length; --i >= 0;) {
                Object keyv = lbuckets[i].key;
                if ((keyv != null) && (keyv != buckets)){
                    array.SetValue(lbuckets[i].val, arrayIndex++);
                }
            }
        }
        
        // Returns the value associated with the given key. If an entry with the
        // given key is not found, the returned value is null.
        // 
    	/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.this"]/*' />
    	public virtual Object this[Object key] {
    	  get {
    		if (key == null) {
    		  throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));
    		}
            uint seed;
            uint incr;
            // Take a snapshot of buckets, in case another thread does a resize
            bucket[] lbuckets = buckets;
            uint hashcode = InitHash(key, lbuckets.Length, out seed, out incr);
    		int  ntry = 0;
    
    		bucket b;
    		do
    		  {
    			int bucketNumber = (int) (seed % (uint)lbuckets.Length);
    			b = lbuckets[bucketNumber];
    			if (b.key == null) {
    			  return null;
    			}
    			if (((b.hash_coll & 0x7FFFFFFF) == hashcode) && 
    				KeyEquals (key, b.key))
    			  return b.val;
    			seed += incr;
    		  }while (b.hash_coll < 0 && ++ntry < lbuckets.Length);
    		return null;
    	  }
    	  set {
    		Insert(key, value, false);
    	  }
    	}	
    
        // Increases the bucket count of this hashtable. This method is called from
        // the Insert method when the actual load factor of the hashtable reaches
        // the upper limit specified when the hashtable was constructed. The number
        // of buckets in the hashtable is increased to the smallest prime number
        // that is larger than twice the current number of buckets, and the entries
        // in the hashtable are redistributed into the new buckets using the cached
        // hashcodes.
        private void expand()  {
            rehash( GetPrime( 1+buckets.Length*2 ) );
        }

        // We occationally need to rehash the table to clean up the collision bits.
        private void rehash() {
            rehash( buckets.Length );
        }

        private void rehash( int newsize ) {

            // reset occupancy
            occupancy=0;
        
            // Don't replace any internal state until we've finished adding to the 
            // new bucket[].  This serves two purposes: 
            //   1) Allow concurrent readers to see valid hashtable contents 
            //      at all times
            //   2) Protect against an OutOfMemoryException while allocating this 
            //      new bucket[].
            bucket[] newBuckets = new bucket[newsize];
    
            // rehash table into new buckets
            int nb;
            for (nb = 0; nb < buckets.Length; nb++){
                bucket oldb = buckets[nb];
                if ((oldb.key != null) && (oldb.key != buckets)){
                    putEntry(newBuckets, oldb.key, oldb.val, oldb.hash_coll & 0x7FFFFFFF);
                }
            }
            
            // New bucket[] is good to go - replace buckets and other internal state.
            version++;
            buckets = newBuckets;
            loadsize = (int)(loadFactor * newsize);

            if (loadsize >= newsize) {
                loadsize = newsize-1;
            }

            return;
        }
    
        // Returns an enumerator for this hashtable.
        // If modifications made to the hashtable while an enumeration is
        // in progress, the MoveNext and Current methods of the
        // enumerator will throw an exception.
        //
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.IEnumerable.GetEnumerator"]/*' />
        IEnumerator IEnumerable.GetEnumerator() {
            return new HashtableEnumerator(this, HashtableEnumerator.DictEntry);
        }

        // Returns a dictionary enumerator for this hashtable.
        // If modifications made to the hashtable while an enumeration is
        // in progress, the MoveNext and Current methods of the
        // enumerator will throw an exception.
        //
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.GetEnumerator"]/*' />
        public virtual IDictionaryEnumerator GetEnumerator() {
            return new HashtableEnumerator(this, HashtableEnumerator.DictEntry);
        }
    
    	// Internal method to get the hash code for an Object.  This will call
    	// GetHashCode() on each object if you haven't provided an IHashCodeProvider
    	// instance.  Otherwise, it calls hcp.GetHashCode(obj).
    	/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.GetHash"]/*' />
    	protected virtual int GetHash(Object key)
    	{
    		if (hcp!=null)
    			return hcp.GetHashCode(key);
    		return key.GetHashCode();
    	}
    	
        // Is this Hashtable read-only?
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.IsReadOnly"]/*' />
        public virtual bool IsReadOnly {
            get { return false; }
        }

		/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.IsFixedSize"]/*' />
		public virtual bool IsFixedSize {
            get { return false; }
        }

        // Is this Hashtable synchronized?  See SyncRoot property
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.IsSynchronized"]/*' />
        public virtual bool IsSynchronized {
            get { return false; }
        }

    	// Internal method to compare two keys.  If you have provided an IComparer
    	// instance in the constructor, this method will call comparer.Compare(item, key).
    	// Otherwise, it will call item.Equals(key).
    	// 
    	/// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.KeyEquals"]/*' />
    	protected virtual bool KeyEquals(Object item, Object key)
    	{
    		if (comparer!=null)
    			return comparer.Compare(item, key)==0;
    		return item.Equals(key);
    	}
    	
        // Returns a collection representing the keys of this hashtable. The order
        // in which the returned collection represents the keys is unspecified, but
        // it is guaranteed to be          buckets = newBuckets; the same order in which a collection returned by
        // GetValues represents the values of the hashtable.
        // 
        // The returned collection is live in the sense that any changes
        // to the hash table are reflected in this collection.  It is not
        // a static copy of all the keys in the hash table.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Keys"]/*' />
        public virtual ICollection Keys {
    		get {
    			if (keys == null) keys = new KeyCollection(this);
    			return keys;
    		}
        }
    
        // Returns a collection representing the values of this hashtable. The
        // order in which the returned collection represents the values is
        // unspecified, but it is guaranteed to be the same order in which a
        // collection returned by GetKeys represents the keys of the
        // hashtable.
        // 
        // The returned collection is live in the sense that any changes
        // to the hash table are reflected in this collection.  It is not
        // a static copy of all the keys in the hash table.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Values"]/*' />
        public virtual ICollection Values {
    		get {
    	        if (values == null) values = new ValueCollection(this);
    		    return values;
    		}
        }
    
        // Inserts an entry into this hashtable. This method is called from the Set
        // and Add methods. If the add parameter is true and the given key already
        // exists in the hashtable, an exception is thrown.
        private void Insert (Object key, Object nvalue, bool add) {
            if (key == null) {
                throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));
            }
            if (count >= loadsize) {
                expand();
            }
            else if(occupancy > loadsize && count > 100) {
                rehash();
            }
            
            uint seed;
            uint incr;
            // Assume we only have one thread writing concurrently.  Modify
            // buckets to contain new data, as long as we insert in the right order.
            uint hashcode = InitHash(key, buckets.Length, out seed, out incr);
            int  ntry = 0;
            int emptySlotNumber = -1; // We use the empty slot number to cache the first empty slot. We chose to reuse slots
                                      // create by remove that have the collision bit set over using up new slots.

            do {
                int bucketNumber = (int) (seed % (uint)buckets.Length);

                // Set emptySlot number to current bucket if it is the first available bucket that we have seen
                // that once contained an entry and also has had a collision.
                // We need to search this entire collision chain because we have to ensure that there are no 
                // duplicate entries in the table.
                if (emptySlotNumber == -1 && (buckets[bucketNumber].key == buckets) && (buckets[bucketNumber].hash_coll < 0))//(((buckets[bucketNumber].hash_coll & unchecked(0x80000000))!=0)))
                    emptySlotNumber = bucketNumber;

                // Insert the key/value pair into this bucket if this bucket is empty and has never contained an entry
                // OR
                // This bucket once contained an entry but there has never been a collision
                if ((buckets[bucketNumber].key == null) || 
                    (buckets[bucketNumber].key == buckets && ((buckets[bucketNumber].hash_coll & unchecked(0x80000000))==0))) {

                    // If we have found an available bucket that has never had a collision, but we've seen an available
                    // bucket in the past that has the collision bit set, use the previous bucket instead
                    if (emptySlotNumber != -1) // Reuse slot
                        bucketNumber = emptySlotNumber;

                    // We pretty much have to insert in this order.  Don't set hash
                    // code until the value & key are set appropriately.
                    buckets[bucketNumber].val = nvalue;
                    buckets[bucketNumber].key  = key;
                    buckets[bucketNumber].hash_coll |= (int) hashcode;
                    count++;
                    version++;
                    return;
                }

                // The current bucket is in use
                // OR
                // it is available, but has had the collision bit set and we have already found an available bucket
                if (((buckets[bucketNumber].hash_coll & 0x7FFFFFFF) == hashcode) && 
                    KeyEquals (key, buckets[bucketNumber].key)) {
                    if (add) {
                        throw new ArgumentException(Environment.GetResourceString("Argument_AddingDuplicate__", buckets[bucketNumber].key, key));
                    }
                    buckets[bucketNumber].val = nvalue;
                    version++;
                    return;
                }

                // The current bucket is full, and we have therefore collided.  We need to set the collision bit
                // UNLESS
                // we have remembered an available slot previously.
                if (emptySlotNumber == -1) {// We don't need to set the collision bit here since we already have an empty slot
                    if( buckets[bucketNumber].hash_coll >= 0 ) {
                        buckets[bucketNumber].hash_coll |= unchecked((int)0x80000000);
                        occupancy++;
                    }
                }
                seed += incr;
            } while (++ntry < buckets.Length);

            // This code is here if and only if there were no buckets without a collision bit set in the entire table
			if (emptySlotNumber != -1)
			{			
			        // We pretty much have to insert in this order.  Don't set hash
                    // code until the value & key are set appropriately.
                    buckets[emptySlotNumber].val = nvalue;
                    buckets[emptySlotNumber].key  = key;
                    buckets[emptySlotNumber].hash_coll |= (int) hashcode;
                    count++;
                    version++;
                    return;
         
			}
    
		    // If you see this assert, make sure load factor & count are reasonable.
            // Then verify that our double hash function (h2, described at top of file)
            // meets the requirements described above. You should never see this assert.
            BCLDebug.Assert(false, "hash table insert failed!  Load factor too high, or our double hashing function is incorrect.");
            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_HashInsertFailed"));
        }
    
        private void putEntry (bucket[] newBuckets, Object key, Object nvalue, int hashcode)
        {
            BCLDebug.Assert(hashcode >= 0, "hashcode >= 0");  // make sure collision bit (sign bit) wasn't set.

            uint seed = (uint) hashcode;
            uint incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)newBuckets.Length - 1)));
            
            do {
                int bucketNumber = (int) (seed % (uint)newBuckets.Length);
    
                if ((newBuckets[bucketNumber].key == null) || (newBuckets[bucketNumber].key == buckets)) {
                    newBuckets[bucketNumber].val = nvalue;
                    newBuckets[bucketNumber].key = key;
                    newBuckets[bucketNumber].hash_coll |= hashcode;
                    return;
                }
                
                if( newBuckets[bucketNumber].hash_coll >= 0 ) {
                    newBuckets[bucketNumber].hash_coll |= unchecked((int)0x80000000);
                    occupancy++;
                }
                seed += incr;
            } while( true );
        }
    
        // Removes an entry from this hashtable. If an entry with the specified
        // key exists in the hashtable, it is removed. An ArgumentException is
        // thrown if the key is null.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Remove"]/*' />
        public virtual void Remove(Object key) {
            if (key == null) {
                throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));
            }
            uint seed;
            uint incr;
            // Assuming only one concurrent writer, write directly into buckets.
            uint hashcode = InitHash(key, buckets.Length, out seed, out incr);
            int ntry = 0;
            
            bucket b;
            int bn; // bucketNumber
            do {
                bn = (int) (seed % (uint)buckets.Length);  // bucketNumber
                b = buckets[bn];
                if (((b.hash_coll & 0x7FFFFFFF) == hashcode) && 
                    KeyEquals (key, b.key)) {
                    // Clear hash_coll field, then key, then value
                    buckets[bn].hash_coll &= unchecked((int)0x80000000);
                    if (buckets[bn].hash_coll != 0) {
                        buckets[bn].key = buckets;
                    } 
                    else {
                        buckets[bn].key = null;
                    }
                    buckets[bn].val = null;  // Free object references sooner & simplify ContainsValue.
                    count--;
                    version++;
                    return;
                }
                seed += incr;
            } while (buckets[bn].hash_coll < 0 && ++ntry < buckets.Length);

	    //throw new ArgumentException(Environment.GetResourceString("Arg_RemoveArgNotFound"));
        }
        
        // Returns the object to synchronize on for this hash table.
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.SyncRoot"]/*' />
        public virtual Object SyncRoot {
            get { return this; }
        }
    
        // Returns the number of associations in this hashtable.
        // 
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Count"]/*' />
        public virtual int Count {
    		get { return count; }
        }
    
        // Returns a thread-safe wrapper for a Hashtable.
        //
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.Synchronized"]/*' />
        public static Hashtable Synchronized(Hashtable table) {
            if (table==null)
                throw new ArgumentNullException("table");
            return new SyncHashtable(table);
        }
    
        //
        // The ISerializable Implementation
        //

        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.GetObjectData"]/*' />
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            info.AddValue(LoadFactorName, loadFactor);
            info.AddValue(VersionName, version);
            info.AddValue(ComparerName, comparer,typeof(IComparer));
            info.AddValue(HashCodeProviderName, hcp, typeof(IHashCodeProvider));
            info.AddValue(HashSizeName, buckets.Length); //This is the length of the bucket array.
            Object [] serKeys = new Object[count];
            Object [] serValues = new Object[count];
            CopyKeys(serKeys, 0);
            CopyValues(serValues,0);
            info.AddValue(KeysName, serKeys, typeof(Object[]));
            info.AddValue(ValuesName, serValues, typeof(Object[]));
        }
        
        //
        // DeserializationEvent Listener 
        //
        /// <include file='doc\Hashtable.uex' path='docs/doc[@for="Hashtable.OnDeserialization"]/*' />
        public virtual void OnDeserialization(Object sender) {
            if (buckets!=null) {
                return; //Somebody had a dependency on this hashtable and fixed us up before the ObjectManager got to it.
            }
            if (m_siInfo==null) {
                throw new SerializationException(Environment.GetResourceString("Serialization_InvalidOnDeser"));
            }
            
            loadFactor = m_siInfo.GetSingle(LoadFactorName);
            version    = m_siInfo.GetInt32(VersionName);
            comparer   = (IComparer)m_siInfo.GetValue(ComparerName, typeof(IComparer));
            hcp        = (IHashCodeProvider)m_siInfo.GetValue(HashCodeProviderName, typeof(IHashCodeProvider));
            int hashsize = m_siInfo.GetInt32(HashSizeName);
            loadsize   = (int)(loadFactor*hashsize);

            buckets = new bucket[hashsize];
    
            Object [] serKeys = (Object[])m_siInfo.GetValue(KeysName, typeof(Object[]));
            Object [] serValues = (Object[])m_siInfo.GetValue(ValuesName, typeof(Object[]));

            if (serKeys==null) {
                throw new SerializationException(Environment.GetResourceString("Serialization_MissingKeys"));
            }
            if (serValues==null) {
                throw new SerializationException(Environment.GetResourceString("Serialization_MissingValues"));
            }
            if (serKeys.Length!=serValues.Length) {
                throw new SerializationException(Environment.GetResourceString("Serialization_KeyValueDifferentSizes"));
            }
            for (int i=0; i<serKeys.Length; i++) {
                if (serKeys[i]==null) {
                    throw new SerializationException(Environment.GetResourceString("Serialization_NullKey"));
                }
                Insert(serKeys[i], serValues[i], true);
            }
    
            m_siInfo=null;
        }
    
    
        // Implements a Collection for the keys of a hashtable. An instance of this
        // class is created by the GetKeys method of a hashtable.
		 [Serializable()]
        private class KeyCollection : ICollection
        {
            private Hashtable _hashtable;
            
            internal KeyCollection(Hashtable hashtable) {
                _hashtable = hashtable;
            }
            
            public virtual void CopyTo(Array array, int arrayIndex) {
                if (array==null)
                    throw new ArgumentNullException("array");
                if (array.Rank != 1)
                    throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
				if (arrayIndex < 0) 
                    throw new ArgumentOutOfRangeException("arrayIndex", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (array.Length - arrayIndex < _hashtable.count)
                    throw new ArgumentException(Environment.GetResourceString("Arg_ArrayPlusOffTooSmall"));
                _hashtable.CopyKeys(array, arrayIndex);
            }
            
            public virtual IEnumerator GetEnumerator() {
                return new HashtableEnumerator(_hashtable, HashtableEnumerator.Keys);
            }
            
            public virtual bool IsReadOnly {
                get { return true; }
            }
    
            public virtual bool IsSynchronized {
                get { return _hashtable.IsSynchronized; }
            }

    		public virtual Object SyncRoot {
    			get { return _hashtable.SyncRoot; }
    		}
    		
    		public virtual int Count { 
    			get { return _hashtable.count; }
    		}
        }
        
        // Implements a Collection for the values of a hashtable. An instance of
        // this class is created by the GetValues method of a hashtable.
		 [Serializable()]
        private class ValueCollection : ICollection
        {
            private Hashtable _hashtable;
            
            internal ValueCollection(Hashtable hashtable) {
                _hashtable = hashtable;
            }
            
            public virtual void CopyTo(Array array, int arrayIndex) {
                if (array==null)
                    throw new ArgumentNullException("array");
                if (array.Rank != 1)
                    throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
                if (arrayIndex < 0) 
                    throw new ArgumentOutOfRangeException("arrayIndex", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (array.Length - arrayIndex < _hashtable.count)
                    throw new ArgumentException(Environment.GetResourceString("Arg_ArrayPlusOffTooSmall"));
                _hashtable.CopyValues(array, arrayIndex);
            }
            
            public virtual IEnumerator GetEnumerator() {
                return new HashtableEnumerator(_hashtable, HashtableEnumerator.Values);
            }
            
            public virtual bool IsReadOnly {
                get { return true; }
            }
    
            public virtual bool IsSynchronized {
                get { return _hashtable.IsSynchronized; }
            }

    		public virtual Object SyncRoot { 
    			get { return _hashtable.SyncRoot; }
    		}
    		
    		public virtual int Count { 
    			get { return _hashtable.count; }
    		}
        }
    
        // Synchronized wrapper for hashtable
        [Serializable()]
        private class SyncHashtable : Hashtable
        {
            protected Hashtable _table;
    
            internal SyncHashtable(Hashtable table) {
                _table = table;
            }

            internal SyncHashtable(SerializationInfo info, StreamingContext context) : base (info, context) {
                _table = (Hashtable)info.GetValue("ParentTable", typeof(Hashtable));
                if (_table==null) {
                    throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientState"));
                }
            }
    

            /*================================GetObjectData=================================
            **Action: Return a serialization info containing a reference to _table.  We need
            **        to implement this because our parent HT does and we don't want to actually
            **        serialize all of it's values (just a reference to the table, which will then
            **        be serialized separately.)
            **Returns: void
            **Arguments: info -- the SerializationInfo into which to store the data.
            **           context -- the StreamingContext for the current serialization (ignored)
            **Exceptions: ArgumentNullException if info is null.
            ==============================================================================*/
            public override void GetObjectData(SerializationInfo info, StreamingContext context) {
                if (info==null) {
                    throw new ArgumentNullException("info");
                }
                info.AddValue("ParentTable", _table, typeof(Hashtable));
            }

    		public override int Count { 
    			get { return _table.Count; }
    		}
    
    		public override bool IsReadOnly { 
    			get { return _table.IsReadOnly; }
    		}
		
			public override bool IsFixedSize {
				get { return _table.IsFixedSize; }
			}
            
    		public override bool IsSynchronized { 
    			get { return true; }
    		}

            public override Object this[Object key] {
                get {
                        return _table[key];
                }
                set {
                    lock(_table.SyncRoot) {
                        _table[key] = value;
                    }
                }
            }
    
            public override Object SyncRoot {
                get { return _table.SyncRoot; }
            }
    
            public override void Add(Object key, Object value) {
                lock(_table.SyncRoot) {
                    _table.Add(key, value);
                }
            }
    
            public override void Clear() {
                lock(_table.SyncRoot) {
                    _table.Clear();
                }
            }
    
            public override bool Contains(Object key) {
                return _table.Contains(key);
            }
    
            public override bool ContainsKey(Object key) {
                return _table.ContainsKey(key);
            }
    
            public override bool ContainsValue(Object key) {
                return _table.ContainsValue(key);
            }
    
            public override void CopyTo(Array array, int arrayIndex) {
                _table.CopyTo(array, arrayIndex);
            }

			public override Object Clone() {
                lock (_table.SyncRoot) {
                    return Hashtable.Synchronized((Hashtable)_table.Clone());
                }
            }
    
            public override IDictionaryEnumerator GetEnumerator() {
                return _table.GetEnumerator();
            }
    
            protected override int GetHash(Object key) {
                return _table.GetHash(key);
	        }
    
            protected override bool KeyEquals(Object item, Object key) {
                return _table.KeyEquals(item, key);
            }

            public override ICollection Keys {
                get {
                    lock(_table.SyncRoot) {
                        return _table.Keys;
                    }
                }
            }
    
            public override ICollection Values {
                get {
                    lock(_table.SyncRoot) {
                        return _table.Values;
                    }
                }
            }
    
            public override void Remove(Object key) {
                lock(_table.SyncRoot) {
                    _table.Remove(key);
                }
            }
            
            /*==============================OnDeserialization===============================
            **Action: Does nothing.  We have to implement this because our parent HT implements it,
            **        but it doesn't do anything meaningful.  The real work will be done when we
            **        call OnDeserialization on our parent table.
            **Returns: void
            **Arguments: None
            **Exceptions: None
            ==============================================================================*/
            public override void OnDeserialization(Object sender) {
                return;
            }
        }
    
    
        // Implements an enumerator for a hashtable. The enumerator uses the
        // internal version number of the hashtabke to ensure that no modifications
        // are made to the hashtable while an enumeration is in progress.
        [Serializable()] private class HashtableEnumerator : IDictionaryEnumerator, ICloneable
        {
            private Hashtable hashtable;
            private int bucket;
            private int version;
    	    private bool current;
            private int getObjectRetType;   // What should GetObject return?
			private Object currentKey;
			private Object currentValue;
            
            internal const int Keys = 1;
            internal const int Values = 2;
            internal const int DictEntry = 3;
            
            internal HashtableEnumerator(Hashtable hashtable, int getObjRetType) {
                this.hashtable = hashtable;
                bucket = hashtable.buckets.Length;
                version = hashtable.version;
    			current = false;
                getObjectRetType = getObjRetType;
            }

            public Object Clone() {
                return MemberwiseClone();
            }
    
            public virtual Object Key {
                get {
                    if (version != hashtable.version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                    if (current == false) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                    return currentKey;
                }
            }
            
            public virtual bool MoveNext() {
    			if (version != hashtable.version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                while (bucket > 0) {
                    bucket--;
                    Object keyv = hashtable.buckets[bucket].key;
                    if ((keyv!= null) && (keyv != hashtable.buckets)) {
						currentKey = keyv;
						currentValue = hashtable.buckets[bucket].val;
                        current = true;
                        return true;
                    }
                }
    			current = false;
                return false;
            }
            
            public virtual DictionaryEntry Entry {
                get {
                    if (current == false) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumOpCantHappen));
                    return new DictionaryEntry(currentKey, currentValue);
                }
            }
    
    
            public virtual Object Current {
                get {
                    if (current == false) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumOpCantHappen));
                    
                    if (getObjectRetType==Keys)
                        return currentKey;
                    else if (getObjectRetType==Values)
                        return currentValue;
                    else 
                        return new DictionaryEntry(currentKey, currentValue);
                }
            }
            
            public virtual Object Value {
                get {
                    if (version != hashtable.version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                    if (current == false) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumOpCantHappen));
                    return currentValue;
                }
            }
    
            public virtual void Reset() {
                if (version != hashtable.version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                current = false;
                bucket = hashtable.buckets.Length;
				currentKey = null;
				currentValue = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\idictionaryenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IDictionaryEnumerator
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Base interface for dictionary enumerators.
**
** Date:  September 20, 1999
** 
===========================================================*/
namespace System.Collections {
	// Interfaces are not serializable
    
	using System;
    // This interface represents an enumerator that allows sequential access to the
    // elements of a dictionary. Upon creation, an enumerator is conceptually
    // positioned before the first element of the enumeration. The first call to the
    // MoveNext method brings the first element of the enumeration into view,
    // and each successive call to MoveNext brings the next element into
    // view until MoveNext returns false, indicating that there are no more
    // elements to enumerate. Following each call to MoveNext, the
    // Key and Value methods are used to obtain the key and
    // value of the element currently in view. The values returned by calls to
    // Key and Value are undefined before the first call to
    // MoveNext and following a call to MoveNext that returned false.
    // Enumerators are typically used in while loops of the form
    // 
    // IDictionaryEnumerator e = ...;
    // while (e.MoveNext()) {
    //     Object key = e.Key;
    //     Object value = e.Value;
    //     ...
    // }
    // 
    // The IDictionaryEnumerator interface extends the IEnumerator
    // inerface and can thus be used as a regular enumerator. The Current 
    // method of an IDictionaryEnumerator returns a DictionaryEntry containing
    // the current key and value pair.  However, the GetEntry method will
    // return the same DictionaryEntry and avoids boxing the DictionaryEntry (boxing
    // is somewhat expensive).
    // 
    /// <include file='doc\IDictionaryEnumerator.uex' path='docs/doc[@for="IDictionaryEnumerator"]/*' />
    public interface IDictionaryEnumerator : IEnumerator
    {
        // Returns the key of the current element of the enumeration. The returned
        // value is undefined before the first call to GetNext and following
        // a call to GetNext that returned false. Multiple calls to
        // GetKey with no intervening calls to GetNext will return
        // the same object.
        // 
        /// <include file='doc\IDictionaryEnumerator.uex' path='docs/doc[@for="IDictionaryEnumerator.Key"]/*' />
        Object Key {
            get; 
        }
        
        // Returns the value of the current element of the enumeration. The
        // returned value is undefined before the first call to GetNext and
        // following a call to GetNext that returned false. Multiple calls
        // to GetValue with no intervening calls to GetNext will
        // return the same object.
        // 
        /// <include file='doc\IDictionaryEnumerator.uex' path='docs/doc[@for="IDictionaryEnumerator.Value"]/*' />
        Object Value {
            get;
        }
    	
    	// GetBlock will copy dictionary values into the given Array.  It will either
    	// fill up the array, or if there aren't enough elements, it will
    	// copy as much as possible into the Array.  The number of elements
    	// copied is returned.
    	// 
    	/// <include file='doc\IDictionaryEnumerator.uex' path='docs/doc[@for="IDictionaryEnumerator.Entry"]/*' />
    	DictionaryEntry Entry {
            get; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\ilist.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IList
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Base interface for all Lists.
**
** Date:  September 21, 1999
** 
===========================================================*/
namespace System.Collections {
    
	using System;
    // An IList is an ordered collection of objects.  The exact ordering
    // is up to the implementation of the list, ranging from a sorted
    // order to insertion order.  
    /// <include file='doc\IList.uex' path='docs/doc[@for="IList"]/*' />
    public interface IList : ICollection
    {
	// Interfaces are not serializable
        // The Item property provides methods to read and edit entries in the List.
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.this"]/*' />
        Object this[int index] {
            get;
            set;
        }
    
        // Adds an item to the list.  The exact position in the list is 
        // implementation-dependent, so while ArrayList may always insert
        // in the last available location, a SortedList most likely would not.
        // The return value is the position the new element was inserted in.
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.Add"]/*' />
        int Add(Object value);
    
        // Returns whether the list contains a particular item.
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.Contains"]/*' />
        bool Contains(Object value);
    
        // Removes all items from the list.
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.Clear"]/*' />
        void Clear();
	    /// <include file='doc\IList.uex' path='docs/doc[@for="IList.IsReadOnly"]/*' />

	    bool IsReadOnly 
        { get; }
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.IsFixedSize"]/*' />

	
        bool IsFixedSize
        {
			get;
		}

	    
        // Returns the index of a particular item, if it is in the list.
        // Returns -1 if the item isn't in the list.
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.IndexOf"]/*' />
        int IndexOf(Object value);
    
        // Inserts value into the list at position index.
        // index must be non-negative and less than or equal to the 
        // number of elements in the list.  If index equals the number
        // of items in the list, then value is appended to the end.
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.Insert"]/*' />
        void Insert(int index, Object value);
    
        // Removes an item from the list.
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.Remove"]/*' />
        void Remove(Object value);
    
        // Removes the item at position index.
        /// <include file='doc\IList.uex' path='docs/doc[@for="IList.RemoveAt"]/*' />
        void RemoveAt(int index);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\ienumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IEnumerator
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Base interface for all enumerators.
**
** Date:  June 14, 1999
** 
===========================================================*/
namespace System.Collections {    
    using System;
    using System.Runtime.InteropServices;

    // Base interface for all enumerators, providing a simple approach
    // to iterating over a collection.
    /// <include file='doc\IEnumerator.uex' path='docs/doc[@for="IEnumerator"]/*' />
    [Guid("496B0ABF-CDEE-11d3-88E8-00902754C43A")]
    public interface IEnumerator
    {
	// Interfaces are not serializable
        // Advances the enumerator to the next element of the enumeration and
        // returns a boolean indicating whether an element is available. Upon
        // creation, an enumerator is conceptually positioned before the first
        // element of the enumeration, and the first call to MoveNext 
        // brings the first element of the enumeration into view.
        // 
        /// <include file='doc\IEnumerator.uex' path='docs/doc[@for="IEnumerator.MoveNext"]/*' />
        bool MoveNext();
    
        // Returns the current element of the enumeration. The returned value is
        // undefined before the first call to MoveNext and following a
        // call to MoveNext that returned false. Multiple calls to
        // GetCurrent with no intervening calls to MoveNext 
        // will return the same object.
        // 
        /// <include file='doc\IEnumerator.uex' path='docs/doc[@for="IEnumerator.Current"]/*' />
        Object Current {
            get; 
        }
    
        // Resets the enumerator to the beginning of the enumeration, starting over.
        // The preferred behavior for Reset is to return the exact same enumeration.
        // This means if you modify the underlying collection then call Reset, your
        // IEnumerator will be invalid, just as it would have been if you had called
        // MoveNext or Current.
        //
        /// <include file='doc\IEnumerator.uex' path='docs/doc[@for="IEnumerator.Reset"]/*' />
        void Reset();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\ienumerable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface:  IEnumerable
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Interface for classes providing IEnumerators
**
** Date:  November 8, 1999
** 
===========================================================*/
namespace System.Collections {
	using System;
	using System.Runtime.InteropServices;
    // Implement this interface if you need to support VB's foreach semantics.
    // Also, COM classes that support an enumerator will also implement this interface.
    /// <include file='doc\IEnumerable.uex' path='docs/doc[@for="IEnumerable"]/*' />
    [Guid("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
    public interface IEnumerable
    {
	// Interfaces are not serializable
        // Returns an IEnumerator for this enumerable Object.  The enumerator provides
        // a simple way to access all the contents of a collection.
        /// <include file='doc\IEnumerable.uex' path='docs/doc[@for="IEnumerable.GetEnumerator"]/*' />
        [DispId(-4)]
        IEnumerator GetEnumerator();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\ihashcodeprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: IHashCodeProvider
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: A bunch of strings.
**
** Date: July 21, 1999
** 
===========================================================*/
namespace System.Collections {
    
	using System;
    // Provides a mechanism for a hash table user to override the default
    // GetHashCode() function on Objects, providing their own hash function.
    /// <include file='doc\IHashCodeProvider.uex' path='docs/doc[@for="IHashCodeProvider"]/*' />
    public interface IHashCodeProvider 
    {
	// Interfaces are not serializable
    	// Returns a hash code for the given object.  
    	// 
    	/// <include file='doc\IHashCodeProvider.uex' path='docs/doc[@for="IHashCodeProvider.GetHashCode"]/*' />
    	int GetHashCode (Object obj);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\readonlycollectionbase.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

namespace System.Collections {

    using System;

    // Useful base class for typed readonly collections where items derive from object
    /// <include file='doc\ReadOnlyCollectionBase.uex' path='docs/doc[@for="ReadOnlyCollectionBase"]/*' />
	[Serializable]
    public abstract class ReadOnlyCollectionBase : ICollection {
        ArrayList list;

        /// <include file='doc\ReadOnlyCollectionBase.uex' path='docs/doc[@for="ReadOnlyCollectionBase.InnerList"]/*' />
        protected ArrayList InnerList {
            get { 
                if (list == null)
                    list = new ArrayList();
                 return list; 
            }
        }

        /// <include file='doc\ReadOnlyCollectionBase.uex' path='docs/doc[@for="ReadOnlyCollectionBase.Count"]/*' />
        public int Count {
            get { return InnerList.Count; }
        }

        /// <include file='doc\ReadOnlyCollectionBase.uex' path='docs/doc[@for="ReadOnlyCollectionBase.ICollection.IsSynchronized"]/*' />
        bool ICollection.IsSynchronized {
            get { return InnerList.IsSynchronized; }
        }

        /// <include file='doc\ReadOnlyCollectionBase.uex' path='docs/doc[@for="ReadOnlyCollectionBase.ICollection.SyncRoot"]/*' />
        object ICollection.SyncRoot {
            get { return InnerList.SyncRoot; }
        }

        /// <include file='doc\ReadOnlyCollectionBase.uex' path='docs/doc[@for="ReadOnlyCollectionBase.ICollection.CopyTo"]/*' />
        void ICollection.CopyTo(Array array, int index) {
            InnerList.CopyTo(array, index);
        }

        /// <include file='doc\ReadOnlyCollectionBase.uex' path='docs/doc[@for="ReadOnlyCollectionBase.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return InnerList.GetEnumerator();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\queue.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Queue
**
** Author: Brian Grunkemeyer (BrianGru), Rajesh Chandrashekaran (rajeshc)
**         Original implementation by Derek Yenser
**
** Purpose: A circular-array implementation of a queue.
**
** Date: October 4, 1999
**
=============================================================================*/
namespace System.Collections {
    using System;

    // A simple Queue of objects.  Internally it is implemented as a circular
    // buffer, so Enqueue can be O(n).  Dequeue is O(1).
    /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue"]/*' />
    [Serializable()] public class Queue : ICollection, ICloneable {
        private Object[] _array;
        private int _head;       // First valid element in the queue
        private int _tail;       // Last valid element in the queue
        private int _size;       // Number of elements.
        private int _growFactor; // 100 == 1.0, 130 == 1.3, 200 == 2.0
    	private int _version;
    	
        private const int _MinimumGrow = 4;
        private const int _ShrinkThreshold = 32;
    
        // Creates a queue with room for capacity objects. The default initial
        // capacity and grow factor are used.
        /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Queue"]/*' />
        public Queue() 
            : this(32, (float)2.0) {
        }
    
        // Creates a queue with room for capacity objects. The default grow factor
        // is used.
        //
        /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Queue1"]/*' />
        public Queue(int capacity) 
            : this(capacity, (float)2.0) {
        }
        
        // Creates a queue with room for capacity objects. When full, the new
        // capacity is set to the old capacity * growFactor.
        //
        /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Queue2"]/*' />
        public Queue(int capacity, float growFactor) {
    		if (capacity < 0)
    			throw new ArgumentOutOfRangeException("capacity", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (!(growFactor >= 1.0 && growFactor <= 10.0))
                throw new ArgumentOutOfRangeException("growFactor", String.Format(Environment.GetResourceString("ArgumentOutOfRange_QueueGrowFactor"), 1, 10));
    
            _array = new Object[capacity];
            _head = 0;
            _tail = 0;
            _size = 0;
            _growFactor = (int)(growFactor * 100);
        }
    
        // Fills a Queue with the elements of an ICollection.  Uses the enumerator
        // to get each of the elements.
        //
        /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Queue3"]/*' />
        public Queue(ICollection col) : this((col==null ? 32 : col.Count))
        {
            if (col==null)
                throw new ArgumentNullException("col");
            IEnumerator en = col.GetEnumerator();
            while(en.MoveNext())
                Enqueue(en.Current);
        }
    
    
    	/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Count"]/*' />
    	public virtual int Count {
    		get { return _size; }
    	}
    	
		/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Clone"]/*' />
		public virtual Object Clone() {
			Queue q = new Queue(_size);
			q._size = _size;
            Array.Copy(_array, 0, q._array, 0, _size);
			q._version = _version;
			return q;
		}

    	/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.IsSynchronized"]/*' />
    	public virtual bool IsSynchronized {
    		get { return false; }
    	}
    	
    	/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.SyncRoot"]/*' />
    	public virtual Object SyncRoot {
    		get { return this; }
    	}
    	
        // Removes all Objects from the queue.
        /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Clear"]/*' />
        public virtual void Clear() {
            if (_head < _tail)
                Array.Clear(_array, _head, _size);
            else {
                Array.Clear(_array, _head, _array.Length - _head);
                Array.Clear(_array, 0, _tail);
            }
    
            _head = 0;
            _tail = 0;
            _size = 0;
    		_version++;
        }
    
    	// CopyTo copies a collection into an Array, starting at a particular
    	// index into the array.
    	// 
    	/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.CopyTo"]/*' />
    	public virtual void CopyTo(Array array, int index)
    	{
    		if (array==null)
    			throw new ArgumentNullException("array");
            if (array.Rank != 1)
                throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
    		if (index < 0)
    			throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            int arrayLen = array.Length;
            if (arrayLen - index < _size)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
    		int numToCopy = (arrayLen-index < _size) ? arrayLen-index : _size;
            if (numToCopy==0)
                return;
    		if (_head < _tail) {
    			Array.Copy(_array, _head, array, index, numToCopy);
    		} else {
    			int firstPart = (_array.Length - _head < numToCopy) ? _array.Length - _head : numToCopy;
    			Array.Copy(_array, _head, array, index, firstPart);
    			numToCopy -= firstPart;
    			Array.Copy(_array, 0, array, index+_array.Length - _head, numToCopy);
    		}
    	}
    	
        // Adds obj to the tail of the queue.
        //
        /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Enqueue"]/*' />
        public virtual void Enqueue(Object obj) {
            if (_size == _array.Length) {
                int newcapacity = (int)((long)_array.Length * (long)_growFactor / 100);
                if (newcapacity < _array.Length + _MinimumGrow) {
                    newcapacity = _array.Length + _MinimumGrow;
                }
                SetCapacity(newcapacity);
            }
    
            _array[_tail] = obj;
            _tail = (_tail + 1) % _array.Length;
            _size++;
    		_version++;
        }
    
    	// GetEnumerator returns an IEnumerator over this Queue.  This
    	// Enumerator will support removing.
    	// 
    	/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.GetEnumerator"]/*' />
    	public virtual IEnumerator GetEnumerator()
    	{
    		return new QueueEnumerator(this);
    	}
    
        // Removes the object at the head of the queue and returns it. If the queue
        // is empty, this method simply returns null.
        /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Dequeue"]/*' />
        public virtual Object Dequeue() {
            if (_size == 0)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EmptyQueue"));
    
            Object removed = _array[_head];
            _array[_head] = null;
            _head = (_head + 1) % _array.Length;
            _size--;
    		_version++;
            return removed;
        }
    
        // Returns the object at the head of the queue. The object remains in the
        // queue. If the queue is empty, this method throws an 
        // InvalidOperationException.
        /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Peek"]/*' />
        public virtual Object Peek() {
            if (_size == 0)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EmptyQueue"));
    
            return _array[_head];
        }
    
    	// Returns a synchronized Queue.  Returns a synchronized wrapper
    	// class around the queue - the caller must not use references to the
    	// original queue.
    	// 
    	/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Synchronized"]/*' />
    	public static Queue Synchronized(Queue queue)
    	{
    		if (queue==null)
    			throw new ArgumentNullException("queue");
    		return new SynchronizedQueue(queue);
    	}
    	
        // Returns true if the queue contains at least one object equal to obj.
        // Equality is determined using obj.Equals().
        //
        // Exceptions: ArgumentNullException if obj == null.
       /// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.Contains"]/*' />
       public virtual bool Contains(Object obj) {
    		int index = _head;
            int count = _size;
    
            while (count-- > 0) {
                if (obj == null) {
                    if (_array[index] == null)
                        return true;
                } else if (obj.Equals(_array[index])) {
                    return true;
                }
                index = (index + 1) % _array.Length;
            }
    
            return false;
        }
    
        internal Object GetElement(int i)
        {
            return _array[(_head + i) % _array.Length];
        }
    
        // Iterates over the objects in the queue, returning an array of the
        // objects in the Queue, or an empty array if the queue is empty.
        // The order of elements in the array is first in to last in, the same
        // order produced by successive calls to Dequeue.
    	/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.ToArray"]/*' />
    	public virtual Object[] ToArray()
    	{
    		Object[] arr = new Object[_size];
            if (_size==0)
                return arr;
    
            if (_head < _tail) {
                Array.Copy(_array, _head, arr, 0, _size);
            } else {
                Array.Copy(_array, _head, arr, 0, _array.Length - _head);
                Array.Copy(_array, 0, arr, _array.Length - _head, _tail);
            }
    
    		return arr;
    	}
    
    
        // PRIVATE Grows or shrinks the buffer to hold capacity objects. Capacity
        // must be >= _size.
        private void SetCapacity(int capacity) {
            Object[] newarray = new Object[capacity];
            if (_size > 0) {
                if (_head < _tail) {
                    Array.Copy(_array, _head, newarray, 0, _size);
                } else {
                    Array.Copy(_array, _head, newarray, 0, _array.Length - _head);
                    Array.Copy(_array, 0, newarray, _array.Length - _head, _tail);
                }
            }
    
            _array = newarray;
            _head = 0;
            _tail = _size;
    		_version++;
        }
    
	/// <include file='doc\Queue.uex' path='docs/doc[@for="Queue.TrimToSize"]/*' />
        public virtual void TrimToSize()
        {
            SetCapacity(_size);
        }
    
    	
    	// Implements a synchronization wrapper around a queue.
        [Serializable()] private class SynchronizedQueue : Queue
        {
            private Queue _q;
            private Object root;
    
            internal SynchronizedQueue(Queue q) {
                this._q = q;
                root = _q.SyncRoot;
            }
            
    		public override bool IsSynchronized {
    			get { return true; }
    		}
    
    		public override Object SyncRoot {
    			get {
    				return root;
    		    }
    		}
    
    		public override int Count { 
    			get { 
    				lock (root) {
    					return _q.Count;
                    } 
    			}
    		}
    	  
            public override void Clear() {
                lock (root) {
                    _q.Clear();
                }
            }

			public override Object Clone() {
                lock (root) {
                    return new SynchronizedQueue((Queue)_q.Clone());
                }
            }
    
			public override bool Contains(Object obj) {
                lock (root) {
                    return _q.Contains(obj);
                }
            }

            public override void CopyTo(Array array, int arrayIndex) {
                lock (root) {
                    _q.CopyTo(array, arrayIndex);
                }
            }
    
            public override void Enqueue(Object value) {
                lock (root) {
                    _q.Enqueue(value);
                }
            }
    
            public override Object Dequeue() {
                lock (root) {
                    return _q.Dequeue();
                }
            }
    
    		public override IEnumerator GetEnumerator() {
                lock (root) {
                    return _q.GetEnumerator();
                }
            }
    
            public override Object Peek() {
                lock (root) {
                    return _q.Peek();
                }
            }
    
            public override Object[] ToArray() {
                lock (root) {
                    return _q.ToArray();
                }
            }

            public override void TrimToSize() {
               lock (root) {
                    _q.TrimToSize();
                }
            }
        }	
    	
    	
        // Implements an enumerator for a Queue.  The enumerator uses the
        // internal version number of the list to ensure that no modifications are
        // made to the list while an enumeration is in progress.
        [Serializable()] private class QueueEnumerator : IEnumerator, ICloneable
        {
            private Queue _q;
            private int _index;
            private int _version;
            private Object currentElement;
    
            internal QueueEnumerator(Queue q) {
                _q = q;
                _version = _q._version;
    			_index = 0;
				currentElement = _q._array;
                if (_q._size == 0)
                    _index = -1;
            }

            public Object Clone()
            {
                return MemberwiseClone();
            }

            public virtual bool MoveNext() {
				if (_version != _q._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
    			
                if (_index < 0) {  
    			    currentElement = _q._array;
                   	return false;
    			}

                currentElement = _q.GetElement(_index);
                _index++;

                if (_index == _q._size)
                    _index = -1;
    			return true;
            }
    
            public virtual Object Current {
                get {
                    if (currentElement == _q._array)
                    {
                        if (_index == 0)
                            throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
                        else
					        throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                    }
                    return currentElement;
                }
            }
    
            public virtual void Reset() {
                if (_version != _q._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                if (_q._size == 0)
                    _index = -1;
                 else
                     _index = 0;
				currentElement = _q._array;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\sortedlist.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SortedList
**
** Author: Brian Grunkemeyer (BrianGru), Rajesh Chandrashekaran (rajeshc)
**         Original implementation by Anders Hejlsberg
**
** Purpose: A sorted dictionary.
**
** Date:  September 21, 1999
** 
===========================================================*/
namespace System.Collections {
    using System;

    // The SortedList class implements a sorted list of keys and values. Entries in
    // a sorted list are sorted by their keys and are accessible both by key and by
    // index. The keys of a sorted list can be ordered either according to a
    // specific IComparer implementation given when the sorted list is
    // instantiated, or according to the IComparable implementation provided
    // by the keys themselves. In either case, a sorted list does not allow entries
    // with duplicate keys.
    // 
    // A sorted list internally maintains two arrays that store the keys and
    // values of the entries. The capacity of a sorted list is the allocated
    // length of these internal arrays. As elements are added to a sorted list, the
    // capacity of the sorted list is automatically increased as required by
    // reallocating the internal arrays.  The capacity is never automatically 
    // decreased, but users can call either TrimToSize or 
    // Capacity explicitly.
    // 
    // The GetKeyList and GetValueList methods of a sorted list
    // provides access to the keys and values of the sorted list in the form of
    // List implementations. The List objects returned by these
    // methods are aliases for the underlying sorted list, so modifications
    // made to those lists are directly reflected in the sorted list, and vice
    // versa.
    // 
    // The SortedList class provides a convenient way to create a sorted
    // copy of another dictionary, such as a Hashtable. For example:
    // 
    // Hashtable h = new Hashtable();
    // h.Add(...);
    // h.Add(...);
    // ...
    // SortedList s = new SortedList(h);
    // 
    // The last line above creates a sorted list that contains a copy of the keys
    // and values stored in the hashtable. In this particular example, the keys
    // will be ordered according to the IComparable interface, which they
    // all must implement. To impose a different ordering, SortedList also
    // has a constructor that allows a specific IComparer implementation to
    // be specified.
    // 
    // By Anders Hejlsberg, further work by Brian Grunkemeyer
    // version 1.10 9/10/98
    /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList"]/*' />
    [Serializable()] public class SortedList : IDictionary, ICloneable
    {
    	private Object[] keys;
        private Object[] values;
        private int _size;
    	private int version;
        private IComparer comparer;
        private KeyList keyList;
        private ValueList valueList;
    
        private const int _defaultCapacity = 16;
    
        // Constructs a new sorted list. The sorted list is initially empty and has
        // a capacity of zero. Upon adding the first element to the sorted list the
        // capacity is increased to 16, and then increased in multiples of two as
        // required. The elements of the sorted list are ordered according to the
        // IComparable interface, which must be implemented by the keys of
        // all entries added to the sorted list.
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.SortedList"]/*' />
        public SortedList() {
            keys = new Object[_defaultCapacity];
            values = new Object[_defaultCapacity];
            comparer = Comparer.Default;
        }
    
        // Constructs a new sorted list. The sorted list is initially empty and has
        // a capacity of zero. Upon adding the first element to the sorted list the
        // capacity is increased to 16, and then increased in multiples of two as
        // required. The elements of the sorted list are ordered according to the
        // IComparable interface, which must be implemented by the keys of
        // all entries added to the sorted list.
        //
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.SortedList1"]/*' />
        public SortedList(int initialCapacity) {
            if (initialCapacity < 0)
                throw new ArgumentOutOfRangeException("initialCapacity", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            keys = new Object[initialCapacity];
            values = new Object[initialCapacity];
            comparer = Comparer.Default;
        }
    
        // Constructs a new sorted list with a given IComparer
        // implementation. The sorted list is initially empty and has a capacity of
        // zero. Upon adding the first element to the sorted list the capacity is
        // increased to 16, and then increased in multiples of two as required. The
        // elements of the sorted list are ordered according to the given
        // IComparer implementation. If comparer is null, the
        // elements are compared to each other using the IComparable
        // interface, which in that case must be implemented by the keys of all
        // entries added to the sorted list.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.SortedList2"]/*' />
        public SortedList(IComparer comparer) 
            : this() {
            if (comparer != null) this.comparer = comparer;
        }
    
        // Constructs a new sorted list with a given IComparer
        // implementation and a given initial capacity. The sorted list is
        // initially empty, but will have room for the given number of elements
        // before any reallocations are required. The elements of the sorted list
        // are ordered according to the given IComparer implementation. If
        // comparer is null, the elements are compared to each other using
        // the IComparable interface, which in that case must be implemented
        // by the keys of all entries added to the sorted list.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.SortedList3"]/*' />
        public SortedList(IComparer comparer, int capacity) 
            : this(comparer) {
            Capacity = capacity;
        }
    
        // Constructs a new sorted list containing a copy of the entries in the
        // given dictionary. The elements of the sorted list are ordered according
        // to the IComparable interface, which must be implemented by the
        // keys of all entries in the the given dictionary as well as keys
        // subsequently added to the sorted list.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.SortedList4"]/*' />
        public SortedList(IDictionary d) 
            : this(d, null) {
        }
        
        // Constructs a new sorted list containing a copy of the entries in the
        // given dictionary. The elements of the sorted list are ordered according
        // to the given IComparer implementation. If comparer is
        // null, the elements are compared to each other using the
        // IComparable interface, which in that case must be implemented
        // by the keys of all entries in the the given dictionary as well as keys
        // subsequently added to the sorted list.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.SortedList5"]/*' />
        public SortedList(IDictionary d, IComparer comparer) 
    		: this(comparer, (d != null ? d.Count : 0)) {
    		if (d==null)
    			throw new ArgumentNullException("d", Environment.GetResourceString("ArgumentNull_Dictionary"));
            d.Keys.CopyTo(keys, 0);
            d.Values.CopyTo(values, 0);
            Array.Sort(keys, values, comparer);
            _size = d.Count;
        }
        
        // Adds an entry with the given key and value to this sorted list. An
        // ArgumentException is thrown if the key is already present in the sorted list.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Add"]/*' />
        public virtual void Add(Object key, Object value) {
            if (key == null) throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));
            int i = Array.BinarySearch(keys, 0, _size, key, comparer);
            if (i >= 0)
    			throw new ArgumentException(Environment.GetResourceString("Argument_AddingDuplicate__", GetKey(i), key));
            Insert(~i, key, value);
        }
        
        // Returns the capacity of this sorted list. The capacity of a sorted list
        // represents the allocated length of the internal arrays used to store the
        // keys and values of the list, and thus also indicates the maximum number
        // of entries the list can contain before a reallocation of the internal
        // arrays is required.
        // 
         /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Capacity"]/*' />
         public virtual int Capacity {
    		get {
    			return keys.Length;
    		}
    		set {
    	        if (value != keys.Length) {
    		        if (value < _size) throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_SmallCapacity"));
    			    if (value > 0) {
    				    Object[] newKeys = new Object[value];
    					Object[] newValues = new Object[value];
    	                if (_size > 0) {
    		                Array.Copy(keys, 0, newKeys, 0, _size);
    			            Array.Copy(values, 0, newValues, 0, _size);
    				    }
    					keys = newKeys;
    	                values = newValues;
    		        }
    			    else {
    				    keys = new Object[_defaultCapacity];
    					values = new Object[_defaultCapacity];
    	            }
    		    }
    		}
        }
    
        // Returns the number of entries in this sorted list.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Count"]/*' />
        public virtual int Count {
    		get {
    			return _size;
    		}
        }
    
        // Returns a collection representing the keys of this sorted list. This
        // method returns the same object as GetKeyList, but typed as an
        // ICollection instead of an IList.
        // 
         /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Keys"]/*' />
         public virtual ICollection Keys {
    		get {
    		   return GetKeyList();
    		}
        }
    
        // Returns a collection representing the values of this sorted list. This
        // method returns the same object as GetValueList, but typed as an
        // ICollection instead of an IList.
        // 
         /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Values"]/*' />
         public virtual ICollection Values {
    		get {
    			return GetValueList();
    		}
        }
    
        // Is this SortedList read-only?
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.IsReadOnly"]/*' />
        public virtual bool IsReadOnly {
            get { return false; }
        }

		/// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.IsFixedSize"]/*' />
		public virtual bool IsFixedSize {
    		get { return false; }
    	}

        // Is this SortedList synchronized (thread-safe)?
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.IsSynchronized"]/*' />
        public virtual bool IsSynchronized {
            get { return false; }
        }
    
        // Synchronization root for this object.
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.SyncRoot"]/*' />
        public virtual Object SyncRoot {
            get { return this; }
        }
    
        // Removes all entries from this sorted list.
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Clear"]/*' />
        public virtual void Clear() {
            version++;
            _size = 0;
            keys = new Object[_defaultCapacity];
            values = new Object[_defaultCapacity];
        }
    
        // Makes a virtually identical copy of this SortedList.  This is a shallow 
        // copy.  IE, the Objects in the SortedList are not cloned - we copy the 
        // references to those objects.
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Clone"]/*' />
        public virtual Object Clone()
        {
            SortedList sl = new SortedList(_size);
            Array.Copy(keys, 0, sl.keys, 0, _size);
            Array.Copy(values, 0, sl.values, 0, _size);
            sl._size = _size;
            sl.version = version;
            sl.comparer = comparer;
            // Don't copy keyList nor valueList.
            return sl;
        }
    
    
        // Checks if this sorted list contains an entry with the given key.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Contains"]/*' />
        public virtual bool Contains(Object key) {
            return IndexOfKey(key) >= 0;
        }
    
        // Checks if this sorted list contains an entry with the given key.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.ContainsKey"]/*' />
        public virtual bool ContainsKey(Object key) {
            // Yes, this is a SPEC'ed duplicate of Contains().
            return IndexOfKey(key) >= 0;
        }
    
        // Checks if this sorted list contains an entry with the given value. The
        // values of the entries of the sorted list are compared to the given value
        // using the Object.Equals method. This method performs a linear
        // search and is substantially slower than the Contains
        // method.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.ContainsValue"]/*' />
        public virtual bool ContainsValue(Object value) {
            return IndexOfValue(value) >= 0;
        }
    
    	// Copies the values in this SortedList to an array.
    	/// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.CopyTo"]/*' />
    	public virtual void CopyTo(Array array, int arrayIndex) {
            if (array == null)
    		throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Array"));
            if (array.Rank != 1)
                throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
    	    if (arrayIndex < 0) 
    		throw new ArgumentOutOfRangeException("arrayIndex", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - arrayIndex < Count)
	        throw new ArgumentException(Environment.GetResourceString("Arg_ArrayPlusOffTooSmall"));
            for (int i = 0; i<Count; i++) {
		DictionaryEntry entry = new DictionaryEntry(keys[i],values[i]);
                array.SetValue(entry, i + arrayIndex);
            }
    	}
    	
        // Ensures that the capacity of this sorted list is at least the given
        // minimum value. If the currect capacity of the list is less than
        // min, the capacity is increased to twice the current capacity or
        // to min, whichever is larger.
        private void EnsureCapacity(int min) {
            int newCapacity = keys.Length == 0? 16: keys.Length * 2;
            if (newCapacity < min) newCapacity = min;
            Capacity = newCapacity;
        }
    
        // Returns the value of the entry at the given index.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.GetByIndex"]/*' />
        public virtual Object GetByIndex(int index) {
            if (index < 0 || index >= _size) 
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            return values[index];
        }
    
        // Returns an IEnumerator for this sorted list.  If modifications 
        // made to the sorted list while an enumeration is in progress, 
        // the MoveNext and Remove methods
        // of the enumerator will throw an exception.
        //
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.IEnumerable.GetEnumerator"]/*' />
        IEnumerator IEnumerable.GetEnumerator() {
            return new SortedListEnumerator(this, 0, _size, SortedListEnumerator.DictEntry);
        }

        // Returns an IDictionaryEnumerator for this sorted list.  If modifications 
        // made to the sorted list while an enumeration is in progress, 
        // the MoveNext and Remove methods
        // of the enumerator will throw an exception.
        //
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.GetEnumerator"]/*' />
        public virtual IDictionaryEnumerator GetEnumerator() {
            return new SortedListEnumerator(this, 0, _size, SortedListEnumerator.DictEntry);
        }
        
        // Returns the key of the entry at the given index.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.GetKey"]/*' />
        public virtual Object GetKey(int index) {
            if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            return keys[index];
        }
    
        // Returns an IList representing the keys of this sorted list. The
        // returned list is an alias for the keys of this sorted list, so
        // modifications made to the returned list are directly reflected in the
        // underlying sorted list, and vice versa. The elements of the returned
        // list are ordered in the same way as the elements of the sorted list. The
        // returned list does not support adding, inserting, or modifying elements
        // (the Add, AddRange, Insert, InsertRange,
        // Reverse, Set, SetRange, and Sort methods
        // throw exceptions), but it does allow removal of elements (through the
        // Remove and RemoveRange methods or through an enumerator).
        // Null is an invalid key value.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.GetKeyList"]/*' />
        public virtual IList GetKeyList() {
            if (keyList == null) keyList = new KeyList(this);
            return keyList;
        }
    
        // Returns an IList representing the values of this sorted list. The
        // returned list is an alias for the values of this sorted list, so
        // modifications made to the returned list are directly reflected in the
        // underlying sorted list, and vice versa. The elements of the returned
        // list are ordered in the same way as the elements of the sorted list. The
        // returned list does not support adding or inserting elements (the
        // Add, AddRange, Insert and InsertRange
        // methods throw exceptions), but it does allow modification and removal of
        // elements (through the Remove, RemoveRange, Set and
        // SetRange methods or through an enumerator).
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.GetValueList"]/*' />
        public virtual IList GetValueList() {
            if (valueList == null) valueList = new ValueList(this);
            return valueList;
        }
    
        // Returns the value associated with the given key. If an entry with the
        // given key is not found, the returned value is null.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.this"]/*' />
        public virtual Object this[Object key] {
    		get {
    			int i = IndexOfKey(key);
    			if (i >= 0) return values[i];
    			return null;
    		}
    		set {
    	        if (key == null) throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));
    		    int i = Array.BinarySearch(keys, 0, _size, key, comparer);
    			if (i >= 0) {
    	            values[i] = value;
    		        version++;
    			    return;
    	        }
    		    Insert(~i, key, value);
    		}
        }
    
        // Returns the index of the entry with a given key in this sorted list. The
        // key is located through a binary search, and thus the average execution
        // time of this method is proportional to Log2(size), where
        // size is the size of this sorted list. The returned value is -1 if
        // the given key does not occur in this sorted list. Null is an invalid 
        // key value.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.IndexOfKey"]/*' />
        public virtual int IndexOfKey(Object key) {
            if (key == null) 
                throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));
            int ret = Array.BinarySearch(keys, 0, _size, key, comparer);
    		return ret >=0 ? ret : -1;
        }
    
        // Returns the index of the first occurrence of an entry with a given value
        // in this sorted list. The entry is located through a linear search, and
        // thus the average execution time of this method is proportional to the
        // size of this sorted list. The elements of the list are compared to the
        // given value using the Object.Equals method.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.IndexOfValue"]/*' />
        public virtual int IndexOfValue(Object value) {
            return Array.IndexOf(values, value, 0, _size);
        }
    
        // Inserts an entry with a given key and value at a given index.
        private void Insert(int index, Object key, Object value) {
            if (_size == keys.Length) EnsureCapacity(_size + 1);
            if (index < _size) {
                Array.Copy(keys, index, keys, index + 1, _size - index);
                Array.Copy(values, index, values, index + 1, _size - index);
            }
            keys[index] = key;
            values[index] = value;
            _size++;
            version++;
        }
    
        // Removes the entry at the given index. The size of the sorted list is
        // decreased by one.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.RemoveAt"]/*' />
        public virtual void RemoveAt(int index) {
            if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            _size--;
            if (index < _size) {
                Array.Copy(keys, index + 1, keys, index, _size - index);
                Array.Copy(values, index + 1, values, index, _size - index);
            }
            keys[_size] = null;
            values[_size] = null;
            version++;
        }
    
        // Removes an entry from this sorted list. If an entry with the specified
        // key exists in the sorted list, it is removed. An ArgumentException is
        // thrown if the key is null.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Remove"]/*' />
        public virtual void Remove(Object key) {
    		int i = IndexOfKey(key);
            if (i >= 0) 
		RemoveAt(i);
        }
    
        // Sets the value at an index to a given value.  The previous value of
        // the given entry is overwritten.
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.SetByIndex"]/*' />
        public virtual void SetByIndex(int index, Object value) {
            if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            values[index] = value;
            version++;
        }
        
        // Returns a thread-safe SortedList.
        //
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.Synchronized"]/*' />
        public static SortedList Synchronized(SortedList list) {
            if (list==null)
                throw new ArgumentNullException("list");
            return new SyncSortedList(list);
        }
      
        // Sets the capacity of this sorted list to the size of the sorted list.
        // This method can be used to minimize a sorted list's memory overhead once
        // it is known that no new elements will be added to the sorted list. To
        // completely clear a sorted list and release all memory referenced by the
        // sorted list, execute the following statements:
        // 
        // sortedList.Clear();
        // sortedList.TrimToSize();
        // 
        /// <include file='doc\SortedList.uex' path='docs/doc[@for="SortedList.TrimToSize"]/*' />
        public virtual void TrimToSize() {
            Capacity = _size;
        }
    
		[Serializable()]
        private class SyncSortedList : SortedList
        {
            private SortedList _list;
            private Object _root;
    
            internal SyncSortedList(SortedList list) {
                _list = list;
                _root = list.SyncRoot;
            }
    
    		public override int Count { 
    			get { lock(_root) { return _list.Count; } }
    		}
    
			public override Object SyncRoot {
                get { return _root; }
            }

    		public override bool IsReadOnly {
    			get { return _list.IsReadOnly; }
    		}

			public override bool IsFixedSize {
    			get { return _list.IsFixedSize; }
    		}


    		public override bool IsSynchronized { 
    			get { return true; }
    		}
            
			public override Object this[Object key] {
                get {
                    lock(_root) {
                        return _list[key];
                    }
                }
                set {
                    lock(_root) {
                        _list[key] = value;
                    }
                }
            }
    
            public override void Add(Object key, Object value) {
                lock(_root) {
                    _list.Add(key, value);
                }
            }
    
			public override int Capacity {
				get{ lock(_root) {	return _list.Capacity; } }
            }

            public override void Clear() {
                lock(_root) {
                    _list.Clear();
                }
            }

            public override Object Clone() {
                lock(_root) {
                    return _list.Clone();
                }
            }

            public override bool Contains(Object key) {
                lock(_root) {
                    return _list.Contains(key);
                }
            }
    
            public override bool ContainsKey(Object key) {
                lock(_root) {
                    return _list.ContainsKey(key);
                }
            }
    
            public override bool ContainsValue(Object key) {
                lock(_root) {
                    return _list.ContainsValue(key);
                }
            }
    
            public override void CopyTo(Array array, int index) {
                lock(_root) {
                    _list.CopyTo(array, index);
                }
            }
    
            public override Object GetByIndex(int index) {
                lock(_root) {
                    return _list.GetByIndex(index);
                }
            }
    
            public override IDictionaryEnumerator GetEnumerator() {
                lock(_root) {
                    return _list.GetEnumerator();
                }
            }
    
            public override Object GetKey(int index) {
                lock(_root) {
                    return _list.GetKey(index);
                }
            }
    
            public override IList GetKeyList() {
                lock(_root) {
                    return _list.GetKeyList();
                }
            }
    
            public override IList GetValueList() {
                lock(_root) {
                    return _list.GetValueList();
                }
            }
    
            public override int IndexOfKey(Object key) {
                lock(_root) {
                    return _list.IndexOfKey(key);
                }
            }
    
            public override int IndexOfValue(Object value) {
                lock(_root) {
                    return _list.IndexOfValue(value);
                }
            }
    
            public override void RemoveAt(int index) {
                lock(_root) {
                    _list.RemoveAt(index);
                }
            }
    
            public override void Remove(Object key) {
                lock(_root) {
                    _list.Remove(key);
                }
            }
    
            public override void SetByIndex(int index, Object value) {
                lock(_root) {
                    _list.SetByIndex(index, value);
                }
            }
    
            public override void TrimToSize() {
                lock(_root) {
                    _list.TrimToSize();
                }
            }
        }
    
    
        [Serializable()] private class SortedListEnumerator : IDictionaryEnumerator, ICloneable
        {
            private SortedList sortedList;
            private Object key;
            private Object value;
            private int index;
            private int startIndex;        // Store for Reset.
            private int endIndex;
            private int version;
            private bool current;       // Is the current element valid?
            private int getObjectRetType;  // What should GetObject return?
    
            internal const int Keys = 1;
            internal const int Values = 2;
            internal const int DictEntry = 3;
    
            internal SortedListEnumerator(SortedList sortedList, int index, int count, 
                                 int getObjRetType) {
                this.sortedList = sortedList;
                this.index = index;
                startIndex = index;
                endIndex = index + count;
                version = sortedList.version;
                getObjectRetType = getObjRetType;
                current = false;
            }
    
            public Object Clone()
            {
                return MemberwiseClone();
            }

            public virtual Object Key {
                get {
                    if (version != sortedList.version) throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumFailedVersion"));
                    if (current == false) throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                    return key;
                }
            }
    
            public virtual bool MoveNext() {
                if (version != sortedList.version) throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumFailedVersion"));
                if (index < endIndex) {
                    key = sortedList.keys[index];
                    value = sortedList.values[index];
                    index++;
                    current = true;
                    return true;
                }
                key = null;
                value = null;
                current = false;
                return false;
            }
    
            public virtual DictionaryEntry Entry {
                get {
                    if (version != sortedList.version) throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumFailedVersion"));
                    if (current == false) throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                    return new DictionaryEntry(key, value);
                }
            }
    
            public virtual Object Current {
                get {
                    if (current == false) throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                    
                    if (getObjectRetType==Keys)
                        return key;
                    else if (getObjectRetType==Values)
                        return value;
                    else 
                        return new DictionaryEntry(key, value);
                }
            }
    
            public virtual Object Value {
                get {
                    if (version != sortedList.version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                    if (current == false) throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                    return value;
                }
            }
            
            public virtual void Reset() {
                if (version != sortedList.version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                index = startIndex;
                current = false;
				key = null;
				value = null;
            }
        }
    
        [Serializable()] private class KeyList : IList
        {
            private SortedList sortedList;
    
            internal KeyList(SortedList sortedList) {
                this.sortedList = sortedList;
            }
    
    		public virtual int Count { 
    			get { return sortedList._size; }
    		}
    
			public virtual bool IsReadOnly {
                get { return true; }
            }

			public virtual bool IsFixedSize {
    			get { return true; }
    		}

			public virtual bool IsSynchronized {
                get { return sortedList.IsSynchronized; }
            }
    
			public virtual Object SyncRoot {
                get { return sortedList.SyncRoot; }
            }
    
            public virtual int Add(Object key) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
                //            return 0; // suppress compiler warning
            }
    
			public virtual void Clear() {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
    
			public virtual bool Contains(Object key) {
                return sortedList.Contains(key);
            }
    
            public virtual void CopyTo(Array array, int arrayIndex) {
                if (array != null && array.Rank != 1)
                    throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
				
                // defer error checking to Array.Copy
    			Array.Copy(sortedList.keys, 0, array, arrayIndex, sortedList.Count);
            }
    
            public virtual void Insert(int index, Object value) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
    
    		public virtual Object this[int index] {
    			get {
    				return sortedList.GetKey(index);
    			}
    			set {
    				throw new NotSupportedException(Environment.GetResourceString("NotSupported_KeyCollectionSet"));
    			}
            }
    
            public virtual IEnumerator GetEnumerator() {
                return new SortedListEnumerator(sortedList, 0, sortedList.Count, SortedListEnumerator.Keys);
            }
    
            public virtual int IndexOf(Object key) {
    			if (key==null)
                    throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));
    
    			int i = Array.BinarySearch(sortedList.keys, 0,
                                           sortedList.Count, key, sortedList.comparer);
                if (i >= 0) return i;
                return -1;
            }
    
			public virtual void Remove(Object key) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
    
			public virtual void RemoveAt(int index) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
        }
    
        [Serializable()] private class ValueList : IList
        {
            private SortedList sortedList;
    
            internal ValueList(SortedList sortedList) {
                this.sortedList = sortedList;
            }
    
    		public virtual int Count { 
    			get { return sortedList._size; }
    		}
    
			public virtual bool IsReadOnly {
                get { return true; }
            }

			public virtual bool IsFixedSize {
    			get { return true; }
    		}

			public virtual bool IsSynchronized {
                get { return sortedList.IsSynchronized; }
            }
    
			public virtual Object SyncRoot {
                get { return sortedList.SyncRoot; }
            }
    
            public virtual int Add(Object key) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
    
			public virtual void Clear() {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
    
            public virtual bool Contains(Object value) {
                return sortedList.ContainsValue(value);
            }
    
            public virtual void CopyTo(Array array, int arrayIndex) {
                if (array != null && array.Rank != 1)
                    throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
				
                // defer error checking to Array.Copy
    			Array.Copy(sortedList.values, 0, array, arrayIndex, sortedList.Count);
            }
    
            public virtual void Insert(int index, Object value) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
    
    		public virtual Object this[int index] {
    			get {
    				return sortedList.GetByIndex(index);
    			}
    			set {
    				sortedList.SetByIndex(index,value);
    			}
    		}

            public virtual IEnumerator GetEnumerator() {
                return new SortedListEnumerator(sortedList, 0, sortedList.Count, SortedListEnumerator.Values);
            }
    
            public virtual int IndexOf(Object value) {
                return Array.IndexOf(sortedList.values, value, 0, sortedList.Count);
            }
    
            public virtual void Remove(Object value) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
    
			public virtual void RemoveAt(int index) {
                throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_SortedListNestedWrite));
            }
            
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\collections\stack.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Stack
**
** Author: Brian Grunkemeyer (BrianGru), Rajesh Chandrashekaran (rajeshc)
**
** Purpose: An array implementation of a stack.
**
** Date: October 7, 1999
**
=============================================================================*/
namespace System.Collections {
    using System;

    // A simple stack of objects.  Internally it is implemented as an array,
    // so Push can be O(n).  Pop is O(1).
    /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack"]/*' />
    [Serializable()] public class Stack : ICollection, ICloneable {
        private Object[] _array;     // Storage for stack elements
        private int _size;           // Number of items in the stack.
        private int _version;        // Used to keep enumerator in sync w/ collection.
    
        private const int _defaultCapacity = 10;
    
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Stack"]/*' />
        public Stack() {
            _array = new Object[_defaultCapacity];
            _size = 0;
            _version = 0;
        }
    
        // Create a stack with a specific initial capacity.  The initial capacity
        // must be a non-negative number.
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Stack1"]/*' />
        public Stack(int initialCapacity) {
            if (initialCapacity < 0)
                throw new ArgumentOutOfRangeException("initialCapacity", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (initialCapacity < _defaultCapacity)
                initialCapacity = _defaultCapacity;  // Simplify doubling logic in Push.
            _array = new Object[initialCapacity];
            _size = 0;
            _version = 0;
        }
    
        // Fills a Stack with the contents of a particular collection.  The items are
        // pushed onto the stack in the same order they are read by the enumerator.
        //
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Stack2"]/*' />
        public Stack(ICollection col) : this((col==null ? 32 : col.Count))
        {
            if (col==null)
                throw new ArgumentNullException("col");
            IEnumerator en = col.GetEnumerator();
            while(en.MoveNext())
                Push(en.Current);
        }
    
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Count"]/*' />
        public virtual int Count {
            get { return _size; }
        }
        	
    	/// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.IsSynchronized"]/*' />
    	public virtual bool IsSynchronized {
    		get { return false; }
    	}

    	/// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.SyncRoot"]/*' />
    	public virtual Object SyncRoot {
    		get { return this; }
    	}
    
        // Removes all Objects from the Stack.
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Clear"]/*' />
        public virtual void Clear() {
            Array.Clear(_array, 0, _size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references.
            _size = 0;
            _version++;
        }

		/// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Clone"]/*' />
		public virtual Object Clone() {
			Stack s = new Stack(_size);
			s._size = _size;
            Array.Copy(_array, 0, s._array, 0, _size);
			s._version = _version;
			return s;
		}

		/// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Contains"]/*' />
		public virtual bool Contains(Object obj) {
         	int count = _size;
    
            while (count-- > 0) {
                if (obj == null) {
                    if (_array[count] == null)
                        return true;
				}
                else if (obj.Equals(_array[count])) {
                    return true;
                }
            }
            return false;
        }
    
        // Copies the stack into an array.
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.CopyTo"]/*' />
        public virtual void CopyTo(Array array, int index) {
            if (array==null)
                throw new ArgumentNullException("array");
            if (array.Rank != 1)
                throw new ArgumentException(Environment.GetResourceString("Arg_RankMultiDimNotSupported"));
            if (index < 0)
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - index < _size)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
            int i = 0;
            if (array is Object[]) {
                Object[] objArray = (Object[]) array;
                while(i < _size) {
                    objArray[i+index] = _array[_size-i-1];
                    i++;
                }
            }
            else {
                while(i < _size) {
                    array.SetValue(_array[_size-i-1], i+index);
                    i++;
                }
            }
        }
    
        // Returns an IEnumerator for this Stack.
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.GetEnumerator"]/*' />
        public virtual IEnumerator GetEnumerator() {
            return new StackEnumerator(this);
        }
    
        // Returns the top object on the stack without removing it.  If the stack
        // is empty, Peek throws an InvalidOperationException.
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Peek"]/*' />
        public virtual Object Peek() {
            if (_size==0)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EmptyStack"));
            return _array[_size-1];
        }
    
        // Pops an item from the top of the stack.  If the stack is empty, Pop
        // throws an InvalidOperationException.
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Pop"]/*' />
        public virtual Object Pop() {
            if (_size == 0)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EmptyStack"));
            _version++;
            Object obj = _array[--_size];
            _array[_size] = null;     // Free memory quicker.
            return obj;
        }
    
        // Pushes an item to the top of the stack.
        // 
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Push"]/*' />
        public virtual void Push(Object obj) {
            if (_size == _array.Length) {
                Object[] newArray = new Object[2*_array.Length];
                Array.Copy(_array, 0, newArray, 0, _size);
                _array = newArray;
            }
            _array[_size++] = obj;
            _version++;
        }
    
        // Returns a synchronized Stack.
        //
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.Synchronized"]/*' />
        public static Stack Synchronized(Stack stack) {
            if (stack==null)
                throw new ArgumentNullException("stack");
            return new SyncStack(stack);
        }
    
    
        // Copies the Stack to an array, in the same order Pop would return the items.
        /// <include file='doc\Stack.uex' path='docs/doc[@for="Stack.ToArray"]/*' />
        public virtual Object[] ToArray()
        {
            Object[] objArray = new Object[_size];
            int i = 0;
            while(i < _size) {
                objArray[i] = _array[_size-i-1];
                i++;
            }
            return objArray;
        }
    
        [Serializable()] private class SyncStack : Stack
        {
            private Stack _s;
            private Object _root;
    
            internal SyncStack(Stack stack) {
                _s = stack;
                _root = stack.SyncRoot;
            }
    
    		public override bool IsSynchronized {
    			get { return true; }
    		}
    
    		public override Object SyncRoot {
    			get {
    				return _root;
    		    }
    		}
    
    		public override int Count { 
    			get { 
    				lock (_root) {
    					return _s.Count;
                    } 
    			}
    		}

			public override bool Contains(Object obj) {
				lock (_root) {
					return _s.Contains(obj);
				}
			}

			public override Object Clone()
			{
				lock (_root) {
					return new SyncStack((Stack)_s.Clone());
				}
			}
    	  
            public override void Clear() {
                lock (_root) {
                    _s.Clear();
                }
            }
    
            public override void CopyTo(Array array, int arrayIndex) {
                lock (_root) {
                    _s.CopyTo(array, arrayIndex);
                }
            }
    
            public override void Push(Object value) {
                lock (_root) {
                    _s.Push(value);
                }
            }
    
            public override Object Pop() {
                lock (_root) {
                    return _s.Pop();
                }
            }
    
    		public override IEnumerator GetEnumerator() {
                lock (_root) {
                    return _s.GetEnumerator();
                }
            }
    
            public override Object Peek() {
                lock (_root) {
                    return _s.Peek();
                }
            }

			public override Object[] ToArray() {
			    lock (_root) {
                    return _s.ToArray();
                }
            }
        }
    
    
        [Serializable()] private class StackEnumerator : IEnumerator, ICloneable
        {
            private Stack _stack;
            private int _index;
            private int _version;
			private Object currentElement;
    
            internal StackEnumerator(Stack stack) {
                _stack = stack;
                _version = _stack._version;
    			_index = -2;
				currentElement = null;
            }

            public Object Clone()
            {
                return MemberwiseClone();
            }

            public virtual bool MoveNext() {
				bool retval;
				if (_version != _stack._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
    			if (_index == -2) {  // First call to enumerator.
    				_index = _stack._size-1;
    				retval = ( _index >= 0);
					if (retval)
						currentElement = _stack._array[_index];
					return retval;
    			}
    			if (_index == -1) {  // End of enumeration.
					return false;
    			}
    			
				retval = (--_index >= 0);
				if (retval)
					currentElement = _stack._array[_index];
				else
					currentElement = null;
				return retval;
            }
    
            public virtual Object Current {
                get {
                    if (_index == -2) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumNotStarted));
					if (_index == -1) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumEnded));
                    return currentElement;
                }
            }
    
            public virtual void Reset() {
                if (_version != _stack._version) throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_EnumFailedVersion));
                _index = -2;
				currentElement = null;
            }
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\assert.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Diagnostics {
	using System;
	using System.IO;
	using System.Reflection;
	using System.Runtime.CompilerServices;
   // Class which handles code asserts.  Asserts are used to explicitly protect
   // assumptions made in the code.  In general if an assert fails, it indicates 
   // a program bug so is immediately called to the attention of the user.
	// Only static data members, does not need to be marked with the serializable attribute
    /// <include file='doc\Assert.uex' path='docs/doc[@for="Assert"]/*' />
   internal class Assert
    {
    	private static AssertFilter[] ListOfFilters = null;
    	private static int iNumOfFilters = 0;
    	private static int iFilterArraySize = 0;
    	private static AssertFilter DefFil = new DefaultFilter();
    
    	// AddFilter adds a new assert filter. This replaces the current
    	// filter, unless the filter returns FailContinue.
    	//
    	/// <include file='doc\Assert.uex' path='docs/doc[@for="Assert.AddFilter"]/*' />
    	public static void AddFilter(AssertFilter filter)
    	{
    		if (iFilterArraySize <= iNumOfFilters)
    		{
    				AssertFilter[] newFilterArray = new AssertFilter [iFilterArraySize+2];
    
    	            if (iNumOfFilters > 0) 
    					Array.Copy(ListOfFilters, newFilterArray, iNumOfFilters);
    
    				iFilterArraySize += 2;
    
    		        ListOfFilters = newFilterArray;
    		}
    
    		ListOfFilters [iNumOfFilters++] = filter;			
    	}
    
    	// Called when an assertion is being made.
    	//
    	/// <include file='doc\Assert.uex' path='docs/doc[@for="Assert.Check"]/*' />
    	public static void Check(bool condition, String conditionString, String message)
    	{
    		if (!condition)
    		{
    			Fail (conditionString, message);
    		}
    	}
    
    
    	/// <include file='doc\Assert.uex' path='docs/doc[@for="Assert.Fail"]/*' />
    	public static void Fail(String conditionString, String message)
    	{
    		// get the stacktrace
    		StackTrace st = new StackTrace();
    
    		// Run through the list of filters backwards (the last filter in the list
    		// is the default filter. So we're guaranteed that there will be atleast 
    		// one filter to handle the assert.
    
    		int iTemp = iNumOfFilters;
    		while (iTemp > 0)
    		{
    
    			AssertFilters iResult = ListOfFilters [--iTemp].AssertFailure (conditionString, message, st);
    
    			if (iResult == AssertFilters.FailDebug)
    			{
    				if (Debugger.IsAttached == true)
    					Debugger.Break();
    				else
    				{
    					if (Debugger.Launch() == false)
    					{
    						throw new InvalidOperationException(
    								Environment.GetResourceString("InvalidOperation_DebuggerLaunchFailed"));
    					}						
    				}
    
    				break;
    			}
    			else if (iResult == AssertFilters.FailTerminate)
    				Environment.Exit(-1);
    			else if (iResult == AssertFilters.FailIgnore)
    				break;
    
    			// If none of the above, it means that the Filter returned FailContinue.
    			// So invoke the next filter.
    		}
    
    	}
    
      // Called when an assertion fails.
      //
      /// <include file='doc\Assert.uex' path='docs/doc[@for="Assert.ShowDefaultAssertDialog"]/*' />
      [MethodImplAttribute(MethodImplOptions.InternalCall)]
      public extern static int ShowDefaultAssertDialog(String conditionString, String message);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\configuration\assemblies\assemblyhashalgorithm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    AssemblyHashAlgorithm
**
** Author:  Suzanne Cook
**
** Purpose: 
**
** Date:    June 4, 1999
**
===========================================================*/
namespace System.Configuration.Assemblies {
    
    using System;
    /// <include file='doc\AssemblyHashAlgorithm.uex' path='docs/doc[@for="AssemblyHashAlgorithm"]/*' />
    [Serializable]
    public enum AssemblyHashAlgorithm
    {
        /// <include file='doc\AssemblyHashAlgorithm.uex' path='docs/doc[@for="AssemblyHashAlgorithm.None"]/*' />
        None        = 0,
        /// <include file='doc\AssemblyHashAlgorithm.uex' path='docs/doc[@for="AssemblyHashAlgorithm.MD5"]/*' />
        MD5         = 0x8003,
        /// <include file='doc\AssemblyHashAlgorithm.uex' path='docs/doc[@for="AssemblyHashAlgorithm.SHA1"]/*' />
        SHA1        = 0x8004
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\assertfilters.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Diagnostics {
    
    /*
     * FailDebug indicates the debugger should be invoked
     * FailIgnore indicates the failure should be ignored & the 
     *			program continued
     * FailTerminate indicates that the program should be terminated
     * FailContinue indicates that no decision is made - 
     *		the previous Filter should be invoked
     */
	using System;
	[Serializable()]
    internal enum AssertFilters
    {
        FailDebug           = 0,
    	FailIgnore          = 1,
    	FailTerminate       = 2,
    	FailContinueFilter  = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\configuration\assemblies\assemblyhash.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    AssemblyHash
**
** Author:  Suzanne Cook
**
** Purpose: 
**
** Date:    June 4, 1999
**
===========================================================*/
namespace System.Configuration.Assemblies {
    using System;
    /// <include file='doc\AssemblyHash.uex' path='docs/doc[@for="AssemblyHash"]/*' />
    [Serializable()]
    public struct AssemblyHash : ICloneable
    {
        private AssemblyHashAlgorithm _Algorithm;
        private byte[] _Value;
        
        /// <include file='doc\AssemblyHash.uex' path='docs/doc[@for="AssemblyHash.Empty"]/*' />
        public static readonly AssemblyHash Empty = new AssemblyHash(AssemblyHashAlgorithm.None, null);
    
        /// <include file='doc\AssemblyHash.uex' path='docs/doc[@for="AssemblyHash.AssemblyHash"]/*' />
        public AssemblyHash(byte[] value) {
            _Algorithm = AssemblyHashAlgorithm.SHA1;
            _Value = null;
    
            if (value != null) {
                int length = value.Length;
                _Value = new byte[length];
                Array.Copy(value, _Value, length);
            }
        }
    
        /// <include file='doc\AssemblyHash.uex' path='docs/doc[@for="AssemblyHash.AssemblyHash1"]/*' />
        public AssemblyHash(AssemblyHashAlgorithm algorithm, byte[] value) {
            _Algorithm = algorithm;
            _Value = null;
    
            if (value != null) {
                int length = value.Length;
                _Value = new byte[length];
                Array.Copy(value, _Value, length);
            }
        }
    
        // Hash is made up of a byte array and a value from a class of supported 
        // algorithm types.
        /// <include file='doc\AssemblyHash.uex' path='docs/doc[@for="AssemblyHash.Algorithm"]/*' />
        public AssemblyHashAlgorithm Algorithm {
            get { return _Algorithm; }
            set { _Algorithm = value; }
        }

        /// <include file='doc\AssemblyHash.uex' path='docs/doc[@for="AssemblyHash.GetValue"]/*' />
        public byte[] GetValue() {
            return _Value;
        }

        /// <include file='doc\AssemblyHash.uex' path='docs/doc[@for="AssemblyHash.SetValue"]/*' />
        public void SetValue(byte[] value) {
            _Value = value;
        }
    
        /// <include file='doc\AssemblyHash.uex' path='docs/doc[@for="AssemblyHash.Clone"]/*' />
        public Object Clone() {
            return new AssemblyHash(_Algorithm, _Value);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\assertfilter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Diagnostics {
  
    
	using System;
   // A Filter is used to decide whether an assert failure 
   // should terminate the program (or invoke the debugger).  
   // Typically this is done by popping up a dialog & asking the user.
   // 
   // The default filter brings up a simple Win32 dialog with 3 buttons.
    
	[Serializable()]
	abstract internal class AssertFilter
    {
    
    	// Called when an assert fails.  This should be overridden with logic which
    	// determines whether the program should terminate or not.  Typically this
    	// is done by asking the user.
    	//
        // condition - String describing condition which failed
        // message - String with message describing problem
    	// location - Stack trace of location in which assert failure occurred
        //
    	// Returns an enum do determine behavior - 
    	// FailDebug indicates the debugger should be invoked
    	// FailIgnore indicates the failure should be ignored & the 
    	//			program continued
    	// FailTerminate indicates that the program should be terminated
    	// FailContinue indicates that no decision is made - 
    	//		the previous Filter should be invoked    
    	abstract public AssertFilters  AssertFailure(String condition, String message, 
    							  StackTrace location);
    
    }
    
    // No data, does not need to be marked with the serializable attribute
    internal class DefaultFilter : AssertFilter
    {
    	internal DefaultFilter()
    	{
    		Assert.AddFilter (this);
    	}
    
    	public override AssertFilters  AssertFailure(String condition, String message, 
    							  StackTrace location)
    
    	{
			// @COOLPORT: We need to remove this cast.
    		return (AssertFilters) Assert.ShowDefaultAssertDialog (condition, message);
    	}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\configuration\assemblies\assemblyversioncompatibility.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    AssemblyVersionCompatibility
**
** Author:  Suzanne Cook
**
** Purpose: defining the different flavor's assembly version compatibility
**
** Date:    June 4, 1999
**
===========================================================*/
namespace System.Configuration.Assemblies {
    
    using System;
    /// <include file='doc\AssemblyVersionCompatibility.uex' path='docs/doc[@for="AssemblyVersionCompatibility"]/*' />
     [Serializable()]
    public enum AssemblyVersionCompatibility
    {
        /// <include file='doc\AssemblyVersionCompatibility.uex' path='docs/doc[@for="AssemblyVersionCompatibility.SameMachine"]/*' />
        SameMachine         = 1,
        /// <include file='doc\AssemblyVersionCompatibility.uex' path='docs/doc[@for="AssemblyVersionCompatibility.SameProcess"]/*' />
        SameProcess         = 2,
        /// <include file='doc\AssemblyVersionCompatibility.uex' path='docs/doc[@for="AssemblyVersionCompatibility.SameDomain"]/*' />
        SameDomain          = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\conditionalattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;

namespace System.Diagnostics {
    /// <include file='doc\ConditionalAttribute.uex' path='docs/doc[@for="ConditionalAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method, AllowMultiple=true), Serializable]
    public sealed class ConditionalAttribute : Attribute
    {
	/// <include file='doc\ConditionalAttribute.uex' path='docs/doc[@for="ConditionalAttribute.ConditionalAttribute"]/*' />
	public ConditionalAttribute(String conditionString)
	{
		m_conditionString = conditionString;
	}

	/// <include file='doc\ConditionalAttribute.uex' path='docs/doc[@for="ConditionalAttribute.ConditionString"]/*' />
	public String ConditionString {
		get {
			return m_conditionString;
		}
	}

	private String m_conditionString;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\ilcover.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Coverage {

    using System;
    using System.Security;
	using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;

    /// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover"]/*' />
    public class ILCover
    {
    	/// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover.m_init"]/*' />
    	public static bool m_init = false;
    	/// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover.m_coverprocid"]/*' />
    	public static int m_coverprocid = 1;
    	/// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover.m_bboptprocid"]/*' />
    	public static int m_bboptprocid = 2;
    	/// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover.m_address"]/*' />
    	[CLSCompliant(false)]
    	public static ulong m_address = 0;


        //[DllImport("ilcovnat", CharSet=CharSet.Auto),
        // SuppressUnmanagedCodeSecurityAttribute()]
        //public static extern void CoverMethodNative(int token, int numbb);

        //[DllImport("ilcovnat", CharSet=CharSet.Auto),
        // SuppressUnmanagedCodeSecurityAttribute()]
        //public static extern void CoverBlockNative(int token, int bbnun, int totalbb);

    	/// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover.CoverBlock"]/*' />
    	public static void CoverBlock(int compid, int BVidx, int totalbb)
    	{
			if (m_init == false)
			{
				m_address = nativeCoverBlock(m_coverprocid);
				m_init = true;
			}

			if (m_address != 0)
			{
				CoverBlock2(compid, BVidx, totalbb);
			}

    	}

    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	[CLSCompliant(false)]
    	internal static extern ulong nativeCoverBlock(int init);

		// This is replaced with a Calli function
		/// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover.CoverBlock2"]/*' />
		public static void CoverBlock2(int compid, int BVidx, int totalbb)
		{
			return;
		}

		/// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover.BBInstrMProbe2"]/*' />
		public static void BBInstrMProbe2(int mdt, int offset, int iscall, int size)
		{
			return;
		}

		/// <include file='doc\ILCover.uex' path='docs/doc[@for="ILCover.BBInstrMProbe"]/*' />
		public static void BBInstrMProbe(int mdt, int offset, int iscall, int size)
		{
			if (m_init == false)
			{
				m_address = nativeCoverBlock(m_bboptprocid);
				m_init = true;
			}

			if (m_address != 0)
			{
				BBInstrMProbe2(mdt, offset, iscall, size);
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\debugger.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The Debugger class is a part of the System.Diagnostics package
// and is used for communicating with a debugger.

namespace System.Diagnostics {
    using System;
    using System.IO;
    using System.Collections;
    using System.Reflection;
	using System.Runtime.CompilerServices;
    using System.Security;
    using System.Security.Permissions;
    
    
    // No data, does not need to be marked with the serializable attribute
    /// <include file='doc\Debugger.uex' path='docs/doc[@for="Debugger"]/*' />
    public sealed class Debugger 
    {
    
    	// Break causes a breakpoint to be signalled to an attached debugger.  If no debugger
    	// is attached, the user is asked if he wants to attach a debugger. If yes, then the 
    	// debugger is launched.
    	/// <include file='doc\Debugger.uex' path='docs/doc[@for="Debugger.Break"]/*' />
    	public static void Break()
        {
            if (!IsDebuggerAttached())
            {
                // Try and demand UIPermission.  This is done in a try block because if this
                // fails we want to be able to silently eat the exception and just return so
                // that the call to Break does not possibly cause an unhandled exception.
                try
                {
                    new UIPermission(PermissionState.Unrestricted).Demand();
                }
    
                // If we enter this block, we do not have permission to break into the debugger
                // and so we just return.
                catch (SecurityException)
                {
                    return;
                }
            }

            // Causing a break is now allowed.
            BreakInternal();
        }

    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern void BreakInternal();
    
    	// Launch launches & attaches a debugger to the process. If a debugger is already attached,
    	// nothing happens.  
    	//
    	/// <include file='doc\Debugger.uex' path='docs/doc[@for="Debugger.Launch"]/*' />
    	public static bool Launch()
        {
            if (IsDebuggerAttached())
                return (true);

            // Try and demand UIPermission.  This is done in a try block because if this
            // fails we want to be able to silently eat the exception and just return so
            // that the call to Break does not possibly cause an unhandled exception.
            try
            {
                new UIPermission(PermissionState.Unrestricted).Demand();
            }

            // If we enter this block, we do not have permission to break into the debugger
            // and so we just return.
            catch (SecurityException)
            {
                return (false);
            }

            // Causing the debugger to launch is now allowed.
            return (LaunchInternal());
        }

    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern bool LaunchInternal();
    
    	// Returns whether or not a debugger is attached to the process.
    	//
    	/// <include file='doc\Debugger.uex' path='docs/doc[@for="Debugger.IsAttached"]/*' />
    	public static bool IsAttached
    	{
    		get { return IsDebuggerAttached(); }
    	}
    
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private static extern bool IsDebuggerAttached();
    
    	// Constants representing the importance level of messages to be logged.
    	//
    	// An attached debugger can enable or disable which messages will
    	// actually be reported to the user through the COM+ debugger
    	// services API.  This info is communicated to the runtime so only
    	// desired events are actually reported to the debugger.  
    	//
    	// Constant representing the default category
    	/// <include file='doc\Debugger.uex' path='docs/doc[@for="Debugger.DefaultCategory"]/*' />
    	public static readonly String DefaultCategory = null;
    
    	// Posts a message for the attached debugger.  If there is no
    	// debugger attached, has no effect.  The debugger may or may not
    	// report the message depending on its settings. 
    	/// <include file='doc\Debugger.uex' path='docs/doc[@for="Debugger.Log"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern void Log(int level, String category, String message);
    
    	// Checks to see if an attached debugger has logging enabled
    	//  
    	/// <include file='doc\Debugger.uex' path='docs/doc[@for="Debugger.IsLogging"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public static extern bool IsLogging();
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\logginglevels.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Diagnostics {
    
	using System;
   // Constants representing the importance level of messages to be logged.
   // This level can be used to organize messages, and also to filter which
   // messages are displayed.
   //
   // An attached debugger can enable or disable which messages will
   // actually be reported to the user through the COM+ debugger
   // services API.  This info is communicated to the runtime so only
   // desired events are actually reported to the debugger.  
    // AtulC: NOTE: The following constants mirror the constants 
    // declared in the EE code (DebugDebugger.h). Any changes here will also
    // need to be made there.
    // Constants representing the importance level of messages to be logged.
    // This level can be used to organize messages, and also to filter which
    // messages are displayed.
    /// <include file='doc\LoggingLevels.uex' path='docs/doc[@for="LoggingLevels"]/*' />
	[Serializable()]
    internal enum LoggingLevels
    {
    	TraceLevel0         = 0,
    	TraceLevel1         = 1,
    	TraceLevel2         = 2,
    	TraceLevel3         = 3,
    	TraceLevel4         = 4,
    
    	StatusLevel0        = 20,
    	StatusLevel1        = 21,
    	StatusLevel2        = 22,
    	StatusLevel3        = 23,
    	StatusLevel4        = 24,
    
    	
    	WarningLevel        = 40,
    
    	/// <include file='doc\LoggingLevels.uex' path='docs/doc[@for="LoggingLevels.ErrorLevel"]/*' />
    	ErrorLevel          = 50,
    
    	PanicLevel          = 100,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\logswitch.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Diagnostics {
    using System;
    using System.IO;
    using System.Collections;
    
    /// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch"]/*' />
	[Serializable()]
    internal class LogSwitch
    {
    	// ! WARNING ! 
    	// If any fields are added/deleted/modified, perform the 
    	// same in the EE code (debugdebugger.cpp)
    	internal String strName;
    	internal String strDescription;
    	private LogSwitch ParentSwitch;	
    	private LogSwitch[] ChildSwitch;
    	internal LoggingLevels iLevel;
    	internal LoggingLevels iOldLevel;
    	private int iNumChildren;
    	private int iChildArraySize;
    
    	// ! END WARNING !
    
    
    	private LogSwitch ()
    	{
    	}
    
    	// Constructs a LogSwitch.  A LogSwitch is used to categorize log messages.
    	// 
    	// All switches (except for the global LogSwitch) have a parent LogSwitch.
    	//
    	// name - Name of switch. Switches are stored by name, and can 
    	//        be looked up quickly by name. 
        // description - The description is for display in a UI for 
    	//               manipulating switches.  
    	// parent - All switches (except for the global switch) have a 
    	//	        parent switch - a switch is considered on if it is 
        //          on or one of its parent switches is on. 
    	/// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch.LogSwitch"]/*' />
    	public LogSwitch(String name, String description, LogSwitch parent)
    	{
    		if ((name != null) && (parent != null) )
    		{
    			if (name.Length == 0)
    				throw new ArgumentOutOfRangeException (
    				"Name", Environment.GetResourceString(
    					"Namelength_0"));
    				
    			strName = name;
    			strDescription = description;
    			iLevel = LoggingLevels.ErrorLevel;
    			iOldLevel = iLevel;
    
    			// update the parent switch to reflect this child switch
    			parent.AddChildSwitch (this);
    
    			ParentSwitch = parent;
    
    			ChildSwitch  = null;
    			iNumChildren = 0;
    			iChildArraySize = 0;
    
    			Log.m_Hashtable.Add (strName, this);			
    
    			// Call into the EE to let it know about the creation of
    			// this switch
    			Log.AddLogSwitch (this);
    
    			// update switch count
    			Log.iNumOfSwitches++;
    		}
    		else
    			throw new ArgumentNullException ((name==null ? "name" : "parent"));
    	}
    
    	internal LogSwitch(String name, String description)
    	{
    		strName = name;
    		strDescription = description;
    		iLevel = LoggingLevels.ErrorLevel;
    		iOldLevel = iLevel;
    		ParentSwitch = null;
    		ChildSwitch  = null;
    		iNumChildren = 0;
    		iChildArraySize = 0;
    
    		Log.m_Hashtable.Add (strName, this);
    
    		// Call into the EE to let it know about the creation of
    		// this switch
    		Log.AddLogSwitch (this);
    
    		// update switch count
    		Log.iNumOfSwitches++;
    	}
    
    
    	// Get property returns the name of the switch
    	/// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch.Name"]/*' />
    	public virtual String Name
    	{
    		get { return strName;}
    	}
    
    	// Get property returns the description of the switch
    	/// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch.Description"]/*' />
    	public virtual String Description
    	{
    		get {return strDescription;}
    	}
    
    
    	// Get property returns the parent of the switch
    	/// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch.Parent"]/*' />
    	public virtual LogSwitch Parent
    	{
    		get { return ParentSwitch; }
    	}
    
    
    	// Property to Get/Set the level of log messages which are "on" for the switch.  
    	// 
    	// level - Minimum level of messages which are "on".  Any message at this
    	//			  level or higher is "on".  Note that you cannot turn off Panic 
    	//			  messages, as this is the max level.
    	/// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch.MinimumLevel"]/*' />
    	public  virtual LoggingLevels  MinimumLevel
    	{
    		get { return iLevel; }
    		set 
    		{ 
    			iLevel = value; 
    			iOldLevel = value;
    			String strParentName = ParentSwitch!=null ? ParentSwitch.Name : "";
    			if (Debugger.IsAttached)
    				Log.ModifyLogSwitch ((int)iLevel, strName, strParentName);
    	
    			Log.InvokeLogSwitchLevelHandlers (this, iLevel);
    		}
    	}
    
    
    	// Checks if the given level is "on" for this switch or one of its parents.
    	//
    	/// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch.CheckLevel"]/*' />
    	public virtual bool CheckLevel(LoggingLevels level)
    	{
    		if (iLevel > level)
    		{
    			// recurse through the list till parent is hit. 
    			if (this.ParentSwitch == null)
    				return false;
    			else
    				return this.ParentSwitch.CheckLevel (level);
    		}
    		else
    			return true;
    	}
    
    
    	// Returns an IEnumerator of all switches in existence.  This is presumably 
    	// useful for constructing some sort of UI with which to set the switches.
    	/// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch.GetAllSwitches"]/*' />
    	public static IEnumerator GetAllSwitches()
    	{
    		return Log.m_Hashtable.GetEnumerator();
    	}
    
    	// Returns a switch with the particular name, if any.  Returns null if no
    	// such switch exists.
    	/// <include file='doc\LogSwitch.uex' path='docs/doc[@for="LogSwitch.GetSwitch"]/*' />
    	public static LogSwitch GetSwitch(String name)
    	{
    		return (LogSwitch) Log.m_Hashtable[name];
    	}
    
    	private  void AddChildSwitch (LogSwitch child)
    	{
    		if (iChildArraySize <= iNumChildren)
    		{
    				int iIncreasedSize;
    
    				if (iChildArraySize == 0)
    					iIncreasedSize = 10;
    				else
    					iIncreasedSize = (iChildArraySize * 3) / 2;
    
    				// increase child array size in chunks of 4
    				LogSwitch[] newChildSwitchArray = new LogSwitch [iIncreasedSize];
    
    				// copy the old array objects into the new one.
    	            if (iNumChildren > 0) 
    					Array.Copy(ChildSwitch, newChildSwitchArray, iNumChildren);
    
    				iChildArraySize = iIncreasedSize;
    
    		        ChildSwitch = newChildSwitchArray;
    		}
    
    		ChildSwitch [iNumChildren++] = child;			
    	}
    
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\editandcontinuehelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: EditAndContinueHelper
**
** Author: Jennifer Hamilton (JenH)
**
** Purpose: Helper for EditAndContinue
**
** Date: August 18, 1999
**
=============================================================================*/

namespace System.Diagnostics {
    
    using System;
	
    /// <include file='doc\EditAndContinueHelper.uex' path='docs/doc[@for="EditAndContinueHelper"]/*' />
    [Serializable()]
    internal sealed class EditAndContinueHelper 
    {
        private Object _objectReference;

  		// This method should never be called.  Its sole purpose is to shut up the compiler
		//	because it warns about private fields that are never used.  Most of these fields
		//	are used in unmanaged code.
#if _DEBUG
		internal Object NeverCallThis()
		{
            BCLDebug.Assert(false,"NeverCallThis");
            return _objectReference=null;
		}
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\debuggerattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  DebuggerAttributes
**
** Author: Rajesh Chandrashekaran(rajeshc)
**
** Purpose: Attributes for debugger
**
** Date:  Feb 01, 2000
** 
===========================================================*/
    


namespace System.Diagnostics {
    /// <include file='doc\DebuggerAttributes.uex' path='docs/doc[@for="DebuggerStepThroughAttribute"]/*' />
    [Serializable, AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Constructor, Inherited = false)]
    public sealed class DebuggerStepThroughAttribute : Attribute
	{
		/// <include file='doc\DebuggerAttributes.uex' path='docs/doc[@for="DebuggerStepThroughAttribute.DebuggerStepThroughAttribute"]/*' />
		public DebuggerStepThroughAttribute () {}
	} 

    /// <include file='doc\DebuggerAttributes.uex' path='docs/doc[@for="DebuggerHiddenAttribute"]/*' />
    [Serializable, AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Constructor, Inherited = false)]
    public sealed class DebuggerHiddenAttribute : Attribute
	{
	   /// <include file='doc\DebuggerAttributes.uex' path='docs/doc[@for="DebuggerHiddenAttribute.DebuggerHiddenAttribute"]/*' />
	   public DebuggerHiddenAttribute () {}
	}

   // Attribute class used by the compiler to mark modules.  
	// If present, then debugging information for everything in the
   // assembly was generated by the compiler, and will be preserved
   // by the Runtime so that the debugger can provide full functionality
   // in the case of JIT attach. If not present, then the compiler may
   // or may not have included debugging information, and the Runtime
   // won't preserve the debugging info, which will make debugging after
   // a JIT attach difficult.
    /// <include file='doc\DebuggerAttributes.uex' path='docs/doc[@for="DebuggableAttribute"]/*' />
	[AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Module, AllowMultiple = false)]
    public sealed class DebuggableAttribute : Attribute
    {
		bool m_isJITTrackingEnabled;
		bool m_isJITOptimizerDisabled;
		
		/// <include file='doc\DebuggerAttributes.uex' path='docs/doc[@for="DebuggableAttribute.DebuggableAttribute"]/*' />
		public DebuggableAttribute(bool isJITTrackingEnabled,
								   bool isJITOptimizerDisabled)
		{
			m_isJITTrackingEnabled = isJITTrackingEnabled;
			m_isJITOptimizerDisabled = isJITOptimizerDisabled;
		}

        /// <include file='doc\DebuggerAttributes.uex' path='docs/doc[@for="DebuggableAttribute.IsJITTrackingEnabled"]/*' />
        public bool IsJITTrackingEnabled
        {
            get { return m_isJITTrackingEnabled; }
        }

        /// <include file='doc\DebuggerAttributes.uex' path='docs/doc[@for="DebuggableAttribute.IsJITOptimizerDisabled"]/*' />
        public bool IsJITOptimizerDisabled
        {
            get { return m_isJITOptimizerDisabled; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\log.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Diagnostics {
	using System.Runtime.Remoting;
	using System;
	using System.IO;
	using System.Collections;
	using System.Runtime.CompilerServices;
    using Encoding = System.Text.Encoding;

   // LogMessageEventHandlers are triggered when a message is generated which is
   // "on" per its switch.
   // 
   // By default, the debugger (if attached) is the only event handler. 
   // There is also a "built-in" console device which can be enabled
   // programatically, by registry (specifics....) or environment
   // variables.
	[Serializable()]
    internal delegate void LogMessageEventHandler(LoggingLevels level, LogSwitch category, 
    												String message, 
    												StackTrace location);
    
    
   // LogSwitchLevelHandlers are triggered when the level of a LogSwitch is modified
   // NOTE: These are NOT triggered when the log switch setting is changed from the 
   // attached debugger.
   // 
	[Serializable()]
    internal delegate void LogSwitchLevelHandler(LogSwitch ls, LoggingLevels newLevel);
    
    
    /// <include file='doc\log.uex' path='docs/doc[@for="Log"]/*' />
    internal class Log
    {
    
    	// Switches allow relatively fine level control of which messages are
    	// actually shown.  Normally most debugging messages are not shown - the
    	// user will typically enable those which are relevant to what is being
    	// investigated.
    	// 
    	// An attached debugger can enable or disable which messages will
    	// actually be reported to the user through the COM+ debugger
    	// services API.  This info is communicated to the runtime so only
    	// desired events are actually reported to the debugger.  
    	internal static Hashtable m_Hashtable;
    	private static bool m_fConsoleDeviceEnabled;
    	private static Stream[] m_rgStream;
    	private static int m_iNumOfStreamDevices;
    	private static int m_iStreamArraySize;
    	//private static StreamWriter pConsole;
    	internal static int iNumOfSwitches;
    	//private static int iNumOfMsgHandlers;
    	//private static int iMsgHandlerArraySize;
        private static LogMessageEventHandler   _LogMessageEventHandler;
        private static LogSwitchLevelHandler   _LogSwitchLevelHandler;
    
    	// Constant representing the global switch
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.GlobalSwitch"]/*' />
    	public static readonly LogSwitch GlobalSwitch;
    
    
    	static Log()
    	{
    		m_Hashtable = new Hashtable();
    		m_fConsoleDeviceEnabled = false;
    		m_rgStream = null;
    		m_iNumOfStreamDevices = 0;
    		m_iStreamArraySize = 0;
    		//pConsole = null;
    		//iNumOfMsgHandlers = 0;
    		//iMsgHandlerArraySize = 0;
    
    		// allocate the GlobalSwitch object
    		GlobalSwitch = new LogSwitch ("Global", "Global Switch for this log");
    
    		GlobalSwitch.MinimumLevel = LoggingLevels.ErrorLevel;
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.AddOnLogMessage"]/*' />
    	public static void AddOnLogMessage(LogMessageEventHandler handler)
    	{
            _LogMessageEventHandler = 
    			(LogMessageEventHandler) MulticastDelegate.Combine(_LogMessageEventHandler, handler);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.RemoveOnLogMessage"]/*' />
    	public static void RemoveOnLogMessage(LogMessageEventHandler handler)
    	{
    
            _LogMessageEventHandler = 
    			(LogMessageEventHandler) MulticastDelegate.Remove(_LogMessageEventHandler, handler);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.AddOnLogSwitchLevel"]/*' />
    	public static void AddOnLogSwitchLevel(LogSwitchLevelHandler handler)
    	{
            _LogSwitchLevelHandler = 
    			(LogSwitchLevelHandler) MulticastDelegate.Combine(_LogSwitchLevelHandler, handler);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.RemoveOnLogSwitchLevel"]/*' />
    	public static void RemoveOnLogSwitchLevel(LogSwitchLevelHandler handler)
    	{
    
            _LogSwitchLevelHandler = 
    			(LogSwitchLevelHandler) MulticastDelegate.Remove(_LogSwitchLevelHandler, handler);
    	}
    
    	internal static void InvokeLogSwitchLevelHandlers (LogSwitch ls, LoggingLevels newLevel)
    	{
    		if (_LogSwitchLevelHandler != null)
    			_LogSwitchLevelHandler(ls, newLevel);
    	}
    
    
    	// Property to Enable/Disable ConsoleDevice. Enabling the console device 
    	// adds the console device as a log output, causing any
    	// log messages which make it through filters to be written to the 
    	// application console.  The console device is enabled by default if the 
    	// ??? registry entry or ??? environment variable is set.
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.IsConsoleEnabled"]/*' />
    	public static bool IsConsoleEnabled
    	{
    		get { return m_fConsoleDeviceEnabled; }
    		set	{ m_fConsoleDeviceEnabled = value; }
    	}
    
    
    	// AddStream uses the given stream to create and add a new log
    	// device.  Any log messages which make it through filters will be written
    	// to the stream.
    	//
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.AddStream"]/*' />
    	public static void AddStream(Stream stream)
    	{
    		if (stream==null)
    			throw new ArgumentNullException("stream");
    		if (m_iStreamArraySize <= m_iNumOfStreamDevices)
    		{
    				// increase array size in chunks of 4
    				Stream[] newArray = new Stream [m_iStreamArraySize+4];
    
    				// copy the old array objects into the new one.
    	            if (m_iNumOfStreamDevices > 0) 
    					Array.Copy(m_rgStream, newArray, m_iNumOfStreamDevices);
    
    				m_iStreamArraySize += 4;
    
    		        m_rgStream = newArray;
    		}
    
    		m_rgStream [m_iNumOfStreamDevices++] = stream;
    	}
    
    
    	// Generates a log message. If its switch (or a parent switch) allows the 
    	// level for the message, it is "broadcast" to all of the log
    	// devices.
    	// 
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.LogMessage"]/*' />
    	public static void LogMessage(LoggingLevels level, String message)
    	{
    		LogMessage (level, GlobalSwitch, message);
    	}
    
    	// Generates a log message. If its switch (or a parent switch) allows the 
    	// level for the message, it is "broadcast" to all of the log
    	// devices.
    	// 
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.LogMessage1"]/*' />
    	public static void LogMessage(LoggingLevels level, LogSwitch logswitch, String message)
    	{
    		if (logswitch == null)
    			throw new ArgumentNullException ("LogSwitch");
    
    		if (level < 0)
    			throw new ArgumentOutOfRangeException("level", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
    
    		// Is logging for this level for this switch enabled?
    		if (logswitch.CheckLevel (level) == true)
    		{
    			// Send message for logging
    			
    			// first send it to the debugger
				// @COOLPORT: Why This cast?
    			Debugger.Log ((int) level, logswitch.strName, message);
    
    			// Send to the console device
    			if (m_fConsoleDeviceEnabled)
    			{
    				Console.Write(message);				
    			}
    
    			// Send it to the streams
    			for (int i=0; i<m_iNumOfStreamDevices; i++)
    			{
                    StreamWriter sw = new StreamWriter(m_rgStream[i]);
                    sw.Write(message);
                    sw.Flush();
    			}
    		}
    	}
    
    	/*
    	* Following are convenience entry points; all go through Log()
    	* Note that the (Switch switch, String message) variations 
    	* are preferred.
    	*/
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Trace"]/*' />
    	public static void Trace(LogSwitch logswitch, String message)
    	{
    		LogMessage (LoggingLevels.TraceLevel0, logswitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Trace1"]/*' />
    	public static void Trace(String switchname, String message)
    	{
    		LogSwitch ls;
    		ls = LogSwitch.GetSwitch (switchname);
    		LogMessage (LoggingLevels.TraceLevel0, ls, message);			
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Trace2"]/*' />
    	public static void Trace(String message)
    	{
    		LogMessage (LoggingLevels.TraceLevel0, GlobalSwitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Status"]/*' />
    	public static void Status(LogSwitch logswitch, String message)
    	{
    		LogMessage (LoggingLevels.StatusLevel0, logswitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Status1"]/*' />
    	public static void Status(String switchname, String message)
    	{
    		LogSwitch ls;
    		ls = LogSwitch.GetSwitch (switchname);
    		LogMessage (LoggingLevels.StatusLevel0, ls, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Status2"]/*' />
    	public static void Status(String message)
    	{
    		LogMessage (LoggingLevels.StatusLevel0, GlobalSwitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Warning"]/*' />
    	public static void Warning(LogSwitch logswitch, String message)
    	{
    		LogMessage (LoggingLevels.WarningLevel, logswitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Warning1"]/*' />
    	public static void Warning(String switchname, String message)
    	{
    		LogSwitch ls;
    		ls = LogSwitch.GetSwitch (switchname);
    		LogMessage (LoggingLevels.WarningLevel, ls, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Warning2"]/*' />
    	public static void Warning(String message)
    	{
    		LogMessage (LoggingLevels.WarningLevel, GlobalSwitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Error"]/*' />
    	public static void Error(LogSwitch logswitch, String message)
    	{
    		LogMessage (LoggingLevels.ErrorLevel, logswitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Error1"]/*' />
    	public static void Error(String switchname, String message)
    	{
    		LogSwitch ls;
    		ls = LogSwitch.GetSwitch (switchname);
    		LogMessage (LoggingLevels.ErrorLevel, ls, message);
    
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Error2"]/*' />
    	public static void Error(String message)
    	{
    		LogMessage (LoggingLevels.ErrorLevel, GlobalSwitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Panic"]/*' />
    	public static void Panic(LogSwitch logswitch, String message)
    	{
    		LogMessage (LoggingLevels.PanicLevel, logswitch, message);
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Panic1"]/*' />
    	public static void Panic(String switchname, String message)
    	{
    		LogSwitch ls;
    		ls = LogSwitch.GetSwitch (switchname);
    		LogMessage (LoggingLevels.PanicLevel, ls, message);
    
    	}
    
    	/// <include file='doc\log.uex' path='docs/doc[@for="Log.Panic2"]/*' />
    	public static void Panic(String message)
    	{
    		LogMessage (LoggingLevels.PanicLevel, GlobalSwitch, message);
    	}
    	
    
    	// Native method to inform the EE about the creation of a new LogSwitch
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	internal static extern void AddLogSwitch(LogSwitch logSwitch);
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	internal static extern void ModifyLogSwitch (int iNewLevel, String strSwitchName, String strParentName);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\stackframe.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Diagnostics {

	using System.Text;
	using System;
	using System.IO;
	using System.Reflection;
    using System.Security.Permissions;

    /// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame"]/*' />
	[Serializable()]
    public class StackFrame
    {
    	private MethodBase	method;
    	private int 		offset;
    	private int			ILOffset;
    	private String		strFileName;
    	private int			iLineNumber;
    	private int			iColumnNumber;
    
		internal void InitMembers()
		{
    		method = null;
    		offset = OFFSET_UNKNOWN;
    		ILOffset = OFFSET_UNKNOWN;
			strFileName = null;
			iLineNumber = 0;
			iColumnNumber = 0;
		}

    	// Constructs a StackFrame corresponding to the active stack frame.
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.StackFrame"]/*' />
    	public StackFrame()
    	{
			InitMembers();
    		BuildStackFrame (0 + StackTrace.METHODS_TO_SKIP, false);// iSkipFrames=0
    	}
    
    	// Constructs a StackFrame corresponding to the active stack frame.
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.StackFrame1"]/*' />
    	public StackFrame(bool fNeedFileInfo)
    	{
			InitMembers();
    		BuildStackFrame (0 + StackTrace.METHODS_TO_SKIP, fNeedFileInfo);// iSkipFrames=0
    	}

    	// Constructs a StackFrame corresponding to a calling stack frame.
    	// 
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.StackFrame2"]/*' />
    	public StackFrame(int skipFrames)
    	{
			InitMembers();
    		BuildStackFrame (skipFrames + StackTrace.METHODS_TO_SKIP, false);
    	}
    
    	// Constructs a StackFrame corresponding to a calling stack frame.
    	// 
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.StackFrame3"]/*' />
    	public StackFrame(int skipFrames, bool fNeedFileInfo)
    	{
			InitMembers();
    		BuildStackFrame (skipFrames + StackTrace.METHODS_TO_SKIP, fNeedFileInfo);
    	}

    
    	// Called from the class "StackTrace"
    	// 
    	internal StackFrame(bool DummyFlag1, bool DummyFlag2)
    	{
			InitMembers();
    	}
    
    	// Constructs a "fake" stack frame, just containing the given file
    	// name and line number.  Use when you don't want to use the 
    	// debugger's line mapping logic.
    	//
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.StackFrame4"]/*' />
    	public StackFrame(String fileName, int lineNumber)
    	{
			InitMembers();
    		BuildStackFrame (StackTrace.METHODS_TO_SKIP, false);
    		strFileName = fileName;
    		iLineNumber = lineNumber;		
			iColumnNumber = 0;
    	}
    

    	// Constructs a "fake" stack frame, just containing the given file
    	// name, line number and column number.  Use when you don't want to 
		// use the debugger's line mapping logic.
    	//
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.StackFrame5"]/*' />
    	public StackFrame(String fileName, int lineNumber, int colNumber)
    	{
			InitMembers();
    		BuildStackFrame (StackTrace.METHODS_TO_SKIP, false);
    		strFileName = fileName;
    		iLineNumber = lineNumber;		
			iColumnNumber = colNumber;
    	}


    	// Constant returned when the native or IL offset is unknown
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.OFFSET_UNKNOWN"]/*' />
    	public const int  OFFSET_UNKNOWN = -1;
        
    
    	internal virtual void SetMethodBase (MethodBase mb)
    	{
    		method = mb;
    	}
    
    	internal virtual void SetOffset (int iOffset)
    	{
    		offset = iOffset;
    	}
    
    	internal virtual void SetILOffset (int iOffset)
    	{
    		ILOffset = iOffset;
    	}

    	internal virtual void SetFileName (String strFName)
    	{
    		strFileName = strFName;
    	}

    	internal virtual void SetLineNumber (int iLine)
    	{
    		iLineNumber = iLine;
    	}

    	internal virtual void SetColumnNumber (int iCol)
    	{
    		iColumnNumber = iCol;
    	}
    
    
    	// Returns the method the frame is executing
    	// 
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.GetMethod"]/*' />
        [ReflectionPermissionAttribute(SecurityAction.Demand, TypeInformation=true)]
        public virtual MethodBase GetMethod ()
    	{
    		return method;
    	}
    
    	// Returns the offset from the start of the native (jitted) code for the
    	// method being executed
    	// 
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.GetNativeOffset"]/*' />
    	public virtual int GetNativeOffset ()
    	{
    		return offset;
    	}
    
    
    	// Returns the offset from the start of the IL code for the
    	// method being executed.  This offset may be approximate depending
    	// on whether the jitter is generating debuggable code or not.
    	// 
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.GetILOffset"]/*' />
    	public virtual int GetILOffset()
    	{
    		return ILOffset;
    	}	
    
    	// Returns the file name containing the code being executed.  This 
    	// information is normally extracted from the debugging symbols
    	// for the executable.
    	//
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.GetFileName"]/*' />
    	public virtual String GetFileName()
		{
			return strFileName;
		}
    
    	// Returns the line number in the file containing the code being executed.  
    	// This information is normally extracted from the debugging symbols
    	// for the executable.
    	//
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.GetFileLineNumber"]/*' />
    	public virtual int GetFileLineNumber()
		{
			return iLineNumber;
		}

    	// Returns the column number in the line containing the code being executed.  
    	// This information is normally extracted from the debugging symbols
    	// for the executable.
    	//
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.GetFileColumnNumber"]/*' />
    	public virtual int GetFileColumnNumber()
		{
			return iColumnNumber;
		}

    
    	// Builds a readable representation of the stack frame
    	//
    	/// <include file='doc\Stackframe.uex' path='docs/doc[@for="StackFrame.ToString"]/*' />
    	public override String ToString()
    	{
            StringBuilder sb = new StringBuilder(255);
            
			if (method != null)
			{
    			sb.Append(method.Name);
    			sb.Append(" at offset ");
    			if (offset == OFFSET_UNKNOWN)
    				sb.Append("<offset unknown>");
    			else
    				sb.Append(offset);
    
    			sb.Append(" in file:line:column ");
				if (strFileName == null)
					sb.Append("<filename unknown>");
				else
	    			sb.Append(strFileName);
    			sb.Append(":");
    			sb.Append(iLineNumber);
				sb.Append(":");
				sb.Append(iColumnNumber);
			}
			else
			{
				sb.Append("<null>");
			}
    		sb.Append(Environment.NewLine);
    
    		return sb.ToString(); 
    	}
    
    
    	private void BuildStackFrame(int skipFrames, bool fNeedFileInfo)
    	{
    		StackFrameHelper StackF = new StackFrameHelper(fNeedFileInfo, null);
    
    		StackTrace.GetStackFramesInternal (StackF, 0, null); 
    
    		int iNumOfFrames = StackF.GetNumberOfFrames();
    
    		skipFrames += StackTrace.CalculateFramesToSkip (StackF, iNumOfFrames);
    
    		if ((iNumOfFrames - skipFrames) > 0)
    		{
    			method = StackF.GetMethodBase (skipFrames);
    			offset = StackF.GetOffset (skipFrames);
    			ILOffset = StackF.GetILOffset (skipFrames);
				if (fNeedFileInfo)
				{
					strFileName = StackF.GetFilename (skipFrames);
					iLineNumber = StackF.GetLineNumber (skipFrames);
					iColumnNumber = StackF.GetColumnNumber (skipFrames);
				}		
    		}
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymdocumentwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolDocumentWriter
**
** Author: Mike Magruder (mikemag)
**
** Represents a document referenced by a symbol store. A document is
** defined by a URL and a document type GUID. Document source can
** optionally be stored in the symbol store.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    
    using System;
	
	// Interface does not need to be marked with the serializable attribute
    /// <include file='doc\ISymDocumentWriter.uex' path='docs/doc[@for="ISymbolDocumentWriter"]/*' />
    public interface ISymbolDocumentWriter
    {
        /// <include file='doc\ISymDocumentWriter.uex' path='docs/doc[@for="ISymbolDocumentWriter.SetSource"]/*' />
        // SetSource will store the raw source for a document into the
        // symbol store. An array of unsigned bytes is used instead of
        // character data to accomidate a wider variety of "source".
        void SetSource(byte[] source);
        /// <include file='doc\ISymDocumentWriter.uex' path='docs/doc[@for="ISymbolDocumentWriter.SetCheckSum"]/*' />
    
        // Check sum support.
        void SetCheckSum(Guid algorithmId,
                                byte[] checkSum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymdocument.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolDocument
**
** Author: Mike Magruder (mikemag)
**
** Represents a document referenced by a symbol store. A document is
** defined by a URL and a document type GUID. Using the document type
** GUID and the URL, one can locate the document however it is
** stored. Document source can optionally be stored in the symbol
** store. This interface also provides access to that source if it is
** present.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    
    using System;
	
	// Interface does not need to be marked with the serializable attribute
    /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument"]/*' />
    public interface ISymbolDocument
    {
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.URL"]/*' />
        // Properties of the document.
        String URL { get; }
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.DocumentType"]/*' />
        Guid DocumentType { get; }
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.Language"]/*' />
    
        // Language of the document.
        Guid Language { get; }
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.LanguageVendor"]/*' />
        Guid LanguageVendor { get; }
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.CheckSumAlgorithmId"]/*' />
    
        // Check sum information.
        Guid CheckSumAlgorithmId { get; }
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.GetCheckSum"]/*' />
        byte[] GetCheckSum();
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.FindClosestLine"]/*' />
    
        // Given a line in this document that may or may not be a sequence
        // point, return the closest line that is a sequence point.
        int FindClosestLine(int line);
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.HasEmbeddedSource"]/*' />
        
        // Access to embedded source.
        bool HasEmbeddedSource { get; }
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.SourceLength"]/*' />
        int SourceLength { get; }
        /// <include file='doc\ISymDocument.uex' path='docs/doc[@for="ISymbolDocument.GetSourceRange"]/*' />
        byte[] GetSourceRange(int startLine, int startColumn,
                                      int endLine, int endColumn);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymmethod.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolMethod
**
** Author: Mike Magruder (mikemag)
**
** Represents a method within a symbol reader. This provides access to
** only the symbol-related attributes of a method, such as sequence
** points, lexical scopes, and parameter information. Use it in
** conjucntion with other means to read the type-related attrbiutes of
** a method, such as Reflections.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
	using System.Runtime.InteropServices;
	using System;
	// Interface does not need to be marked with the serializable attribute
    /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod"]/*' />
    public interface ISymbolMethod
    {
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.Token"]/*' />
        // Get the token for this method.
        SymbolToken Token { get; }
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.SequencePointCount"]/*' />
    
        // Get the count of sequence points.
        int SequencePointCount { get; }
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.GetSequencePoints"]/*' />
        
        // Get the sequence points for this method. The sequence points
        // are sorted by offset and are for all documents in the
        // method. Use GetSequencePointCount to retrieve the count of all
        // sequence points and create arrays of the proper size.
        // GetSequencePoints will verify the size of each array and place
        // the sequence point information into each. If any array is NULL,
        // then the data for that array is simply not returned.
        void GetSequencePoints(int[] offsets,
                               ISymbolDocument[] documents,
                               int[] lines,
                               int[] columns,
                               int[] endLines,
                               int[] endColumns);
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.RootScope"]/*' />
    
        // Get the root lexical scope for this method. This scope encloses
        // the entire method.
        ISymbolScope RootScope { get; } 
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.GetScope"]/*' />
    
        // Given an offset within the method, returns the most enclosing
        // lexical scope. This can be used to start local variable
        // searches.
        ISymbolScope GetScope(int offset);
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.GetOffset"]/*' />
    
        // Given a position in a document, return the offset within the
        // method that corresponds to the position.
        int GetOffset(ISymbolDocument document,
                             int line,
                             int column);
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.GetRanges"]/*' />
    
        // Given a position in a document, return an array of start/end
        // offset paris that correspond to the ranges of IL that the
        // position covers within this method. The array is an array of
        // integers and is [start,end,start,end]. The number of range
        // pairs is the length of the array / 2.
        int[] GetRanges(ISymbolDocument document,
                               int line,
                               int column);
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.GetParameters"]/*' />
    
        // Get the parameters for this method. The paraemeters are
        // returned in the order they are defined within the method's
        // signature.
        ISymbolVariable[] GetParameters();
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.GetNamespace"]/*' />
    
        // Get the namespace that this method is defined within.
        ISymbolNamespace GetNamespace();
        /// <include file='doc\ISymMethod.uex' path='docs/doc[@for="ISymbolMethod.GetSourceStartEnd"]/*' />
    
        // Get the start/end document positions for the source of this
        // method. The first array position is the start while the second
        // is the end. Returns true if positions were defined, false
        // otherwise.
        bool GetSourceStartEnd(ISymbolDocument[] docs,
                                         int[] lines,
                                         int[] columns);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymreader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolReader
**
** Author: Mike Magruder (mikemag)
**
** Represents a symbol reader for managed code. Provides access to
** documents, methods, and variables.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    // Interface does not need to be marked with the serializable attribute
    using System;

    /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader"]/*' />
    public interface ISymbolReader
    {
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetDocument"]/*' />
        // Find a document. Language, vendor, and document type are
        // optional.
        ISymbolDocument GetDocument(String url,
                                        Guid language,
                                        Guid languageVendor,
                                        Guid documentType);
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetDocuments"]/*' />
    
        // Return an array of all of the documents defined in the symbol
        // store.
        ISymbolDocument[] GetDocuments();
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.UserEntryPoint"]/*' />
    
        // Return the method that was specified as the user entry point
        // for the module, if any. This would be, perhaps, the user's main
        // method rather than compiler generated stubs before main.
        SymbolToken UserEntryPoint { get; }
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetMethod"]/*' />
    
        // Get a symbol reader method given the id of a method.
        ISymbolMethod GetMethod(SymbolToken method);
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetMethod1"]/*' />
    
        // Get a symbol reader method given the id of a method and an E&C
        // version number. Version numbers start a 1 and are incremented
        // each time the method is changed due to an E&C operation.
        ISymbolMethod GetMethod(SymbolToken method, int version);
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetVariables"]/*' />
    
        // Return a non-local variable given its parent and name.
        ISymbolVariable[] GetVariables(SymbolToken parent);
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetGlobalVariables"]/*' />
    
        // Return a non-local variable given its parent and name.
        ISymbolVariable[] GetGlobalVariables();
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetMethodFromDocumentPosition"]/*' />
    
        // Given a position in a document, return the ISymbolMethod that
        // contains that position.
        ISymbolMethod GetMethodFromDocumentPosition(ISymbolDocument document,
                                                        int line,
                                                        int column);
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetSymAttribute"]/*' />
        
        // Gets a custom attribute based upon its name. Not to be
        // confused with Metadata custom attributes, these attributes are
        // held in the symbol store.
        byte[] GetSymAttribute(SymbolToken parent, String name);
        /// <include file='doc\ISymReader.uex' path='docs/doc[@for="ISymbolReader.GetNamespaces"]/*' />
    
        // Get the namespaces defined at global scope within this symbol store.
        ISymbolNamespace[] GetNamespaces();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymbinder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolBinder
**
** Author: Mike Magruder (mikemag)
**
** Represents a symbol binder for managed code.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    
    using System;
	
	// Interface does not need to be marked with the serializable attribute
    /// <include file='doc\ISymBinder.uex' path='docs/doc[@for="ISymbolBinder"]/*' />
    public interface ISymbolBinder
    {
        /// <include file='doc\ISymBinder.uex' path='docs/doc[@for="ISymbolBinder.GetReader"]/*' />
        ISymbolReader GetReader(int importer, String filename,
                                String searchPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymnamespace.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolNamespace
**
** Author: Mike Magruder (mikemag)
**
** Represents a namespace within a symbol reader.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    
    using System;
	
	// Interface does not need to be marked with the serializable attribute
    /// <include file='doc\ISymNamespace.uex' path='docs/doc[@for="ISymbolNamespace"]/*' />
    public interface ISymbolNamespace
    {
        /// <include file='doc\ISymNamespace.uex' path='docs/doc[@for="ISymbolNamespace.Name"]/*' />
        // Get the name of this namespace
        String Name { get; }
        /// <include file='doc\ISymNamespace.uex' path='docs/doc[@for="ISymbolNamespace.GetNamespaces"]/*' />
    
        // Get the children of this namespace
        ISymbolNamespace[] GetNamespaces();
        /// <include file='doc\ISymNamespace.uex' path='docs/doc[@for="ISymbolNamespace.GetVariables"]/*' />
    
        // Get the variables in this namespace
        ISymbolVariable[] GetVariables();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymscope.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolScope
**
** Author: Mike Magruder (mikemag)
**
** Represents a lexical scope within a ISymbolMethod. Provides access to
** the start and end offsets of the scope, as well as its child and
** parent scopes. Also provides access to all the locals defined
** within this scope.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    // Interface does not need to be marked with the serializable attribute
    using System;

    /// <include file='doc\ISymScope.uex' path='docs/doc[@for="ISymbolScope"]/*' />
    public interface ISymbolScope
    {
        /// <include file='doc\ISymScope.uex' path='docs/doc[@for="ISymbolScope.Method"]/*' />
        // Get the method that contains this scope.
        ISymbolMethod Method { get; }
        /// <include file='doc\ISymScope.uex' path='docs/doc[@for="ISymbolScope.Parent"]/*' />
    
        // Get the parent scope of this scope.
        ISymbolScope Parent { get; }
        /// <include file='doc\ISymScope.uex' path='docs/doc[@for="ISymbolScope.GetChildren"]/*' />
    
        // Get any child scopes of this scope.
        ISymbolScope[] GetChildren();
        /// <include file='doc\ISymScope.uex' path='docs/doc[@for="ISymbolScope.StartOffset"]/*' />
        
        // Get the start and end offsets for this scope.
        int StartOffset { get; }
        /// <include file='doc\ISymScope.uex' path='docs/doc[@for="ISymbolScope.EndOffset"]/*' />
        int EndOffset { get; }
        /// <include file='doc\ISymScope.uex' path='docs/doc[@for="ISymbolScope.GetLocals"]/*' />
    
        // Get the locals within this scope. They are returned in no
        // particular order. Note: if a local variable changes its address
        // within this scope then that variable will be returned multiple
        // times, each with a different offset range.
        ISymbolVariable[] GetLocals();
        /// <include file='doc\ISymScope.uex' path='docs/doc[@for="ISymbolScope.GetNamespaces"]/*' />
    
        // Get the namespaces that are being "used" within this scope.
        ISymbolNamespace[] GetNamespaces();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\stacktrace.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Diagnostics {
	using System.Text;
	using System.Threading;
	using System;
	using System.IO;
	using System.Reflection;
	using System.Runtime.CompilerServices;
        using System.Globalization;
    // READ ME:
    // Modifying the order or fields of this object may require other changes to the
    // classlib defintion of the StackFrameHelper class.
	[Serializable()]
    internal class StackFrameHelper
    {
		private Thread targetThread;
    	private int[] rgiOffset;
    	private int[] rgiILOffset;
    	private MethodBase[] rgMethodBase;
		private String[] rgFilename;
		private int[] rgiLineNumber;
		private int[] rgiColumnNumber;
    	private int iFrameCount;
		private bool fNeedFileInfo;
    
    	public StackFrameHelper(bool fNeedFileLineColInfo, Thread target)
    	{
			targetThread = target;
    		rgMethodBase = null;
    		rgiOffset = null;
			rgiILOffset = null;
			rgFilename = null;
			rgiLineNumber = null;
			rgiColumnNumber = null;
			iFrameCount = 512;	//read by the internal to EE method: this is the
								// number of requested frames
			fNeedFileInfo = fNeedFileLineColInfo;
   		}
    
    	public virtual MethodBase GetMethodBase (int i) { return rgMethodBase [i];}
    	public virtual int GetOffset (int i) { return rgiOffset [i];}
    	public virtual int GetILOffset (