           );
    BAIL_ON_FAILURE(hr);

    penumvariant->_pLdapHandle = pLdapHandle;

    // Need to AddRef since we are storing the ld that is owned by the object
    pADs->AddRef();
    penumvariant->_pADs = pADs;

    aStrings[0] = TEXT("objectClass");
    aStrings[1] = NULL;


    //
    // Check if paged search control is supported; if so, we will use it.
    //

    hr = ReadPagingSupportedAttr(
                 pszLDAPServer,
                 &penumvariant->_fPagedSearch,
                 Credentials,
                 dwPort
                 ) ;

    if (penumvariant->_fPagedSearch) {

        //
        // In this case we wont to use the ldap paging API
        // wrapper rather than use cookies directly.
        //
        hr = LdapSearchInitPage(
                 penumvariant->_pLdapHandle,
                 penumvariant->_pszLDAPDn,
                 LDAP_SCOPE_ONELEVEL,
                 penumvariant->_pszFilter,
                 aStrings,
                 0,
                 NULL,
                 clientControls,
                 0,
                 0,
                 NULL,
                 &penumvariant->_phPagedSearch
                 );

        if (FAILED(hr) || (penumvariant->_phPagedSearch == NULL)) {
            //
            // Some error in setting up the paged control, default to non
            // paged search.
            //
            penumvariant->_fPagedSearch = FALSE;
        }
    }

    if (!penumvariant->_fPagedSearch) {

        hr = LdapSearchExtS(
                 penumvariant->_pLdapHandle,
                 penumvariant->_pszLDAPDn,
                 LDAP_SCOPE_ONELEVEL,
                 penumvariant->_pszFilter,
                 aStrings,
                 0,
                 NULL,
                 clientControls,
                 NULL,
                 0,
                 &penumvariant->_res
                 );


        //
        // Error out only if there are no entries returned.
        //

        dwcEntriesReturned = LdapCountEntries(
                                 penumvariant->_pLdapHandle,
                                 penumvariant->_res
                                 );

        if (FAILED(hr) && !dwcEntriesReturned) {

            BAIL_ON_FAILURE(hr);
        }

    } // if not do the paged search case
    else {

        if (penumvariant->_fPagedSearch) {

            //
            // Get the first page full of results.
            //
            hr = LdapGetNextPageS(
                     penumvariant->_pLdapHandle,
                     penumvariant->_phPagedSearch,
                     NULL,
                     penumvariant->_dwPageSize,
                     &totalCount,
                     &penumvariant->_res
                     );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {

                penumvariant->_fLastPage = TRUE;
                goto error;

            } else if ((hr == HRESULT_FROM_WIN32(ERROR_DS_SIZELIMIT_EXCEEDED))
                       && totalCount != 0) {

                penumvariant->_fLastPage = TRUE;
                hr = S_OK;

            }

            BAIL_ON_FAILURE(hr);
        }
    } // the paged search case


error:

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer);

     if (pPagedControl) {
         LdapControlFree(pPagedControl);
     }

     if (serverReturnedControls) {
         LdapControlsFree(serverReturnedControls);
     }


    if (FAILED(hr) && !dwcEntriesReturned) {

        if (penumvariant)  delete penumvariant;

        *ppenumvariant = NULL;

    } else {

        //
        // entries successfully retrieved from server, return them
        // to client even if error and let client decide
        //

        *ppenumvariant = penumvariant;
    }


     RRETURN_EXP_IF_ERR(hr);
}


CLDAPGenObjectEnum::CLDAPGenObjectEnum():
    _ADsPath(NULL),
    _fAllEntriesReturned(FALSE),
    _fPagedSearch(FALSE),
    _fLastPage(FALSE),
    _dwOptReferral(LDAP_CHASE_EXTERNAL_REFERRALS),
    _pszFilter(NULL),
    _pszLDAPDn(NULL),
    _phPagedSearch(NULL)

{
    _pObjList = NULL;

    _pLdapHandle = NULL;
    _pADs = NULL;

    _res = NULL;
    _entry = NULL;
}


CLDAPGenObjectEnum::~CLDAPGenObjectEnum()
{
    if ( _res )
        LdapMsgFree( _res );

    if (_pszFilter) {
        FreeADsMem(_pszFilter);
    }

    if (_pszLDAPDn) {
        FreeADsMem(_pszLDAPDn);
    }

    if (_fPagedSearch) {
        LdapSearchAbandonPage(_pLdapHandle, _phPagedSearch);

    }

    if ( _pADs )
        _pADs->Release();

    if ( _ADsPath )
        ADsFreeString( _ADsPath );

    if ( _pObjList )
        delete _pObjList;

    _pLdapHandle = NULL;
    _phPagedSearch = NULL;

}

HRESULT
CLDAPGenObjectEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;  
    BOOL fRepeat = FALSE;
    DWORD dwFailureCount = 0;
    DWORD dwPermitFailure = 1000;

    
    while (i < cElements) {

        hr = GetGenObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }
        else if (FAILED(hr)) {
            //
            // Got an error while retrieving the object, ignore the
            // error and continue with the next object.
            // If continuously getting error more than dwPermitFailure,
            // make the return value S_FALSE, leave the loop.            
            //            
            if (fRepeat) {
            	dwFailureCount++;
            	if(dwFailureCount > dwPermitFailure) {
            		hr = S_FALSE;
            		break;
            	}            	
            }
            else {
            	fRepeat = TRUE;
            	dwFailureCount = 1;
            }
            	                        
            hr = S_OK;
            continue;
        }
        

        if (fRepeat) {
        	fRepeat = FALSE;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    return(hr);
}


HRESULT
CLDAPGenObjectEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszObjectName = NULL;
    TCHAR **aValues = NULL;
    int nCount = 0;
    DWORD totalCount = 0;
    TCHAR szADsClassName[64];
    LPWSTR aStrings[2] = {TEXT("objectClass"), NULL};

    DWORD  dwPort;
    LPWSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    LPWSTR pszADsPathParent = NULL;

    BOOL   fGCNameSpace = FALSE;


    PLDAPControl    pPagedControl = NULL;
    PLDAPControl    serverControls[2] = {NULL, NULL};
    PLDAPControl    *serverReturnedControls = NULL;

    LDAPControl     referralControl =
                    {
                        LDAP_CONTROL_REFERRALS_W,
                        {
                            sizeof( DWORD ), (PCHAR) &_dwOptReferral
                        },
                        TRUE
                    };

    PLDAPControl    clientControls[2] =
                    {
                        &referralControl,
                        NULL
                    };

    OBJECTINFO ObjectInfoLocal;

    memset(&ObjectInfoLocal, 0, sizeof(OBJECTINFO));

    *ppDispatch = NULL;

    if ( _fAllEntriesReturned )
    {
        hr = S_FALSE;
        goto error;
    }

    if ( _entry == NULL )
        hr = LdapFirstEntry( _pLdapHandle, _res, &_entry );
    else
       hr = LdapNextEntry( _pLdapHandle, _entry, &_entry );

   if (FAILED(hr) ) {

        _fAllEntriesReturned = TRUE;

        BAIL_ON_FAILURE(hr);
    }
    else if ( _entry == NULL ) {

        if (!_fPagedSearch || _fLastPage) { // reached the end of enumeration

            hr = S_FALSE;
            _fAllEntriesReturned = TRUE;
            goto error;
        }
        else {      // more pages are remaining
            //
            // release this page
            //
            if (_res) {
                LdapMsgFree(
                    _res
                    );
                _res = NULL;
            }

            //
            // Get the next page of results
            //
            //
            // Get the first page full of results.
            //
            hr = LdapGetNextPageS(
                     _pLdapHandle,
                     _phPagedSearch,
                     NULL,
                     _dwPageSize,
                     &totalCount,
                     &_res
                     );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {

                     _fLastPage = TRUE;
                     hr = S_FALSE;
                     goto error;

                 }

            BAIL_ON_FAILURE(hr);

            hr = LdapFirstEntry(_pLdapHandle, _res, &_entry );

            if (FAILED(hr) ) {

                 _fAllEntriesReturned = TRUE;

                 BAIL_ON_FAILURE(hr);
            }
            else if ( (_entry == NULL)  ) {  // reached the end of enumeration

                 hr = S_FALSE;
                 _fAllEntriesReturned = TRUE;
                 goto error;
            }
        }
    }

    hr = LdapGetDn( _pLdapHandle, _entry, &pszObjectName );

    if (FAILED(hr) ) {
        BAIL_ON_FAILURE(hr);
    }

    hr = LdapGetValues( _pLdapHandle, _entry, TEXT("objectClass"),
                              &aValues, &nCount );

    BAIL_ON_FAILURE(hr);

    if ( nCount == 0 )
    {
        // This object exists but does not contain objectClass attribute
        // which is required for all DS objects. Hence, ignore the object
        // and return error.

        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now send back the current object
    //

    {
        CLexer Lexer;
        hr = Lexer.InitializePath(pszObjectName);
        BAIL_ON_FAILURE(hr);
        
        hr = InitObjectInfo(pszObjectName,
                            &ObjectInfoLocal);
        BAIL_ON_FAILURE(hr);


        Lexer.SetAtDisabler(TRUE);

        Lexer.SetFSlashDisabler(TRUE);

        hr = PathName(&Lexer,
                      &ObjectInfoLocal);
        BAIL_ON_FAILURE(hr);

        Lexer.SetFSlashDisabler(FALSE);

        if (ObjectInfoLocal.ComponentArray[0].szValue == NULL) {
            BAIL_ON_FAILURE(hr=E_ADS_BAD_PATHNAME);
        }
        DWORD len;

        len = wcslen(ObjectInfoLocal.ComponentArray[0].szComponent) +
              wcslen(ObjectInfoLocal.ComponentArray[0].szValue) +
          1;        // For equal to sign

        pszObjectName[len] = '\0';


        //
        // We form the ADsPath to the parent by taking the _ADsPath of this
        // object (which is the parent ADsPath), chopping off the DN portion,
        // and attaching the parent DN portion of the object retrieved.  This
        // is so that the enumerated child objects get a proper parent ADsPath
        // even if the parent object was bound using a GUID.
        //
        hr = BuildLDAPPathFromADsPath2(
                                       _ADsPath,
                                       &pszLDAPServer,
                                       &pszLDAPDn,
                                       &dwPort
                                       );
        BAIL_ON_FAILURE(hr);

        // _ADsPath could not be NULL 
        if(!_wcsnicmp(L"GC:", _ADsPath, wcslen(L"GC:")))
        {
            fGCNameSpace = TRUE;
        }

        if (ObjectInfoLocal.NumComponents > 1) {
            //
            // pszObjectName[0 ... len] = object name (e.g., "CN=child")
            // pszObjectName[len+1 ....] = parent name (e.g., "OU=parent, DC=....")
            //
            hr = BuildADsPathFromLDAPPath2(
                                           (pszLDAPServer ? TRUE : FALSE),
                                           fGCNameSpace ? L"GC:" : L"LDAP:",
                                           pszLDAPServer,
                                           dwPort,
                                           &(pszObjectName[len+1]),
                                           &pszADsPathParent
                                           );
        } 
        else {
            //
            // If the count is zero or less, then the objectName will
            // need to be created with a parent path of NULL. In this case
            // pszObjectName[len+1] is not necessarily valid. This is
            // espescially true when we have a defaultNamingContext
            // that is NULL or no defaultNamingContext with an object
            // directly underneath it (say dn is just o=testObject.
            //
            hr = BuildADsPathFromLDAPPath2(
                     (pszLDAPServer ? TRUE : FALSE),
                     fGCNameSpace ? L"GC:" : L"LDAP:",
                     pszLDAPServer,
                     dwPort,
                     NULL,
                     &pszADsPathParent
                     );

        }

        BAIL_ON_FAILURE(hr);
                                     
    }




    hr = CLDAPGenObject::CreateGenericObject(
                        pszADsPathParent,
                        pszObjectName,
                        aValues,
                        nCount,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **) ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

error:

    FreeObjectInfo(&ObjectInfoLocal);

    if ( pszObjectName )
        LdapMemFree( pszObjectName );

    if ( aValues )
        LdapValueFree( aValues );

    if (pPagedControl) {
        LdapControlFree(pPagedControl);
    }

    if (serverReturnedControls) {
        LdapControlsFree(serverReturnedControls);
    }

    if (pszADsPathParent) {
        FreeADsMem(pszADsPathParent);
    }

    if (pszLDAPServer) {
        FreeADsMem(pszLDAPServer);
    }

    if (pszLDAPDn) {
        FreeADsMem(pszLDAPDn);
    }


    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPGenObjectEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGenObjectEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
BuildLDAPFilterArray(
    VARIANT var,
    LPTSTR  *ppszFilter
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    LONG dwBracketCount = 0;
    DWORD dwFilterBufLen = 0;
    DWORD dwCurrentFilterLen = 0;
    LPTSTR pszFilter = NULL, pszTempFilter = NULL;

    *ppszFilter = NULL;

    if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is at least one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwCurrentFilterLen = 0;
    dwFilterBufLen = FILTER_BUFFER_LEN;

    pszFilter = (LPTSTR) AllocADsMem( (dwFilterBufLen + 1) * sizeof(WCHAR));
    if ( pszFilter == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        BAIL_ON_FAILURE(hr);

        // The last length below is the string length of
        // "(| (objectClass=))" which is 18.
        //

        while ( dwCurrentFilterLen + _tcslen(V_BSTR(&v)) + 18  > dwFilterBufLen)
        {
            pszTempFilter = (LPTSTR) ReallocADsMem(
                            pszFilter,
                            (dwFilterBufLen + 1) * sizeof(WCHAR),
                            (dwFilterBufLen*2 + 1) * sizeof(WCHAR));
            if ( pszTempFilter == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            pszFilter = pszTempFilter;
            dwFilterBufLen *= 2;
        }

        if ( i == dwSUBound )
        {
            _tcscat( pszFilter, TEXT("(objectClass="));
        }
        else
        {
            dwBracketCount++;
            _tcscat( pszFilter, TEXT("(| (objectClass="));
        }

        _tcscat( pszFilter, V_BSTR(&v));
        _tcscat( pszFilter, TEXT(")"));
        dwCurrentFilterLen = _tcslen(pszFilter);

        VariantClear(&v);
    }

    for ( i = 0; i < dwBracketCount; i++ )
        _tcscat( pszFilter, TEXT(")"));

    *ppszFilter = pszFilter;

    RRETURN(S_OK);

error:

    VariantClear(&v);

    if ( pszFilter != NULL)
        FreeADsMem( pszFilter );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cdsobj.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

DWORD
ComputeObjectInfoSize(
    PADS_OBJECT_INFO pObjectInfo
    );

HRESULT
MarshallObjectInfo(
    PADS_OBJECT_INFO pSrcObjectInfo,
    LPBYTE pDestObjectInfo,
    LPBYTE pEnd
    );

LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD  *DestOffsets,
    LPBYTE pEnd
    );

HRESULT
CLDAPGenObject::SetObjectAttributes(
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    // parameter validation
    if(!pdwNumAttributesModified || !dwNumAttributes)
    {
        hr = E_ADS_BAD_PARAMETER;
        return hr;
    }

    hr = ADsSetObjectAttributes( _pLdapHandle,
                                 _pszLDAPServer,
                                 _pszLDAPDn,
                                 _Credentials,
                                 _dwPort,
                                 _seInfo,
                                 pAttributeEntries,
                                 dwNumAttributes,
                                 pdwNumAttributesModified );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::GetObjectAttributes(
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    // parameter validation
    // -1 means that return all the attributes.    
    
    if(!ppAttributeEntries || !pdwNumAttributesReturned)
    {
        hr = E_ADS_BAD_PARAMETER;
        return hr;
    }

    hr = ADsGetObjectAttributes( _pLdapHandle,
                                 _pszLDAPServer,
                                 _pszLDAPDn,
                                 _Credentials,
                                 _dwPort,
                                 _seInfo,
                                 pAttributeNames,
                                 dwNumberAttributes,
                                 ppAttributeEntries,
                                 pdwNumAttributesReturned );

    RRETURN(hr);

}

HRESULT
CLDAPGenObject::CreateDSObject(
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs *pADs = NULL;
    TCHAR* pszLDAPClassName = NULL;
    DWORD i;
    PADS_ATTR_INFO pThisAttribute = NULL;
    LDAP_SCHEMA_HANDLE hSchema = NULL;
    BOOL fSecDesc = FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    // parameter validation
    if(!pszRDNName || !ppObject || !dwNumAttributes)
    {
        hr = E_ADS_BAD_PARAMETER;
        return hr;
    }

    //
    // Check and see if security descriptor is one of the attributes.
    //
    for (i=0; (i < dwNumAttributes) && (fSecDesc == FALSE); i++) {
        pThisAttribute = pAttributeEntries + i;

        if(!pThisAttribute)
        {
            hr = E_ADS_BAD_PARAMETER;
            return hr;
        }
        
        if (_tcsicmp(
                pThisAttribute->pszAttrName,
                 L"ntSecurityDescriptor")
            == 0)
        {
            fSecDesc = TRUE;
        }

    }

    if (fSecDesc) {
        //
        // Use the create extended method only if the control
        // is supported by the server
        //
        hr = ReadSecurityDescriptorControlType(
                 _pszLDAPServer,
                 &dwSecDescType,
                 _Credentials,
                 _dwPort
                 );

        if (FAILED(hr) || (dwSecDescType != ADSI_LDAPC_SECDESC_NT)) {
            //
            // Do not use the control
            //
            fSecDesc = FALSE;
        }
    }


    //
    // Get the LDAP path of the object to create
    //
    hr = ADsCreateDSObjectExt(
             _pLdapHandle,
             _ADsPath,
             pszRDNName,
             pAttributeEntries,
             dwNumAttributes,
             _seInfo,
             fSecDesc
             );

    BAIL_ON_FAILURE(hr);

    if (ppObject) {
        for (i = 0; i < dwNumAttributes; i++) {
            pThisAttribute = pAttributeEntries + i;
            if ( _tcsicmp( pThisAttribute->pszAttrName,
                           TEXT("objectClass")) == 0 ) {
                           
                pszLDAPClassName = new TCHAR[_tcslen(pThisAttribute->pADsValues->CaseIgnoreString) + 1];
                if(!pszLDAPClassName)
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
                
                _tcscpy( pszLDAPClassName,
                         (LPTSTR)pThisAttribute->pADsValues->CaseIgnoreString);
                break;
            }
        }

        hr = CreateGenericObject(
                        _ADsPath,
                        pszRDNName,
                        pszLDAPClassName,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **) &pADs
                        );
        BAIL_ON_FAILURE(hr);

        hr = pADs->QueryInterface(
                          IID_IDispatch,
                          (void **)ppObject
                          );
        BAIL_ON_FAILURE(hr);

    }

error:

    if ( pADs ) {
        pADs->Release();
    }

    if ( hSchema ) {
        SchemaClose( &hSchema );
    }

    if(pszLDAPClassName)
    {
        delete [] pszLDAPClassName;
        pszLDAPClassName = NULL;
    }
    


    RRETURN(hr);
}

HRESULT
CLDAPGenObject::DeleteDSObject(
    LPWSTR pszRDNName
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    // parameter validation
    if(!pszRDNName)
    {
        hr = E_ADS_BAD_PARAMETER;
        return hr;
    }

    //
    // Get the LDAP path of the object to create
    //
    hr = ADsDeleteDSObject(
                _pLdapHandle,
                _ADsPath,
                pszRDNName
                );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::GetObjectInformation(
    THIS_ PADS_OBJECT_INFO  *ppObjInfo
    )
{
    HRESULT hr = S_OK;

    ADS_OBJECT_INFO ObjectInfo;
    PADS_OBJECT_INFO pObjectInfo = &ObjectInfo;
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    BSTR bstrSchema = NULL;
    BSTR bstrClass = NULL;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    // parameter validation
    if(!ppObjInfo)
    {
        hr = E_ADS_BAD_PARAMETER;
        return hr;
    }

    hr = get_Schema( &bstrSchema );
    BAIL_ON_FAILURE(hr);

    hr = get_Class( &bstrClass );
    BAIL_ON_FAILURE(hr);

    pObjectInfo->pszRDN = _Name;
    pObjectInfo->pszObjectDN = _ADsPath;
    pObjectInfo->pszParentDN = _Parent;
    pObjectInfo->pszSchemaDN = bstrSchema;
    pObjectInfo->pszClassName = bstrClass;

    dwSize = ComputeObjectInfoSize(pObjectInfo);

    pBuffer = (LPBYTE)AllocADsMem(dwSize);
    if (!pBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = MarshallObjectInfo(
             pObjectInfo,
             pBuffer,
             pBuffer + dwSize
             );
    BAIL_ON_FAILURE(hr);

    *ppObjInfo = (PADS_OBJECT_INFO) pBuffer;

error:

    if ( bstrSchema )
        SysFreeString( bstrSchema );

    if ( bstrClass )
        SysFreeString( bstrClass );

    RRETURN(hr);
}

DWORD
ComputeObjectInfoSize(
    PADS_OBJECT_INFO pObjectInfo
    )
{
    DWORD dwLen = 0;

    dwLen += (wcslen(pObjectInfo->pszRDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszObjectDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszParentDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszSchemaDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszClassName) + 1) * sizeof(WCHAR);

    dwLen += sizeof(ADS_OBJECT_INFO);

    return(dwLen);
}

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD_PTR)addr & ~1))

DWORD ObjectInfoStrings[] =  {
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszRDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszObjectDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszParentDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszSchemaDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszClassName),
                             0xFFFFFFFF
                             };

HRESULT
MarshallObjectInfo(
    PADS_OBJECT_INFO pSrcObjectInfo,
    LPBYTE pDestObjectInfo,
    LPBYTE pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(ADS_OBJECT_INFO)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;

    memset(SourceStrings, 0, sizeof(ADS_OBJECT_INFO));
    *pSourceStrings++ = pSrcObjectInfo->pszRDN;
    *pSourceStrings++ = pSrcObjectInfo->pszObjectDN;
    *pSourceStrings++ = pSrcObjectInfo->pszParentDN;
    *pSourceStrings++ = pSrcObjectInfo->pszSchemaDN;
    *pSourceStrings++ = pSrcObjectInfo->pszClassName;

    pEnd = PackStrings(
                SourceStrings,
                pDestObjectInfo,
                ObjectInfoStrings,
                pEnd
                );

    RRETURN(S_OK);
}

LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumsch.cxx
//
//  Contents:  LDAP Schema Enumeration Code
//
//             CLDAPSchemaEnum::CLDAPSchemaEnum()
//             CLDAPSchemaEnum::CLDAPSchemaEnum
//             CLDAPSchemaEnum::EnumObjects
//             CLDAPSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPSchemaEnum::Create(
    CLDAPSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrServerPath,
    VARIANT vFilter,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CLDAPSchemaEnum FAR* penumvariant = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    *ppenumvariant = NULL;

    penumvariant = new CLDAPSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrServerPath, &penumvariant->_bstrServerPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsObject(bstrADsPath, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = SchemaOpen(
             bstrServerPath,
             &(penumvariant->_hSchema),
             Credentials,
             pObjectInfo->PortNumber
             );
    BAIL_ON_FAILURE(hr);

    hr = SchemaGetObjectCount(
             penumvariant->_hSchema,
             &(penumvariant->_nNumOfClasses),
             &(penumvariant->_nNumOfProperties) );
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
             vFilter,
             &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:

    FreeObjectInfo(pObjectInfo);

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CLDAPSchemaEnum::CLDAPSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrServerPath( NULL ),
      _hSchema( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _nNumOfClasses( 0 ),
      _nNumOfProperties( 0 )
{
}

CLDAPSchemaEnum::~CLDAPSchemaEnum()
{
    ADsFreeString( _bstrADsPath );
    ADsFreeString( _bstrServerPath );

    if ( _hSchema )
    {
        SchemaClose( &_hSchema );
    }

    if ( _pObjList != NULL )
    {
        delete _pObjList;
        _pObjList = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects( cElements,
                      pvar,
                      &cElementFetched );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr;
    switch (ObjectType)
    {
        case LDAP_CLASS_ID:
            hr = EnumClasses(cElements, pvar, pcElementFetched);
            break;

        case LDAP_PROPERTY_ID:
            hr = EnumProperties(cElements, pvar, pcElementFetched);
            break;

        case LDAP_SYNTAX_ID:
            hr = EnumSyntaxObjects(cElements, pvar, pcElementFetched);
            break;

        default:
            hr = S_FALSE;

    }
    RRETURN(hr);
}

HRESULT
CLDAPSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_FALSE;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CLDAPSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    CLASSINFO *pClassInfo = NULL;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= _nNumOfClasses )
        goto error;

    hr = SchemaGetClassInfoByIndex(
             _hSchema,
             _dwCurrentEntry,
             &pClassInfo );
    BAIL_ON_FAILURE(hr); 

    if (_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {

        //
        // If we are in Umi land, then we cannot ask for dispatch.
        //
        hr = CLDAPClass::CreateClass(
                            _bstrADsPath,
                            _hSchema,
                            pClassInfo->pszName,
                            pClassInfo,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            (void **) ppDispatch
                            );
    } 
    else {
        
        hr = CLDAPClass::CreateClass(
                            _bstrADsPath,
                            _hSchema,
                            pClassInfo->pszName,
                            pClassInfo,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    }
    
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;


    RRETURN(S_OK);

error:


    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CLDAPSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CLDAPSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    PROPERTYINFO *pPropertyInfo = NULL;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= _nNumOfProperties )
        goto error;

    hr = SchemaGetPropertyInfoByIndex(
             _hSchema,
             _dwCurrentEntry,
             &pPropertyInfo );
    BAIL_ON_FAILURE(hr);

    if (_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // In Umi land ask for IID_IUnknown.
        //
        hr = CLDAPProperty::CreateProperty(
                    _bstrADsPath,
                    _hSchema,
                    pPropertyInfo->pszPropertyName,
                    pPropertyInfo,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    (void **)ppDispatch
                    );

    } 
    else {
        hr = CLDAPProperty::CreateProperty(
                    _bstrADsPath,
                    _hSchema,
                    pPropertyInfo->pszPropertyName,
                    pPropertyInfo,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );
    }

    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CLDAPSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CLDAPSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cLDAPSyntax )
        goto error;

    if (_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // In Umi land ask for IID_IUnknown not dispatch.
        //
        hr = CLDAPSyntax::CreateSyntax(
                            _bstrADsPath,
                            &g_aLDAPSyntax[_dwCurrentEntry],
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            (void **)ppDispatch
                            );
    } 
    else {
        hr = CLDAPSyntax::CreateSyntax(
                            _bstrADsPath,
                            &g_aLDAPSyntax[_dwCurrentEntry],
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
    }

    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cgenobj.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cgenobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   08-30-96  yihsins   Created.
//
//---------------------------------------- ------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#ifdef __cplusplus
extern "C"
#else
extern
#endif
HRESULT
AdsTypeToPropVariant2(
    PADSVALUE pAdsValues,
    DWORD dwNumValues,
    VARIANT * pVariant,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    );

#ifdef __cplusplus
extern "C"
#else
extern
#endif
HRESULT
PropVariantToAdsType2(
    PVARIANT pVariant,
    DWORD dwNumVariant,
    PADSVALUE *ppAdsValues,
    PDWORD pdwNumValues,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    );

//
// Helper routine that handles setting the sticky server private
// option when the input is an array.
//
HRESULT
SetStickyServerWithDomain(
    PVARIANT pvProp
    );

//  Class CLDAPGenObject

DEFINE_IDispatch_ExtMgr_Implementation(CLDAPGenObject)
DEFINE_IADs_Shorter_Implementation(CLDAPGenObject)

//
// This is a useful function
//
HRESULT GetIntegerFromVariant(
    VARIANT* pvProp,
    DWORD* pdwValue
    );

typedef struct _classeshierarchylist {
    LPWSTR pszClassName;
    struct _classeshierarchylist *pNext;
} ClassesHierarchyList, *PClassesHierarchyList;


//
// Helper to Trace The Tree for a class
//
HRESULT
TraceTreeForClass(
    BSTR Parent,
    BSTR CommonName,
    LPWSTR pszClassName,
    CCredentials& Credentials,
    PWCHAR **pppszNameArr,
    PLONG plnNumElements
    );

HRESULT
AddToClassesList(
    VARIANT vBstrVal,
    LPWSTR *ppszCurClass,
    PClassesHierarchyList *pClassListhead,
    PLONG plnNumItems
    );


CLDAPGenObject::CLDAPGenObject():
    _pExtMgr(NULL),
    _pPropertyCache( NULL ),
    _pDispMgr( NULL ),
    _pszLDAPServer(NULL),
    _pszLDAPDn(NULL),
    _pLdapHandle( NULL ),
    _dwOptReferral((DWORD) LDAP_CHASE_EXTERNAL_REFERRALS),
    _dwPageSize(99),
    _dwCorePropStatus(0),
    _fRangeRetrieval(FALSE),
    _pSid(NULL),
    _dwSidLength(0),
    _dwPasswordPort((DWORD) -1),
    _dwPasswordMethod(ADS_PASSWORD_ENCODE_REQUIRE_SSL),
    _fPasswordPortSet(FALSE)
{
    VariantInit(&_vFilter);
    VariantInit(&_vHints);

    _seInfo = OWNER_SECURITY_INFORMATION
              | GROUP_SECURITY_INFORMATION
              | DACL_SECURITY_INFORMATION;

    _fExplicitSecurityMask = FALSE;

    LdapInitializeSearchPreferences(&_SearchPref, TRUE);

    ENLIST_TRACKING(CLDAPGenObject);
}

//
// fClassDefaulted indicates if the class has been defaulted
// because of a fast bind flag or otherwise.
//
HRESULT
CLDAPGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR LdapClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj,
    BOOL fClassDefaulted,
    BOOL fNoQI // defaulted to FALSE
    )
{

    //
    // Call into the fully featured Create
    //
    LPWSTR pszClassNames[2];
    HRESULT hr = S_OK;
    PWCHAR *ppListOfNames;
    LONG lnNumNames = 0;

    pszClassNames[0] = LdapClassName;
    pszClassNames[1] = NULL;

    hr = TraceTreeForClass(
             Parent,
             CommonName,
             LdapClassName,
             Credentials,
             &ppListOfNames,
             &lnNumNames
             );

    if (FAILED(hr)) {
        //
        // Default to just the class name given
        //
        RRETURN(CreateGenericObject(
                    Parent,
                    CommonName,
                    pszClassNames,
                    1,
                    Credentials,
                    dwObjectState,
                    riid,
                    ppvObj,
                    fClassDefaulted,
                    fNoQI
                    )
                );
    }
    else {
        //
        // Create with all the classes specified
        //
        hr = CreateGenericObject(
                 Parent,
                 CommonName,
                 ppListOfNames,
                 lnNumNames,
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj,
                 fClassDefaulted,
                 fNoQI
                 );

        for (long i = 0; i < lnNumNames; i++) {
            if (ppListOfNames[i]) {
                FreeADsStr(ppListOfNames[i]);
            }
        }

        if (ppListOfNames) {
            FreeADsMem(ppListOfNames);
        }

        RRETURN(hr);
    }
}

//+------------------------------------------------------------------------
//
//  Function:   CLDAPGenObject::CreateGenericObject
//
//  Synopsis:   Does all the work and actually creates the object.
//          Difference from the overlaoded member being that it accepts an
//          array of values for the class name so that it can load
//          extensions for all the classes in the inheritance hierarchy.
//
//  Arguments:
//
//-------------------------------------------------------------------------
HRESULT
CLDAPGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    LPWSTR LdapClassNames[],
    long lnNumClasses,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj,
    BOOL fClassDefaulted,
    BOOL fNoQI // will return cgenobject if set to TRUE, defaulted FALSE
    )
{
    CLDAPGenObject FAR * pGenObject = NULL;
    HRESULT hr = S_OK;
    DWORD dwCtr = 0;
    LPWSTR pszBaseClassName = GET_BASE_CLASS(LdapClassNames, lnNumClasses);

    hr = AllocateGenObject(pszBaseClassName, Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pGenObject->_pDispMgr);


    pGenObject->_Credentials = Credentials;


    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                pszBaseClassName,
                CLSID_LDAPGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             pGenObject->_ADsPath,
             &pGenObject->_pszLDAPServer,
             &pGenObject->_pszLDAPDn,
             &pGenObject->_dwPort
             );

    BAIL_ON_FAILURE(hr);

    //
    // At this point update the info in the property cache
    //
    hr = pGenObject->_pPropertyCache->SetObjInformation(
                                     &(pGenObject->_Credentials),
                                     pGenObject->_pszLDAPServer,
                                     pGenObject->_dwPort
                                     );

    BAIL_ON_FAILURE(hr);

    //
    // Create and Load 3rd party extensions and the extension mgr.
    // This should be done after initilaization of core and generic object s.t
    // 1) an extension writer can access info on IADs (e.g _Parent) etc
    //    during extension creation, if he wants to.
    // 2) we shouldn't waste the effort to create and load extension
    //    objects if fialure in the aggregator's creation
    //

    hr = CADsExtMgr::CreateExtMgr(
                      (IADs *)pGenObject,
                      pGenObject->_pDispMgr,
                      LdapClassNames,
                      lnNumClasses,
                      &(pGenObject->_Credentials),
                      &pGenObject->_pExtMgr
                      );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pGenObject->_pExtMgr);

    hr = LdapOpenObject(
                   pGenObject->_pszLDAPServer,
                   pGenObject->_pszLDAPDn,
                   &(pGenObject->_pLdapHandle),
                   pGenObject->_Credentials,
                   pGenObject->_dwPort
                   );

    BAIL_ON_FAILURE(hr);

    if (!fClassDefaulted) {
        //
        // Update the status to reflect we do not need to go
        // on the wire to get the class
        //
        pGenObject->_dwCorePropStatus |= LDAP_CLASS_VALID;
    }


    if (fNoQI) {
        *ppvObj = (void *) pGenObject;
    } 
    else if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // Call is from umi so we need to create the umi object.
        //
        hr = ((CCoreADsObject*)pGenObject)->InitUmiObject(
                 IntfPropsGeneric,
                 pGenObject->_pPropertyCache,
                 (IADs *) pGenObject,
                 (IADs *) pGenObject,
                 IID_IUnknown,
                 ppvObj,
                 &(pGenObject->_Credentials),
                 pGenObject->_dwPort,
                 pGenObject->_pszLDAPServer,
                 pGenObject->_pszLDAPDn,
                 pGenObject->_pLdapHandle,
                 pGenObject->_pExtMgr
                 );

        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);

    } else {
        //
        // Need the appropriate interface.
        //
        hr = pGenObject->QueryInterface(riid, ppvObj);
        BAIL_ON_FAILURE(hr);

        pGenObject->Release();
    }

    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pGenObject;
    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
// Function:   CLDAPGenObject::CreateGenericObject (static constructor), this
//          constructor is used by Umi Searches only.
//
// Synopsis:   This routine uses the other static constructor routines 
//          depending on the objectClass information available in the passed
//          in ldapMsg. The state of the newly created object reflects this
//          information. The newly created object is then prepopulated with
//          the attributes in the ldapMsg. The return value from this routine
//          is the newly created object (interface asked on this object).
//
// Arguments:  Parent       -  Path to the parent of the newly created object.
//             CommonName   -  Name of new object to create.
//             Credentials  -  Standard credentials object.
//             dwObjectState-  Bound/unbound (always bound in this case).
//             ldapHandle   -  Handle used in the deciphering search info.
//             pldapMsg     -  The Ldao msg with the attributes.
//             riid         -  IID requested on newly created object.
//             ppvObj       -  Return value.
//             
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   ppvObj contains newly created object with attributes.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    PADSLDP ldapHandle,
    LDAPMessage *pldapMsg,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    TCHAR **aValues = NULL;
    int   nCount;
    CLDAPGenObject *pGenObject = NULL;

    hr = LdapGetValues(
             ldapHandle,
             pldapMsg,
             L"objectClass",
             &aValues,
             &nCount
             );

    if (FAILED(hr) || !aValues) {
        //
        // We do not have the objectClass
        //
        hr = CLDAPGenObject::CreateGenericObject(
                 Parent,
                 CommonName,
                 L"Top",
                 Credentials,
                 dwObjectState,
                 riid,
                 (void **) &pGenObject,
                 TRUE, // class is defaulted
                 TRUE // No QI
                 );

    } 
    else {
        //
        // We have the info we need for the constructor with class name
        //
        hr = CLDAPGenObject::CreateGenericObject(
                 Parent,
                 CommonName,
                 aValues,
                 nCount,
                 Credentials,
                 dwObjectState,
                 riid,
                 (void **) &pGenObject,
                 FALSE, // objectClass is not defaulted
                 TRUE // No QI
                 );
    }

    BAIL_ON_FAILURE(hr);

    //
    // Now we need to prepopulate the object.
    //
    hr = pGenObject->_pPropertyCache->
             LDAPUnMarshallProperties2(
                 pGenObject->_pszLDAPServer,
                 pGenObject->_pLdapHandle,
                 pldapMsg,
                 FALSE, // this is not an explicit getinfo.
                 pGenObject->_Credentials,
                 &pGenObject->_fRangeRetrieval
                 );
    //
    // Should we really fail if we could not unmarshall properties ???
    ///
    BAIL_ON_FAILURE(hr);

    //
    // This call is always from UMI, so now we need to get the
    // outer umiObject and return that.
    //
    hr = ((CCoreADsObject*)pGenObject)->InitUmiObject(
               IntfPropsGeneric,
               pGenObject->_pPropertyCache,
               (IADs *) pGenObject,
               (IADs *) pGenObject,
               riid,
               ppvObj,
               &(pGenObject->_Credentials),
               pGenObject->_dwPort,
               pGenObject->_pszLDAPServer,
               pGenObject->_pszLDAPDn,
               pGenObject->_pLdapHandle,
               pGenObject->_pExtMgr
               );

    BAIL_ON_FAILURE(hr);

    //
    // Only thing remaining is to get a list of the attributes fetched
    // into this object. That way we wont go on the wire for them. This
    // can be done once the GetInfoEx related bug is fixed.
    //

error :

    if (pGenObject && FAILED(hr)) {
        delete pGenObject;
        *ppvObj = NULL;
    }

    //
    // Need to free the Ldap values in all cases.
    //
    if (aValues) {
        LdapValueFree(aValues);
        aValues = NULL;
    }

    RRETURN(hr);
}

CLDAPGenObject::~CLDAPGenObject( )
{

    //
    // last to be created - first to be unloaded
    //

    delete _pExtMgr;

    VariantClear(&_vFilter);
    VariantClear(&_vHints);

    if ( _pLdapHandle )
    {
        LdapCloseObject(_pLdapHandle);
        _pLdapHandle = NULL;
    }

    if (_pszLDAPServer) {
       FreeADsStr(_pszLDAPServer);
       _pszLDAPServer = NULL;
    }

    if (_pszLDAPDn) {
       FreeADsStr(_pszLDAPDn);
       _pszLDAPDn = NULL;
    }

    if(_pSid)
    {
       FreeADsMem(_pSid);
       _pSid = NULL;        
    }

    delete _pDispMgr;

    delete _pPropertyCache;

    //
    // Free the sort keys if applicable.
    //
    if (_SearchPref._pSortKeys) {
        for (DWORD dwCtr = 0; dwCtr < _SearchPref._nSortKeys; dwCtr++) {
            if (_SearchPref._pSortKeys[dwCtr].sk_attrtype)
                FreeADsStr(_SearchPref._pSortKeys[dwCtr].sk_attrtype);
        }
        FreeADsMem(_SearchPref._pSortKeys);
    }

    //
    // Free the VLV information if applicable
    //
    if (_SearchPref._pVLVInfo) {

        if (_SearchPref._pVLVInfo->ldvlv_attrvalue) {

            if (_SearchPref._pVLVInfo->ldvlv_attrvalue->bv_val) {
                FreeADsMem(_SearchPref._pVLVInfo->ldvlv_attrvalue->bv_val);
            }

            FreeADsMem(_SearchPref._pVLVInfo->ldvlv_attrvalue);
        }

        if (_SearchPref._pVLVInfo->ldvlv_context) {
        
            if (_SearchPref._pVLVInfo->ldvlv_context->bv_val) {
                FreeADsMem(_SearchPref._pVLVInfo->ldvlv_context->bv_val);
            }

            FreeADsMem(_SearchPref._pVLVInfo->ldvlv_context);
        }

        FreeADsMem(_SearchPref._pVLVInfo);
    }

    //
    // Free the attribute scoped query information if applicable
    //
    if (_SearchPref._pAttribScoped) {

        FreeADsStr(_SearchPref._pAttribScoped);
    }
}

STDMETHODIMP
CLDAPGenObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsObjectOptions))
    {
        *ppv = (IADsObjectOptions FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDeleteOps))
    {
        *ppv = (IADsDeleteOps FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsObjOptPrivate))
    {
        *ppv = (IADsObjOptPrivate *) this;
    }
    else if (_pExtMgr)
    {

            RRETURN(hr = _pExtMgr->QueryInterface(iid, ppv));

    }else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
HRESULT
CLDAPGenObject::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsPropertyList) ||
    IsEqualIID(riid, IID_IADsContainer) ||
#if 0
    IsEqualIID(riid, IID_IDirectoryObject) ||
    IsEqualIID(riid, IID_IDirectorySearch) ||
    IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
    IsEqualIID(riid, IID_IADsObjectOptions)) {

        RRETURN(S_OK);

    }
    else {

        RRETURN(S_FALSE);

    }
}

HRESULT
CLDAPGenObject::SetInfo()
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = LDAPCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = LDAPSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPGenObject::LDAPSetObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    BOOL fNTSecDes=FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;
    BOOL fModifyDone = FALSE;
    SECURITY_INFORMATION NewSeInfo=0;


    SECURITY_INFORMATION SeInfo = _seInfo;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE) ((ULONG)SeInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    LDAPControl     ModifyControl =
                    {
                        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                        {
                            0, NULL
                        },
                        FALSE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    PLDAPControl    ServerControlsOnlyModify[2] =
                    {
                        &ModifyControl,
                        NULL
                    };

    PLDAPControl    ServerControlsAll[3] =
                    {
                        &SeInfoControl,
                        &ModifyControl,
                        NULL
                    };

    BOOL fServerIsAD = FALSE;


    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( aMod == NULL )  // There are no changes that needs to be modified
        RRETURN(S_OK);

    //
    // Sometimes the call to Marshall might contain the SD but NewSeInfo
    // might not have been updated suitable because of failures not sever
    // enough to warrant failing the entire operation.
    //
    if (!_fExplicitSecurityMask 
        && fNTSecDes
        && (NewSeInfo != INVALID_SE_VALUE)
        ) {
        berValue[4] = (BYTE) ((ULONG)NewSeInfo);
    }

    //
    // Find out if server is AD.
    //
    hr = ReadServerSupportsIsADControl(
            _pszLDAPServer,
             &fServerIsAD,
             _Credentials,
             _dwPort
             );
    if (FAILED(hr)) {
        //
        // Assume it is not AD and continue, there is no
        // good reason for this to fail on AD.
        //
        fServerIsAD = FALSE;
    }

    if (fNTSecDes) {

        hr = ReadSecurityDescriptorControlType(
                 _pszLDAPServer,
                 &dwSecDescType,
                 _Credentials,
                 _dwPort
                 );

        if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT)) {

                hr = LdapModifyExtS(
                         _pLdapHandle,
                         _pszLDAPDn,
                         aMod,
                         fServerIsAD ?
                            (PLDAPControl *) &ServerControlsAll :
                            (PLDAPControl *) &ServerControls,
                         NULL
                         );

                fModifyDone = TRUE;


        } // SecDesc type == NT
    } // if modifySecDes

    if (!fModifyDone) {

        if (fServerIsAD) {
            //
            // Need to send the additional control that says it is
            // ok to clear the values on attributes that do not
            // have any values.
            //
            hr = LdapModifyExtS(
                     _pLdapHandle,
                     _pszLDAPDn,
                     aMod,
                     (PLDAPControl *) &ServerControlsOnlyModify,
                     NULL
                     );
        }
        else {
            hr = LdapModifyS(
                     _pLdapHandle,
                     _pszLDAPDn,
                     aMod
                     );
        }

    }

    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearMarshalledProperties();
    _pPropertyCache->ClearAllPropertyFlags();
    
    _pPropertyCache->DeleteSavingEntry();


error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );

        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPGenObject::LDAPCreateObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    DWORD dwIndex = 0;
    BOOL fNTSecDes= FALSE;
    BOOL fAddDone = FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;
    SECURITY_INFORMATION SeInfo = _seInfo;
    SECURITY_INFORMATION NewSeInfo=0;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE) ((ULONG)SeInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    if ( _pPropertyCache->findproperty( TEXT("objectClass"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VARIANT v;

        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _SchemaClass;

        hr = Put( TEXT("objectClass"), v );
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if (!_fExplicitSecurityMask && NewSeInfo) {
        berValue[4] = (BYTE) ((ULONG)NewSeInfo);
    }
    
    if (fNTSecDes == TRUE) {
        //
        // If we support the SD control, then we use
        // the add ext method.
        //
        if (fNTSecDes) {


            hr = ReadSecurityDescriptorControlType(
                     _pszLDAPServer,
                     &dwSecDescType,
                     _Credentials,
                     _dwPort
                     );

            if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT)) {

                hr = LdapAddExtS(
                         _pLdapHandle,
                         _pszLDAPDn,
                         aMod,
                         (PLDAPControl *)&ServerControls,
                         NULL
                         );

                fAddDone = TRUE;

            } // SecDesc type == NT
        }
    } // if SecDesc needs to be sent.


    if (!fAddDone) {
        //
        // Call add s
        //
        hr = LdapAddS(
                 _pLdapHandle,
                 _pszLDAPDn,
                 aMod
                 );
    }

    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );
        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPGenObject::GetInfoEx(
    THIS_ VARIANT vProperties,
    long lnReserved
    )
{
    HRESULT hr = S_OK;
    LDAPMessage *res = NULL;
    VARIANT *vVarArray = NULL;
    DWORD dwNumVariants = 0;
    PWSTR *ppszStringArray = NULL;
    DWORD dwOptions = 0;
    int ldaperr = 0;
    DWORD dwCtr = 0;
    DWORD dwSecDescType = 0;
    BOOL fSearchDone = FALSE;
    
    DWORD dwControls = 0;
    PLDAPControl *ppServerControls = NULL;
    DWORD dwCurControl = 0;
    PLDAPControl pQuotaControl = NULL;
    PBERVAL pBerVal = NULL;   


    SECURITY_INFORMATION SeInfo = _seInfo;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };
    

    UNREFERENCED_PARAMETER(lnReserved);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSafeArrayToVariantArray(
             vProperties,
             &vVarArray,
             &dwNumVariants
             );
    // returns E_FAIL if vProperties is invalid
    if (hr == E_FAIL)
        hr = E_ADS_BAD_PARAMETER;
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantArrayToLDAPStringArray(
             vVarArray,
             &ppszStringArray,
             dwNumVariants
             );
    BAIL_ON_FAILURE(hr);

    while ((dwCtr < dwNumVariants) && (dwSecDescType == 0)) {
        if (_wcsicmp(ppszStringArray[dwCtr], L"ntSecurityDescriptor") == 0) {
            dwSecDescType = 1;
        }

        dwCtr++;
    }

    //
    // Do not bother doing this if secdesc has not been
    // explicitly requested.
    //
    if (dwSecDescType) {

        //
        // If the server is V3, we want to use controls in case
        // the security descriptor has to be retrieved
        //
        ldaperr = ldap_get_option(
                        _pLdapHandle->LdapHandle,
                        LDAP_OPT_VERSION,
                        &dwOptions
                        );

        if (dwOptions == LDAP_VERSION3) {

            hr = ReadSecurityDescriptorControlType(
                     _pszLDAPServer,
                     &dwSecDescType,
                     _Credentials,
                     _dwPort
                     );

            BAIL_ON_FAILURE(hr);

            if (dwSecDescType == ADSI_LDAPC_SECDESC_NT) {
                
                dwControls++;

                
            }
        }
    } // sec desc requested

    if(_pSid && _dwSidLength)
    {
        dwControls++;
    }

    if(dwControls)
    {
        ppServerControls = (PLDAPControl *) AllocADsMem( sizeof(PLDAPControl) * (dwControls+1) );
        if (!ppServerControls) 
        {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        if(dwSecDescType == ADSI_LDAPC_SECDESC_NT)
        {
            ppServerControls[dwCurControl++] = &SeInfoControl;
        }

        if(_pSid && _dwSidLength)
        {
            // add quota control
            pQuotaControl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

            if (!pQuotaControl) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            hr = BerEncodingQuotaControl((PBYTE)_pSid, _dwSidLength, &pBerVal);
            BAIL_ON_FAILURE(hr);

            pQuotaControl->ldctl_oid = LDAP_SERVER_QUOTA_CONTROL_OID_W;
            pQuotaControl->ldctl_value.bv_len = pBerVal->bv_len;

            pQuotaControl->ldctl_value.bv_val = (PCHAR) pBerVal->bv_val;
            pQuotaControl->ldctl_iscritical = TRUE;

            ppServerControls[dwCurControl++] = pQuotaControl;

            
        }

        ppServerControls[dwCurControl] = NULL;

        hr = LdapSearchExtS(
                         _pLdapHandle,
                         _pszLDAPDn,
                         LDAP_SCOPE_BASE,
                         TEXT("(objectClass=*)"),
                         ppszStringArray,
                         0,
                         ppServerControls,
                         NULL,
                         NULL,
                         10000,
                         &res
                         );

       fSearchDone = TRUE;
    }    


    //
    // At this point even if it is a vesion 3 DS, we might still
    // need to call the normal search routine as all version 3
    // DS's need not necessarily support controls - Ex: Exchange.
    //

    if (!fSearchDone) {

        hr = LdapSearchS(
                 _pLdapHandle,
                 _pszLDAPDn,
                 LDAP_SCOPE_BASE,
                 TEXT("(objectClass=*)"),
                 ppszStringArray,
                 0,
                 &res
                 );

        fSearchDone = TRUE;
    }

    BAIL_ON_FAILURE(hr);

    //
    // This is an explicit GetInfo[Ex], but we don't want to flush the
    // property cache.  For example, if we have [A B C] in the cache, and
    // we request [C D E], we want to end up with [A B C D E] in the cache.
    //
    // But we do want to tell LDAPUnMarshallProperties that this is an
    // explicit call; using the same example, we want the server's value of
    // C in the cache after this call, not the old value.
    //
    hr = _pPropertyCache->LDAPUnMarshallProperties2(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            TRUE,   // fExplicit
                            _Credentials,
                            &_fRangeRetrieval
                            );
    BAIL_ON_FAILURE(hr);


    for(DWORD i = 0; i < dwNumVariants; i++) {
    	_pPropertyCache->AddSavingEntry(ppszStringArray[i]);
    }

error:
    if (res)
        LdapMsgFree(res);

    if (ppszStringArray) {
    for (DWORD i = 0; i < dwNumVariants; i++)
        if (ppszStringArray[i])
            FreeADsStr(ppszStringArray[i]);
        FreeADsMem(ppszStringArray);
    }

    if (vVarArray) {
        for (dwCtr = 0; dwCtr < dwNumVariants; dwCtr++) {
            VariantClear(vVarArray + dwCtr);
        }
        FreeADsMem(vVarArray);
    }

    // free the LDAP server control
    if(pBerVal)
    {
        ber_bvfree(pBerVal);
    }
    
    if(pQuotaControl)
    {        
        FreeADsMem(pQuotaControl);
    }

    if(ppServerControls)
    {
        FreeADsMem(ppServerControls);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPGenObject::GetInfo()
{
    _fRangeRetrieval = FALSE;
    RRETURN(GetInfo(GETINFO_FLAG_EXPLICIT));
}

HRESULT
CLDAPGenObject::GetInfo(
    DWORD dwFlags
    )
{
    HRESULT hr = S_OK;
    LDAPMessage *res = NULL;
    int ldaperr = 0;
    DWORD dwOptions = 0;
    DWORD dwSecDescType = 0;
    BOOL fSearchDone = FALSE;


    SECURITY_INFORMATION SeInfo = _seInfo;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (dwFlags == GETINFO_FLAG_IMPLICIT_AS_NEEDED) {
        if (_pPropertyCache->getGetInfoFlag()) {
            //
            // We are done there is nothing to do.
            //
            goto error;
        }
    }


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    if ( dwFlags == GETINFO_FLAG_EXPLICIT )
    {
        // If this is an explicit GetInfo,
        // delete the old cache and start a new cache from scratch.

        _pPropertyCache->flushpropertycache();
    }

    // modified from LdapSearchS to LdapSearchExtS to get all attributes
    // including SecurityDescriptor by one call

    ldaperr = ldap_get_option(
                    _pLdapHandle->LdapHandle,
                    LDAP_OPT_VERSION,
                    &dwOptions
                    );

    if (dwOptions == LDAP_VERSION3) {

        hr = ReadSecurityDescriptorControlType(
                 _pszLDAPServer,
                 &dwSecDescType,
                 _Credentials,
                 _dwPort
                 );

        BAIL_ON_FAILURE(hr);

        if (dwSecDescType == ADSI_LDAPC_SECDESC_NT) {

            hr = LdapSearchExtS(
                     _pLdapHandle,
                     _pszLDAPDn,
                     LDAP_SCOPE_BASE,
                     TEXT("(objectClass=*)"),
                     NULL,  // modified to NULL for all attributes
                     0,
                     (PLDAPControl *)&ServerControls,
                     NULL,
                     NULL,
                     10000,
                     &res
                     );

            fSearchDone = TRUE;
        }
    }


    //
    // If the fSearchDone flags is not set, then the server
    // probably did not support the SecDesc control and we need to
    // just a search not extended.
    //
    if (!fSearchDone) {

        hr = LdapSearchS(
                    _pLdapHandle,
                    _pszLDAPDn,
                    LDAP_SCOPE_BASE,
                    TEXT("(objectClass=*)"),
                    NULL,
                    0,
                    &res
                    );

        fSearchDone = TRUE;

    }

    BAIL_ON_FAILURE(hr);

    hr = _pPropertyCache->LDAPUnMarshallProperties2(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            (dwFlags == GETINFO_FLAG_EXPLICIT) ?
                                TRUE : FALSE,
                            _Credentials,
                            &_fRangeRetrieval
                            );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();

error:

    if (res) {

        LdapMsgFree( res );
    }

    if (_pPropertyCache) {
       Reset();
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::get_GUID(THIS_ BSTR FAR* retval)
{

    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    ULONG ulLength = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    LPWSTR pszTempStr = NULL;
    WCHAR pszSmallStr[5];

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (_dwObjectState == ADS_OBJECT_UNBOUND) {
        RRETURN(E_ADS_OBJECT_UNBOUND);
    }

    if (!(_dwCorePropStatus & LDAP_GUID_VALID)) {

        //
        // Get the property from the server (implicit getinfo)
        // and update the property in the
        //
        hr = _pPropertyCache->getproperty(
                        L"objectGUID",
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

        BAIL_ON_FAILURE(hr);

        if ((ldapSrcObjects.dwCount == 0)
            || (ldapSrcObjects.dwCount > 1)) {
            BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
        }

        ulLength = LDAPOBJECT_BERVAL_LEN(ldapSrcObjects.pLdapObjects);

        pszTempStr = (LPWSTR) AllocADsMem((ulLength * 2 + 1) * sizeof(WCHAR));

        if (!pszTempStr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (DWORD dwCtr = 0; dwCtr < ulLength; dwCtr++) {
            wsprintf(pszSmallStr, L"%02x", (BYTE) LDAPOBJECT_BERVAL_VAL(ldapSrcObjects.pLdapObjects)[dwCtr]);
            wcscat(pszTempStr, pszSmallStr);
        }

        wcscat(pszTempStr, L"\0");

        if (_ADsGuid) {
            ADsFreeString(_ADsGuid);
            _ADsGuid = NULL;
        }

        hr = ADsAllocString(pszTempStr, &_ADsGuid);

        if (SUCCEEDED(hr)) {
            _dwCorePropStatus |= LDAP_GUID_VALID;
        }
    }


error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    if (pszTempStr) {
        FreeADsMem(pszTempStr);
    }

    if (SUCCEEDED(hr)) {
        RRETURN(get_CoreGUID(retval));
    }

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::get_Parent(BSTR * retval)
{

    HRESULT hr;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    LPWSTR pszTempStr = NULL;
    LPWSTR pszADsPath = NULL;
    LPWSTR pszADsParent = NULL;
    LPWSTR pszADsCommon = NULL;

    BOOL   fGCNameSpace = FALSE;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( (wcslen(_Name) > wcslen(L"<GUID=")) &&
         (_wcsnicmp(_Name, L"<GUID=", wcslen(L"<GUID=")) == 0)) {

        //
        // Replace the guid with the distinguishedName
        //

        //
        // Get the property from the server (implicit getinfo)
        //
        hr = _pPropertyCache->getproperty(
                        L"distinguishedName",
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

        BAIL_ON_FAILURE(hr);

        if (ldapSrcObjects.dwCount == 0) {
            BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
        }

        pszTempStr = LDAPOBJECT_STRING(ldapSrcObjects.pLdapObjects);


        //
        // Break it down into parent name & common name portions
        //

        // _ADsPath could not be NULL 
        if(!_wcsnicmp(L"GC:", _ADsPath, wcslen(L"GC:")))
        {
            fGCNameSpace = TRUE;
        }
        
        hr = BuildADsPathFromLDAPPath2(
                                       (_pszLDAPServer ? TRUE : FALSE),
                                       fGCNameSpace ? L"GC:" : L"LDAP:",
                                       _pszLDAPServer,
                                       _dwPort,
                                       pszTempStr,
                                       &pszADsPath
                                       );
        BAIL_ON_FAILURE(hr);

        hr = BuildADsParentPath(pszADsPath,
                                &pszADsParent,
                                &pszADsCommon);

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString(pszADsParent, retval);
        
    }
    else {

        hr = get_CoreParent(retval);

    }


error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    if (pszADsPath)
        FreeADsMem(pszADsPath);

    if (pszADsParent)
        FreeADsMem(pszADsParent);

    if (pszADsCommon)
        FreeADsMem(pszADsCommon);


    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPGenObject::get_Name(BSTR * retval)
{
    HRESULT hr;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    LPWSTR pszTempStr = NULL;
    LPWSTR pszADsPath = NULL;
    LPWSTR pszADsParent = NULL;
    LPWSTR pszADsCommon = NULL;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( (wcslen(_Name) > wcslen(L"<WKGUID=")) &&
         (_wcsnicmp(_Name, L"<WKGUID=", wcslen(L"<WKGUID=")) == 0)) {

        //
        // Replace the name with the DN
        //
        hr = ADsAllocString(_pszLDAPDn, retval);

    }
    else if ( (wcslen(_Name) > wcslen(L"<GUID=")) && 
              (_wcsnicmp(_Name, L"<GUID=", wcslen(L"<GUID=")) == 0)) {

        //
        // Replace the guid with the distinguishedName
        //

        //
        // Get the property from the server (implicit getinfo)
        //
        hr = _pPropertyCache->getproperty(
                        L"distinguishedName",
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

        BAIL_ON_FAILURE(hr);

        if (ldapSrcObjects.dwCount == 0) {
            BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
        }

        pszTempStr = LDAPOBJECT_STRING(ldapSrcObjects.pLdapObjects);


        //
        // Break it down into parent name & common name portions
        //
        hr = BuildADsPathFromLDAPPath2(
                                       (_pszLDAPServer ? TRUE : FALSE),
                                       L"LDAP:",           // does not matter, just a place holder
                                       _pszLDAPServer,
                                       _dwPort,   // doesn't matter
                                       pszTempStr,
                                       &pszADsPath
                                       );
        BAIL_ON_FAILURE(hr);

        hr = BuildADsParentPath(pszADsPath,
                                &pszADsParent,
                                &pszADsCommon);

        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString(pszADsCommon, retval);
        
    }
    else {
        hr = ADsAllocString(_Name, retval);
    }

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    if (pszADsPath)
        FreeADsMem(pszADsPath);

    if (pszADsParent)
        FreeADsMem(pszADsParent);

    if (pszADsCommon)
        FreeADsMem(pszADsCommon);


    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::get_Class(THIS_ BSTR FAR* retval)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    ULONG ulNumVals = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    PLDAPOBJECT pLdapObject = NULL;
    LPWSTR pszTempStr = NULL;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // Need to go on wire only if object is bound as in this
    // object is not being create now
    //
    if (!(_dwCorePropStatus & LDAP_CLASS_VALID)
        && _dwObjectState != ADS_OBJECT_UNBOUND) {

        //
        // Get the property from the server (implicit getinfo)
        // and update the property in the
        //
        hr = _pPropertyCache->getproperty(
                        L"objectClass",
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

        BAIL_ON_FAILURE(hr);

        if (ldapSrcObjects.dwCount == 0) {
            BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
        }


        ulNumVals = ldapSrcObjects.dwCount;

        pLdapObject = ldapSrcObjects.pLdapObjects;
        //
        // Try and see if we need the first or the last value
        //
        if (_wcsicmp(LDAPOBJECT_STRING(pLdapObject + (ulNumVals - 1)),
                     L"Top")== 0) {

            pszTempStr = LDAPOBJECT_STRING(
                             pLdapObject + 0
                             );
        } else {

            pszTempStr = LDAPOBJECT_STRING(
                             pLdapObject + (ulNumVals - 1)
                             );

        }

        if (_SchemaClass) {
            ADsFreeString(_SchemaClass);
            _SchemaClass = NULL;
        }

        hr = ADsAllocString(pszTempStr, &_SchemaClass);

        if (SUCCEEDED(hr)) {
            _dwCorePropStatus |= LDAP_CLASS_VALID;
        }
    }


error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );


    if (SUCCEEDED(hr)) {
        RRETURN(get_CoreADsClass(retval));
    }

    RRETURN(hr);

}


STDMETHODIMP
CLDAPGenObject::get_Schema(THIS_ BSTR FAR* retval)
{
    BSTR bstrTemp = NULL;

    //
    // We call the get_Class method because that will take care
    // of all the work we need to do in the event that we need
    // read the information from the server. It makes sense to do
    // that rather than repeat the code here.
    //
    HRESULT hr = get_Class(&bstrTemp);

    if (FAILED(hr)) {
        RRETURN(hr);
    }

    if (bstrTemp) {
        SysFreeString(bstrTemp);
    }

    RRETURN(get_CoreSchema(retval));
}

/* IADsContainer methods */

STDMETHODIMP
CLDAPGenObject::get_Count(long FAR* retval)
{
    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPGenObject::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    VariantClear(&_vFilter);

    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vHints);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    VariantClear(&_vHints);

    hr = VariantCopy(&_vHints, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    TCHAR *pszBuffer = NULL;
    HRESULT hr = S_OK;

    IADs *pADs = NULL;
    BSTR bstrClass = NULL;

    BSTR bstrParent  = NULL;
    BSTR bstrName    = NULL;
    LPWSTR pszADsPath = NULL;
    

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }


    //
    // Build an ADsPath from get_Parent/get_Name
    // (which always returns useful LDAP-style values)
    // rather than using _ADsPath, which could be
    // of the <GUID=....> form
    //
    hr = get_Parent(&bstrParent);
    BAIL_ON_FAILURE(hr);
    
    hr = get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromParent(bstrParent,
                                bstrName,
                                &pszADsPath);
    BAIL_ON_FAILURE(hr);


    //
    // Tack on the path component of the child
    // object being retrieved
    //
    hr = BuildADsPathFromParent(
             pszADsPath,
             RelativeName,
             &pszBuffer
             );
    BAIL_ON_FAILURE(hr);


    hr = ::GetObject(
                pszBuffer,
                _Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Check the class name only if we are not in umi land. In umi
    // land, we will fail the QI for the IID_IADs interface.
    //
    if(ClassName && !(_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED)) {
        hr = (*ppObject)->QueryInterface(
                    IID_IADs,
                    (void **)&pADs
                    );
        BAIL_ON_FAILURE(hr);

        hr = pADs->get_Class(&bstrClass);

        BAIL_ON_FAILURE(hr);
    
#ifdef WIN95
        if (_wcsicmp( bstrClass, ClassName )) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                bstrClass,
                -1,
                ClassName,
                -1
                ) != CSTR_EQUAL) {
#endif
            (*ppObject)->Release();
            *ppObject = NULL;
            BAIL_ON_FAILURE(hr=E_ADS_UNKNOWN_OBJECT);
        }
    }

error:

    if (bstrParent) {
        ADsFreeString(bstrParent);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }

    if ( pADs ) {
        pADs->Release();
    }

    if ( pszBuffer )
        FreeADsMem( pszBuffer );

    if ( bstrClass ) {
        SysFreeString( bstrClass );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = S_OK;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    *retval = NULL;

    hr = CLDAPGenObjectEnum::Create(
                (CLDAPGenObjectEnum **)&penum,
                _ADsPath,
                _pLdapHandle,
                this,
                _vFilter,
                _Credentials,
                _dwOptReferral,
                _dwPageSize
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    BOOL fValid = FALSE;

    BSTR bstrParent  = NULL;
    BSTR bstrName    = NULL;
    LPWSTR pszADsPath = NULL;


    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // No null or empty names for class or rdn.
    //
    if (!ClassName || !*ClassName
        || !RelativeName || !*RelativeName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }


    //
    // Build an ADsPath from get_Parent/get_Name
    // (which always returns useful LDAP-style values)
    // rather than using _ADsPath, which could be
    // of the <GUID=....> form
    //
    hr = get_Parent(&bstrParent);
    BAIL_ON_FAILURE(hr);
    
    hr = get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromParent(bstrParent,
                                bstrName,
                                &pszADsPath);
    BAIL_ON_FAILURE(hr);


    hr = CLDAPGenObject::CreateGenericObject(
                    pszADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IADs,
                    (void **) ppObject
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (bstrParent) {
        ADsFreeString(bstrParent);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }


    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = S_OK;
    BSTR bstrParent  = NULL;
    BSTR bstrName    = NULL;
    LPWSTR pszADsPath = NULL;
    BSTR bstrAbsoluteName = NULL;
    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszLDAPDn = NULL;
    LPTSTR *aValues = NULL;
    int nCount = 0;
    DWORD dwPort = 0;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // Check to see if the RelativeName is non empty
    //
    if (bstrRelativeName == NULL) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }


    //
    // Build an ADsPath from get_Parent/get_Name
    // (which always returns useful LDAP-style values)
    // rather than using _ADsPath, which could be
    // of the <GUID=....> form
    //
    hr = get_Parent(&bstrParent);
    BAIL_ON_FAILURE(hr);
    
    hr = get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromParent(bstrParent,
                                bstrName,
                                &pszADsPath);
    BAIL_ON_FAILURE(hr);


    //
    // Tack on the path component of the child object to be
    // deleted
    //
    hr = BuildADsPath(
                pszADsPath,
                bstrRelativeName,
                &bstrAbsoluteName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             bstrAbsoluteName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Compare the class names only if one is given. Null
    // can be used to speed up the delete operation.
    //
    if (bstrClassName) {
        //
        //  Validate the class name first
        //
        hr = LdapReadAttribute(
                        pszLDAPServer,
                        pszLDAPDn,
                        TEXT("objectClass"),
                        &aValues,
                        &nCount,
                        _Credentials,
                        _dwPort
                        );
        BAIL_ON_FAILURE(hr);


        if ( nCount > 0 )
        {
            if ( _tcsicmp( bstrClassName, GET_BASE_CLASS( aValues, nCount) ) != 0 )
            {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
        }
    }

    hr = LdapDeleteS(
             _pLdapHandle,
             pszLDAPDn
             );
    BAIL_ON_FAILURE(hr);

error:

    if (bstrParent) {
        ADsFreeString(bstrParent);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }

    if ( bstrAbsoluteName ) {
        ADsFreeString( bstrAbsoluteName );
    }

    if ( pszLDAPServer ) {
        FreeADsStr( pszLDAPServer );
    }

    if (pszLDAPDn) {

       FreeADsStr(pszLDAPDn);
    }

    if ( aValues ) {
        LdapValueFree( aValues );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

/*
    RRETURN(CopyObject( SourceName,
                        _ADsPath,
                        _pLdapHandle,
                        _pSchemaInfo,
                        NewName,
                        ppObject ) );

                        */
    RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

STDMETHODIMP
CLDAPGenObject::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    LPWSTR pszLDAPServer= NULL;
    LPWSTR pszLDAPDn = NULL;
    
    BSTR bstrParent = NULL;
    BSTR bstrName = NULL;
    LPWSTR pszADsPath = NULL;

    HRESULT hr = S_OK;
    LPWSTR pszSrcParent= NULL;
    LPWSTR pszCN = NULL;
    LPWSTR pszRelativeName = NULL;
    BSTR bstrDestADsPath = NULL;
    LPWSTR pszDestLDAPServer = NULL;
    LPWSTR pszDestLDAPDn = NULL;
    LPWSTR pszLDAPServerTemp = NULL;
    LPWSTR pszLDAPSourceDnParent = NULL;
    DWORD dwPort = 0;
    LPBOOL lpBoolVal = NULL;

    // Variables need to conver wide char to ANSI format
    DWORD dwOptions = 0;
    int intErr = 0;
    LPSTR pANSIServer = NULL;
    DWORD dwDestLen = 0;
    DWORD dwTempLen = 0;
    PADSLDP pSourceLD = NULL;
    BOOL fTryXDom = FALSE;

    LPWSTR pszDestLDAPRelativeName = NULL;

    LDAPControl     RenExtInfoControl =
                    {
                        LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W,
                        {
                            0, NULL
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &RenExtInfoControl,
                        NULL
                    };

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // Build the source paths of the object
    // being moved
    //
    hr = BuildADsParentPath(
             SourceName,
             &pszSrcParent,
             &pszCN
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             SourceName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    if (!pszSrcParent) {
        //
        // If we cannot get the parent, then we cannot move this object.
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // We need the dn to the parent of the object being moved.
    //
    hr = BuildLDAPPathFromADsPath2(
             pszSrcParent,
             &pszLDAPServerTemp,
             &pszLDAPSourceDnParent,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);


    //
    // set the right value of relative distinguished name
    // use the name given by the user if given at all
    // otherwise use the name of the source
    //
    if (NewName != NULL) {
        pszRelativeName = NewName;

    } else {
        pszRelativeName = pszCN;
    }


    //
    // Build an ADsPath from get_Parent/get_Name
    // (which always returns useful LDAP-style values)
    // rather than using _ADsPath, which could be
    // of the <GUID=....> form
    //
    hr = get_Parent(&bstrParent);
    BAIL_ON_FAILURE(hr);

    hr = get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsPathFromParent(
             bstrParent,
             bstrName,
             &pszADsPath
             );
    BAIL_ON_FAILURE(hr);

    //
    // Build the destination ADsPath of the object being moved.
    //
    hr = BuildADsPath(
             pszADsPath,
             pszRelativeName,
             &bstrDestADsPath
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             bstrDestADsPath,
             &pszDestLDAPServer,
             &pszDestLDAPDn,
             &dwPort
             );

    BAIL_ON_FAILURE(hr);

    //
    // ADSI needs to escape /, but on server side, / is not a special character. So if someone passes
    // in rdn but has ADSI type escaping, we need to convert it to ldap type path, otherwise server will
    // reject this kind of rdn
    //
    hr = GetLDAPTypeName(
    	     pszRelativeName,
    	     &pszDestLDAPRelativeName
    	     );

    BAIL_ON_FAILURE(hr); 
    
    //
    // LdapModDNS uses ldap_modrdn2_s. This function is used to
    // rename the object not to really move it. If the path of this
    // container and the parentDN of the object being moved here are
    // not the same, we need to use ldapRenameExt instead.
    //
#ifdef WIN95
    if (!_wcsicmp(_pszLDAPDN, pszLDAPSourceDnParent)) {
#else
    if (CompareStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        _pszLDAPDn,
                        -1,
                        pszLDAPSourceDnParent,
                        -1
                    ) == CSTR_EQUAL ) {
#endif

        //
        // They have the same parent, so we can use LdapModDnS.
        //
        hr = LdapModDnS(
                 _pLdapHandle,
                 pszLDAPDn,
                 pszDestLDAPRelativeName,
                 TRUE
                 );
    } 
    else {
        //
        // Since the object is not in this container, we need to use
        // the renameExt call.
        //
        hr = LdapRenameExtS(
                 _pLdapHandle,
                 pszLDAPDn,
                 pszDestLDAPRelativeName,
                 _pszLDAPDn,
                 TRUE,
                 NULL,
                 NULL
                 );
    }

    // if there was an error it maybe because the move should
    // be across the domains.
    if (FAILED(hr)) {

        intErr = ldap_get_option(
                      _pLdapHandle->LdapHandle,
                      LDAP_OPT_VERSION,
                      &dwOptions
                      );

        //
        // Only if server is V3 and if the server names are not
        // the same will we attempt the extended rename operation.
        // is there are a better way to decide ?
        //

        if (!pszDestLDAPServer) {
            //
            // This object does not have a server, we should
            // read it and then use that as the target server.
            //

            // If this call succeeds, it will copy the servername
            // to the ptr, even if it fails, there should not be problem
            // of memory leak
            //
            GetActualHostName(&pszDestLDAPServer);
            
        } // if !pszDestLDAPServer

        //
        // Try the XDom move only if we have no match on the server
        // names. Note that there is small chance that we will call
        // crossdom when both are serverless but that should be rare
        // as the ModDN call should have succeeded.
        // If the source server is NULL, LDAPOpenObject will handle
        // that case. The target can never be NULL for XDOm.
        //
        if (dwOptions == LDAP_VERSION3 && pszDestLDAPServer) {
            if (!pszLDAPServer) {
                //
                // One server is set the other is not.
                //
                fTryXDom = TRUE;
            }
#ifdef WIN95
            else if (_wcsicmp(pszLDAPServer, pszDestLDAPServer)) {
#else
            else if (CompareStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        pszLDAPServer,
                        -1,
                        pszDestLDAPServer,
                        -1
                    ) != CSTR_EQUAL ) {
#endif
                //
                // Only if both the servers are different.
                //
                fTryXDom = TRUE;
            }
        }

        if (fTryXDom) {
            //
            // The move request has to go to the server that has
            // the object not the target server.
            //
            dwDestLen = _tcslen(pszDestLDAPServer);
            dwTempLen = LdapUnicodeToUTF8(
                            pszDestLDAPServer,
                            dwDestLen,
                            NULL,
                            0
                            );
            // pszDestLDAPServer will not be NULL here
            if(!dwTempLen)
            {
                // keep the previous behavior
                
                // note that there has to be a valid hr from the
                // previous LdapModDN call to be here.
                BAIL_ON_FAILURE(hr);
            }
            pANSIServer = (LPSTR)LocalAlloc(LPTR, dwTempLen + 1);


            if (!pANSIServer) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            intErr = LdapUnicodeToUTF8(
                         pszDestLDAPServer,
                         dwDestLen,
                         pANSIServer,
                         dwTempLen + 1
                         );

            /*
            intErr = WideCharToMultiByte(
                         CP_OEMCP,
                         WC_DEFAULTCHAR,
                         pszDestLDAPServer,
                         dwDestLen,
                         pANSIDestServer,
                         dwDestLen * 2,
                         NULL,
                         lpBoolVal
                         );
            */

            if (!intErr) {
                // note that there has to be a valid hr from the
                // previous LdapModDN call to be here.
                BAIL_ON_FAILURE(hr);
            }

            *(pANSIServer+dwTempLen) = '\0';


            // Update the control information
            RenExtInfoControl.ldctl_value.bv_len = strlen(pANSIServer);
            RenExtInfoControl.ldctl_value.bv_val = pANSIServer;

            CCredentials Credentials = _Credentials;

            //
            // Add request delegation flag
            //
            Credentials.SetAuthFlags(
                            _Credentials.GetAuthFlags()
                            | ADS_USE_DELEGATION
                            );


            hr = LdapOpenObject(
                     pszLDAPServer,
                     pszLDAPDn,
                     &pSourceLD,
                     Credentials,
                     dwPort
                     );
            BAIL_ON_FAILURE(hr);


            hr = LdapRenameExtS(
                     pSourceLD,
                     pszLDAPDn,
                     pszDestLDAPRelativeName,
                     _pszLDAPDn,
                     TRUE,
                     ServerControls,
                     NULL
                     );

        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // We do not need to pass the class name - even if we do it
    // is not used
    //
    hr = GetObject(
            NULL,
            pszDestLDAPRelativeName,
            (IDispatch **)ppObject
            );


error:

    if (bstrParent) {
        ADsFreeString(bstrParent);
    }

    if (bstrName) {
        ADsFreeString(bstrName);
    }

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }

    if(pszSrcParent){
        FreeADsStr(pszSrcParent);
    }

    if(pszCN){
        FreeADsStr(pszCN);
    }

    if(bstrDestADsPath){
        ADsFreeString(bstrDestADsPath );
    }

    if(pszDestLDAPServer){
        FreeADsStr(pszDestLDAPServer);
    }

    if(pszDestLDAPDn){
        FreeADsStr(pszDestLDAPDn);
    }


    if(pszLDAPServer){
        FreeADsStr(pszLDAPServer);
    }

    if(pszLDAPDn){
        FreeADsStr(pszLDAPDn);
    }

    if (pszLDAPServerTemp) {
        FreeADsStr(pszLDAPServerTemp);
    }

    if (pszLDAPSourceDnParent) {
        FreeADsStr(pszLDAPSourceDnParent);
    }

    if (pANSIServer) {
        LocalFree(pANSIServer);
    }

    if (pSourceLD) {
        LdapCloseObject(pSourceLD);
    }

    if (pszDestLDAPRelativeName) {
    	FreeADsStr(pszDestLDAPRelativeName);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPGenObject::AllocateGenObject(
    LPWSTR pszClassName,
    CCredentials &Credentials,
    CLDAPGenObject ** ppGenObject
    )
{
    CLDAPGenObject FAR * pGenObject = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CLDAPGenObject();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pGenObject,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsObjectOptions,
                           (IADsObjectOptions *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsDeleteOps,
                           (IADsDeleteOps *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *) pGenObject,
                        (IGetAttributeSyntax *)pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(pPropertyCache);


    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pGenObject;

    RRETURN_EXP_IF_ERR(hr);

}

//
// IADsObjOptPrivate methods, IADsObjectOptions are wrapped
// around this.
//

STDMETHODIMP
CLDAPGenObject::GetOption(
    DWORD dwOption,
    void *pValue
    )
{

    HRESULT hr = S_OK;
    CtxtHandle hCtxtHandle;
    DWORD dwErr = 0;
    ULONG ulFlags = 0;
    DWORD dwPropertyStatus;
    LONG lUserAccountCtrlVal;

    if (!pValue) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    switch( dwOption ) {

    case LDP_CACHE_ENTRY:
        *((PADSLDP *) pValue) = _pLdapHandle;
        break;

    case LDAP_HANDLE:
        *((LDAP **) pValue) = _pLdapHandle ? _pLdapHandle->LdapHandle : (LDAP *) NULL;
        break;

    case LDAP_SERVER:
    	//
    	// pValue here is expected to be a pointer to LPWSTR
    	//
        hr = GetActualHostName((LPWSTR *)pValue);
        break;

    case LDAP_DN:
        *((LPWSTR *) pValue) = _pszLDAPDn;
        break;

    case LDAP_CHASE_REFERRALS:
        *((DWORD *) pValue) = _dwOptReferral;
        break;

    case LDAP_PAGESIZE:
        *((DWORD *) pValue) = _dwPageSize;
        break;

    case LDAP_SECURITY_MASK:
        *((SECURITY_INFORMATION*) pValue) = _seInfo;
        break;

    case LDAP_MUTUAL_AUTH_STATUS:
        dwErr = ldap_get_option(
                    _pLdapHandle->LdapHandle,
                    LDAP_OPT_SECURITY_CONTEXT,
                    (void *) &hCtxtHandle
                    );
        if (dwErr) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

#if (!defined(WIN95))
        dwErr = QueryContextAttributesWrapper(
                    &hCtxtHandle,
                    SECPKG_ATTR_FLAGS,
                    (void *) &ulFlags
                    );
        if (dwErr) {
            if (dwErr == SEC_E_INVALID_HANDLE) {
                //
                // This will happen when SSL is used for certain.
                //
                hr = E_ADS_BAD_PARAMETER;
            } 
            else {
                hr = HRESULT_FROM_WIN32(dwErr);
            }
            BAIL_ON_FAILURE(hr);
        }
#else
        ulFlags = 0;
#endif

        *((ULONG *) pValue) = ulFlags;
        break;

    case LDAP_MEMBER_HAS_RANGE :
        *((BOOL *) pValue) = _fRangeRetrieval;
        break;

    case LDAP_USERACCOUNTCONTROL :           
        hr = get_LONG_Property(this, TEXT("userAccountControl"), &lUserAccountCtrlVal );
        // if it failed, we treat it as user does not want to explicitly unset the UF_LOCKOUT bit
        if(FAILED(hr))
        {
            *((BOOL *) pValue) = FALSE;
            break;
        }

        // user does not want to unset the UF_LOCKOUT flag
        if(lUserAccountCtrlVal & UF_LOCKOUT)
        {
            *((BOOL *) pValue) = FALSE;
            break;
        }   
        
        hr = _pPropertyCache->GetPropertyFlag(L"userAccountControl", &dwPropertyStatus);
        
        if(FAILED(hr))
            *((BOOL *) pValue) = FALSE;                    
        else if(dwPropertyStatus == PROPERTY_UPDATE || dwPropertyStatus == PROPERTY_ADD)
            *((BOOL *) pValue) = TRUE;
        else
            *((BOOL *) pValue) = FALSE;     

        break;
            

    default:
        *((DWORD *) pValue) = 0;
        hr = E_ADS_BAD_PARAMETER;

    }

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::SetOption(
    DWORD dwOption,
    void *pValue
    )
{

    HRESULT hr = S_OK;
    int ldaperr = 0;
    void *ldapOption = 0;

    switch (dwOption) {

    case LDAP_CHASE_REFERRALS:

        switch (*((DWORD *)pValue) ) {

        case ADS_CHASE_REFERRALS_NEVER:
            _dwOptReferral = (DWORD) (DWORD_PTR) LDAP_OPT_OFF;
            break;

        case ADS_CHASE_REFERRALS_SUBORDINATE:
            _dwOptReferral = LDAP_CHASE_SUBORDINATE_REFERRALS;
            break;

        case ADS_CHASE_REFERRALS_EXTERNAL:
            _dwOptReferral = LDAP_CHASE_EXTERNAL_REFERRALS;
            break;

        case ADS_CHASE_REFERRALS_ALWAYS:
            _dwOptReferral = (DWORD) (DWORD_PTR) LDAP_OPT_ON;
            break;

        default:
            RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
        }

        break;

    case LDAP_PAGESIZE:
        _dwPageSize = *((DWORD *)pValue);
        break;

    case LDAP_SECURITY_MASK:
        _seInfo = *((SECURITY_INFORMATION *) pValue);
        _fExplicitSecurityMask = TRUE;
        break;

    default:

        hr = E_ADS_BAD_PARAMETER;
        break;
    }

    RRETURN_EXP_IF_ERR( hr );

}


//
// IADsObjecOptions methods - wrapper around IADsObjOptPrivate
//

STDMETHODIMP
CLDAPGenObject::GetOption(
    THIS_ long lnControlCode,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszServerTemp = NULL;
    
    ULONG ulMutualAuth = 0;

    VariantInit(pvProp);

    switch (lnControlCode) {

    case ADS_OPTION_SERVERNAME:

        hr = GetOption(LDAP_SERVER, (void *) &pszServerTemp);
        BAIL_ON_FAILURE(hr);

        pvProp->vt = VT_BSTR;

        hr = ADsAllocString(
                 pszServerTemp,
                 &(pvProp->bstrVal)
                 );
        break;

    case ADS_OPTION_SECURITY_MASK:
        //
        // No need to call GetOpion at least not now
        //
        pvProp->vt = VT_I4;
        pvProp->lVal = (ULONG) _seInfo;
        break;

    case ADS_OPTION_REFERRALS :
        pvProp->vt = VT_I4;

        switch (_dwOptReferral) {

        case ((DWORD) (DWORD_PTR)LDAP_OPT_OFF) :
            pvProp->lVal = ADS_CHASE_REFERRALS_NEVER;
            break;

        case LDAP_CHASE_SUBORDINATE_REFERRALS :
            pvProp->lVal = ADS_CHASE_REFERRALS_SUBORDINATE;
            break;

        case LDAP_CHASE_EXTERNAL_REFERRALS :
            pvProp->lVal = ADS_CHASE_REFERRALS_EXTERNAL;
            break;

        case ((DWORD) (DWORD_PTR)LDAP_OPT_ON) :
            pvProp->lVal = ADS_CHASE_REFERRALS_ALWAYS;
            break;

        default:
            pvProp->lVal = 0;
            hr = E_ADS_PROPERTY_INVALID;

        }

        break;

    case ADS_OPTION_PAGE_SIZE :
        pvProp->vt = VT_I4;
        pvProp->lVal = (ULONG) _dwPageSize;
        break;

    case ADS_OPTION_MUTUAL_AUTH_STATUS :
        hr = GetOption(LDAP_MUTUAL_AUTH_STATUS, (void *) &ulMutualAuth);
        BAIL_ON_FAILURE(hr);

        pvProp->vt = VT_I4;
        pvProp->lVal = ulMutualAuth;
        break;

    case ADS_OPTION_PASSWORD_PORTNUMBER :
        pvProp->vt = VT_I4;
        if(_fPasswordPortSet)
        {
            // user explicitly set the password
            pvProp->lVal = _dwPasswordPort;
        }
        else
        {
            // we need to use the default value
            if(_dwPasswordMethod == ADS_PASSWORD_ENCODE_REQUIRE_SSL)
                pvProp->lVal = 636;
            else
                pvProp->lVal = 389;
        }
        break;

    case ADS_OPTION_PASSWORD_METHOD :
        pvProp->vt = VT_I4;
        pvProp->lVal = _dwPasswordMethod;
        break;

    default:
        hr = E_ADS_BAD_PARAMETER;
    }

error :

	if (pszServerTemp) {
		FreeADsStr(pszServerTemp);
	}
	
    RRETURN(hr);
}

STDMETHODIMP
CLDAPGenObject::SetOption(
    THIS_ long lnControlCode,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwOptVal = 0;
    VARIANT *pvProp = NULL;
    LPWSTR pszServerTemp = NULL;    
    PSID   pSidTemp = NULL;
    DWORD dwSidSizeTemp;
    BOOL fNTDS = TRUE;

    //
    // To make sure we handle variant by refs correctly.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    switch (lnControlCode) {
    case ADS_OPTION_REFERRALS :

        hr = GetIntegerFromVariant(pvProp, &dwOptVal);

        if (SUCCEEDED(hr))
            hr = SetOption(LDAP_CHASE_REFERRALS, (void *) &dwOptVal);

        break;

    case ADS_OPTION_PAGE_SIZE :

        hr = GetIntegerFromVariant(pvProp, &dwOptVal);

        if (SUCCEEDED(hr))
            hr = SetOption(LDAP_PAGESIZE, (void *) &dwOptVal);

        break;

    case ADS_OPTION_SECURITY_MASK :

        hr = GetIntegerFromVariant(pvProp, &dwOptVal);

        if (SUCCEEDED(hr)) {
            _seInfo = (SECURITY_INFORMATION) dwOptVal;
            _fExplicitSecurityMask = TRUE;
        }
         
        break;

    case ADS_OPTION_QUOTA :

        // validate the parameter
        if(pvProp->vt == VT_EMPTY)
        {
            // user just wants to set the sid as himself

            // Free existing memory if necessary
            if(_pSid)
            {
                FreeADsMem(_pSid);
                
                _pSid = NULL;
                _dwSidLength = 0;
            }                        
            
        }
        else if(pvProp->vt == VT_BSTR)
        {
            if(pvProp->bstrVal && *(pvProp->bstrVal) != L'\0')
            {                
                // get the server name
                hr = GetOption(LDAP_SERVER, (void *) &pszServerTemp);
                if(FAILED(hr))
                    break;

                hr = ReadServerType(pszServerTemp,
                                    &_Credentials,
                                    &fNTDS
                                   );
                if(FAILED(hr))
                    break;

                // convert the trustee to sid
                hr = ConvertTrusteeToSid(pszServerTemp,
                                        _Credentials,
                                        pvProp->bstrVal,
                                        &pSidTemp,
                                        &dwSidSizeTemp,
                                        fNTDS
                                        );
                if(FAILED(hr))
                    break;

                // Free existing memory if necessary
                if(_pSid)
                {
                    FreeADsMem(_pSid);
                }
                    
                _pSid = pSidTemp;
                _dwSidLength = dwSidSizeTemp;     
                                        
                                        
            }
            else
            {
                // user just wants to set the sid as himself

                // Free existing memory if necessary
                if(_pSid)
                {
                    FreeADsMem(_pSid);

                    _pSid = NULL;
                    _dwSidLength = 0;
                }
                
            }
        }  
        else
        {
            hr = E_ADS_BAD_PARAMETER;
        }

        break;

    case ADS_OPTION_PASSWORD_PORTNUMBER:
        hr = GetIntegerFromVariant(pvProp, &dwOptVal);
        if(SUCCEEDED(hr))
        {
            _dwPasswordPort = dwOptVal;
            _fPasswordPortSet = TRUE;
        }

        break;        

    case ADS_OPTION_PASSWORD_METHOD:
        hr = GetIntegerFromVariant(pvProp, &dwOptVal);
        if(SUCCEEDED(hr))
        {
            if(dwOptVal == ADS_PASSWORD_ENCODE_REQUIRE_SSL || dwOptVal == ADS_PASSWORD_ENCODE_CLEAR)
            {
                _dwPasswordMethod = dwOptVal;
            }
            else
            {
                hr = E_ADS_BAD_PARAMETER;
            }
        }

        break;

    case ADS_PRIVATE_OPTION_SPECIFIC_SERVER :

        //
        // If it is just a VT_BSTR, then this is old.
        // If this is an array, then it should also 
        // have the domain information.
        //
        if (pvProp->vt == VT_BSTR) {

            if (gpszStickyDomainName) {
                FreeADsStr(gpszStickyDomainName);
                gpszStickyDomainName = NULL;
            }

            if (gpszStickyServerName) {
                FreeADsStr(gpszStickyServerName);
                gpszStickyServerName = NULL;
            }
            //
            // Set for LDAP layer
            //
            if (pvProp->bstrVal) {
                gpszStickyServerName = AllocADsStr(pvProp->bstrVal);

                if (!gpszStickyServerName) {
                    hr = E_OUTOFMEMORY;
                }
            }

            if (SUCCEEDED(hr)) {
                hr = LdapcSetStickyServer(NULL, pvProp->bstrVal);
            }
        }
        else if ((pvProp->vt & VT_ARRAY)) {
            hr = SetStickyServerWithDomain(pvProp);
        }

        break;

    default:
        hr = E_ADS_BAD_PARAMETER;
    }

    // release the memory
    if (pszServerTemp) {
    	FreeADsStr(pszServerTemp);
    }


    RRETURN(hr);
}


HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    HRESULT hr = S_OK;
    VARIANT * pvarData = NULL;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // Although no known automation controller passes
    // VT_VARIANT|VT_BYREF into get_/put_ function
    // as a reference to an array, we carry out the following
    // check for extra safety.
    //
    pvarData = &varData;
    if (V_VT(pvarData) == (VT_VARIANT|VT_BYREF)) {
    pvarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pvarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
    (V_VT(pvarData) ==  (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  *pvarData,
                  &pVarArray,
                  &dwNumValues
                  );
        // returns E_FAIL if *pvarData is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;                
        BAIL_ON_FAILURE(hr);

    } else {

        pVarArray = NULL;
        dwNumValues = 0;
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}


HRESULT
ConvertVariantToLdapValues(
    VARIANT varData,
    LPWSTR* ppszPropertyName,
    PDWORD pdwControlCode,
    LDAPOBJECTARRAY * pldapDestObjects,
    PDWORD pdwSyntaxId,
    LPWSTR pszServer,
    CCredentials* pCredentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;
    PVARIANT pVar = NULL;
    BOOL fNTDSType = TRUE;
    BOOL fGenTime = FALSE;
    DWORD dwServerSyntaxId = 0;

    *ppszPropertyName = NULL;


    if (V_VT(&varData) != VT_DISPATCH) {

        if (V_VT(&varData) != (VT_VARIANT | VT_BYREF)) {

            RRETURN (hr = DISP_E_TYPEMISMATCH);
        }
        else {

            pVar = V_VARIANTREF(&varData);

            if (pVar == NULL || V_VT(pVar) != VT_DISPATCH) {

                RRETURN (hr = DISP_E_TYPEMISMATCH);
            }
            else {
                pDispatch = V_DISPATCH(pVar);
            }
        }
    }
    else {
        pDispatch = V_DISPATCH(&varData);
    }


    VariantInit(&varValues);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);

    // property name should not be NULL
    if(!bstrPropName)
    {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    *ppszPropertyName= AllocADsStr(bstrPropName);
    if(!(*ppszPropertyName))
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }    

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        //
        // At this point it is probably cheaper to read the
        // server type and send the values to the conversion
        // routines than to check if this is a securityDescriptor
        // by walking the PropertyEntry and then looking at the variant.
        // There is a good chance that this information is already cached.
        //

        hr = ReadServerType(
                         pszServer,
                         pCredentials,
                         &fNTDSType
                         );
        BAIL_ON_FAILURE(hr);


        hr = PropVariantToAdsType2(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues,
                    pszServer,
                    pCredentials,
                    fNTDSType
                    );
        BAIL_ON_FAILURE(hr);

        if (dwAdsType == ADSTYPE_UTC_TIME) {
            //
            // See if this is a GenTime on the server
            //
            HRESULT hr;
            hr = LdapGetSyntaxOfAttributeOnServer(
                     pszServer,
                     *ppszPropertyName,
                     &dwServerSyntaxId,
                     *pCredentials,
                     dwPort
                     );

            if (FAILED(hr)) {
                hr = S_OK;
            }
            else if (dwServerSyntaxId == LDAPTYPE_GENERALIZEDTIME) {
                fGenTime = TRUE;
            }
        }

        hr = AdsTypeToLdapTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    pldapDestObjects,
                    pdwSyntaxId,
                    fGenTime
                    );
        BAIL_ON_FAILURE(hr);

    }

    *pdwControlCode = dwControlCode;

cleanup:

    if (bstrPropName) {
        ADsFreeString(bstrPropName);
    }

    if (pAdsValues) {
        AdsTypeFreeAdsObjects(
                pAdsValues,
                dwNumValues
                );
    }

    if (pVarArray) {

        FreeVariantArray(
                pVarArray,
                dwAdsValues
                );
    }

    if (pPropEntry) {

        pPropEntry->Release();
    }

    VariantClear(&varValues);

    RRETURN(hr);

error:

    LdapTypeFreeLdapObjects( pldapDestObjects );

    if(*ppszPropertyName)
    {
        FreeADsStr(*ppszPropertyName);
        *ppszPropertyName = NULL;
    }

    goto cleanup;

}


HRESULT
MapAdsTypeToLdapType(
    BSTR bstrPropName,
    DWORD dwAdsType,
    PDWORD pdwLdapType
    )
{
    RRETURN(S_OK);
}



HRESULT
ConvertLdapValuesToVariant(
    BSTR bstrPropName,
    LDAPOBJECTARRAY * pldapSrcObjects,
    DWORD dwLdapType,
    DWORD dwControlCode,
    PVARIANT pVarProp,
    LPWSTR pszServer,
    CCredentials* pCredentials
    )
{
    HRESULT hr = S_OK;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwNumValues = 0;
    DWORD dwAdsType = 0;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    BOOL fNTDS = TRUE;

    VariantInit(&varData);
    VariantClear(&varData);
    VariantInit(pVarProp);

    // pldaSrcObject should never be null
    ADsAssert(pldapSrcObjects);

    if (dwControlCode != ADS_PROPERTY_DELETE ) {

        hr = LdapTypeToAdsTypeCopyConstruct(
                 *pldapSrcObjects,
                 dwLdapType,
                 &pAdsValues,
                 &dwNumAdsValues,
                 &dwAdsType
                 );

        if (SUCCEEDED(hr)) {

            dwNumValues = pldapSrcObjects->dwCount;

            //
            // if the property is a security descriptor
            // we need to set the server type also
            //

            if (dwAdsType == ADSTYPE_NT_SECURITY_DESCRIPTOR) {

                hr = ReadServerType(
                         pszServer,
                         pCredentials,
                         &fNTDS
                         );
                BAIL_ON_FAILURE(hr);

                hr = AdsTypeToPropVariant2(
                         pAdsValues,
                         dwNumValues,
                         &varData,
                         pszServer,
                         pCredentials,
                         fNTDS
                         );

            } else {

                hr = AdsTypeToPropVariant(
                         pAdsValues,
                         dwNumValues,
                         &varData
                         );
            }

            BAIL_ON_FAILURE(hr);

        } else {

            // We could not convert the data type
            // This maybe because we have the invalid data type
            // so we will just return the variant data as null
            // and also set the data type to 0 or invalid in that case
            if (dwLdapType == LDAPTYPE_UNKNOWN) {
                dwAdsType = 0;
                hr = S_OK;
            } else {
                // since the datatpye was valid, we should
                // send this back to the user.
                BAIL_ON_FAILURE(hr);
            }

        }
    } else {

        dwAdsType = 0;

    }

    hr = CreatePropEntry(
            bstrPropName,
            dwAdsType,
            dwNumValues,
            dwControlCode,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pVarProp) = pDispatch;
    V_VT(pVarProp) = VT_DISPATCH;

error:

    VariantClear(&varData);

    if (pAdsValues) {
       AdsTypeFreeAdsObjects(
            pAdsValues,
            dwNumValues
            );
    }

    RRETURN(hr);
}


//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPGenObject::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr;
    hr = LdapGetSyntaxOfAttributeOnServer(
         _pszLDAPServer,
         szPropertyName,
         pdwSyntaxId,
         _Credentials,
         _dwPort
         );
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CLDAPGenObject::DeleteObject(
    long lnFlags
    )
{
    HRESULT hr = S_OK;

    LDAPControl     SeInfoControlRecursDelete =
                    {
                        LDAP_SERVER_TREE_DELETE_OID_W,

                        { NULL, NULL},

                        FALSE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControlRecursDelete,
                        NULL
                    };


    hr = LdapDeleteExtS(
                    _pLdapHandle,
                    _pszLDAPDn,
                    (PLDAPControl *)&ServerControls,
                    NULL
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::GetActualHostName(
    LPWSTR * pValue
    )
{
    HRESULT hr = S_OK;

    DWORD dwLength = MAX_PATH;
    LPWSTR szHostName = NULL;
    int err = 0;

    LDAPMessage *pMsgResult = NULL;
    LDAPMessage *pMsgEntry = NULL;
    LDAP *pLdapCurrent = NULL;
    LPWSTR Attributes[] = {L"objectClass", NULL};

    //
    // We need to get at the actual object as we may have a
    // referral
    //
    hr = LdapSearchS(
             _pLdapHandle,
             _pszLDAPDn,
             LDAP_SCOPE_BASE,
             L"(objectClass=*)",
             Attributes,
             0,
             &pMsgResult
             );

    //
    // Only one entry should be returned
    //
    BAIL_ON_FAILURE(hr);

    hr = LdapFirstEntry(
             _pLdapHandle,
             pMsgResult,
             &pMsgEntry
             );
    BAIL_ON_FAILURE(hr);

    pLdapCurrent = pMsgResult->Connection;

    err = ldap_get_optionW(
              pLdapCurrent,
              LDAP_OPT_HOST_NAME,
              &szHostName
              );

    if (err != LDAP_SUCCESS || szHostName == NULL) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    // If we are here we need to copy the name and return

    *pValue = AllocADsStr(szHostName);
    if(!(*pValue)) {
    	hr = E_OUTOFMEMORY;
    	BAIL_ON_FAILURE(hr);
    }
    
    
error:

    if (pMsgResult) {
        LdapMsgFree(pMsgResult);
    }

    RRETURN(hr);
}

HRESULT
GetIntegerFromVariant(
    VARIANT* pvProp,
    DWORD* pdwVal)
{
    HRESULT hr = S_OK;

    *pdwVal = 0;

    if (pvProp->vt == VT_I4) {

        *pdwVal = pvProp->lVal;

    }
    else if(pvProp->vt == VT_I2) {

        *pdwVal = pvProp->iVal;

    } else
        hr = E_ADS_BAD_PARAMETER;

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   TraceTreeForClass
//
//  Synopsis: Traces the inheritance hierarchy for the class being crerated
//      and returns the list in the arg pppszNameArr. There are
//      *plnNumElements in this array. This can be used later while
//      creating the object so that all the extensions will be available.
//
//  Arguments:
//      Parent      - The ADsPath of the parent,
//      CommonName  - RDN of the object being created,
//      pszClassName- Class of the object being created,
//      Credentials - Credentials blob,
//      pppszNameArr- Return value - array of names of parent classes.
//      plnNumItems - Return value - number of elements in above array.
//
//-------------------------------------------------------------------------
HRESULT
TraceTreeForClass(
    BSTR Parent,
    BSTR CommonName,
    LPWSTR pszClassName,
    CCredentials& Credentials,
    PWCHAR **pppszNameArr,
    PLONG plnNumElements
    )
{
    HRESULT hr = S_OK;
    IADsClass *pIADsClass = NULL;
    IUnknown *pUnk = NULL;

    PWCHAR *pszRetVal = NULL;
    WCHAR* pszSchemaPathBase = NULL;    
    WCHAR* pszSchemaPath = NULL;
    LPWSTR pszServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    LPWSTR pszCurVal = NULL;
    DWORD dwPort = 0;
    VARIANT vBstrVal;
    CCredentials Creds = Credentials;
    long lnNumItems = 1;
    BOOL fDone = FALSE;

    PClassesHierarchyList pClassListHead = NULL;
    PClassesHierarchyList pClassListNode = NULL;

    //
    // We need to make sure that the ADS_AUTH_RESERVED flag is not set
    // in the credentials because that will result in us not getting the
    // IADsClass interface ptr we want.
    //
    Creds.SetAuthFlags(Creds.GetAuthFlags() & ~ADS_AUTH_RESERVED);


    VariantInit(&vBstrVal);

    //
    // Build The schema name
    //
    hr = BuildLDAPPathFromADsPath2(
             Parent,
             &pszServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    if (pszServer) {

        pszSchemaPathBase = new WCHAR[wcslen(L"LDAP://") + wcslen(pszServer) + 1];
        if(!pszSchemaPathBase)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);            
        }

        wsprintf(pszSchemaPathBase, L"LDAP://%s", pszServer);

    } else {
        pszSchemaPathBase = new WCHAR[wcslen(L"LDAP:/") + 1];
        if(!pszSchemaPathBase)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);            
        }

        wsprintf(pszSchemaPathBase, L"LDAP:/");
    }

    pszCurVal = AllocADsStr(pszClassName);

    if (!pszCurVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    while (!fDone && _wcsicmp(L"Top", pszCurVal)) {

        lnNumItems++;
        //
        // Add a new node to the list
        //
        pClassListNode = (PClassesHierarchyList)
                            AllocADsMem(sizeof(ClassesHierarchyList));
        if (!pClassListNode) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassListNode->pszClassName = AllocADsStr(pszCurVal);
        if (!pClassListNode->pszClassName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassListNode->pNext = pClassListHead;
        pClassListHead = pClassListNode;

        //
        // Check for the next class on the list
        //

        if(pszSchemaPath)
        {
            delete [] pszSchemaPath;
        }
        
        pszSchemaPath = new WCHAR[wcslen(pszSchemaPathBase) + wcslen(L"/Schema/") + wcslen(pszCurVal) + 1];
        if(!pszSchemaPath)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        wcscpy(pszSchemaPath, pszSchemaPathBase);

        wcscat(pszSchemaPath, L"/Schema/");
        wcscat(pszSchemaPath, pszCurVal);

        FreeADsStr(pszCurVal);
        pszCurVal = NULL;

        hr = GetObject(
                 pszSchemaPath,
                 Credentials,
                 (LPVOID *) &pUnk
                 );

        BAIL_ON_FAILURE(hr);

        hr = pUnk->QueryInterface(
                  IID_IADsClass,
                  (void **) &pIADsClass
                  );
        BAIL_ON_FAILURE(hr);

        //
        // Release the ref on the pUnk
        //
        pUnk->Release();
        pUnk = NULL;

        hr = pIADsClass->get_DerivedFrom(&vBstrVal);

        BAIL_ON_FAILURE(hr);

        //
        // Release the ptr as we no longer need it.
        //
        pIADsClass->Release();
        pIADsClass = NULL;


        if (vBstrVal.vt == (VT_VARIANT | VT_ARRAY)) {
            //
            // Server has complete list of classes in schema
            //
            hr = AddToClassesList(
                     vBstrVal,
                     &pszCurVal,
                     &pClassListHead,
                     &lnNumItems
                     );
            BAIL_ON_FAILURE(hr);

            //
            // add one to the count for the value passed in
            //
            lnNumItems++;
            fDone = TRUE;
        }
        else if (vBstrVal.vt == VT_BSTR) {

            pszCurVal = AllocADsStr(vBstrVal.bstrVal);
            VariantClear(&vBstrVal);
            if (!pszCurVal) {
                hr = E_OUTOFMEMORY;
            }
        }
        else {
            hr = E_FAIL;
        }

        BAIL_ON_FAILURE(hr);

    }

    //
    // We now have the list as well as the number of items
    //
    pszRetVal = (PWCHAR *) AllocADsMem(sizeof(PWCHAR) * (lnNumItems + 1));

    if (!pszRetVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Do not move as we may call -- below
    //
    *plnNumElements = lnNumItems;

    pszRetVal[lnNumItems] = NULL;

    if (!fDone) {
        //
        // Add top to the list and set last to NULL
        // only if we did not hit addclasses fn.
        //
        pszRetVal[lnNumItems - 1] = AllocADsStr(L"Top");
        if (!pszRetVal[lnNumItems - 1]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        lnNumItems--;
    }

    while (pClassListHead && (lnNumItems > -1)) {

        pszRetVal[--lnNumItems] =
                AllocADsStr(pClassListHead->pszClassName);

        if (!pszRetVal[lnNumItems]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        //
        // Free the entry and advance list
        //
        FreeADsStr(pClassListHead->pszClassName);
        pClassListNode = pClassListHead;
        pClassListHead = pClassListHead->pNext;
        FreeADsMem(pClassListNode);
        pClassListNode = NULL;
    }

    //
    // Put appropriate value in return arg.
    //
    *pppszNameArr = pszRetVal;

error:

    if (pszServer) {
        FreeADsStr(pszServer);
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    if (pszCurVal) {
        FreeADsStr(pszCurVal);
    }

    if (pUnk) {
        pUnk->Release();
    }

    if (pIADsClass) {
        pIADsClass->Release();
    }

    if(pszSchemaPathBase)
    {
        delete [] pszSchemaPathBase;
        pszSchemaPathBase = NULL;
    }

    if(pszSchemaPath)
    {
        delete [] pszSchemaPath;
        pszSchemaPath = NULL;
    }

    //
    // Walk through and free the list if necessary
    //
    while (pClassListHead) {

        pClassListNode = pClassListHead;

        if (pClassListHead->pszClassName) {
            FreeADsStr(pClassListHead->pszClassName);
        }

        pClassListHead = pClassListHead->pNext;
        FreeADsMem(pClassListNode);
    }


    RRETURN(hr);
}

//
// Helper to get the values from the Variant and add to list
//
HRESULT
AddToClassesList(
    VARIANT vProps,
    LPWSTR *ppszCurClass,
    PClassesHierarchyList *ppClassListHead,
    PLONG  plnNumItems
    )
{
    HRESULT hr = S_OK;
    PClassesHierarchyList pClassNode = NULL;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    DWORD dwNumValues = 0, i = 0;

    pvProp = &vProps;

    hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
    BAIL_ON_FAILURE(hr);

    //
    // Go through the array adding nodes.
    //
    for (i = 0; i < dwNumValues; i++) {

        pvProp = pVarArray + i;
        if (pvProp->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        //
        // Alloc node to add
        //
        pClassNode = (PClassesHierarchyList)
                            AllocADsMem(sizeof(ClassesHierarchyList));

        if (!pClassNode) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassNode->pszClassName = AllocADsStr(pvProp->bstrVal);
        if (!pClassNode->pszClassName) {
            //
            // Free pClassNode as we will let caller free the list
            // if we run out of memory.
            //
            FreeADsMem(pClassNode);
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassNode->pNext = *ppClassListHead;
        *ppClassListHead  = pClassNode;
    } // end for

    *plnNumItems = dwNumValues;
error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}


//
// Helper routine that handles setting the sticky server private
// option when the input is an array.
//
HRESULT
SetStickyServerWithDomain(
    PVARIANT pvProp
    )
{
    HRESULT hr = S_OK;
    VARIANT *pvVarArray = NULL;
    DWORD dwNumVariants = 0;
    DWORD dwCtr = 0;
    LPWSTR *ppszStringArray = NULL;

    hr = ConvertSafeArrayToVariantArray(
             *pvProp,
             &pvVarArray,
             &dwNumVariants
             );

    // returns E_FAIL if vProperties is invalid
    if (hr == E_FAIL)
        hr = E_ADS_BAD_PARAMETER;
    BAIL_ON_FAILURE(hr);

    //
    // There have to be precisely 2 entries, one for domain
    // and the second for the serverName.
    //
    if (dwNumVariants != 2) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    hr = ConvertVariantArrayToLDAPStringArray(
             pvVarArray,
             &ppszStringArray,
             dwNumVariants
             );
    BAIL_ON_FAILURE(hr);

    if (!ppszStringArray
        || !ppszStringArray[0]
        || !*(ppszStringArray[0])
        || !ppszStringArray[1]
        || !*(ppszStringArray[1])
        ) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    if (gpszStickyServerName) {
        FreeADsStr(gpszStickyServerName);
        gpszStickyServerName = NULL;
    }

    if (gpszStickyDomainName) {
        FreeADsStr(gpszStickyDomainName);
        gpszStickyDomainName = NULL;
    }

    gpszStickyServerName = AllocADsStr(ppszStringArray[1]);
    if (!gpszStickyServerName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    gpszStickyDomainName = AllocADsStr(ppszStringArray[0]);
    if (!gpszStickyDomainName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = LdapcSetStickyServer(
             gpszStickyDomainName,
             gpszStickyServerName
             );

    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr)) {
        //
        // Clear the global strings on failure.
        //
        if (gpszStickyServerName) {
            FreeADsStr(gpszStickyServerName);
            gpszStickyServerName = NULL;
        }

        if (gpszStickyDomainName) {
            FreeADsStr(gpszStickyDomainName);
            gpszStickyDomainName = NULL;
        }
    }

    //
    // Cleanup variant array and string array.
    //
    if (pvVarArray) {
        for (dwCtr = 0; dwCtr < dwNumVariants; dwCtr++) {
            VariantClear(pvVarArray + dwCtr);
        }
        FreeADsMem(pvVarArray);
    }

    if (ppszStringArray) {
        for (dwCtr = 0; dwCtr < dwNumVariants; dwCtr++) {
            if (ppszStringArray[dwCtr])
                FreeADsStr(ppszStringArray[dwCtr]);
        }
        FreeADsMem(ppszStringArray);
    }

    
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cmacro.h ===
#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}




#define DEFINE_CONTAINED_IADsPutGet_Implementation(cls, ClassPropMapping)    \
STDMETHODIMP                                                                 \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Get( pszPropName, pvProp));                               \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                                 \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Put( pszPropName, vProp));                                \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                         \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->GetEx( pszPropName, pvProp));                             \
}                                                                            \
STDMETHODIMP                                                                 \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->PutEx( lnControlCode, pszPropName, vProp));               \
}



#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectoryObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_INFO *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_INFO pAttributeEntries,                                 \
    DWORD dwNumAttributes,                                            \
    IDispatch * FAR* ppObject                                         \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        ppObject                                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectorySearch_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetSearchPreference(                                             \
    PADS_SEARCHPREF_INFO pSearchPrefs,                                \
    DWORD   dwNumPrefs                                                \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->SetSearchPreference(                             \
                         pSearchPrefs,                                \
                         dwNumPrefs                                   \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ExecuteSearch(                                                   \
    LPWSTR pszSearchFilter,                                           \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_SEARCH_HANDLE phSearchResult                                 \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->ExecuteSearch(                                   \
                         pszSearchFilter,                             \
                         pAttributeNames,                             \
                         dwNumberAttributes,                          \
                         phSearchResult                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::AbandonSearch(                                                   \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->AbandonSearch(                                   \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetFirstRow(                                                     \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetFirstRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextRow(                                                      \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPreviousRow(                                                  \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetPreviousRow(                                  \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextColumnName(                                               \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR * ppszColumnName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextColumnName(                               \
                         hSearchResult,                               \
                         ppszColumnName                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetColumn(                                                       \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR szColumnName,                                              \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetColumn(                                       \
                         hSearchResult,                               \
                         szColumnName,                                \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::FreeColumn(                                                      \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->FreeColumn(                                      \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CloseSearchHandle(                                               \
    ADS_SEARCH_HANDLE hSearchResult                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->CloseSearchHandle(                               \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(cls)     \
STDMETHODIMP                                                          \
cls::EnumAttributes(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumAttributes,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumAttributes                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->EnumAttributes(                                \
              ppszAttrNames,                                          \
              dwNumAttributes,                                        \
              ppAttrDefinition,                                       \
              pdwNumAttributes                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateAttributeDefinition(                                       \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF pAttributeDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->CreateAttributeDefinition(                     \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteAttributeDefinition(                                        \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF  pAttributeDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->WriteAttributeDefinition(                      \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteAttributeDefinition(                                       \
    LPWSTR pszAttributeName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->DeleteAttributeDefinition(                      \
              pszAttributeName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                   \
STDMETHODIMP                                                      \
cls::EnumClasses(                                                     \
    LPWSTR * ppszClassNames,                                           \
    DWORD dwNumClasses,                                               \
    PADS_CLASS_DEF * ppClassDefinition,                                 \
    DWORD * pdwNumClasses                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->EnumClasses(                                    \
              ppszClassNames,                                          \
              dwNumClasses,                                           \
              ppClassDefinition,                                       \
              pdwNumClasses                                           \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateClassDefinition(                                           \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF pClassDefinition                                    \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->CreateClassDefinition(                          \
              pszClassName,                                           \
              pClassDefinition                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteClassDefinition(                                            \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF  pClassDefinition                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->WriteClassDefinition(                           \
              pszClassName,                                           \
              pClassDefinition                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteClassDefinition(                                           \
    LPWSTR pszClassName                                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->DeleteClassDefinition(                          \
              pszClassName                                            \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IADsObjectOptions_Implementation(cls)        \
STDMETHODIMP                                                          \
cls::GetOption(                                                       \
     THIS_ DWORD dwOption,                                            \
     void *pValue )                                                   \
{                                                                     \
    RRETURN(_pADsObjectOptions->GetOption(dwOption, pValue));         \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetOption(                                                       \
     THIS_ DWORD dwOption,                                            \
     void *pValue )                                                   \
{                                                                     \
    RRETURN(_pADsObjectOptions->SetOption(dwOption, pValue));          \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Namespace Object Class Factory Code
//
//             CLDAPNamespaceCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CLDAPNamespace::CreateNamespace(
                TEXT("ADs:"),
               TEXT("LDAP:"),
                Credentials,
                ADS_OBJECT_BOUND,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumvar.cxx
//
//  Contents:  LDAP Enumerator Code
//
//             CLDAPEnumVariant::Create
//             CLDAPEnumVariant::CLDAPEnumVariant
//             CLDAPEnumVariant::~CLDAPEnumVariant
//             CLDAPEnumVariant::QueryInterface
//             CLDAPEnumVariant::AddRef
//             CLDAPEnumVariant::Release
//             CLDAPEnumVariant::Next
//             CLDAPEnumVariant::Skip
//             CLDAPEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::CLDAPEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPEnumVariant::CLDAPEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::~CLDAPEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPEnumVariant::~CLDAPEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLDAPEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLDAPEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamesp.cxx
//
//  Contents:  LDAP Namespace Object
//
//
//  History:   06-15-96     yihsins     Created.
//
//----------------------------------------------------------------------------
#include "LDAP.hxx"
#pragma hdrstop
#include <ntdsapi.h>

DEFINE_IDispatch_Implementation(CLDAPNamespace)
DEFINE_IADs_Implementation(CLDAPNamespace)
DEFINE_IADsPutGet_UnImplementation(CLDAPNamespace)

//  Class CLDAPNamespace

CLDAPNamespace::CLDAPNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CLDAPNamespace);

    _pObjectInfo = NULL;
}

HRESULT
CLDAPNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(
                Credentials,
                &pNamespace
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                NAMESPACE_CLASS_NAME,
                CLSID_LDAPNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // Umi Object is going to be the owner, so we need to
        // initilaize the umi object and return.
        //
        hr = ((CCoreADsObject*)pNamespace)->InitUmiObject(
                   IntfPropsSchema,
                   NULL,
                   (IADs *) pNamespace,
                   (IADs *) pNamespace,
                   riid,
                   ppvObj,
                   &(pNamespace->_Credentials)
                   );

        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);

    }
    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:
    *ppvObj = NULL;
    delete pNamespace;
    RRETURN_EXP_IF_ERR(hr);
}


CLDAPNamespace::~CLDAPNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CLDAPNamespace::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider)) 
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPNamespace::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsOpenDSObject)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
STDMETHODIMP
CLDAPNamespace::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CLDAPNamespace::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    DWORD dwBufferSize = 0;
    TCHAR *pszBuffer = NULL;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    dwBufferSize = ( _tcslen(_ADsPath) + _tcslen(RelativeName)
                     + 3  ) * sizeof(TCHAR);   // includes "//"

    pszBuffer = (LPTSTR) AllocADsMem( dwBufferSize );

    if ( pszBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _tcscpy(pszBuffer, _ADsPath);
    _tcscat(pszBuffer, TEXT("//"));
    _tcscat(pszBuffer, RelativeName);

    hr = ::GetObject(
               pszBuffer,
               _Credentials,
               (LPVOID *)ppObject
               );
    BAIL_ON_FAILURE(hr);

error:

    if ( pszBuffer )
        FreeADsStr( pszBuffer );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CLDAPNamespaceEnum::Create(
                (CLDAPNamespaceEnum **)&penum,
                 _vFilter,
                 _Credentials,
                 _ADsPath
                 );
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPNamespace::MoveHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CLDAPNamespace::AllocateNamespaceObject(
    CCredentials& Credentials,
    CLDAPNamespace ** ppNamespace
    )
{
    CLDAPNamespace FAR * pNamespace = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CLDAPNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsOpenDSObject,
                           (IADsOpenDSObject *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespace,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;
    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:

    delete pNamespace;
    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CLDAPNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch FAR * * ppADsObj
    )
{
    HRESULT hr = S_OK;
    IUnknown * pObject = NULL;

    // we need to block the invoke on UMI code
    lnReserved &= (~ADS_AUTH_RESERVED);
    
    CCredentials Credentials(lpszUserName, lpszPassword, lnReserved);

    hr = ::GetObject(
                lpszDNName,
                Credentials,
                (LPVOID *)&pObject
                );
    BAIL_ON_FAILURE(hr);



    hr = pObject->QueryInterface(
                        IID_IDispatch,
                        (void **)ppADsObj
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pObject) {
        pObject->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPNamespace::ParsePath(
    BSTR bstrADsPath, 
    DWORD dwType, 
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - The place where the parsed object is stored.
                  It assumes that this structure is valid and empty, and will
                  overwrite anything that is in there already.
    
Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    LPWSTR szPath = NULL;
    
    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            hr = ADsObject(bstrADsPath, pObjInfo);
            BAIL_ON_FAILURE(hr);

            
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            hr = GetDisplayName(bstrADsPath, &szPath);
            BAIL_ON_FAILURE(hr);

            hr = InitObjectInfo(szPath,
                                pObjInfo);
            BAIL_ON_FAILURE(hr);

            CLexer Lexer;
            hr = Lexer.InitializePath(szPath);
            BAIL_ON_FAILURE(hr);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
                goto error;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            hr = GetDisplayName(bstrADsPath, &szPath);
            BAIL_ON_FAILURE(hr);

            CLexer Lexer;
            hr = Lexer.InitializePath(szPath);
            BAIL_ON_FAILURE(hr);
        
            hr = InitObjectInfo(szPath, pObjInfo);
            BAIL_ON_FAILURE(hr);

            Lexer.SetAtDisabler(TRUE);
        
            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->NamespaceName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->TreeName) {
        pObjectInfo->ServerName = AllocADsStr(pObjInfo->TreeName);
        if (!pObjectInfo->ServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->DisplayTreeName) {
        pObjectInfo->DisplayServerName = AllocADsStr(pObjInfo->DisplayTreeName);
        if (!pObjectInfo->DisplayServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = (pObjInfo->dwPathType == PATHTYPE_X500) ? 
                                ADS_PATHTYPE_LEAFFIRST : ADS_PATHTYPE_ROOTFIRST;

error:
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    FreeObjectInfo(pObjInfo);
    return (hr);
}

HRESULT
CLDAPNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the 
    components in the target objinfo is empty. Users of this function can call 
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;
    PWSTR pszPath = NULL;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pObjectInfoTarget->ProvSpecComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->ProvSpecComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            DWORD dwResult;
            DWORD dwSize = 0;

            pObjectInfoTarget->ComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        
            dwSize = wcslen(pObjectInfo->ComponentArray[NumComponents].szValue) + 1;
            pszPath = (PWSTR)AllocADsMem(dwSize * sizeof(WCHAR));
            if (pszPath == NULL) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            dwResult = DsUnquoteRdnValueWrapper(
                                wcslen(pObjectInfo->ComponentArray[NumComponents].szValue),
                                pObjectInfo->ComponentArray[NumComponents].szValue,
                                &dwSize,
                                pszPath);

            if (dwResult == NO_ERROR) {
                pszPath[dwSize] = NULL;
                pObjectInfoTarget->ProvSpecComponentArray[NumComponents].szValue =
                    AllocADsStr(pszPath);
                if (pObjectInfoTarget->ProvSpecComponentArray[NumComponents].szValue == NULL) {
                    pObjectInfoTarget->NumComponents = NumComponents;
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
            }
            if (pszPath) {
                FreeADsMem(pszPath);
                pszPath = NULL;
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);
    if (pszPath) {
        FreeADsMem(pszPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}

void
CLDAPNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent);
            pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ProvSpecComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ProvSpecComponentArray[NumComponents].szValue);
            pObjectInfo->ProvSpecComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void 
CLDAPNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    DWORD dwEscapedMode
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    ASSERT(dwEscapedMode != ADS_ESCAPEDMODE_DEFAULT);
    if (dwEscapedMode == ADS_ESCAPEDMODE_OFF){
        pComponent = _pObjectInfo->ComponentArray;
    }
    else if (dwEscapedMode == ADS_ESCAPEDMODE_OFF_EX){
        pComponent = _pObjectInfo->ProvSpecComponentArray;
    }
    else if (dwEscapedMode == ADS_ESCAPEDMODE_ON) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }

    if (_fNamingAttribute) {
        wcscat(szReturn, pComponent[cComponents].szComponent);
        if (pComponent[cComponents].szValue) {
            wcscat(szReturn,
                   TEXT("="));
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
    }
    else {
        if (pComponent[cComponents].szValue) {
            //
            // If value exist, only show display value
            //
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
        else {
            //
            // else value is only stored in Component
            //
            wcscat(szReturn,
                   pComponent[cComponents].szComponent);
        }
    }
}


HRESULT 
CLDAPNamespace::SetComponents(
                            LPWSTR szReturn,
                            BOOLEAN bIsWindowsPath,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            DWORD dwEscapedMode
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    bIsWindowsPath - whether a windows path is to be returned
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    BOOL bReverse;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             dwEscapedMode);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             dwEscapedMode);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
        bReverse = !bIsWindowsPath;
    }
    else {
        bReverse = bIsWindowsPath;
    }


    if (!bReverse) {
        dwLimit = _pObjectInfo->NumComponents;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwOtherLimit >= dwLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
            SetComponent(szReturn,
                         cComponents,
                         dwEscapedMode);
            if (cComponents != dwLimit - 1) {
                wcscat(szReturn,
                       chSeparator);
            }
        }
    }
    else {
        dwLimit = _pObjectInfo->NumComponents-1;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwLimit < dwOtherLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwLimit ; (long)cComponents >= dwOtherLimit; cComponents--) {
            SetComponent(szReturn,
                         cComponents,
                         dwEscapedMode);
            if (cComponents != dwOtherLimit) {
                wcscat(szReturn, chSeparator);
            }
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2; 
    }
    return dwPath;
}


STDMETHODIMP
CLDAPNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
/*++

Routine Description:

    Given an objectinfo structure, and the settings required, this function
    assembles the path and returns it in pbstrADsPath

Arguments:

    pObjectInfo - the input object info structure
    dwFormatType- The format type passed in from Retrieve.
    dwFlag - the flag to be set
        ADS_CONSTRUCT_ESCAPED
        ADS_CONSTRUCT_NAMINGATTRIBUTE
    pbstrADsPath - the returned path


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    DWORD dwEscapedInternal;

    dwEscapedInternal = dwEscapedMode;
    if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
        dwEscapedInternal = ADS_ESCAPEDMODE_OFF;
    }


    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _fNamingAttribute = (BOOLEAN)(dwFlag & ADS_CONSTRUCT_NAMINGATTRIBUTE);
    _pObjectInfo = pObjectInfo; // useful in SetComponet() and SetComponents()

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                dwEscapedInternal = ADS_ESCAPEDMODE_ON;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (dwEscapedInternal == ADS_ESCAPEDMODE_ON) {
                    if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                        wcscat(szReturn,pObjectInfo->DisplayServerName);
                        if (pObjectInfo->NumComponents>0) {
                            wcscat(szReturn,TEXT("/"));
                        }
                    }
                }
                else {
                    if (pObjectInfo->ServerName && (*(pObjectInfo->ServerName))) {
                        wcscat(szReturn,pObjectInfo->ServerName);
                        if (pObjectInfo->NumComponents>0) {
                            wcscat(szReturn,TEXT("/"));
                        }
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                dwEscapedInternal = ADS_ESCAPEDMODE_ON;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;    // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_X500) {
                if (dwEscapedInternal == ADS_ESCAPEDMODE_ON) {
                    if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                        wcscat(szReturn,pObjectInfo->DisplayServerName);
                        if (pObjectInfo->NumComponents>0) {
                            wcscat(szReturn,TEXT("/"));
                        }
                    }
                }
                else {
                    if (pObjectInfo->ServerName && (*(pObjectInfo->ServerName))) {
                        wcscat(szReturn,pObjectInfo->ServerName);
                        if (pObjectInfo->NumComponents>0) {
                            wcscat(szReturn,TEXT("/"));
                        }
                    }
                }
            }
            hr = SetComponents(szReturn,
                               FALSE,
                               TEXT(","),
                               ADS_COMPONENT_DN,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500_DN:
            hr = SetComponents(szReturn,
                               FALSE,
                               TEXT(","),
                               ADS_COMPONENT_DN,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500_PARENT:
            hr = SetComponents(szReturn,
                               FALSE,
                               TEXT(","),
                               ADS_COMPONENT_PARENT,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
        break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               dwEscapedInternal);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    HRESULT hr = S_OK;

    if (FAILED(hr = ValidateOutParameter(pbstrOutStr))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if (!bstrInStr) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = HelperEscapeRDN(bstrInStr, pbstrOutStr);

    RRETURN(hr);
}


/////////////////////////////////////////////////////////////////////
//      escape.cpp
//
//      routine to escape special characters in an RDN
//      
//      ASSUMPTIONS/RESTRICTIONS:
//      - we assume that the input string is un-escaped in any way
//      - we assume that the input string is a correctly attributed
//        RDN, and we directly copy everything up to and including
//        the first '='
//
//      HISTORY
//      3-dec-98                jimharr         Creation.
/////////////////////////////////////////////////////////////////////


static WCHAR specialChars[] =  L",=\r\n+<>#;\"\\/";

HRESULT
HelperEscapeRDN (
    IN BSTR bstrIn,
    OUT BSTR * pbstrOut
    )
{

  //
  // algorithm:
  //     create temporary buffer to hold escaped RDN
  //     skip up to first '=', to skip attributeType
  //     examine each character, if it needs escaping
  //        put a '\' in the dest.
  //     copy the character
  //     continue until done
  //
  //     alloc BSTR of correct size to return
  //     copy string, delete temp buffer
  //
  HRESULT hr = S_OK;
  WCHAR *pchSource = NULL;
  WCHAR *pchDest = NULL;
  WCHAR *pBuffer = NULL;
  WCHAR *pTmp;

  pBuffer = (WCHAR* ) AllocADsMem((wcslen(bstrIn) * 3 + 1) * sizeof(WCHAR));
  if (pBuffer == NULL)
    BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

  pchDest = pBuffer;
  pchSource = (WCHAR *)bstrIn;

  // copy up to the equals sign
  do {
    *pchDest = *pchSource;
    pchSource++;
    pchDest++;
  } while ((*pchSource != L'=') && (*pchSource != L'\0'));

  // if we didn't find an '=', bail
  if (*pchSource == L'\0') {
    BAIL_ON_FAILURE(hr=E_INVALIDARG);
  }

  // copy the '='
  *pchDest = *pchSource;
  pchSource++;
  pchDest++;

  //
  // If the first character after the '=' is a space, we'll escape it. 
  // According to LDAP, if the value starts with a space, it has to be escaped
  // or else it will be trimmed.
  //
  if (*pchSource == L' ') {
    *pchDest = L'\\';
    pchDest++;
    *pchDest = *pchSource;
    pchDest++;
    pchSource++;
  }

  while (*pchSource != L'\0') {

    //
    // If we have reached the last character and it is a space, we'll escape
    // it
    //
    if ( (*(pchSource+1) == L'\0') && 
         ((*pchSource) == L' ') ) {
        *pchDest = L'\\';
        pchDest++;
        *pchDest = *pchSource;
        pchDest++;
        break;
    }

    if (NeedsEscaping(*pchSource)) {
      *pchDest = L'\\';
      pchDest++;
    }
    pTmp = EscapedVersion(*pchSource);
    if (pTmp != NULL) {
      wcscpy (pchDest, pTmp);
      pchDest += wcslen(pTmp);
    } else {
      *pchDest = *pchSource;
      pchDest++;
    }
    pchSource++;
  }
  *pchDest = L'\0';

  *pbstrOut = SysAllocString (pBuffer);

error:

  if (pBuffer) {
      FreeADsMem(pBuffer);
  }
  return (hr);
}


BOOL
NeedsEscaping (WCHAR c)
{
  WCHAR * pSpecial = specialChars;

  while (*pSpecial != L'\0'){
    if (*pSpecial == c) return TRUE;
    pSpecial++;
  }
  return FALSE;
}

WCHAR *
EscapedVersion (WCHAR c)
{
  if (c == L'\r')
    return L"0D";
  if (c == L'\n')
    return L"0A";

  return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cextmgr.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cextmgr.cxx
//
//  Contents:  LDAP ExtMgr Object
//
//
//  History:   06-15-96     yihsins     Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


//  Class CADsExtMgr

CADsExtMgr::CADsExtMgr(
    IUnknown FAR * pUnkOuter
    ):
    _pUnkOuter(pUnkOuter),
    _pClassEntry(NULL),
    _pDispMgr(NULL),
    _pCreds(NULL),
    _fExtensionsLoaded(FALSE)
{
}


//
// Static create to handle multiple classes
//
HRESULT
CADsExtMgr::CreateExtMgr(
    IUnknown FAR * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    LPWSTR pszClassNames[],
    long lnNumClasses,
    CCredentials *pCreds,
    CADsExtMgr ** ppExtMgr
    )
{
    long lnCtr = 0;
    long lnInc = 1;

    PCLASS_ENTRY pClassEntry =  NULL;
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    pExtMgr = new CADsExtMgr(pUnkOuter);
    if (!pExtMgr)
        RRETURN(E_OUTOFMEMORY);

    //
    // Now store the DispatchMgr of the Aggregator
    //

    pExtMgr->_pDispMgr = pDispMgr;
    pExtMgr->_pCreds = pCreds;

    if (_tcsicmp(pszClassNames[lnNumClasses-1], TEXT("Top")) == 0)
         lnCtr = 0;
    else
         lnCtr = lnNumClasses - 1;

    lnInc = lnCtr ? -1 : 1;

    //
    // Read the list of extension object of the same class from registry
    //

    hr = ADSIGetExtensionList(
            pszClassNames[lnCtr],
            &(pExtMgr->_pClassEntry)
            );
    BAIL_ON_FAILURE(hr);

    lnCtr += lnInc;

    for (;
        (lnInc == -1) ? (lnCtr > -1) : (lnCtr < lnNumClasses);
        lnCtr += lnInc) {

        hr = ADSIAppendToExtensionList(
                 pszClassNames[lnCtr],
                 &(pExtMgr->_pClassEntry)
                 );

        BAIL_ON_FAILURE(hr);
    }

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:

    *ppExtMgr = NULL;
    delete pExtMgr;
    RRETURN(hr);
}


CADsExtMgr::~CADsExtMgr( )
{
    //
    // Free the ClassEntry
    //

    if (_pClassEntry) {

        FreeClassEntry(_pClassEntry);
    }

    //
    // And do nothing with the DispMgr, pCreds - we just keep pointers
    //

}

//
// Instantiate extension objects listed in _pClassEntry as aggregates of
// aggregator _pUnkOuter. Initialize extensions with <Credentials>.
//
// Max Load 127 extensions. Extensions > 127 are silently ignored.
//

HRESULT
CADsExtMgr::LoadExtensions(
    CCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    DWORD dwExtensionID = MIN_EXTENSION_ID;
    IPrivateDispatch * pPrivDisp = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;
    VARIANT varUserName;
    VARIANT varPassword;
    VARIANT varAuthFlags;
    PVARIANT pvarUserName = &varUserName;
    PVARIANT pvarPassword = &varPassword;
    PVARIANT pvarAuthFlags = &varAuthFlags;
    BOOL    fReturnError = FALSE;    


    //
    // Extensions (ext mgr) do(es) not exist on its own without an aggregator
    //

    ADsAssert(_pUnkOuter);


    //
    // If _pClassEntry!=NULL, pClassEntry->pExtensionHead should not
    // be NULL either. But just in case a user removes all extension entries
    // under a class key without removing the class key itself in the registry,
    //  we will let it pass and just return S_OK here.
    //

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    VariantInit(pvarUserName);
    VariantInit(pvarPassword);
    VariantInit(pvarAuthFlags);


    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr)) {
        if (pszUserName) {
            FreeADsStr(pszUserName);
        }
        
        RRETURN(S_OK);
    }

    dwAuthFlags = Credentials.GetAuthFlags();


    while (pExtEntry) {

        //
        // Max # of extension have been loaded, cannot load more
        //

        if (dwExtensionID>MAX_EXTENSION_ID) {

            //
            // Terminate loading extensions.
            //
            break;
        }

        //
        // create extension object (aggregatee) and ask for Non-delegating
        // IUnknown. Ref count on extension object = 1.
        //

        hr = CoCreateInstance(
                    pExtEntry->ExtCLSID,
                    _pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IUnknown,
                    (void **)&(pExtEntry->pUnknown)
                    );


        //
        // if fail, go to next extesion entry s.t. bad individual extension
        // cannot block other extensions from loading (no clean up needed)
        //

        if (SUCCEEDED(hr)) {

            pExtEntry->dwExtensionID = dwExtensionID;


            hr = (pExtEntry->pUnknown)->QueryInterface(
                        IID_IADsExtension,
                        (void **) &(pExtEntry->pADsExt)
                        );

            if  (FAILED(hr)) {

                //
                // extension does not support the optioanl IADsExtension -> OK.
                // (no clean up needed)
                //

                pExtEntry->pADsExt=NULL;

                pExtEntry->fDisp = FALSE;

            } else {

                //
                // Cache the interface ptr but call Release() immediately to
                // avoid aggregator having a ref count on itself
                // since IADsExtension inherits from delegating IUnknown.
                //
                // Note: codes still works if inherit from NonDelegatingIUknown
                //

                (pExtEntry->pADsExt)->Release() ;

                //
                // For efficiency, set this flag to FALSE on FIRST encounter of
                // pADsExt->PrivateGetIDsOfNames()/Invoke() returning E_NOTIMPL.
                // Set as TRUE now s.t. at least first encounter will happen.
                //

                pExtEntry->fDisp = TRUE;


                //
                // Pass its own credentials to extension. Ignore error if any.
                //

                hr = ADsAllocString(
                        pszUserName,
                        &(pvarUserName->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);
                }
                V_VT(pvarUserName) = VT_BSTR;

                hr = ADsAllocString(
                        pszPassword,
                        &(pvarPassword->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);
                }
                V_VT(pvarPassword) = VT_BSTR;

                V_I4(pvarAuthFlags) = dwAuthFlags;
                V_VT(pvarAuthFlags) = VT_I4;

                hr = (pExtEntry->pADsExt)->Operate(
                        ADS_EXT_INITCREDENTIALS,
                        varUserName,
                        varPassword,
                        varAuthFlags
                        );

                //
                // Free them as they are reused
                //
                VariantClear(pvarUserName);
                if(pvarPassword->bstrVal)
                {
                    SecureZeroMemory(pvarPassword->bstrVal, wcslen(pvarPassword->bstrVal)*sizeof(WCHAR));
                }
                VariantClear(pvarPassword);                

            }

        } // end if CoCreateInstance() succeeded


        pExtEntry = pExtEntry->pNext;


        //
        // ++ extension ID even if creat'n of extension fails just to be safe
        // - chuck's stuff :)
        //

        dwExtensionID++;

    }   // end while



error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        SecureZeroMemory(pszPassword, wcslen(pszPassword)*sizeof(WCHAR));
        FreeADsStr(pszPassword);        
    }

    VariantClear(pvarUserName);

    if(V_VT(pvarPassword) != VT_EMPTY && pvarPassword->bstrVal)
    {
        SecureZeroMemory(pvarPassword->bstrVal, wcslen(pvarPassword->bstrVal)*sizeof(WCHAR));
        VariantClear(pvarPassword);
    }
    VariantClear(pvarAuthFlags);

    if (fReturnError) {
        RRETURN(hr);        // fatal error,
    }
    else {
        RRETURN(S_OK);      // "okay" error if any, optional support
    }

}


HRESULT 
CADsExtMgr::LoadExtensionsIfReqd()
{
    HRESULT hr = S_OK;

    if(!_fExtensionsLoaded) {
        hr = LoadExtensions(*_pCreds);
        BAIL_ON_FAILURE(hr);
 
        hr = FinalInitializeExtensions(); // this call never fails
        BAIL_ON_FAILURE(hr);

        _fExtensionsLoaded = TRUE;
    }

    RRETURN(S_OK);

error:

    RRETURN(hr);
}

STDMETHODIMP
CADsExtMgr::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    IUnknown * pUnknown = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;

    if (!pClassEntry) {

        RRETURN(E_NOINTERFACE);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, iid)) {

                hr = LoadExtensionsIfReqd();
                if (FAILED(hr)) {
                    RRETURN(E_NOINTERFACE);
                }

                pUnknown = pExtensionEntry->pUnknown;


                if (!pUnknown) {

                    RRETURN(E_NOINTERFACE);
                }

                hr = pUnknown->QueryInterface(
                            iid,
                            ppv
                            );
                RRETURN(hr);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = E_NOINTERFACE);
}


STDMETHODIMP
CADsExtMgr::GetTypeInfoCount(
    unsigned int FAR* pctinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetTypeInfo(
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR FAR* rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID FAR* rgdispid
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch FAR * pPrivDisp = NULL;


    hr = _pDispMgr->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );

    if (FAILED(hr)) {

        if (!_pClassEntry) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        hr = LoadExtensionsIfReqd();
        if (FAILED(hr)) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        pExtension = _pClassEntry->pExtensionHead;

        while (pExtension) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ADsAssert(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          iid,
                          rgszNames,
                          cNames,
                          lcid,
                          rgdispid
                          );

                if (SUCCEEDED(hr)) {

                    //
                    // check & prefix extension id to dispid(s) returned
                    // by extension
                    //

                    hr = CheckAndPrefixExtIDArray(
                                pExtension->dwExtensionID,
                                cNames,
                                rgdispid
                                );

                    if (SUCCEEDED(hr) )
                    {
                        RRETURN(hr);
                    }

                    //
                    // if cannot prefix extension id because NOT ALL
                    // dispids returned by PrivateGetIDsOfNames() are
                    // valid, this extension does not support this property
                    // or method -> try next extension
                    //
                }

                else if (hr == E_NOTIMPL) {

                    //
                    // extension object does not support the optional
                    // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                    // -> remember this in cache & try next extension object
                    //

                    pExtension->fDisp = FALSE;
                }

                else {

                    //
                    // extens'n object supports PrivateGetIDsOfNames()/Invoke()
                    // but does not know about this property or method
                    // -> try next extension object
                    //
                }

            } // end "if (pExtension->pADs && pExtension->fDisp)"

            pExtension = pExtension->pNext;

        } // end while

    }


    //
    // Unify the final error code retuned to ADSI client to DISP_E_UNKNOWNNAME
    //

    if ( FAILED(hr) && hr!=E_OUTOFMEMORY) {

        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr
    )
{
    DWORD dwExtensionId = 0;
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch * pPrivDisp = NULL;
    DISPID rgExtDispid = DISPID_UNKNOWN;

    //
    // This could be a special dispatch id - pass it to
    // the aggregator
    //

    if (dispidMember <= 0) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    //
    // It is not a special dispatch id, so compute the extension
    // id and pass it to the appropriate dispatch manager
    //

    dwExtensionId = EXTRACT_EXTENSION_ID(dispidMember);

    if (!dwExtensionId) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    if (!_pClassEntry) {

        RRETURN(DISP_E_MEMBERNOTFOUND);
    }

    //
    // Not really neede but just in case.
    //
    hr = LoadExtensionsIfReqd();
    if (FAILED(hr)) {
        RRETURN(DISP_E_MEMBERNOTFOUND);
    }

    pExtension = _pClassEntry->pExtensionHead;

    rgExtDispid = REMOVE_EXTENSION_ID(dispidMember);

    while (pExtension) {

        if (dwExtensionId == pExtension->dwExtensionID) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet (client bug)
                //

                ADsAssert(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateInvoke(
                        rgExtDispid,
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr
                        );
                RRETURN(hr);

            } else {

                //
                // A dwExtensionId match indicates THIS extens'n has returned
                // a valid dispid to clients thru' pADs->PrivateGetIDsOfNames.
                // Thus, fDisp should be TURE.
                //
                // But since dispid goes thru' clients before passed back to
                // PrivateInovke(), don't ASSERT in case of clients errors.
                //

                RRETURN(DISP_E_MEMBERNOTFOUND);
            }
        }

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(DISP_E_MEMBERNOTFOUND);
}


HRESULT
CADsExtMgr::CheckAndPrefixExtIDArray(
    IN      DWORD dwExtensionID,
    IN      unsigned int cDispids,
    IN OUT  DISPID * rgDispids
    )
{

    HRESULT hrEach = S_OK;
    HRESULT hrAll = S_OK;


    ASSERT_VALID_EXTENSION_ID(dwExtensionID);


    for (unsigned int i = 0; i<cDispids; i++)
    {
        hrEach = CheckAndPrefixExtID(
                    dwExtensionID,
                    rgDispids[i],
                    rgDispids+i
                    );

        if (FAILED(hrEach))
        {
            hrAll = E_FAIL;

            //
            // The entire operation is considered as failure as a whole.
            // But continue to get other dispid s.t. debugger or user knows
            // which dispid in the array is causing problem -> DISPID_UNKOWN
            //
        }
    }

    RRETURN(hrAll);

}


HRESULT
CADsExtMgr::CheckAndPrefixExtID(
    IN      DWORD   dwExtensionID,
    IN      DISPID  dispid,
    IN OUT  DISPID  * pNewDispid
    )
{
    ADsAssert(pNewDispid);

    if  ( (dispid>= ADS_EXT_MINEXTDISPID) &&
          (dispid<= ADS_EXT_MAXEXTDISPID) )
    {
        *pNewDispid = PREFIX_EXTENSION_ID(dwExtensionID, dispid) ;

        RRETURN(S_OK);
    }
    else
    {
        *pNewDispid = DISPID_UNKNOWN;

        RRETURN(E_FAIL);
    }

}


//+------------------------------------------------------------------------
//
//  Function:   CADsExtMgr::FinalInitializeExtensions
//
//  Synopsis:   At this point we call Operate on all the extensions
//           so that they can do initialization stuff that
//
//
//
//  Arguments: None
//
//  AjayR - added on 1-27-99.
//-------------------------------------------------------------------------
HRESULT
CADsExtMgr::FinalInitializeExtensions()
{

    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    VARIANT vDummy;

    VariantInit(&vDummy);

    //
    // Extensions (ext mgr) does not exist on its own without an aggregator
    //

    ADsAssert(_pUnkOuter);

    //
    // If _pClassEntry!=NULL, pClassEntry->pExtensionHead should not
    // be NULL either. But just in case a user removes all extension entries
    // under a class key without removing the class key itself in the registry,
    //  we will let it pass and just return S_OK here.
    //

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    while (pExtEntry) {

        //
        // Call operate only if the extension supports the interface
        //
        if (pExtEntry->pADsExt) {

            hr = (pExtEntry->pADsExt)->Operate(
                      ADS_EXT_INITIALIZE_COMPLETE,
                      vDummy,
                      vDummy,
                      vDummy
                      );
        }

        //
        // we cannot really do much if there is a failure here
        //

        pExtEntry = pExtEntry->pNext;

    }   // end while


    //
    // We need to return S_OK here as otherwise just because
    // the final initialization of one extension failed - we
    // will hold up the entire lot.
    //
    RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
// Function:   GetCLSIDForIID  --- used in supporting ICustomInterfaceFactory
//
// Synopsis:   Returns the CLSID corresponding to a given interface IID. 
//             If the IID is one of the interfaces implemented by the 
//             extension manager, then the extension's CLSID is returned.
//
// Arguments:  riid      -   Interface ID for which we want to find the CLSID
//             lFlags    -   Reserved. Must be 0.
//             pCLSID    -   Returns the CLSID corresponding to the IID.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return CLSID.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsExtMgr::GetCLSIDForIID(
    REFIID riid,
    long lFlags,
    CLSID *pCLSID
    )
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    HRESULT hr = S_OK;

    ADsAssert(!lFlags && pCLSID);

    if (!pClassEntry) {

        RRETURN(UMI_E_NOT_FOUND);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {
        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, riid)) {
                *pCLSID = pExtensionEntry->ExtCLSID;
                RRETURN(S_OK);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = UMI_E_NOT_FOUND);
}

//+---------------------------------------------------------------------------
// Function:   GetObjectByCLSID --- Used for ICustomInterfaceFactory support.
//
// Synopsis:   Returns a pointer to a requested interface on the object
//             specified by a CLSID. The object specified by the CLSID is
//             aggregated by the specified outer unknown on return. The 
//             interface returned is a non-delegating interface on the object.
//
// Arguments:  clsid       -   CLSID of object on which interface 
//                           should be obtained
//             pUnkOuter   -  Aggregating outer unknown
//             riid        -  Interface requested
//             ppInterface -  Returns requested interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return requested interface
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CADsExtMgr::GetObjectByCLSID(
    CLSID clsid,
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppInterface
    )
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;
    IUnknown *pPrevUnk = NULL, *pUnknown = NULL;

    ADsAssert(ppInterface && pUnkOuter);

    if (!pClassEntry) {

        RRETURN(UMI_E_NOT_FOUND);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {
        if (IsEqualCLSID(pExtensionEntry->ExtCLSID, clsid)) {
           pPrevUnk = _pUnkOuter;

           _pUnkOuter = pUnkOuter;

           hr = LoadExtensionsIfReqd();
           if (FAILED(hr)) {
               _pUnkOuter = pPrevUnk;
               BAIL_ON_FAILURE(hr = E_FAIL);
           }

           pUnknown = pExtensionEntry->pUnknown; 

           if (!pUnknown) {

                BAIL_ON_FAILURE(hr = E_FAIL);
           }

           *ppInterface = pUnknown;
           pUnknown->AddRef();
           BAIL_ON_FAILURE(hr);

           RRETURN(S_OK);
       }

       pExtensionEntry = pExtensionEntry->pNext;
    }

    RRETURN(UMI_E_NOT_FOUND);

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetCLSIDForNames --- Used for ICustomInterfaceFactory support.
//
// Synopsis:   Returns the CLSID of the object that supports a specified
//             method/property. Also returns DISPIDs for the property/method.
//
// Arguments:  rgszNames     -  Names to be mapped
//             cNames        -  Number of names to be mapped
//             lcid          -  Locale in which to interpret the names
//             rgDispId      -  Returns DISPID
//             lFlags        -  Reserved. Must be 0.
//             pCLSID        -  Returns CLSID of object which supports this
//                             property/method.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return the CLSID.
//             *rgDispId to return the DISPIDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CADsExtMgr::GetCLSIDForNames(
    LPOLESTR *rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;

    ADsAssert(pCLSID && !lFlags && rgszNames && rgDispId);

    if (!_pClassEntry) {
        RRETURN(DISP_E_UNKNOWNNAME);
    }

    hr = LoadExtensionsIfReqd();
    if (FAILED(hr)) {
        RRETURN(DISP_E_UNKNOWNNAME);
    }

    pExtension = _pClassEntry->pExtensionHead;

    while (pExtension) {
        if (pExtension->fDisp) {
            //
            // fDisp = TRUE indicates
            //  1)  extension supports pADsExt AND
            //  2)  either
            //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
            //      OR
            //      b) we don't know if a) is true or not yet
            //

            ADsAssert(pExtension->pADsExt);

            hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                     IID_NULL,
                     rgszNames,
                     cNames,
                     lcid,
                     rgDispId
                     );

            if (SUCCEEDED(hr)) {
                *pCLSID = pExtension->ExtCLSID;
                RRETURN(S_OK);
            }
            else if (hr == E_NOTIMPL) {
                //
                // extension object does not support the optional
                // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                // -> remember this in cache & try next extension object
                //
                pExtension->fDisp = FALSE;
            }
        } 

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(hr = DISP_E_UNKNOWNNAME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\common.cxx ===
#include "ldap.hxx"
#pragma hdrstop


FILTERS Filters[] = { { USER_CLASS_NAME, LDAP_USER_ID},
                      { GROUP_CLASS_NAME, LDAP_GROUP_ID},
                      { PRINTER_CLASS_NAME, LDAP_PRINTER_ID},
                      { DOMAIN_CLASS_NAME, LDAP_DOMAIN_ID},
                      { COMPUTER_CLASS_NAME, LDAP_COMPUTER_ID},
                      { SERVICE_CLASS_NAME, LDAP_SERVICE_ID},
                      { FILESERVICE_CLASS_NAME, LDAP_FILESERVICE_ID},
                      { FILESHARE_CLASS_NAME, LDAP_FILESHARE_ID},
                      { CLASS_CLASS_NAME, LDAP_CLASS_ID},
                      { SYNTAX_CLASS_NAME, LDAP_SYNTAX_ID},
                      { PROPERTY_CLASS_NAME, LDAP_PROPERTY_ID},
                      { TEXT("Locality"), LDAP_LOCALITY_ID },
                      { TEXT("Organization"), LDAP_O_ID},
                      { TEXT("Organizational Unit"), LDAP_OU_ID},
                      { TEXT("organizationalUnit"), LDAP_OU_ID},
                      { TEXT("Country"), LDAP_COUNTRY_ID},
                      { TEXT("localGroup"), LDAP_GROUP_ID},
                      { TEXT("groupOfNames"), LDAP_GROUP_ID},
                      { TEXT("groupOfUniqueNames"), LDAP_GROUP_ID},
                      { TEXT("person"), LDAP_USER_ID},
                      { TEXT("organizationalPerson"), LDAP_USER_ID},
                      { TEXT("residentialPerson"), LDAP_USER_ID},
                      { TEXT("inetOrgPerson"), LDAP_USER_ID}

                    };

#define MAX_FILTERS (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;


HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    HRESULT hr = S_OK;
    TCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }

    RRETURN(ADsAllocString( ADsClass, pADsClass));
}


HRESULT
MakeUncName(
    LPTSTR szSrcBuffer,
    LPTSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    _tcscpy(szTargBuffer, TEXT("\\\\"));
    _tcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR SchemaClass,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;

    //
    // Both should never be NULL, replacing the ADsAsserts with 
    // this check to make sure that we never get into this problem
    // on all builds.
    //
    if (!Parent || !Name) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( SchemaClass, &_SchemaClass);
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _SchemaClass(NULL),
                        _ADsGuid(NULL),
                        _pUnkOuter(NULL),
                        _dwObjectState(0)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_SchemaClass) {
        ADsFreeString(_SchemaClass);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _SchemaClass == NULL || *_SchemaClass == 0 ) {
        hr = ADsAllocString(_ADsClass, retval);
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_SchemaClass, retval);  // report the actual class
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");


    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _SchemaClass == NULL || *_SchemaClass == 0 )
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = BuildSchemaPath(
             _ADsPath,
             _SchemaClass,
             retval );

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ DWORD dwFlags)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CCoreADsObject::GetInfo(
    THIS_ LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}


//----------------------------------------------------------------------------
// Function:   InitUmiObject
//
// Synopsis:   Initializes UMI object.
//
// Arguments:
//
// pSchema      Pointer to schema for this object
// dwSchemaSize Size of schema array
// pPropCache   Pointer to property cache for this object
// pUnkInner    Pointer to inner unknown of WinNT object
// pExtMgr      Pointer to extension manager object on WinNT object
// riid         Interface requested
// ppvObj       Returns pointer to interface 
//
// Returns:     S_OK if a UMI object is created and the interface is obtained. 
//              Error code otherwise 
//
// Modifies:    *ppvObj to return the UMI interface requested. 
//
//----------------------------------------------------------------------------
HRESULT 
CCoreADsObject::InitUmiObject(
    INTF_PROP_DATA intfProps[],
    CPropertyCache * pPropertyCache,
    IADs *pIADs,
    IUnknown *pUnkInner,
    REFIID riid,
    LPVOID *ppvObj,
    CCredentials *pCreds,
    DWORD dwPort, // defaulted to -1
    LPWSTR pszServerName, // defaulted to NULL
    LPWSTR pszLdapDn, // defaulted to NULL
    PADSLDP pLdapHandle, // defaulted to NULL,
    CADsExtMgr *pExtMgr // defaulted to NULL
    )
{
    HRESULT hr = S_OK;
    CLDAPUmiObject *pUmiObject = NULL;

    if (!ppvObj) {
        RRETURN(E_INVALIDARG);
    }

    hr = CLDAPUmiObject::CreateLDAPUmiObject(
             intfProps,
             pPropertyCache,
             pUnkInner,
             this, // pCoreObj
             pIADs,
             pCreds,
             &pUmiObject,
             dwPort,
             pLdapHandle,
             pszServerName,
             pszLdapDn,
             pExtMgr
             );

    BAIL_ON_FAILURE(hr);

    //
    // Bump up reference count of pUnkInner. On any error after this point,
    // the UMI object's destructor will call Release() on pUnkInner and we
    // don't want this to delete the LDAP object.
    //
    pUnkInner->AddRef();

    hr = pUmiObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    //
    // Ref on umi object is now 2, reduce by one.
    //
    pUmiObject->Release();

    //
    // Restore ref count of inner unknown
    //
    pUnkInner->Release();

    RRETURN(S_OK);

error:

    if (pUmiObject) {
        delete pUmiObject;
    }

    RRETURN(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cprov.cxx
//
//  Contents:  LDAP Provider Object Class Factory Code
//
//             CLDAPProvider
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

extern ULONG g_ulLocks;
extern CRITICAL_SECTION g_LockCritSect;

//  Class CLDAPProvider

CLDAPProvider::CLDAPProvider()
{
    EnterCriticalSection(&g_LockCritSect);
    g_ulLocks++;
    LeaveCriticalSection(&g_LockCritSect);
        
    ENLIST_TRACKING(CLDAPProvider);
}

HRESULT
CLDAPProvider::Create(CLDAPProvider FAR * FAR * ppProvider)
{
    CLDAPProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CLDAPProvider();
    if (pProvider == NULL) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN_EXP_IF_ERR(hr);
}

CLDAPProvider::~CLDAPProvider( )
{
    EnterCriticalSection(&g_LockCritSect);
    g_ulLocks--;
    LeaveCriticalSection(&g_LockCritSect);

}

STDMETHODIMP
CLDAPProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CLDAPProvider::ParseDisplayName(IBindCtx* pbc, TCHAR* szDisplayName, ULONG* pchEaten, IMoniker** ppmk)
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPProvider::ResolvePathName(IBindCtx* pbc,
                TCHAR* szDisplayName,
                ULONG* pchEaten,
                IMoniker** ppmk
                )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    CCredentials Credentials;

    if (!pchEaten) {
        BAIL_IF_ERROR(hr = E_INVALIDARG);
    }
    *pchEaten = 0;
    hr = GetObject(
            szDisplayName,
            Credentials,
            (LPVOID *)&pUnknown
            );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += _tcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for LDAP
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      15-Jun-96   yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString1 = NULL;
    LPWSTR tempString2 = NULL;

    PPROPERTY pNewProperties = NULL;

    PDISPPROPERTY pDispNewProperty = NULL;
    PDISPPROPERTY pDispNewProperties = NULL;
    DWORD dwDispLoc = 0;


    //
    // Allocate the string first
    //
    tempString1 = AllocADsStr(szPropertyName);

    if (!tempString1)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    // Make a copy for the Dispatch Mgr Table.
    //

    tempString2 = AllocADsStr(szPropertyName);

    if (!tempString2)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    //  extend the property cache by adding a new property entry
    //

    pNewProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!pNewProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _pProperties = pNewProperties;

    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);


    //
    // Since the memory has already been allocated in tempString
    // just set the value/pointer now.
    //
    pNewProperty->szPropertyName = tempString1;

    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

    //
    //  extend the property cache by adding a new property entry
    //

    //
    // Need to check if this property is already there in the
    // dispatch table - otherwise we are going to keep on growing
    // forever - AjayR 7-31-98.
    //

    hr = DispatchFindProperty(szPropertyName, &dwDispLoc);

    if (hr == S_OK) {
        // we do not need this string in this case
        if (tempString2) {
            FreeADsStr(tempString2);
            tempString2 = NULL;
        }
    } else {

        //
        // reset the hr otherwise we will return an
        // error incorrectly when there was none.
        //
        hr = S_OK;

        pDispNewProperties = (PDISPPROPERTY)ReallocADsMem(
                                    _pDispProperties,
                                    _cbDisp,
                                    _cbDisp + sizeof(DISPPROPERTY)
                                    );
        if (!pDispNewProperties) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        _pDispProperties = pDispNewProperties;

        pDispNewProperty = (PDISPPROPERTY)((LPBYTE)_pDispProperties + _cbDisp);


        //
        // Since the memory has already been allocated in tempString
        // just set the value/pointer now.
        //
        pDispNewProperty->szPropertyName = tempString2;

        //
        // Update the index
        //

        _dwDispMaxProperties++;
        _cbDisp += sizeof(DISPPROPERTY);

    } // else clause - that is property not found in disp

    RRETURN(hr);
error:

    // if we failed but we already increased the property count and property size, we need to revert them
    if(pNewProperties)
    {
        _dwMaxProperties--;
        _cb -= sizeof(PROPERTY);        
    }

    if (tempString1){
       FreeADsStr(tempString1);
    }

    if (tempString2) {
        FreeADsStr(tempString2);
    }


    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putpropertyext
//
//  Synopsis: Similar to put property only unlike update it will add
//       the property to the cahce if it is not already there ! 
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//  History 
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putpropertyext(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    LDAPOBJECTARRAY ldapObjectArray
    )
{
    HRESULT hr;
    DWORD dwIndex;
    BOOL fFound = FALSE;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    //
    // If the property is not in the cache we need to add it
    // as updateproperty expects it to be in the cache.
    //
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        hr = addproperty(
                 szPropertyName
                 );
    } 
    else {
        fFound = TRUE;
    }

    BAIL_ON_FAILURE(hr);

    //
    // at this time we can call putproperty
    //
    if (fFound) {
        hr = putproperty(
                 dwIndex,
                 dwFlags,
                 dwSyntaxId,
                 ldapObjectArray
                 );
    } 
    else {
        hr = putproperty(
                 szPropertyName,
                 dwFlags,
                 dwSyntaxId,
                 ldapObjectArray
                 );
    }

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    LDAPOBJECTARRAY ldapObjectArray,
    BOOL   fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (!fExplicit) {
        if ( PROPERTY_FLAGS(pThisProperty) == PROPERTY_UPDATE ) {
            hr = S_OK;
            goto error;
        }
    }

    // Free the old values first
    LdapTypeFreeLdapObjects( &(PROPERTY_LDAPOBJECTARRAY(pThisProperty)));

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;

    hr = LdapTypeCopyConstruct(
            ldapObjectArray,
            &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
            );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }

    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);

}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId,
    PDWORD pdwStatusFlag,
    LDAPOBJECTARRAY *pLdapObjectArray
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;    


    //
    // retrieve index of property in cache
    //

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    //
    // if property not already in cache, try get properties from svr
    //

    //
    // INDEX_EMPTY(???) ???
    //

    if ((hr == E_ADS_PROPERTY_NOT_FOUND || 
         (INDEX_EMPTY(dwIndex) && !PROP_DELETED(dwIndex))
        ) && 
        !_fGetInfoDone)
    { 
        BOOL fResult = FindSavingEntry(szPropertyName);

        if(!fResult) {
            hr = _pCoreADsObject->GetInfo(FALSE);

            // workaround to avoid confusing callers of getproperty.
            if (hr == E_NOTIMPL) {
                hr = E_ADS_PROPERTY_NOT_FOUND;
            }
            BAIL_ON_FAILURE(hr);

            hr = findproperty(szPropertyName, &dwIndex);

        }
        else {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }
    }
    BAIL_ON_FAILURE(hr);


    //
    // get property based on index in cache
    //

    hr = unboundgetproperty(
            dwIndex,
            pdwSyntaxId,
            pdwStatusFlag,
            pLdapObjectArray
            );

error:


   RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putproperty(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    LDAPOBJECTARRAY ldapObjectArray
    )
{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0L;

    hr = findproperty(szPropertyName, &dwIndex);
    if (SUCCEEDED(hr))
        hr = putproperty(dwIndex, dwFlags, dwSyntaxId, ldapObjectArray);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putproperty(
    DWORD  dwIndex,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    LDAPOBJECTARRAY ldapObjectArray
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pThisProperty = NULL;

    pThisProperty = _pProperties + dwIndex;

    // Free the old values first
    LdapTypeFreeLdapObjects( &(PROPERTY_LDAPOBJECTARRAY(pThisProperty)) );

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

    switch ( dwFlags ) {

    case PROPERTY_INIT:
        if ( ldapObjectArray.dwCount > 0 )
        {
            hr = LdapTypeCopyConstruct(
                     ldapObjectArray,
                     &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
                     );
            BAIL_ON_FAILURE(hr);
        }

        PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;
        break;

    case PROPERTY_DELETE:
        PROPERTY_FLAGS(pThisProperty) = PROPERTY_DELETE;
        break;

    case PROPERTY_UPDATE:
        if ( ldapObjectArray.dwCount > 0 )
        {
            hr = LdapTypeCopyConstruct(
                     ldapObjectArray,
                     &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
                     );
            BAIL_ON_FAILURE(hr);
        }

        PROPERTY_FLAGS(pThisProperty) = ldapObjectArray.dwCount?
                                        PROPERTY_UPDATE : PROPERTY_DELETE;
        break;


    case PROPERTY_DELETE_VALUE:
        if ( ldapObjectArray.dwCount > 0 )
        {
            hr = LdapTypeCopyConstruct(
                     ldapObjectArray,
                     &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
                     );
            BAIL_ON_FAILURE(hr);
        }

        PROPERTY_FLAGS(pThisProperty) = PROPERTY_DELETE_VALUE;

        break;



    case PROPERTY_ADD:
        hr = LdapTypeCopyConstruct(
                 ldapObjectArray,
                 &(PROPERTY_LDAPOBJECTARRAY(pThisProperty))
                 );
        BAIL_ON_FAILURE(hr);

        PROPERTY_FLAGS(pThisProperty) = PROPERTY_ADD;
        break;

    }

error:

    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
CPropertyCache():
    _dwMaxProperties(0),
    _pProperties(NULL),
    _cb(0),
    _dwCurrentIndex(0),
    _pCoreADsObject(NULL),
    _pGetAttributeSyntax(NULL),
    _fGetInfoDone(FALSE),
    _pDispProperties(NULL),
    _dwDispMaxProperties(0),
    _cbDisp(0),
    _pCredentials(NULL),
    _pszServerName(NULL),
    _dwPort(0)
{
    InitializeListHead(&_ListSavingEntries);

}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    PPROPERTY pThisProperty = NULL;
    PDISPPROPERTY pThisDispProperty = NULL;
    
    if (_pProperties) {

        for ( DWORD i = 0; i < _dwMaxProperties; i++ ) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            LdapTypeFreeLdapObjects(&(PROPERTY_LDAPOBJECTARRAY(pThisProperty)));
        }

        FreeADsMem(_pProperties);
    }

    if (_pDispProperties) {

        for ( DWORD i = 0; i < _dwDispMaxProperties; i++ ) {

            pThisDispProperty = _pDispProperties + i;

            if (pThisDispProperty->szPropertyName) {
               FreeADsStr(pThisDispProperty->szPropertyName);
               pThisDispProperty->szPropertyName = NULL;
            }

        }

        FreeADsMem(_pDispProperties);
    }

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
        _pszServerName = NULL;
    }

    DeleteSavingEntry();


    //
    // The property cache is deleted before the object is
    // so the object will handle freeing the credentials.
    // We just keep a pointer to the credentials.
    //
    if (_pCredentials) {
        _pCredentials = NULL;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::ClearAllPropertyFlags
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT CPropertyCache::ClearAllPropertyFlags(VOID)
{
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for ( DWORD i = 0; i < _dwMaxProperties; i++ ) {

            pThisProperty = _pProperties + i;
            PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;
        }
    }

    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::ClearPropertyFlag
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT CPropertyCache::ClearPropertyFlag( LPWSTR szPropertyName )
{
    PPROPERTY pThisProperty = NULL;
    HRESULT hr = S_OK;
    DWORD dwIndex;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;
    if (PROPERTY_LDAPOBJECTARRAY(pThisProperty).pLdapObjects) {

        PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;
    }

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::ClearMarshalledProperties
//
//  Synopsis: Once the properties have been marshalled and
// the set has been done, the properties on the cache are no
// longer valid. This method must be called to keep the property
// cache in a coherrent state.
//       The method frees the 'dirty' entries, sets implicit get
// flag. If the dirty entries cannot be cleared, then the
// entire contents are flushed and they will be picked up at the
// next GetInfo call -- AjayR
//
//  Arguments: None.
//
//
//-------------------------------------------------------------------------
HRESULT CPropertyCache::ClearMarshalledProperties()
{
    HRESULT hr = S_OK;
    DWORD dwIndx = 0;
    DWORD dwCtr = 0;
    DWORD dwChng = 0;
    PPROPERTY pNewProperties = NULL;
    PPROPERTY pThisProperty = NULL;
    PPROPERTY pNewCurProperty = NULL;
    DWORD dwNewProps = 0;


    //
    // Go through properties to see how many have changed
    //
    for (dwCtr = 0; dwCtr < _dwMaxProperties; dwCtr++ ) {
        pThisProperty = _pProperties + dwCtr;

        if (PROPERTY_FLAGS(pThisProperty) != PROPERTY_INIT)
            dwChng++;
    }

    if (dwChng == 0) {
        RRETURN(S_OK);
    }

    //
    // Need to remove those entries which were changed
    //

    dwNewProps = _dwMaxProperties - dwChng;

    if (dwNewProps != 0) {
        pNewProperties = (PPROPERTY) AllocADsMem(
                                         dwNewProps * sizeof(PROPERTY)
                                         );

        if (!pNewProperties) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            // if this fails, then we cannot recover
            // effectively. What alternative is there ?
            // We do not want to flush the cache.
        }
    }

    for (dwCtr = 0, dwIndx = 0; dwCtr < _dwMaxProperties; dwCtr++ ) {

        pThisProperty = _pProperties + dwCtr;

        if (PROPERTY_FLAGS(pThisProperty) != PROPERTY_INIT) {
            //
            // delete the property
            //

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            LdapTypeFreeLdapObjects(&(PROPERTY_LDAPOBJECTARRAY(pThisProperty)));

        } else {

            //
            // Sanity Check, should not hit this if Assert preferable
            //
            if (dwIndx > dwNewProps || dwIndx == dwNewProps) {
                BAIL_ON_FAILURE(hr = E_FAIL);
            }

            pNewCurProperty = pNewProperties + dwIndx;

            pNewCurProperty->szPropertyName = pThisProperty->szPropertyName;

            pNewCurProperty->ldapObjectArray =
                PROPERTY_LDAPOBJECTARRAY(pThisProperty);

            pNewCurProperty->dwFlags = pThisProperty->dwFlags;

            pNewCurProperty->dwSyntaxId = pThisProperty->dwSyntaxId;

            dwIndx++;
        }
    } // for, copying the old elements to new buffer

    _dwMaxProperties -= dwChng;

    _cb = dwNewProps * sizeof(PROPERTY);

    if (_pProperties)
        FreeADsMem(_pProperties);

    _pProperties = pNewProperties;


    // Need to set this flag to implicitly fetch properties
    // the next time somebody asks for a poperty not in the cache.
    _fGetInfoDone = FALSE;

    RRETURN(S_OK);

error:

    if (pNewProperties) {
        FreeADsMem(pNewProperties);
    }

    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::SetPropertyFlag
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT CPropertyCache::SetPropertyFlag( LPWSTR szPropertyName, DWORD dwFlag )
{
    PPROPERTY pThisProperty = NULL;
    HRESULT hr = S_OK;
    DWORD dwIndex;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;
    if (PROPERTY_LDAPOBJECTARRAY(pThisProperty).pLdapObjects) {

        PROPERTY_FLAGS(pThisProperty) = dwFlag;
    }

error:

    RRETURN(hr);
}


HRESULT CPropertyCache::GetPropertyFlag( LPWSTR szPropertyName, DWORD* pdwFlag )
{
    PPROPERTY pThisProperty = NULL;
    HRESULT hr = S_OK;
    DWORD dwIndex;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    *pdwFlag = PROPERTY_FLAGS(pThisProperty);
    

error:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::IsPropertyUpdated
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
IsPropertyUpdated(
    LPWSTR szPropertyName,
    BOOL   *pfUpdated
    )
{
    PPROPERTY pThisProperty = NULL;
    HRESULT hr = S_OK;
    DWORD dwIndex;

    *pfUpdated = FALSE;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;
    if (PROPERTY_LDAPOBJECTARRAY(pThisProperty).pLdapObjects) {

        if ( PROPERTY_FLAGS(pThisProperty) == PROPERTY_UPDATE )
            *pfUpdated = TRUE;
    }

error:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::createpropertycache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    CCoreADsObject *pCoreADsObject,
    IGetAttributeSyntax *pGetAttributeSyntax,
    CPropertyCache **ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    pPropertyCache->_pGetAttributeSyntax = pGetAttributeSyntax;
    pPropertyCache->_fGetInfoDone = FALSE;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}


HRESULT
CPropertyCache::SetObjInformation(
    CCredentials* pCredentials,
    LPWSTR pszServerName,
    DWORD dwPortNo
    )
{
    //
    // We need the credentials to be valid
    //
    if (!pCredentials) {
        ADsAssert(!"InvalidCredentials to prop cache");
    } else {
        _pCredentials = pCredentials;
    }

    //
    // This can be NULL, so it is better to allocate and dealloc
    // in destructor
    //
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
        _pszServerName = NULL;
    }

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);
        if (_pszServerName == NULL) {
            RRETURN(E_OUTOFMEMORY);
        }
    }

    _dwPort = dwPortNo;

    RRETURN(S_OK);
}
//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::flushpropertycache
//
//  Synopsis:   Flushes the property cache of all data.
//
//  The name <-> index mappings need to stay until the property cache is
//  destructed, because the indexes are also used as the DISPIDs of the
//  properties.  So this neither deallocates the names nor the array itself.
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropertycache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            LdapTypeFreeLdapObjects(&(PROPERTY_LDAPOBJECTARRAY(pThisProperty)));
            PROPERTY_FLAGS(pThisProperty) = PROPERTY_INIT;
        }

        FreeADsMem(_pProperties);

        _pProperties = NULL;
        _dwMaxProperties = 0;
        _cb = 0;

    }

    //
    // Reset the property cache
    //

    _dwCurrentIndex = 0;
    _fGetInfoDone = FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::unmarshallproperty
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    PADSLDP pLdapHandle,
    LDAPMessage *entry,
    DWORD  dwSyntaxId,
    BOOL   fExplicit,
    BOOL * pfRangeRetrieval // defaulted to NULL
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    LDAPOBJECTARRAY ldapObjectArray;
    LPWSTR pszTemp = NULL;
    WCHAR* pszTempPropertyName = NULL;
    WCHAR* pszToken = NULL;
    WCHAR* pszPlaceHolder = NULL;
    

    LDAPOBJECTARRAY_INIT(ldapObjectArray);

    //
    // If arg is valid default value to false.
    //
    if (pfRangeRetrieval) {
        *pfRangeRetrieval = FALSE;
    }

    hr = UnMarshallLDAPToLDAPSynID(
             szPropertyName,
             pLdapHandle,
             entry,
             dwSyntaxId,
             &ldapObjectArray
             );

    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Need to look for ; when subtype of attribute is used
    //
    if ((pszTemp = wcschr(szPropertyName, L';')) != NULL ) {
        // we don't want to break the existing behavior of range retrieval, so keep it
        // as a special case. For the others, we will not strip whatever is after ;
            
            pszTempPropertyName= new WCHAR[wcslen(szPropertyName) + 1];
            if(!pszTempPropertyName)
            {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            	
            wcsncpy(pszTempPropertyName, szPropertyName, pszTemp-szPropertyName);
            pszTempPropertyName[pszTemp-szPropertyName] = '\0';		

            pszToken = wcstok( pszTemp+1, L";" );
            while( pszToken != NULL )
            {
                if(_wcsnicmp(pszToken, L"Range=", wcslen(L"Range=")))			
                {
                    wcscat(pszTempPropertyName, L";");
                    wcscat(pszTempPropertyName, pszToken);
                }

                pszPlaceHolder= pszToken - 1;

                pszToken = wcstok( NULL, L";" );
                *pszPlaceHolder = L';';
                
            }
            
            
    }
    //
    // Find this property in the cache
    //

    hr = findproperty(
                pszTempPropertyName? pszTempPropertyName : szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    pszTempPropertyName? pszTempPropertyName : szPropertyName
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    pszTempPropertyName? pszTempPropertyName : szPropertyName,
                    dwSyntaxId,
                    ldapObjectArray,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);    
    
    //
    // Put the ; back if we replaced it.
    //
    if (pszTemp) {        

        //
        // Do we need to update the flag ?
        //
        if (pfRangeRetrieval) {
            //
            // See if this was members and update flag.
            //
            if (!_wcsicmp(L"member", pszTempPropertyName? pszTempPropertyName : szPropertyName)) {
                *pfRangeRetrieval = TRUE;
            }
        }        

    }    

error:

    if ( ldapObjectArray.fIsString )
        LdapValueFree( (TCHAR **) ldapObjectArray.pLdapObjects );
    else
        LdapValueFreeLen( (struct berval **) ldapObjectArray.pLdapObjects );

    if(pszTempPropertyName)
        delete [] pszTempPropertyName;

    RRETURN_EXP_IF_ERR(hr);

}


HRESULT
CPropertyCache::
LDAPUnMarshallProperties(
    LPWSTR   pszServerPath,
    PADSLDP pLdapHandle,
    LDAPMessage *ldapmsg,
    BOOL     fExplicit,
    CCredentials& Credentials
    )
{
    int nNumberOfEntries = 0L;
    int nNumberOfValues = 0L;
    HRESULT hr = S_OK;
    DWORD i = 0;
    LDAPMessage *entry;
    LPWSTR pszAttrName = NULL;
    BSTR bstrADsPath = NULL;
    void *ptr;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    //
    // Compute the number of attributes in the
    // read buffer.

    nNumberOfEntries = LdapCountEntries( pLdapHandle, ldapmsg );

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);

    hr = _pCoreADsObject->get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsObject(bstrADsPath, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );

    BAIL_ON_FAILURE(hr);

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);

    while ( pszAttrName != NULL )
    {
        DWORD dwSyntax = LDAPTYPE_UNKNOWN;       
        

        //
        // unmarshall this property into the
        // property cache.
        // LdapGetSyntax takes care of ; while looking up
        // the schema no need to handle at this level.
        //
        hr = LdapGetSyntaxOfAttributeOnServer(
                 pszServerPath,
                 pszAttrName,
                 &dwSyntax,
                 Credentials,
                 pObjectInfo->PortNumber,
                 TRUE // fForce
                 );        

        if ( SUCCEEDED(hr) && (dwSyntax != LDAPTYPE_UNKNOWN))
        {
            if ( (!_wcsicmp(pszAttrName, L"ntSecurityDescriptor")) &&
                 (dwSyntax == LDAPTYPE_OCTETSTRING) )
            {
                dwSyntax = LDAPTYPE_SECURITY_DESCRIPTOR;
            }

            (VOID) unmarshallproperty(
                       pszAttrName,
                       pLdapHandle,
                       entry,
                       dwSyntax,
                       fExplicit
                       );
        }

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;

        //
        // If we cannot find the syntax, ignore the property and
        // continue with the next property
        //
        hr = S_OK;

        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );

        BAIL_ON_FAILURE(hr);

        FreeObjectInfo(pObjectInfo);

        memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    }

error:

    if(bstrADsPath)
    {
        ADsFreeString(bstrADsPath);
    }    
    
    FreeObjectInfo(pObjectInfo);

    RRETURN_EXP_IF_ERR(hr);

}

////////////////////////////////////////////////////////////////////////
//
// Unmarshall attributes (& their values) in [ldapmsg] into cache.
// Syntaxes of attributes are read from schema on server [pszServerPath].
// If an attribute not in the schema (e.g. not in our default schema used
// in case of schemaless server), the attribute is unmarshalled as ldap
// binary data with type = LDAPTYPE_UNKWNON.
//
// [Credentials]
//      - used to access pszServerPath
//
// [pLdapHandle]
//      - handle assoc with [ldapmsg]
//      - used to retrive attributes and their values from [ldapmsg]
//
// [fExplicit]
//      - overwrite value of exiting attributes in cache iff = TRUE
//
// NOTE: This function modified LDAPUnMarshallProperties to allow
// unmarshalling of attributes not in the schema.
//
////////////////////////////////////////////////////////////////////////

HRESULT
CPropertyCache::
LDAPUnMarshallProperties2(
    IN LPWSTR   pszServerPath,
    IN PADSLDP pLdapHandle,
    IN LDAPMessage *ldapmsg,
    IN BOOL     fExplicit,
    IN CCredentials& Credentials,
    OUT BOOL * pfRangeRetrieval
    )
{

    HRESULT hr = S_OK;
    int nNumberOfEntries = 0L;
    LDAPMessage *entry = NULL;
    void *ptr = NULL;
    LPWSTR pszAttrName = NULL;
    DWORD dwSyntax = LDAPTYPE_UNKNOWN;
    BSTR bstrADsPath = NULL;
    OBJECTINFO ObjectInfo;
    BOOL fRange = FALSE;
    memset(&ObjectInfo, 0, sizeof(OBJECTINFO));

    ADsAssert(pfRangeRetrieval);
    *pfRangeRetrieval = FALSE;

    if (!pLdapHandle || !ldapmsg)
        RRETURN(E_ADS_BAD_PARAMETER);


    //
    // Compute the number of attributes in the read buffer.
    //

    nNumberOfEntries = LdapCountEntries(pLdapHandle, ldapmsg);

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);


    //
    // get port number to talk to server on which schema locate ???
    //

    hr = _pCoreADsObject->get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsObject(bstrADsPath, &ObjectInfo);
    BAIL_ON_FAILURE(hr);


    //
    // Get first entry from ldapmsg first. Should be only one entry.
    //

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );
    BAIL_ON_FAILURE(hr);


    //
    // get first attribute's name
    //

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);


    while ( pszAttrName != NULL )
    {
        //
        // get syntax of attribute from schema on sever (may be cached);
        // continue to unmarshall the attribute even if it isn't in the
        // schema.
        //

        dwSyntax = LDAPTYPE_UNKNOWN;

        (VOID) LdapGetSyntaxOfAttributeOnServer(
                    pszServerPath,
                    pszAttrName,
                    &dwSyntax,
                    Credentials,
                    ObjectInfo.PortNumber,
                    TRUE // fForce
                    );


        //
        // There is currently no such syntax as "SecurityDescriptor" on
        // server, ADSI will unmarshall "OctetString" security descriptor
        // as as ntSecurityDescriptor
        //

        if ( (!_wcsicmp(pszAttrName, L"ntSecurityDescriptor"))
                &&   (dwSyntax == LDAPTYPE_OCTETSTRING)
           )
        {
               dwSyntax = LDAPTYPE_SECURITY_DESCRIPTOR;
        }

        //
        // unmarshall the property into cache, LDAPTYPE_UNWKNOWN
        // (dwSyntax) will be unmarshalled as binary data.
        //

        (VOID) unmarshallproperty(
                       pszAttrName,
                       pLdapHandle,
                       entry,
                       dwSyntax,
                       fExplicit,
                       fRange ? NULL : pfRangeRetrieval
                       );

        //
        // Small trick to make sure we do not loose the range
        // retrieval information for members attribute.
        //
        fRange = *pfRangeRetrieval;

        //
        // get next attribute
        //

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;
        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );
        BAIL_ON_FAILURE(hr);
    }

error:

    if (bstrADsPath)
        ADsFreeString(bstrADsPath);

    FreeObjectInfo(&ObjectInfo);

    RRETURN_EXP_IF_ERR(hr);

}

////////////////////////////////////////////////////////////////////////
//
// Unmarshall attributes (& their values) in [ldapmsg] into cache.
// Syntaxes of attributes are read from schema on server [pszServerPath].
// If an attribute not in the schema (e.g. not in our default schema used
// in case of schemaless server), the attribute is unmarshalled as dwDefaultSyntaxID
//
// [Credentials]
//      - used to access pszServerPath
//
// [pLdapHandle]
//      - handle assoc with [ldapmsg]
//      - used to retrive attributes and their values from [ldapmsg]
//
// [fExplicit]
//      - overwrite value of exiting attributes in cache iff = TRUE
//
// NOTE: This function modified LDAPUnMarshallProperties2 to allow
// unmarshalling of attributes not in the schema with dwDefaultSyntaxID passed in
// It is currently only used by CLDAPRootDSE::GetInfoEx, since most of the attributes on
// RootDSE on not defined in schema
//
////////////////////////////////////////////////////////////////////////

HRESULT
CPropertyCache::
LDAPUnMarshallProperties3(
    LPWSTR   pszServerPath,
    PADSLDP pLdapHandle,
    LDAPMessage *ldapmsg,
    BOOL     fExplicit,
    DWORD   dwDefaultSyntaxID,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    int nNumberOfEntries = 0L;
    LDAPMessage *entry = NULL;
    void *ptr = NULL;
    LPWSTR pszAttrName = NULL;
    DWORD dwSyntax = LDAPTYPE_UNKNOWN;
    BSTR bstrADsPath = NULL;    
    OBJECTINFO ObjectInfo;    
    memset(&ObjectInfo, 0, sizeof(OBJECTINFO));    

    if (!pLdapHandle || !ldapmsg)
        RRETURN(E_ADS_BAD_PARAMETER);


    //
    // Compute the number of attributes in the read buffer.
    //

    nNumberOfEntries = LdapCountEntries(pLdapHandle, ldapmsg);

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);


    //
    // get port number to talk to server on which schema locate ???
    //

    hr = _pCoreADsObject->get_CoreADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsObject(bstrADsPath, &ObjectInfo);
    BAIL_ON_FAILURE(hr);


    //
    // Get first entry from ldapmsg first. Should be only one entry.
    //

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );
    BAIL_ON_FAILURE(hr);


    //
    // get first attribute's name
    //

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);


    while ( pszAttrName != NULL )
    {
        //
        // get syntax of attribute from schema on sever (may be cached);
        // continue to unmarshall the attribute even if it isn't in the
        // schema.
        //

        dwSyntax = LDAPTYPE_UNKNOWN;

        (VOID) LdapGetSyntaxOfAttributeOnServer(
                    pszServerPath,
                    pszAttrName,
                    &dwSyntax,
                    Credentials,
                    ObjectInfo.PortNumber,
                    TRUE // fForce
                    );


        if(dwSyntax == LDAPTYPE_UNKNOWN)
        {
            dwSyntax = dwDefaultSyntaxID;            
        }

        //
        // unmarshall the property into cache, LDAPTYPE_UNWKNOWN
        // (dwSyntax) will be unmarshalled as binary data.
        //

        (VOID) unmarshallproperty(
                       pszAttrName,
                       pLdapHandle,
                       entry,
                       dwSyntax,
                       fExplicit                       
                       );
        
        //
        // get next attribute
        //

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;
        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );
        BAIL_ON_FAILURE(hr);
    }

error:

    if (bstrADsPath)
        ADsFreeString(bstrADsPath);

    FreeObjectInfo(&ObjectInfo);
    
    RRETURN_EXP_IF_ERR(hr);

    
}



HRESULT
CPropertyCache::
LDAPMarshallProperties(
    LDAPModW ***aMods,
    PBOOL pfNTSecDes,
    SECURITY_INFORMATION *pSeInfo
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD j = 0;
    PPROPERTY pThisProperty = NULL;
    int dwCount = 0;
    LDAPModW *aModsBuffer = NULL;
    LDAPOBJECTARRAY ldapObjectArray;
    
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fSecDesProp = FALSE;

    *pSeInfo = INVALID_SE_VALUE;
    *pfNTSecDes = FALSE;

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) != PROPERTY_INIT)
            dwCount++;
    }

    if ( dwCount == 0 )  // Nothing to change
    {
        *aMods = NULL;
        RRETURN(S_OK);
    }

    *aMods = (LDAPModW **) AllocADsMem((dwCount+1) * sizeof(LDAPModW *));

    if ( *aMods == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    aModsBuffer = (LDAPModW *) AllocADsMem( dwCount * sizeof(LDAPModW));

    if ( aModsBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0, j = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == PROPERTY_INIT ) {

            continue;
        }


        if (!_wcsicmp(PROPERTY_NAME(pThisProperty),L"ntSecurityDescriptor")) {
            *pfNTSecDes = TRUE;
            fSecDesProp = TRUE;
        } else {
            fSecDesProp = FALSE;
        }

        ldapObjectArray = PROPERTY_LDAPOBJECTARRAY(pThisProperty);

        (*aMods)[j] = &aModsBuffer[j];
        aModsBuffer[j].mod_type   = PROPERTY_NAME(pThisProperty);

        if ( ldapObjectArray.fIsString )
        {
            aModsBuffer[j].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
        }
        else
        {
            aModsBuffer[j].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
            aModsBuffer[j].mod_op = LDAP_MOD_BVALUES;
            if (fSecDesProp && ldapObjectArray.pLdapObjects) {
                pSecurityDescriptor = LDAPOBJECT_BERVAL_VAL(ldapObjectArray.pLdapObjects);

                if ( GetSecurityDescriptorOwner(
                                pSecurityDescriptor,
                                &pOwnerSid,
                                &fOwnerDefaulted
                                )
                            &&
                     
                     GetSecurityDescriptorGroup(
                                pSecurityDescriptor,
                                &pGroupSid,
                                &fGroupDefaulted
                                    )
                            &&

                     GetSecurityDescriptorDacl(
                                pSecurityDescriptor,
                                &DaclPresent,
                                &pDacl,
                                &fDaclDefaulted
                                )
                            &&
                     
                     GetSecurityDescriptorSacl(
                                pSecurityDescriptor,
                                &SaclPresent,
                                &pSacl,
                                &fSaclDefaulted
                                )
                   ) {
                    //
                    // All the calls succeeded, so we should reset to 0
                    // instead of the invalid value.
                    //
                    *pSeInfo = 0;

                    if (!fOwnerDefaulted) {
                        *pSeInfo = *pSeInfo | OWNER_SECURITY_INFORMATION;
                    }

                    if (!fGroupDefaulted) {
                        *pSeInfo = *pSeInfo | GROUP_SECURITY_INFORMATION;
                    }

                    //
                    // If the DACL is present we need to send DACL bit.
                    // 
                    if (DaclPresent) {
                        *pSeInfo = *pSeInfo | DACL_SECURITY_INFORMATION;
                    }

                    //
                    // If SACL present then we set the SACL bit.
                    if (SaclPresent) {
                        *pSeInfo = *pSeInfo | SACL_SECURITY_INFORMATION;
                    }

                }

            }
        }

        switch( PROPERTY_FLAGS(pThisProperty))
        {
            case PROPERTY_UPDATE:
                aModsBuffer[j].mod_op |= LDAP_MOD_REPLACE;
                break;

            case PROPERTY_ADD:
                aModsBuffer[j].mod_op |= LDAP_MOD_ADD;
                break;

            case PROPERTY_DELETE:
                aModsBuffer[j].mod_op |= LDAP_MOD_DELETE;
                break;


            case PROPERTY_DELETE_VALUE:
                aModsBuffer[j].mod_op |= LDAP_MOD_DELETE;
                break;

        }

        j++;

    }


    RRETURN(hr);

error:

    FreeADsMem( aModsBuffer );
    FreeADsMem( *aMods );
    *aMods = NULL;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CPropertyCache::
LDAPMarshallProperties2(
    LDAPModW ***aMods,
    DWORD *pdwNumOfMods
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD j = 0;
    PPROPERTY pThisProperty = NULL;
    int dwCount = 0;
    LDAPModW *aModsBuffer = NULL;
    LDAPOBJECTARRAY ldapObjectArray;

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) != PROPERTY_INIT)
            dwCount++;
    }

    if ( dwCount == 0 )  // Nothing to change
        RRETURN(S_OK);

    if ( *aMods == NULL )
    {
        *aMods = (LDAPModW **) AllocADsMem((dwCount+1) * sizeof(LDAPModW *));

        if ( *aMods == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aModsBuffer = (LDAPModW *) AllocADsMem( dwCount * sizeof(LDAPModW));

        if ( aModsBuffer == NULL )
        {
            FreeADsMem( *aMods );
            *aMods = NULL;
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    else
    {
        LDAPModW **aModsTemp = NULL;

        aModsTemp = (LDAPModW **) AllocADsMem(
                        (*pdwNumOfMods+ dwCount + 1) * sizeof(LDAPModW *));

        if ( aModsTemp == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aModsBuffer = (LDAPModW *) AllocADsMem(
                          (*pdwNumOfMods + dwCount) * sizeof(LDAPModW));

        if ( aModsBuffer == NULL )
        {
            FreeADsMem( aModsTemp );
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy( aModsBuffer, **aMods, *pdwNumOfMods * sizeof(LDAPModW));
        FreeADsMem( **aMods );
        FreeADsMem( *aMods );

        *aMods = aModsTemp;

        for ( j = 0; j < *pdwNumOfMods; j++ )
        {
            (*aMods)[j] = &aModsBuffer[j];
        }
    }

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == PROPERTY_INIT ) {

            continue;
        }

        ldapObjectArray = PROPERTY_LDAPOBJECTARRAY(pThisProperty);

        (*aMods)[j] = &aModsBuffer[j];
        aModsBuffer[j].mod_type   = PROPERTY_NAME(pThisProperty);

        if ( ldapObjectArray.fIsString )
        {
            aModsBuffer[j].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
        }
        else
        {
            aModsBuffer[j].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
            aModsBuffer[j].mod_op = LDAP_MOD_BVALUES;
        }

        switch( PROPERTY_FLAGS(pThisProperty))
        {
            case PROPERTY_UPDATE:
                aModsBuffer[j].mod_op |= LDAP_MOD_REPLACE;
                break;

            case PROPERTY_ADD:
                aModsBuffer[j].mod_op |= LDAP_MOD_ADD;
                break;

            case PROPERTY_DELETE:
                aModsBuffer[j].mod_op |= LDAP_MOD_DELETE;
                break;
        }

        j++;

    }

    *pdwNumOfMods += dwCount;

error:

    RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::unboundgetproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR  szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwStatusFlag,
    LDAPOBJECTARRAY *pLdapObjectArray
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;


    //
    // get index of property in cache
    //

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);


    //
    // get property based on index in cache
    //

    hr = unboundgetproperty(
            dwIndex,
            pdwSyntaxId,
            pdwStatusFlag,
            pLdapObjectArray
            );

error:

   RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::unboundgetproperty
//
//  Synopsis: Note that this version takes the index of the element to
//      fetch. It also returns the control code of the item in the cache.
//
//
//  Arguments:  [dwIndex]           --  Index of the property to retrieve.
//              [pdwSytnaxId]       --  SyntaxId of the data.
//              [pdwStatusFlag]     --  Status of this property in cache.
//              [pLdapObjectArray]  --  Array of ldapObjects returned.
//
//  NOTE: [dwIndex] is invalid -> E_ADS_PROPERTY_NOT_FOUND//E_FAIL ???
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD pdwSyntaxId,
    PDWORD pdwStatusFlag,
    LDAPOBJECTARRAY *pLdapObjectArray
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pThisProperty = NULL;


    if (!index_valid(dwIndex))
        RRETURN(E_ADS_PROPERTY_NOT_FOUND);

    pThisProperty = _pProperties + dwIndex;


    // Status flag has to be valid if we found the property
    *pdwStatusFlag = PROPERTY_FLAGS(pThisProperty);


    if (PROPERTY_LDAPOBJECTARRAY(pThisProperty).pLdapObjects) {

        //
        // property has non-empty values
        //

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);

        hr = LdapTypeCopyConstruct(
                PROPERTY_LDAPOBJECTARRAY(pThisProperty),
                pLdapObjectArray
                );
        BAIL_ON_FAILURE(hr);

    }else {

        //
        // property has empty values: E.g. status flag indicate delete
        // operation (or empty values allowed on non-ntds ldap server?)
        //

        pLdapObjectArray->pLdapObjects = NULL;
        pLdapObjectArray->dwCount = 0;
        *pdwSyntaxId = LDAPTYPE_UNKNOWN;
        //hr = E_FAIL;
    }

error:

   RRETURN(hr);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // - allow current index to go from within range to out of range by 1
    // - by 1 since initial state is out of range by 1
    //

    if ( newIndex > _dwMaxProperties )
        RRETURN_EXP_IF_ERR(E_FAIL);

    _dwCurrentIndex = newIndex;
    RRETURN(S_OK);

}

HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    ADsAssert(pdwMaxProperties);    // function private -> use assertion

    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid())
       return(NULL);

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}


LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}



HRESULT
CPropertyCache::
LDAPUnMarshallPropertyAs(
    LPWSTR   pszServerPath,
    PADSLDP pLdapHandle,
    LDAPMessage *ldapmsg,
    LPWSTR szPropertyName,
    DWORD dwSyntaxId,
    BOOL     fExplicit,
    CCredentials& Credentials
    )
{
    int nNumberOfEntries = 0L;
    int nNumberOfValues = 0L;
    HRESULT hr = S_OK;
    DWORD i = 0;
    LDAPMessage *entry;
    LPWSTR pszAttrName = NULL;
    void *ptr;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    //
    // Compute the number of attributes in the
    // read buffer.
    //

    nNumberOfEntries = LdapCountEntries( pLdapHandle, ldapmsg );

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );

    BAIL_ON_FAILURE(hr);

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);

    while ( pszAttrName != NULL )
    {
        DWORD dwSyntax = LDAPTYPE_UNKNOWN;

        LPWSTR pszADsPath;
        hr = _pCoreADsObject->get_CoreADsPath(&pszADsPath);
        BAIL_ON_FAILURE(hr);

        hr = ADsObject(pszADsPath, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        //
        // unmarshall this property into the
        // property cache
        //
        hr = LdapGetSyntaxOfAttributeOnServer(
                 pszServerPath,
                 pszAttrName,
                 &dwSyntax,
                 Credentials,
                 pObjectInfo->PortNumber
                 );
        ADsFreeString(pszADsPath);

        if ( SUCCEEDED(hr) && (dwSyntax != LDAPTYPE_UNKNOWN))
        {
            if ( (!_wcsicmp(pszAttrName, L"ntSecurityDescriptor")) &&
                 (dwSyntax == LDAPTYPE_OCTETSTRING) )
            {
                dwSyntax = LDAPTYPE_SECURITY_DESCRIPTOR;
            }

            (VOID) unmarshallproperty(
                       pszAttrName,
                       pLdapHandle,
                       entry,
                       dwSyntax,
                       fExplicit
                       );
        }else {

            if (!_wcsicmp(pszAttrName, szPropertyName)) {

                (VOID) unmarshallproperty(
                           pszAttrName,
                           pLdapHandle,
                           entry,
                           dwSyntaxId,
                           fExplicit
                           );

            }


        }

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;

        //
        // If we cannot find the syntax, ignore the property and
        // continue with the next property
        //
        hr = S_OK;

        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );

        BAIL_ON_FAILURE(hr);

        FreeObjectInfo(pObjectInfo);

        memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    }

error:

    FreeObjectInfo(pObjectInfo);

    RRETURN_EXP_IF_ERR(hr);

}



HRESULT
CPropertyCache::
LDAPUnMarshallPropertiesAs(
    LPWSTR   pszServerPath,
    PADSLDP pLdapHandle,
    LDAPMessage *ldapmsg,
    DWORD dwSyntaxId,
    BOOL     fExplicit,
    CCredentials& Credentials
    )
{
    int nNumberOfEntries = 0L;
    int nNumberOfValues = 0L;
    HRESULT hr = S_OK;
    DWORD i = 0;
    LDAPMessage *entry;
    LPWSTR pszAttrName = NULL;
    void *ptr;

    //
    // Compute the number of attributes in the
    // read buffer.
    //

    nNumberOfEntries = LdapCountEntries( pLdapHandle, ldapmsg );

    if ( nNumberOfEntries == 0 )
        RRETURN(S_OK);

    hr = LdapFirstEntry( pLdapHandle, ldapmsg, &entry );

    BAIL_ON_FAILURE(hr);

    hr = LdapFirstAttribute( pLdapHandle, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);

    while ( pszAttrName != NULL )
    {
        (VOID) unmarshallproperty(
                   pszAttrName,
                   pLdapHandle,
                   entry,
                   dwSyntaxId,
                   fExplicit
                   );

        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;

        hr = LdapNextAttribute( pLdapHandle, entry, ptr, &pszAttrName );

        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      FreeADsStr(pThisProperty->szPropertyName);
      LdapTypeFreeLdapObjects( &(PROPERTY_LDAPOBJECTARRAY(pThisProperty)) );
      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      //
      // Need to reset the current index too just in case.
      //
      _dwCurrentIndex = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   FreeADsStr(pThisProperty->szPropertyName);
   LdapTypeFreeLdapObjects( &(PROPERTY_LDAPOBJECTARRAY(pThisProperty)) );
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);

   //
   // Reset the current index if necesary so we do not skip a property.
   //
   if (_dwCurrentIndex > dwIndex) {
       _dwCurrentIndex--;
   }
error:

   RRETURN_EXP_IF_ERR(hr);
}

//
// For dynamic dispid's.
//

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::locateproperty
//
//  Synopsis:   Finds a property in the cache by name.
//
//  This differs from findproperty() in return code; this returns no ADSI
//  errors, since it's going to a VB interface.
//
//  If the property is not found in the cache, this uses the IDirectoryObject
//  interface of the containing object to get the attributes of the object.
//  If GetObjectAttributes doesn't return any information about the property,
//  this method returns DISP_E_UNKNOWNNAME.
//
//  Arguments:  [szPropertyName]        -- Name of the property.
//              [pdwIndex]              -- Index in the array of properties.
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::locateproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )
{
    HRESULT hr = findproperty(szPropertyName, pdwIndex);

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        DWORD dwLdapSyntaxId = 0;
        PPROPERTY pProperty = NULL;

        hr = _pGetAttributeSyntax->GetAttributeSyntax(
            szPropertyName,
            &dwLdapSyntaxId
            );
        BAIL_ON_FAILURE(hr);

        hr = addproperty(szPropertyName);
        BAIL_ON_FAILURE(hr);

        hr = findproperty(szPropertyName, pdwIndex);
        BAIL_ON_FAILURE(hr);

        pProperty = _pProperties + *pdwIndex;
        PROPERTY_SYNTAX(pProperty) = dwLdapSyntaxId;
        PROPERTY_FLAGS(pProperty) = PROPERTY_INIT;
        PROPERTY_LDAPOBJECTARRAY(pProperty).dwCount = 0;
        PROPERTY_LDAPOBJECTARRAY(pProperty).pLdapObjects = NULL;
    }

error:
    //
    // Automation return code would be DISP_E_UNKNOWNNAME.
    // ADSI return code would be E_ADS_PROPERTY_NOT_FOUND (like findproperty.)
    //
    if (FAILED(hr))
        hr = E_ADS_PROPERTY_NOT_FOUND;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:   Get the values of a property from the cache.
//              The values are returned as a VARIANT.
//
//  Arguments:  [dwIndex]               -- Index of property to retrieve
//              [pVarResult]            -- Data returned as a VARIANT
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::getproperty(
    DWORD dwIndex,
    PDWORD dwStatusFlag,
    VARIANT *pVarResult,
    CCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY LdapObjectArray;

    LDAPOBJECTARRAY_INIT(LdapObjectArray);

    //
    // This should not return E_ADS_PROPERTY_NOT_FOUND in this case.
    // We have an index, which should indicate that we have an array entry.
    // If we weren't dealing with VB, I'd be tempted to make this an Assert.
    //
    if (!index_valid(dwIndex))
        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

    if (INDEX_EMPTY(dwIndex) && 
        !PROP_DELETED(dwIndex) && 
        !_fGetInfoDone)
    {
        hr = _pCoreADsObject->GetInfo(FALSE);

        // workaround to avoid confusing callers of getproperty.
        if (hr == E_NOTIMPL)
            hr = DISP_E_MEMBERNOTFOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = unboundgetproperty(
             dwIndex,
             &dwSyntaxId,
             dwStatusFlag,
             &LdapObjectArray
             );

    // For backward compatibility
    if (!LdapObjectArray.pLdapObjects && SUCCEEDED(hr)) {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        if (LdapObjectArray.dwCount == 1) {
            hr = LdapTypeToVarTypeCopy(
                NULL,
                Credentials,
                LdapObjectArray.pLdapObjects,
                dwSyntaxId,
                pVarResult);
        }
        else {
            hr = LdapTypeToVarTypeCopyConstruct(
                NULL,
                Credentials,
                LdapObjectArray,
                dwSyntaxId,
                pVarResult);
        }
    }
    else
    {
        //
        // unboundgetproperty() returns E_FAIL on failure.
        // But getproperty() should return E_ADS_PROPERTY_NOT_FOUND.
        //
        if (hr == E_FAIL)
            hr = E_ADS_PROPERTY_NOT_FOUND;

        //
        // A proper Automation return value would be
        //   hr = DISP_E_MEMBERNOTFOUND;
        //
        ADsAssert(pVarResult);
        V_VT(pVarResult) = VT_ERROR;
    }

error:
    LdapTypeFreeLdapObjects(&LdapObjectArray);

    RRETURN(hr);
}


//
//
// This is here just so that we can compile, no one should be
// calling this
//
//  - The comment above and within the function is INCORRECT.
//  - At present, this function is called and works with known bug.
//    This function should NOT be a wrap around of getproperty with
//    3 param. The [dwIndex] in this function should have a DIFFERENT
//    meaning than the index in the cache.
//  - Please LEAVE this for irenef to fix before beta2.
//

HRESULT
CPropertyCache::getproperty(
    DWORD dwIndex,
    VARIANT *pVarResult,
    CCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;

    // Ideally we need to get rid of this but this would mean that
    // we need to change the cdispmgr code and the IPropertyCache
    // interface.
    hr = getproperty(
             dwIndex,
             &dwStatus,
             pVarResult,
             Credentials
             );

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:   Updates a property in the property cache.
//              The property is specified by its index in the array of
//              properties (which is also its DISPID), and the new value
//              is given by a VARIANT.
//
//  Arguments:  [dwIndex]               -- Index of the property.
//              [varValue]              -- Value of the property.
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::putproperty(
    DWORD dwIndex,
    VARIANT vValue
    )
{
    HRESULT hr;
    LDAPOBJECTARRAY LdapObjectArray;
    DWORD dwLdapType;

    LDAPOBJECTARRAY_INIT(LdapObjectArray);

    VARIANT *pvValue = &vValue, *pvArray = NULL;
    DWORD dwNumValues = 1;

    //
    // This should not return E_ADS_PROPERTY_NOT_FOUND in this case.
    // We have an index, which should indicate that we have an array entry.
    // If we weren't dealing with VB, I'd be tempted to make this an Assert.
    //
    if (!index_valid(dwIndex))
        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);


    //
    // If we get a safe array of variants, convert it to a regular array
    // of variants, so we can pass the first one to GetLdapSyntaxFromVariant.
    // We assume that all the elements of the array are of the same type
    //
    if (V_VT(pvValue) == (VT_VARIANT|VT_ARRAY))
    {
        hr = ConvertSafeArrayToVariantArray(vValue, &pvArray, &dwNumValues);
        BAIL_ON_FAILURE(hr);
        pvValue = pvArray;
    }

    //
    // - dwLdapType in cache can be LDAPTYPE_UNKNOWN.
    // - for consistency btw this function and Put/PutEx, will
    //   get type from input VARIANT and overwrite existing type in
    //   cache if any
    //

    ADsAssert(_pCredentials);

    hr = GetLdapSyntaxFromVariant(
             pvValue,
             &dwLdapType,
             _pszServerName,
             (_pProperties+dwIndex)->szPropertyName,
             *_pCredentials,
             _dwPort
             );

    BAIL_ON_FAILURE(hr);

    hr = VarTypeToLdapTypeCopyConstruct(
        _pszServerName,
        *_pCredentials,
        dwLdapType,
        pvValue,
        dwNumValues,
        &LdapObjectArray
        );
    BAIL_ON_FAILURE(hr);

    hr = putproperty(dwIndex, PROPERTY_UPDATE, dwLdapType, LdapObjectArray);
    BAIL_ON_FAILURE(hr);

error:
    // if (hr == E_ADS_CANT_CONVERT_DATATYPE)
    //     hr = DISP_E_TYPEMISMATCH;

    LdapTypeFreeLdapObjects(&LdapObjectArray);

    if (pvArray) {

        for (DWORD i=0; i < dwNumValues; i++) {
            VariantClear(pvArray + i);
        }

        FreeADsMem(pvArray);
    }

    RRETURN(hr);
}


//
// This method is called by _pCoreADsObject->GetInfo().  It signifies
// exactly that the property cache has been filled with all the data
// the server has, i.e. that a GetInfo() has been done.  When this is
// set, further implicit calls to GetInfo are skipped.  This flag is
// cleared only by "flushpropertycache".
//
void
CPropertyCache::setGetInfoFlag()
{
    _fGetInfoDone = TRUE;
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
DispatchFindProperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;
    PDISPPROPERTY pThisDispProperty = NULL;

    for (i = 0; i < _dwDispMaxProperties; i++) {

        pThisDispProperty = _pDispProperties + i;

        if (!_wcsicmp(pThisDispProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }

    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);

}

//+---------------------------------------------------------------------------
// Function:   CPropertyCache::GetPropertyNames.
//
// Synopsis:   Gets a list of the names of the properties in this object.
//
// Arguments:  ppUmiPropVals    -   Contains the return value.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyCache::GetPropertyNames(
    UMI_PROPERTY_VALUES **ppUmiPropVals
    )
{
    HRESULT hr = S_OK;
    PUMI_PROPERTY_VALUES pUmiPropVals = NULL;
    PUMI_PROPERTY pUmiProps = NULL;
    PPROPERTY pNextProperty = NULL;
    DWORD dwCtr = 0;

    ADsAssert(ppUmiPropVals);

    //
    // Always have only 1 value.
    //
    pUmiPropVals = (PUMI_PROPERTY_VALUES) 
                       AllocADsMem(sizeof(UMI_PROPERTY_VALUES));
    if (!pUmiPropVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!_dwMaxProperties) {
        //
        // No properties, we need to special case this.
        //
        *ppUmiPropVals = pUmiPropVals;
        RRETURN(S_OK);
    }

    pUmiProps = (PUMI_PROPERTY) AllocADsMem(
                    _dwMaxProperties * sizeof(UMI_PROPERTY)
                    );

    if (!pUmiProps) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    
    for(dwCtr = 0; dwCtr < _dwMaxProperties; dwCtr++) {
        pNextProperty = _pProperties + dwCtr;

        pUmiProps[dwCtr].pszPropertyName =
            (LPWSTR) AllocADsStr(pNextProperty->szPropertyName);
        if(pUmiProps[dwCtr].pszPropertyName == NULL) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pUmiProps[dwCtr].uCount = 0;
        //
        // Put correct operation type
        //
        hr = ConvertLdapCodeToUmiPropCode(
                 pNextProperty->dwFlags,
                 pUmiProps[dwCtr].uOperationType
                 );
        //
        // Verify that this is the right thing to do.
        // 
        pUmiProps[dwCtr].uType = UMI_TYPE_NULL;
    }

    pUmiPropVals->uCount = _dwMaxProperties;
    pUmiPropVals->pPropArray = pUmiProps;

    *ppUmiPropVals = pUmiPropVals;

    RRETURN(S_OK);

error:

    if(pUmiProps != NULL) {
        for(dwCtr = 0; dwCtr < _dwMaxProperties; dwCtr++) {
            if(pUmiProps[dwCtr].pszPropertyName != NULL) {
                FreeADsStr(pUmiProps[dwCtr].pszPropertyName);
            }
        }
        FreeADsMem(pUmiProps);
    }

    if (pUmiProps) {
        FreeADsMem(pUmiPropVals);
    }

    RRETURN(hr);
}

HRESULT
CPropertyCache::
AddSavingEntry(
    LPWSTR propertyName
    )
{
    HRESULT hr = S_OK;
    PSAVINGENTRY tempEntry = NULL;
    BOOL fResult = FALSE;

    fResult = FindSavingEntry(propertyName);

    if(!fResult) {
    	tempEntry = new SAVINGENTRY;
        if(!tempEntry) {
            hr = E_OUTOFMEMORY;
    	    BAIL_ON_FAILURE(hr);
        }
    
        tempEntry->entryData = AllocADsStr(propertyName);
        if(!(tempEntry->entryData)) {
            hr = E_OUTOFMEMORY;
            delete tempEntry;
         	
            BAIL_ON_FAILURE(hr);
        }
    
        InsertTailList( &_ListSavingEntries, &tempEntry->ListEntry );
    }
    
error:

	return hr;	
    
}

BOOL
CPropertyCache::
FindSavingEntry(
    LPWSTR propertyName
    )
{
    PLIST_ENTRY listEntry = NULL;
    PSAVINGENTRY EntryInfo = NULL;
    BOOL fResult = FALSE;

    listEntry = _ListSavingEntries.Flink;
    while (listEntry != &_ListSavingEntries) {
        EntryInfo = CONTAINING_RECORD( listEntry, SAVINGENTRY, ListEntry );
        if (!_wcsicmp(EntryInfo->entryData, propertyName)) {
            fResult = TRUE;
            break;
        }

        listEntry = listEntry->Flink;
    }

    return fResult;

}

HRESULT
CPropertyCache::
DeleteSavingEntry()
{
    PLIST_ENTRY pEntry;
    PSAVINGENTRY EntryInfo;

    while (!IsListEmpty (&_ListSavingEntries)) {
        pEntry = RemoveHeadList (&_ListSavingEntries);
        EntryInfo = CONTAINING_RECORD (pEntry, SAVINGENTRY, ListEntry);

        if(EntryInfo->entryData) {
            FreeADsStr(EntryInfo->entryData);
            EntryInfo->entryData = NULL;
        }

        delete EntryInfo;
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cquerycf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cquerycf.hxx
//
//  Contents: Class factory for the LDAP Query Object.
//
//            CLDAPQueryCF::CreateInstance.
//
//  History:    03-29-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQueryCF::CreateInstance
//
// Synopsis:   Standard CreateInstance implementation.
//
// Arguments:  pUnkOuter     ---- standard outer IUnknown ptr.
//             iid           ---- interface requested.
//             ppv           ---- output ptr for created object.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUmiLDAPQueryCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CUmiLDAPQuery::CreateUmiLDAPQuery(iid, ppv);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       umisrch.cxx
//
//  Contents:   This file contains the query object for the LDAP provider.
//          IUmiQuery is the interface supported by this object. The 
//          properties on the interface property list of this object are
//          mapped to the preferences you can set for IDirectorySearch.
//
//  History:    03-27-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::CUmiLDAPQuery --- Constructor.
//
// Synopsis:   Standard constructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CUmiLDAPQuery::CUmiLDAPQuery():
    _pIntfPropMgr(NULL),
    _pszQueryText(NULL),
    _pszLanguage(NULL),
    _ulStatus(0)
{
}

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::~CUmiLDAPQuery --- Destructor.
//
// Synopsis:   Standard destructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CUmiLDAPQuery::~CUmiLDAPQuery()
{
    if (_pIntfPropMgr) {
        delete _pIntfPropMgr;
    }

    if (_pszQueryText) {
        FreeADsStr(_pszQueryText);
    }

    if (_pszLanguage) {
        FreeADsStr(_pszLanguage);
    }
}

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::CreateUmiLDAPQuery --- STATIC constructor.
//
// Synopsis:   Static constructor.
//
// Arguments:  riid          -  Interface needed on new object.
//             ppObj         -  Return ptr for newly created object.
//
// Returns:    S_OK on success or any suitable error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CUmiLDAPQuery::CreateUmiLDAPQuery(
    IID riid,
    void FAR* FAR* ppObj
    )
{
    HRESULT hr = S_OK;
    CUmiLDAPQuery *pQuery;
    CPropertyManager *pIntfPropMgr = NULL;

    if (!ppObj) {
        RRETURN(E_INVALIDARG);
    }

    pQuery = new CUmiLDAPQuery();
    if (!pQuery) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = CPropertyManager::CreatePropertyManager(
             (IUmiQuery *) pQuery,
             NULL, // IADs ptr
             NULL, // pCreds
             IntfPropsQuery,
             &pIntfPropMgr
             );
    BAIL_ON_FAILURE(hr);


    hr = pQuery->QueryInterface(riid, ppObj);
    BAIL_ON_FAILURE(hr)

    pQuery->Release();

    pQuery->_pIntfPropMgr = pIntfPropMgr;

    RRETURN(hr);

error :

    if (pQuery) {
        delete pQuery;
    }

    if (pIntfPropMgr) {
        delete pIntfPropMgr;
    }

    RRETURN(hr);
}

//
// IUnknown support - standard query interface method.
//
STDMETHODIMP
CUmiLDAPQuery::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown)){
        *ppv = (IUnknown FAR *) this;
    } 
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiBaseObject)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiQuery)) {
        *ppv = (IUmiQuery FAR *) this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return NOERROR;
}

//
// IUmiQuery methods.
//

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::Set --- IUmiQuery support.
//
// Synopsis:   Sets the query string and language.
//
// Arguments:  pszLanguage   -  Language used to specify the query,
//                              only LDAP and SQL/WQL are supported.
//             uFlags        -  Flags, only 0 is allowed now.
//             pszText       -  Query text.
//
// Returns:    N/A.
//
// Modifies:   Internal query and language strings.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUmiLDAPQuery::Set(
    IN LPCWSTR pszLanguage,
    IN ULONG uFlags,
    IN LPCWSTR pszText
    )
{
    HRESULT hr = S_OK;

    SetLastStatus(0);
    //
    // Validate params
    //
    if (!pszLanguage || !pszText) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    if (_wcsicmp(pszLanguage, L"LDAP")
        && _wcsicmp(pszLanguage, L"SQL")
        && _wcsicmp(pszLanguage, L"WQL")
        ) {
        //
        // We do not support this language.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Free exisitng stuff if needed.
    //
    if (_pszLanguage) {
        FreeADsStr(_pszLanguage);
        _pszLanguage = NULL;
    }

    if (_pszQueryText) {
        FreeADsStr(_pszQueryText);
    }

    _pszLanguage = AllocADsStr(pszLanguage);
    if (!_pszLanguage) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    _pszQueryText = AllocADsStr(pszText);
    if (!_pszQueryText) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::GetQuery --- IUmiQuery support.
//
// Synopsis:   Returns the query language and text in the user allocated
//          buffers provided.
//
// Arguments:  puLangBufSize     -  Size of buffer for language string.
//             pszLangBuf        -  The actual buffer.
//             puQyeryTextBufSiz -  Size of buffer for queyr text.
//             pszQueryTextBuf   -  Buffer for query text. 
//
// Returns:    S_OK on success or any appropriate error code.
//
// Modifies: pszLangBuf and pszQueryText on success. On failure, 
//          * puLangBufSize and *puQueryTextBufSize are updated with
//          the length of the buffers needed (length in bytes).
//
//----------------------------------------------------------------------------    
STDMETHODIMP 
CUmiLDAPQuery::GetQuery(
    IN OUT ULONG * puLangBufSize,
    IN OUT LPWSTR pszLangBuf,
    IN OUT ULONG * puQueryTextBufSize,
    IN OUT LPWSTR pszQueryTextBuf
        )
{
    HRESULT hr = S_OK;

    SetLastStatus(0);

    if (!_pszLanguage || !_pszQueryText) {
        BAIL_ON_FAILURE(hr = UMI_E_NOT_FOUND);
    }

    if (!puLangBufSize || !puQueryTextBufSize) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if ((*puLangBufSize < ((wcslen(_pszLanguage) + 1) * sizeof(WCHAR)))
        || *puQueryTextBufSize < ((wcslen(_pszQueryText) + 1) * sizeof(WCHAR))
        ) {
        //
        // We really need an insufficient buffer error for this.
        //
        *puLangBufSize = (wcslen(_pszLanguage) + 1) * sizeof(WCHAR);
        *puQueryTextBufSize = (wcslen(_pszQueryText) + 1) * sizeof(WCHAR);
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY);
    }

    //
    // We have enough space in the provided buffers.
    //
    wcscpy(pszLangBuf, _pszLanguage);
    wcscpy(pszQueryTextBuf, _pszQueryText);

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//
// IUmiBaseObject methods.
//

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::GetLastStatus (IUmiBaseObject method).
//
// Synopsis:   Returns only numeric status code from the last operation.
//
// Arguments:  uFlags           -  Only 0 is supported for now.
//             puSpecificStatus -  Returns status/error code.
//             riid             -  Not used.
//             pStatusObj       -  NULL, not used currently.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *puSpecificStatus to return appropriate status code.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiLDAPQuery::GetLastStatus(
    IN  ULONG uFlags,
    OUT ULONG *puSpecificStatus,
    IN  REFIID riid,
    OUT LPVOID *pStatusObj
    )
{
    if (uFlags != 0) {
       RRETURN(UMI_E_INVALID_FLAGS);
    }

    if (!puSpecificStatus) {
        RRETURN(E_INVALIDARG);
    }

    if (pStatusObj) {
        //
        // Should we error out ?
        //
        *pStatusObj = NULL;
    }

    *puSpecificStatus = _ulStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//+---------------------------------------------------------------------------
// Function:   CUmiLDAPQuery::GetInterfacePropList (IUmiBaseObject method).
//
// Synopsis:   Returns a pointer to the interface property list for
//          cursor object.
//
// Arguments:  uFlags      -  Flags, only 0 is supported.
//             ppPropList  -  Return value.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList changed to IUmiPropList pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiLDAPQuery::GetInterfacePropList(
    IN  ULONG uFlags,
    OUT IUmiPropList **pPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if (uFlags != 0) {
        SetLastStatus(hr);
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    //
    // QI will check for bad pointer so no need to check here.
    //
    hr = _pIntfPropMgr->QueryInterface(IID_IUmiPropList, (void **)pPropList);

    if (FAILED(hr)) {
        SetLastStatus(hr);
    }

    RRETURN(hr);
}

//
// Private/Protected Methods.
//

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::SetLastStatus (internal private helper routine).
//
// Synopsis:   Sets the status of the last operation. If the status is one
//             of the pre-defined error codes, then the status is just set to
//             0 since we are not adding any value by returning the same
//             status as the error code.
//
// Arguments:  ulStatus      -   Status to be set.
//
// Returns:    Nothing
//
// Modifies:   Internal member status variable.
//
//----------------------------------------------------------------------------
void
CUmiLDAPQuery::SetLastStatus(ULONG ulStatus)
{
    this->_ulStatus = ulStatus;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cprovcf.cxx
//
//  Contents:  LDAP Provider Object Class Factory Code
//
//             CLDAPProviderCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CLDAPProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CLDAPProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cpropmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cpropmgr.cxx
//
//  Contents: Property manager - object that implements/helps implement 
//        IUMIPropList functions.
//        The property manager needs to be initialized in one of 2 modes
//        1) PropertyCache mode in which case it uses the objects existing
//       to provide IUMIPropList support and
//        2) Interface property mode in which case ???    
//
//  Functions: TBD.
//
//  History:    02-07-00    AjayR  Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"


//
// These are global utility fucntions. Might be worth moving to a
// better location subsequently.
//

//+---------------------------------------------------------------------------
// Function:   FreeOneUmiProperty -- Global scope.
//
// Synopsis:   Walk through and free all information being pointed to
//          including the values.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT FreeOneUmiProperty(UMI_PROPERTY umiProperty)
{
    //
    // Free the name now if we can
    //
    if (umiProperty.pszPropertyName) {
        FreeADsStr(umiProperty.pszPropertyName);
        umiProperty.pszPropertyName = NULL;
    }

    if (!umiProperty.pUmiValue) {
        //
        // We are done if count is 0
        //
        if (umiProperty.uCount == 0) {
            RRETURN(S_OK);
        }
        else {
            RRETURN(E_ADS_BAD_PARAMETER);
        }
    }

    //
    // Must have valid umiValues at this point.
    //
    for (ULONG ulCtr = 0; ulCtr < umiProperty.uCount; ulCtr++) {

        switch (umiProperty.uType) {

        case  UMI_TYPE_LPWSTR:
            //
            // Go through and free each of the values.
            //
            if (umiProperty.pUmiValue->pszStrValue[ulCtr]) {
                FreeADsStr(umiProperty.pUmiValue->pszStrValue[ulCtr]);
                umiProperty.pUmiValue->pszStrValue[ulCtr] = NULL;
            }
            break;

        case UMI_TYPE_BOOL:
        case UMI_TYPE_I4:
        case UMI_TYPE_FILETIME:
        case UMI_TYPE_SYSTEMTIME:
        case UMI_TYPE_I8:
            //
            // In all these cases nothing much to free except the value array
            //
            break;

        case UMI_TYPE_OCTETSTRING:
            //
            // Go through and free each of the values.
            //
            if (umiProperty.pUmiValue->octetStr[ulCtr].lpValue) {
                FreeADsMem(umiProperty.pUmiValue->octetStr[ulCtr].lpValue);
                umiProperty.pUmiValue->octetStr[ulCtr].lpValue = NULL;
            }
            break;

        case UMI_TYPE_IUNKNOWN:
            //
            // Need to release the ptr and Free the riid.
            //
            UMI_COM_OBJECT ComObject;

            if (umiProperty.pUmiValue->comObject) {
                ComObject = umiProperty.pUmiValue->comObject[ulCtr];
                
                if (ComObject.pInterface) {
                    ((IUnknown*)ComObject.pInterface)->Release();
                    ComObject.pInterface = NULL;
                }

                if (ComObject.priid) {
                    FreeADsMem((void *)ComObject.priid);
                    ComObject.priid = NULL;
                }
            }

            break;

        default:
            //
            // UmiType that we do not know anything about ??
            //
            ADsAssert(!"Unknown umitype in free memory");
            RRETURN(E_ADS_BAD_PARAMETER);
            break;
        } // end of case
    } // end of for

    //
    // Free the array of values now
    //
    if (umiProperty.pUmiValue) {
        FreeADsMem( (void *)umiProperty.pUmiValue);
        umiProperty.pUmiValue = NULL;
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   FreeUmiPropertyValues -- Global scope.
//
// Synopsis:   Walk through and free all information being pointed to
//          including the values.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT FreeUmiPropertyValues(UMI_PROPERTY_VALUES *pUmiProps)
{
    HRESULT hr = S_OK;

    if (pUmiProps) {
        __try {
    
            //
            // Go through and free each property in the list
            //  
            for (ULONG ulCtr = 0; ulCtr < pUmiProps->uCount; ulCtr++) {

                hr = FreeOneUmiProperty(pUmiProps->pPropArray[ulCtr]);

            }

            //
            // Free the inner array.
            //
            if (pUmiProps->pPropArray) {
                FreeADsMem(pUmiProps->pPropArray);
            }

            //
            // Free the array itself.
            //
            FreeADsMem( (LPVOID) pUmiProps);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = E_INVALIDARG;
        }
    } 
    else {
        hr = E_INVALIDARG;
    }



    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertUmiPropCodeToLdapCode -- Global scope.
//
// Synopsis:   Convert the property code appropriately.
//
// Arguments:  umiFlags        -   the umiPropCode,
//             dwLdapOpCode&   -  byRef return value.
//
// Returns:    HRESULT - S_OK or E_ADS_BAD_PARAMETER
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT ConvertUmiPropCodeToLdapCode(ULONG umiFlags, DWORD& dwLdapOpCode)
{
    HRESULT hr = S_OK;

    switch (umiFlags) {
    
    case UMI_OPERATION_APPEND:
        dwLdapOpCode = PROPERTY_ADD;
        break;
    
    case UMI_OPERATION_UPDATE:
        dwLdapOpCode = PROPERTY_UPDATE;
        break;

    case UMI_OPERATION_EMPTY:
        dwLdapOpCode = PROPERTY_DELETE;
        break;
    
    case UMI_OPERATION_DELETE_ALL_MATCHES:
        dwLdapOpCode = PROPERTY_DELETE_VALUE;
        break;

    default:
        //
        // we do not handle these values.
        // UMI_OPERATION_INSERT_AT
        // UMI_OPERATION_REMOVE_AT
        // UMI_OPERATION_DELETE_AT
        // UMI_OPERATION_DELETE_FIRST_MATCH
        // UMI_OPERATION_DELETE_ALL_MATCHES
        //
        hr = UMI_E_UNSUPPORTED_OPERATION;
        break;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertLdapCodeToUmiPropCode -- Global scope.
//
// Synopsis:   Convert the property code appropriately.
//
// Arguments:  dwLdapOpCode&   -  property cache operation code.
//             umiFlags&       -  byRef return value.
//
// Returns:    HRESULT - S_OK or E_ADS_BAD_PARAMETER
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT 
ConvertLdapCodeToUmiPropCode(
    DWORD dwLdapCode,
    ULONG &uUmiFlags
    )
{

    HRESULT hr = S_OK;

    switch (dwLdapCode) {
    
    case PROPERTY_ADD:
        uUmiFlags = UMI_OPERATION_APPEND;
        break;
    
    case PROPERTY_UPDATE: 
        uUmiFlags = UMI_OPERATION_UPDATE;
        break;

    case PROPERTY_DELETE:
        uUmiFlags = UMI_OPERATION_EMPTY;
        break;
    
    case PROPERTY_DELETE_VALUE:
        uUmiFlags = UMI_OPERATION_DELETE_ALL_MATCHES;
        break;

     
    case 0:
        //
        // special case values that are just in the cache.
        //
        uUmiFlags = 0;
        break;

    default:
        hr = E_ADS_BAD_PARAMETER;
        break;
    }

    RRETURN(hr);
}

//****************************************************************************
//
//Internal helpers - restricted scope 
//
//****************************************************************************

//+---------------------------------------------------------------------------
// Function:   ConvertVariantLongToUmiProp.
//
// Synopsis:   Convert the variant to a corresponding UmiProp.
//
// Arguments:  vVariant        -  variant containg long val to convert.
//             ppProp          -  Output UmiPropertyValues.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pProp to point to valid UMI_PROPERTY_VALUES.
//
//----------------------------------------------------------------------------
HRESULT
ConvertVariantLongToUmiProp(
    VARIANT vVariant,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    LONG *pLArray = NULL;

    *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*ppProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->pPropArray = 
        (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!((*ppProp)->pPropArray)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->uCount = 1;

    (*ppProp)->pPropArray[0].uType = UMI_TYPE_I4;
    (*ppProp)->pPropArray[0].uCount = 1;
    pLArray = (LONG *) AllocADsMem(sizeof(LONG) * 1);

    if (!pLArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pLArray[0] = vVariant.lVal;
    

    (*ppProp)->pPropArray[0].pUmiValue = (UMI_VALUE *)(void *)pLArray;

error :

    if (FAILED(hr)) {
        if (pLArray) {
            FreeADsMem( (void*) pLArray);
        }
        FreeUmiPropertyValues(*ppProp);
    }

    RRETURN(hr);
}

HRESULT
GetEmptyLPWSTRProp(UMI_PROPERTY_VALUES **ppProp)
{
    HRESULT hr = S_OK;
    
    *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*ppProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->pPropArray = 
        (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!((*ppProp)->pPropArray)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->uCount = 1;
    

    (*ppProp)->pPropArray[0].uType = UMI_TYPE_LPWSTR;
    (*ppProp)->pPropArray[0].uCount = 0;
    
    (*ppProp)->pPropArray[0].pUmiValue = NULL;


error :

    if (FAILED(hr)) {
        FreeUmiPropertyValues(*ppProp);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   ConvertBSTRToUmiProp.
//
// Synopsis:   Convert the bstr to a corresponding UmiProp.
//
// Arguments:  bstrStringVal   -  String to convert to umi values.
//             ppProp          -  Output UmiPropertyValues.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pProp to point to valid UMI_PROPERTY_VALUES.
//
//----------------------------------------------------------------------------
HRESULT
ConvertBSTRToUmiProp(
    BSTR bstrStringVal,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    LPWSTR * pszStrArray = NULL;
    LPWSTR pszTmpStr = NULL;

    *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*ppProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->pPropArray = 
        (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!((*ppProp)->pPropArray)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    
    (*ppProp)->uCount = 1;

    (*ppProp)->pPropArray[0].uType = UMI_TYPE_LPWSTR;
    (*ppProp)->pPropArray[0].uCount = 1;
    pszStrArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * 1);

    if (!pszStrArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // If the value is NULL, then we return an array with a NULL
    // value as the result.
    //
    if (bstrStringVal) {
        pszStrArray[0] = AllocADsStr(bstrStringVal);
    
        if (!pszStrArray[0]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    (*ppProp)->pPropArray[0].pUmiValue = (UMI_VALUE *)(void *)pszStrArray;

error :

    if (FAILED(hr)) {
        if (pszStrArray) {
            FreeADsMem( (void*) pszStrArray);
        }
        FreeUmiPropertyValues(*ppProp);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertIUnkToUmiProp.
//
// Synopsis:   Convert the IUnk to a corresponding UmiProp.
//
// Arguments:  pUnk            -  IUnk ptr.
//             iid             -  iid of the ptr.
//             ppProp          -  Output UmiPropertyValues.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pProp to point to valid UMI_PROPERTY_VALUES.
//
//----------------------------------------------------------------------------
HRESULT
ConvertIUnkToUmiProp(
    IUnknown * pUnk,
    IID iid,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    PUMI_COM_OBJECT pComObjArray = NULL;

    *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*ppProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppProp)->pPropArray = 
        (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!((*ppProp)->pPropArray)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    
    (*ppProp)->uCount = 1;

    (*ppProp)->pPropArray[0].uType = UMI_TYPE_IUNKNOWN;
    (*ppProp)->pPropArray[0].uCount = 1;
    pComObjArray = (PUMI_COM_OBJECT) AllocADsMem(sizeof(UMI_COM_OBJECT) * 1);

    if (!pComObjArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = pUnk->QueryInterface(
                   iid,
                   (void **) &(pComObjArray[0].pInterface)
                   );
    BAIL_ON_FAILURE(hr);

    pComObjArray[0].priid = (IID *) AllocADsMem(sizeof(IID));
    if (!pComObjArray[0].priid) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pComObjArray[0].priid, &iid, sizeof(IID));

    (*ppProp)->pPropArray[0].pUmiValue = (UMI_VALUE *)(void *)pComObjArray;

error :

    if (FAILED(hr)) {
        if (pComObjArray) {
            if (pComObjArray[0].pInterface) {
                ((IUnknown *)pComObjArray[0].pInterface)->Release();
            }
            FreeADsMem( (void*) pComObjArray);
        }
        FreeUmiPropertyValues(*ppProp);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetUmiRelUrl.
//
// Synopsis:   Gets the __RELURL property for the object. This routine
//          combines the IADs::get_Name and IADs::get_Class
//
// Arguments:  pIADs        -  Pointer to obj implementing IADs.
//             bstrRetVal   -  Pointer for retrun bstr value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pProp to point to valid UMI_PROPERTY_VALUES.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetUmiRelUrl(
    IADs * pIADs,
    BSTR * bstrRetVal
    )
{
    HRESULT hr = S_OK;
    BSTR bstrName = NULL, bstrClass = NULL;
    LPWSTR pszTempVal = NULL;
    BOOL fSchemaObject = FALSE;

    hr = pIADs->get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    hr = pIADs->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    //
    // See if this is a schema object.
    //
    if (!_wcsicmp(bstrClass, L"Schema")
        || !_wcsicmp(bstrClass, L"Class")
        || !_wcsicmp(bstrClass, L"Property")
        )
         {
        LPWSTR pszTemp;
        //
        // If this is indeed a schema object then the name
        // wont have any = sign in it. Equal is not allowed
        // in the names of schema objects.
        //
        if ((pszTemp = wcschr(bstrName, L'=')) == NULL)
        fSchemaObject = TRUE;
    }

    //
    // Add 2 as we need 1 for the \0 and the other for the . 
    // in class.name
    //
    DWORD dwLen;
    dwLen = wcslen(bstrName) + wcslen(bstrClass) + 2;

    if (fSchemaObject) {
        //
        // Need to add space for .Name
        //
        dwLen = dwLen + 6;

    }

    pszTempVal = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));

    if (!pszTempVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!fSchemaObject) {
        wsprintf(pszTempVal, L"%s.%s", bstrClass, bstrName);
    } 
    else {
        wsprintf(pszTempVal, L"%s.Name=%s", bstrClass, bstrName);
    }

    hr = ADsAllocString(pszTempVal, bstrRetVal);

    BAIL_ON_FAILURE(hr);

error:

    if (bstrName) {
        SysFreeString(bstrName);
    }

    if (bstrClass) {
        SysFreeString(bstrClass);
    }

    if (pszTempVal) {
        FreeADsStr(pszTempVal);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetUmiSchemaContainerPath.
//
// Synopsis:   Gets the Umi path to the schema container for this object.
//
// Arguments:  pIADs        -  Pointer to obj implementing IADs.
//             bstrRetVal   -  Pointer for retrun bstr value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *bstrRetVal points to the correct schema path.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetUmiSchemaContainerPath(
    IADs * pIADs,
    BSTR * bstrRetVal
    )
{
    HRESULT hr = S_OK;
    BSTR bstrSchema = NULL;
    LPWSTR pszParent = NULL, pszCN = NULL, pszUmiSchema = NULL;

    //
    // First we need the path of the schema object itslef.
    //
    hr = pIADs->get_Schema(&bstrSchema);
    BAIL_ON_FAILURE(hr);

    //
    // Now we can build the path to the schema container from the path.
    //
    hr = BuildADsParentPath(
             bstrSchema,
             &pszParent,
             &pszCN
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsPathToUmiURL(pszParent, &pszUmiSchema);

    BAIL_ON_FAILURE(hr);
           
    hr = ADsAllocString(pszUmiSchema, bstrRetVal);

    BAIL_ON_FAILURE(hr);

error:

    if (bstrSchema) {
        SysFreeString(bstrSchema);
    }

    if (pszCN) {
        FreeADsStr(pszCN);
    }

    if (pszParent) {
        FreeADsStr(pszParent);
    }

    if (pszUmiSchema) {
        FreeADsStr(pszUmiSchema);
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetUmiDerivedFrom.
//
// Synopsis:   Gets the value of the class that the current class object
//          is derived from.
//
// Arguments:  pIADs        -  Pointer to obj implementing IADs.
//             bstrRetVal   -  Pointer for retrun bstr value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *bstrRetVal points to the correct schema path.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetUmiDerivedFrom(
    IADs * pIADs,
    BSTR * pbstrRetVal
    )
{
    HRESULT hr = S_OK;
    IADsClass *pClass = NULL;
    BSTR bstrName = NULL;
    VARIANT vVariant;

    VariantInit(&vVariant);
    *pbstrRetVal = NULL;

    hr = pIADs->get_Name(&bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // If the class is Top then we just return NULL.
    //
    if (_wcsicmp(bstrName, L"Top")) {
        //
        // Get the IADsClass interface, this is done because IADs::Get
        // will need to ask for different attributes based on the server.
        // IADsClass encapsulates this difference for us.
        //
        hr = pIADs->QueryInterface(IID_IADsClass, (void **) &pClass);
        if (FAILED(hr)) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    
        hr = pClass->get_DerivedFrom(&vVariant);
        BAIL_ON_FAILURE(hr);
    
        ADsAssert(vVariant.vt == VT_BSTR);
        hr = ADsAllocString(vVariant.bstrVal, pbstrRetVal);
    }
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vVariant);

    if (bstrName) {
        SysFreeString(bstrName);
    }

    if (pClass) {
        pClass->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperConvertNameToKey.
//
// Synopsis:   Converts the value of the BSTR (of the form cn=test) to cn
//          as required by UMI.
//
// Arguments:  bstrName     -  Value to get the key from.
//             pszUmiKey    -  Return value for the key.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *pszUmiUrl points to the key.
//
//----------------------------------------------------------------------------
HRESULT
HelperConvertNameToKey(
    BSTR bstrName,
    LPWSTR * pszUmiUrl
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTemp = bstrName;
    BOOL fEqualFound = FALSE;
    DWORD dwCount = 0;

    ADsAssert(bstrName && pszTemp && *pszTemp);

    while (pszTemp 
           && *pszTemp
           && (!fEqualFound)
           ) {
        if (*pszTemp == L'=') {
            fEqualFound = TRUE;
        }
        dwCount++;
        pszTemp++;
    }

    if (!fEqualFound) {
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    *pszUmiUrl = (LPWSTR) AllocADsMem(dwCount * sizeof(WCHAR));
    if (!*pszUmiUrl) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wcsncpy(*pszUmiUrl, bstrName, (dwCount-1));

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperUpdateSDFlags.
//
// Synopsis:   On put/get calls updates the security flags appropriately.
//
// Arguments:  pIADs       -  IADs pointer to use to update sd.
//             uFlags      -  Flags to use for getting SD.
//             pfUpdated   -  Return boolean value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   Underlying property cache and pfUpdated to TRUE if the
//          flags on the object had to be changed and FALSE otherwise.
//
//----------------------------------------------------------------------------
HRESULT
HelperUpdateSDFlags(
    IADs *pIADs,
    ULONG uFlags,
    BOOL *pfUpdated = NULL
    )
{
    HRESULT hr = S_OK;
    IADsObjOptPrivate *pPrivOpt = NULL;
    SECURITY_INFORMATION secInfo;

    ADsAssert(pIADs);

    if (pfUpdated) {
        *pfUpdated = FALSE;
    }

    //
    // Get the objOpt intf and make sure the flags are right.
    //
    hr = pIADs->QueryInterface(IID_IADsObjOptPrivate, (void **) &pPrivOpt);
    BAIL_ON_FAILURE(hr);

    hr = pPrivOpt->GetOption(
             LDAP_SECURITY_MASK,
             (void *) &secInfo
             );
    BAIL_ON_FAILURE(hr);

    if (secInfo != uFlags) {
        //
        // We need to update the security mask on the object.
        //
        hr = pPrivOpt->SetOption(
                 LDAP_SECURITY_MASK,
                 (void **) &uFlags
                 );
        BAIL_ON_FAILURE(hr);
        //
        // Need to let caller know that the flags have changed.
        //
        if (pfUpdated) {
            *pfUpdated  = TRUE;
        }
    }

error:

    if (pPrivOpt) {
        pPrivOpt->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetSDIntoCache.
//
// Synopsis:   Reads the sd into the property cache using the appropriate
//          flags as needed.
//
// Arguments:  pIADs       -  IADs pointer to use to update sd.
//             uFlags      -  Flags to use for getting SD.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   Underlying property cache.
//
//----------------------------------------------------------------------------
HRESULT HelperGetSDIntoCache(
    IADs * pIADs,
    ULONG uFlags
    )
{
    HRESULT hr = S_OK;
    VARIANT vVar;
    BOOL fUpdated = FALSE;
    LPWSTR szSecDesc[] = {L"ntSecurityDescriptor"};

    VariantInit(&vVar);

    hr = HelperUpdateSDFlags(
             pIADs,
             (uFlags & UMI_SECURITY_MASK),
             &fUpdated
             );
    BAIL_ON_FAILURE(hr);

    if (fUpdated) {
        //  
        // Update just the SD by calling GetInfoEx.
        //
        hr = ADsBuildVarArrayStr(
                 szSecDesc,
                 1,
                 &vVar
                 );
        BAIL_ON_FAILURE(hr);

        hr = pIADs->GetInfoEx(vVar, 0);
        BAIL_ON_FAILURE(hr);
    }

error :

    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetOrigin.
//
// Synopsis:   Gets the originating class for the property in question.
//
// Arguments:  pIADs       -  IADs pointer to backing object.
//             pszName     -  Name of the property whose origin is needed.
//             ppProp      -  Return value.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetOrigin(
    IADs *pIADs,
    LPCWSTR pszName,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    IADsUmiHelperPrivate *pHelper = NULL;
    BSTR bstrVal = NULL;

    hr = pIADs->QueryInterface(
             IID_IADsUmiHelperPrivate,
             (void **) &pHelper
             );
    if (FAILED(hr)) {
        //
        // This object does not support this property as it is not
        // a class object.
        //
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    hr = pHelper->GetOriginHelper(
             pszName,
             &bstrVal
             );
    BAIL_ON_FAILURE(hr);

    hr = ConvertBSTRToUmiProp(
             bstrVal,
             ppProp
             );
error:
    if (bstrVal) {
        SysFreeString(bstrVal);
    }

    if (pHelper) {
        pHelper->Release();
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CopyUmiProperty.
//
// Synopsis:   Copy the input value into a newly allocated output buffer.
//          Note that since this is an internal routine assumptions are made
//          as to the data. Currently handles only UMI_TYPE_LPWSTR,
//          UMI_TYPE_I4 and UMI_TYPE_BOOL. If multivalued, we can only copy
//          strings (things like filter on enum can be multi-valued).
//
// Arguments:  umiProp         -  Umi property value to copy.
//             ppUmiProp       -  Return value for new umi property.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *ppUmiProp to point to valid UMI_PROPERTY.
//
//----------------------------------------------------------------------------
HRESULT
CopyUmiProperty(
    UMI_PROPERTY umiProp,
    PUMI_PROPERTY *ppUmiProp
    )
{
    HRESULT hr = S_OK;
    UMI_PROPERTY *pUmiPropLocal = NULL;
    ULONG ulUmiType = umiProp.uType;
    ULONG ulPropCount = umiProp.uCount;

    *ppUmiProp = NULL;

    //
    // Multi valued has to be string.
    //
    if ((ulPropCount > 1) && (ulUmiType != UMI_TYPE_LPWSTR)) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    pUmiPropLocal = (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!pUmiPropLocal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pUmiPropLocal->pszPropertyName = AllocADsStr(umiProp.pszPropertyName);
    
    if (!pUmiPropLocal->pszPropertyName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pUmiPropLocal->uOperationType = umiProp.uOperationType;
    pUmiPropLocal->uType = umiProp.uType;

    switch (umiProp.uType) {
    
    case UMI_TYPE_LPWSTR :
        LPWSTR *pszTmpArray;
        pszTmpArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * ulPropCount);
        
        if (!pszTmpArray) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (DWORD dwCtr = 0; dwCtr < ulPropCount; dwCtr++) {
            pszTmpArray[dwCtr] = AllocADsStr(
                umiProp.pUmiValue->pszStrValue[dwCtr]
                );
            
            if (!pszTmpArray[dwCtr]) {
                //
                // NULL is allowed as a value only if it is the
                // only value being set.
                //
                if (ulPropCount != 1
                    || umiProp.pUmiValue->pszStrValue[dwCtr] 
                    ) {
                    //
                    // Cleanup and exit.
                    //
                    for (DWORD dwCtr2 = 0; dwCtr2 < dwCtr; dwCtr2++) {
                        if (pszTmpArray[dwCtr2]) {
                            FreeADsStr(pszTmpArray[dwCtr2]);
                            pszTmpArray[dwCtr2] = NULL;
                        }
                    }
                    FreeADsMem(pszTmpArray);
                    pszTmpArray = NULL;
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
            } // if alloc failed in middle of array.
        }
        
        pUmiPropLocal->pUmiValue = (PUMI_VALUE) (void *) pszTmpArray;
        break;

    case UMI_TYPE_I4:
        LONG *pLongArray;

        pLongArray = (LONG *) AllocADsMem(sizeof(LONG) * 1);
        if (!pLongArray) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pLongArray[0] = umiProp.pUmiValue->lValue[0];
        pUmiPropLocal->pUmiValue = (PUMI_VALUE) (void *) pLongArray;
        break;

    case UMI_TYPE_BOOL:
        BOOL *pBoolArray;

        pBoolArray = (BOOL *) AllocADsMem(sizeof(BOOL) * 1);
        if (!pBoolArray) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pBoolArray[0] = umiProp.pUmiValue->bValue[0];
        pUmiPropLocal->pUmiValue = (PUMI_VALUE) (void *) pBoolArray;
        break;

    default:
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        break;

    }

    pUmiPropLocal->uCount = ulPropCount;
    *ppUmiProp = pUmiPropLocal;

    RRETURN(hr);

error:
    //
    // Cleanup cause we hit an error.
    //
    if (pUmiPropLocal) {
        FreeOneUmiProperty(*pUmiPropLocal);
        FreeADsMem( (void*) pUmiPropLocal);
    }

    RRETURN(hr);
}

//****************************************************************************
//
//CPropertyManager Methods.
//
//****************************************************************************

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::CPropertyManager
//
// Synopsis:   Constructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CPropertyManager::CPropertyManager():
    _dwMaxProperties(0),
    _pPropCache(NULL),
    _pIntfProperties(NULL),
    _dwMaxLimit(0),
    _fPropCacheMode(TRUE),
    _pStaticPropData(NULL),
    _ulStatus(0),
    _pIADs(NULL),
    _pUnk(NULL),
    _pCreds(NULL),
    _pszServerName(NULL)
{
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::~CPropertyManager
//
// Synopsis:   Destructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CPropertyManager::~CPropertyManager()
{
    //
    // Need to cleanup inftProps table
    // 
    if (_pIntfProperties) {
        DWORD dwCtr;
        for (dwCtr = 0; dwCtr < _dwMaxProperties; dwCtr++) {
            //
            // Free each of the entries and their contents.
            //
            PINTF_PROPERTY pIntfProp = &(_pIntfProperties[dwCtr]);

            if (pIntfProp->pszPropertyName) {
                FreeADsStr(pIntfProp->pszPropertyName);
                pIntfProp->pszPropertyName = NULL;
            }

            if (pIntfProp->pUmiProperty) {
                FreeOneUmiProperty(*(pIntfProp->pUmiProperty));
                FreeADsMem(pIntfProp->pUmiProperty);
                pIntfProp->pUmiProperty = NULL;
            }
        }
        FreeADsMem(_pIntfProperties);
    }

    _pIntfProperties = NULL;

    //
    // The rest of the stuff is taken care of when the
    // destructor to the IADs obj is called. This object
    // itself will be released only in the destructor of the
    // IADs object is called.
    //
    _pPropCache = NULL;
    
    if (_pIADs) {
        _pIADs->Release();
    } 

    _pIADs = NULL;
    _dwMaxProperties = 0;

    //
    // Do not free as these are owned by the owning object.
    //
    _pszServerName = NULL;
    _pCreds = NULL;
    _pUnk = NULL;

}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::CreatePropertyManager (overloaded)
//
// Synopsis:   Static allocation routine (property cache mode).
//
// Arguments:  IADs*             -  pointer to IADs implementor object.
//             pUnk              -  owning object unknown.
//             pPropCache        -  pointer to propertyCache used by object.
//             pCredentials      -  pointer to credentials.
//             pszServerName     -  pointer to servername.
//             ppPropertyManager -  return ptr for new prop mgr.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   CPropertyManager ** - ptr to newly created object.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::CreatePropertyManager(
    IADs *pADsObj,
    IUnknown *pUnk,
    CPropertyCache *pPropCache,
    CCredentials *pCredentials,
    LPWSTR pszServerName,
    CPropertyManager FAR * FAR * ppPropertyManager
    )
{
    CPropertyManager FAR * pPropMgr = NULL;

    pPropMgr = new CPropertyManager();

    if (!pPropMgr) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    if (pADsObj) {
        pADsObj->QueryInterface(IID_IADs, (void**) &(pPropMgr->_pIADs));
    }

    pPropMgr->_pUnk =  pUnk;
    pPropMgr->_pPropCache = pPropCache;
    pPropMgr->_fPropCacheMode = TRUE;
    pPropMgr->_pIntfProperties = NULL;
    pPropMgr->_pszServerName = pszServerName;
    pPropMgr->_pCreds = pCredentials;

    *ppPropertyManager = pPropMgr;

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::CreatePropertyManager (overloaded)
//
// Synopsis:   Static allocation routine (interface properties mode).
//
// Arguments:  pUnk              - pointer to owner (umi) object.
//             pIADs             - pointer to IADs implementor.
//             pCredentials      - pointer to credentials.
//             pTable            - property table.
//             ppPropertyManager - return value for new prop mgr.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   CPropertyManager ** - ptr to newly created object.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::CreatePropertyManager(
    IUnknown *pUnk,
    IUnknown *pIADs,
    CCredentials *pCredentials,
    INTF_PROP_DATA pTable[],
    CPropertyManager FAR * FAR * ppPropertyManager
    )
{
    CPropertyManager FAR * pPropMgr = NULL;

    pPropMgr = new CPropertyManager();

    if (!pPropMgr) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropMgr->_pUnk = pUnk;
    
    //
    // We can ignore any failures here.
    //
    if (pIADs) {
        pIADs->QueryInterface(IID_IADs, (void**) &(pPropMgr->_pIADs));
    }

    pPropMgr->_pPropCache = NULL;
    pPropMgr->_fPropCacheMode = FALSE;
    pPropMgr->_pIntfProperties = NULL;
    pPropMgr->_pCreds = pCredentials;
    pPropMgr->_pStaticPropData = pTable;

    *ppPropertyManager = pPropMgr;

    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyManager::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    HRESULT hr = S_OK;

    SetLastStatus(0);
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown)){
        *ppv = (IUnknown FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppv = (IUmiPropList FAR *) this;
    }
    else {
        *ppv = NULL;
        SetLastStatus(E_NOINTERFACE);
        return E_NOINTERFACE;
    }
    
    AddRef();
    return NOERROR;
}


//
// Methods defined on the proplist interface.
//

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::Put (IUmiPropList support).
//
// Synopsis:   Sets the value for the attribute in the cache.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   PropertyCache or internal interface property list.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::Put(
    IN LPCWSTR pszName,
    IN ULONG   uFlags,
    IN UMI_PROPERTY_VALUES *pProp
    )
{
    HRESULT hr = S_OK;
    LDAPOBJECTARRAY ldapDestObjects;
    DWORD dwOperationFlags = 0;
    BOOL fSecurityFlags = FALSE;
    IUmiObject *pUmiObj = NULL;
    BOOL fInternalPut = FALSE;

    SetLastStatus(0);

    //
    // Initialize so that we are not trying to free junk.
    //
    if (_fPropCacheMode) {
       LDAPOBJECTARRAY_INIT(ldapDestObjects);
    }

    //
    // Pre process and pull out the highest flag, all these
    // because we are not allowed to support Put with 0.
    //
    if (uFlags & 0x8000000) {
        uFlags &= 0x4000000;
        fInternalPut = TRUE;
    }

    if (uFlags > UMI_SECURITY_MASK) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }
    if (!pProp || !pszName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    if (uFlags & UMI_SECURITY_MASK) {
        fSecurityFlags = TRUE;
    }

    //
    // We support only putting one property at a time.
    //
    if (pProp->uCount != 1) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // Make sure that the data passed in is correct.
    //        
    if (!pProp->pPropArray
        || !pProp->pPropArray[0].pszPropertyName) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (_fPropCacheMode) {
        DWORD dwLdapSyntaxId = 1;

        if (fInternalPut
            && pProp->pPropArray[0].uOperationType == 0) {
            dwOperationFlags = 0;
        } 
        else {
            //
            // Verify that the operationType is something we support.
            //
            hr = ConvertUmiPropCodeToLdapCode(
                     pProp->pPropArray[0].uOperationType,
                     dwOperationFlags
                     );
            BAIL_ON_FAILURE(hr);
        }

        if (fSecurityFlags) {
            //
            // Only this ntSecurityDescriptor can use the security flags.
            //
            if (_wcsicmp(L"ntSecurityDescriptor", pszName)) {
                BAIL_ON_FAILURE(hr = E_FAIL);
            }
            hr = HelperUpdateSDFlags(
                     _pIADs,
                     uFlags & UMI_SECURITY_MASK
                     );
            BAIL_ON_FAILURE(hr);
        }

        //
        // In this case we need to convert data to ldap values and
        // store in cache.
        //
        hr = UmiTypeToLdapTypeCopy(
                 *pProp,
                 uFlags,
                 &ldapDestObjects,
                 dwLdapSyntaxId,  // byRef
                 _pCreds,
                 _pszServerName
                 );
        BAIL_ON_FAILURE(hr);

        //
        // PutpropertyExt will add to the cache if needed.
        //
        hr = _pPropCache->putpropertyext(
                 (LPWSTR)pszName,
                 dwOperationFlags,
                 dwLdapSyntaxId,
                 ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
               
    } 
    else {
        //
        // Local cache for interface properties. Verify property is 
        // legal and update the local information accordingly.
        //
        if (VerifyIfValidProperty(
                pProp->pPropArray[0].pszPropertyName,
                pProp->pPropArray[0]
                )
            ) {

            if (fSecurityFlags
                || !_wcsicmp(pszName, L"__SECURITY_DESCRIPTOR")
                ) {
                //
                // Make sure name is correct.
                //
                if (_wcsicmp(L"__SECURITY_DESCRIPTOR", pszName)) {
                    BAIL_ON_FAILURE(hr = E_FAIL);
                }
                //
                // We need turn around and call put on the owning object.
                // This means we need to package the UMI_PROPERTY_VALUES
                // accordingly.
                //
                UMI_PROPERTY pUmiProperty[] = {
                    pProp->pPropArray[0].uType,
                    pProp->pPropArray[0].uCount,
                    pProp->pPropArray[0].uOperationType,
                    L"ntSecurityDescriptor",
                    pProp->pPropArray[0].pUmiValue
                };

                UMI_PROPERTY_VALUES pUmiProp[] = {1, pUmiProperty};

                hr = _pUnk->QueryInterface(
                         IID_IUmiObject,
                         (void **) &pUmiObj
                         );
                BAIL_ON_FAILURE(hr);

                hr = pUmiObj->Put(
                         L"ntSecurityDescriptor",
                         uFlags,
                         pUmiProp
                         );
                BAIL_ON_FAILURE(hr);
            } 
            else {
                //
                // We need to update this value in our cache
                //
                hr = AddProperty(
                         pszName,
                         pProp->pPropArray[0]
                         );                
                BAIL_ON_FAILURE(hr);
            } 
        } // not valid property.
        else {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

error :

    //
    // Free ldapDestObjects if applicable.
    //
    if (_fPropCacheMode) {
        LdapTypeFreeLdapObjects( &ldapDestObjects );
    }

    if (pUmiObj) {
        pUmiObj->Release();
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::Get (IUmiPropList support).
//
// Synopsis:   Gets the value for the attribute. This will read data 
//        from the server as needed.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   UMI_PROPERTY_VALUES* has the values of the attribute.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::Get(
    IN  LPCWSTR pszName,
    IN  ULONG uFlags,
    OUT UMI_PROPERTY_VALUES **pProp
    )
{
    HRESULT hr = S_OK;
    ULONG uUmiFlag;
    LDAPOBJECTARRAY ldapSrcObjects;
    BOOL fSecurityFlag = FALSE;
    BOOL fSchemaFlag   = FALSE;
    IADsObjOptPrivate *pPrivOpt = NULL;

    SetLastStatus(0);

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    if (!pProp) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    *pProp = NULL;
    //
    // Currently this is the highest flag we support.
    //
    if (uFlags > UMI_FLAG_PROPERTY_ORIGIN) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    } 
    else if (uFlags & UMI_SECURITY_MASK) {
        fSecurityFlag = TRUE;
    }
    else if (uFlags == UMI_FLAG_PROPERTY_ORIGIN) {
        fSchemaFlag = TRUE;
    }

    if (fSchemaFlag && fSecurityFlag) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    //
    // Name cannot be NULL.
    //
    if (!pszName) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG)
    }

    //
    // If this is Property Manager is for server properties.
    //
    if (_fPropCacheMode) {

        DWORD dwSyntaxId;
        DWORD dwStatus;
        DWORD dwSecOptions;
    
        if (fSchemaFlag) {
            BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
        }
        
        if (fSecurityFlag) {
            if (_wcsicmp(L"ntSecurityDescriptor", pszName)) {
                //
                // Security flag used and attrib not securityDescriptor.
                //
                BAIL_ON_FAILURE(hr = E_FAIL);
            } 
            else {
                //
                // Valid flag we need to process the flags.
                //
                hr = HelperGetSDIntoCache(
                         _pIADs,
                         uFlags
                         );
                BAIL_ON_FAILURE(hr);
            }
        }
        
        //
        // Object maybe unbound, so we should return no such prop if
        // we get back E_ADS_OBJECT_UNBOUND.
        //
        hr = _pPropCache->getproperty(
                 (LPWSTR)pszName,
                 &dwSyntaxId,
                 &dwStatus,
                 &ldapSrcObjects
                 );
    
        if (hr == E_ADS_OBJECT_UNBOUND) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

        BAIL_ON_FAILURE(hr);

        hr = ConvertLdapCodeToUmiPropCode(dwStatus, uUmiFlag);
        BAIL_ON_FAILURE(hr);
    
        //
        // Return error if provider cache is not set and
        // the cache is dirty.
        //
        if (uUmiFlag && !(uFlags & UMI_FLAG_PROVIDER_CACHE)) {
            BAIL_ON_FAILURE(hr = UMI_E_SYNCHRONIZATION_REQUIRED);
        }

        //
        // At this point we might have ldapSrcObjects.pLdapObjects == NULL.
        // Typically that would be for property delete operations.
        //
        hr = LdapTypeToUmiTypeCopy(
                 ldapSrcObjects,
                 pProp,
                 dwStatus,
                 dwSyntaxId,
                 _pCreds,
                 _pszServerName,
                 uUmiFlag
                 );

    }
    else {
        //
        // Property Manager is for interface properties.
        //
        DWORD dwIndex;

        //
        // If the schema flag is set then we need to get the origin
        // and not the property itself.
        //
        if (fSchemaFlag) {
            hr = HelperGetOrigin(
                     _pIADs,
                     pszName,
                     pProp
                     );

        } 
        else {
            //
            // Make sure this property is valid.
            //
            hr = GetIndexInStaticTable(pszName, dwIndex); // dwIndex is byRef
            BAIL_ON_FAILURE(hr);

            hr = GetInterfaceProperty(
                     pszName,
                     uFlags,
                     pProp,
                     dwIndex
                     );
        }
    }

    BAIL_ON_FAILURE(hr);

    //
    // Stuff the name in the return value.
    //
    if (pProp && *pProp) {
        (*pProp)->pPropArray[0].pszPropertyName = AllocADsStr(pszName);

        if (!(*pProp)->pPropArray[0].pszPropertyName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

error:

    if (_fPropCacheMode) {
        LdapTypeFreeLdapObjects(&ldapSrcObjects);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);

        if (pProp && *pProp) {
            this->FreeMemory(0, (void *) *pProp);
            *pProp = NULL;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetAt (IUmiPropList support).
//
// Synopsis:   Used to get the value by index ???
//
// Arguments:  Not implemented
//
//
// Returns:    E_NOTIMPL
//
// Modifies:   Not implemented
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::GetAt(
    IN  LPCWSTR pszName,
    IN  ULONG   uFlags,
    IN  ULONG   uBufferLength,
    OUT LPVOID  pExisitingMem
    )
{
    SetLastStatus(E_NOTIMPL);
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetAs (IUmiPropList support).
//
// Synopsis:   Gets the value for the attribute in the specified format. 
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   UMI_PROPERTY_VALUES* has the values of the attribute.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::GetAs(
    IN     LPCWSTR pszName,
    IN     ULONG uFlags,
    IN     ULONG uCoercionType,
    IN OUT UMI_PROPERTY_VALUES **pProp
    )
{
    HRESULT hr = S_OK;
    LDAPOBJECTARRAY ldapSrcObjects;
    LDAPOBJECTARRAY ldapSrcObjectsTmp;
    LDAPOBJECTARRAY * pldapObjects = NULL;
    ULONG uUmiFlag;
    DWORD dwSyntaxId, dwStatus, dwRequestedSyntax;
    DWORD dwCachedSyntax, dwUserSyntax;


    SetLastStatus(0);

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);
    LDAPOBJECTARRAY_INIT(ldapSrcObjectsTmp);

    if (!pszName || !pProp) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Has to be in prop cache mode.
    //
    if (!_fPropCacheMode || !_pPropCache) {
        BAIL_ON_FAILURE(hr = E_NOTIMPL);
    }

    if (uFlags > UMI_SECURITY_MASK) {
        BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
    }

    if (uFlags & UMI_SECURITY_MASK) {
        //
        // Make sure it is the SD they are interested in.
        //
        if (_wcsicmp(L"ntSecurityDescriptor", pszName)) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }
        //
        // At this point we need to get the SD in the cache.
        //
        hr = HelperGetSDIntoCache(_pIADs, uFlags);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Object maybe unbound, so we should return no such prop if
    // we get back E_ADS_OBJECT_UNBOUND.
    //
    hr = _pPropCache->getproperty(
             (LPWSTR)pszName,
             &dwSyntaxId,
             &dwStatus,
             &ldapSrcObjects
             );

    if (hr == E_ADS_OBJECT_UNBOUND) {
        hr = E_ADS_PROPERTY_NOT_FOUND;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Get the appropriate umi code for the status.
    //
    hr = ConvertLdapCodeToUmiPropCode(dwStatus, uUmiFlag);
    BAIL_ON_FAILURE(hr);

    //
    // At this point we need to see if we can convert the data
    // to the format requested. This code is similar to that in
    // proplist.cxx GetPropertyItem but there appears to be no
    // easy way to avoid this duplication.
    //
    dwCachedSyntax = dwSyntaxId;

    //
    // Need to take the requested type to ADs types and from there to
    // ldap types.
    //
    hr = UmiTypeToLdapTypeEnum(uCoercionType, &dwUserSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // We can convert to any requested type only if it is unknown.
    //
    if (dwCachedSyntax == LDAPTYPE_UNKNOWN) {
        dwRequestedSyntax = dwUserSyntax;
    } 
    else if (dwCachedSyntax == dwUserSyntax) {
        //
        // Easy one !
        //
        dwRequestedSyntax = dwCachedSyntax;
    } 
    else {
        //
        // This means we already have a type. In this case the only
        // coercion we allows is SD to binary blob and vice-versa.
        //
        if ((dwCachedSyntax == LDAPTYPE_SECURITY_DESCRIPTOR)
            && (dwUserSyntax == LDAPTYPE_OCTETSTRING)
            ) {
            dwRequestedSyntax = dwUserSyntax;
        } 
        else if ((dwCachedSyntax == LDAPTYPE_OCTETSTRING)
              && (dwUserSyntax == LDAPTYPE_SECURITY_DESCRIPTOR)
              ) {
            dwRequestedSyntax = dwUserSyntax;
        }
        else {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

    //
    // If the data is in a state that needs conversion the fn will
    // take care - note that if the source is already in the correct
    // format then the HR will S_FALSE.
    //
    hr = LdapTypeBinaryToString(
             dwRequestedSyntax,
             &ldapSrcObjects,
             &ldapSrcObjectsTmp
             );
    BAIL_ON_FAILURE(hr);

    if (hr == S_OK) {
        pldapObjects = &ldapSrcObjectsTmp;
    } 
    else {
        //
        // We already have the data in the right format.
        //
        pldapObjects = &ldapSrcObjects;
        hr = S_OK;
    }

    //
    // Now that we have the correct data in pLdapObjects, we need
    // to convert that to Umi Properties.
    //
    hr = LdapTypeToUmiTypeCopy(
             *pldapObjects,
             pProp,
             dwStatus,
             dwRequestedSyntax,
             _pCreds,
             _pszServerName,
             uUmiFlag
             );
    BAIL_ON_FAILURE(hr);

    //
    // Stuff the name in the return value.
    //
    if (pProp) {
        (*pProp)->pPropArray[0].pszPropertyName = AllocADsStr(pszName);

        if (!(*pProp)->pPropArray[0].pszPropertyName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

error:

    if (_fPropCacheMode) {
        LdapTypeFreeLdapObjects(&ldapSrcObjects);
        LdapTypeFreeLdapObjects(&ldapSrcObjectsTmp);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);

        if (pProp) {
            this->FreeMemory(0, (void *)*pProp);
            *pProp = NULL;
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::FreeMemory (IUmiPropList support).
//
// Synopsis:   Free memory pointed to. Note that the pointer should have 
//        originally come from a Get/GetAs call.
//
// Arguments:  Ptr to data to be freed.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   *pMem is of course freed.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::FreeMemory(
    ULONG  uReserved,
    LPVOID pMem
    )
{
    HRESULT hr = S_OK;

    SetLastStatus(0);

    if (uReserved) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (pMem) {
        //
        // At this time this has to be a pUmiProperty. Ideally we should
        // tag this in some way so that we can check to make sure.
        //
        hr = FreeUmiPropertyValues((UMI_PROPERTY_VALUES *)pMem);
    } 
    else {
        hr = E_INVALIDARG;
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}
        
//+---------------------------------------------------------------------------
// Function:   CPropertyManager::Delete (IUmiPropList support).
//
// Synopsis:   Delete the named property from the cache.
//
// Arguments:  pszName   -   Name of property to delete.
//             uFlags    -   Standard flags parameter.
//
// Returns:    E_NOTIMPL.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::Delete(
    IN LPCWSTR pszName,
    IN ULONG uFlags
    )
{
    SetLastStatus(E_NOTIMPL);
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetProps (IUmiPropList support).
//
// Synopsis:   Gets the values for the attributes. This will read data 
//        from the server as needed.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   UMI_PROPERTY_VALUES* has the an array of values for the 
//        attributes. Note that there is no ordering specified
//        for the return values. 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::GetProps(
    IN LPCWSTR* pszNames,
    IN ULONG uNameCount,
    IN ULONG uFlags,
    OUT UMI_PROPERTY_VALUES **pProps
    )
{
    HRESULT hr = S_OK;

    if ((uFlags != UMI_FLAG_GETPROPS_NAMES)
        && (uFlags != UMI_FLAG_GETPROPS_SCHEMA)
        ) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    //
    // Currently we support only getting the names of all the properties.
    //
    if (pszNames
        || uNameCount
        || !pProps
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    *pProps = NULL;

    if (_fPropCacheMode) {
        //
        // Only UMI_FLAG_GETPROPS_NAMES is valid in this case.
        //
        if (uFlags != UMI_FLAG_GETPROPS_NAMES) {
            BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
        }

        hr = _pPropCache->GetPropertyNames(pProps);
    } 
    else {
        //
        // Need to see what type of flag it is and extra check needed,
        // if this is UMI_FLAGS_GETPROPS_SCHEMA.
        //
        if (uFlags == UMI_FLAG_GETPROPS_SCHEMA) {
            LONG lVal;
            hr = GetLongProperty(L"__GENUS", &lVal);
            
            BAIL_ON_FAILURE(hr);

            if (lVal != UMI_GENUS_CLASS) {
                BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
            }

            hr = GetPropertyNamesSchema(pProps);
        } 
        else {
            //
            // Need to do get our static list.
            //
            hr = this->GetPropertyNames(pProps);
        }
    } // else for !propertyCacheMode.

error:

    RRETURN(hr);

}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::PutProps (IUmiPropList support).
//
// Synopsis:   Puts the value for the attributes in the cache.
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Property cache for the object.
//
//---------------------------------------------------------------------------- 
HRESULT 
CPropertyManager::PutProps(
    IN LPCWSTR* pszNames,
    IN ULONG uNameCount,
    IN ULONG uFlags,
    IN UMI_PROPERTY_VALUES *pProps
    )
{
    HRESULT hr = S_OK;
    
    //
    // When done - should get and put multiple work directly of the server ?
    // That would take care off problems like 5 can be put in the cache
    // but sixth cannot ...
    //
    SetLastStatus(E_NOTIMPL);
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::PutFrom (IUmiPropList support).
//
// Synopsis:   Clarify exactly what this is supposed to do ?
//
// Arguments:  self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Property cache for the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPropertyManager::PutFrom(
    IN  LPCWSTR pszName,
    IN  ULONG uFlags,
    IN  ULONG uBufferLength,
    IN  LPVOID pExistingMem
    )
{
    SetLastStatus(E_NOTIMPL);
    RRETURN(E_NOTIMPL);
}



//
// PropertyManager methods that are not part of the IUmiPropList interface.
//

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetLastStatus
//
// Synopsis:   Returns the error from the last operation on this object.
//          For now only the status code is supported.
//
// Arguments:  uFlags            -   Must be 0 for now.
//             puSpecificStatus  -   Status is returned in this value.
//             riid              -   IID requested on status obj.
//             pStatusObj        -   Must be NULL for now.
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   *puSpecificStatus with last status code.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if (!puSpecificStatus || pStatusObj) {
        RRETURN(E_INVALIDARG);
    }

    if (uFlags) {
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    *puSpecificStatus = _ulStatus;

    RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::AddProperty.
//
// Synopsis:   Updates the value of the property to the interface 
//        property cache. This fn is called only in interface mode.
//        If necessary the property will be added to the cache. 
//
// Arguments:  self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Changes the internal property table.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::AddProperty(
    LPCWSTR szPropertyName,
    UMI_PROPERTY umiProperty
    )
{
    HRESULT hr = S_OK;
    DWORD dwIndex = (DWORD) -1;
    BOOL fAddedName = FALSE;

    //
    // Make sure we do not have property in the cache.
    //
    hr = FindProperty(szPropertyName, &dwIndex);

    if (FAILED(hr)) {
        //
        // We actually need to add this property in our list.
        //
        hr = AddToTable(szPropertyName, &dwIndex);

        fAddedName = TRUE;
    }

    BAIL_ON_FAILURE(hr);

    //
    // At this point we can just dump the value into the cache.
    //
    hr = UpdateProperty(
             dwIndex,
             umiProperty
             );

    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr) && fAddedName) {
        //
        // Do we delete the name from the cache.
        //
        DeleteProperty(dwIndex);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::UpdateProperty.
//
// Synopsis:   Updates the value of an interface property in the local cache.
//        The assumption is that this function is only called with from
//        AddProperty (or anywhere else where we have the correct index).
//       
// Arguments:  dwIndex - index in our table of the property to update
//             UMI_PROPERTY - the value to add to our table, note that
//             if the operation is delete we should remove the element
//             from our table (value returned if any will be default value
//             for subsequent get calls).
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Underlying data in the cache is changed
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::UpdateProperty(
    DWORD  dwIndex,
    UMI_PROPERTY umiProp
    )
{
    HRESULT hr = E_NOTIMPL;
    DWORD dwFlags, dwCacheSyntaxId, dwNumElements;
    PUMI_PROPERTY pUmiProperty = NULL;


    if (!_pIntfProperties) {
        //
        // Should we check the index ? It is after all an internal
        // value, so it should not be wrong.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Only update and delete are really supported.
    //
    if ((umiProp.uOperationType != UMI_OPERATION_UPDATE)
        && (umiProp.uOperationType != UMI_OPERATION_DELETE_ALL_MATCHES)) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (_pIntfProperties[dwIndex].pUmiProperty) {
        //
        // Free the current data in the table and set initial values.
        //
        hr = FreeOneUmiProperty(*(_pIntfProperties[dwIndex].pUmiProperty));
        BAIL_ON_FAILURE(hr);

        FreeADsMem(_pIntfProperties[dwIndex].pUmiProperty);

        _pIntfProperties[dwIndex].pUmiProperty = NULL;
        _pIntfProperties[dwIndex].dwFlags = 0;
        _pIntfProperties[dwIndex].dwSyntaxId = 0;
    }

    //
    // Copy the value to temp variable, so we can handle failures gracefully.
    //
    hr = CopyUmiProperty(
             umiProp,
             &pUmiProperty
             );
    BAIL_ON_FAILURE(hr);

    _pIntfProperties[dwIndex].pUmiProperty = pUmiProperty;

error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::FindProperty.
//
// Synopsis:   Searches for the specified property in the local cache.
//       
// Arguments:  szPropertyName, name of property.
//         pdwIndex - pointer to DWORD with index in table. 
//
// Returns:    HRESULT - S_OK or E_ADS_PROPERTY_NOT_FOUND.
//
// Modifies:   *pdwIndex to.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::FindProperty(
    LPCWSTR szPropertyName,
    PDWORD pdwIndex
    )
{
    DWORD dwIndex;

    if (!_pIntfProperties) {
        RRETURN(E_ADS_PROPERTY_NOT_FOUND);
    }
    for (dwIndex = 0; dwIndex < _dwMaxProperties; dwIndex++) {
        if (_wcsicmp(
                _pIntfProperties[dwIndex].pszPropertyName,
                szPropertyName
                ) == 0) {
                *pdwIndex = dwIndex;
                RRETURN(S_OK);
        }
    }

    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::DeleteProperty.
//
// Synopsis:   Deletes the property specified from the cahce.
//       
// Arguments:  Index to element to delete.
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Underlying data in the cache is changed.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::DeleteProperty(
    DWORD dwIndex
    )
{
    HRESULT hr = S_OK;
    INTF_PROPERTY* pIntfProp = NULL;

    if (_pIntfProperties && ((_dwMaxProperties-1) < dwIndex)) {
        //
        // Valid property in cache.
        //
        pIntfProp = _pIntfProperties + dwIndex;
        ADsAssert(pIntfProp);
    
        if (pIntfProp->pszPropertyName) {
            FreeADsStr(pIntfProp->pszPropertyName);
            pIntfProp->pszPropertyName = NULL;
        }
    
        //
        // Now Copy over the rest of the data here.
        //
        
    } 
    else {
        hr = E_FAIL;
    }

    RRETURN (hr);
}



//+---------------------------------------------------------------------------
// Function:  CPropertyManager::FlushPropertyCache.
//
// Synopsis:  Clear all internal data in the property cache.
//       
// Arguments:  
//
// Returns:   N/A
//
// Modifies:  Underlying data in the cache is changed
//
//----------------------------------------------------------------------------        
VOID
CPropertyManager::flushpropertycache() 
{
    //
    // Free any data in our table
    if (_pIntfProperties) {
        for (DWORD dwCtr = 0; (dwCtr < _dwMaxProperties); dwCtr++) {
            INTF_PROPERTY *pIntfProp = (PINTF_PROPERTY)_pIntfProperties+ dwCtr;
            if (pIntfProp) {
                if (pIntfProp->pszPropertyName) {
                    FreeADsStr(pIntfProp->pszPropertyName);
                    pIntfProp->pszPropertyName = NULL;
                }
            }
        }
        //
        // Now free the array of pointers.
        //
        FreeADsMem((void *) _pIntfProperties);
        _pIntfProperties = NULL;
    }
}


//+---------------------------------------------------------------------------
// Function:  CPropertyManager::ClearAllPropertyFlags.
//
// Synopsis:  Resets all property flags to zero.
//       
// Arguments:  None.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   Underlying data in the cache is changed.
//
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::ClearAllPropertyFlags(
    VOID
    )
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetPropertyNames.
//
// Synopsis:  Returns list of names of interface properties available.  
//       
// Arguments:  out params only
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   ppStringsNames to point to valid array of strings.
//         pUlCount to point to number of strings in the array.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetPropertyNames(
    PUMI_PROPERTY_VALUES *pUmiProps
    )
{
    HRESULT hr = S_OK;
    PUMI_PROPERTY_VALUES pUmiPropVals = NULL;
    PUMI_PROPERTY pUmiProperties = NULL;
    DWORD dwCtr, dwPropCount = 0;

    pUmiPropVals = (PUMI_PROPERTY_VALUES) AllocADsMem(
                       sizeof(UMI_PROPERTY_VALUES)
                       );

    if (!pUmiPropVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Need to count the properties.
    //
    while (_pStaticPropData[dwPropCount].pszPropertyName) {
        dwPropCount++;
    }
    
    if (!dwPropCount) {
        *pUmiProps = pUmiPropVals;
        RRETURN(S_OK);        
    }

    pUmiProperties = (PUMI_PROPERTY) AllocADsMem(
                         sizeof(UMI_PROPERTY) * dwPropCount
                         );

    if (!pUmiProperties) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Need to go through the table and alloc the values.
    //
    for (dwCtr = 0; dwCtr < dwPropCount; dwCtr++) {
        pUmiProperties[dwCtr].pszPropertyName = 
            AllocADsStr(_pStaticPropData[dwCtr].pszPropertyName);

        if (!pUmiProperties[dwCtr].pszPropertyName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pUmiProperties[dwCtr].uType = UMI_TYPE_NULL;
    }

    pUmiPropVals->pPropArray = pUmiProperties;
    pUmiPropVals->uCount = dwPropCount;

    *pUmiProps = pUmiPropVals;

    RRETURN(S_OK);

error :

    if (pUmiProperties) {
        for (dwCtr = 0; dwCtr < dwPropCount; dwCtr++) {
            if (pUmiProperties[dwCtr].pszPropertyName) {
                FreeADsStr(pUmiProperties[dwCtr].pszPropertyName);
            }
        }
        FreeADsMem(pUmiProperties);
    }

    if (pUmiPropVals) {
        FreeADsMem(pUmiPropVals);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetPropertyNamesSchema
//
// Synopsis:  Returns list of the names and types of the properties this 
//          object can contain. Note that this method is valid only if the
//          underlying object is an instance of class Class (schema class).
//       
// Arguments:  out params only
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetPropertyNamesSchema(
    PUMI_PROPERTY_VALUES *pUmiProps
    )
{
    HRESULT hr = S_OK;
    IADsUmiHelperPrivate *pIADsUmiPriv = NULL;
    // Array of ptr to PROPERTYINFO
    PPROPERTYINFO *pPropArray = NULL;
    DWORD dwPropCount = 0;
    PUMI_PROPERTY_VALUES pUmiPropVals = NULL;
    PUMI_PROPERTY pUmiProperties = NULL;

    //
    // Need a ptr to the helper routine.
    //
    hr = this->_pIADs->QueryInterface(
                           IID_IADsUmiHelperPrivate,
                           (void **) &pIADsUmiPriv
                           );

    if (hr == E_NOINTERFACE) {
        BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
    }

    hr = pIADsUmiPriv->GetPropertiesHelper(
                           (void**) &pPropArray,
                           &dwPropCount
                           );
    BAIL_ON_FAILURE(hr);

    //
    // Need to prepare the return values.
    //
    pUmiPropVals = (PUMI_PROPERTY_VALUES) AllocADsMem(
                       sizeof(UMI_PROPERTY_VALUES)
                       );

    if (!pUmiPropVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!dwPropCount) {
        *pUmiProps = pUmiPropVals;
        RRETURN(S_OK);        
    }

    pUmiProperties = (PUMI_PROPERTY) AllocADsMem(
                         sizeof(UMI_PROPERTY) * dwPropCount
                         );

    if (!pUmiProperties) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    
    for (DWORD dwCtr = 0; dwCtr < dwPropCount; dwCtr++) {
        DWORD dwSyntaxId = 0;
        pUmiProperties[dwCtr].pszPropertyName = 
            AllocADsStr(pPropArray[dwCtr]->pszPropertyName);

        if (!pUmiProperties[dwCtr].pszPropertyName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        //
        // Need to update the type with the type from the schema.
        //
        dwSyntaxId = LdapGetSyntaxIdOfAttribute(
                         pPropArray[dwCtr]->pszSyntax
                         );

        //
        // If we get dwSyntaxId == -1 we could not find the entry in
        // our table.
        //
        if (dwSyntaxId == -1) {
            pUmiProperties[dwCtr].uType = UMI_TYPE_UNDEFINED;
        } 
        else {
            hr = ConvertLdapSyntaxIdToUmiType(
                     dwSyntaxId,
                     (pUmiProperties[dwCtr].uType)
                     );
            if (FAILED(hr)) {
                hr = S_OK;
                //
                // Cannot do anything about this.
                //
                pUmiProperties[dwCtr].uType = UMI_TYPE_UNDEFINED;
            }

            //
            // If this property is multivalued.
            //
            if (!pPropArray[dwCtr]->fSingleValued) {
                pUmiProperties[dwCtr].uType |= UMI_TYPE_ARRAY_FLAG;
            }
        }
    } // for each property.

    pUmiPropVals->pPropArray = pUmiProperties;
    pUmiPropVals->uCount = dwPropCount;

    *pUmiProps = pUmiPropVals;

error:

    if (pIADsUmiPriv) {
        pIADsUmiPriv->Release();
    }

    //
    // Need to free the array not the elements which are ptrs into
    // the global parsed schema's we hold.
    //
    if (pPropArray) {
        FreeADsMem(pPropArray);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetInterfaceProperty
//
// Synopsis:  Gets the interface property from the owning object or the
//          default value and packages the value as an UMI_PROPERTY_VALUE.
//
// Arguments:  pszName       - name of property to get.
//             uFlags        - flags has to be zero for now.
//             ppProp        - value is returned in this ptr.
//             dwTableIndex  - index to entry in table describing this item.
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   ppProp which will point to return value if the fn succeeds.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetInterfaceProperty(
    LPCWSTR pszName,
    ULONG   uFlags,
    UMI_PROPERTY_VALUES **ppProp,
    DWORD dwTableIndex
    )
{
    HRESULT hr;
    ULONG ulOperationAllowed = _pStaticPropData[dwTableIndex].ulOpCode;
    ULONG ulVal;
    LONG lGenus;
    LPWSTR pszStringVal = NULL;
    BSTR bstrRetVal = NULL, bstrTempVal = NULL;
    LPWSTR pszUmiUrl = NULL;
    IADsObjectOptions *pObjOpt = NULL;
    VARIANT vVariant;
    DWORD dwIndex;
    PUMI_PROPERTY pUmiPropLocal = NULL;
    IUnknown *pUnk = NULL;
    IUmiObject *pUmiObj = NULL;
    BOOL fUnkPtr = FALSE;
    BOOL fClassInstance = FALSE;

    VariantInit(&vVariant);

    if (!_pUnk) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }
     
    //
    // If the property is READ/WRITE, we need to see if there is a value
    // in the propCache. If yes, return that. If not return the default
    // value.
    //
    if (ulOperationAllowed == OPERATION_CODE_READWRITE) {

        hr = FindProperty(pszName, &dwIndex);
        //
        // If it succeeded it was updated in the cache.
        //
        if (SUCCEEDED(hr)) {
            hr = CopyUmiProperty(
                     *(_pIntfProperties[dwIndex].pUmiProperty),
                     &pUmiPropLocal
                     );
            BAIL_ON_FAILURE(hr);

            //
            // We need to free the name of the first property cause
            // that is allocated again by the Get call.
            //
            if (pUmiPropLocal && pUmiPropLocal->pszPropertyName) {
                FreeADsStr(pUmiPropLocal->pszPropertyName);
                pUmiPropLocal->pszPropertyName = NULL;
            }

            //
            // Got the property need to package in umi property values.
            //
            *ppProp = (PUMI_PROPERTY_VALUES) AllocADsMem(
                                                 sizeof(UMI_PROPERTY_VALUES)
                                                 );
            
            if (!*ppProp) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            (*ppProp)->pPropArray = pUmiPropLocal;
            (*ppProp)->uCount = 1;
            RRETURN(hr);
        } // value found in cache 
        else {
            //
            // Setting this should trigger a read of the default
            // value for this property.
            //
            ulOperationAllowed = OPERATION_CODE_READABLE;
        }
    }

    //
    // We need to check for the securityDescriptor as that needs
    // some special handling.
    //
    if (!_wcsicmp(pszName, L"__SECURITY_DESCRIPTOR")) {
        //
        // Need to read this from the actual object.
        //
        hr = _pUnk->QueryInterface(IID_IUmiObject, (void **) &pUmiObj);
        BAIL_ON_FAILURE(hr);

        hr = pUmiObj->GetAs(
                 L"ntSecurityDescriptor",
                 uFlags,
                 UMI_TYPE_OCTETSTRING,
                 ppProp
                 );
        if (SUCCEEDED(hr)) {
            //
            // Need to make sure that we do not set name twice.
            //
            if (*ppProp
                && (*ppProp)[0].pPropArray
                && (*ppProp)[0].pPropArray[0].pszPropertyName
                ) {
                FreeADsStr((*ppProp)[0].pPropArray[0].pszPropertyName);
                (*ppProp)[0].pPropArray[0].pszPropertyName = NULL;
            }
        }
        //
        // This seems the cleanest ...
        //
        goto error;
    }

    //
    // If the property is only readable, then get it from owning object.
    // If not get the value from cache or use defualt value as appropriate.
    //
    if (ulOperationAllowed == OPERATION_CODE_READABLE) {
        hr = GetLongProperty(L"__GENUS", &lGenus);
        if (FAILED(hr)) {
            //
            // There was no genus property = connection for example.
            //
            fClassInstance = FALSE;
        } 
        else if (lGenus == UMI_GENUS_CLASS) {
            fClassInstance = TRUE;
        }

        //
        // The value can be a string/long for now and it has to 
        // be either the default value or the value from the owning object.
        //
        switch (_pStaticPropData[dwTableIndex].ulDataType) {
            
        case UMI_TYPE_I4:
            //
            // Use default value from the static table.
            //
            vVariant.lVal = _pStaticPropData[dwTableIndex].umiVal.lValue[0];

            hr = ConvertVariantLongToUmiProp(vVariant, ppProp);
            break;
            
        case UMI_TYPE_BOOL:
            //
            // Use default value from table.
            //
            vVariant.lVal = _pStaticPropData[dwTableIndex].umiVal.bValue[0];
            hr = ConvertVariantLongToUmiProp(vVariant, ppProp);
            (*ppProp)[0].pPropArray[0].uType = UMI_TYPE_BOOL;
            break;

        case UMI_TYPE_LPWSTR:
            //
            // In this case it has to be NULL.
            //
            hr = GetEmptyLPWSTRProp(ppProp);
            break;

        case 9999:
            if (!_pIADs) {
                //
                // Nothing we can do here !
                //
                BAIL_ON_FAILURE(hr = E_FAIL);
            }

            if (!_wcsicmp(pszName, L"__Path")) {
                hr = _pIADs->get_ADsPath(&bstrRetVal);
            }
            else if (!_wcsicmp(pszName, L"__Class")) {
                if (fClassInstance) {
                    //
                    // For classes, the class is the name,
                    // not "class" itself.
                    //
                    hr = _pIADs->get_Name(&bstrRetVal);
                } 
                else {
                    hr = _pIADs->get_Class(&bstrRetVal);
                }
            }
            else if (!_wcsicmp(pszName, L"__KEY")) {
                hr = _pIADs->get_Name(&bstrRetVal);
                BAIL_ON_FAILURE(hr);

                if (SUCCEEDED(hr)) {
                    hr = HelperConvertNameToKey(bstrRetVal, &pszUmiUrl);
                }
            }
            else if (!_wcsicmp(pszName, L"__GUID")) {
                hr = _pIADs->get_GUID(&bstrRetVal);
            }
            else if (!_wcsicmp(pszName, L"__Parent")) {
                hr = _pIADs->get_Parent(&bstrRetVal);
                if (SUCCEEDED(hr)) {
                    hr = ADsPathToUmiURL(bstrRetVal, &pszUmiUrl);
                }
            }
            else if (!_wcsicmp(pszName, L"__Schema")) {
                hr = _pIADs->get_Schema(&bstrRetVal);
                //
                // Now need to bind to this object.
                //
                if (SUCCEEDED(hr)) {
                    hr = GetObject(
                             bstrRetVal,
                             *_pCreds,
                             (void **) &pUnk
                             );
                    BAIL_ON_FAILURE(hr);
                    fUnkPtr = TRUE;
                }
            }
            else if (!_wcsicmp(pszName, L"__URL")) {
                hr = _pIADs->get_ADsPath(&bstrTempVal);
                if (SUCCEEDED(hr)) {
                    hr = ADsPathToUmiURL(bstrTempVal, &pszUmiUrl);
                }
            } 
            else if (!_wcsicmp(pszName, L"__Name")) {
                if (fClassInstance) {
                    hr = _pIADs->get_Name(&bstrRetVal);
                } else {
                    hr = HelperGetUmiRelUrl(_pIADs, &bstrRetVal);
                }
            }
            else if (!_wcsicmp(pszName, L"__RELURL")) {
                hr = HelperGetUmiRelUrl(_pIADs, &bstrRetVal); 
            } 
            else if (!_wcsicmp(pszName, L"__RELPATH")) {
                hr = HelperGetUmiRelUrl(_pIADs, &bstrRetVal); 
            }
            else if (!_wcsicmp(pszName, L"__FULLRELURL")) {
                //
                // Same as __RELURL, __NAME and __RELPATH
                //
                hr = HelperGetUmiRelUrl(_pIADs, &bstrRetVal);
            }
            else if (!_wcsicmp(pszName, L"__PADS_SCHEMA_CONTAINER_PATH")) {
                hr = HelperGetUmiSchemaContainerPath(_pIADs, &bstrRetVal);
            } 
            else if (!_wcsicmp(pszName, L"__SUPERCLASS")) {
                if (!fClassInstance) {
                    //
                    // Only supported if this is a class.
                    //
                    hr = E_FAIL;
                } 
                else {
                    hr = HelperGetUmiDerivedFrom(_pIADs, &bstrRetVal);
                }
            }
            else {
                hr = E_FAIL;
            }

            BAIL_ON_FAILURE(hr);

            //
            // If not schema then it has to be a string.
            //
            if (!fUnkPtr) {
                hr = ConvertBSTRToUmiProp(
                         pszUmiUrl ? pszUmiUrl:bstrRetVal,
                         ppProp
                     );
            } 
            else {
                hr = ConvertIUnkToUmiProp(
                         pUnk,
                         IID_IUmiObject,
                         ppProp
                         );
            }
            break;
            
        default:
            hr = E_FAIL;
        } // end of switch
        
        BAIL_ON_FAILURE(hr);
    } // opeartion code is READABLE.
    else {
        hr = E_FAIL;
    }

error:

    if (pObjOpt) {
        pObjOpt->Release();
    }

    VariantClear(&vVariant);
    
    if (bstrRetVal) {
        SysFreeString(bstrRetVal);
    }

    if (bstrTempVal) {
        SysFreeString(bstrTempVal);
    }

    if (pszUmiUrl) {
        FreeADsStr(pszUmiUrl);
    }

    if (pUnk) {
        pUnk->Release();
    }

    if (pUmiObj) {
        pUmiObj->Release();
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::DeleteSDIfPresent    --- Helper method.
//
// Synopsis:  Helps remove the SD from the property cache so that we do not
//          set it when we Commit the changes.
//
// Arguments:  N/A.
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   Underlying property cache.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::DeleteSDIfPresent()
{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;

    if (!_fPropCacheMode) {
        //
        // Sanity check, should never be here.
        //
        RRETURN(S_OK);
    }

    if (!_pPropCache) {
        //
        // Want to delete SD when we do not have a cache - weird.
        //
        RRETURN(S_OK);
    }

    hr = _pPropCache->findproperty(L"ntSecurityDescriptor", &dwIndex);
    if (FAILED(hr)) {
       RRETURN(S_OK);
    } 
    else {
        //
        // Get rid of this from the cache.
        //
        _pPropCache->deleteproperty(dwIndex);
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetIndexInStaticTable
//
// Synopsis:  Verifies that the named property can be found in the list of
//          valid properties and returns the index.
//       
// Arguments:  Self explanatory.
//
// Returns:    S_OK or E_ADS_PROPERTY_NOT_FOUND as appropriate.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetIndexInStaticTable(
    LPCWSTR pszName,
    DWORD &dwIndex
    )
{
    for (DWORD dwCtr = 0;
         _pStaticPropData[dwCtr].pszPropertyName;
         dwCtr++ ) {
        
        if (!_wcsicmp(
                 pszName,
                 _pStaticPropData[dwCtr].pszPropertyName
                 )) {
            dwIndex = dwCtr;
            RRETURN(S_OK);            
        }
    }

    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


//+---------------------------------------------------------------------------
// Function:   CPropertyManager::VerifyIfValidProperty.
//
// Synopsis:  Makes sure that a valid interface property is being set. This
//          function is called internally if we know we are not in the
//          property cache mode. The internal static table pointer is used to
//          verify the property.
//       
// Arguments:  Self explanatory.
//
// Returns:    Bool - True or False as appropriate.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
BOOL
CPropertyManager::VerifyIfValidProperty(
    LPCWSTR pszPropertyName,
    UMI_PROPERTY umiProperty
    )
{
    DWORD dwIndex;
    //
    // if _pStaticPropData is NULL then there are no interface properties.
    // If the count is zero, then the only operation is delete.
    //
    if ((!_pStaticPropData)
        || ((umiProperty.uCount == 0) 
           && (umiProperty.uOperationType != UMI_OPERATION_DELETE_ALL_MATCHES)
            )
        )
         {
        return FALSE;
    }

    if (SUCCEEDED(GetIndexInStaticTable(
                   pszPropertyName,
                   dwIndex
                   ))
        ) {
        //
        // Verify type and if property can be changed.
        // If the types do not match we should still allow 9999 for
        // things like __SECURITY_DESCRIPTOR that can be changed.
        // If the attribute cannot be written, then the next part of 
        // the check will fail, so you still wont be able to write
        // things the __URL property.
        //
        if (((_pStaticPropData[dwIndex].ulDataType == umiProperty.uType)
              || (_pStaticPropData[dwIndex].ulDataType == 9999))
            && (_pStaticPropData[dwIndex].ulOpCode 
                != OPERATION_CODE_READABLE)
            ) {
            //
            // Need to make sure count is correct.
            //
            if ((umiProperty.uCount > 1)
                && (!_pStaticPropData[dwIndex].fMultiValued)
                ) {
                return FALSE;
            }
            return TRUE;
        }

    }

    //
    // Either we did not satisfy requirements or not found
    //
    return FALSE;
}

HRESULT
CPropertyManager::AddToTable(
    LPCWSTR pszPropertyName,
    PDWORD pdwIndex
    )
{
    HRESULT hr = S_OK;
    PINTF_PROPERTY pNewProperty = NULL;
    //
    // Check to see if the table is already there. If not create
    // the table with potential to store upto 10 entries. This should
    // suffice unless we have more properties. Set the current pointer
    // and current top appropriately.
    //
    if (!_pIntfProperties) {
        _pIntfProperties = (PINTF_PROPERTY) AllocADsMem(
            sizeof(INTF_PROPERTY) * MAX_PROPMGR_PROP_COUNT
            );

        if (!_pIntfProperties) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        _dwMaxProperties = 0;
        _dwMaxLimit      = MAX_PROPMGR_PROP_COUNT;
    }


    if ((_dwMaxProperties+1) < _dwMaxLimit) {
        //
        // We can add this property to the table.
        //
        DWORD dwTop;
        
        dwTop = _dwMaxProperties++;

        _pIntfProperties[dwTop].pszPropertyName = 
            AllocADsStr(pszPropertyName);

        if (!_pIntfProperties[dwTop].pszPropertyName) {
            //
            // Reset the count.
            //
            _dwMaxProperties--;
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *pdwIndex = dwTop;
    } 
    else {
        //
        // We do not have space in the table - return an error.
        //
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetStringProperty.
//
// Synopsis: Retrieves the string property if one is set in the cache or 
//          returns NULL if the property is not in the cache. The assumption
//          here is that string properties are defaulted to NULL always.
//       
// Arguments:  Self explanatory.
//
// Returns:    S_OK, UMI_E_NOT_FOUND, E_FAIL.
//
// Modifies:   pszRetVal to point to the appropriate value.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetStringProperty(
    LPCWSTR pszPropName,
    LPWSTR *ppszRetStrVal
    )
{
    DWORD dwIndex;
    HRESULT hr = FindProperty(pszPropName, &dwIndex);
    PUMI_PROPERTY pUmiProp;

    if (FAILED(hr)) {
        //
        // Do we lookup the static table ? The table wont have strings in
        // it though cause the union assumes chars.
        //
        *ppszRetStrVal = NULL;
        RRETURN(S_OK);
    }

    pUmiProp = _pIntfProperties[dwIndex].pUmiProperty;
    
    //
    // Make sure that this is a string.
    //
    if (pUmiProp->uType != UMI_TYPE_LPWSTR) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (pUmiProp->pUmiValue
        && pUmiProp->pUmiValue->pszStrValue[0]) {

        *ppszRetStrVal = AllocADsStr(pUmiProp->pUmiValue->pszStrValue[0]);

        if (!*ppszRetStrVal) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetLongProperty   - Helper method.
//
// Synopsis: Retrieves the long property if one is set in the cache or 
//          returns the defaulted value if the property is not in the cache.
//
// Arguments:  pszPropName   ---   Name of property being retrieved.
//             plVal         ---   Ptr for return value.
//
// Returns:    S_OK, UMI_E_NOT_FOUND or E_FAIL.
//
// Modifies:   *plVal with appropriate value.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetLongProperty(
    LPCWSTR pszPropName,
    LONG *plVal
    )
{
    DWORD dwIndex;
    HRESULT hr = FindProperty(pszPropName, &dwIndex);
    PUMI_PROPERTY pUmiProp;

    *plVal = 0;

    if (FAILED(hr)) {
        //
        // We need to look for the property in the static table.
        //
        hr = GetIndexInStaticTable(pszPropName, dwIndex);
        if (SUCCEEDED(hr)
            && (_pStaticPropData[dwIndex].ulDataType == UMI_TYPE_I4)
            ) {
            //
            // Get the correct value from the table.
            //
            *plVal = _pStaticPropData[dwIndex].umiVal.lValue[0];

        } 
        else {
            hr = UMI_E_NOT_FOUND;
        }

        RRETURN(hr);
    }

    pUmiProp = _pIntfProperties[dwIndex].pUmiProperty;
    
    //
    // Make sure that this is a long.
    //
    if (pUmiProp->uType != UMI_TYPE_I4) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (pUmiProp->pUmiValue) {
        *plVal = pUmiProp->pUmiValue->lValue[0];
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CPropertyManager::GetBoolProperty   - Helper method.
//
// Synopsis: Retrieves the bool property if one is set in the cache or 
//          returns the defaulted value if the property is not in the cache.
//
// Arguments:  pszPropName   ---   Name of property being retrieved.
//             pfFlag        ---   Ptr for return value.
//
// Returns:    S_OK, UMI_E_NOT_FOUND or E_FAIL.
//
// Modifies:   ofFlag with appropriate value of the property.
//
//----------------------------------------------------------------------------
HRESULT
CPropertyManager::GetBoolProperty(
    LPCWSTR pszPropName,
    BOOL *pfFlag
    )
{
    DWORD dwIndex;
    HRESULT hr = FindProperty(pszPropName, &dwIndex);
    PUMI_PROPERTY pUmiProp;

    *pfFlag = FALSE;

    if (FAILED(hr)) {
        //
        // We need to look for the property in the static table.
        //
        hr = GetIndexInStaticTable(pszPropName, dwIndex);
        if (SUCCEEDED(hr)
            && (_pStaticPropData[dwIndex].ulDataType == UMI_TYPE_BOOL)
            ) {
            //
            // Get the correct value from the table.
            //
            *pfFlag = _pStaticPropData[dwIndex].umiVal.bValue[0];

        }
        else {
            hr = E_FAIL;
        }
        RRETURN(hr);
    }

    pUmiProp = _pIntfProperties[dwIndex].pUmiProperty;
    
    //
    // Make sure that this is a long.
    //
    if (pUmiProp->uType != UMI_TYPE_BOOL) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (pUmiProp->pUmiValue) {
        *pfFlag = pUmiProp->pUmiValue->bValue[0];
    }

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\crootdse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cgenobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   08-30-96  yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//  Class CLDAPRootDSE


DEFINE_IDispatch_Implementation(CLDAPRootDSE)
DEFINE_IADs_Implementation(CLDAPRootDSE)

CLDAPRootDSE::CLDAPRootDSE():
    _pPropertyCache( NULL ),
    _pDispMgr( NULL ),
    _pszLDAPServer(NULL),
    _pszLDAPDn(NULL),
    _pLdapHandle( NULL )
{
    VariantInit(&_vFilter);
    VariantInit(&_vHints);

    ENLIST_TRACKING(CLDAPRootDSE);
}

HRESULT
CLDAPRootDSE::CreateRootDSE(
    BSTR Parent,
    BSTR CommonName,
    BSTR LdapClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPRootDSE FAR * pGenObject = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGenObject(Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                LdapClassName,
                CLSID_LDAPGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildLDAPPathFromADsPath2(
             pGenObject->_ADsPath,
             &pGenObject->_pszLDAPServer,
             &pGenObject->_pszLDAPDn,
             &pGenObject->_dwPort
             );

    BAIL_ON_FAILURE(hr);


    //
    // At this point update the info in the property cache
    //
    hr = pGenObject->_pPropertyCache->SetObjInformation(
                                     &(pGenObject->_Credentials),
                                     pGenObject->_pszLDAPServer,
                                     pGenObject->_dwPort
                                     );

    BAIL_ON_FAILURE(hr);

    hr = LdapOpenObject(
                   pGenObject->_pszLDAPServer,
                   NULL,
                   &(pGenObject->_pLdapHandle),
                   pGenObject->_Credentials,
                   pGenObject->_dwPort
                   );

    BAIL_ON_FAILURE(hr);

    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        //
        // From Umi so we need to return UMI Object not RootDSE.
        //
        hr = ((CCoreADsObject*)pGenObject)->InitUmiObject(
                   IntfPropsGeneric,
                   pGenObject->_pPropertyCache,
                   (IADs*) pGenObject,
                   (IADs*) pGenObject,
                   riid,
                   ppvObj,
                   &(pGenObject->_Credentials),
                   pGenObject->_dwPort,
                   pGenObject->_pszLDAPServer,
                   NULL,
                   pGenObject->_pLdapHandle
                   );
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);
                   
    }

    hr = pGenObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGenObject->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pGenObject;
    RRETURN_EXP_IF_ERR(hr);
}

CLDAPRootDSE::~CLDAPRootDSE( )
{
    VariantClear(&_vFilter);
    VariantClear(&_vHints);

    if ( _pLdapHandle )
    {
        LdapCloseObject(_pLdapHandle);
        _pLdapHandle = NULL;
    }

    if (_pszLDAPServer) {
       FreeADsStr(_pszLDAPServer);
       _pszLDAPServer = NULL;
    }

    if (_pszLDAPDn) {
       FreeADsStr(_pszLDAPDn);
       _pszLDAPDn = NULL;
    }

    delete _pDispMgr;

    delete _pPropertyCache;

}

STDMETHODIMP
CLDAPRootDSE::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsObjectOptions)) {
        *ppv = (IADsObjectOptions FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CLDAPRootDSE::SetInfo()
{
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        //
        //  No concept of creating RootDSE objects
        //  Any DS must have a RootDSE object
        //

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = LDAPSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPRootDSE::LDAPSetObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    BOOL fNTSecDes = FALSE;
    SECURITY_INFORMATION NewSeInfo;


    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( aMod == NULL )  // There are no changes that needs to be modified
        RRETURN(S_OK);

    hr = LdapModifyS(
             _pLdapHandle,
             NULL,
             aMod
             );
    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

    _pPropertyCache->DeleteSavingEntry();

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );

        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPRootDSE::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CLDAPRootDSE::GetInfo()
{
    RRETURN(GetInfo(GETINFO_FLAG_EXPLICIT));
}

HRESULT
CLDAPRootDSE::GetInfo(
    DWORD dwFlags
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = ADSTYPE_CASE_IGNORE_STRING;
    LDAPMessage *res = NULL;

    if (dwFlags == GETINFO_FLAG_IMPLICIT_AS_NEEDED) {
        if (_pPropertyCache->getGetInfoFlag()) {
            //
            // Nothing to do in this case.
            //
            RRETURN(S_OK);
        }
    }

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = LdapSearchS(
                    _pLdapHandle,
                    NULL,
                    LDAP_SCOPE_BASE,
                    TEXT("(objectClass=*)"),
                    NULL,
                    0,
                    &res
                    );

    BAIL_ON_FAILURE(hr);

    if ( dwFlags == GETINFO_FLAG_EXPLICIT )
    {
        // If this is an explicit GetInfo,
        // delete the old cache and start a new cache from scratch.

        _pPropertyCache->flushpropertycache();
    }

    hr = _pPropertyCache->LDAPUnMarshallPropertiesAs(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            dwSyntaxId,
                            (dwFlags == GETINFO_FLAG_EXPLICIT) ?
                                 TRUE :
                                 FALSE,    
                            _Credentials
                            );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();

error:

    if (res) {

        LdapMsgFree( res );
    }


    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    HRESULT hr = S_OK;
    LDAPMessage *res = NULL;
    VARIANT *vVarArray = NULL;
    DWORD dwNumVariants = 0;
    PWSTR *ppszStringArray = NULL;
    DWORD dwOptions = 0;    
    DWORD dwCtr = 0;
    DWORD dwSyntaxId = ADSTYPE_CASE_IGNORE_STRING;
    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSafeArrayToVariantArray(
             vProperties,
             &vVarArray,
             &dwNumVariants
             );
    // returns E_FAIL if vProperties is invalid
    if (hr == E_FAIL)
        hr = E_ADS_BAD_PARAMETER;
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantArrayToLDAPStringArray(
             vVarArray,
             &ppszStringArray,
             dwNumVariants
             );
    BAIL_ON_FAILURE(hr);

    
    hr = LdapSearchS(
                 _pLdapHandle,
                 NULL,
                 LDAP_SCOPE_BASE,
                 TEXT("(objectClass=*)"),
                 ppszStringArray,
                 0,
                 &res
                 );    
    

    BAIL_ON_FAILURE(hr);
     
    hr = _pPropertyCache->LDAPUnMarshallProperties3(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            TRUE,   // fExplicit
                            dwSyntaxId,
                            _Credentials                            
                            );
    BAIL_ON_FAILURE(hr);

    for(DWORD i = 0; i < dwNumVariants; i++) {
    	_pPropertyCache->AddSavingEntry(ppszStringArray[i]);
    }

error:
        
    if (res)
        LdapMsgFree(res);

    if (ppszStringArray) 
    {
        for (DWORD i = 0; i < dwNumVariants; i++)
            if (ppszStringArray[i])
                FreeADsStr(ppszStringArray[i]);
        FreeADsMem(ppszStringArray);
    }

    if (vVarArray) 
    {
        for (dwCtr = 0; dwCtr < dwNumVariants; dwCtr++) {
            VariantClear(vVarArray + dwCtr);
        }
        FreeADsMem(vVarArray);
    }
   
    RRETURN_EXP_IF_ERR(hr);


    
}


HRESULT
CLDAPRootDSE::AllocateGenObject(
    CCredentials& Credentials,
    CLDAPRootDSE ** ppGenObject
    )
{
    CLDAPRootDSE FAR * pGenObject = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CLDAPRootDSE();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsObjectOptions,
                           (IADsObjectOptions *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *) pGenObject,
                        (IGetAttributeSyntax *) pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(pPropertyCache);

    pGenObject->_Credentials = Credentials;
    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pGenObject;

    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CLDAPRootDSE::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For some folks who have no clue what they are doing.
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }
    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    if ( ldapSrcObjects.dwCount == 1 ) {

        hr = LdapTypeToVarTypeCopy(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects.pLdapObjects,
                 dwSyntaxId,
                 pvProp
                 );
    } else {

        hr = LdapTypeToVarTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects,
                 dwSyntaxId,
                 pvProp
                 );
    }
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vDefProp;

    VariantInit(&vDefProp);

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
    pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
    (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                    vProp,
                    &pVarArray,
                    &dwNumValues
                    );
        // returns E_FAIL if vProp is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;                    
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }
    else {
    
        //                                                                  
        // If this is a single VT_BYREF of a basic type, we dereference
        // it once.
        //
        if (V_ISBYREF(pvProp)) {
            hr = VariantCopyInd(&vDefProp, pvProp);
    
            BAIL_ON_FAILURE(hr);
            pvProp = &vDefProp;
        }

        dwNumValues = 1;
    }

    //
    // check if the variant maps to the syntax of this property
    //

    hr = GetLdapSyntaxFromVariant(
             pvProp,
             &dwSyntaxId,
             _pszLDAPServer,
             bstrName,
             _Credentials,
             _dwPort
             );

    BAIL_ON_FAILURE(hr);


    if ( dwNumValues > 0 )
    {
        hr = VarTypeToLdapTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 dwSyntaxId,
                 pvProp,
                 dwNumValues,
                 &ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For those who know no not what they do
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    hr = LdapTypeToVarTypeCopyConstruct(
                _pszLDAPServer,
                _Credentials,
                ldapSrcObjects,
                dwSyntaxId,
                pvProp
                );
    BAIL_ON_FAILURE(hr);

error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    switch ( lnControlCode ) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_APPEND:
        dwFlags = PROPERTY_ADD;
        break;


    case ADS_PROPERTY_UPDATE:
        dwFlags = PROPERTY_UPDATE;
        break;

    default:
        RRETURN(hr = E_ADS_BAD_PARAMETER);
    }

    if ( dwFlags != PROPERTY_DELETE )
    {
        //
        // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
        // We should dereference a VT_BYREF|VT_VARIANT once and see
        // what's inside.
        //
        pvProp = &vProp;
        if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
            pvProp = V_VARIANTREF(&vProp);
        }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

            hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
            // returns E_FAIL if *pvProp is invalid
            if (hr == E_FAIL)
                hr = E_ADS_BAD_PARAMETER;                     
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // check if the variant maps to the syntax of this property
        //

        //
        // check if the variant maps to the syntax of this property
        //

        hr = GetLdapSyntaxFromVariant(
                 pvProp,
                 &dwSyntaxId,
                 _pszLDAPServer,
                 bstrName,
                 _Credentials,
                 _dwPort
                 );

        BAIL_ON_FAILURE(hr);

        if ( dwNumValues > 0 )
        {
            hr = VarTypeToLdapTypeCopyConstruct(
                     _pszLDAPServer,
                     _Credentials,
                     dwSyntaxId,
                     pvProp,
                     dwNumValues,
                     &ldapDestObjects
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId,
                    ldapDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::get_PropertyCount(
    THIS_ long FAR *plCount
    )
{
    HRESULT hr = E_FAIL;

    if (!plCount) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if (_pPropertyCache) {

        hr = _pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::Next(
    THIS_ VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    IDispatch * pDispatch = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;
    DWORD dwPropStatus = 0;
    DWORD dwCtrlCode = 0;
    LDAPOBJECTARRAY_INIT(ldapSrcObjects);


    if (!pVariant) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if(!_pPropertyCache->index_valid())
       RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // retreive the item with current idex; unboundgetproperty()
    // returns E_ADS_PROPERTY_NOT_FOUND if index out of bound
    //

    hr = _pPropertyCache->unboundgetproperty(
                _pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwPropStatus,
                &ldapSrcObjects
                );
    BAIL_ON_FAILURE(hr);


    dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);


    //
    // translate the LDAP objects to variants
    //

    hr = ConvertLdapValuesToVariant(
            _pPropertyCache->get_CurrentPropName(),
            &ldapSrcObjects,
            dwSyntaxId,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );
    BAIL_ON_FAILURE(hr);


error:

    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the success of Skip().
    //

    Skip(1);

    LdapTypeFreeLdapObjects(&ldapSrcObjects);

    if (FAILED(hr)) {
        V_VT(pVariant) = VT_ERROR;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::Skip(
    THIS_ long cElements
    )
{
    HRESULT hr = E_FAIL;

    hr = _pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN(hr);
}


STDMETHODIMP
CLDAPRootDSE::Reset(

    )
{
    _pPropertyCache->reset_propindex();

    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPRootDSE::ResetPropertyItem(THIS_ VARIANT varEntry)
{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;

    switch (V_VT(&varEntry)) {

    case VT_BSTR:

        hr = _pPropertyCache->findproperty(
                            V_BSTR(&varEntry),
                            &dwIndex
                            );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I4:
        dwIndex = V_I4(&varEntry);
        break;


    case VT_I2:
        dwIndex = V_I2(&varEntry);
        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->deleteproperty(
                        dwIndex
                        );
error:
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::GetPropertyItem(
    THIS_ BSTR bstrName,
    LONG lnType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    DWORD dwNumValues = 0;

    DWORD dwUserSyntaxId = 0;
    DWORD dwStatus = 0;
    DWORD dwCtrlCode = 0;



    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // retrieve data object from cache; do NOT retreive from server
    //

    hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);

    hr = ConvertLdapValuesToVariant(
            bstrName,
            &ldapSrcObjects,
            dwSyntaxId,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );

error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::PutPropertyItem(
    THIS_ VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    DWORD dwControlCode = 0;
    LDAPOBJECTARRAY ldapDestObjects;
    WCHAR* pszPropertyName = NULL;
    DWORD dwSyntaxId = 0;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    hr = ConvertVariantToLdapValues(
                varData,
                &pszPropertyName,
                &dwControlCode,
                &ldapDestObjects,
                &dwSyntaxId,
                _pszLDAPServer,
                &_Credentials,
                _dwPort
                );
    BAIL_ON_FAILURE(hr);

    switch ( dwControlCode ) {

    case ADS_PROPERTY_CLEAR:

        //
        // Clears an entire property
        //

        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:

        //
        // Updates the entire property
        //

        dwFlags = PROPERTY_UPDATE;
        break;

    case ADS_PROPERTY_APPEND:
        //
        // Appends a set of values to the property
        //

        break;

    case ADS_PROPERTY_DELETE:
        //
        // Delete a value(s) from the property

        break;


    default:
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }



    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        pszPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( pszPropertyName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    pszPropertyName,
                    dwFlags,
                    dwSyntaxId,
                    ldapDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if(pszPropertyName)
    {
        FreeADsStr(pszPropertyName);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPRootDSE::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)

{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumValues = 0;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;
    DWORD dwStatus = 0;
    DWORD dwCtrlCode = 0;
    VARIANT *pvVar = &varIndex;
    LPWSTR szPropName = NULL;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // retrieve data object from cache; if one exis
    //

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:
        //
        // retrieve data object from cache; if one exists
        //

        if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

            hr = _pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

            // For backward compatibility -- nothing done, you
            // should be able to get an item marked as delete.

        } else {

            hr = _pPropertyCache->getproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwStatus,
                        &ldapSrcObjects
                        );

            // For backward compatibility -- nothing done,
            // you should be able to get an item marked as delete.

        }

        BAIL_ON_FAILURE(hr);
        szPropName = V_BSTR(pvVar);

        dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);
        break;

    case VT_I4:


        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I4(pvVar),
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility -- nothing done, you
        // should be able to get an item marked as delte.

        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(
                         (DWORD)V_I4(pvVar)
                         );

        dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);
        break;


    case VT_I2:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility -- nothing done, you
        // should be able to get an item marked as delete.

        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(
                         (DWORD)V_I2(pvVar)
                         );

        dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);
        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    //
    // translate the Ldap objects to variants
    //

    dwCtrlCode = MapPropCacheFlagToControlCode(dwStatus);

    hr = ConvertLdapValuesToVariant(
            szPropName,
            &ldapSrcObjects,
            dwSyntaxId,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );

error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPRootDSE::PurgePropertyList()
{
    _pPropertyCache->flushpropertycache();
    RRETURN(S_OK);
}



STDMETHODIMP
CLDAPRootDSE::GetInfo(
    LPWSTR szPropertyName,
    DWORD dwSyntaxId,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LDAPMessage *res = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = LdapSearchS(
                    _pLdapHandle,
                    _pszLDAPDn,
                    LDAP_SCOPE_BASE,
                    TEXT("(objectClass=*)"),
                    NULL,
                    0,
                    &res
                    );

    BAIL_ON_FAILURE(hr);

    if ( fExplicit )
    {
        // If this is an explicit GetInfo,
        // delete the old cache and start a new cache from scratch.

        _pPropertyCache->flushpropertycache();
    }

    hr = _pPropertyCache->LDAPUnMarshallPropertiesAs(
                            _pszLDAPServer,
                            _pLdapHandle,
                            res,
                            ADSTYPE_CASE_IGNORE_STRING,
                            fExplicit,
                            _Credentials
                            );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();


error:

    if (res) {

        LdapMsgFree( res );
    }


    RRETURN_EXP_IF_ERR(hr);
}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPRootDSE::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr;
    hr = LdapGetSyntaxOfAttributeOnServer(
         _pszLDAPServer,
         szPropertyName,
         pdwSyntaxId,
         _Credentials,
         _dwPort
         );
    RRETURN_EXP_IF_ERR(hr);
}


//
// IADsObjecOptions methods
//

//
// Unlike the cgenobj GetOption implementation, this will support
// only a subset of the flags - mutual auth status being the only one.
//
STDMETHODIMP
CLDAPRootDSE::GetOption(
    THIS_ long lnControlCode,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    ULONG ulFlags = 0;
    CtxtHandle hCtxtHandle;
    DWORD dwErr = 0;

    VariantInit(pvProp);

    switch (lnControlCode) {

    case ADS_OPTION_MUTUAL_AUTH_STATUS :

        dwErr = ldap_get_option(
                    _pLdapHandle->LdapHandle,
                    LDAP_OPT_SECURITY_CONTEXT,
                    (void *) &hCtxtHandle
                    );
        if (dwErr) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

//DSCLIENT

#if (!defined(WIN95))

        dwErr = QueryContextAttributesWrapper(
                    &hCtxtHandle,
                    SECPKG_ATTR_FLAGS,
                    (void *) &ulFlags
                    );
        if (dwErr) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
        }
#else
        ulFlags = 0;
#endif
        pvProp->vt = VT_I4;
        pvProp->lVal = ulFlags;
        break;

    default:
        hr = E_NOTIMPL;
    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CLDAPRootDSE::SetOption(
    THIS_ long lnControlCode,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwOptVal = 0;
    VARIANT *pvProp = NULL;

    //
    // To make sure we handle variant by refs correctly.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    switch (lnControlCode) {

    case ADS_PRIVATE_OPTION_KEEP_HANDLES :

        hr = LdapcKeepHandleAround(_pLdapHandle);
        break;

    default:
        hr = E_NOTIMPL;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cumiobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumiobj.cxx
//
//  Contents: Contains the implementation of IUmiObject/Container methods.
//            Methods are encapsulated in one object but this object holds
//            a pointer to the inner unknown of the corresponding LDAP 
//            object. The methods of IUmiContainer are also implemented on
//            this object, but will only be used if the underlying object
//            is a container. 
//
//  History:  03-06-00    SivaramR  Created.
//            04-07-00    AjayR modified for LDAP Provider.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::CLDAPUmiObject
//
// Synopsis:   Constructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CLDAPUmiObject::CLDAPUmiObject():
    _pPropMgr(NULL),
    _pIntfPropMgr(NULL),
    _pUnkInner(NULL),
    _pIADs(NULL),
    _pIADsContainer(NULL),
    _ulErrorStatus(0),
    _pCoreObj(NULL),
    _pExtMgr(NULL),
    _fOuterUnkSet(FALSE)
{
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::~CLDAPUmiObject
//
// Synopsis:   Destructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CLDAPUmiObject::~CLDAPUmiObject(void)
{
    if (_pIntfPropMgr) {
        delete _pIntfPropMgr;
    }

    if (_pPropMgr) {
        delete _pPropMgr;
    }

    if (_pUnkInner) {
        _pUnkInner->Release();
    }

    if (_pIADsContainer) {
        _pIADsContainer->Release();
    }

    if (_pIADs) {
        _pIADs->Release();
    }

    //
    // We specifically do not release these as they are all just ptrs
    // _pCreds, _pszLDAPServer, _pszLDAPDn, _pLdapHandle.
    //
    
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::AllocateLDAPUmiObject --- Static constructor.
//
// Synopsis:   Static contstructor routine.
//
// Arguments:  intfPropTable- Schema information for interface properties.
//             pPropCache   - Pointer to property cache (shared with IADs).
//             pUnkInner    - Pointer to inner unknown of underlying obj.
//             pExtMgr      - Pointer to extension manager of object.
//             pCoreObj     - Pointer to the core object of underlying object.
//             ppUmiObj     - Return value.
//
// Returns:   S_OK on success. Error code otherwise. 
//
// Modifies:  *ppUmObj to point to newly created object.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUmiObject::CreateLDAPUmiObject(
    INTF_PROP_DATA intfPropTable[],
    CPropertyCache *pPropertyCache,
    IUnknown *pUnkInner,
    CCoreADsObject *pCoreObj,
    IADs *pIADs,
    CCredentials *pCreds,
    CLDAPUmiObject **ppUmiObj,
    DWORD dwPort, // defaulted to -1
    PADSLDP pLdapHandle,  // defaulted to NULL
    LPWSTR pszServerName,  // defaulted to NULL
    LPWSTR pszLDAPDn,  // defaulted to NULL
    CADsExtMgr *pExtMgr  // defaulted to NULL
    )
{
    HRESULT hr = S_OK;
    CLDAPUmiObject *pUmiObject = NULL;
    CPropertyManager *pPropMgr = NULL;
    CPropertyManager *pIntfPropMgr = NULL;

    //
    // This always has to be there, the extension manager will not 
    // be there for RootDSE and schema realted objects.
    //
    ADsAssert(pCoreObj);

    pUmiObject = new CLDAPUmiObject();
    
    if (!pUmiObject) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Property cache is not supported on the schema container object alone.
    // There will be no support for the propList methods for this object.
    //
    if (pPropertyCache) {
        //
        // Has to be valid if we have a property cache.
        //
        ADsAssert(pUnkInner);

        //
        // Need the standard property manager for Get/Put support.
        //
        hr = CPropertyManager::CreatePropertyManager(
                 pIADs,
                 (IUmiObject *) pUmiObject,
                 pPropertyCache,
                 pCreds,
                 pszServerName,
                 &pPropMgr
                 );

        BAIL_ON_FAILURE(hr);
    }

    if (intfPropTable) {
        hr = CPropertyManager::CreatePropertyManager(
                 (IUmiObject *) pUmiObject,
                 pUnkInner, // should support IADs.
                 pCreds,
                 intfPropTable,
                 &pIntfPropMgr
                 );
        BAIL_ON_FAILURE(hr);
    }
    
    //
    // At this point failures are not catastrophic so we can prepare
    // the object for return.
    //
    pUmiObject->_pUnkInner = pUnkInner;
    pUmiObject->_pIADs = pIADs;
    pUmiObject->_pExtMgr = pExtMgr;
    pUmiObject->_pCoreObj = pCoreObj;
    pUmiObject->_pCreds = pCreds;
    pUmiObject->_pPropMgr = pPropMgr;
    pUmiObject->_pIntfPropMgr = pIntfPropMgr;
    pUmiObject->_pszLDAPServer = pszServerName;
    pUmiObject->_pszLDAPDn = pszLDAPDn;
    pUmiObject->_pLdapHandle = pLdapHandle;
    pUmiObject->_dwPort = dwPort;

    //
    // Addref cause we release this in the destructor.
    //
    pIADs->AddRef();

    //
    // Get IADsContainer ptr if applicable - can ignore failures.
    //
    hr = pUnkInner->QueryInterface(
             IID_IADsContainer,
             (void **) &(pUmiObject->_pIADsContainer)
             );

    *ppUmiObj = pUmiObject;

    RRETURN(S_OK);

error:

    if (pUmiObject) {
        delete pUmiObject;
    }
    
    if (pPropMgr) {
        delete pPropMgr;
    }

    if (pIntfPropMgr) {
        delete pIntfPropMgr;
    }
        
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::QueryInterface --- IUnknown support.
//
// Synopsis:   Standard query interface method.
//
// Arguments:  iid           -  Interface requested.
//             ppInterface   -  Return pointer to interface requested. 
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pTmpIntfPtr = NULL;

    SetLastStatus(0);

    if (!ppInterface) {
        RRETURN(E_INVALIDARG); 
    }

    *ppInterface = NULL;

    if (IsEqualIID(iid, IID_IUnknown)) {
        *ppInterface = (IUmiObject *) this;
    } 
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppInterface = (IUmiObject *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiBaseObject)) {
        *ppInterface = (IUmiObject *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiObject)) {
        *ppInterface = (IUmiObject *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiContainer)) {
        //
        // Check if underlying LDAP object is a container.
        //
        if (_pIADsContainer != NULL) {
            *ppInterface = (IUmiContainer *) this;
        }
        else {
            RRETURN(E_NOINTERFACE);
        }
    }
    else if (IsEqualIID(iid, IID_IUmiCustomInterfaceFactory)) {
        *ppInterface = (IUmiCustomInterfaceFactory *) this;
    }
    else if (IsEqualIID(iid, IID_IADsObjOptPrivate)) {
        if (_pLdapHandle) {
            *ppInterface = (IADsObjOptPrivate*) this;
        } 
        else {
            RRETURN(E_NOINTERFACE);
        }
    } 
    else {
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    RRETURN(S_OK);
}
        
//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Clone --- IUmiObject support.
//
// Synopsis:   Clones this object. Note that this will do an implicit
//          refresh if one has not already been done on the object before
//          copying all the attributes. The new object has a state that a 
//          bound state (rather than unbound).
//
// Arguments:  uFlags     ---  Must be 0 for now.
//             riid       ---  IID requested on the clone.
//             pCopy      ---  The return ptr for the cloned object.
//
// Returns:    S_OK or appropriate error code. 
//
// Modifies:   pCopy to be updated with new UmiObject ptr on success.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPUmiObject::Clone(
    ULONG uFlags,
    REFIID riid,
    LPVOID *pCopy
    )
{
    HRESULT hr = S_OK;
    CCredentials Creds;
    BSTR bstrPath = NULL;
    BSTR bstrClass = NULL;
    LPWSTR pszParent = NULL, pszCommonName = NULL;
    IUmiObject *pUmiObj = NULL;
    IUmiObject *pDestUmiObj = NULL;
    DWORD dwAuthFlags = 0;

    SetLastStatus(0);

    //
    // We cannot clone objects that do not have an underlying IADs ptr.
    //
    if (!_pIADs) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (_pCreds) {
        Creds = *_pCreds;
    }

    //
    // Need to tag on the ADS_FAST_BIND to prevent the call from 
    // going on the wire.
    //
    dwAuthFlags = Creds.GetAuthFlags();
    Creds.SetAuthFlags(dwAuthFlags | ADS_FAST_BIND);

    //
    // Need to call Refresh with the internal flag. Note that using this
    // flag means that we will go on the wire only if we have to.
    //
    hr = this->Refresh(
             ADSI_INTERNAL_FLAG_GETINFO_AS_NEEDED,
             NULL,
             NULL
             );
    BAIL_ON_FAILURE(hr);

    //
    // Next we need to get the destination object.
    //
    hr = _pIADs->get_ADsPath(&bstrPath);
    BAIL_ON_FAILURE(hr);

    if (_pCoreObj->GetObjectState() == ADS_OBJECT_UNBOUND) {
        //
        // In this case we need to Create the target object.
        // The parent path, the common name and the class are needed.
        //
        hr = BuildADsParentPath(
                 bstrPath,
                 &pszParent,
                 &pszCommonName
                 );
        BAIL_ON_FAILURE(hr);

        hr = _pIADs->get_Class(&bstrClass);
        BAIL_ON_FAILURE(hr);

        hr = CLDAPGenObject::CreateGenericObject(
                 pszParent,
                 pszCommonName,
                 bstrClass,
                 Creds,
                 ADS_OBJECT_UNBOUND,
                 riid, // this is ignored
                 (void **) &pUmiObj
                 );
        BAIL_ON_FAILURE(hr);
    } 
    else {
        // 
        // In this case we bind to the object.
        //
        hr = GetObject(bstrPath, Creds, (void **)&pUmiObj);
        BAIL_ON_FAILURE(hr);
    }

    pUmiObj->QueryInterface(IID_IUmiObject, (void **) &pDestUmiObj);
    BAIL_ON_FAILURE(hr);

    //
    // Now we can call the helper to copy the attributes over.
    //
    hr = this->CopyToHelper(
             (IUmiObject*) this,
             pDestUmiObj,
             0,
             FALSE, // do not mark as update
             FALSE // do not copy intf props
             );
    BAIL_ON_FAILURE(hr);

    //
    // Update return value as this means copy was succesful.
    //
    *pCopy = pDestUmiObj;

error:

    if (FAILED(hr)) {
        if (!_ulErrorStatus) {
            SetLastStatus(hr);
        }
        hr = MapHrToUmiError(hr);

        if (pDestUmiObj) {
            pDestUmiObj->Release();
        }
    }

    if (bstrPath) {
        SysFreeString(bstrPath);
    }

    if (bstrClass) {
        SysFreeString(bstrClass);
    }
    
    if (pszParent) {
        FreeADsStr(pszParent);
    }
    
    if (pszCommonName) {
        FreeADsStr(pszCommonName);
    }

    if (pUmiObj) {
        pUmiObj->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::CopyTo --- IUmiObject support.
//
// Synopsis:   Copies the object to the new destination.Note that this will
//          do an implicit refresh if one has not already been done on the 
//          object before copying all the attributes. The new objecst state
//          is unbound, and the new object will be created on the destination
//          directory only when Commit is called. If any of the properties on
//          the object being copied are marked as updated/dirty then the call
//          will fail.
//
// Arguments:  uFlags     ---  Must be 0 for now.
//             pURL       ---  Url pointing to the destination.
//             riid       ---  IID requested on the clone.
//             pCopy      ---  The return ptr for the copied object.
//
// Returns:    S_OK or appropriate error code. 
//
// Modifies:   pCopy to be updated with new UmiObject ptr on success.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPUmiObject::CopyTo(
    IN  ULONG uFlags,
    IN  IUmiURL *pURL,
    IN  REFIID riid,
    OUT LPVOID *pCopy
    )
{
    HRESULT hr = S_OK;
    CCredentials Creds;
    BSTR bstrClass = NULL;
    LPWSTR pszLdapPath = NULL;
    LPWSTR pszParent = NULL, pszCommonName = NULL;
    IUmiObject *pUmiObj = NULL;
    IUmiObject *pUmiDestObj = NULL;
    DWORD dwAuthFlags = 0;

    SetLastStatus(0);

    RRETURN(E_NOTIMPL);
    //*******************************************************/
    // This code is not used currently.                      /
    //*******************************************************/

    //
    // Has to be 0.
    //
    if (uFlags) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    //
    // All these need to be valid.
    //
    if (!pURL
        || !pCopy
        || (riid != IID_IUmiObject)
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // We cannot copy objects that do not have an underlying IADs ptr.
    //
    if (!_pIADs) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (_pCreds) {
        Creds = *_pCreds;
    }

    //
    // Need to call Refresh with the internal flag. Note that using this
    // flag means that we will go on the wire only if we have to.
    //
    hr = this->Refresh(
             ADSI_INTERNAL_FLAG_GETINFO_AS_NEEDED,
             NULL,
             NULL
             );
    BAIL_ON_FAILURE(hr);

    hr = _pIADs->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    //
    // Now we need to convert the UmiPath to LDAPPath that we can use.
    //
    hr = UrlToLDAPPath(
             pURL,
             &pszLdapPath
             );
    BAIL_ON_FAILURE(hr);

    //
    // We need to split path to parent and common name.
    //
    hr = BuildADsParentPath(
             pszLdapPath,
             &pszParent,
             &pszCommonName
             );
    BAIL_ON_FAILURE(hr);

    hr = CLDAPGenObject::CreateGenericObject(
             pszParent,
             pszCommonName,
             bstrClass,
             Creds,
             ADS_OBJECT_UNBOUND,
             riid, // this is ignored
             (void **) &pUmiObj
             );
    BAIL_ON_FAILURE(hr);

    hr = pUmiObj->QueryInterface(riid, (void **) &pUmiDestObj);
    BAIL_ON_FAILURE(hr);

    //
    // Need to copy the attributes over now.
    //
    hr = this->CopyToHelper(
             this,
             pUmiDestObj,
             0,
             TRUE, // means fail call if property status is not 0
             FALSE // do not copy intf props.
             );
    BAIL_ON_FAILURE(hr);

    *pCopy = pUmiDestObj;

error:

    if (pszLdapPath) {
        FreeADsStr(pszLdapPath);
    }

    if (pszParent) {
        FreeADsStr(pszParent);
    }

    if (pszCommonName) {
        FreeADsStr(pszCommonName);
    }

    if (pUmiObj) {
        pUmiObj->Release();
    }

    if (bstrClass) {
        SysFreeString(bstrClass);
    }

    if (FAILED(hr)) {
        if (!this->_ulErrorStatus) {
            SetLastError(hr);
        }

        if (pUmiDestObj) {
            pUmiDestObj->Release();
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Refresh --- IUmiObject support.
//
// Synopsis:   Refreshes the properties of the object. This calls the
//          underlying LDAP object for the operation.
//
// Arguments:  uFlags      -  UMI_FLAGS_REFERESH_ALL, PARTIAL supported
//                           and ADSI internal flag to implicit GetInfo only
//                           if one is needed (helps clone and copyto).
//             uNameCount  -  Number of attributes to refresh.
//             pszNames    -  Names of attributes to refresh.
//
// Returns:    S_OK on success. Error code otherwise
//
// Modifies:   Underlying property cache.
//
//----------------------------------------------------------------------------
HRESULT CLDAPUmiObject::Refresh(
    ULONG uFlags,
    ULONG uNameCount,
    LPWSTR *pszNames
    )
{
    ULONG   i = 0;
    HRESULT hr = S_OK;
    BOOL fUseGetInfoEx = FALSE;
    DWORD dwGetInfoFlag = TRUE;

    SetLastStatus(0);

    //
    // Only all and partial and the special internal flag. Refresh
    // partial translates to an implicit getinfo in ADSI.
    //
    if ((uFlags != UMI_FLAG_REFRESH_ALL)
        && (uFlags != UMI_FLAG_REFRESH_PARTIAL)
        && (uFlags != ADSI_INTERNAL_FLAG_GETINFO_AS_NEEDED)
        ) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    if (uFlags == UMI_FLAG_REFRESH_PARTIAL) {
        //
        // Cannot specify list of names in this case.
        //
        if (uNameCount != 0) {
            BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_OPERATION);
        }
        dwGetInfoFlag = GETINFO_FLAG_IMPLICIT;
    } 
    else if (uFlags == ADSI_INTERNAL_FLAG_GETINFO_AS_NEEDED) {
        dwGetInfoFlag = GETINFO_FLAG_IMPLICIT_AS_NEEDED;
    }

    if ((uFlags == UMI_FLAG_REFRESH_ALL) && (uNameCount != 0)) {
        fUseGetInfoEx = TRUE;
    }

    if (fUseGetInfoEx) {
        //
        // Build the variant array of strings.
        //
        VARIANT vVar;
        VariantInit(&vVar);

        //
        // Builds a variant array we can use in GetInfoEx
        //
        hr = ADsBuildVarArrayStr(
                 pszNames,
                 (DWORD)uNameCount,
                 &vVar);
        BAIL_ON_FAILURE(hr);

        //
        // Call GetInfoEx to do the actual work.
        //
        hr = _pIADs->GetInfoEx(vVar, 0);
        VariantClear(&vVar);
    } 
    else {
        hr = this->_pCoreObj->GetInfo(dwGetInfoFlag);
        //
        // Since schema and few others do not implement the implicit GetInfo.
        //
        if (FAILED(hr) && hr == E_NOTIMPL) {
            //
            // Should try just an ordinary GetInfo if applicable.
            //
            if (dwGetInfoFlag == GETINFO_FLAG_EXPLICIT) {
                hr = _pIADs->GetInfo();
            }
        }
    }

    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Commit --- IUmiObject support.
//
// Synopsis:   Implements IUmiObject::Commit. Calls SetInfo on WinNT
//             object to commit changes made to the cache. 
//
// Arguments:  uFlags      -   Only 0 for now.
//
// Returns:    S_OK on success. Error code otherwise
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::Commit(ULONG uFlags)
{
    HRESULT hr = S_OK;
    IADsObjOptPrivate *pPrivOpt = NULL;
    DWORD dwFlags;

    SetLastStatus(0);

    if (uFlags > UMI_DONT_COMMIT_SECURITY_DESCRIPTOR) {
        SetLastStatus(UMI_E_INVALID_FLAGS);
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    //
    // If this is set do not commit security descriptor.
    //
    if (uFlags & UMI_DONT_COMMIT_SECURITY_DESCRIPTOR) {
        //
        // The prop manager has to do this cause it has the prop cache.
        //
        hr = _pPropMgr->DeleteSDIfPresent();
        BAIL_ON_FAILURE(hr);
    }

    if (uFlags & UMI_SECURITY_MASK) {
        //
        // Need to make sure that we update the SD 
        // flags on the ADSI object if necessary.
        //
        if (!_pIADs) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
        
        hr = _pIADs->QueryInterface(
                 IID_IADsObjOptPrivate,
                 (void **)&pPrivOpt
                 );
        BAIL_ON_FAILURE(hr);

        dwFlags = uFlags & UMI_SECURITY_MASK;

        hr = pPrivOpt->SetOption(
                 LDAP_SECURITY_MASK,
                 (void *) &dwFlags
                 );
        BAIL_ON_FAILURE(hr);
    }

    hr = _pIADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    if (pPrivOpt) {
        pPrivOpt->Release();
    }

    RRETURN(hr);
}   

//+---------------------------------------------------------------------------
// IUmiPropList methods
//
// These are implemented by invoking the corresponding method in the
// CUmiPropList object that implements object properties. For a description
// of these methods, refer to cpropmgr.cxx
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::Put(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProp
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->Put(
             pszName,
             uFlags,
             pProp
             );

    if (FAILED(hr)) {
        IID iid;
        //
        // Need to update the error status on this object.
        //
        _pPropMgr->GetLastStatus(  // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            ); 
           
         SetLastStatus(ulStatus);
    }
 
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::Get(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->Get(
             pszName,
             uFlags,
             ppProp
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus(
             0,
             &ulStatus,
             iid,
             NULL
             );

        SetLastStatus(ulStatus);
    }

    //
    // No need to map the error as the property manager would have
    // already done that for us.
    //
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::GetAs(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uCoercionType,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->GetAs(
             pszName,
             uFlags,
             uCoercionType,
             ppProp
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus( // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            );

        SetLastStatus(ulStatus);
    }

    //
    // No need to map hr as property manager would have already done that.
    //
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::FreeMemory(
    ULONG uReserved,
    LPVOID pMem
    )
{
    HRESULT hr = S_OK;

    if (uReserved) {
        SetLastStatus(E_INVALIDARG);
        RRETURN(E_INVALIDARG);
    }

    hr = FreeUmiPropertyValues((PUMI_PROPERTY_VALUES) pMem);

    SetLastStatus(hr);
    
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::GetAt(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem 
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->GetAt(
             pszName,
             uFlags,
             uBufferLength,
             pExistingMem
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus( // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            );

         SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::GetProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **pProps
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->GetProps(
             pszNames,
             uNameCount,
             uFlags,
             pProps
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus( // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            );

         SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::PutProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProps
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->PutProps(
             pszNames,
             uNameCount,
             uFlags,
             pProps
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus(
            0,
            &ulStatus,
            iid,
            NULL
            );

        SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

HRESULT CLDAPUmiObject::PutFrom(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->PutFrom(
             pszName,
             uFlags,
             uBufferLength,
             pExistingMem
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;

        _pPropMgr->GetLastStatus(
            0,
            &ulStatus,
            iid,
            NULL
            );

        SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUmiObject::Delete(
    LPCWSTR pszName,
    ULONG uFlags
    )
{
    HRESULT hr = S_OK;
    ULONG   ulStatus = 0;

    SetLastStatus(0);

    if (!_pPropMgr) {
        SetLastStatus(E_NOTIMPL);
        RRETURN(E_NOTIMPL);
    }

    hr = _pPropMgr->Delete(
             pszName,
             uFlags
             );

    if (FAILED(hr)) {
        //
        // Update error on this object appropriately.
        //
        IID iid;
        _pPropMgr->GetLastStatus( // ignore error return
            0,
            &ulStatus,
            iid,
            NULL
            );

        SetLastStatus(ulStatus);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::GetLastStatus --- IUmiBaseObject support.
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. Implements IUmiBaseObject::GetLastStatus().
//
// Arguments: uFlags           -  Reserved. Must be 0 for now.
//            puSpecificStatus -  Returns status code.
//            riid             -  IID requested. Ignored currently.
//            pStatusObj       -  Returns interface requested.
//                                Always returns NULL currently.
//
// Returns:   S_OK on success. Error code otherwise.
//
// Modifies:  *puSpecificStatus to return status code.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if (pStatusObj) {
        *pStatusObj = NULL;
    }

    if (puSpecificStatus) {
        *puSpecificStatus = 0;
    } 
    else {
        RRETURN(E_INVALIDARG);
    }

    if (uFlags) {
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    *puSpecificStatus = _ulErrorStatus;

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::GetInterfacePropList --- IUmiBaseObject method.
//
// Synopsis:   Returns a pointer to the interface property list implementation
//             for the connection object. Implements
//             IUmiBaseObject::GetInterfacePropList().
//
// Arguments:  uFlags     -  Reserved. Must be 0 for now.
//             pPropList  -  Returns pointer to IUmiPropertyList interface
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pPropList to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    HRESULT hr = S_OK;

    if (uFlags) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    if (!pPropList) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    ADsAssert(_pIntfPropMgr);

    //
    // The refCounts are tricky here. When this operation is done,
    // the ref on this object goes up by one, so you will need to
    // releaserefs on the proplist in order to delete this object.
    // This is to prevent the case of a proplist existing without
    // the underlying object (ok for WinNT not for LDAP).
    //
    hr = _pIntfPropMgr->QueryInterface(IID_IUmiPropList, (void **) pPropList);
    
error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::SetLastStatus --- Internal helper routine.
//
// Synopsis:   Sets the status of the last operation. If the status is one
//             of the pre-defined error codes, then the status is just set to
//             0 since we are not adding any value by returning the same
//             status as the error code.
//
// Arguments:  ulStatus     -   Status to be set
//
// Returns:    N/A.
//
// Modifies:   ulStatus member variable.
//
//----------------------------------------------------------------------------
void 
CLDAPUmiObject::SetLastStatus(ULONG ulStatus)
{
    _ulErrorStatus = ulStatus;

    return;
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Open --- IUmiContainer support.
//
// Synopsis:   Opens the object specified by a URL. URL may be native LDAP
//             path or any UMI path.
//
// Arguments:  pURL        -  Pointer to an IUmiURL interface
//             uFlags      -  Reserved. Must be 0 for now.
//             TargetIID   -  Interface requested.
//             ppInterface -  Returns pointer to interface requested.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPUmiObject::Open(
    IUmiURL *pURL,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    HRESULT hr;
    LONG lGenus = UMI_GENUS_INSTANCE;
    LPWSTR pszDN = NULL, pszClass = NULL;
    IDispatch *pDispObj = NULL;

    SetLastStatus(0);
    //
    // Get the class name and the dn from the url.
    //
    if (!pURL || !ppInterface) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    //
    // Helper will split the url txt to useful pieces.
    //
    hr = UrlToClassAndDn(pURL, &pszClass, &pszDN);
    BAIL_ON_FAILURE(hr);

    //
    // At this point if this is a class instance == schema class object,
    // then if the dn is of the format name="something", we should just
    // pass in "something" to the IADsContainer::Open call.
    //
    if (pszClass
        && *pszClass
        && !_wcsicmp(pszClass, L"Class")) {
        //
        // Want to see if this is a class instance.
        //
        if (_pIntfPropMgr) {
            hr = _pIntfPropMgr->GetLongProperty(L"__GENUS", &lGenus);
            if (FAILED(hr)) {
                //
                // We will assume that this is not a class in this case.
                //
                hr = S_OK;
                lGenus = UMI_GENUS_INSTANCE;
            }
        }

        if (pszDN // should always be true
            && lGenus == UMI_GENUS_CLASS
            ) {
            if (!_wcsnicmp(pszDN, L"name=", 5)) {
                //
                // Copy over the new name and replace pszDN with
                // the new name.
                //
                LPWSTR pszReplace;
                pszReplace = AllocADsStr(pszDN + 5);
                
                if (!pszReplace) {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }

                if (pszDN) {
                    FreeADsStr(pszDN);
                }
                
                pszDN = pszReplace;
            }
        }

    }
    
    //
    // Call the IADSContaienr::GetObject to do the remaining work.
    //
    hr = _pIADsContainer->GetObject(pszClass, pszDN, &pDispObj);
    BAIL_ON_FAILURE(hr);

    if (pszClass && *pszClass) {
        //
        // We need to compare the name cause, the GetObject code cannot
        // do that for umi calls.
        //
        hr = VerifyIfClassMatches(
                 pszClass,
                 pDispObj,
                 lGenus
                 );
        BAIL_ON_FAILURE(hr);
    }
             
    hr = pDispObj->QueryInterface(TargetIID, ppInterface);
    BAIL_ON_FAILURE(hr);

error:

    if (pDispObj) {
        pDispObj->Release();
    }

    if (pszClass) {
        FreeADsStr(pszClass);
    }

    if (pszDN) {
        FreeADsStr(pszDN);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}         
    

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Put --- IUmiContainer support.
//
// Synopsis:   Commits an object into the container. Not implemented. 
//
// Arguments:  uFlags       -   Reserved. Must be 0 for now.
//             TargetIID    -   IID of interface pointer requesed.
//             pInterface   -   Output interface pointer.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::PutObject(
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  pInterface
    )   
{
    SetLastStatus(E_NOTIMPL);

    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::DeleteObject --- IUmiContainer support.
//
// Synopsis:   Deletes the object specified by the URL. This calls the
//          underlying container object to do the delete after preparing
//          the arguments suitably. Note that if no class name is specified
//          we will pass in NULL to the IADsContainer::Delete call.
//
// Arguments:  pURL       -   Pointer to URL of object to delete (relative).
//             uFlags     -   Reserved. Must be 0 for now.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   N/A. 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::DeleteObject(
    IUmiURL *pURL,
    ULONG   uFlags
    )
{
    HRESULT hr;
    LPWSTR pszClass = NULL, pszDN = NULL;

    if (!pURL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }
    
    hr = UrlToClassAndDn(pURL, &pszClass, &pszDN);
    BAIL_ON_FAILURE(hr);

    //
    // Call the IADsContainer::Delete entry point to do the work.
    //
    hr = _pIADsContainer->Delete(pszClass, pszDN);

error:

    if (pszClass) {
        FreeADsStr(pszClass);
    }
    
    if (pszDN) {
        FreeADsStr(pszDN);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Create --- IUmiContainer support.
//
// Synopsis:   Creates the object specified by the URL. There always has
//          to be a className for this operation to succeed. The newly
//          created object is not yet on the directory, just local (need
//          to call Commit to create it on the directory).
//
// Arguments:  pURL        -   Pointer to URL of new object (relative).
//             uFlags      -   Reserved. Must be 0 for now.
//             ppNewObj    -   Return ptr for newly created object.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pNewObject to return the IUmiObject interface 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::Create(
    IUmiURL *pURL,
    ULONG   uFlags,
    IUmiObject **ppNewObj
    )
{
    HRESULT hr;
    LPWSTR pszClass = NULL, pszDN = NULL;
    IDispatch *pDispObj = NULL;

    if (!pURL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    hr = UrlToClassAndDn(pURL, &pszClass, &pszDN);
    BAIL_ON_FAILURE(hr);

    hr = _pIADsContainer->Create(pszClass, pszDN, &pDispObj);
    BAIL_ON_FAILURE(hr);

    hr = ((IUnknown *)pDispObj)->QueryInterface(
               IID_IUmiObject,
               (void **) ppNewObj
               );

error:

    if (pDispObj) {
        pDispObj->Release();
    }

    if (pszClass) {
        FreeADsStr(pszClass);
    }

    if (pszDN) {
        FreeADsStr(pszDN);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::Move --- IUmiContainer support.
//
// Synopsis:   Moves a specified object into the container.
//
// Arguments: uFlags      -  Reserved. Must be 0 for now.
//           pOldURL      -  URL of the object to be moved.
//           pNewURL      -  New URL of the object within the container. 
//                           If NULL, then no name change is needed.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   N/A. 
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPUmiObject::Move(
    ULONG   uFlags,
    IUmiURL *pOldURL,
    IUmiURL *pNewURL
    )
{
    HRESULT hr;
    LPWSTR pszOldPath = NULL, pszNewPath = NULL, pszClass = NULL;
    ULONGLONG ullPathType = 0;
    IDispatch *pDispObj = NULL;

    if (!_pIADsContainer) {
        BAIL_ON_FAILURE(hr = E_NOTIMPL);
    }

    if (!pOldURL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // What flags should we support here ?
    //
    if (uFlags) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    hr = UrlToLDAPPath(
             pOldURL,
             &pszOldPath
             );
    BAIL_ON_FAILURE(hr);

    if (pNewURL) {
        //
        // Update code based on the path type.
        // 
        hr = pNewURL->GetPathInfo(0, &ullPathType);
        BAIL_ON_FAILURE(hr);

        if (ullPathType == UMIPATH_INFO_RELATIVE_PATH) {
            hr = UrlToClassAndDn(
                     pNewURL,
                     &pszClass,
                     &pszNewPath
                     );
            BAIL_ON_FAILURE(hr);
        } 
        else {
            //
            // Does this even make sense on a move ???
            //
            hr = UrlToLDAPPath(
                     pNewURL,
                     &pszNewPath
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // At this point both the new and old path will be set correctly.
    //
    hr = _pIADsContainer->MoveHere(
             pszOldPath,
             pszNewPath,
             &pDispObj
             );
    BAIL_ON_FAILURE(hr);


error:
    
    if (pszOldPath) {
        FreeADsStr(pszOldPath);
    }

    if (pszNewPath) {
        FreeADsStr(pszNewPath);
    }

    if (pszClass) {
        FreeADsStr(pszClass);
    }

    if (pDispObj) {
        pDispObj->Release();
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::CreateEnum --- IUmiContainer support.
//
// Synopsis:   Creates an enumerator within a container. The enumerator is
//          an IUmiCursor interface pointer. The caller can optionally set
//          a filter on the cursor and then enumerate the contents of the
//          container. The actual enumeration of the container does
//          not happen in this function. It is deferred to the point
//          when the cursor is used to enumerate the results.
//
// Arguments:  pszEnumContext   -   Not used. Must be NULL.
//             uFlags           -   Reserved. Must be 0 for now.
//             TargetIID        -   Interface requested on enum has to be
//                                 IUmiCursor for now.
//             ppInterface      -   Return value for new enurator.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return the IUmiCursor interface 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::CreateEnum(
    IUmiURL *pszEnumContext,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    HRESULT hr;

    SetLastStatus(0);
    //
    // Validate args.
    //
    if (pszEnumContext || uFlags) {
        //
        // We do not support contexts currently.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (!(TargetIID == IID_IUmiCursor)) {
        //
        // Type of cursor we do not support.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    hr = CUmiCursor::CreateCursor(
             _pIADsContainer,
             TargetIID,
             ppInterface
             );
    
error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::ExecQuery --- IUmiContainer support.
//
// Synopsis:   Executes a query on this container. 
//             
// Arguments:  pQuery      -   Pointer to the query to execute.
//             uFlags      -   Reserved. Must be 0 for now.
//             TargetIID   -   Interface requested.
//             ppInterface -   Return value for the cursor requested.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::ExecQuery(
    IUmiQuery *pQuery,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppResult
    )
{
    HRESULT hr = S_OK;
    CLDAPConObject *pConnection = NULL;
    BSTR bstrADsPath = NULL;

    SetLastStatus(0);

    if (!ppResult 
        || !pQuery
        || !(TargetIID == IID_IUmiCursor)
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    *ppResult = NULL;

    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    hr = this->_pIADs->get_ADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // We want to pre-process this query and verify that it is
    // valid if this is a SQL/WQL style query. This is a little
    // bit of double effort but provides a much easier usage
    // paradigm.
    //
    hr = VerifyIfQueryIsValid(pQuery);
    BAIL_ON_FAILURE(hr);

    hr = CLDAPConObject::CreateConnectionObject(
             &pConnection,
             this->_pLdapHandle
             );
    BAIL_ON_FAILURE(hr);

    hr = CUmiCursor::CreateCursor(
             pQuery,
             pConnection,
             (IUmiObject *) this,
             bstrADsPath,
             _pszLDAPServer,
             _pszLDAPDn,
             *_pCreds,
             _dwPort,
             TargetIID,
             ppResult
             );

    BAIL_ON_FAILURE(hr);


error :

    if (FAILED(hr)) {
        if (*ppResult) {
            ((IUnknown*)(*ppResult))->Release();
        }
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }
    
    if (bstrADsPath) {
        SysFreeString(bstrADsPath);
    }

    if (pConnection) {
        pConnection->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CLDAPUmiObject::GetCLSIDForIID --- ICustomInterfaceFactory.
//
// Synopsis:   Returns the CLSID corresponding to a given interface IID. If
//             the interface is one of the interfaces implemented by the
//             underlying LDAP object, then CLSID_LDAPObject is returned.
//             If the IID is one of the interfaces implemented by an 
//             extension object, then the extension's CLSID is returned. 
//
// Arguments:  riid     -   Interface ID for which we want to find the CLSID.
//             lFlags   -   Reserved. Must be 0.
//             pCLSID   -   Returns the CLSID corresponding to the IID.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return CLSID.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetCLSIDForIID(
    REFIID riid,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pUnknown = NULL;

    SetLastStatus(0);

    if ( (lFlags) || (!pCLSID) ) {
        SetLastStatus(E_INVALIDARG);
        RRETURN(E_INVALIDARG);
    }

    if (_pExtMgr) {
        //
        // Check if there is any extension that supports this IID.
        //
        hr = _pExtMgr->GetCLSIDForIID(
                riid,
                lFlags,
                pCLSID
                );

        if (SUCCEEDED(hr)) {
            RRETURN(S_OK);
        }
    }

    //
    // check if the underlying LDAP object supports this IID
    //
    hr = _pUnkInner->QueryInterface(riid, (void **) &pUnknown);

    if (SUCCEEDED(hr)) {
        pUnknown->Release();

        memcpy(pCLSID, &CLSID_LDAPObject, sizeof(GUID));

        RRETURN(S_OK);
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}
     
//+---------------------------------------------------------------------------
// Function:   GetObjectByCLSID --- IUmiCustomInterfaceFactory support.
//
// Synopsis:   Returns a pointer to a requested interface on the object 
//             specified by a CLSID. The object specified by the CLSID is
//             aggregated by the specified outer unknown. The interface
//             returned is a non-delegating interface on the object.
//
// Arguments:  clsid        -  CLSID of object supporting requested interface.
//             pUnkOuter    -  Aggregating outer unknown.
//             dwClsContext -  Context for running executable code. 
//             riid         -  Interface requested.
//             lFlags       -  Reserved. Must be 0.
//             ppInterface  -  Returns requested interface.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return requested interface
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetObjectByCLSID(
    CLSID clsid,
    IUnknown *pUnkOuter,
    DWORD dwClsContext,
    REFIID riid,
    long lFlags,
    void **ppInterface
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pCurOuterUnk = NULL;

    SetLastStatus(0);

    if ( (lFlags != 0)
        || (!pUnkOuter)
        || (!ppInterface)
        || (dwClsContext != CLSCTX_INPROC_SERVER) ) 
        {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // ensure outer unknown specified is same as what is on the LDAP object
    //
    if (_fOuterUnkSet) {
        pCurOuterUnk = _pCoreObj->GetOuterUnknown();

        if (pCurOuterUnk != pUnkOuter) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }
    }

    //
    // The interface requested has to be IUnknown if there is
    // an outer uknown ptr.
    //
    if (!IsEqualIID(riid, IID_IUnknown)) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }


    if (!IsEqualCLSID(clsid, CLSID_LDAPObject)) {
        //
        // has to be a CLSID of an extension object
        //
        if (_pExtMgr) {

            hr = _pExtMgr->GetObjectByCLSID(
                     clsid,
                     pUnkOuter,
                     riid,
                     ppInterface
                     );
            BAIL_ON_FAILURE(hr);

            //
            // successfully got the interface
            //
            _pCoreObj->SetOuterUnknown(pUnkOuter); 
            _fOuterUnkSet = TRUE;

            RRETURN(S_OK);
        }
        else {
            BAIL_ON_FAILURE(hr = E_INVALIDARG); // bad CLSID
        }
    }

    //
    // CLSID == CLSID_LDAPObject. This has to be an interface on the
    // underlying LDAP object. Check if the LDAP object supports this IID.
    //
    hr = _pUnkInner->QueryInterface(riid, ppInterface);

    if (SUCCEEDED(hr)) {
        //
        // successfully got the interface
        //
        _pCoreObj->SetOuterUnknown(pUnkOuter);
        _fOuterUnkSet = TRUE;

        RRETURN(S_OK);
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetCLSIDForNames --- ICustomInterfaceFactory support.
//
// Synopsis:   Returns the CLSID of the object that supports a specified
//             method/property. Also returns DISPIDs for the property/method.
//
// Arguments:  rgszNames   -  Names to be mapped.
//             cNames      -  Number of names to be mapped.
//             lcid        -  Locale in which to interpret the names.
//             rgDispId    -  Returns DISPID.
//             lFlags      -  Reserved. Must be 0.
//             pCLSID      -  Returns CLSID of object supporting this
//                            property/method.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return the CLSID.
//             *rgDispId to return the DISPIDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetCLSIDForNames(
    LPOLESTR *rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT   hr = S_OK;
    IDispatch *pDispatch = NULL;

    SetLastStatus(0);

    if ( (lFlags != 0) || (!pCLSID) ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (cNames == 0) {
        RRETURN(S_OK);
    }

    if ( (!rgszNames) || (!rgDispId) ) {
        RRETURN(S_OK);
    }

    if (_pExtMgr) {
        //
        // check if there is any extension which supports this IID
        //
        hr = _pExtMgr->GetCLSIDForNames(
                 rgszNames,
                 cNames,
                 lcid,
                 rgDispId,
                 lFlags,
                 pCLSID
                 );
        if (SUCCEEDED(hr)) {
            //
            // successfully got the CLSID and DISPIDs
            //
            RRETURN(S_OK);
        }
    }

    //
    // Check if the underlying LDAP object supports this name 
    //
    hr = _pUnkInner->QueryInterface(IID_IDispatch, (void **) &pDispatch);
    if (FAILED(hr)) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = pDispatch->GetIDsOfNames(
             IID_NULL,
             rgszNames,
             cNames,
             lcid,
             rgDispId
             );
    if (SUCCEEDED(hr)) {
        pDispatch->Release();
        memcpy(pCLSID, &CLSID_LDAPObject, sizeof(GUID));

        RRETURN(S_OK);
    }

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetOption --- IADsObjOptPrivate support.
//
// Synopsis:   Private interface for internal use, this function is used to
//          return the ldap handle if applicable.
//
// Arguments:  dwOption    -  Option being read.
//             pValue      -  Return pointer to hold value of option.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   pValue to return requested option.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::GetOption(
    DWORD dwOption,
    void  *pValue
    )
{
    if (dwOption != LDP_CACHE_ENTRY) {
        RRETURN(E_FAIL);
    } 
    else {
        *((PADSLDP *) pValue) = _pLdapHandle;
        RRETURN(S_OK);
    }
}


//+---------------------------------------------------------------------------
// Function:   SetOption --- IADsObjOptPrivate support.
//
// Synopsis:   Private interface for internal use - NOTIMPL.
//
// Arguments:  dwOption    -  Option being set
//             pValue      -  Value of option being set.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   pValue to return requested option.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUmiObject::SetOption(
    DWORD dwOption,
    void  *pValue
    )
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
// Function:   CopyToHelper --- Helper routine protected scope.
//
// Synopsis:   Copies the attributes on the source object over to the
//          destination object.
//
// Arguments:  pUmiObjSr      ---   Source object.
//             pUmiObjDest    ---   Destination object to copy attributes to.
//             uFlags         ---   Only 0 is supported currently.
//             fMarkAsUpdate  ---   Flag indicating if we should mark the
//                               attributes on dest as update rather than 0.
//             fCopyIntfProps ---   Only false is supported currently.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   pUmiObjDest
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUmiObject::CopyToHelper(
    IUmiObject *pUmiSrcObj,
    IUmiObject *pUmiDestObj,
    ULONG uFlags,
    BOOL fMarkAsUpdate, // default is TRUE
    BOOL fCopyIntfProps // default is FALSE
    )
{
    HRESULT hr = S_OK;
    ULONG ulLastError = S_OK;
    PUMI_PROPERTY_VALUES pUmiPropValsList = NULL;
    DWORD dwCount;


    if (!pUmiSrcObj || !pUmiDestObj || uFlags) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // We need to get the list of properties from the src object.
    //
    hr = pUmiSrcObj->GetProps(
             NULL,
             0,
             UMI_FLAG_GETPROPS_NAMES,
             &pUmiPropValsList
             );
    BAIL_ON_FAILURE(hr);

    for (dwCount = 0; dwCount < pUmiPropValsList->uCount; dwCount++) {
        //
        // We need to walk the list, get each properties name and then
        // for each property get its values from the source and put them
        // on the destination.
        //
        LPWSTR pszTempStr = 
            pUmiPropValsList->pPropArray[dwCount].pszPropertyName;
        PUMI_PROPERTY_VALUES pCurProp = NULL;

        if (!pszTempStr) {
            //
            // Name should never be NULL.
            //
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        //
        // We need to add a check for the SD cause we want to copy that over
        // as a binary blob to prevent unnecessary traffic.
        //

        // Should change the get to use the force flag once it is done.
        //
        hr = pUmiSrcObj->Get(
                 pszTempStr,
                 0,
                 &pCurProp
                 );
        if (FAILED(hr)) {
            pUmiSrcObj->GetLastStatus(0, &ulLastError, IID_IUnknown, NULL);
            BAIL_ON_FAILURE(hr); 
        }

        hr = pUmiDestObj->Put(
                 pszTempStr,
                 0x8000000,
                 pCurProp
                 );

        //
        // Irrespective of this operation success/failure we need to free
        // the contents of pCurProp.
        //
        pUmiSrcObj->FreeMemory(0, (void *) pCurProp);

        if (FAILED(hr)) {
            pUmiDestObj->GetLastStatus(0, &ulLastError, IID_IUnknown, NULL);
            BAIL_ON_FAILURE(hr); 
        }

    } // for each property in the source object.


error:

    if (pUmiPropValsList) {
        pUmiSrcObj->FreeMemory(0, (void *) pUmiPropValsList);
    }

    if (FAILED(hr)) {
        if (ulLastError) {
            SetLastStatus(ulLastError);
        }
        else {
            SetLastStatus(hr);
        }

        hr = MapHrToUmiError(hr);
    }
    
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    VerifyifQueryIsValid --- Helper routine protected scope.
//
// Synopsis:   Copies the attributes on the source object over to the
//          destination object.
//
// Arguments:  pUmiQeury      ---   Query object to validate.
//
// Returns:    S_OK on success. Error code from parser otherwise.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUmiObject::VerifyIfQueryIsValid(
    IUmiQuery *pUmiQuery
    )
{
    HRESULT hr = S_OK;
    ULONG ulLangBufSize = 100 * sizeof(WCHAR);
    ULONG ulQueryBufSize = MAX_PATH * sizeof(WCHAR);
    WCHAR pszLangBuf[100];
    WCHAR szQueryText[MAX_PATH];
    LPWSTR pszQueryText = szQueryText;
    IWbemQuery *pQueryParser = NULL;
    ULONG ulFeatures[] = {
        WMIQ_LF1_BASIC_SELECT,
        WMIQ_LF2_CLASS_NAME_IN_QUERY,
        WMIQ_LF6_ORDER_BY,
        WMIQ_LF24_UMI_EXTENSIONS
    };

    //
    // We need to look at the query language if the language is SQL,
    // then we need to go through and convert the SQL settings to
    // properties on the intfPropList of the query.
    //
    hr = pUmiQuery->GetQuery(
             &ulLangBufSize,
             pszLangBuf,
             &ulQueryBufSize,
             pszQueryText
             );

    if (hr == E_OUTOFMEMORY ) {
        //
        // Means there was insufficient length in the buffers.
        //
        if (ulQueryBufSize > (MAX_PATH * sizeof(WCHAR))) {
            pszQueryText = (LPWSTR) AllocADsMem(
                ulQueryBufSize + sizeof(WCHAR)
                );
            if (pszQueryText) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        hr =  pUmiQuery->GetQuery(
                  &ulLangBufSize,
                  pszLangBuf,
                  &ulQueryBufSize,
                  pszQueryText
                  );
    }
    BAIL_ON_FAILURE(hr);

    if (*pszLangBuf) {
        if (!_wcsicmp(L"SQL", pszLangBuf)
            || !_wcsicmp(L"WQL", pszLangBuf)
             ) {
            //
            // Create the WBEM parser object and verify the query is valid.
            //
            hr = CoCreateInstance(
                     CLSID_WbemQuery,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IWbemQuery,
                     (LPVOID *) &pQueryParser
                     );
            BAIL_ON_FAILURE(hr);

            //
            // Set the query into the parser and try and parse the query.
            //
            hr = pQueryParser->SetLanguageFeatures(
                     0,
                     sizeof(ulFeatures)/sizeof(ULONG),
                     ulFeatures
                     );
            BAIL_ON_FAILURE(hr);

            hr = pQueryParser->Parse(L"SQL", pszQueryText, 0);
            BAIL_ON_FAILURE(hr);
        } // if the language is SQL
    } // if the language has been set
    else {
        //
        // No language ???.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        //
        // For now do not map error as we want error from parser
        // until such time as new error codes are added to umi.
        //        hr = MapHrToUmiError(hr);
    }

    if (pQueryParser) {
        pQueryParser->Release();
    }

    if (pszQueryText && pszQueryText != szQueryText) {
        FreeADsMem(pszQueryText);
    }

    return hr;
}


//+---------------------------------------------------------------------------
// Function:    VerifyIfClassMatches --- Helper routine protected scope.
//
// Synopsis:   Makes sure the class name of the object matches the class
//          asked for.
//
// Arguments:  pszClass      ---   Class requested.
//             pUnk          ---   Ptr to IUnk of Umi Object.
//             lGenus        ---   Is the parent a schema object or not ?
//
// Returns:    S_OK on success. Any failure error code or E_INVALIDARG.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUmiObject::VerifyIfClassMatches(
    LPWSTR pszClass,
    IUnknown * pUnk,
    LONG     lGenus
    )
{
    HRESULT hr = S_OK;
    IUmiObject *pUmiObject = NULL;
    IUmiPropList *pPropList = NULL;
    UMI_PROPERTY_VALUES *pPropVals = NULL;

    //
    // For now the schema will always succeed cause we have no
    // way to verify the parent class. We will fail the GetObject
    // calls on the schema objects with bad paths.
    //
    if (lGenus == UMI_GENUS_CLASS) {
        RRETURN(hr);
    }

    //
    // Get hold of the IUmiObject and then the proplist from it.
    //
    hr = pUnk->QueryInterface(
             IID_IUmiObject,
             (void **) &pUmiObject
             );
    BAIL_ON_FAILURE(hr);

    hr = pUmiObject->GetInterfacePropList(
             0,
             &pPropList
             );
    BAIL_ON_FAILURE(hr);

    hr = pPropList->Get(L"__CLASS", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    //
    // Should have one value that we need to compare
    // 
    if (!pPropVals
        || (pPropVals->uCount != 1)
        || !pPropVals->pPropArray
        || !pPropVals->pPropArray[0].pUmiValue
        || !pPropVals->pPropArray[0].pUmiValue->pszStrValue
        || !pPropVals->pPropArray[0].pUmiValue->pszStrValue[0]
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Failure if the names do not match.
    //
    if (_wcsicmp(
             pPropVals->pPropArray[0].pUmiValue->pszStrValue[0],
             pszClass
             )
        ) {
        hr = E_INVALIDARG;
    }
    
error:

    if (pUmiObject) {
        pUmiObject->Release();
    }

    if (pPropList) {
        pPropList->Release();
    }

    if (pPropVals) {
        FreeMemory(0, (void*)pPropVals);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cschema.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  LDAP
//
//
//  History:   09-01-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#define NT_SCHEMA_CLASS_NAME     TEXT("classSchema")
#define NT_SCHEMA_PROPERTY_NAME  TEXT("attributeSchema")
#define BEGIN_FILTER TEXT("(& (lDAPDisplayName=")
#define END_FILTER TEXT(") (! (isdefunct=TRUE)))")

struct _syntaxmapping
{
    LPTSTR pszSyntax;
    LPTSTR pszOID;
    DWORD  dwOMSyntax;
} aSyntaxMap[] =
{
    { TEXT("Boolean"), TEXT("2.5.5.8"), 1 },
    { TEXT("Integer"), TEXT("2.5.5.9"), 2 },
    { TEXT("OctetString"), TEXT("2.5.5.10"), 4 },

    // The following are in ADS only
    { TEXT("Counter"), TEXT("2.5.5.9"), 2 },
    { TEXT("ADsPath"), TEXT("2.5.5.12"), 64 },
    { TEXT("EmailAddress"), TEXT("2.5.5.12"), 64 },
    { TEXT("FaxNumber"), TEXT("2.5.5.12"), 64 },
    { TEXT("Interval"), TEXT("2.5.5.9"), 2 },
    { TEXT("List"), TEXT("2.5.5.10"), 4 },
    { TEXT("NetAddress"), TEXT("2.5.5.12"), 64 },
    { TEXT("Path"), TEXT("2.5.5.12"), 64 },
    { TEXT("PhoneNumber"), TEXT("2.5.5.12"), 64 },
    { TEXT("PostalAddress"), TEXT("2.5.5.12"), 64 },
    { TEXT("SmallInterval"), TEXT("2.5.5.9"), 2 },
    { TEXT("String"), TEXT("2.5.5.12"), 64 },
    { TEXT("Time"), TEXT("2.5.5.11"), 23 },

    // The following are in NTDS only
    { TEXT("INTEGER8"), TEXT("2.5.5.16"), 65 },
    { TEXT("UTCTime"), TEXT("2.5.5.11"), 23 },
    { TEXT("DN"), TEXT("2.5.5.1"), 127 },
    { TEXT("OID"), TEXT("2.5.5.2"), 6 },
    { TEXT("DirectoryString"), TEXT("2.5.5.12"), 64 },
    { TEXT("PrintableString"), TEXT("2.5.5.5"), 19 },
    { TEXT("CaseIgnoreString"), TEXT("2.5.5.4"), 20 },
    { TEXT("NumericString"), TEXT("2.5.5.6"), 18 },
    { TEXT("IA5String"), TEXT("2.5.5.5"), 22 },
    { TEXT("PresentationAddresses"), TEXT("2.5.5.13"), 127 },
    { TEXT("ORName"), TEXT("2.5.5.7"), 127 },
    { TEXT("DNWithBinary"), TEXT("2.5.5.7"), 127},
    // needs additional information to distinguish from ORName
    { TEXT("AccessPointDN"), TEXT("2.5.5.14"), 127 },
    { TEXT("DNWithString"), TEXT("2.5.5.14"), 127 },
    // needs additional information to distinguish from AccessPointDN
    { TEXT("NTSecurityDescriptor"), TEXT("2.5.5.15"), 66},
    { TEXT("GeneralizedTime"), TEXT("2.5.5.11"), 24},
    { TEXT("Enumeration"), TEXT("2.5.5.9"), 10 },
    { TEXT("ReplicaLink"), TEXT("2.5.5.10"), 127 },
    { TEXT("Sid"), TEXT("2.5.5.17"), 4 },
    { TEXT("CaseExactString"), TEXT("2.5.5.3"), 27 }
};

struct _classmapping
{
    LPTSTR pszLdapClassName;
    LPTSTR pszADsClassName;
    const GUID *pCLSID;
    const GUID *pPrimaryInterfaceGUID;
} aClassMap[] =
{
  { TEXT("user"),  USER_CLASS_NAME,
    &CLSID_LDAPUser, &IID_IADsUser },  // NTDS
  { TEXT("group"),  GROUP_CLASS_NAME,
    &CLSID_LDAPGroup, &IID_IADsGroup },  // NTDS
  { TEXT("localGroup"),  GROUP_CLASS_NAME,
    &CLSID_LDAPGroup, &IID_IADsGroup },    // NTDS
//  { TEXT("computer"), COMPUTER_CLASS_NAME,
//  &CLSID_LDAPComputer, &IID_IADsComputer },  // NTDS
  { TEXT("printQueue"), PRINTER_CLASS_NAME,
    &CLSID_LDAPPrintQueue, &IID_IADsPrintQueue }, // NTDS

  { TEXT("country"), TEXT("Country"),
    &CLSID_LDAPCountry, &IID_IADs },
  { TEXT("locality"), TEXT("Locality"),
    &CLSID_LDAPLocality, &IID_IADsLocality },
  { TEXT("organization"), TEXT("Organization"),
    &CLSID_LDAPO, &IID_IADsO },
  { TEXT("organizationalUnit"), TEXT("Organizational Unit"),
    &CLSID_LDAPOU, &IID_IADsOU },
  { TEXT("domain"), DOMAIN_CLASS_NAME,
    &CLSID_LDAPDomain, &IID_IADsDomain },

  { TEXT("person"), USER_CLASS_NAME,
    &CLSID_LDAPUser, &IID_IADsUser },
  { TEXT("organizationalPerson"), USER_CLASS_NAME,
    &CLSID_LDAPUser, &IID_IADsUser },
  { TEXT("residentialPerson"), USER_CLASS_NAME,
    &CLSID_LDAPUser, &IID_IADsUser },

  { TEXT("groupOfNames"), GROUP_CLASS_NAME,
    &CLSID_LDAPGroup, &IID_IADsGroup },
  { TEXT("groupOfUniqueNames"), GROUP_CLASS_NAME,
    &CLSID_LDAPGroup, &IID_IADsGroup }

  // { TEXT("alias"), TEXT("Alias") },
  // ..other classes in RFC 1788 new
};

SYNTAXINFO g_aLDAPSyntax[] =
{ {  TEXT("Boolean"),               VT_BOOL },
  {  TEXT("Counter"),               VT_I4 },
  {  TEXT("ADsPath"),               VT_BSTR },
  {  TEXT("EmailAddress"),          VT_BSTR },
  {  TEXT("FaxNumber"),             VT_BSTR },
  {  TEXT("Integer"),               VT_I4 },
  {  TEXT("Interval"),              VT_I4 },
  {  TEXT("List"),                  VT_VARIANT },  // VT_BSTR | VT_ARRAY
  {  TEXT("NetAddress"),            VT_BSTR },
  {  TEXT("OctetString"),           VT_VARIANT },  // VT_UI1| VT_ARRAY
  {  TEXT("Path"),                  VT_BSTR },
  {  TEXT("PhoneNumber"),           VT_BSTR },
  {  TEXT("PostalAddress"),         VT_BSTR },
  {  TEXT("SmallInterval"),         VT_I4 },
  {  TEXT("String"),                VT_BSTR },
  {  TEXT("Time"),                  VT_DATE },
  {  TEXT("Integer8"),              VT_DISPATCH },
  {  TEXT("UTCTime"),               VT_DATE },
  {  TEXT("DN"),                    VT_BSTR },
  {  TEXT("OID"),                   VT_BSTR },
  {  TEXT("DirectoryString"),       VT_BSTR },
  {  TEXT("PrintableString"),       VT_BSTR },
  {  TEXT("CaseIgnoreString"),      VT_BSTR },
  {  TEXT("NumericString"),         VT_BSTR },
  {  TEXT("IA5String"),             VT_BSTR },
  {  TEXT("PresentationAddresses"), VT_BSTR },
  {  TEXT("ORName"),                VT_BSTR },
  {  TEXT("DNWithBinary"),          VT_DISPATCH },
  {  TEXT("AccessPointDN"),         VT_BSTR },
  {  TEXT("DNWithString"),          VT_DISPATCH },
  {  TEXT("NTSecurityDescriptor"),  VT_DISPATCH },
  {  TEXT("ObjectSecurityDescriptor"), VT_DISPATCH },
  {  TEXT("PresentationAddress"), VT_BSTR },
  {  TEXT("GeneralizedTime"),       VT_DATE },
  //
  // We do not support these
  //  {  TEXT("Enumeration")},
  //  {  TEXT("ReplicaLink") },
  //  {  TEXT("Sid") },
  {  TEXT("CaseExactString"),       VT_BSTR}
};

struct _OIDToNamemapping
{
    LPTSTR pszAttributeTypeOID;
    LPTSTR pszFriendlyName;
} aOIDtoNameMap[] =
{
    { TEXT("1.2.840.113556.1.4.903"),        TEXT("DNWithBinary") },
    { TEXT("1.2.840.113556.1.4.904"),        TEXT("DNWithString") },
    // DnString also has the same OID as above
    { TEXT("1.2.840.113556.1.4.905"),        TEXT("CaseIgnoreString") },
    { TEXT("1.2.840.113556.1.4.906"),        TEXT("INTEGER8") },
    { TEXT("1.2.840.113556.1.4.907"),        TEXT("ObjectSecurityDescriptor") },
    // the type is ORName a type of string -> mapped to string.
    { TEXT("1.2.840.113556.1.4.1221"),       TEXT("ORName") },
    // the type is Undefined syntax in the server, so we are defaulting.
    { TEXT("1.2.840.113556.1.4.1222"),       TEXT("Undefined") },
    { TEXT("1.2.840.113556.1.4.1362"),       TEXT("CaseExactString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.10"), TEXT("CertificatePair") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.11"), TEXT("CountryString") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.12"), TEXT("DN") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.13"), TEXT("DataQualitySyntax") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.14"), TEXT("DeliveryMethod") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.15"), TEXT("DirectoryString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.19"), TEXT("DSAQualitySyntax") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.2"),  TEXT("AccessPointDN") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.21"), TEXT("EmhancedGuide") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.22"), TEXT("FacsimileTelephoneNumber") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.23"), TEXT("Fax") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.24"), TEXT("GeneralizedTime") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.25"), TEXT("Guide") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.26"), TEXT("IA5String") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.27"), TEXT("INTEGER") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.28"), TEXT("JPEG") },// not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.3"),  TEXT("AttributeTypeDescription") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.32"), TEXT("MailPreference") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.33"), TEXT("ORAddress") },  // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.34"), TEXT("NameAndOptionalUID") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.36"), TEXT("NumericString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.37"), TEXT("ObjectClassDescription") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.38"), TEXT("OID") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.39"), TEXT("OtherMailBox") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.4"),  TEXT("Audio") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.40"), TEXT("OctetString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.41"), TEXT("PostalAddress") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.43"), TEXT("PresentationAddress") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.44"), TEXT("PrintableString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.5"),  TEXT("OctetString") }, // not in ours we map to Octet
    { TEXT("1.3.6.1.4.1.1466.115.121.1.50"), TEXT("TelephoneNumber") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.51"), TEXT("TeletexTerminalIdentifier") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.52"), TEXT("TelexNumber") }, // not in ours
    { TEXT("1.3.6.1.4.1.1466.115.121.1.53"), TEXT("UTCTime") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.6"),  TEXT("BitString") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.7"),  TEXT("Boolean") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.8"),  TEXT("Certificate") },
    { TEXT("1.3.6.1.4.1.1466.115.121.1.9"),  TEXT("CertificateList") },
};


DWORD g_cLDAPSyntax = (sizeof(g_aLDAPSyntax)/sizeof(g_aLDAPSyntax[0]));


typedef struct _classnamelist {

    LPTSTR pszClassName;
    _classnamelist *pNext;

} CLASSNAME_LIST, *PCLASSNAME_LIST;


BOOL
GetSyntaxOID(
    LPTSTR  pszSyntax,
    LPTSTR  *ppszOID,
    DWORD   *pdwOMSyntax
)
{
    for ( int i = 0; i < ARRAY_SIZE(aSyntaxMap); i++ )
    {
        if (_tcsicmp(pszSyntax, aSyntaxMap[i].pszSyntax) == 0 )
        {
            *ppszOID = aSyntaxMap[i].pszOID;
            *pdwOMSyntax = aSyntaxMap[i].dwOMSyntax;
            return TRUE;
        }
    }

    *ppszOID = NULL;
    return FALSE;
}


BOOL
GetFriendlyNameFromOID(
    LPTSTR  pszOID,
    LPTSTR  *ppszFriendlyName
)
{
    HRESULT hr = S_OK;

    for ( int i = 0; i < ARRAY_SIZE(aOIDtoNameMap); i++ )
    {
        if ( _tcsicmp( pszOID, aOIDtoNameMap[i].pszAttributeTypeOID ) == 0 )
        {
            hr = ADsAllocString(
                     aOIDtoNameMap[i].pszFriendlyName,
                      ppszFriendlyName
                     );

            if (SUCCEEDED(hr))
                return TRUE;
            else
                return FALSE;
        }
    }

    *ppszFriendlyName = NULL;
    return FALSE;
}


HRESULT
MakeVariantFromStringArray(
    BSTR *bstrList,
    VARIANT *pvVariant
);

HRESULT
MakeVariantFromPropStringTable(
    int *propList,
    LDAP_SCHEMA_HANDLE hSchema,
    VARIANT *pvVariant
);

HRESULT
ConvertSafeArrayToVariantArray(
    VARIANT   varSafeArray,
    PVARIANT *ppVarArray,
    PDWORD    pdwNumVariants
);

/* No Longer needed
HRESULT
DeleteSchemaEntry(
    LPTSTR pszADsPath,
    LPTSTR pszRelativeName,
    LPTSTR pszClassName,
    LPTSTR pszSubSchemaSubEntry,
    CCredentials& Credentials
);
*/

HRESULT
BuildSchemaLDAPPathAndGetAttribute(
    IN  LPTSTR pszParent,
    IN  LPTSTR pszClass,
    IN  LPTSTR pszSubSchemaSubEntry,
    IN  BOOL   fNew,
    IN  CCredentials& Credentials,
    IN  LPTSTR pszAttribs[],
    OUT LPWSTR * ppszSchemaLDAPServer,
    OUT LPWSTR * ppszSchemaLDAPDn,
    IN OUT PADS_LDP *pLd,
    OUT LDAPMessage **ppRes
);

HRESULT
BuildSchemaLDAPPath(
    LPTSTR pszParent,
    LPTSTR pszClass,
    LPTSTR pszSubSchemaSubEntry,
    LPWSTR * ppszSchemaLDAPServer,
    LPWSTR * ppszSchemaLDAPDn,
    BOOL   fNew,
    ADS_LDP   **pld,
    CCredentials& Credentials
);

HRESULT
MakePropArrayFromVariant(
    VARIANT vProp,
    SCHEMAINFO *hSchema,
    int **pOIDs,
    DWORD *pNumOfOids
);

HRESULT
MakePropArrayFromStringArray(
    LPTSTR *aValues,
    DWORD  nCount,
    SCHEMAINFO *hSchema,
    int **pOIDs,
    DWORD *pNumOfOids
);

HRESULT
SchemaGetPrimaryInterface(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR pszClassName,
    GUID **ppPrimaryInterfaceGUID,
    GUID **ppCLSID
);


STDMETHODIMP
makeUnionVariantFromLdapObjects(
    LDAPOBJECTARRAY ldapSrcObjects1,
    LDAPOBJECTARRAY ldapSrcObjects2,
    VARIANT FAR * pvPossSuperiors
    );

STDMETHODIMP
addStringIfAbsent(
    BSTR addString,
    BSTR *strArray,
    PDWORD dwArrIndx
    );

//
// This functions puts the named string property into the cache
// of the object as a CaseIgnoreString. It is meant for usage from
// umi to put the simulated name property on schema objects.
//
HRESULT
HelperPutStringPropertyInCache(
    LPWSTR pszName,
    LPWSTR pszStrProperty,
    CCredentials &Credentials,
    CPropertyCache *pPropCache
    )
{
    HRESULT hr = E_NOTIMPL;
    DWORD dwIndex = 0;
    VARIANT varBstr;
    LDAPOBJECTARRAY ldapDestObjects;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);
    VariantInit(&varBstr);

    hr = ADsAllocString(pszStrProperty, &(varBstr.bstrVal));
    BAIL_ON_FAILURE(hr);

    varBstr.vt = VT_BSTR;
    //
    // Conver the variant to LDAP objects we can cache.
    //
    hr = VarTypeToLdapTypeCopyConstruct(
             NULL, //ServerName not needed here,
             Credentials,
             LDAPTYPE_CASEIGNORESTRING,
             &varBstr,
             1,
             &ldapDestObjects
             );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //
    hr = pPropCache->findproperty(
                         pszName,
                         &dwIndex
                         );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //
    if (FAILED(hr)) {
        hr = pPropCache->addproperty( pszName );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //
    hr = pPropCache->putproperty(
             pszName,
             PROPERTY_INIT,
             LDAPTYPE_CASEIGNORESTRING,
             ldapDestObjects
             );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varBstr);
    LdapTypeFreeLdapObjects( &ldapDestObjects );

    RRETURN_EXP_IF_ERR(hr);
}

/******************************************************************/
/*  Class CLDAPSchema
/******************************************************************/

DEFINE_IDispatch_Implementation(CLDAPSchema)
DEFINE_IADs_Implementation(CLDAPSchema)

CLDAPSchema::CLDAPSchema()
    : _pDispMgr( NULL ),
      _pPropertyCache(NULL)
{
    VariantInit( &_vFilter );
    VariantInit( &_vHints );

    _szServerPath[0] = 0;

    ENLIST_TRACKING(CLDAPSchema);
}

CLDAPSchema::~CLDAPSchema()
{
    VariantClear( &_vFilter );
    VariantClear( &_vHints );

    delete _pDispMgr;
    delete _pPropertyCache;

}

HRESULT
CLDAPSchema::CreateSchema(
    BSTR   bstrParent,
    BSTR   bstrName,
    LPTSTR pszServerPath,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPSchema FAR *pSchema = NULL;
    HRESULT hr = S_OK;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateSchemaObject( &pSchema, Credentials );
    BAIL_ON_FAILURE(hr);

    _tcscpy( pSchema->_szServerPath, pszServerPath );

    hr = ADsObject(bstrParent, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pSchema->_dwPort = pObjectInfo->PortNumber;

    FreeObjectInfo(pObjectInfo);
    pObjectInfo = NULL;

    hr = pSchema->InitializeCoreObject(
             bstrParent,
             bstrName,
             SCHEMA_CLASS_NAME,
             CLSID_LDAPSchema,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    //
    // See if we need to create the Umi object.
    //
    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        hr = ((CCoreADsObject*)pSchema)->InitUmiObject(
                   IntfPropsSchema,
                   pSchema->_pPropertyCache,
                   (IADs*) pSchema,
                   (IADs*) pSchema,
                   riid,
                   ppvObj,
                   &(pSchema->_Credentials),
                   pSchema->_dwPort
                   );

        BAIL_ON_FAILURE(hr);


        hr = HelperPutStringPropertyInCache(
                 L"Name",
                 bstrName,
                 pSchema->_Credentials,
                 pSchema->_pPropertyCache
                 );
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);
    }

    hr = pSchema->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    FreeObjectInfo(pObjectInfo);

    *ppvObj = NULL;
    delete pSchema;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPSchema::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CLDAPSchema::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::GetInfo(THIS)
{
    HRESULT hr;
    hr = LDAPRefreshSchema();
    RRETURN_EXP_IF_ERR(hr);
}

//
// Helper function for Umi - defined in CCoreADsObject.
//
STDMETHODIMP
CLDAPSchema::GetInfo(DWORD dwFlags)
{
    if (dwFlags == GETINFO_FLAG_EXPLICIT) {
        RRETURN(GetInfo());
    } 

    //
    // All other cases we just say OK cause there is no way to go.
    //
    RRETURN(S_OK);
}

/* IADsContainer methods */

STDMETHODIMP
CLDAPSchema::get_Count(long FAR* retval)
{
    HRESULT hr;

    DWORD nNumOfClasses;
    DWORD nNumOfProperties;

    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = LdapGetSchemaObjectCount(
             _szServerPath,
             &nNumOfClasses,
             &nNumOfProperties,
             _Credentials,
             _dwPort
             );

    if ( SUCCEEDED(hr))
        *retval = nNumOfClasses + nNumOfProperties + g_cLDAPSyntax;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    if ( !pVar )
        RRETURN(E_ADS_BAD_PARAMETER);

    HRESULT hr;
    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vFilter );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy( &_vFilter, &Var );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    if ( !pVar )
        RRETURN(E_ADS_BAD_PARAMETER);

    HRESULT hr;
    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vHints );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr;
    VariantClear(&_vHints);

    hr = VariantCopy( &_vHints, &Var );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    DWORD dwBufferSize = 0;
    TCHAR *pszBuffer = NULL;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    dwBufferSize = ( _tcslen(_ADsPath) + _tcslen(RelativeName)
                     + 2  ) * sizeof(TCHAR);   // includes "/"

    pszBuffer = (LPTSTR) AllocADsMem( dwBufferSize );

    if ( pszBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _tcscpy(pszBuffer, _ADsPath);
    _tcscat(pszBuffer, TEXT("/"));
    _tcscat(pszBuffer, RelativeName);

    hr = ::GetObject(
                pszBuffer,
                _Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    if ( pszBuffer )
        FreeADsMem( pszBuffer );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT *penum = NULL;

    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CLDAPSchemaEnum::Create( (CLDAPSchemaEnum **)&penum,
                                   _ADsPath,
                                   _szServerPath,
                                   _vFilter,
                                   _Credentials
                                   );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface( IID_IUnknown, (VOID FAR* FAR*)retval );
    BAIL_ON_FAILURE(hr);

    if ( penum )
        penum->Release();

    RRETURN(hr);

error:

    if ( penum )
        delete penum;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    HRESULT hr = S_OK;
    LDAP_SCHEMA_HANDLE hSchema = NULL;

    hr = SchemaOpen( _szServerPath, &hSchema, _Credentials, _dwPort );
    BAIL_ON_FAILURE(hr);

    //
    // We can only create "Class","Property" here, "Syntax" is read-only
    //


    if (  ( _tcsicmp( ClassName, CLASS_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, NT_SCHEMA_CLASS_NAME ) == 0 )
       )
    {
        //
        // Now, create the class
        //
        hr = CLDAPClass::CreateClass(
                         _ADsPath,
                         hSchema,
                         RelativeName,
                         NULL,
                         _Credentials,
                         ADS_OBJECT_UNBOUND,
                         IID_IUnknown,
                         (void **) ppObject );
    }
    else if (  ( _tcsicmp( ClassName, PROPERTY_CLASS_NAME ) == 0 )
            || ( _tcsicmp( ClassName, NT_SCHEMA_PROPERTY_NAME ) == 0 )
            )
    {
        hr = CLDAPProperty::CreateProperty(
                         _ADsPath,
                         hSchema,
                         RelativeName,
                         NULL,
                         _Credentials,
                         ADS_OBJECT_UNBOUND,
                         IID_IUnknown,
                         (void **) ppObject );

    }
    else
    {
        hr = E_ADS_BAD_PARAMETER;
    }

error:

    if ( hSchema )
        SchemaClose( &hSchema );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::Delete(THIS_ BSTR bstrClassName, BSTR bstrRelativeName )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::CopyHere(THIS_ BSTR SourceName,
                       BSTR NewName,
                       IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::MoveHere(THIS_ BSTR SourceName,
                       BSTR NewName,
                       IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    LPTSTR pszSubSchemaSubEntry = NULL;
    LPTSTR pszSchemaRoot = NULL;

    //
    // For folks who know now what they do.
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    VariantInit( pvProp );

    // Temporary hack
    if ( _tcsicmp( bstrName, TEXT("NTSchemaPath")) == 0 )
    {
        hr = LdapGetSubSchemaSubEntryPath(
                 _szServerPath,
                 &pszSubSchemaSubEntry,
                 _Credentials,
                 _dwPort
                 );
        BAIL_ON_FAILURE(hr);

        if ( pszSubSchemaSubEntry == NULL )   // not NTDS server
        {
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
        }

        // the _tcschr is to get rid of "CN=Aggregate"
        pszSchemaRoot = _tcschr(pszSubSchemaSubEntry, TEXT(','));

        if ( pszSchemaRoot == NULL )   // not NTDS server
        {
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
        }

        hr = ADsAllocString( pszSchemaRoot + 1,
                             &(pvProp->bstrVal));
        BAIL_ON_FAILURE(hr);

        pvProp->vt = VT_BSTR;
    }
    else 
    {
        hr = E_NOTIMPL;
    }

error:

    if ( pszSubSchemaSubEntry )
        FreeADsStr( pszSubSchemaSubEntry );

    if ( FAILED(hr))
        VariantClear( pvProp );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSchema::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSchema::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CLDAPSchema::AllocateSchemaObject(
    CLDAPSchema FAR * FAR * ppSchema,
    CCredentials& Credentials
    )
{
    CLDAPSchema FAR *pSchema = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR *pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pSchema = new CLDAPSchema();
    if ( pSchema == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pSchema,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *) pSchema,
                            DISPID_NEWENUM );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                            (CCoreADsObject FAR *) pSchema,
                            (IGetAttributeSyntax *) pSchema,
                            &pPropertyCache
                            );
    BAIL_ON_FAILURE(hr);

    pSchema->_pPropertyCache = pPropertyCache;
    pSchema->_Credentials = Credentials;
    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSchema;
    delete pPropertyCache;

    RRETURN(hr);

}

HRESULT
CLDAPSchema::LDAPRefreshSchema(THIS)
{
    HRESULT hr = S_OK;

    //
    // Make the old schema obsolete.
    // We cannot delete the old schema since other objects might have
    // references to it.
    //

    hr = LdapMakeSchemaCacheObsolete(
             _szServerPath,
             _Credentials,
             _dwPort
             );

    RRETURN_EXP_IF_ERR(hr);
}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPSchema::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if ((_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED)
        && !_wcsicmp(L"Name", szPropertyName)) {
        *pdwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
    } 
    else {
        hr = E_ADS_PROPERTY_NOT_FOUND;
    }

    RRETURN_EXP_IF_ERR(hr);
}

/******************************************************************/
/*  Class CLDAPClass
/******************************************************************/

DEFINE_IDispatch_Implementation(CLDAPClass)
DEFINE_IADs_Implementation(CLDAPClass)

CLDAPClass::CLDAPClass()
    : _pDispMgr( NULL ),
      _pPropertyCache( NULL ),
      _bstrCLSID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 ),
      _hSchema( NULL ),
      _pClassInfo( NULL ),
      _fNTDS( TRUE ),
      _pszLDAPServer(NULL),
      _pszLDAPDn(NULL),
      _ld( NULL ),
      _fLoadedInterfaceInfo(FALSE)
{
    ENLIST_TRACKING(CLDAPClass);
}

CLDAPClass::~CLDAPClass()
{
    delete _pDispMgr;

    delete _pPropertyCache;

    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    if ( _hSchema ) {
        SchemaClose( &_hSchema );
        _hSchema = NULL;
    }

    if ( _pszLDAPServer ) {
        FreeADsStr( _pszLDAPServer );
    }

    if (_pszLDAPDn) {
        FreeADsStr(_pszLDAPDn);

    }


    if ( _ld ) {
        LdapCloseObject( _ld );
        _ld = NULL;
    }

}

HRESULT      
CLDAPClass::CreateClass(
    BSTR   bstrParent,
    LDAP_SCHEMA_HANDLE hSchema,
    BSTR   bstrName,
    CLASSINFO *pClassInfo,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    BOOL fUmiCall = FALSE;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    VARIANT var;

    VariantInit(&var);

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateClassObject(Credentials,  &pClass );
    BAIL_ON_FAILURE(hr);

    //
    // Some extra things need to be done if the call is from umi.
    //
    fUmiCall = Credentials.GetAuthFlags() & ADS_AUTH_RESERVED;

    pClass->_pClassInfo = pClassInfo;
    SchemaAddRef( hSchema );
    pClass->_hSchema = hSchema;

    if ( pClassInfo )  // an existing class
    {
    
        if ( pClassInfo->pszHelpFileName )
        {
            hr = ADsAllocString( pClassInfo->pszHelpFileName,
                                 &pClass->_bstrHelpFileName );
        }

        pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;

        hr = put_BSTR_Property( pClass, TEXT("governsID"), pClassInfo->pszOID);

        if ( SUCCEEDED(hr))
        {
            hr = put_LONG_Property( pClass, TEXT("objectClassCategory"),
                                    pClassInfo->dwType );
            BAIL_ON_FAILURE(hr);

            VariantInit( &var );
            hr = MakeVariantFromPropStringTable( pClassInfo->pOIDsMustContain,
                                                 pClass->_hSchema,
                                                 &var );
            BAIL_ON_FAILURE(hr);
            hr = put_VARIANT_Property( pClass, TEXT("mustContain"), var );
            BAIL_ON_FAILURE(hr);
            if (fUmiCall) {
                //
                // Need to add this to the cache as mandatoryProperties.
                //
                hr = put_VARIANT_Property(
                         pClass,
                         TEXT("mandatoryProperties"),
                         var
                         );
                BAIL_ON_FAILURE(hr);

                //
                // We also need a dummy property called Name.
                //
                hr = put_BSTR_Property(
                         pClass,
                         TEXT("Name"),
                         bstrName
                         );
                BAIL_ON_FAILURE(hr);
            }

            VariantClear( &var );

            hr = MakeVariantFromPropStringTable( pClassInfo->pOIDsMayContain,
                                                 pClass->_hSchema,
                                                 &var );
            BAIL_ON_FAILURE(hr);
            hr = put_VARIANT_Property( pClass, TEXT("mayContain"), var );
            BAIL_ON_FAILURE(hr);
            if (fUmiCall) {
                //
                // Again need to add as optionalProperties.
                //
                hr = put_VARIANT_Property(
                         pClass,
                         TEXT("optionalProperties"),
                         var
                         );
                BAIL_ON_FAILURE(hr);
            }

            VariantClear( &var );

            hr = MakeVariantFromStringArray( pClassInfo->pOIDsSuperiorClasses,
                                             &var );
            BAIL_ON_FAILURE(hr);

            hr = put_VARIANT_Property( pClass, TEXT("subClassOf"), var );
            BAIL_ON_FAILURE(hr);
            VariantClear( &var );

            hr = MakeVariantFromStringArray( pClassInfo->pOIDsAuxClasses,
                                             &var );
            BAIL_ON_FAILURE(hr);

            hr = put_VARIANT_Property( pClass, TEXT("auxiliaryClass"), var );
            BAIL_ON_FAILURE(hr);
            VariantClear( &var );

            pClass->_pPropertyCache->ClearAllPropertyFlags();

            pClass->_fNTDS = TRUE;
        }
        else
        {
            pClass->_fNTDS = FALSE;
        }
    }


    hr = ADsObject(bstrParent, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pClass->_dwPort = pObjectInfo->PortNumber;

    FreeObjectInfo(pObjectInfo);
    pObjectInfo = NULL;

    hr = pClass->InitializeCoreObject(
             bstrParent,
             bstrName,
             CLASS_CLASS_NAME,
             CLSID_LDAPClass,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    //
    // At this point update the info in the property cache
    //

    pClass->_pPropertyCache->SetObjInformation(
                                     &(pClass->_Credentials),
                                     pClass->_pszLDAPServer,
                                     pClass->_dwPort
                                     );

    BAIL_ON_FAILURE(hr);

    //
    // If this is a umi call we need to return umi object.
    //
    if (fUmiCall) {
        hr = ((CCoreADsObject*)pClass)->InitUmiObject(
                   IntfPropsSchema,
                   pClass->_pPropertyCache,
                   (IADs *) pClass,
                   (IADs *) pClass,
                   riid,
                   ppvObj,
                   &(pClass->_Credentials),
                   pClass->_dwPort,
                   pClass->_pszLDAPServer,
                   pClass->_pszLDAPDn
                   );
        
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);
    }

    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pClass;

    VariantClear(&var);
    FreeObjectInfo(pObjectInfo);

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPClass::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUmiHelperPrivate)) {
        *ppv = (IADsUmiHelperPrivate FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPClass::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CLDAPClass::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    BOOL fChanged = FALSE;

    if ( !_fNTDS )
        RRETURN(E_NOTIMPL);

    if ( GetObjectState() == ADS_OBJECT_UNBOUND )
    {
        hr = LDAPCreateObject();
        BAIL_ON_FAILURE(hr);

        fChanged = TRUE;

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }
    else
    {
        hr = LDAPSetObject( &fChanged );
        BAIL_ON_FAILURE(hr);
    }

    //
    //  Need to refresh the schema
    //

    if ( SUCCEEDED(hr) && fChanged )
        hr = LDAPRefreshSchema();

error:

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPClass::LDAPSetObject( BOOL *pfChanged )
{
    HRESULT hr = S_OK;

    BOOL fUpdated = FALSE;
    BOOL fUpdateMustContain = FALSE;
    BOOL fUpdateMayContain = FALSE;

    VARIANT var;
    int *pOIDs = NULL;
    DWORD nNumOfOids = 0;

    LDAPModW **aMod = NULL;
    DWORD dwNumOfMods = 0;
    DWORD dwNumOfModsNeedFreeing = 0;

    *pfChanged = FALSE;

    hr = _pPropertyCache->IsPropertyUpdated( TEXT("mustContain"), &fUpdated);
    BAIL_ON_FAILURE(hr);

    if ( fUpdated )
    {
        VariantInit(&var);
        hr = get_VARIANT_Property( this, TEXT("mustContain"), &var );
        BAIL_ON_FAILURE(hr);

        hr = MakePropArrayFromVariant( var,
                                       (SCHEMAINFO *) _hSchema,
                                       &pOIDs,
                                       &nNumOfOids );
        BAIL_ON_FAILURE(hr);

        hr = FindModifications( pOIDs,
                                nNumOfOids,
                                TEXT("mustContain"),
                                &aMod,
                                &dwNumOfMods );
        BAIL_ON_FAILURE(hr);

        // This flag needs to be cleared temporarily so that
        // LDAPMarshallProperties2 below will not try to update
        // this property. We will reset the flag right later.

        hr = _pPropertyCache->ClearPropertyFlag( TEXT("mustContain"));
        BAIL_ON_FAILURE(hr);

        fUpdateMustContain = TRUE;

        VariantClear(&var);
        FreeADsMem( pOIDs );
        pOIDs = NULL;
    }

    hr = _pPropertyCache->IsPropertyUpdated( TEXT("mayContain"), &fUpdated);
    BAIL_ON_FAILURE(hr);

    if ( fUpdated )
    {
        VariantInit(&var);
        hr = get_VARIANT_Property( this, TEXT("mayContain"), &var );
        BAIL_ON_FAILURE(hr);

        hr = MakePropArrayFromVariant( var,
                                       (SCHEMAINFO *) _hSchema,
                                       &pOIDs,
                                       &nNumOfOids );
        BAIL_ON_FAILURE(hr);

        hr = FindModifications( pOIDs,
                                nNumOfOids,
                                TEXT("mayContain"),
                                &aMod,
                                &dwNumOfMods );
        BAIL_ON_FAILURE(hr);

        // This flag needs to be cleared temporarily so that
        // LDAPMarshallProperties2 below will not try to update
        // this property. We will reset the flag later on.

        hr = _pPropertyCache->ClearPropertyFlag( TEXT("mayContain"));
        BAIL_ON_FAILURE(hr);

        fUpdateMayContain = TRUE;

        VariantClear(&var);
        FreeADsMem( pOIDs );
        pOIDs = NULL;
    }

    dwNumOfModsNeedFreeing = dwNumOfMods;

    hr = _pPropertyCache->LDAPMarshallProperties2(
                            &aMod,
                            &dwNumOfMods
                            );
    BAIL_ON_FAILURE(hr);

    if ( aMod == NULL )  // There are no changes that needs to be modified
        RRETURN(S_OK);

    //
    // Reset the flags so that if LdapModifyS fails, they are still flagged
    // as needed to be updated.
    //
    if ( fUpdateMustContain )
    {
        hr = _pPropertyCache->SetPropertyFlag( TEXT("mustContain"),
                                               PROPERTY_UPDATE );
        BAIL_ON_FAILURE(hr);
    }

    if ( fUpdateMayContain )
    {
        hr = _pPropertyCache->SetPropertyFlag( TEXT("mayContain"),
                                               PROPERTY_UPDATE );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Send the request to the server
    //

    if (_pszLDAPDn == NULL )
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pClassInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );


        BAIL_ON_FAILURE(hr);
    }

    hr = LdapModifyS(
                   _ld,
                   _pszLDAPDn,
                   aMod
                   );
    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

    *pfChanged = TRUE;

error:

    VariantClear(&var);

    if ( pOIDs )
        FreeADsMem( pOIDs );

    if (aMod) {

        for ( DWORD i = 0; i < dwNumOfModsNeedFreeing; i++ )
        {
            FreeADsMem((*aMod)[i].mod_values);
        }

        if ( *aMod )
            FreeADsMem( *aMod );

        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPClass::LDAPCreateObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    DWORD dwIndex = 0;
    VARIANT v;
    BOOL fNTSecDes = FALSE;
    SECURITY_INFORMATION NewSeInfo;

    //
    // Get the LDAP path of the schema entry
    //
    if (_pszLDAPDn == NULL )
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pClassInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );

        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("objectClass"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {

        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = NT_SCHEMA_CLASS_NAME;

        hr = Put( TEXT("objectClass"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("cn"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _Name;

        hr = Put( TEXT("cn"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("lDAPDisplayName"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _Name;

        hr = Put( TEXT("lDAPDisplayName"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("objectClassCategory"), &dwIndex)
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_I4;
        V_I4(&v) = CLASS_TYPE_STRUCTURAL;

        hr = Put( TEXT("objectClassCategory"), v );
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( _ld == NULL )
    {
        hr = LdapOpenObject(
                       _pszLDAPServer,
                       _pszLDAPDn,
                       &_ld,
                       _Credentials,
                       _dwPort
                       );

    BAIL_ON_FAILURE(hr);

    }

    hr = LdapAddS(
                    _ld,
                    _pszLDAPDn,
                    aMod
                    );

    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );
        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPClass::LDAPRefreshSchema(THIS)
{
    HRESULT hr = S_OK;
    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszLDAPDn = NULL;
    DWORD dwPort = 0;

    //
    // Get the server name
    //

    hr = BuildLDAPPathFromADsPath2(
             _Parent,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Make the old schema obsolete so we will get the new schema next
    // time we asked for it.
    // We cannot delete the old schema since other objects might have
    // references to it.
    //
    hr = LdapMakeSchemaCacheObsolete(
             pszLDAPServer,
             _Credentials,
             _dwPort
             );
    BAIL_ON_FAILURE(hr);

error:

    if (pszLDAPServer) {

        FreeADsStr(pszLDAPServer);
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::GetInfo(THIS)
{
    HRESULT hr = S_OK;
    VARIANT var;
    BOOL fUmiCall = FALSE;

    LPWSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwPort = 0;

    VariantInit(&var);
    if ( GetObjectState() == ADS_OBJECT_UNBOUND )
        RRETURN(E_ADS_OBJECT_UNBOUND);

    //
    // Update the umicall flag - we need to add items to prop cache
    // if the call is from Umi.
    //
    fUmiCall = _Credentials.GetAuthFlags() & ADS_AUTH_RESERVED;
    
    //
    // Get the server name
    //

    hr = BuildLDAPPathFromADsPath2(
             _Parent,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);


    //
    // AjayR - 04-05-99 do not understand why this is done
    // I do not think you need to obsolete the cache on the
    // GetInfo for a class - for the schema container yes.
    //
    hr = LdapMakeSchemaCacheObsolete(
             pszLDAPServer,
             _Credentials,
             dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Release the original schema info
    //
    SchemaClose( &_hSchema );

    //
    // Get the new schema info
    //
    hr = SchemaOpen(
                pszLDAPServer,
                &_hSchema,
                _Credentials,
                _dwPort             // IsGCNamespace(_Parent)
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find the new class info
    //

    hr = SchemaGetClassInfo(
             _hSchema,
             _Name,
             &_pClassInfo );

    BAIL_ON_FAILURE( hr );

    if ( _pClassInfo == NULL )
    {
        // Class name not found, set error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    _pPropertyCache->flushpropertycache();

    hr = put_BSTR_Property( this, TEXT("governsID"), _pClassInfo->pszOID);
    BAIL_ON_FAILURE(hr);

    hr = put_LONG_Property( this, TEXT("objectClassCategory"),
                            _pClassInfo->dwType );
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromPropStringTable( _pClassInfo->pOIDsMustContain,
                                         _hSchema, &var );
    BAIL_ON_FAILURE(hr);
    hr = put_VARIANT_Property( this, TEXT("mustContain"), var );
    BAIL_ON_FAILURE(hr);
    if (fUmiCall) {
        //
        // Add as mandatoryProperties to cache.
        //
        hr = put_VARIANT_Property( this, TEXT("mandatoryProperties"), var );
        BAIL_ON_FAILURE(hr);

        hr = put_BSTR_Property( this, TEXT("Name"), this->_Name);
        BAIL_ON_FAILURE(hr);
    }
    VariantClear( &var );

    hr = MakeVariantFromPropStringTable( _pClassInfo->pOIDsMayContain,
                                         _hSchema, &var );
    BAIL_ON_FAILURE(hr);
    hr = put_VARIANT_Property( this, TEXT("mayContain"), var );
    BAIL_ON_FAILURE(hr);
    if (fUmiCall) {
        //
        // Add to the cache as optionalProperties.
        //
        hr = put_VARIANT_Property( this, TEXT("optionalProperties"), var );
        BAIL_ON_FAILURE(hr);
    }
    VariantClear( &var );

    hr = MakeVariantFromStringArray( _pClassInfo->pOIDsSuperiorClasses, &var );
    BAIL_ON_FAILURE(hr);

    hr = put_VARIANT_Property( this, TEXT("subClassOf"), var );
    BAIL_ON_FAILURE(hr);
    VariantClear( &var );

    hr = MakeVariantFromStringArray( _pClassInfo->pOIDsAuxClasses, &var );
    BAIL_ON_FAILURE(hr);

    hr = put_VARIANT_Property( this, TEXT("auxiliaryClass"), var );
    BAIL_ON_FAILURE(hr);
    VariantClear( &var );

    if (_fNTDS) {
        //
        // Read the extra NTDS specific schema properties.
        //
        hr = GetNTDSSchemaInfo(TRUE);
        BAIL_ON_FAILURE(hr);
    }

    _pPropertyCache->ClearAllPropertyFlags();
    _pPropertyCache->setGetInfoFlag();

error:

    if (pszLDAPServer) {
        FreeADsStr(pszLDAPServer);
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    VariantClear(&var);

    RRETURN_EXP_IF_ERR(hr);   // All current information are in _pClassInfo
}

//
// This routine is called only when the server is AD.
//
HRESULT
CLDAPClass::GetNTDSSchemaInfo(
    BOOL fForce
    )
{
    HRESULT hr = S_OK;
    LPTSTR aStrings[] = {
        TEXT("cn"),
        TEXT("displaySpecification"),
        TEXT("schemaIDGUID"),
        TEXT("possibleInferiors"),
        TEXT("rDNAttid"),
        TEXT("possSuperiors"),
        TEXT("systemPossSuperiors"),
        NULL
    };

    LDAPMessage *res = NULL;


    if (_pszLDAPDn == NULL) {
        //
        // Need to get the dn for this object and also 
        // the attributes we are interested in.
        //
        hr = BuildSchemaLDAPPathAndGetAttribute(
                 _Parent,
                 _Name,
                 ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                 _pClassInfo == NULL,
                 _Credentials,
                 aStrings,
                 &_pszLDAPServer,
                 &_pszLDAPDn,
                 &_ld,
                 &res
                 );

    }
    else {
        //
        // Looks like we just need the attributes in this case.
        //
        hr = LdapSearchS(
                 _ld,
                 _pszLDAPDn,
                 LDAP_SCOPE_BASE,
                 L"(objectClass=*)",
                 aStrings,
                 FALSE,
                 &res
                 );
    }
        
    BAIL_ON_FAILURE(hr);

    //
    // If we succeeded we should unmarshall properties into the cache.
    //
    hr = _pPropertyCache->LDAPUnMarshallProperties(
             _pszLDAPServer,
             _ld,
             res,
             fForce,
             _Credentials
             );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();

error:

    if (res) {
        LdapMsgFree(res);
    }

    RRETURN(hr);
}

//
// Helper function for Umi - defined in CCoreADsObject.
//
STDMETHODIMP
CLDAPClass::GetInfo(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    
    if (dwFlags ==  GETINFO_FLAG_EXPLICIT) {
        RRETURN(GetInfo());
    } 
    else {
        //
        // Read NTDS info if this is not an implicit as needed call.
        // That is this just a regular implicit GetInfo.
        //
        if (_fNTDS
            && dwFlags != GETINFO_FLAG_IMPLICIT_AS_NEEDED
            ) {
            //
            // Read the extra NTDS specific schema properties.
            //
            hr = GetNTDSSchemaInfo(FALSE);
        }   
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPClass::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    DWORD dwStatus = 0;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For folks who know now what they do.
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    if ( ldapSrcObjects.dwCount == 1 ) {

        hr = LdapTypeToVarTypeCopy(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects.pLdapObjects,
                 dwSyntaxId,
                 pvProp
                 );
    } else {

        hr = LdapTypeToVarTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects,
                 dwSyntaxId,
                 pvProp
                 );
    }
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vDefProp;

    VariantInit(&vDefProp);

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    hr = SchemaGetSyntaxOfAttribute( _hSchema, bstrName, &dwSyntaxId );
    if (FAILED(hr)) {
        //
        // Need to see if this is either mandatoryProperties or
        // OptionalProperties that we special case for Umi Objects.
        //
        if (!_wcsicmp(L"mandatoryProperties", bstrName)
            || !_wcsicmp(L"optionalProperties", bstrName)
            ) {
            dwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
            hr = S_OK;
        }
    }

    BAIL_ON_FAILURE(hr);

    if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
    (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        // returns E_FAIL if *pvProp is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;                 
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    } else {

        //
        // If pvProp is a reference to a fundamental type, we
        // have to derefernce it once.
        //
        if (V_ISBYREF(pvProp)) {
            hr = VariantCopyInd(&vDefProp, pvProp);
            BAIL_ON_FAILURE(hr);
            pvProp = &vDefProp;
        }
        dwNumValues = 1;
    }


#if 0
    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    //
    // check if the variant maps to the syntax of this property
    //

    if ( dwNumValues > 0 )
    {
        hr = VarTypeToLdapTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 dwSyntaxId,
                 pvProp,
                 dwNumValues,
                 &ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //
    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );

    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vDefProp);

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPClass::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    DWORD dwStatus = 0;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For those who know no not what they do
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    hr = LdapTypeToVarTypeCopyConstruct(
             _pszLDAPServer,
             _Credentials,
             ldapSrcObjects,
             dwSyntaxId,
             pvProp
             );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = PROPERTY_UPDATE;
        break;

    default:
       RRETURN(hr = E_ADS_BAD_PARAMETER);

    }

    hr = SchemaGetSyntaxOfAttribute( _hSchema, bstrName, &dwSyntaxId );
    BAIL_ON_FAILURE(hr);

    if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

#if 0
    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    if ( dwFlags != PROPERTY_DELETE )
    {

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pvProp) ==  (VT_VARIANT|VT_ARRAY))) {

            hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
            // returns E_FAIL if *pvProp is invalid
            if (hr == E_FAIL)
                hr = E_ADS_BAD_PARAMETER;           
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // check if the variant maps to the syntax of this property
        //

        if ( dwNumValues > 0 )
        {
            hr = VarTypeToLdapTypeCopyConstruct(
                     _pszLDAPServer,
                     _Credentials,
                     dwSyntaxId,
                     pvProp,
                     dwNumValues,
                     &ldapDestObjects
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //
    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );

    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

/* IADsClass methods */


HRESULT
CLDAPClass::LoadInterfaceInfo(void)
{
    HRESULT hr = S_OK;
    BSTR bstrTmp = NULL;

    if ( _pClassInfo )  {
    
        GUID *pPrimaryInterfaceGUID = NULL;
        GUID *pCLSID = NULL;

        hr = SchemaGetPrimaryInterface( _hSchema,
                                        _Name,
                                        &pPrimaryInterfaceGUID,
                                        &pCLSID );

        if ( pPrimaryInterfaceGUID == NULL )
            pPrimaryInterfaceGUID = (GUID *) &IID_IADs;

        //
        // Set the primary interface string
        //

        hr = StringFromCLSID((REFCLSID)*(pPrimaryInterfaceGUID),
                             &bstrTmp );
        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( bstrTmp,
                             &_bstrPrimaryInterface);
        BAIL_ON_FAILURE(hr);

        CoTaskMemFree(bstrTmp);
        bstrTmp = NULL;

        if ( pCLSID )
        {
            //
            // Set the CLSID string
            //

            hr = StringFromCLSID( (REFCLSID) *(pCLSID),
                                   &bstrTmp );
            BAIL_ON_FAILURE(hr);

            hr = ADsAllocString( bstrTmp,
                                   &_bstrCLSID );

            BAIL_ON_FAILURE(hr);

            CoTaskMemFree(bstrTmp);
            bstrTmp = NULL;
        }
    }

error:

    if ( bstrTmp != NULL )
        CoTaskMemFree(bstrTmp);

    RRETURN(hr);
}


STDMETHODIMP
CLDAPClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    HRESULT hr;

    if ( !pbstrGUID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if (!_fLoadedInterfaceInfo) {
        hr = LoadInterfaceInfo();
        BAIL_ON_FAILURE(hr);
        
        _fLoadedInterfaceInfo = TRUE;
    }
    
    hr = ADsAllocString(
                 _bstrPrimaryInterface? _bstrPrimaryInterface : TEXT(""),
                 pbstrGUID );

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    HRESULT hr;

    if ( !pbstrCLSID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if (!_fLoadedInterfaceInfo) {
        hr = LoadInterfaceInfo();
        BAIL_ON_FAILURE(hr);
        
        _fLoadedInterfaceInfo = TRUE;
    }

    hr = ADsAllocString( _bstrCLSID? _bstrCLSID: TEXT(""), pbstrCLSID );

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPClass::get_OID( THIS_ BSTR FAR *retval )
{
    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr;

    if ( _fNTDS )
    {
        GET_PROPERTY_BSTR( this, governsID );
    }
    else if ( _pClassInfo )
    {
        hr = ADsAllocString( _pClassInfo->pszOID?
                                   _pClassInfo->pszOID : TEXT(""), retval );
    RRETURN_EXP_IF_ERR(hr);
    }
    else
    {
        hr = ADsAllocString( TEXT(""), retval );
    RRETURN_EXP_IF_ERR(hr);
    }
}

STDMETHODIMP
CLDAPClass::put_OID( THIS_ BSTR bstrOID )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR(E_NOTIMPL);

    HRESULT hr = put_BSTR_Property( this, TEXT("governsID"), bstrOID );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if ( !pfAbstract )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr = S_OK;
    long lClassType = CLASS_TYPE_STRUCTURAL;  // by default

    if ( _fNTDS )
    {
        hr = get_LONG_Property( this, TEXT("objectClassCategory"),
                                &lClassType );
        BAIL_ON_FAILURE(hr);
    }
    else if ( _pClassInfo )
    {
        lClassType = _pClassInfo->dwType;
    }

    *pfAbstract = lClassType == CLASS_TYPE_ABSTRACT ?
                      VARIANT_TRUE : VARIANT_FALSE;

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    long lClassType;
    HRESULT hr = get_LONG_Property( this, TEXT("objectClassCategory"),
                                    &lClassType );
    if ( SUCCEEDED(hr))
    {
        if (  ( fAbstract && lClassType == CLASS_TYPE_ABSTRACT )
           || ( !fAbstract && lClassType != CLASS_TYPE_ABSTRACT )
           )
        {
            RRETURN(S_OK);  // Nothing to set
        }
    }

    hr = put_LONG_Property( (IADs *) this,
                            TEXT("objectClassCategory"),
                            fAbstract? CLASS_TYPE_ABSTRACT
                                     : CLASS_TYPE_STRUCTURAL );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary )
{
    if ( !pfAuxiliary )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr = S_OK;
    long lClassType = CLASS_TYPE_STRUCTURAL;  // by default

    if ( _fNTDS )
    {
        hr = get_LONG_Property( this, TEXT("objectClassCategory"),
                                &lClassType );
        BAIL_ON_FAILURE(hr);
    }
    else if ( _pClassInfo )
    {
        lClassType = _pClassInfo->dwType;
    }

    *pfAuxiliary = lClassType == CLASS_TYPE_AUXILIARY ?
                       VARIANT_TRUE : VARIANT_FALSE;

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    long lClassType = CLASS_TYPE_STRUCTURAL;
    HRESULT hr = get_LONG_Property( this, TEXT("objectClassCategory"),
                                    &lClassType );
    if ( SUCCEEDED(hr))
    {
        if (  ( fAuxiliary && lClassType == CLASS_TYPE_AUXILIARY )
           || ( !fAuxiliary && lClassType != CLASS_TYPE_AUXILIARY )
           )
        {
            RRETURN(S_OK);  // Nothing to set
        }
    }

    hr = put_LONG_Property( (IADs *) this,
                            TEXT("objectClassCategory"),
                            fAuxiliary? CLASS_TYPE_AUXILIARY
                                      : CLASS_TYPE_STRUCTURAL );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_MandatoryProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    if ( _fNTDS )
    {
        GET_PROPERTY_VARIANT( this, mustContain );
    }
    else if ( _pClassInfo )
    {
        hr = MakeVariantFromPropStringTable( _pClassInfo->pOIDsMustContain,
                                             _hSchema,
                                             retval );
    }
    else
    {
        hr = MakeVariantFromStringArray( NULL,
                                         retval );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("mustContain"),
                                       vMandatoryProperties );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    if ( _fNTDS )
    {
        GET_PROPERTY_VARIANT( this, mayContain );
    }
    else if ( _pClassInfo )
    {
        hr = MakeVariantFromPropStringTable( _pClassInfo->pOIDsMayContain,
                                             _hSchema,
                                             retval );
    }
    else
    {
        hr = MakeVariantFromStringArray( NULL,
                                         retval );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("mayContain"),
                                       vOptionalProperties );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_NamingProperties( THIS_ VARIANT FAR *pvNamingProperties )
{
    HRESULT hr = S_OK;

    if ( !pvNamingProperties )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    VariantInit( pvNamingProperties );

    hr = get_VARIANT_Property( this, TEXT("rDNAttId"), pvNamingProperties );

    if ( SUCCEEDED(hr) )
        RRETURN(hr);

    hr = get_NTDSProp_Helper( TEXT("rDNAttId"), pvNamingProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("rDNAttId"),
                                       vNamingProperties );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_DerivedFrom( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    if ( _fNTDS )
    {
        GET_PROPERTY_VARIANT( this, subClassOf );
    }
    else if ( _pClassInfo )
    {
        hr = MakeVariantFromStringArray( _pClassInfo->pOIDsSuperiorClasses,
                                         retval );
    }
    else
    {
        hr = MakeVariantFromStringArray( NULL,
                                         retval );
    }

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("subClassOf"),
                                       vDerivedFrom );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    if ( _fNTDS )
    {
        GET_PROPERTY_VARIANT( this, auxiliaryClass );
    }
    else if ( _pClassInfo )
    {
        hr = MakeVariantFromStringArray( _pClassInfo->pOIDsAuxClasses,
                                         retval );
    }
    else
    {
        hr = MakeVariantFromStringArray( NULL,
                                         retval );
    }

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("auxiliaryClass"),
                                       vAuxDerivedFrom );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors)
{
    HRESULT hr = S_OK;
    VARIANT vSysPossSuperiors;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    // Boolean values used to indicate if the values exist
    BOOL fpossSuperiors = FALSE;
    BOOL fsysPossSuperiors = FALSE;

    // Used in case we need a union of the values
    LDAPOBJECTARRAY ldapSrcObjects1;
    LDAPOBJECTARRAY ldapSrcObjects2;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects1);
    LDAPOBJECTARRAY_INIT(ldapSrcObjects2);

    VariantInit(&vSysPossSuperiors);

    if ( !pvPossSuperiors )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    VariantInit( pvPossSuperiors );

    hr = get_VARIANT_Property( this, TEXT("possSuperiors"), pvPossSuperiors );

    if ( SUCCEEDED(hr) ){
        fpossSuperiors = TRUE;
    }

    hr = get_VARIANT_Property(
             this, TEXT("systemPossSuperiors"), &vSysPossSuperiors
             );
    if (SUCCEEDED(hr)) {
        fsysPossSuperiors = TRUE;
    }

    if (!fpossSuperiors) {
        hr = get_NTDSProp_Helper( TEXT("possSuperiors"), pvPossSuperiors );
        if (SUCCEEDED(hr)) {
            fpossSuperiors = TRUE;
        }
    }

    if (!fsysPossSuperiors) {
        hr = get_NTDSProp_Helper(
                 TEXT("systemPossSuperiors"), &vSysPossSuperiors
                 );
        if (SUCCEEDED(hr)) {
            fsysPossSuperiors = TRUE;
        }
    }

    // Now if both are true, we need to do a union
    if (fpossSuperiors && fsysPossSuperiors) {
        // need to do the union
        // it is easier for me to handle strings in the ldap format
        // than to handle them as variants as there are helpers available
        // for that already
        hr = _pPropertyCache->unboundgetproperty(
                                  L"possSuperiors",
                                  &dwSyntaxId,
                                  &dwStatus,
                                  &ldapSrcObjects1
                                  );

        // No compatibility -- below it resets hr

        if (hr == E_FAIL) {
            hr = S_OK;
        }

        BAIL_ON_FAILURE(hr);

        hr = _pPropertyCache->unboundgetproperty(
                                  L"systemPossSuperiors",
                                  &dwSyntaxId,
                                  &dwStatus,
                                  &ldapSrcObjects2
                                  );

        // No compatibility -- below it resets hr

        if (hr == E_FAIL) {
            hr = S_OK;
        }

        BAIL_ON_FAILURE(hr);

        // Clear them as we no longer need the data here
        VariantClear(pvPossSuperiors);
        VariantClear(&vSysPossSuperiors);

        hr = makeUnionVariantFromLdapObjects(
                 ldapSrcObjects1,
                 ldapSrcObjects2,
                 pvPossSuperiors
                 );

        BAIL_ON_FAILURE(hr);

    }
    else if (fpossSuperiors || fsysPossSuperiors) {
        // return the appropriate value in the variant
        if (fsysPossSuperiors) {
            hr = VariantCopy(pvPossSuperiors, &vSysPossSuperiors);
            VariantClear(&vSysPossSuperiors);
            BAIL_ON_FAILURE(hr);
        }
    }

error:

    LdapTypeFreeLdapObjects(&ldapSrcObjects1);
    LdapTypeFreeLdapObjects(&ldapSrcObjects2);

    // this will make sure we handle fall through correctly

    if (SUCCEEDED(hr)) {
        RRETURN(hr);
    }

    VariantClear(pvPossSuperiors);
    VariantClear(&vSysPossSuperiors);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors)
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_Property( this, TEXT("possSuperiors"),
                                       vPossSuperiors);

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::get_Containment( THIS_ VARIANT *pvContainment )
{
    HRESULT hr = S_OK;
    LPTSTR *aValues = NULL;

    if ( !pvContainment )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    VariantInit( pvContainment );

    //
    // This call will fetch possibleInferiors if necessary using
    // an implicit GetInfo. 
    //
    hr = GetEx(L"possibleInferiors", pvContainment);
   
    if (FAILED(hr) && 
        (hr == E_ADS_PROPERTY_NOT_FOUND)
        ) {
        //
        // In this case we need to return an empty array 
        //
        hr = MakeVariantFromStringArray(
                 aValues,
                 pvContainment
                 );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_Containment( THIS_ VARIANT vContainment)
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{

    HRESULT hr = S_OK;
    VARIANT vVar;
    
    if (!pfContainer) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    *pfContainer = VARIANT_FALSE;

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    VariantInit(&vVar);

    //
    // We now cache possibleInferiors as part of a GetInfo call.
    //
    hr = GetEx(L"possibleInferiors", &vVar);

    if (SUCCEEDED(hr)) {
        //
        // Need to see if there were any values and not just NULL.
        //
        if (V_VT(&vVar) != (VT_VARIANT | VT_ARRAY)) {
            //
            // Not the expected result has
            //
            *pfContainer = VARIANT_FALSE;
        } 
        else {
            //
            // Need to see how many elements are there.
            //
            LONG lnLBound = 0, lnUBound = 0;

            hr = SafeArrayGetUBound(
                     V_ARRAY(&vVar),
                     1,
                     &lnUBound
                     );
            if (SUCCEEDED(hr)) {
                hr = SafeArrayGetLBound(
                         V_ARRAY(&vVar),
                         1,
                         &lnLBound
                         );
                if (SUCCEEDED(hr)) {
                    //
                    // Check the length and make sure it is not 0 vals.
                    //
                    if ((lnUBound - lnLBound) + 1) {
                        *pfContainer = VARIANT_TRUE;
                    }
                } 
                else {
                    //
                    // Default to not container in this case
                    //  
                    *pfContainer = VARIANT_FALSE;
                }
            }

            hr = S_OK;
        }

        // we need to release the memory in vVar
        VariantClear(&vVar);
        
    } 
    else if (FAILED(hr) 
             && (hr == E_ADS_PROPERTY_NOT_FOUND)
             ) {
        *pfContainer = VARIANT_FALSE;
        hr = S_OK;
    } 
    
    //
    // Anything other than these and we should return the
    // appropriate hr back.
    //

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    if ( !pbstrHelpFileName )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr;
    hr = ADsAllocString( _bstrHelpFileName?
                               _bstrHelpFileName: TEXT(""),
                               pbstrHelpFileName );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

#if 0
    RRETURN( ADsReAllocString( &_bstrHelpFileName,
                                 bstrHelpFile? bstrHelpFile: TEXT("") ));
#endif
}

STDMETHODIMP
CLDAPClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

#if 0
    _lHelpFileContext = lHelpContext;
    RRETURN(S_OK);
#endif
}

STDMETHODIMP
CLDAPClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CLDAPClass::AllocateClassObject(
    CCredentials& Credentials,
    CLDAPClass FAR * FAR * ppClass
    )
{

    CLDAPClass FAR  *pClass = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR *pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pClass = new CLDAPClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                            (CCoreADsObject FAR *) pClass,
                            (IGetAttributeSyntax *) pClass,
                            &pPropertyCache
                            );

    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(pPropertyCache);

    pClass->_Credentials = Credentials;
    pClass->_pDispMgr = pDispMgr;
    pClass->_pPropertyCache = pPropertyCache;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT CLDAPClass::FindModifications(
    int    *pOIDs,
    DWORD  nNumOfOids,
    LPTSTR pszPropName,
    LDAPModW ***aMods,
    DWORD  *pdwNumOfMods
    )
{
    HRESULT hr = S_OK;
    int *pOIDsOld = _tcsicmp(pszPropName, TEXT("mustContain")) == 0
                        ? _pClassInfo->pOIDsMustContain
                        : _pClassInfo->pOIDsMayContain;
    DWORD i = 0;
    DWORD j = 0;
    DWORD k = 0;

    BOOL fReadProperty = FALSE;
    int *pOIDsCurrent = NULL;
    DWORD nNumOfOidsCurrent = 0;
    BOOL fFound = FALSE;

    LPTSTR *aValuesAdd = NULL;
    LPTSTR *pTemp = NULL;
    DWORD nValuesAdd = 0;
    DWORD nValuesAddTotal = 10;
    LPTSTR *aValuesRemove = NULL;
    DWORD nValuesRemove = 0;
    DWORD nValuesRemoveTotal = 10;
    DWORD nIndex = 0;
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPTSTR aStrings[] = {
        TEXT("cn"),
        pszPropName,
        NULL
    };


    aValuesAdd = (LPTSTR *) AllocADsMem(sizeof(LPTSTR) * nValuesAddTotal );
    if ( aValuesAdd == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    aValuesRemove = (LPTSTR *) AllocADsMem(sizeof(LPTSTR) * nValuesRemoveTotal);
    if ( aValuesRemove == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We need to find the differences between the properties that needs to be
    // set and the properties that is currently on the server.
    //

    while ((pOIDs[j] != -1) || (pOIDsOld[k] != -1))
    {
        if ( pOIDs[j] == pOIDsOld[k] )
        {
            // No changes here
            j++; k++;
        }
        else if (  ( pOIDsOld[k] == -1 )
                || ( ( pOIDs[j] != -1 ) && ( pOIDs[j] < pOIDsOld[k] ))
                )
        {
            //
            // A new property has been added.
            //
            if ( nValuesAdd == nValuesAddTotal )
            {
                pTemp = (LPTSTR *) ReallocADsMem( aValuesAdd,
                                          sizeof(LPTSTR) * nValuesAddTotal,
                                          sizeof(LPTSTR) * nValuesAddTotal * 2 );
                if ( pTemp == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
                
                aValuesAdd = pTemp;
                pTemp = NULL;
                nValuesAddTotal *= 2;
            }

            nIndex = (((SCHEMAINFO *)_hSchema)->aPropertiesSearchTable[pOIDs[j]]).nIndex;

            aValuesAdd[nValuesAdd++] =
                (((SCHEMAINFO *)_hSchema)->aProperties[nIndex]).pszPropertyName;

            j++;
        }
        else  // ( pOIDs[j] == -1 || pOIDs[j] > pOIDsOld[k] )
        {
            // Some property has been removed, we need to read the current class
            // set of "mayContain" or "mustContain" to make sure we
            // aren't removing any "systemMustContain" or "systemMayContain"
            // and we are not trying to remove any parent classes
            // may/mustContain

            if ( !fReadProperty )
            {
                LPTSTR *aValues = NULL;
                int nCount = 0;

                if ( _pszLDAPDn == NULL )
                {
                    hr = BuildSchemaLDAPPathAndGetAttribute(
                             _Parent,
                             _Name,
                             ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                             _pClassInfo == NULL,
                             _Credentials,
                             aStrings,
                             &_pszLDAPServer,
                             &_pszLDAPDn,
                             &_ld,
                             &res
                             );
                    BAIL_ON_FAILURE(hr);

                    hr = LdapFirstEntry(
                                _ld,
                                res,
                                &e
                                );
                    BAIL_ON_FAILURE(hr);

                    hr = LdapGetValues(
                                _ld,
                                e,
                                pszPropName,
                                &aValues,
                                &nCount
                                );
                }

                else
                {
                    hr = LdapReadAttribute(
                               _pszLDAPServer,
                               _pszLDAPDn,
                               pszPropName,
                               &aValues,
                               &nCount,
                               _Credentials,
                               _dwPort
                               );
                }

                if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) )
                {
                    hr = S_OK;
                }
                BAIL_ON_FAILURE(hr);

                fReadProperty = TRUE;

                if ( nCount > 0 )
                {
                    hr = MakePropArrayFromStringArray( aValues,
                                                       nCount,
                                                       (SCHEMAINFO *) _hSchema,
                                                       &pOIDsCurrent,
                                                       &nNumOfOidsCurrent );
                    LdapValueFree( aValues );
                    BAIL_ON_FAILURE(hr);
                }
            }

            //
            // See if we can find the property that we want to remove from.
            // We don't need to reset i since both arrays are sorted.
            //
            for ( fFound = FALSE; i < nNumOfOidsCurrent; i++ )
            {
                 if ( pOIDsOld[k] == pOIDsCurrent[i] )
                 {
                     fFound = TRUE;
                     break;
                 }
                 else if ( pOIDsOld[k] < pOIDsCurrent[i] )
                 {
                     // Both arrays are sorted, so we can break here
                     break;
                 }
            }

            if ( nNumOfOidsCurrent == 0 || !fFound )
            {
                int err = NO_ERROR;

                // This property is not in "mustContain" or "mayContain",
                // so nothing can be removed

                hr = E_ADS_SCHEMA_VIOLATION;
                BAIL_ON_FAILURE(hr);
            }

            //
            // Modify the request to remove the property here
            //
            if ( nValuesRemove == nValuesRemoveTotal )
            {
                pTemp = (LPTSTR *) ReallocADsMem( aValuesRemove,
                                     sizeof(LPTSTR) * nValuesRemoveTotal,
                                     sizeof(LPTSTR) * nValuesRemoveTotal * 2 );
                if ( pTemp == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                aValuesRemove = pTemp;
                pTemp = NULL;
                nValuesRemoveTotal *= 2;
            }

            nIndex = (((SCHEMAINFO *)_hSchema)->aPropertiesSearchTable[pOIDsOld[k]]).nIndex;

            aValuesRemove[nValuesRemove++] =
                (((SCHEMAINFO *)_hSchema)->aProperties[nIndex]).pszPropertyName;

            k++;
        }
    }

    if ( nValuesAdd == 0 )
    {
        FreeADsMem( aValuesAdd );
        aValuesAdd = NULL;
    }

    if ( nValuesRemove == 0 )
    {
        FreeADsMem( aValuesRemove );
        aValuesRemove = NULL;
    }

    if ( aValuesAdd || aValuesRemove )
    {
        hr = AddModifyRequest(
                 aMods,
                 pdwNumOfMods,
                 pszPropName,
                 aValuesAdd,
                 aValuesRemove );
    }

error:

    if ( pOIDsCurrent )
        FreeADsMem( pOIDsCurrent );

    if (res)
        LdapMsgFree(res);

    if ( FAILED(hr))
    {
        if ( aValuesAdd )
            FreeADsMem( aValuesAdd );

        if ( aValuesRemove )
            FreeADsMem( aValuesRemove );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT CLDAPClass::AddModifyRequest(
    LDAPModW ***aMods,
    DWORD    *pdwNumOfMods,
    LPTSTR   pszPropName,
    LPTSTR   *aValuesAdd,
    LPTSTR   *aValuesRemove
    )
{
    HRESULT hr = S_OK;
    LDAPModW *aModsBuffer = NULL;
    DWORD j = 0;
    DWORD nCount = 0;

    if ( aValuesAdd != NULL )
        nCount++;

    if ( aValuesRemove != NULL )
        nCount++;

    if ( nCount == 0 )
        RRETURN(S_OK);

    if ( *aMods == NULL )
    {
        *aMods = (LDAPModW **) AllocADsMem( (nCount + 1) * sizeof(LDAPModW *));

        if ( *aMods == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aModsBuffer = (LDAPModW *) AllocADsMem( nCount * sizeof(LDAPModW));

        if ( aModsBuffer == NULL )
        {
            FreeADsMem( *aMods );
            *aMods = NULL;
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    else
    {
        LDAPModW **aModsTemp = NULL;

        aModsTemp = (LDAPModW **) AllocADsMem(
                        (*pdwNumOfMods + nCount + 1) * sizeof(LDAPModW *));

        if ( aModsTemp == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aModsBuffer = (LDAPModW *) AllocADsMem(
                          (*pdwNumOfMods + nCount) * sizeof(LDAPModW));

        if ( aModsBuffer == NULL )
        {
            FreeADsMem( aModsTemp );
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy( aModsBuffer, **aMods, *pdwNumOfMods * sizeof(LDAPModW));
        FreeADsMem( **aMods );
        FreeADsMem( *aMods );

        *aMods = aModsTemp;

        for ( j = 0; j < *pdwNumOfMods; j++ )
        {
            (*aMods)[j] = &aModsBuffer[j];
        }
    }

    if ( aValuesAdd )
    {
        (*aMods)[j] = &aModsBuffer[j];
        aModsBuffer[j].mod_type = pszPropName;
        aModsBuffer[j].mod_values = aValuesAdd;
        aModsBuffer[j].mod_op |= LDAP_MOD_ADD;
        j++;
    }

    if ( aValuesRemove )
    {
        (*aMods)[j] = &aModsBuffer[j];
        aModsBuffer[j].mod_type = pszPropName;
        aModsBuffer[j].mod_values = aValuesRemove;
        aModsBuffer[j].mod_op |= LDAP_MOD_DELETE;
    }

    *pdwNumOfMods += nCount;

error:

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CLDAPClass::get_NTDSProp_Helper( THIS_ BSTR bstrName, VARIANT FAR *pvProp )
{
    HRESULT hr = S_OK;
    LPTSTR *aValues = NULL;
    int nCount = 0;
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPTSTR aStrings[3];
    
    aStrings[0] = TEXT("cn");
    aStrings[1] = bstrName;
    aStrings[2] = NULL;

    if ( _pClassInfo == NULL )  // new class
    {
        hr = MakeVariantFromStringArray( NULL,
                                         pvProp );
        RRETURN_EXP_IF_ERR(hr);
    }

    //
    // If the dn is NULL we have not got the info so fetch it.
    //
    if (_pszLDAPDn == NULL )
    {
        hr = BuildSchemaLDAPPathAndGetAttribute(
                _Parent,
                _Name,
               ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                _pClassInfo == NULL,
                _Credentials,
                aStrings,
                &_pszLDAPServer,
                &_pszLDAPDn,
                &_ld,
                &res
                );
        BAIL_IF_ERROR(hr);

        hr = LdapFirstEntry(
                _ld,
                res,
                &e
                );
        BAIL_IF_ERROR(hr);

        hr = LdapGetValues(
                _ld,
                e,
                bstrName,
                &aValues,
                &nCount
                );
    }

    else
    {
        hr = LdapReadAttribute(
                    _pszLDAPServer,
                    _pszLDAPDn,
                    bstrName,
                    &aValues,
                    &nCount,
                    _Credentials,
                    _dwPort
                    );
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) )
    {
        hr = NO_ERROR;
    }
    BAIL_IF_ERROR(hr);

    hr = MakeVariantFromStringArray( aValues,
                                     pvProp );
    BAIL_IF_ERROR(hr);

    hr = put_VARIANT_Property( this, bstrName, *pvProp );
    BAIL_IF_ERROR(hr);

    hr = _pPropertyCache->ClearPropertyFlag( bstrName );
    BAIL_IF_ERROR(hr);

cleanup:

    if ( aValues )
        LdapValueFree( aValues );

    if (res)
        LdapMsgFree(res);

    RRETURN_EXP_IF_ERR(hr);
}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPClass::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr;
    hr = LdapGetSyntaxOfAttributeOnServer(
         _pszLDAPServer,
         szPropertyName,
         pdwSyntaxId,
         _Credentials,
         _dwPort
         );

    RRETURN_EXP_IF_ERR(hr);
}

/* IUmiHelperPrivate support. */

//+---------------------------------------------------------------------------
// Function:   CLDAPClass::GetPropertiesHelper
//
// Synopsis:   Returns an array of PPROPERTYINFO that points to the
//          property definitions this class can hold.
//
// Arguments:  ppProperties    -   Ret values for the property info.
//             pdwCount        -   Ret value for the number of properties.
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   ppProperties and pdwCount appropriately.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPClass::GetPropertiesHelper(
    void **ppProperties,
    PDWORD pdwPropCount
    )
{
    HRESULT hr = S_OK;
    PPROPERTYINFO *pPropArray = NULL;
    DWORD dwPropCount = 0;
    DWORD dwCtr;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) _hSchema;

    //
    // Initialize out params to default values.
    //
    *pdwPropCount = 0;
    *ppProperties  = NULL;

    //
    // If there is no classInfo then we do not have any further processing
    // to do as there are no properties on this class.
    //
    if (!this->_pClassInfo) {
        RRETURN(E_FAIL);
    }
    
    //
    // We need to know how many entries are there in the list of properties.
    // The total is made up of both the mandatory and optional properties.
    // Note that we will adjust this value suitably as we process the array.
    // 
    dwPropCount = _pClassInfo->nNumOfMayContain 
                + _pClassInfo->nNumOfMustContain;                

    pPropArray = (PPROPERTYINFO *) AllocADsMem(
                     sizeof(PPROPERTY*) * dwPropCount
                     );
    if (!pPropArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Go through and get the info for the must contain.
    //
    for (
         dwCtr = 0;
         ((dwCtr < (_pClassInfo->nNumOfMustContain))
         && (_pClassInfo->pOIDsMustContain[dwCtr] != -1));
         dwCtr++) 
        {
        //
        // Assign the appropriate prop info ptrs from the may contain list.
        //
        pPropArray[dwCtr] = &(pSchemaInfo->aProperties[
                             (pSchemaInfo->aPropertiesSearchTable[
                              _pClassInfo->pOIDsMustContain[dwCtr]].nIndex
                              )]);
    }

    DWORD dwAdjust;
    
    //
    // We could have less than the number in the array if we hit -1, or
    // -1 could be pointing correctly to the last element !!!
    //
    if ((_pClassInfo->pOIDsMustContain[dwCtr] == -1)
        && (dwCtr < _pClassInfo->nNumOfMustContain)) {
        dwCtr++;
    }
    
    dwAdjust = dwCtr;

    //
    // Now get the may contain information.
    //
    for (
         dwCtr = 0;
         ((dwCtr < (_pClassInfo->nNumOfMayContain))
          && (_pClassInfo->pOIDsMayContain[dwCtr]) != -1);
         dwCtr++) 
         {
        DWORD dwTemp = dwCtr + dwAdjust;
        pPropArray[dwTemp] = &(pSchemaInfo->aProperties[
                               (pSchemaInfo->aPropertiesSearchTable[
                                _pClassInfo->pOIDsMayContain[dwCtr]].nIndex
                                )]);
    }

    *ppProperties = (void *) pPropArray;

    if ((_pClassInfo->pOIDsMayContain[dwCtr] == -1)
        && (dwCtr < _pClassInfo->nNumOfMustContain)) {
        *pdwPropCount = dwAdjust + dwCtr + 1;
    }
    else {
        *pdwPropCount = dwAdjust + dwCtr;
    }

error:

    if (FAILED(hr)) {
        if (pPropArray) {
            FreeADsMem(pPropArray);
        }
    }

    RRETURN(hr);
}

HRESULT 
IsPropertyInList(
    LPCWSTR pszName,
    VARIANT vProp,
    BOOL *pfInList
    )
{
    HRESULT hr = S_OK;
    VARIANT *pvProp = &vProp;
    SAFEARRAY *pArray = V_ARRAY(pvProp);
    DWORD dwSLBound;
    DWORD dwSUBound;
    DWORD dwLength = 0;
    VARIANT vVar;

    VariantInit(&vVar);

    *pfInList = FALSE;

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);
    
    dwLength = dwSUBound - dwSLBound;

    //
    // If there are 0 elements in cannot be in the list.
    //
    if (!dwLength) {
        RRETURN(S_OK);
    }
    
    for (DWORD dwCtr = 0;
         (dwCtr <= dwLength) && (*pfInList != TRUE);
         dwCtr++)
         {
        //
        // Go through the array to see if we find the name in the list.
        //
        VariantClear(&vVar);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&dwCtr,
                                &vVar
                                );
        BAIL_ON_FAILURE(hr);

        if (V_VT(&vVar) != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        if (!_wcsicmp(pszName, vVar.bstrVal)) {
            *pfInList = TRUE;
        }
    }

error:

    VariantClear(&vVar);

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
// Function:   CLDAPClass::GetOriginHelper
//
// Synopsis:   Returns the name of the class this property originated on.
//
// Arguments:  pszName         -   Name of the property whose origin is needed.
//             pbstrOrigin     -   Return value - name of class.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pbstrOrigin on success.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CLDAPClass::GetOriginHelper(
    LPCWSTR pszName,
    BSTR *pbstrOrigin
    )
{
    HRESULT hr = S_OK;
    CCredentials cCreds = _Credentials;
    IUnknown *pUnk = NULL;
    IADsContainer *pContainer = NULL;
    BSTR bstrTemp = NULL;
    DWORD dwAuthFlags = cCreds.GetAuthFlags();
    BOOL fDone = FALSE;
    BOOL fInMustContain = FALSE;
    BOOL fInList = FALSE;
    IADsClass *pClass = NULL;
    IDispatch *pDispObj = NULL;
    BOOL fMustContain = FALSE;
    VARIANT vVar, vVarProps;

    VariantInit(&vVar);
    VariantInit(&vVarProps);

    //
    // If we are already at the top.
    //
    if (!_wcsicmp(_Name, L"top")) {
        hr = ADsAllocString(L"top", pbstrOrigin);
        RRETURN(hr);
    }

    //
    // We want to chase up either the mandatory or optional list and
    // not both. So we first update this flag.
    //
    hr = get_MandatoryProperties(&vVarProps);
    BAIL_ON_FAILURE(hr);

    hr = IsPropertyInList(pszName, vVarProps, &fInMustContain);
    BAIL_ON_FAILURE(hr)

    //
    // Mask out the reserved flags - we want to be in ADSI land now.
    //
    cCreds.SetAuthFlags(dwAuthFlags & ~(ADS_AUTH_RESERVED));

    //
    // This will be the default class name to return.
    //  
    hr = ADsAllocString(_Name, &bstrTemp);
    BAIL_ON_FAILURE(hr);
    //
    // Need to get hold of the schema container.
    //
    hr = GetObject(_Parent, cCreds, (void **)&pUnk);
    BAIL_ON_FAILURE(hr);

    hr = pUnk->QueryInterface(IID_IADsContainer, (void **) &pContainer);
    BAIL_ON_FAILURE(hr);

    while (!fDone) {
        //
        // Need to keep finding the derived from until we hit top
        // or we hit a class that does not support the attribute.
        //
        VariantClear(&vVar);
        VariantClear(&vVarProps);

        if (pDispObj) {
            pDispObj->Release();
            pDispObj = NULL;
        }

        if (!pClass) {
            //
            // Need to get the derived from for the current class.
            //
            hr = get_DerivedFrom(&vVar);
        } 
        else {
            hr = pClass->get_DerivedFrom(&vVar);
            pClass->Release();
            pClass = NULL;
        }

        //
        // Get the derived from classes object.
        //
        hr = pContainer->GetObject(
                 L"Class",
                 vVar.bstrVal,
                 &pDispObj
                 );
        BAIL_ON_FAILURE(hr);

        hr = pDispObj->QueryInterface(
                 IID_IADsClass,
                 (void **) &pClass
                 );
        BAIL_ON_FAILURE(hr);

        if (!_wcsicmp(vVar.bstrVal, L"top")) {
            fDone = TRUE;
        }

        if (fInMustContain) {
            hr = pClass->get_MandatoryProperties(&vVarProps);
        } 
        else {
            hr = pClass->get_OptionalProperties(&vVarProps);
        }
        BAIL_ON_FAILURE(hr);

        hr = IsPropertyInList(pszName, vVarProps, &fInList);
        BAIL_ON_FAILURE(hr);

        if (!fInList) {
            //
            // The value in temp is the correct class name
            //
            hr = ADsAllocString(bstrTemp, pbstrOrigin);
            BAIL_ON_FAILURE(hr);

            fDone = TRUE;
        }

        //
        // This will be true only if we found the item in top.
        //
        if (fInList && fDone) {
            hr = ADsAllocString(L"Top", pbstrOrigin);
            BAIL_ON_FAILURE(hr);
        }

        if (bstrTemp) {
            SysFreeString(bstrTemp);
            bstrTemp = NULL;
        }

        //
        // Need to get the current class name in bstrTemp.
        //
        hr = ADsAllocString(vVar.bstrVal, &bstrTemp);
        BAIL_ON_FAILURE(hr);
    }

    //
    // We will default to the current class.
    //
    if (!pbstrOrigin) {
        hr = ADsAllocString(_Name, pbstrOrigin);
        BAIL_ON_FAILURE(hr);
    }

error:

    if (bstrTemp) {
        SysFreeString(bstrTemp);
    }

    VariantClear(&vVar);
    VariantClear(&vVarProps);
    
    if (pContainer) {
        pContainer->Release();
    }

    if (pUnk) {
        pUnk->Release();
    }

    if (pClass) {
        pClass->Release();
    }

    if (pDispObj) {
        pDispObj->Release();
    }

    RRETURN(hr);
}
/******************************************************************/
/*  Class CLDAPProperty
/******************************************************************/

DEFINE_IDispatch_Implementation(CLDAPProperty)
DEFINE_IADs_Implementation(CLDAPProperty)

CLDAPProperty::CLDAPProperty()
    : _pDispMgr( NULL ),
      _pPropertyCache( NULL ),
      _bstrSyntax( NULL ),
      _hSchema( NULL ),
      _pPropertyInfo( NULL ),
      _pszLDAPServer(NULL),
      _pszLDAPDn(NULL),
      _fNTDS( TRUE ),
      _ld( NULL )
{
    ENLIST_TRACKING(CLDAPProperty);
}

CLDAPProperty::~CLDAPProperty()
{
    delete _pDispMgr;

    delete _pPropertyCache;

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    if ( _hSchema ) {
        SchemaClose( &_hSchema );
        _hSchema = NULL;
    }


    if (_pszLDAPServer) {
        FreeADsStr(_pszLDAPServer);
    }

    if (_pszLDAPDn) {
        FreeADsStr(_pszLDAPDn);
    }

    if ( _ld ) {
        LdapCloseObject( _ld );
        _ld = NULL;
    }
}

HRESULT
CLDAPProperty::CreateProperty(
    BSTR   bstrParent,
    LDAP_SCHEMA_HANDLE hSchema,
    BSTR   bstrName,
    PROPERTYINFO *pPropertyInfo,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;
    BSTR bstrSyntax = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocatePropertyObject(Credentials, &pProperty );
    BAIL_ON_FAILURE(hr);

    pProperty->_pPropertyInfo = pPropertyInfo;

    SchemaAddRef( hSchema );
    pProperty->_hSchema = hSchema;

    if ( pPropertyInfo )
    {
        hr = put_BSTR_Property( pProperty, TEXT("attributeID"),
                                pPropertyInfo->pszOID);

        if ( SUCCEEDED(hr))
        {
            hr = put_VARIANT_BOOL_Property( pProperty, TEXT("isSingleValued"),
                                            (VARIANT_BOOL)pPropertyInfo->fSingleValued );
            BAIL_ON_FAILURE(hr);

            pProperty->_pPropertyCache->ClearAllPropertyFlags();

            pProperty->_fNTDS = TRUE;

        }
        else
        {
            pProperty->_fNTDS = FALSE;
        }
    }

    hr = ADsObject(bstrParent, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pProperty->_dwPort = pObjectInfo->PortNumber;

    FreeObjectInfo(pObjectInfo);
    pObjectInfo = NULL;

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             bstrName,
             PROPERTY_CLASS_NAME,
             CLSID_LDAPProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    //
    // At this point update the info in the property cache
    //
    pProperty->_pPropertyCache->SetObjInformation(
                                     &(pProperty->_Credentials),
                                     pProperty->_pszLDAPServer,
                                     pProperty->_dwPort
                                     );

    BAIL_ON_FAILURE(hr);

    //
    // Need to create the umi object if applicable.
    //
    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        hr = ((CCoreADsObject*)pProperty)->InitUmiObject(
                   IntfPropsSchema,
                   pProperty->_pPropertyCache,
                   (IADs *) pProperty,
                   (IADs *) pProperty,
                   riid,
                   ppvObj,
                   &(pProperty->_Credentials),
                   pProperty->_dwPort,
                   pProperty->_pszLDAPServer,
                   pProperty->_pszLDAPDn
                   );
        BAIL_ON_FAILURE(hr);
        //
        // Need to put syntax in the cache.
        //
        if (pProperty->_pPropertyInfo->pszSyntax) {
            hr = GetFriendlyNameFromOID(
                    pProperty->_pPropertyInfo->pszSyntax,
                     &bstrSyntax
                    );
            if (FAILED(hr)) {
                //
                // ok if this failed.
                //
                hr = S_OK;
            } 
            else {
                hr = put_BSTR_Property( 
                         pProperty, TEXT("syntax"),
                         bstrSyntax
                         );
                SysFreeString(bstrSyntax);
                //
                // Not critical failure
                //
                hr = S_OK;
            }
        }
        //
        // Name is a simulated propert used for UMI.
        //
        hr = put_BSTR_Property(
                 pProperty,
                 TEXT("Name"),
                 bstrName
                 );
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);

    }

    //
    // Get the LDAP path of the schema entry
    //

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pProperty;

    FreeObjectInfo(pObjectInfo);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPProperty::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) |
    IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
/* IADs methods */

STDMETHODIMP
CLDAPProperty::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    BOOL fChanged = FALSE;

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR(E_NOTIMPL);

    if ( GetObjectState() == ADS_OBJECT_UNBOUND )
    {
        hr = LDAPCreateObject();
        BAIL_ON_FAILURE(hr);

        fChanged = TRUE;

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }
    else
    {
        hr = LDAPSetObject( &fChanged );
        BAIL_ON_FAILURE(hr);
    }

    //
    //  Need to refresh the schema
    //

    if ( SUCCEEDED(hr) && fChanged )
        hr = LDAPRefreshSchema();

error:

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPProperty::LDAPSetObject( BOOL *pfChanged )
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    BOOL fNTSecDes = FALSE;
    SECURITY_INFORMATION NewSeInfo;

    *pfChanged = FALSE;

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( aMod == NULL )  // There are no changes that needs to be modified
        RRETURN(S_OK);

    if ( _pszLDAPDn == NULL )
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pPropertyInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );
        BAIL_ON_FAILURE(hr);
    }

    if ( _ld == NULL )
    {
        hr = LdapOpenObject(
                       _pszLDAPServer,
                       _pszLDAPDn,
                       &_ld,
                       _Credentials,
                       _dwPort
                       );
    BAIL_ON_FAILURE(hr);
    }

    hr = LdapModifyS(
                   _ld,
                   _pszLDAPDn,
                   aMod
                   );
    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

    *pfChanged = TRUE;

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );

        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPProperty::LDAPCreateObject()
{
    HRESULT hr = S_OK;
    LDAPModW **aMod = NULL;
    DWORD dwIndex = 0;
    VARIANT v;
    BOOL fNTSecDes= FALSE;
    SECURITY_INFORMATION NewSeInfo;

    //
    // Get the LDAP path of the schema entry
    //
    if ( (_pszLDAPServer == NULL) && (_pszLDAPDn == NULL))
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pPropertyInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );

        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("objectClass"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {

        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = NT_SCHEMA_PROPERTY_NAME;

        hr = Put( TEXT("objectClass"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("cn"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _Name;

        hr = Put( TEXT("cn"), v );
        BAIL_ON_FAILURE(hr);
    }

    if ( _pPropertyCache->findproperty( TEXT("lDAPDisplayName"), &dwIndex )
         == E_ADS_PROPERTY_NOT_FOUND )
    {
        VariantInit(&v);
        v.vt = VT_BSTR;
        V_BSTR(&v) = _Name;

        hr = Put( TEXT("lDAPDisplayName"), v );
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->LDAPMarshallProperties(
                            &aMod,
                            &fNTSecDes,
                            &NewSeInfo
                            );
    BAIL_ON_FAILURE(hr);

    if ( _ld == NULL )
    {
        hr = LdapOpenObject(
                       _pszLDAPServer,
                       _pszLDAPDn,
                       &_ld,
                       _Credentials,
                       _dwPort
                       );
    BAIL_ON_FAILURE(hr);
    }

    hr = LdapAddS(
                    _ld,
                    _pszLDAPDn,
                    aMod
                    );


    BAIL_ON_FAILURE(hr);

    // We are successful at this point,
    // So, clean up the flags in the cache so the same operation
    // won't be repeated on the next SetInfo()

    _pPropertyCache->ClearAllPropertyFlags();

error:

    if (aMod) {

        if ( *aMod )
            FreeADsMem( *aMod );
        FreeADsMem( aMod );
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPProperty::LDAPRefreshSchema(THIS)
{
    HRESULT hr = S_OK;

    if (( _pszLDAPServer == NULL) && (_pszLDAPDn == NULL))
    {
        hr = BuildSchemaLDAPPath( _Parent,
                                  _Name,
                                  ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                                  &_pszLDAPServer,
                                  &_pszLDAPDn,
                                  _pPropertyInfo == NULL,
                                  &_ld,
                                  _Credentials
                                  );

        BAIL_ON_FAILURE(hr);
    }

    //
    // Make the old schema obsolete and get the new schema
    // We cannot delete the old schema since other objects might have
    // references to it.
    //
    hr = LdapMakeSchemaCacheObsolete(
             _pszLDAPServer,
             _Credentials,
             _dwPort
             );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::GetInfo(THIS)
{
    HRESULT hr = S_OK;
    BSTR bstrSyntax = NULL;

    if ( GetObjectState() == ADS_OBJECT_UNBOUND )
        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);

    hr = LDAPRefreshSchema();
    BAIL_ON_FAILURE(hr);

    SchemaClose( &_hSchema );

    hr = SchemaOpen( _pszLDAPServer, &_hSchema, _Credentials, _dwPort );
    BAIL_ON_FAILURE(hr);

    //
    // Find the new property info in the new schemainfo
    //

    hr = SchemaGetPropertyInfo(
             _hSchema,
             _Name,
             &_pPropertyInfo );

    BAIL_ON_FAILURE( hr );

    if ( _pPropertyInfo == NULL )
    {
        // Property name not found, set error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    _pPropertyCache->flushpropertycache();

    hr = put_BSTR_Property( this, TEXT("attributeID"),
                            _pPropertyInfo->pszOID);
    BAIL_ON_FAILURE(hr);

    if ( _bstrSyntax )
    {
        ADsFreeString( _bstrSyntax );
        _bstrSyntax = NULL;
    }

    hr = put_VARIANT_BOOL_Property( this, TEXT("isSingleValued"),
                                    (VARIANT_BOOL)_pPropertyInfo->fSingleValued );
    BAIL_ON_FAILURE(hr);

    //
    // If we are calling from Umi land then we need to set 
    // additional properties.
    //
    if (_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        if (_pPropertyInfo->pszSyntax) {
            hr = GetFriendlyNameFromOID(
                     _pPropertyInfo->pszSyntax,
                     &bstrSyntax
                     );
            if (FAILED(hr)) {
                //
                // ok if this failed.
                //
                hr = S_OK;
            } 
            else {
                hr = put_BSTR_Property( 
                         this, TEXT("syntax"),
                         bstrSyntax
                         );
                SysFreeString(bstrSyntax);
                //
                // Not critical failure
                //
                hr = S_OK;
            }
        }
        //
        // Name is a simulated propert used for UMI.
        //
        hr = put_BSTR_Property(
                 this,
                 TEXT("Name"),
                 _Name
                 );
        BAIL_ON_FAILURE(hr);

    } // special props for Umi.

    if (_fNTDS) {
        hr = GetNTDSSchemaInfo(TRUE);
    }

    _pPropertyCache->ClearAllPropertyFlags();
    _pPropertyCache->setGetInfoFlag();

error:

    if (bstrSyntax) {
        SysFreeString(bstrSyntax);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//
// Helper function for Umi - defined in CCoreADsObject.
//
STDMETHODIMP
CLDAPProperty::GetInfo(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (dwFlags ==  GETINFO_FLAG_EXPLICIT) {
        RRETURN(GetInfo());
    } 
    else if (_fNTDS
             && dwFlags != GETINFO_FLAG_IMPLICIT_AS_NEEDED
             ) {
        //
        // Read the extra NTDS specific schema properties.
        //
        hr = GetNTDSSchemaInfo(FALSE);
    }
    
    //
    // Any other flags means nothing to do.
    //
    RRETURN(hr);
}

HRESULT
CLDAPProperty::GetNTDSSchemaInfo(
    BOOL fForce
    )
{
    HRESULT hr = S_OK;
    LPTSTR aStrings[] = {
        TEXT("cn"),
        TEXT("schemaIDGUID"),
        TEXT("rangeUpper"),
        TEXT("rangeLower"),
        NULL
    };

    LDAPMessage *res = NULL;

    if (_pszLDAPDn == NULL) {
        //
        // Need to get the dn for this object and also 
        // the attributes we are interested in.
        //
        hr = BuildSchemaLDAPPathAndGetAttribute(
                 _Parent,
                 _Name,
                 ((SCHEMAINFO*)_hSchema)->pszSubSchemaSubEntry,
                 _pPropertyInfo == NULL,
                 _Credentials,
                 aStrings,
                 &_pszLDAPServer,
                 &_pszLDAPDn,
                 &_ld,
                 &res
                 );
    }
    else {
        //
        // Looks like we just need the attributes in this case.
        //
        hr = LdapSearchS(
                 _ld,
                 _pszLDAPDn,
                 LDAP_SCOPE_BASE,
                 L"(objectClass=*)",
                 aStrings,
                 FALSE,
                 &res
                 );
    }
        
    BAIL_ON_FAILURE(hr);

    //
    // If we succeeded we should unmarshall properties into the cache.
    //
    hr = _pPropertyCache->LDAPUnMarshallProperties(
             _pszLDAPServer,
             _ld,
             res,
             fForce,
             _Credentials
             );
    BAIL_ON_FAILURE(hr);

    _pPropertyCache->setGetInfoFlag();

error:

    if (res) {
        LdapMsgFree(res);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPProperty::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    DWORD dwStatus = 0;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For folks who know now what they do.
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }
    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    if ( ldapSrcObjects.dwCount == 1 ) {

        hr = LdapTypeToVarTypeCopy(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects.pLdapObjects,
                 dwSyntaxId,
                 pvProp
                 );

    } else {

        hr = LdapTypeToVarTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects,
                 dwSyntaxId,
                 pvProp
                 );
    }
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vDefProp;

    VariantInit(&vDefProp);

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    hr = SchemaGetSyntaxOfAttribute( _hSchema, bstrName, &dwSyntaxId );
    if (FAILED(hr)) {
        //
        // Need to see if this is syntax if so we special case
        // for Umi Objects.
        //
        if (!_wcsicmp(L"syntax", bstrName)) {
            dwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
            hr = S_OK;
        }
    }
    BAIL_ON_FAILURE(hr);


    if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
    pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
    (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                        );
        // returns E_FAIL if *pvProp is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;                    
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else {

    //
    // If pvProp is a reference to a fundamental type,
    // we have to dereference it once.
    //
    if (V_ISBYREF(pvProp)) {
        hr = VariantCopyInd(&vDefProp, pvProp);
        BAIL_ON_FAILURE(hr);
        pvProp = &vDefProp;
    }
        dwNumValues = 1;
    }


#if 0
    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    //
    // check if the variant maps to the syntax of this property
    //

    if ( dwNumValues > 0 )
    {
        hr = VarTypeToLdapTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 dwSyntaxId,
                 pvProp,
                 dwNumValues,
                 &ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //
    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );

    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vDefProp);

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // For those who know no not what they do
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND ) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    hr = LdapTypeToVarTypeCopyConstruct(
             _pszLDAPServer,
             _Credentials,
             ldapSrcObjects,
             dwSyntaxId,
             pvProp
             );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = PROPERTY_UPDATE;
        break;

    default:
       RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);

    }

    hr = SchemaGetSyntaxOfAttribute( _hSchema, bstrName, &dwSyntaxId );
    BAIL_ON_FAILURE(hr);

    if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

#if 0
    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    if ( dwFlags != PROPERTY_DELETE )
    {

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

            hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
            // returns E_FAIL if *pvProp is invalid
            if (hr == E_FAIL)
                hr = E_ADS_BAD_PARAMETER;                      
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }


        //
        // check if the variant maps to the syntax of this property
        //

        if ( dwNumValues > 0 )
        {
            hr = VarTypeToLdapTypeCopyConstruct(
                     _pszLDAPServer,
                     _Credentials,
                     dwSyntaxId,
                     pvProp,
                     dwNumValues,
                     &ldapDestObjects
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //
    hr = _pPropertyCache->putproperty(
                    bstrName,
                    PROPERTY_UPDATE,
                    dwSyntaxId,
                    ldapDestObjects
                    );

    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsProperty methods */


STDMETHODIMP
CLDAPProperty::get_OID( THIS_ BSTR FAR *retval )
{
    HRESULT hr;
    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( _fNTDS )
    {
        GET_PROPERTY_BSTR( this, attributeID );
    }
    else if ( _pPropertyInfo )
    {
        hr =  ADsAllocString( _pPropertyInfo->pszOID?
                                   _pPropertyInfo->pszOID : TEXT(""), retval);
    }
    else
    {
        hr = ADsAllocString( TEXT(""), retval );
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::put_OID( THIS_ BSTR bstrOID )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR(E_NOTIMPL);

    HRESULT hr = put_BSTR_Property( this, TEXT("attributeID"), bstrOID );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::get_Syntax( THIS_ BSTR FAR *retval )
{
    HRESULT hr = S_OK;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( _fNTDS )
    {

        if ( _bstrSyntax )  // New property or syntax has been reset
        {
            hr = ADsAllocString( _bstrSyntax, retval);

        } else if (_pPropertyInfo && !_pPropertyInfo->pszSyntax) {
            //
            // New property but syntax has not been set
            //
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }
    }

    //
    // Need to return if hr or retVal as we have what we need
    //
    if (FAILED(hr) || _bstrSyntax) {

        RRETURN_EXP_IF_ERR(hr);
    }

    // If we have the syntax in _pPropertyInfo we need to
    // continue and see if we can get a friendly name to return.
    if ( _pPropertyInfo ) {

        if (_pPropertyInfo->pszSyntax) {

            if (!GetFriendlyNameFromOID(
                         _pPropertyInfo->pszSyntax, retval)
                 ) {

                    // in this case we want to set the retVal
                    // to the OID as we could not find a match
                    hr = ADsAllocString(_pPropertyInfo->pszSyntax, retval);

            }
        }

    } else {

        hr = ADsAllocString( TEXT(""), retval );

    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR(E_NOTIMPL);

    LPTSTR pszOID;
    DWORD  dwOMSyntax;
    HRESULT hr = S_OK;


    BYTE btDNWithBinary[] = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x14, 0x01,
                              0x01, 0x01, 0x0B };


    BYTE btDNWithString[]      = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x14, 0x01,
                                   0x01, 0x01, 0x0C
                                   };


    if ( GetSyntaxOID( bstrSyntax, &pszOID, &dwOMSyntax))
    {
        hr = put_BSTR_Property( this, TEXT("attributeSyntax"),
                                pszOID );
        BAIL_ON_FAILURE(hr);

        hr = put_LONG_Property( this, TEXT("oMSyntax"),
                                dwOMSyntax );
        BAIL_ON_FAILURE(hr);

        if ( _bstrSyntax )
            ADsFreeString( _bstrSyntax );

        hr = ADsAllocString( bstrSyntax, &_bstrSyntax );
        BAIL_ON_FAILURE(hr);

        //
        // We need to handle the special case of DNWithBinary
        // and DNString
        //
        if (_wcsicmp(bstrSyntax, L"DNWithBinary") == 0) {
            //
            // Need to set additional byte attribute
            //
            hr = put_OCTETSTRING_Property(
                     this,
                     TEXT("omObjectClass"),
                     btDNWithBinary,
                     (sizeof(btDNWithBinary)/sizeof(btDNWithBinary[0]))
                     );

            BAIL_ON_FAILURE(hr);

        }
        else if (_wcsicmp(bstrSyntax, L"DNWithString") == 0) {
            //
            // Need to set omObjectClass here too
            //
            hr = put_OCTETSTRING_Property(
                     this,
                     TEXT("omObjectClass"),
                     btDNWithString,
                     (sizeof(btDNWithString)/sizeof(btDNWithString[0]))
                     );

            BAIL_ON_FAILURE(hr);

        }
    }
    else
    {
        // Unknown syntax
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

error:
    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    HRESULT hr = S_OK;

    if ( !plMaxRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    hr = get_LONG_Property(this, TEXT("rangeUpper"), plMaxRange );

    if ( SUCCEEDED(hr) )
        RRETURN(hr);

    if ( _pPropertyInfo == NULL )  // new class
    {
        hr = E_ADS_PROPERTY_NOT_SET;
        RRETURN_EXP_IF_ERR(hr);
    }

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPProperty::put_MaxRange( THIS_ long lMaxRange )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_LONG_Property( this, TEXT("rangeUpper"),
                                    lMaxRange );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    HRESULT hr = S_OK;
    
    if ( !plMinRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    hr = get_LONG_Property(this, TEXT("rangeLower"), plMinRange );

    if ( SUCCEEDED(hr) )
        RRETURN(hr);

    if ( _pPropertyInfo == NULL )  // new class
    {
        hr = E_ADS_PROPERTY_NOT_SET;
        RRETURN_EXP_IF_ERR(hr);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::put_MinRange( THIS_ long lMinRange )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_LONG_Property( this, TEXT("rangeLower"),
                                    lMinRange );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr = S_OK;
    VARIANT_BOOL fSingleValued = FALSE;  // by default

    if ( _fNTDS )
    {
        hr = get_VARIANT_BOOL_Property( this, TEXT("isSingleValued"),
                                        &fSingleValued );
        BAIL_ON_FAILURE(hr);
    }
    else if ( _pPropertyInfo )
    {
        fSingleValued = (VARIANT_BOOL)_pPropertyInfo->fSingleValued;
    }

    *pfMultiValued = fSingleValued? VARIANT_FALSE : VARIANT_TRUE;

error:

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    if ( !_fNTDS )
        RRETURN_EXP_IF_ERR( E_NOTIMPL );

    HRESULT hr = put_VARIANT_BOOL_Property( (IADs *) this,
                                            TEXT("isSingleValued"),
                                            !fMultiValued );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        _fNTDS = FALSE;
        hr = E_NOTIMPL;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CLDAPProperty::AllocatePropertyObject(
    CCredentials& Credentials,
    CLDAPProperty FAR * FAR * ppProperty
    )
{
    CLDAPProperty FAR *pProperty = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR *pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pProperty = new CLDAPProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                            (CCoreADsObject FAR *) pProperty,
                            (IGetAttributeSyntax *) pProperty,
                            &pPropertyCache
                            );

    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(pPropertyCache);

    pProperty->_Credentials = Credentials;
    pProperty->_pDispMgr = pDispMgr;
    pProperty->_pPropertyCache = pPropertyCache;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPProperty::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr;
    hr = LdapGetSyntaxOfAttributeOnServer(
    _pszLDAPServer,
    szPropertyName,
    pdwSyntaxId,
    _Credentials,
    _dwPort
    );
    RRETURN_EXP_IF_ERR(hr);
}


/******************************************************************/
/*  Class CLDAPSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CLDAPSyntax)
DEFINE_IADs_Implementation(CLDAPSyntax)
DEFINE_IADsPutGet_UnImplementation(CLDAPSyntax)

CLDAPSyntax::CLDAPSyntax()
    : _pDispMgr( NULL ),
      _pPropertyCache(NULL)
{
    ENLIST_TRACKING(CLDAPSyntax);
}

CLDAPSyntax::~CLDAPSyntax()
{
    delete _pDispMgr;
    delete _pPropertyCache;
}

HRESULT
CLDAPSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject(Credentials, &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->pszName,
             SYNTAX_CLASS_NAME,
             CLSID_LDAPSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    //
    // If the call is from umi we need to instantiate the umi object.
    //
    if (Credentials.GetAuthFlags() & ADS_AUTH_RESERVED) {
        hr = ((CCoreADsObject*)pSyntax)->InitUmiObject(
                   IntfPropsSchema,
                   pSyntax->_pPropertyCache,
                   (IADs *) pSyntax,
                   (IADs *) pSyntax,
                   riid,
                   ppvObj,
                   &(pSyntax->_Credentials)
                   );
        BAIL_ON_FAILURE(hr);

        //
        // Set the simulated Name property.
        //
        hr = HelperPutStringPropertyInCache(
                 L"Name",
                 pSyntaxInfo->pszName,
                 pSyntax->_Credentials,
                 pSyntax->_pPropertyCache
                 );
        BAIL_ON_FAILURE(hr);

        RRETURN(S_OK);
    }

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pSyntax;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPSyntax::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
    IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
/* IADs methods */

STDMETHODIMP
CLDAPSyntax::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPSyntax::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CLDAPSyntax::AllocateSyntaxObject(
    CCredentials& Credentials,
    CLDAPSyntax FAR * FAR * ppSyntax
    )
{
    CLDAPSyntax FAR *pSyntax = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR *pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CLDAPSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr(Credentials);
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                            (CCoreADsObject FAR *) pSyntax,
                            (IGetAttributeSyntax *) pSyntax,
                            &pPropertyCache
                            );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pPropertyCache = pPropertyCache;

    pSyntax->_Credentials = Credentials;
    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;
    delete pPropertyCache;

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLDAPSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

//
// Needed for dynamic dispid's in the property cache.
//
HRESULT
CLDAPSyntax::GetAttributeSyntax(
    LPWSTR szPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if ((_Credentials.GetAuthFlags() & ADS_AUTH_RESERVED)
        && !_wcsicmp(L"Name", szPropertyName)) {
        *pdwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
    } 
    else {
        hr = E_ADS_PROPERTY_NOT_FOUND;
    }

    RRETURN_EXP_IF_ERR(hr);
}

/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringArray(
    BSTR *bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    if ( (bstrList != NULL) && (*bstrList != 0) )
    {
        long i = 0;
        long j = 0;
        long nCount = 0;

        while ( bstrList[nCount] )
            nCount++;

        if ( nCount == 1 )
        {
            VariantInit( pvVariant );
            V_VT(pvVariant) = VT_BSTR;
            hr = ADsAllocString( bstrList[0], &(V_BSTR(pvVariant)));
            RRETURN_EXP_IF_ERR(hr);
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        i = 0;
        while ( bstrList[i] )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( bstrList[i], &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            i++;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
MakeVariantFromPropStringTable(
    int *propList,
    LDAP_SCHEMA_HANDLE hSchema,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    DWORD nCount = 0;
    BSTR *aStrings = NULL;

    if ( propList != NULL )
    {
        while ( propList[nCount] != -1 )
            nCount++;
    }

    if ( nCount > 0 )
    {
        hr = SchemaGetStringsFromStringTable(
                 hSchema,
                 propList,
                 nCount,
                 &aStrings );

        if (FAILED(hr))
            RRETURN_EXP_IF_ERR(hr);
    }

    hr =  MakeVariantFromStringArray(
              aStrings,
              pvVariant );

    for ( DWORD i = 0; i < nCount; i ++ )
    {
        FreeADsStr( aStrings[i] );
    }

    if (aStrings)
    {
        FreeADsMem( aStrings );
    }

    RRETURN(hr);

}

/* No longer needed
HRESULT
DeleteSchemaEntry(
    LPTSTR szADsPath,
    LPTSTR szRelativeName,
    LPTSTR szClassName,
    LPTSTR szSubSchemaSubEntry,
    CCredentials& Credentials
)
{
    HRESULT hr = S_OK;
    ADS_LDP *ld = NULL;


    TCHAR  *pszParentLDAPServer = NULL;
    LPWSTR pszParentLDAPDn = NULL;
    DWORD dwPort = 0;
    LPWSTR pszLDAPDn = NULL;
    LPTSTR *aValues = NULL;
    int nCount = 0;

    //
    // Need to distinguish between LDAP Display Name and ...
    //

    //
    // Get the LDAP server name
    //
    hr = BuildLDAPPathFromADsPath2(
                szADsPath,
                &pszParentLDAPServer,
                &pszParentLDAPDn,
                &dwPort
                );
    BAIL_ON_FAILURE(hr);

    if ( szSubSchemaSubEntry == NULL )  // not NTDS
    {
        hr = E_NOTIMPL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Get the name of the schema object
    //
    pszLDAPDn = (LPTSTR) AllocADsMem((_tcslen(szRelativeName )
                          + _tcslen( _tcschr(szSubSchemaSubEntry,TEXT(',')))
                           ) * sizeof(TCHAR));  // includes "\\"

    if ( pszLDAPDn == NULL ){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _tcscpy( pszLDAPDn, szRelativeName );
    _tcscat( pszLDAPDn, _tcschr( szSubSchemaSubEntry, TEXT(',')) );

    if ( aValues )
    {
        LdapValueFree( aValues );
        aValues = NULL;
        nCount = 0;
    }

    //
    //  Validate the class name first
    //
    hr = LdapReadAttribute(
                    pszParentLDAPServer,
                    pszLDAPDn,
                    TEXT("objectClass"),
                    &aValues,
                    &nCount,
                    Credentials,
                    dwPort
                    );
    BAIL_ON_FAILURE(hr);

    if ( nCount > 0 )
    {
        if ( _tcsicmp( szClassName, GET_BASE_CLASS( aValues, nCount) ) != 0 )
        {
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Class name has been verified, so delete the object
    //
    hr = LdapDeleteS(
                    ld,
                    pszLDAPDn
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pszParentLDAPServer) {
        FreeADsStr(pszParentLDAPServer);
    }

    if (pszParentLDAPDn) {
       FreeADsStr(pszParentLDAPDn);
    }
    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    if ( aValues ) {
        LdapValueFree( aValues );
    }

    if ( ld ) {
        LdapCloseObject( ld );
    }

    RRETURN(hr);
}

*/


//
// ******** Important usage note **********
//  Users of this function must make sure that cn is part of
// the list of attributes passed in. This is a requirement and
// the array must contain a NULL string as the last element.
// ******** Important usage note **********
//
HRESULT
BuildSchemaLDAPPathAndGetAttribute(
    IN LPTSTR pszParent,
    IN LPTSTR pszName,
    IN LPTSTR pszSubSchemaSubEntry,
    IN BOOL fNew,
    IN CCredentials& Credentials,
    IN LPTSTR pszAttribs[],
    OUT LPWSTR * ppszSchemaLDAPServer,
    OUT LPWSTR * ppszSchemaLDAPDn,
    IN OUT PADS_LDP *ppLd,              // optional in,
    OUT PLDAPMessage *ppRes             // caller need to get first entry
)
{
    HRESULT hr = S_OK;
    LPTSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwPort = 0;
    BOOL  fOpenLd = FALSE;
    LPTSTR pszSchemaRoot = NULL;
    LPTSTR pszFilter = NULL;    // name on ldap svr
    LDAPMessage *pE = NULL;
    int nCount = 0;
    LPTSTR pszClassName = NULL;
    LPTSTR *aValues = NULL;
    int nNumberOfEntries = 0;


    if ( !ppszSchemaLDAPServer || !ppszSchemaLDAPDn || !ppLd || !ppRes)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }


    //
    //  Using pszSubSchemaSubEntry to test NTDS is no longer accurate.
    //  But the following codes are written to work for NTDS.
    //

    if ( pszSubSchemaSubEntry == NULL )   // not NTDS
    {
        hr = E_NOTIMPL;
        BAIL_IF_ERROR(hr);
    }


    //
    // Get the server name & port #
    //

    hr = BuildLDAPPathFromADsPath2(
             pszParent,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_IF_ERROR(hr);


    //
    // Connect and bind to schema Root object (in NTDS only)
    //

    pszSchemaRoot = _tcschr(                    // strip CN=Aggregate
                        pszSubSchemaSubEntry,
                        TEXT(',')
                        );

    if ( *ppLd == NULL )
    {
        hr = LdapOpenObject(
                pszLDAPServer,
                pszSchemaRoot+1,    // go past ",", we've stripped CN=Aggregate
                ppLd,
                Credentials,
                dwPort
                );
        BAIL_IF_ERROR(hr);

        fOpenLd = TRUE;
    }


    //
    // Set Serach Filter to (& (lDAPDisplayName=<pszName>)
    //                         (! (isDefunct=TRUE) )
    //                      )
    //

    pszFilter = (LPTSTR) AllocADsMem((_tcslen(BEGIN_FILTER) + _tcslen(pszName) + _tcslen(END_FILTER) + 1)*sizeof(TCHAR));
    if(!pszFilter)
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }
    _tcscpy( pszFilter, BEGIN_FILTER);
    _tcscat( pszFilter, pszName );
    _tcscat( pszFilter, END_FILTER );


    //
    // Search for scheam pszName (class object) under schema root
    //

    hr = LdapSearchS(
            *ppLd,
            pszSchemaRoot+1,        // go past ",", we've stripped CN=Aggregate
            LDAP_SCOPE_ONELEVEL,
            pszFilter,
            pszAttribs,
            0,
            ppRes
            );

    //
    // Confirm with anoopa & johnsona (ntds5) :
    //      If 1 out of the 2 attributes asked for is not on the svr,
    //      LdapSearchS (ldap_search_s) returns the 1 located and hr = S_OK
    //
    BAIL_IF_ERROR(hr);


    //
    // Only one active entry should be returned.
    // If more than one entry is returned, return E_ADS_SCHEMA_VIOLATION
    // Get cn to build schemalLDAPDn
    //

    nNumberOfEntries = LdapCountEntries( *ppLd, *ppRes );

    if ( nNumberOfEntries != 1 )
        BAIL_IF_ERROR(hr = E_ADS_SCHEMA_VIOLATION);


    if ( fNew)      // ? still keep this
    {
        pszClassName = pszName;
    }
    else
    {
        hr = LdapFirstEntry(
                *ppLd,
                *ppRes,
                &pE
                );
        BAIL_IF_ERROR(hr);

        hr = LdapGetValues(
                *ppLd,
                pE,
                L"cn",
                &aValues,
                &nCount
                );
        BAIL_IF_ERROR(hr);

        if (nCount == 0)
        {
            // use lDAPDisplayName as common name (cn) if cn not set on svr
            pszClassName = pszName;
        }
        else
        {
            pszClassName = aValues[0];
        }
    }

    if (pszLDAPServer!=NULL)
    {
        *ppszSchemaLDAPServer = (LPWSTR) AllocADsStr(
                                        pszLDAPServer
                                        );

        if (*ppszSchemaLDAPServer == NULL)
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }
    else    // pszLDAPServer allowed to be NULL
    {
        *ppszSchemaLDAPServer = NULL;
    }

    *ppszSchemaLDAPDn =  (LPWSTR) AllocADsMem(
                                        (_tcslen(L"CN=") +
                                         _tcslen(pszClassName) +
                                         _tcslen(pszSchemaRoot) + 1 ) *
                                         sizeof(TCHAR)
                                        );
    if ( *ppszSchemaLDAPDn == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    _tcscpy( *ppszSchemaLDAPDn, L"CN=");
    _tcscat( *ppszSchemaLDAPDn, pszClassName );
    _tcscat( *ppszSchemaLDAPDn, pszSchemaRoot );


    //
    // clean up for both success and failure
    //
release:

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

    if (pszLDAPDn) {
        FreeADsMem( pszLDAPDn );
    }

    if ( aValues )
        LdapValueFree( aValues );

    if(pszFilter) {
        FreeADsMem(pszFilter);
        pszFilter = NULL;
    }
    

    RRETURN(hr);


cleanup:

    //
    // clean up if failure only
    //
    if (fOpenLd==TRUE)  {
        LdapCloseObject(*ppLd);
        *ppLd= NULL;
    }

    if (*ppRes) {
        LdapMsgFree(*ppRes);
        *ppRes=NULL;
    }

    if (*ppszSchemaLDAPServer) {
        FreeADsStr(*ppszSchemaLDAPServer);
        *ppszSchemaLDAPServer=NULL;
    }

    if (*ppszSchemaLDAPDn) {
        FreeADsMem(*ppszSchemaLDAPDn);
        *ppszSchemaLDAPDn=NULL;
    }    


    goto release;
}


HRESULT
BuildSchemaLDAPPath(
    LPTSTR pszParent,
    LPTSTR pszName,
    LPTSTR pszSubSchemaSubEntry,
    LPWSTR * ppszSchemaLDAPServer,
    LPWSTR * ppszSchemaLDAPDn,
    BOOL   fNew,
    ADS_LDP   **pld,
    CCredentials& Credentials
)
{
    HRESULT hr = S_OK;
    LPTSTR *aValues = NULL;
    LPTSTR *aValues2 = NULL;
    int nCount = 0;
    TCHAR* pszFilter = NULL;
    LPTSTR aStrings[2];
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPTSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwPort = 0;

    LPTSTR pszSchemaRoot = NULL;
    LPTSTR pszClassName = NULL;

    //
    // Get the server name
    //

    hr = BuildLDAPPathFromADsPath2(
             pszParent,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_IF_ERROR(hr);

    if ( pszSubSchemaSubEntry == NULL )   // not NTDS
    {
        hr = E_NOTIMPL;
        BAIL_IF_ERROR(hr);
    }

    // the _tcschr is to get rid of "CN=Aggregate"

    pszSchemaRoot = _tcschr(pszSubSchemaSubEntry, TEXT(','));

    if ( fNew )
    {
        pszClassName = pszName;
    }
    else
    {
        pszFilter = (LPTSTR) AllocADsMem((_tcslen(TEXT("lDAPDisplayName=")) + _tcslen(pszName) + 1)*sizeof(TCHAR));
        if(!pszFilter)
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
        _tcscpy(pszFilter, TEXT("lDAPDisplayName="));
        _tcscat( pszFilter, pszName );

        aStrings[0] = TEXT("cn");
        aStrings[1] = NULL;

        if ( *pld == NULL )
        {
            hr = LdapOpenObject(
                pszLDAPServer,
                pszSchemaRoot  + 1,     // go past the , - we've stripped off "CN=Aggregate"
                pld,
                Credentials,
                dwPort
                );
        BAIL_IF_ERROR(hr);

        }

        hr = LdapSearchS(
                       *pld,
                       pszSchemaRoot + 1,
                       LDAP_SCOPE_ONELEVEL,
                       pszFilter,
                       aStrings,
                       0,
                       &res
                       );

       // Only one entry should be returned

       if (FAILED(hr)
          || (FAILED(hr = LdapFirstEntry( *pld, res, &e )))
          || (FAILED(hr = LdapGetValues( *pld, e, aStrings[0], &aValues2, &nCount)))
          )
       {
           BAIL_IF_ERROR(hr);
       }

       if ( nCount == 0 )
           pszClassName = pszName;
       else
           pszClassName = aValues2[0];
    }


    *ppszSchemaLDAPServer = (LPWSTR)AllocADsStr(pszLDAPServer);
    //
    // pszLDAPServer might be NULL, in which case NULL is the
    // expected return value from the alloc.
    //
    if ( (*ppszSchemaLDAPServer == NULL) && pszLDAPServer) {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    *ppszSchemaLDAPDn =  (LPTSTR) AllocADsMem(
                                            (_tcslen(L"CN=") +
                                            _tcslen(pszClassName) +
                                            _tcslen(pszSchemaRoot) + 1 ) *
                                            sizeof(TCHAR));

    if ( *ppszSchemaLDAPDn == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }
    _tcscpy( *ppszSchemaLDAPDn, L"CN=");
    _tcscat( *ppszSchemaLDAPDn, pszClassName );
    _tcscat( *ppszSchemaLDAPDn, pszSchemaRoot );

cleanup:

    if ( aValues )
        LdapValueFree( aValues );

    if ( aValues2 )
        LdapValueFree( aValues2 );

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

    if (pszLDAPDn) {
        FreeADsStr( pszLDAPDn);
    }

    if ( res )
        LdapMsgFree( res );

    if(pszFilter)
    {
        FreeADsMem(pszFilter);
        pszFilter = NULL;
    }



    RRETURN(hr);
}

HRESULT
MakePropArrayFromVariant(
    VARIANT vProp,
    SCHEMAINFO *hSchema,
    int **pOIDs,
    DWORD *pnNumOfOids )
{
    HRESULT hr = S_OK;
    int nIndex;
    LONG dwSLBound;
    LONG dwSUBound;
    LONG i = 0;
    LONG j, k;
    DWORD nCurrent = 0;

    *pOIDs = NULL;
    *pnNumOfOids = 0;

    if ( !V_ISARRAY( &vProp))
    {
        // special case of one object (not an array)

        nIndex = FindSearchTableIndex( V_BSTR(&vProp),
                                       hSchema->aPropertiesSearchTable,
                                       hSchema->nNumOfProperties * 2 );

        if ( nIndex != -1 )
        {
            *pOIDs = (int *) AllocADsMem( sizeof(int) * 2);
            if ( *pOIDs == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            (*pOIDs)[nCurrent++] = nIndex;
            (*pOIDs)[nCurrent] = -1;
            *pnNumOfOids = 1;
        }
        else
        {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

        RRETURN_EXP_IF_ERR(hr);
    }

    //
    // Here, we have an array of properties. We want to create an array of
    // indexes into the aPropertiesSearchTable
    //

    hr = SafeArrayGetLBound(V_ARRAY(&vProp),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&vProp),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    *pOIDs = (int *) AllocADsMem( sizeof(int) * (dwSUBound - dwSLBound + 2));
    if ( *pOIDs == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VARIANT v;

        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&vProp),
                                (long FAR *)&i,
                                &v
                                );
        BAIL_ON_FAILURE(hr);

        nIndex = FindSearchTableIndex( V_BSTR(&v),
                                       hSchema->aPropertiesSearchTable,
                                       hSchema->nNumOfProperties * 2 );

        VariantClear(&v);

        if ( nIndex != -1 )
        {
            (*pOIDs)[nCurrent++] = nIndex;
        }
        else
        {
            hr = E_ADS_PROPERTY_NOT_FOUND;
            BAIL_ON_FAILURE(hr);
        }
    }

    (*pOIDs)[nCurrent] = -1;
    *pnNumOfOids = nCurrent;

    SortAndRemoveDuplicateOIDs( *pOIDs, pnNumOfOids );

error:

    if (FAILED(hr))
    {
        if ( *pOIDs )
        {
            FreeADsMem( *pOIDs );
            *pOIDs = NULL;
        }
    }

    RRETURN(hr);

}

HRESULT
MakePropArrayFromStringArray(
    LPTSTR *aValues,
    DWORD  nCount,
    SCHEMAINFO *hSchema,
    int **pOIDs,
    DWORD *pnNumOfOids
)
{
    HRESULT hr = S_OK;
    int nIndex;
    DWORD i = 0;
    DWORD nCurrent = 0;

    *pOIDs = NULL;
    *pnNumOfOids = 0;

    //
    // Here, we have an array of properties. We want to create an array of
    // indexes into the aPropertiesSearchTable
    //

    *pOIDs = (int *) AllocADsMem( sizeof(int) * (nCount+1));
    if ( *pOIDs == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < nCount ; i++) {

        nIndex = FindSearchTableIndex( aValues[i],
                                       hSchema->aPropertiesSearchTable,
                                       hSchema->nNumOfProperties * 2 );

        if ( nIndex != -1 )
        {
            (*pOIDs)[nCurrent++] = nIndex;
        }
        else
        {
            hr = E_ADS_PROPERTY_NOT_FOUND;
            BAIL_ON_FAILURE(hr);
        }
    }

    (*pOIDs)[nCurrent] = -1;
    *pnNumOfOids = nCurrent;

    qsort( *pOIDs, *pnNumOfOids, sizeof((*pOIDs)[0]), intcmp );

error:

    if (FAILED(hr))
    {
        if ( *pOIDs )
        {
            FreeADsMem( *pOIDs );
            *pOIDs = NULL;
        }
    }

    RRETURN(hr);
}

/******************************************************************/
/*  Misc Schema functions
/******************************************************************/

BOOL
GetLdapClassPrimaryInterface(
    LPTSTR  pszLdapClass,
    GUID  **ppPrimaryInterfaceGUID,
    GUID  **ppCLSID
)
{
    for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
    {
        if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
        {
            *ppPrimaryInterfaceGUID = (GUID *) aClassMap[i].pPrimaryInterfaceGUID;
            *ppCLSID = (GUID *) aClassMap[i].pCLSID;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
GetPrimaryInterface(
    LPTSTR pszClassName,
    SCHEMAINFO *pSchemaInfo,
    PCLASSNAME_LIST pClassNames,
    GUID **ppPrimaryInterfaceGUID,
    GUID **ppCLSID
)
{
    int i = 0;
    CLASSINFO *pClassInfo;
    LPTSTR pszName;
    DWORD index;

    PCLASSNAME_LIST pClass = NULL;
    PCLASSNAME_LIST pNextClass = NULL;
    BOOL fExitStatus = FALSE;

    if ( GetLdapClassPrimaryInterface( pszClassName,
                                       ppPrimaryInterfaceGUID,
                                       ppCLSID ))
    {
        return TRUE;
    }

    index = (DWORD) FindEntryInSearchTable(
                        pszClassName,
                        pSchemaInfo->aClassesSearchTable,
                        2 * pSchemaInfo->nNumOfClasses );

    if ( index == ((DWORD) -1) )
        return FALSE;

    //
    // Recursively search the list of superiors and
    // aux classes.  To avoid loops, we maintain a list
    // of classes we have already reached.  If we are called
    // with a class on this list, we abort.
    //

    //
    // Make sure the current class isn't already on the list
    //
    if (pClassNames) {

        for (pNextClass = pClassNames;
             pNextClass != NULL;
             pNextClass = pNextClass->pNext)
        {

            if (_tcscmp(pNextClass->pszClassName, pszClassName) == 0)
            {
                // found match, bail
                fExitStatus = FALSE;
                BAIL_ON_SUCCESS(S_OK);
            }
        }
    }

    //
    // Construct a node for the current class & add it to the list
    //
    pClass = static_cast<PCLASSNAME_LIST>(AllocADsMem(sizeof(CLASSNAME_LIST)));
    if (!pClass) {
        BAIL_ON_FAILURE(E_OUTOFMEMORY);
    }

    pClass->pszClassName = static_cast<LPTSTR>(AllocADsMem((_tcslen(pszClassName)+1) * sizeof(TCHAR)));
    if (!pClass->pszClassName) {
        BAIL_ON_FAILURE(E_OUTOFMEMORY);
    }

    _tcscpy(pClass->pszClassName, pszClassName);

    pClass->pNext = pClassNames;
    

    //
    // Perform the recursive search
    //
    pClassInfo = &(pSchemaInfo->aClasses[index]);

    if ( pClassInfo->pOIDsSuperiorClasses )
    {
        for ( i = 0;
              (pszName = pClassInfo->pOIDsSuperiorClasses[i]);
              i++  )
        {
            if ( GetPrimaryInterface( pszName, pSchemaInfo, pClass,
                                      ppPrimaryInterfaceGUID, ppCLSID )) 
            {
                fExitStatus = TRUE;
                BAIL_ON_SUCCESS(S_OK);
            }
        }
    }

    if ( pClassInfo->pOIDsAuxClasses )
    {
        for ( i = 0;
              (pszName = pClassInfo->pOIDsAuxClasses[i]);
              i++  )
        {
            if ( GetPrimaryInterface( pszName, pSchemaInfo, pClass,
                                      ppPrimaryInterfaceGUID, ppCLSID )) 
            {
                fExitStatus = TRUE;
                BAIL_ON_SUCCESS(S_OK);
            }
        }
    }

error:

    //
    // Each level of recursion is responsible for freeing
    // its own corresponding node.
    //
    if (pClass) {

        if (pClass->pszClassName) {
            FreeADsMem(pClass->pszClassName);
        }
    
        FreeADsMem(pClass);
    }

    return fExitStatus;
}

HRESULT
SchemaGetPrimaryInterface(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR pszClassName,
    GUID **ppPrimaryInterfaceGUID,
    GUID **ppCLSID
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    GetPrimaryInterface(
        pszClassName,
        pSchemaInfo,
        NULL,
        ppPrimaryInterfaceGUID,
        ppCLSID );

    RRETURN(hr);
}


BOOL
MapLdapClassToADsClass(
    LPTSTR *aLdapClasses,
    int nCount,
    LPTSTR pszADsClass
)
{
    *pszADsClass = 0;

    if ( nCount == 0 )
        return FALSE;

    if ( _tcsicmp( aLdapClasses[nCount-1], TEXT("Top")) == 0 )
    {
        for ( int j = 0; j < nCount; j++ )
        {
            LPTSTR pszLdapClass = aLdapClasses[j];

            for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
            {
                if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
                {
                    _tcscpy( pszADsClass, aClassMap[i].pszADsClassName );
                    return TRUE;
                }
            }
        }

        _tcscpy( pszADsClass, aLdapClasses[0] );
        return FALSE;

    }
    else
    {
        for ( int j = nCount-1; j >= 0; j-- )
        {
            LPTSTR pszLdapClass = aLdapClasses[j];

            for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
            {
                if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
                {
                    _tcscpy( pszADsClass, aClassMap[i].pszADsClassName );
                    return TRUE;
                }
            }
        }

        _tcscpy( pszADsClass, aLdapClasses[nCount-1] );
        return FALSE;
    }

}

BOOL
MapLdapClassToADsClass(
    LPTSTR pszClassName,
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR pszADsClass
)
{
    LPTSTR aClasses[1];
    CLASSINFO *pClassInfo = NULL;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    *pszADsClass = 0;

    aClasses[0] = pszClassName;
    if ( MapLdapClassToADsClass( aClasses, 1, pszADsClass ))
        return TRUE;

    DWORD index = (DWORD) FindEntryInSearchTable(
                        pszClassName,
                        pSchemaInfo->aClassesSearchTable,
                        2 * pSchemaInfo->nNumOfClasses );

    if ( index == ((DWORD) -1) )  // cannot find the class name in the schema
    {
        _tcscpy( pszADsClass, pszClassName );
        return FALSE;
    }

    pClassInfo = &(pSchemaInfo->aClasses[index]);

    if ( pClassInfo->pOIDsSuperiorClasses )
    {
        LPTSTR pszName = NULL;
        for ( int i = 0;
              (pszName = pClassInfo->pOIDsSuperiorClasses[i]);
              i++  )
        {
            if ( MapLdapClassToADsClass( pszName, pSchemaInfo, pszADsClass))
                return TRUE;
        }
    }

    _tcscpy( pszADsClass, pszClassName );
    return FALSE;
}

LPTSTR
MapADsClassToLdapClass(
    LPTSTR pszADsClass,
    LPTSTR pszLdapClass
)
{
    for ( int i=0; i < ARRAY_SIZE(aClassMap); i++ )
    {
        if ( _tcsicmp( pszADsClass, aClassMap[i].pszADsClassName ) == 0 )
        {
            _tcscpy( pszLdapClass, aClassMap[i].pszLdapClassName );
            return pszLdapClass;
        }
    }

    _tcscpy( pszLdapClass, pszADsClass );
    return pszLdapClass;
}


STDMETHODIMP
makeUnionVariantFromLdapObjects(
    LDAPOBJECTARRAY ldapSrcObjects1,
    LDAPOBJECTARRAY ldapSrcObjects2,
    VARIANT FAR * pvPossSuperiors
    )
{
    HRESULT hr = S_OK;
    BSTR *retVals = NULL;
    DWORD dwNumVals = 0;
    BSTR curString = NULL;
    DWORD dwMaxVals = 0;
    DWORD dwCtr = 0;
    DWORD dwArrIndx = 0;
    PLDAPOBJECT pLdapObject;

    dwMaxVals = ldapSrcObjects1.dwCount + ldapSrcObjects2.dwCount + 1;

    retVals = (BSTR *)AllocADsMem(dwMaxVals * sizeof(BSTR *));

    if (!retVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


    for (dwCtr = 0; dwCtr < ldapSrcObjects1.dwCount; dwCtr++) {

        pLdapObject = ldapSrcObjects1.pLdapObjects + dwCtr;
        curString = LDAPOBJECT_STRING(pLdapObject);
        hr = addStringIfAbsent(curString, retVals, &dwArrIndx);
        BAIL_ON_FAILURE(hr);
    }


    for (dwCtr = 0; dwCtr < ldapSrcObjects2.dwCount; dwCtr++) {

        pLdapObject = ldapSrcObjects2.pLdapObjects + dwCtr;
        curString = LDAPOBJECT_STRING(pLdapObject);
        hr = addStringIfAbsent(curString, retVals, &dwArrIndx);
        BAIL_ON_FAILURE(hr);
    }

    // do the same for the second ldapobjectarray

    hr = MakeVariantFromStringArray(retVals, pvPossSuperiors);

error:
    // clean up the string array either way
    for (dwCtr=0; dwCtr < dwArrIndx; dwCtr++) {
        ADsFreeString(retVals[dwCtr]);
    }
    FreeADsMem(retVals);

    RRETURN(hr);
}

STDMETHODIMP
addStringIfAbsent(
    BSTR addString,
    BSTR *strArray,
    PDWORD dwArrIndx
    )
{
    HRESULT hr = S_OK;
    DWORD dwCtr = 0;
    BOOLEAN fFound = FALSE;

    for (dwCtr = 0; (dwCtr < *dwArrIndx) && !fFound; dwCtr ++) {
        if (!_wcsicmp(addString, strArray[dwCtr])) {
            fFound = TRUE;
        }
    }

    if (!fFound) {

        hr = ADsAllocString(
                 addString,
                 &strArray[*dwArrIndx]
                 );

        BAIL_ON_FAILURE(hr);

        (*dwArrIndx)++;

        strArray[*dwArrIndx] = NULL;
    }

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cumicurs.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumicurs.cxx
//
//  Contents: Contains the UMI cursor object implementation. There are 2
//          ways to use this object. One is to initialize with an 
//          IADsContainer pointer and the other is to use an IUmiQuery obj.
//
//  History:  03-16-00    SivaramR  Created (in WinNT)
//            03-28-00    AjayR  modified for LDAP.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::CUmiCursor
//
// Synopsis:   Constructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CUmiCursor::CUmiCursor():
    _pPropMgr(NULL),
    _ulErrorStatus(0),
    _pIID(NULL),
    _pContainer(NULL),
    _pEnum(NULL),
    _pSearchHelper(NULL),
    _fQuery(FALSE)
{
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::~CUmiCursor
//
// Synopsis:   Destructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CUmiCursor::~CUmiCursor()
{
    if (_pPropMgr) {
        delete _pPropMgr;
    }

    if (_pContainer) {
        _pContainer->Release();
    }

    if (_pIID){
        FreeADsMem(_pIID);
    }

    if (_pEnum) {
        _pEnum->Release();
    }

    if (_pSearchHelper) {
        delete _pSearchHelper;
    }
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::CreateCursor (static constructor overloaded)
//
// Synopsis:   Creats a UmiCursor object in the container mode.
//
// Arguments:  *pCont      - Pointer to container we are enumerating.
//             iid         - IID requested on returned object.
//             ppInterface - Ptr to return value.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   ppInterface to point to new cursor object.
//
//----------------------------------------------------------------------------
HRESULT 
CUmiCursor::CreateCursor(
    IUnknown *pCont,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    CUmiCursor *pCursor = NULL;
    CPropertyManager *pPropMgr = NULL;
    IADsContainer *pContainer = NULL;
    HRESULT    hr = S_OK;

    ADsAssert(ppInterface);
    ADsAssert(pCont);

    pCursor = new CUmiCursor();
    if (!pCursor) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Initialize the various params on this object.
    //
    hr = CPropertyManager::CreatePropertyManager(
             (IUnknown *) pCursor,
             NULL, // IADs ptr
             NULL, // pCreds
             IntfPropsCursor,
             &pPropMgr
             );
    BAIL_ON_FAILURE(hr);

    hr = pCont->QueryInterface(
             IID_IADsContainer, 
             (void **) &pContainer
             );
    BAIL_ON_FAILURE(hr);

    hr = pCursor->QueryInterface(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

    //
    // Ref on this object is now 2, release the additional ref.
    //
    pCursor->Release();

    pCursor->_pContainer = pContainer;
    pCursor->_pPropMgr = pPropMgr;
    pCursor->_pIID = NULL;
    pCursor->_ulErrorStatus = 0;


    RRETURN(S_OK);

error:

    if (pCursor) {
        delete pCursor;
    }

    if (pPropMgr) {
        delete pPropMgr;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::CreateCursor (static constructor overloaded).
//
// Synopsis:   Creats a UmiCursor object in the query mode. Most of the 
//          params are needed for creating the search helper object.
//
// Arguments:  pQuery        - Query being executed.
//             pConnection   - Connection being used for query.
//             pUnk          - ???.
//             pszADsPath    - Path of object query is being executed on.
//             pszLdapServer - Server of object being queried.
//             pszLdapDn     - Dn of the object being searched.
//             cCredentials  - Credentials to use for query.
//             dwPort        - Port being used for connection.
//             iid           - Cursor iid requested 
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   ppInterface to point to new cursor object.
//
//----------------------------------------------------------------------------
HRESULT
CUmiCursor::CreateCursor(
    IUmiQuery *pQuery,
    IUmiConnection *pConnection,
    IUnknown *pUnk,
    LPCWSTR pszADsPath,
    LPCWSTR pszLdapServer,
    LPCWSTR pszLdapDn,
    CCredentials cCredentials,
    DWORD dwPort,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    CUmiCursor *pCursor = NULL;
    CPropertyManager *pPropMgr = NULL;
    HRESULT    hr = S_OK;
    CUmiSearchHelper *pSearchHelper = NULL;

    ADsAssert(ppInterface);

    hr = CUmiSearchHelper::CreateSearchHelper(
             pQuery,
             pConnection,
             pUnk,
             pszADsPath,
             pszLdapServer,
             pszLdapDn,
             cCredentials,
             dwPort,
             &pSearchHelper
             );
    BAIL_ON_FAILURE(hr);

    pCursor = new CUmiCursor();
    if (!pCursor) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Initialize the various params on this object.
    //
    hr = CPropertyManager::CreatePropertyManager(
             (IUnknown *) pCursor,
             NULL, // pIADs
             NULL, // pCreds
             IntfPropsCursor,
             &pPropMgr
             );
    BAIL_ON_FAILURE(hr);

    hr = pCursor->QueryInterface(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

    //
    // Ref on this object is now 2, release the additional ref.
    //
    pCursor->Release();

    pCursor->_pSearchHelper = pSearchHelper;
    pCursor->_pPropMgr = pPropMgr;
    pCursor->_pIID = NULL;
    pCursor->_ulErrorStatus = 0;
    pCursor->_fQuery = TRUE;

    RRETURN(S_OK);

error:

    if (pCursor) {
        delete pCursor;
    }

    if (pSearchHelper) {
        delete pSearchHelper;
    }

    if (pPropMgr) {
        delete pPropMgr;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::QueryInterface (IUnknown interface).
//
// Synopsis:   Standard QueryInterface function.
//
// Arguments:  Self explanatory.
//
// Returns:    S_OK on success or any suitable error code.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if (!ppInterface)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(iid, IID_IUnknown)) {
        *ppInterface = (IUmiCursor *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiBaseObject)) {
        *ppInterface = (IUmiCursor *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppInterface = (IUmiCursor *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiCursor)) {
        *ppInterface = (IUmiCursor *) this;
    }
    else {
        *ppInterface = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::GetLastStatus (IUmiBaseObject method).
//
// Synopsis:   Returns only numeric status code from the last operation.
//
// Arguments:  uFlags           -  Only 0 is supported for now.
//             puSpecificStatus -  Returns status/error code.
//             riid             -  Not used.
//             pStatusObj       -  NULL, not used currently.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *puSpecificStatus to return appropriate status code.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if (uFlags != 0) {
       RRETURN(UMI_E_INVALID_FLAGS);
    }

    if (!puSpecificStatus) {
        RRETURN(E_INVALIDARG);
    }

    if (pStatusObj) {
        //
        // Should we error out ?
        //
        *pStatusObj = NULL;
    }

    *puSpecificStatus = _ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::GetInterfacePropList (IUmiBaseObject method).
//
// Synopsis:   Returns a pointer to the interface property list for
//          cursor object.
//
// Arguments:  uFlags      -  Flags, only 0 is supported.
//             ppPropList  -  Return value.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList changed to IUmiPropList pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **ppPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if (uFlags != 0) {
        RRETURN(UMI_E_INVALID_FLAGS);
    }

    if (!ppPropList) {
        RRETURN(E_INVALIDARG);
    }

    hr = _pPropMgr->QueryInterface(IID_IUmiPropList, (void **)ppPropList);

    if (FAILED(hr)) {
        SetLastStatus(hr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::SetLastStatus (internal private helper routine).
//
// Synopsis:   Sets the status of the last operation. If the status is one
//             of the pre-defined error codes, then the status is just set to
//             0 since we are not adding any value by returning the same
//             status as the error code.
//
// Arguments:  ulStatus      -   Status to be set.
//
// Returns:    Nothing
//
// Modifies:   Internal member status variable.
//
//----------------------------------------------------------------------------
void 
CUmiCursor::SetLastStatus(ULONG ulStatus)
{
    this->_ulErrorStatus = ulStatus;

    return;
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::SetIID (IUmiCursor method).
//
// Synopsis:   Sets the interface to be requested off each item returned by
//             the enumerator. Default is IID_IUmiObject. 
//
// Arguments: riid        -   IID of interface to request.
//
// Returns:   UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:  Nothing. 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUmiCursor::SetIID(
    REFIID riid
    )
{
    SetLastStatus(0);

    if (_fQuery) {
        RRETURN(this->_pSearchHelper->SetIID(riid));
    } 
    else {
        if (!_pIID){
    
           _pIID = (IID *) AllocADsMem(sizeof(IID));
           if (!_pIID){
               RRETURN(E_OUTOFMEMORY);
           }
        }

        memcpy(_pIID, &riid, sizeof(IID));
    }

    RRETURN(UMI_S_NO_ERROR);
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::Reset (IUmiCursor method).
//
// Synopsis:   Resets the enumerator to restart from begining (this is for
//          likely to return an error for the IADsContainer case).
//
// Arguments:  N/A.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::Reset(void)
{
    HRESULT hr = E_NOTIMPL;
    RRETURN(hr);

    //
    // Rest of the code can be invoked when we have proper support.
    //
    SetLastStatus(0);

    if (!_fQuery) {
    
        //
        // it is possible that _pEnum may be NULL here if the user
        // called Reset before calling Next()
        //
        if (!_pEnum) {
            RRETURN(UMI_S_NO_ERROR);
        }
    
        hr = _pEnum->Reset();
        BAIL_ON_FAILURE(hr);

        hr = S_OK;
    } 
    else {
        hr = _pSearchHelper->Reset();
    }

error:

    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }
    
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::GetFilter (internal private helper routine).
//
// Synopsis:   Gets the filter from the interface property cache. If the
//             interface property was not set, an emty variant is returned. 
//
// Arguments:  pvFilter   -  ptr to variant for return value.
//
// Returns:    UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:   *pvFilter to return the filter. 
//
//----------------------------------------------------------------------------
HRESULT
CUmiCursor::GetFilter(VARIANT *pvFilter)
{
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    LPWSTR              *ppszFilters = NULL;
    DWORD               dwNumFilters = 0;

    ADsAssert(pvFilter);

    VariantInit(pvFilter);

    hr = _pPropMgr->Get(
             L"__FILTER",
             0,
             &pUmiProp
             );

    if (hr == UMI_E_NOT_FOUND) {
        //
        // interface property was not set. Return empty variant.
        //
        RRETURN(hr);
    }

    BAIL_ON_FAILURE(hr);

    ADsAssert(pUmiProp->pPropArray->uType == UMI_TYPE_LPWSTR);
    //
    // Make sure we have data back and that it is not just NULL.
    // We will not get back a NULL string but instead an array with 
    // one element that is NULL. That is as good as no filter.
    //
    if (pUmiProp->pPropArray->uCount
        && pUmiProp->pPropArray->pUmiValue
        && pUmiProp->pPropArray->pUmiValue->pszStrValue[0]
        ) {
        //
        // Valid filter is present.
        //
        ppszFilters = pUmiProp->pPropArray->pUmiValue->pszStrValue;
        dwNumFilters = pUmiProp->pPropArray->uCount;

        hr = ADsBuildVarArrayStr(ppszFilters, dwNumFilters, pvFilter);
        BAIL_ON_FAILURE(hr);
    }
    else {
        hr = UMI_E_NOT_FOUND;
    }

error:

    if (pUmiProp) {
        _pPropMgr->FreeMemory(0, pUmiProp);
    }
    RRETURN(hr);
} 

//+---------------------------------------------------------------------------
// Function:   CUmiCursor::Next  (IUmiCursor method). 
//
// Synopsis:   Returns the next "n" item(s) in the enumeration sequence.
//
// Arguments:  uNumRequested     -  Number of items requested.
//             pNumReturned      -  Returns actual number of objects returned.
//             ppObjects         -  Array of interface pointers of size 
//                                 *pNumReturned.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pNumReturned to return the number of objects returned
//             *ppObjects to return the interface pointers 
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CUmiCursor::Next(
    ULONG uNumRequested,
    ULONG *puNumReturned,
    LPVOID *ppObjects
    )
{
    HRESULT   hr = S_OK;;
    VARIANT   vFilter, *pvResults = NULL;
    ULONG     ulIndex = 0, uNumReturned = 0, uNumResults = 0;
    IDispatch *pDisp = NULL;
    IUnknown  **pUnkArr = NULL, *pTmpUnk = NULL;
    VARIANT   vOldFilter;
    BOOL      fReplaceFilter = FALSE;

    SetLastStatus(0);
    VariantInit(&vOldFilter);

    if ( (!puNumReturned) || (!ppObjects) ){
        RRETURN(E_INVALIDARG);
    }

    *puNumReturned = 0;
    *ppObjects = NULL;

    //
    // If this is a query then we need to get the results from the
    // query object.
    //
    if (_fQuery) {
        hr = _pSearchHelper->Next(
                 uNumRequested,
                 puNumReturned,
                 ppObjects
                 );
        //
        // MapHrToUmiError
        //
        RRETURN(hr);
    }

    //
    // If we get here this is a container enumerate.
    //
    VariantInit(&vFilter);

    if (!_pEnum) {
        //
        // first call to Next()
        //
        ADsAssert(_pContainer);

        //
        // check if the user set a filter on the cursor 
        //
        hr = GetFilter(&vFilter);
        if (SUCCEEDED(hr)) {
            //
            // We need to get the old filter to restore it.
            //
            hr = _pContainer->get_Filter(&vOldFilter);
            if (SUCCEEDED(hr)) {
                fReplaceFilter = TRUE;
            }
            //
            // We have a valid filter that we need to set.
            //
            hr = _pContainer->put_Filter(vFilter);
        } 
        else if (hr == UMI_E_NOT_FOUND) {
            //
            // Reset error as this one is expected, anything else we bail.
            //
            hr = S_OK;
        } 
        //
        // Catch either GetFilter failure or put_Filter failure.
        //
        BAIL_ON_FAILURE(hr);
        
        hr = _pContainer->get__NewEnum((IUnknown **) &_pEnum);
        //
        // Restore old filter irrespective of ECODE.
        //
        if (fReplaceFilter) {
            _pContainer->put_Filter(vOldFilter);
        }
        BAIL_ON_FAILURE(hr);
    }

    //
    // allocate memory for variants to return objects
    //
    pvResults = (VARIANT *) AllocADsMem(uNumRequested * sizeof(VARIANT));
    if (!pvResults) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = _pEnum->Next(
             uNumRequested,
             pvResults,
             &uNumReturned
             );
    BAIL_ON_FAILURE(hr);

    if (!uNumReturned) {
        //
        // This will handle the S_FALSE case.
        //
        goto error;
    }

    //
    // allocate memory for array of interface pointers to return
    //
    pUnkArr = (IUnknown **) AllocADsMem(uNumReturned * sizeof(IUnknown *));
    if (!pUnkArr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // convert the V_DISPATCH variants to the requested interface properties
    //
    for(ulIndex = 0; ulIndex < uNumReturned; ulIndex++) {

        pDisp = V_DISPATCH(&pvResults[ulIndex]);

        if (_pIID) {
            hr = pDisp->QueryInterface(*_pIID, (void **) &pTmpUnk);
        } 
        else {
            hr = pDisp->QueryInterface(IID_IUmiObject, (void **) &pTmpUnk);
        }

        //
        // Is this really correct ?
        //
        if (FAILED(hr)) {
            continue;
        }

        pUnkArr[uNumResults] = pTmpUnk;
        uNumResults++;
    }

    *puNumReturned = uNumResults;

    if (uNumResults > 0) {
        *ppObjects = pUnkArr;
    }
    else {
        FreeADsMem(pUnkArr);
    }
       
error:

    VariantClear(&vFilter);
    VariantClear(&vOldFilter);

    if (pvResults) {
        for(ulIndex = 0; ulIndex < uNumReturned; ulIndex++) {
            VariantClear(&pvResults[ulIndex]);
        }

        FreeADsMem(pvResults);
    }
            
    if (FAILED(hr)) {
        SetLastStatus(hr);
        hr = MapHrToUmiError(hr);
    }

    RRETURN(hr);
}    

//+---------------------------------------------------------------------------
// Function:   Count 
//
// Synopsis:   Counts the number of results returned by the enumerator.
//             Not implemented currently.
//
// Arguments:
//
// None
//
// Returns:    E_NOTIMPL for now.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Count(
    ULONG *puNumObjects
    )
{
    SetLastStatus(0);

    RRETURN(E_NOTIMPL);
}       

//+---------------------------------------------------------------------------
// Function:   Previous 
//
// Synopsis:   Returnss the previous object returned by the enumerator.
//             Not implemented currently.
//
// Arguments:
//
// None
//
// Returns:    E_NOTIMPL for now.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Previous(
    ULONG uFlags,
    LPVOID *pObj 
    )
{
    SetLastStatus(0);

    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cumisrch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       umisrch.cxx
//
//  Contents: This object wraps an IDirectorySearch and returns Umi objects
//          as a result of the search. The Umi objects returned are
//          pre-populated with the attributes received from the search.
//          This object is used by the cursor object to support the
//          IUmiCursor interface.
//            This file also contains the CQueryStack helper class that is
//          used by the SearcHelper to parse SQL queries.
//
//  History:    03-20-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//
// Helper functions.
//

//+---------------------------------------------------------------------------
// Function:   HelperGetAttributeList - helper routine.
//
// Synopsis:   Gets a list of attributes that can be used in an execute
//          search call from the wbem query information.
//
// Arguments:  pdwAttribCount    -   Returns the number of attributes.
//                                 -1 means all attributes.
//             pppszAttribArray  -   Return value for string array.
//             ulListSize        -   Size of list of wbem names.
//             pWbemNames        -   The list of parsed tokens.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pdwAttribCount to correct value and pppszAttribArray to 
//          array of strings containing the attribute list.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetAttributeList(
    PDWORD pdwAttribCount,
    LPWSTR ** pppszAttribArray,
    ULONG ulListSize,
    SWbemQueryQualifiedName **pWbemNames
    )
{
    HRESULT hr = S_OK;
    DWORD dwCtr = 0;
    SWbemQueryQualifiedName *pName = NULL;
    LPWSTR pszTmpString = NULL;

    //
    // There should at least be a * in the list.
    //
    ADsAssert(pWbemNames);

    *pppszAttribArray = NULL;
    *pdwAttribCount = (DWORD) -1;

    //
    // If the count is just one we need to see if this is just *.
    //
    if (ulListSize == 1) {
        pName = pWbemNames[0];
        if (pName->m_ppszNameList
            && pName->m_ppszNameList[0]
            ) {
            if (_wcsicmp(pName->m_ppszNameList[0], L"*")) {
                //
                // We need to retun NULL and -1 for count.
                //
                RRETURN(hr);
            }
        }
        else {
            //
            // This has to be a bad query cause either 
            // 1) the name list was empty - cannot have empty from clause,
            // 2) the name list had an empty string in it, or
            //
            BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED_QUERY ???
        }
    }
    
    //
    // At this point we have a valid attribute list.
    //
    *pppszAttribArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * ulListSize);
    if (!*pppszAttribArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; dwCtr < ulListSize; dwCtr++) {
        pszTmpString = NULL;
        pName = pWbemNames[dwCtr];
        
        if (!pName || !pName->m_ppszNameList) {
            BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_BAD_QUERY ???
        }
        
        // 
        // ADSI does not expect more than one entry in each of the pName's.
        // so if some did user.Description then we just treat this as 
        // as description by using the last value always.
        //
        pszTmpString = AllocADsStr(
            pName->m_ppszNameList[pName->m_uNameListSize-1]
            );

        if (!pszTmpString) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
        (*pppszAttribArray)[dwCtr] = pszTmpString;
    }

    *pdwAttribCount = ulListSize;

error:

    if (FAILED(hr)) {
        if (*pppszAttribArray) {
            for (dwCtr = 0; dwCtr < ulListSize; dwCtr++) {
                pszTmpString = (*pppszAttribArray)[dwCtr];
                if (pszTmpString) {
                    FreeADsStr(pszTmpString);
                }
            }
            FreeADsMem(*pppszAttribArray);
            *pppszAttribArray = NULL;
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetFromList - helper routine.
//
// Synopsis:   Get a filter that represents the from list. For now this
//          will only return NULL. However we will need to spruce this fn
//          if we need to support a list of classes in here.
//
// Arguments:  ppszFromFilter    -   Return value for a filter corresponding
//                                to the From list.
//             pQuery            -   Wbem query object.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   *ppszFromFilter if From list is valid.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetFromList(
    LPWSTR *ppszFromFilter,
    SWbemRpnEncodedQuery *pQuery
    )
{
    HRESULT hr = E_FAIL;
    LPWSTR pszFilter = NULL;


    *ppszFromFilter = NULL;

    if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_PATH) {
        //
        // This can only be . for now.
        //
        if (!_wcsicmp(L".", pQuery->m_pszOptionalFromPath)) {
            //
            // We are ok as long as there are no other pieces.
            //
            RRETURN(S_OK);
        } 
        else {
            RRETURN(E_FAIL); // UMI_E_NOT_SUPPORTED ???
        }
    }

    //
    // For now we are going to ignore pieces if there are any other
    // pieces in the from clause.
    //
    if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_UNARY) {
        // hr = E_FAIL; UMI_E_NOT_SUPPORTED.
        hr = S_OK;
    }
    else if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_CLASS_LIST) {
        // hr = E_FAIL; UMI_E_NOT_SUPPORTED.
        //for (unsigned u = 0; u < pQuery->m_uFromListSize; u++)
        //{
        // printf("  Selected class = %S\n", pQuery->m_ppszFromList[u]);
        //}
        hr = S_OK;
    }
    else {
        //
        // The query does not have anything in the from clause.
        // This is an invalid query.
        //
        hr = E_FAIL; // UMI_E_NOT_SUPPORTED ???
    }

    RRETURN(hr);
}
 
//+---------------------------------------------------------------------------
// Function:   HelperGetSubExpressionFromOperands - helper routine.
//
// Synopsis:   Updates the result with the operands and the operator. This
//          routine munges the operators/operands around so that we can
//          support operands not supported by ldap directly.
//
// Arguments:  pszResult      -   Return value, allocated by caller.
//             pszOperand1    -   The attribute being tested.
//             pszOperand2    -   The value being tested against.
//             ulOperator     -   Inidcates the comparision type.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pStack contents.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetSubExpressionFromOperands(
    LPWSTR pszResult,
    LPWSTR pszOperand1,
    LPWSTR pszOperand2,
    ULONG  ulOperator
    )
{
    HRESULT hr = S_OK;

    //
    // In all cases we will need to begin with "(".
    //
    wsprintf(pszResult, L"(");

    //
    // All these are easy to handle.
    //
    if ((ulOperator == WMIQ_RPN_OP_EQ)
        || (ulOperator == WMIQ_RPN_OP_LT)
        || (ulOperator == WMIQ_RPN_OP_GT)
        ) {
        wcscat(pszResult, pszOperand1);
    }

    switch (ulOperator) {
    
    case WMIQ_RPN_OP_EQ :
        wcscat(pszResult, L"=");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L")");
        break;

    case WMIQ_RPN_OP_LT :
        wcscat(pszResult, L"<");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L")");
        break;

    case WMIQ_RPN_OP_GT :
        wcscat(pszResult, L">");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L")");
        break;

    //
    // All these need some processing as ldap does not 
    // handle these directly.
    //
    case WMIQ_RPN_OP_NE :
        //
        // This needs to be (!(operand1=operand2)) so a != b becomes
        // (!(a=b))
        //
        wcscat(pszResult, L"!");
        wcscat(pszResult, L"(");
        wcscat(pszResult, pszOperand1);
        wcscat(pszResult, L"=");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L"))");
        break;

    case WMIQ_RPN_OP_GE :
        //
        // a >= b becomes (!(a<b))
        //
        wcscat(pszResult, L"!(");
        wcscat(pszResult, pszOperand1);
        wcscat(pszResult, L"<");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L"))");
        break;

    case WMIQ_RPN_OP_LE :
        //
        // a <= b becomes (!(a>b))
        //
        wcscat(pszResult, L"!(");
        wcscat(pszResult, pszOperand1);
        wcscat(pszResult, L">");
        wcscat(pszResult, pszOperand2);
        wcscat(pszResult, L"))");
        break;

    default:
        hr = E_FAIL; // UMI_E_UNSUPPORTED_QUERY.
        break;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperProcessOperator - helper routine.
//
// Synopsis:   Pops 2 elements from the stack, applies the operator on them
//          and pushes the effective expression on to the stack.
//
// Arguments:  pStack        -   Valid stack which should have at least 2
//                             elements in the stack.
//             ulOperatorType-   Operator type corresponding to wbem enum.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pStack contents.
//
//----------------------------------------------------------------------------
HRESULT
HelperProcessSubExpression(
    CQueryStack *pStack,
    SWbemRpnQueryToken *pExpression
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszOperand1 = NULL;
    LPWSTR pszOperand2 = NULL;
    LPWSTR pszResult = NULL;
    ULONG ulShape = pExpression->m_uSubexpressionShape;
    DWORD dwTotalLen = 0;

    ADsAssert(pStack);

    //
    // As per what is supported we should not have a function.
    // However the query parses seems to always report functions so we
    // will ignore.
    //
    if (ulShape & WMIQ_RPN_LEFT_PROPERTY_NAME) {
        SWbemQueryQualifiedName *pName = pExpression->m_pLeftIdent;
        //
        // The identifier could be x.y.z in which case ADSI is only
        // interested in z
        //
        if (pName->m_ppszNameList[pName->m_uNameListSize-1]) {
            //
            // Alloc the name itself if the operand1 is not __CLASS.
            // If it is __CLASS we need to substitute with objectClass.
            //
            if (!_wcsicmp(
                     pName->m_ppszNameList[pName->m_uNameListSize-1],
                     L"__CLASS"
                     )
                ) {
                pszOperand1 = AllocADsStr(L"objectClass");
            } 
            else {
                //
                // Alloc whatever was passed in.
                //
                pszOperand1 = AllocADsStr(
                    pName->m_ppszNameList[pName->m_uNameListSize-1]
                    );
            }
            if (!pszOperand1) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        } 
        else {
            //
            // Something really wrong.
            //
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    } 
    else {
        //
        // We cannot handle this as there is no identifier on LHS.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // We should have the operand by now, need the value
    //
    switch (pExpression->m_uConstApparentType) {
    case VT_I4:
    case VT_UI4:
        //
        // We cannot possibly have more than 20 chars.
        //
        pszOperand2 = (LPWSTR) AllocADsMem(20 * sizeof(WCHAR));
        if (!pszOperand2) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        if (pExpression->m_uConstApparentType == VT_I4) {
            _ltot(pExpression->m_Const.m_lLongVal, pszOperand2, 10 );
        }
        else {
            _ltot(pExpression->m_Const.m_uLongVal, pszOperand2, 10);
        }
        break;

    case VT_BOOL:
        //
        // Again 20 sounds good !
        //
        pszOperand2 = (LPWSTR) AllocADsMem(20 * sizeof(WCHAR));
        if (!pszOperand2) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        if (pExpression->m_Const.m_bBoolVal )
            wcscpy(pszOperand2, L"TRUE");
        else
            wcscpy(pszOperand2, L"FALSE");
        break;

    case VT_LPWSTR:
        pszOperand2 = AllocADsStr(pExpression->m_Const.m_pszStrVal);
        if (!pszOperand2) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        break;

    default:
        BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED.
        break;
    }

    //
    // At this point we can combine the 2 operands and operator.
    // Total size is size of strings + () + 2 for operator + 1 for \0.
    // Total additions = 5. This is for most cases.
    //
    dwTotalLen = wcslen(pszOperand1) + wcslen(pszOperand2) + 5;

    //
    // Operators <= >= and != need to be processed to be usable in ldap.
    // In these cases, we assume that twice the length is needed.
    //
    dwTotalLen *= 2;

    pszResult = (LPWSTR) AllocADsMem(dwTotalLen * sizeof(WCHAR));
    if (!pszResult) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = HelperGetSubExpressionFromOperands(
             pszResult,
             pszOperand1,
             pszOperand2,
             pExpression->m_uOperator
             );

    /*
    wsprintf(pszResult, L"(");
    wcscat(pszResult, pszOperand1);
    
    //
    // Need to add the opearator now.
    //
    switch (pExpression->m_uOperator) {

    case WMIQ_RPN_OP_EQ :
        wcscat(pszResult,L"=");
        break;

    case WMIQ_RPN_OP_NE :
        wcscat(pszResult, L"!=");
        break;

    case WMIQ_RPN_OP_GE :
        wcscat(pszResult, L">=");
        break;

    case WMIQ_RPN_OP_LE :
        wcscat(pszResult, L"<=");
        break;

    case WMIQ_RPN_OP_LT :
        wcscat(pszResult, L"<");
        break;

    case WMIQ_RPN_OP_GT :
        wcscat(pszResult, L">");
        break;

        
    case WMIQ_RPN_OP_UNDEFINED:
    case WMIQ_RPN_OP_LIKE :
    case WMIQ_RPN_OP_ISA  :
    case WMIQ_RPN_OP_ISNOTA  :
    default :
        //
        // All these mean we have a bad query.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
        break;
    }

    //
    // Now tag on operand2 and the closing ), and push result onto stack.
    //
    wcscat(pszResult, pszOperand2);
    wcscat(pszResult, L")");
    */

    hr = pStack->Push(pszResult, QUERY_STACK_ITEM_LITERAL);
    BAIL_ON_FAILURE(hr);
error:

    if (pszOperand1) {
        FreeADsStr(pszOperand1);
    }

    if (pszOperand2) {
        FreeADsStr(pszOperand2);
    }

    if (pszResult) {
        FreeADsStr(pszResult);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperProcessOperator - helper routine.
//
// Synopsis:   Pops 2 elements from the stack, applies the operator on them
//          and pushes the effective expression on to the stack.
//
// Arguments:  pStack        -   Valid stack which should have at least 2
//                             elements in the stack.
//             ulOperatorType-   Operator type corresponding to wbem enum.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pStack contents.
//
//----------------------------------------------------------------------------
HRESULT
HelperProcessOperator(
    CQueryStack *pStack,
    ULONG ulOperatorType
    )
{
    HRESULT hr;
    LPWSTR pszStr1 = NULL;
    LPWSTR pszStr2 = NULL;
    LPWSTR pszResult = NULL;
    DWORD dwNodeType;
    DWORD dwTotalLen = 0;

    ADsAssert(pStack);

    hr = pStack->Pop(
             &pszStr1,
             &dwNodeType
             );
    BAIL_ON_FAILURE(hr);

    //
    // String has to be valid and the node cannot be an operator.
    //
    if (!pszStr1 || !*pszStr1
        || (dwNodeType != QUERY_STACK_ITEM_LITERAL) 
        ) {
        BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED_QUERY
    }

    dwTotalLen += wcslen(pszStr1);
    
    //
    // Not has only one operand.
    //
    if (ulOperatorType != WMIQ_RPN_TOKEN_NOT) {
        hr = pStack->Pop(
                 &pszStr2,
                 &dwNodeType
                 );
        BAIL_ON_FAILURE(hr);

        //
        // Sanity check.
        //
        if (!pszStr2 || !*pszStr2 
            || (dwNodeType != QUERY_STACK_ITEM_LITERAL)
            ) {
            BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED_QUERY
        }
        //
        // Need to add string2's length.
        //
        dwTotalLen += wcslen(pszStr2);
    }

    //
    // The resultant node needs to hold both strings and the operator
    // and the additional set of parentheses.
    // 4 = operator + () and one for \0.
    //
    dwTotalLen += 4;
    
    pszResult = (LPWSTR) AllocADsMem(dwTotalLen * sizeof(WCHAR));
    if (!pszResult) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wsprintf(pszResult, L"(");
    switch (ulOperatorType) {
    
    case WMIQ_RPN_TOKEN_AND :
        wcscat(pszResult, L"&");
        break;

    case WMIQ_RPN_TOKEN_OR :
        wcscat(pszResult, L"|");
        break;

    case WMIQ_RPN_TOKEN_NOT :
        wcscat(pszResult, L"!");
        break;

    default:
        BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED.
    }

    //
    // At this point we need to tag on both the pre composed pieces
    // and the final closing parentheses.
    //
    wcscat(pszResult, pszStr1);
    
    //
    // Do not Tag on the second string only if operator is NOT.
    //
    if (ulOperatorType != WMIQ_RPN_TOKEN_NOT) {
        wcscat(pszResult, pszStr2);
    }

    wcscat(pszResult, L")");

    //
    // Need to push the result on to the stack as a literal.
    //
    hr = pStack->Push(
             pszResult,
             QUERY_STACK_ITEM_LITERAL
             );
    BAIL_ON_FAILURE(hr);

error:

    if (pszStr1) {
        FreeADsStr(pszStr1);
    }

    if (pszStr2) {
        FreeADsStr(pszStr2);
    }

    if (pszResult) {
        FreeADsStr(pszResult);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HelperGetFilterFromWhereClause - helper routine.
//
// Synopsis:   Returns a filter corresponding to the elements specified in
//          the where clause.
//
// Arguments:  ppszFilter    -   Return value for a filter corresponding
//                             to the Where clause.
//             ulCount       -   Number of elements in the where clause.
//             pWhere        -   Pointer to the Wbem where clause.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   *ppszFilter if Where clause is valid.
//
//----------------------------------------------------------------------------
HRESULT
HelperGetFilterFromWhereClause(
    LPWSTR *ppszFilter,
    ULONG ulCount,
    SWbemRpnQueryToken **pWhere
    )
{
    HRESULT hr = S_OK;
    DWORD dwCtr;
    CQueryStack *pStack = NULL;
    LPWSTR pszFilter = NULL;
    DWORD dwType;

    *ppszFilter = NULL;

    if (!ulCount) {
        //
        // In this case we will default to NULL.
        //
        RRETURN(hr);
    }

    pStack = new CQueryStack();
    if (!pStack) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Process the tokens in the where clause.
    //
    for (dwCtr = 0; dwCtr < ulCount; dwCtr++) {
        SWbemRpnQueryToken *pToken = pWhere[dwCtr];

        switch (pToken->m_uTokenType) {
            //
            // All these are operations.
            //
        case WMIQ_RPN_TOKEN_AND :
        case WMIQ_RPN_TOKEN_OR :
        case WMIQ_RPN_TOKEN_NOT :
            HelperProcessOperator(pStack, pToken->m_uTokenType);
            break;

        case WMIQ_RPN_TOKEN_EXPRESSION :
            HelperProcessSubExpression(pStack, pToken);
            break;

        default:
            //
            // We cannot handle the query.
            //
            hr = E_FAIL; // UMI_E_UNSUPPORTED_QUERY.
            break;
        }
        BAIL_ON_FAILURE(hr);
    }

    //
    // At this stack should have one element and that should be
    // the filter we use if things went right.
    //
    hr = pStack->Pop(
             &pszFilter,
             &dwType
             );
    BAIL_ON_FAILURE(hr);

    if (!pStack->IsEmpty()) {
        BAIL_ON_FAILURE(hr = E_FAIL); // UMI_E_UNSUPPORTED_QUERY
    }

    *ppszFilter = pszFilter;

error:

    if (pStack) {
        delete pStack;
    }

    if (FAILED(hr) && pszFilter) {
        FreeADsStr(pszFilter);
    }

    RRETURN(hr);
}

HRESULT
HelperGetSortKey(
    SWbemRpnEncodedQuery *pRpn,
    PADS_SORTKEY * ppADsSortKey
    )
{
    HRESULT hr = S_OK;
    PADS_SORTKEY pSortKey = NULL;

    if (!pRpn->m_uOrderByListSize) {
        RRETURN(S_OK);
    }
    //
    // Allocate the sort key.
    //
    pSortKey = (PADS_SORTKEY) AllocADsMem(sizeof(ADS_SORTKEY));
    if (!pSortKey) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pSortKey->pszAttrType = AllocADsStr(pRpn->m_ppszOrderByList[0]);
    if (!pSortKey->pszAttrType) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (pRpn->m_uOrderDirectionEl[0]) {
        pSortKey->fReverseorder = TRUE;
    }

    RRETURN(S_OK);
error:

    if (pSortKey) {
        if (pSortKey->pszAttrType) {
            FreeADsStr(pSortKey->pszAttrType);
        }
        FreeADsMem(pSortKey);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::CUmiSearchHelper --- Constructor.
//
// Synopsis:   Standard constructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CUmiSearchHelper::CUmiSearchHelper():
    _hSearchHandle(NULL),
    _pConnection(NULL),
    _pContainer(NULL),
    _pszADsPath(NULL),
    _pszLdapServer(NULL),
    _pszLdapDn(NULL),
    _pIID(NULL),
    _fSearchExecuted(FALSE),
    _fResetAllowed(TRUE)
{
    //
    // This is global scope helper routine that will not fail.
    // The boolean is the value for cache results.
    //
    LdapInitializeSearchPreferences(&_searchPrefs, FALSE);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::~CUmiSearchHelper --- Destructor.
//
// Synopsis:   Standard destructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CUmiSearchHelper::~CUmiSearchHelper()
{
    if (_hSearchHandle) {
        ADsCloseSearchHandle(_hSearchHandle);
    }

    if (_pConnection) {
        _pConnection->Release();
    }

    if (_pContainer) {
        _pContainer->Release();
    }

    if (_pQuery) {
        _pQuery->Release();
    }

    if (_pszADsPath) {
        FreeADsStr(_pszADsPath);
    }

    if (_pszLdapServer) {
        FreeADsStr(_pszLdapServer);
    }

    if (_pszLdapDn) {
        FreeADsStr(_pszLdapDn);
    }

    if (_pCreds) {
        delete _pCreds;
    }

}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::CreateSearchHelper --- STATIC constructor.
//
// Synopsis:   Static constructor.
//
// Arguments:  pUmiQuery     -  Pointer to query object that.
//             pConnection   -  Connection to execute query on.
//             pUnk          -  Container on which the query is executed.
//             pSrchObj      -  New object is returned in this param.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::CreateSearchHelper(
    IUmiQuery *pUmiQuery,
    IUmiConnection *pConnection,
    IUnknown *pUnk,
    LPCWSTR pszADsPath,
    LPCWSTR pszLdapServer,
    LPCWSTR pszLdapDn,
    CCredentials cCredentials,
    DWORD dwPort,
    CUmiSearchHelper FAR* FAR * ppSrchObj
    )
{
    HRESULT hr = S_OK;
    CUmiSearchHelper FAR * pSearchHelper = NULL;
    
    //
    // Asserts are good enough as this is an internal routine.
    //
    ADsAssert(ppSrchObj);
    ADsAssert(pUmiQuery && pConnection && pUnk);

    pSearchHelper = new CUmiSearchHelper();
    if (!pSearchHelper) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pSearchHelper->_pszADsPath = AllocADsStr(pszADsPath);
    if (!pSearchHelper->_pszADsPath) {
        BAIL_ON_FAILURE(hr);
    }

    //
    // pszLdapDn can be null
    //
    if (pszLdapDn) {
        pSearchHelper->_pszLdapDn = AllocADsStr(pszLdapDn);
        if (!pSearchHelper->_pszLdapDn) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }
    
    //
    // the server can also be null.
    //
    if (pszLdapServer) {
        pSearchHelper->_pszLdapServer = AllocADsStr(pszLdapServer);
        if (!pSearchHelper->_pszLdapServer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    pSearchHelper->_pCreds = new CCredentials(cCredentials);
    if (!pSearchHelper->_pCreds) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pSearchHelper->_pConnection = pConnection;
    pConnection->AddRef();

    pSearchHelper->_pQuery = pUmiQuery;
    pUmiQuery->AddRef();

    pSearchHelper->_pContainer = pUnk;
    pUnk->AddRef();

    pSearchHelper->_dwPort = dwPort;

    *ppSrchObj = (CUmiSearchHelper FAR *)pSearchHelper;
    RRETURN(hr);

error :

    delete pSearchHelper;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::SetIID
//
// Synopsis:   Sets the IID requested on the returned objects.
//
// Arguments:  riid    -    The iid requested.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   _pIID the internal IID pointer.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::SetIID(REFIID riid)
{
    if (_pIID) {
        FreeADsMem(_pIID);
    }

    _pIID = (IID *) AllocADsMem(sizeof(IID));

    if (!_pIID) {
        RRETURN(E_OUTOFMEMORY);
    }

    memcpy(_pIID, &riid, sizeof(IID));

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::Reset
//
// Synopsis:   Not implemented.
//
// Arguments:  None.
//
// Returns:    E_NOTIMPL.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::Reset()
{
    //
    // We can potentially add support for this down the road.
    //
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::Next
//
// Synopsis:   Return the next uNumRequested elements from the search.
//
// Arguments:  uNumRequested     -   number of objects/rows to fetch.
//             pNumReturned      -   number of objects/rows returned.
//             pObject           -   array of returned objects.
//
// Returns:    S_OK, S_FALSE or any appropriate error code.
//
// Modifies:   pNumReturned, pObjects and internal search handle state.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::Next(
    ULONG uNumRequested,
    ULONG *puNumReturned,
    LPVOID *ppObjects
    )
{
    HRESULT hr = S_OK;
    IUnknown **pTempUnks = NULL;
    DWORD dwCtr = 0, dwIndex = 0;

    if (!puNumReturned || !ppObjects || (uNumRequested < 1)) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    if (!_fSearchExecuted) {
        hr = InitializeSearchContext();
        BAIL_ON_FAILURE(hr);
    }

    pTempUnks = (IUnknown **) AllocADsMem(sizeof(IUnknown*) * uNumRequested);
    
    if (!pTempUnks) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Get the requested number of objects one at a time until 
    // we hit S_FALSE or an error and then repackage to suitable
    // array as needed.
    //
    while ((dwCtr < uNumRequested) 
           && (hr != S_FALSE) ) {
        IUnknown *pUnk = NULL;
        hr = GetNextObject(&pUnk);
        //
        // This wont catch S_FALSE.
        //
        BAIL_ON_FAILURE(hr);
        
        //
        // Needed as if he get S_FALSE we will set the ptr and
        // increase the count incorrectly.
        //
        if (hr != S_FALSE) {
            pTempUnks[dwCtr] = pUnk;
            dwCtr++;
        }
    }

    //
    // At this point we have all the results we need or can get.
    //
    if (uNumRequested == dwCtr) {
        //
        // We can return tempObjects in this case.
        //
        *ppObjects = (void *)pTempUnks;
    } 
    else {
        //
        // Less than what had been requested.
        //
        IUnknown **pUnkCopy;
        
        pUnkCopy = (IUnknown **) AllocADsMem(sizeof(IUnknown *) * dwCtr);
        if (!pUnkCopy) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (dwIndex = 0; dwIndex < dwCtr; dwIndex++) {
            //
            // Just need to copy the ptrs over.
            //
            pUnkCopy[dwIndex] = pTempUnks[dwIndex];
        }

        //
        // Only return the number of entries we got back.
        //
        *ppObjects = (void *) pUnkCopy;

        FreeADsMem((void *)pTempUnks);
    }

    //
    // We are error free over here.
    //
    *puNumReturned = dwCtr;
    
    RRETURN(hr);

error:

    if (pTempUnks) {
        //
        // For will be executed only if we have valid count.
        //
        for (dwIndex = 0; dwIndex < dwCtr; dwIndex++) {
            pTempUnks[dwIndex]->Release();
        }

        FreeADsMem(pTempUnks);
    }

    *puNumReturned = 0;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::Previous (E_NOTIMPL)
//
// Synopsis:   Return the previous object in the result set - Not implemented.
//
// Arguments:  uFlags            -   only flag supported is 0.
//             pObj              -   object is returned in this param.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   Internal search handle state and pObject.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::Previous(
    ULONG uFlags,
    LPVOID *pObj
    )
{
    RRETURN(E_NOTIMPL);
}

//
// Internal/protected routines
//

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::InitializeSearchContext.
//
// Synopsis:   Prepares the internal state of the object. This initializes
//          the search preferences from the query object, leaveing the search
//          helper ready to retrieve results.
//
// Arguments:  None.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   Internal search preferences and also state search handle.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::InitializeSearchContext()
{
    HRESULT hr = S_OK;
    PUMI_PROPERTY_VALUES pPropVals = NULL;
    IUmiPropList *pPropList = NULL;
    LPWSTR pszFilter = NULL;
    LPWSTR *pszAttrNames = NULL;
    DWORD dwAttrCount = (DWORD) -1;
    ULONG ulLangBufSize = 100 * sizeof(WCHAR);
    ULONG ulQueryBufSize = 1024 * sizeof(WCHAR);
    LPWSTR pszLangBuf = NULL;
    LPWSTR pszQueryText = NULL;
    PADS_SORTKEY pSortKey = NULL;

    //
    // We need to walk through the properties in the query and update
    // our local copy of preferences accordingly.
    //
    if (!_pQuery) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = _pQuery->GetInterfacePropList(0, &pPropList);
    BAIL_ON_FAILURE(hr);

    //
    // Need to allocate memory for the buffers.
    //
    pszLangBuf = (LPWSTR) AllocADsMem(ulLangBufSize);
    pszQueryText = (LPWSTR) AllocADsMem(ulQueryBufSize);
    if (!pszLangBuf || !pszQueryText) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    //
    // We need to look at the query language if the language is SQL,
    // then we need to go through and convert the SQL settings to
    // properties on the intfPropList of the query.
    //
    hr = _pQuery->GetQuery(
             &ulLangBufSize,
             pszLangBuf,
             &ulQueryBufSize, // Change this before checking in.
             pszQueryText
             );
    if (hr == E_OUTOFMEMORY ) {
        //
        // Means there was insufficient length in the buffers.
        //
        if (ulLangBufSize > (100 * sizeof(WCHAR))) {
            FreeADsStr(pszLangBuf);
            pszLangBuf = (LPWSTR) AllocADsMem(ulLangBufSize + sizeof(WCHAR));
            if (!pszLangBuf) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        if (ulQueryBufSize > (1024 * sizeof(WCHAR))) {
            FreeADsStr(pszQueryText);
            pszQueryText = (LPWSTR) AllocADsMem(
                ulQueryBufSize + sizeof(WCHAR)
                );
            if (pszQueryText) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        hr = _pQuery->GetQuery(
                 &ulLangBufSize,
                 pszLangBuf,
                 &ulQueryBufSize, // Change this before checking in.
                 pszQueryText
                 );
    }
    BAIL_ON_FAILURE(hr);

    if (*pszLangBuf) {
        if (!_wcsicmp(L"SQL", pszLangBuf)
            || !_wcsicmp(L"WQL", pszLangBuf)
             ) {
            //  
            // This is a sql query and we need to process the query before
            // pulling the options out of the query object.
            //
            hr = ProcessSQLQuery(
                     pszQueryText,
                     &pszFilter,
                     &pSortKey
                     );
            BAIL_ON_FAILURE(hr);

        } 
        else if (!_wcsicmp(L"LDAP", pszLangBuf)) {
            //
            // Neither SQL nor LDAP but the language is set which means
            // we cannot handle this query.
            //
            pszFilter = AllocADsStr(pszQueryText);
            if (!pszFilter) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }
    }

    //
    // At this point we need to go through and pick up all the properties.
    // we know about and update our search preferences accordingly. Each of 
    // these properties has to be set and has to have some valid data.
    //

    //
    // Start with the search scope.
    //
    hr = pPropList->Get(L"__SEARCH_SCOPE", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwSearchScope = 
        pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the synchronous/asynchronous pref.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_ASYNCHRONOUS", 0,  &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._fAsynchronous = 
        pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the deref aliases search pref.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_DEREF_ALIASES", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._dwDerefAliases = 
        pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the size limit.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_SIZE_LIMIT", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwSizeLimit = pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the time limit.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_TIME_LIMIT", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwTimeLimit = pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the attributes only preference.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_ATTRIBTYPES_ONLY", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._fAttrsOnly = pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the search scope again ???
    //
    // __PADS_SEARCHPREF_SEARCH_SCOPE (duplicate for consistency cause it should be for all ideally).
    //

    hr = pPropList->Get(L"__PADS_SEARCHPREF_TIMEOUT", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwTimeLimit = pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // The page size is next.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_PAGESIZE", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwPageSize = pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Get the paged time limit.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_PAGED_TIME_LIMIT", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwPagedTimeLimit = 
        pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Chase referrals comes next.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_CHASE_REFERRALS", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidLongProperty(pPropVals));

    _searchPrefs._dwChaseReferrals = 
        pPropVals->pPropArray[0].pUmiValue->uValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;
    
    //
    // Get the sort preferences ---> more complex do later.
    //
    // __PADS_SEARCHPREF_SORT_ON ---> potential candidate for all providers.
    //

    //
    // Cache results.
    //
    pPropList->Get(L"__PADS_SEARCHPREF_CACHE_RESULTS", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._fCacheResults = 
        pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // DirSync control --- do later.
    // __PADS_SEARCHPREF_DIRSYNC
    //

    //
    // Tombstone preferences.
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_TOMBSTONE", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE(hr = VerifyValidBoolProperty(pPropVals));

    _searchPrefs._fTombStone = pPropVals->pPropArray[0].pUmiValue->bValue[0];

    pPropList->FreeMemory(0, (void *) pPropVals);
    pPropVals = NULL;

    //
    // Need to get the list of attributes.
    //
    //
    hr = pPropList->Get(L"__PADS_SEARCHPREF_ATTRIBUTES", 0, &pPropVals);
    BAIL_ON_FAILURE(hr);

    //
    // Need to change to check for NULL then set count to -1.
    //
    pszAttrNames = pPropVals->pPropArray[0].pUmiValue->pszStrValue;
    dwAttrCount = pPropVals->pPropArray[0].uCount;

    //
    // Special case to ask for NULL with 0 to get all attributes.
    //
    if (!dwAttrCount && !pszAttrNames) {
        dwAttrCount = (DWORD) -1;
    }
    //
    // Now that we have all the preferences, we can set the search prefs
    // and also execute the search.
    //
    hr = ADsExecuteSearch(
             _searchPrefs,
             _pszADsPath,
             _pszLdapServer,
             _pszLdapDn,
             pszFilter,
             pszAttrNames,
             dwAttrCount,
             & _hSearchHandle
             );
    BAIL_ON_FAILURE(hr);

    _fSearchExecuted = TRUE;

error:

    if (pPropVals) {
        //
        // Guess we need to use the query to free this !
        //
        _pQuery->FreeMemory(0, (void *)pPropVals);
    }
    
    if (pPropList) {
        pPropList->Release();
    }

    if (pszLangBuf) {
        FreeADsStr(pszLangBuf);
    }

    if (pszQueryText) {
        FreeADsStr(pszQueryText);
    }

    if (pSortKey) {
        if (pSortKey->pszAttrType) {
            FreeADsStr(pSortKey->pszAttrType);
        }
        if (pSortKey->pszReserved) {
            FreeADsStr(pSortKey->pszReserved);
        }

        FreeADsMem(pSortKey);
    }

    if (FAILED(hr)) {
        //
        // Should we really be doing this ?
        //
        LdapInitializeSearchPreferences(&_searchPrefs, FALSE);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::GetNextObject.
//
// Synopsis:   This routine gets the next object in the result set. It calls
//          get next row to get the next row and creates the equivalent
//          cgenobj (need to add code to prepopulate the attributes).
//
// Arguments:  None.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   Internal search preferences and also state search handle.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::GetNextObject(IUnknown **pUnk)
{
    HRESULT hr = S_OK;
    ADS_SEARCH_COLUMN adsColumn;
    BSTR ADsPath = NULL;
    LPWSTR pszParent = NULL;
    LPWSTR pszCN = NULL;
    PADSLDP ldapHandle = NULL;
    LDAPMessage *pldapMsg = NULL;

    //
    // Zero init the struct to make sure we can free in error path.
    //
    memset(&adsColumn, 0, sizeof(ADS_SEARCH_COLUMN));


    ADsAssert(_fSearchExecuted);

    if (!_hSearchHandle) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Get the next row.
    //
    hr = ADsGetNextRow(
             _hSearchHandle,
             *_pCreds
             );
    if (hr == S_ADS_NOMORE_ROWS) {
        //
        // Hit end of enumeration.
        //
        *pUnk = NULL;
        RRETURN(S_FALSE);
    } 
    else if (FAILED(hr)) {
        BAIL_ON_FAILURE(hr);
    }

    //
    // Fetch the path and use it to create the object.
    //
    hr = ADsGetColumn(
             _hSearchHandle,
             L"ADsPath",
             *_pCreds,
             _dwPort,
             &adsColumn
             );
    BAIL_ON_FAILURE(hr);

    if (adsColumn.dwADsType != ADSTYPE_CASE_IGNORE_STRING
        || adsColumn.dwNumValues != 1) {
        //
        // Bad type or number of return values, this should never happen.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Get the whole ldap message for the current row, that way we can
    // prepopulate the object. Since we are picking up the actual message,
    // we cannot rely on GetNextColumnName to work properly.
    //
    hr = ADsHelperGetCurrentRowMessage(
             _hSearchHandle,
             &ldapHandle, // need this when getting the actual attributes.
             &pldapMsg
             );
    BAIL_ON_FAILURE(hr);

    //
    //
    // For creating the object, the parent path and the rdn is needed.
    //
    hr = BuildADsParentPath(
             adsColumn.pADsValues[0].CaseIgnoreString,
             &pszParent,
             &pszCN
             );
    BAIL_ON_FAILURE(hr);

    //
    // Maybe we should just get all the values for this row and
    // send into a constructor for the cgenobj ???
    //
    hr = CLDAPGenObject::CreateGenericObject(
             pszParent,
             pszCN,
             *_pCreds,
             ADS_OBJECT_BOUND,
             ldapHandle,
             pldapMsg,
             _pIID ? (*_pIID) : IID_IUmiObject,
             (void **) pUnk
             );

    BAIL_ON_FAILURE(hr);

error:

    if (pszParent) {
        FreeADsStr(pszParent);
    }

    if (pszCN) {
        FreeADsStr(pszCN);
    }

    //
    // Calling this can not harm us.
    //
    ADsFreeColumn(&adsColumn);

    if (FAILED(hr) && *pUnk) {
        (*pUnk)->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CUmiSearchHelper::ProcessSQLQuery (helper function).
//
// Synopsis:   This routine takes the SQL Query text, parses it using the 
//          wmi query parser and converts the query to preferences on
//          the underlying queryObjects interface proplist.
//
// Arguments:  pszQueryText   -   SQL language query.
//
// Returns:    S_OK, or any appropriate error code.
//
// Modifies:   Search preferences on the underlying query object.
//
//----------------------------------------------------------------------------
HRESULT
CUmiSearchHelper::ProcessSQLQuery(
    LPCWSTR pszQueryText,
    LPWSTR * ppszFilter,
    PADS_SORTKEY *ppADsSortKey
    )
{
    HRESULT hr = S_OK;
    IWbemQuery *pQuery = NULL;
    ULONG ulFeatures[] = {
        WMIQ_LF1_BASIC_SELECT,
        WMIQ_LF2_CLASS_NAME_IN_QUERY,
        WMIQ_LF6_ORDER_BY,
        WMIQ_LF24_UMI_EXTENSIONS
    };
    SWbemRpnEncodedQuery *pRpn = NULL;
    LPWSTR *pszAttribArray = NULL;
    DWORD dwAttribCount = 0;
    LPWSTR pszFromListFilter = NULL;
    LPWSTR pszFilter = NULL;
    IUmiPropList *pIntfPropList = NULL;
    UMI_PROPERTY umiPropAttribs = {
        UMI_TYPE_LPWSTR,
        1,
        UMI_OPERATION_UPDATE,
        L"__PADS_SEARCHPREF_ATTRIBUTES",
        NULL
    };
    //
    // Will likely need to set the attribute list.
    //
    UMI_PROPERTY pOneUmiProp[1];
     
    pOneUmiProp[0] = umiPropAttribs;

    UMI_PROPERTY_VALUES propUmiVals[1];
    propUmiVals[0].uCount = 1;
    propUmiVals[0].pPropArray = pOneUmiProp;

    ADsAssert(ppszFilter);
    *ppszFilter = NULL;

    //
    // Create the WBEM parser object.
    //
    hr = CoCreateInstance(
             CLSID_WbemQuery,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IWbemQuery,
             (LPVOID *) &pQuery
             );
    BAIL_ON_FAILURE(hr);

    //
    // Set the query into the parser and try and parse the query.
    //
    hr = pQuery->SetLanguageFeatures(
             0,
             sizeof(ulFeatures)/sizeof(ULONG),
             ulFeatures
             );
    BAIL_ON_FAILURE(hr);

    hr = pQuery->Parse(L"SQL", pszQueryText, 0);
    BAIL_ON_FAILURE(hr);

    hr = pQuery->GetAnalysis(
             WMIQ_ANALYSIS_RPN_SEQUENCE,
             0,
             (LPVOID *) &pRpn
             );
    BAIL_ON_FAILURE(hr);

    if (!pRpn->m_uSelectListSize) {
        //
        // Sanity check to make sure we are selecting something.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = HelperGetAttributeList(
             &dwAttribCount,
             &pszAttribArray,
             pRpn->m_uSelectListSize,
             pRpn->m_ppSelectList
             );
    BAIL_ON_FAILURE(hr);
    
    //
    // As of now the from list cannot have anything in other than *.
    //
    hr = HelperGetFromList(
             &pszFromListFilter,
             pRpn
             );
    BAIL_ON_FAILURE(hr);

    hr = HelperGetFilterFromWhereClause(
             &pszFilter,
             pRpn->m_uWhereClauseSize,
             pRpn->m_ppRpnWhereClause
             );
    BAIL_ON_FAILURE(hr);

    //
    // See if we have an order by list, in SQL we support only one
    // order by clause.
    //
    if (pRpn->m_uOrderByListSize) {
        hr = HelperGetSortKey(pRpn, ppADsSortKey);
        BAIL_ON_FAILURE(hr);
    }
    //
    // Need to set the attribute list if applicable.
    //
    if ((dwAttribCount != (DWORD) -1)
        && dwAttribCount) {
        //
        // Need to set the property on the interface proplist.
        //
        hr = _pQuery->GetInterfacePropList(
                 0,
                 &pIntfPropList
                 );
        BAIL_ON_FAILURE(hr);

        pOneUmiProp[0].uCount = dwAttribCount;
        pOneUmiProp[0].pUmiValue = (PUMI_VALUE) (LPVOID) pszAttribArray;

        hr = pIntfPropList->Put(
                 L"__PADS_SEARCHPREF_ATTRIBUTES",
                 0,
                 propUmiVals
                 );
        BAIL_ON_FAILURE(hr);

    }
    //
    // Need to return the filter back.
    //
    *ppszFilter = pszFilter;

error:

    if (pQuery) {
        pQuery->Release();
    }

    if (pszFromListFilter) {
        FreeADsStr(pszFromListFilter);
    }
    
    if (pIntfPropList) {
        pIntfPropList->Release();
    }

    //
    // We might need to return this as a param.
    //
    if (FAILED(hr) && pszFilter) {
        FreeADsStr(pszFilter);
    }

    RRETURN(hr);
}

//****************************************************************************
//                      CQueryStack Implementation                           *
//****************************************************************************

//+---------------------------------------------------------------------------
// Function:   CQueryStack::CQueryStack - Constructor.
//
// Synopsis:   Initializes the underlying list to NULL and count to 0.
//
// Arguments:  None.
//
// Returns:    N/A.
//
// Modifies:   All member variables.
//
//----------------------------------------------------------------------------
CQueryStack::CQueryStack():
    _pStackList(NULL),
    _dwElementCount(0)
{
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::~CQueryStack - Destructor.
//
// Synopsis:   Frees the underlying list contents if applicable.
//
// Arguments:  None.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CQueryStack::~CQueryStack()
{
    if (_pStackList) {
        STACKLIST *pList = _pStackList;
        STACKLIST *pPrev = NULL;
        //
        // Walk through and free the list.
        //
        while (pList) {
            pPrev = pList;
            pList = pList->pNext;
            //
            // Need to free prev node and its contents.
            //
            CQueryStack::FreeStackEntry(pPrev);
        }
        _pStackList = NULL;
    }
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::Push.
//
// Synopsis:   Pushes the node onto the stack and increases the count. The
//          node is added to the head of the underlying list. 
//
// Arguments:  pszString    -   The string value of the node.
//             dwType       -   The type of the node can either be 
//                           a literal or an operator.
//
// Returns:    S_OK or E_OUTOFMEMORY.
//
// Modifies:   The underlying list.
//
//----------------------------------------------------------------------------
HRESULT
CQueryStack::Push(
    LPWSTR pszString,
    DWORD  dwType
    )
{
    HRESULT hr = S_OK;
    PSTACKLIST pStackEntry = NULL;

    //
    // Allocate the new node.
    //
    hr = CQueryStack::AllocateStackEntry(
             pszString,
             dwType,
             &pStackEntry
             );
    if (FAILED(hr)) {
        BAIL_ON_FAILURE(hr);
    }

    //
    // If the list is not already then it is added to the head.
    //
    if (!this->_pStackList) {
        _pStackList = pStackEntry;
    } 
    else {
        //
        // Add new entry to the head of the list.
        //
        pStackEntry->pNext = _pStackList;
        _pStackList = pStackEntry;
    }

    //
    // Increment count as the add to list was successful.
    //
    _dwElementCount++;

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::Pop.
//
// Synopsis:   Removes node node from the stack and returns the contents. 
//          Node is removed from the head of the underlying list. 
//
// Arguments:  ppszString   -   Return ptr for string value of node.
//             dwType       -   Return ptr for the type of the node.
//
// Returns:    S_OK, E_OUTOFMEMORY or E_FAIL.
//
// Modifies:   The underlying list.
//
//----------------------------------------------------------------------------
HRESULT
CQueryStack::Pop(
    LPWSTR *ppszString,
    DWORD  *pdwType
    )
{
    HRESULT hr = S_OK;
    PSTACKLIST pStackEntry = _pStackList;

    if (!pStackEntry
        || !ppszString
        || !pdwType ) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Initialize the return values.
    //
    *ppszString = NULL;
    *pdwType = (DWORD) -1;

    if (pStackEntry->pszElement) {
        *ppszString = AllocADsStr(pStackEntry->pszElement);
        if (!*ppszString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        *pdwType = pStackEntry->dwElementType;
    } 
    else {
        //
        // Should never get here.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Need to advance the list to the next node and free the
    // contents of the current node.
    //
    _pStackList = _pStackList->pNext;
    CQueryStack::FreeStackEntry(pStackEntry);

    //
    // Decrement count as the remove from list was successful.
    //
    _dwElementCount--;

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::IsEmpty.
//
// Synopsis:   Returns TRUE or FALSE based on the contents of the stack.
//
// Arguments:  N/A.
//
// Returns:    TRUE or FALSE.
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
BOOL
CQueryStack::IsEmpty()
{
    return (_dwElementCount == 0);
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::AllocateStackEntry - static helper routine.
//
// Synopsis:   Allocates a stack node with the specified contents.
//
// Arguments:  pszString    -   The string value of the node.
//             dwType       -   The type of the node can either be 
//                           a literal or an operator.
//             ppStackEntry -   Return value.
//
// Returns:    S_OK, E_OUTOFMEMORY or E_FAIL.
//
// Modifies:   ppStackEntry.
//
//----------------------------------------------------------------------------
HRESULT
CQueryStack::AllocateStackEntry(
    LPWSTR pszString,
    DWORD  dwType,
    STACKLIST **ppStackEntry
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszTmpString = NULL;

    if (!pszString || !dwType) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    *ppStackEntry = NULL;

    pszTmpString = AllocADsStr(pszString);
    if (!pszString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Allocate the new stack node.
    //
    *ppStackEntry = (PSTACKLIST) AllocADsMem(sizeof(STACKLIST));
    if (!*ppStackEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*ppStackEntry)->pszElement = pszTmpString;
    (*ppStackEntry)->dwElementType = dwType;
    
error:

   if (FAILED(hr) && pszTmpString) {
       FreeADsStr(pszTmpString);
   }

   RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CQueryStack::FreeStackEntry - static helper routine.
//
// Synopsis:   Frees contents of the stack node and the node itself.
//
// Arguments:  pStackEntry    -   Pointer to stack node to free.
//
// Returns:    N/A.
//
// Modifies:   pStackEntry and contents.
//
//----------------------------------------------------------------------------
void
CQueryStack::FreeStackEntry(
    PSTACKLIST pStackEntry
    )
{
    if (!pStackEntry) {
        return;
    }

    //
    // Free the string if there is one and then the node.
    //
    if (pStackEntry->pszElement) {
        FreeADsStr(pStackEntry->pszElement);
    }
    FreeADsMem(pStackEntry);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  getobj.cxx
//
//  Contents:  LDAP GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

DWORD
GetDefaultLdapServer(
    LPWSTR Addresses[],
    LPDWORD Count,
    BOOL Verify,
    DWORD dwPort
    ) ;

DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

LPWSTR gpszStickyServerName = NULL;
LPWSTR gpszStickyDomainName = NULL;
//
// Dont do DsGetDCName with FORCE_DISCOVERY too frequently.
// LastVerifyDefaultServer is uses to track tick count.
//
#define  DC_NORETRY (1000 * 60 * 5)

DWORD LastVerifyDefaultServer = 0 ;

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPTSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetServerBasedObject(
    LPWSTR szBuffer,
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;

    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszLDAPDn = NULL;
    TCHAR *pszParent = NULL;
    TCHAR *pszCommonName = NULL;

    TCHAR szNamespace[MAX_PATH];

    IADs *pADs = NULL;

    LPTSTR *aValues = NULL;
    LPTSTR *aValuesNamingContext = NULL;
    int nCount = 0;

    TCHAR *pszNewADsPath = NULL;
    LPWSTR pszNewADsParent = NULL;
    LPWSTR pszNewADsCommonName = NULL;

    LPWSTR pszNamingContext = NULL;

    TCHAR *pszLast = NULL;
    BOOL fVerify = FALSE ;

    DWORD dwPort = 0;
    ADS_LDP *ld = NULL;
    BOOL fGCDefaulted = FALSE;
    BOOL fNoDefaultNamingContext = FALSE;
    BOOL fFastBind = Credentials.GetAuthFlags() & ADS_FAST_BIND;

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is LDAP:
    //

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateObjectType(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    // Get the namespace name

    wcscpy(szNamespace, pObjectInfo->NamespaceName);
    wcscat(szNamespace, L":");

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_ROOTDSE:
        //
        // This means that this is a RootDSE object;
        // instantiate the RootDSE object
        //

        hr = GetRootDSEObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;


    case TOKEN_SCHEMA:
    case TOKEN_CLASS:
    case TOKEN_PROPERTY:
    case TOKEN_SYNTAX:

        hr = GetSchemaObject(
                pObjectInfo,
                Credentials,
                pObjectInfo->PortNumber,
                ppObject
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:

        hr = BuildLDAPPathFromADsPath2(
                    szBuffer,
                    &pszLDAPServer,
                    &pszLDAPDn,
                    &dwPort
                    );

        hr = LdapOpenObject2(
                        pszLDAPServer,
                        NULL,
                        NULL,
                        &ld,
                        Credentials,
                        dwPort
                        );
        BAIL_ON_FAILURE(hr);

        if ( pszLDAPDn  == NULL ) {

            // If only server name is specified, we need to
            // find the root of the naming context...

            if (dwPort == USE_DEFAULT_GC_PORT) {
                pszNamingContext = NULL;
                fGCDefaulted = TRUE;
            } else {
                pszNamingContext = TEXT(LDAP_OPATT_DEFAULT_NAMING_CONTEXT);
            }

            // We already have an open connection so we can do
            // fast read to avoid looking up the bind cache.
            if (!fGCDefaulted ) {

                hr = LdapReadAttributeFast(
                         ld,
                         NULL, // the DN is that of the RootDSE
                         pszNamingContext,
                         &aValuesNamingContext,
                         &nCount
                         );

                if (SUCCEEDED(hr) && (nCount < 1)) {
                    hr = HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
                }
            }

            //
            // If we fail reading the naming context then we need to continue
            // if the error was no attribute or value, set some flags
            //
            if (FAILED(hr)) {

              if ( hr != HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) ) {

                  nCount = 1;
                  pszNamingContext = NULL;
                  hr = S_OK;
                  fNoDefaultNamingContext = TRUE;
                  fGCDefaulted = TRUE;
              }
            }
        
            BAIL_ON_FAILURE(hr);

            //
            // At this point we have either
            // 1) Valid defaultNamingContext and pszNamingContext
            // 2) Either a GC or a case where defaultNamingContext
            //   is not available - essentially just a null dn
            //

            hr = BuildADsPathFromLDAPPath2(
                     TRUE,               //Server is Present
                     szNamespace,
                     pszLDAPServer,
                     dwPort,
                     pszNamingContext ?
                        aValuesNamingContext[0] :
                        TEXT(""),
                     &pszNewADsPath
                     );
            BAIL_ON_FAILURE(hr);

            hr = BuildADsParentPath(
                      pszNewADsPath,
                      &pszNewADsParent,
                      &pszNewADsCommonName
                      );
            BAIL_ON_FAILURE(hr);


            if (pszLDAPServer) {
                FreeADsStr(pszLDAPServer);
                pszLDAPServer = NULL;
            }

            if (pszLDAPDn) {
                FreeADsStr(pszLDAPDn);
                pszLDAPDn = NULL;
            }

        //
        // Put the info from the new path build above into the
        // various components - matters if we are dealing with
        // a valid defaultNanmingContext
        //
        hr = BuildLDAPPathFromADsPath2(
             pszNewADsPath,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );

        }
        nCount = 0;

        // At this point we have a valid DN
        // so we can go ahead and do the a fast read rather than
        // just a plain read to avoid the overhead of looking upt
        // the bindcache.

        if (!fGCDefaulted && !fFastBind) {

            hr = LdapReadAttributeFast(
                     ld,
                     pszLDAPDn,
                     TEXT("objectClass"),
                     &aValues,
                     &nCount
                     );

            BAIL_ON_FAILURE(hr);

            if (nCount == 0) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
            }
        }

        if (fGCDefaulted) {

            //
            // This is either  GC://server, where we want to
        // set the object DN to null so that all
        // searches will yield correct results.
        // or the case of a server that did not have
        // a default naming context in the RootDSE
        //
        hr = CLDAPGenObject::CreateGenericObject(
                                     pszNewADsParent,
                                     pszNewADsCommonName,
                                     L"top",
                                     Credentials,
                                     ADS_OBJECT_BOUND,
                                     IID_IADs,
                                     (void **) &pADs
                                     );
        }
        else if (aValuesNamingContext ) {

            //
            // Need to create the object with new parent
            // and newADsCN
            //
            if (fFastBind) {
                hr = CLDAPGenObject::CreateGenericObject(
                            pszNewADsParent,
                            pszNewADsCommonName,
                            L"top",
                            Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IADs,
                            (void **) &pADs,
                            fFastBind
                            );

            } else {

                hr = CLDAPGenObject::CreateGenericObject(
                            pszNewADsParent,
                            pszNewADsCommonName,
                            aValues,
                            nCount,
                            Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IADs,
                            (void **) &pADs,
                            fFastBind
                            );
                }

        } else {
            //
            // This is the default case where we build the info from
            // the data passed into GetObject call
            //
            hr = BuildADsParentPathFromObjectInfo2(
                        pObjectInfo,
                        &pszParent,
                        &pszCommonName
                        );
            BAIL_ON_FAILURE(hr);

            if (fFastBind) {

                hr = CLDAPGenObject::CreateGenericObject(
                            pszParent,
                            pszCommonName,
                            L"top",
                            Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IADs,
                            (void **) &pADs,
                            fFastBind
                            );

            } else {

                hr = CLDAPGenObject::CreateGenericObject(
                            pszParent,
                            pszCommonName,
                            aValues,
                            nCount,
                            Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IADs,
                            (void **) &pADs,
                            fFastBind
                            );
            }
        }

        BAIL_ON_FAILURE(hr);

        //
        // InstantiateDerivedObject should add-ref this pointer for us.
        //

        hr = pADs->QueryInterface(
                        IID_IUnknown,
                        ppObject
                        );

        BAIL_ON_FAILURE(hr);
        break;

    }

error:

    if ( ld ){
        LdapCloseObject( ld );
    }

    if (pADs)
        pADs->Release();

    if ( aValuesNamingContext )
        LdapValueFree( aValuesNamingContext );

    if ( aValues )
        LdapValueFree( aValues );

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

     if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
     }

    if ( pszNewADsPath )
        FreeADsStr( pszNewADsPath );

    if (pszNewADsParent) {
       FreeADsStr(pszNewADsParent);
    }

    if (pszNewADsCommonName) {
       FreeADsStr(pszNewADsCommonName);
    }

    if ( pszParent )
        FreeADsStr( pszParent );

    if ( pszCommonName )
        FreeADsStr( pszCommonName );

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    GetNamespaceObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    WCHAR szNamespace[MAX_PATH];


    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    wsprintf(szNamespace,L"%s:", pObjectInfo->NamespaceName);

    hr = CLDAPNamespace::CreateNamespace(
                TEXT("ADs:"),
                szNamespace,
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                ppObject
                );


error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:    GetRootDSEObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetRootDSEObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    LPWSTR pszParent = NULL;
    LPWSTR pszCommonName = NULL;

    hr = ValidateRootDSEObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPathFromObjectInfo2(
                pObjectInfo,
                &pszParent,
                &pszCommonName
                );
    BAIL_ON_FAILURE(hr);

    hr = CLDAPRootDSE::CreateRootDSE(
                pszParent,
                pszCommonName,
                L"",
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                (void **)ppObject
                );
error:

    if (pszParent) {
      FreeADsStr(pszParent);
    }

    if (pszCommonName) {
       FreeADsStr(pszCommonName);
    }


    RRETURN(hr);
}


HRESULT
ValidateRootDSEObject(
    POBJECTINFO pObjectInfo
    )
{
    if ( pObjectInfo->NumComponents > 1 )
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    RRETURN(S_OK);
}


HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (_tcsicmp(pObjectInfo->NamespaceName, szLDAPNamespaceName) == 0 ||
        _tcsicmp(pObjectInfo->NamespaceName, szGCNamespaceName) == 0) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (_tcscmp(pObjectInfo->ProviderName, szProviderName) == 0) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}



//+---------------------------------------------------------------------------
// Function:    GetSchemaObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    CCredentials&  Credentials,
    DWORD dwPort,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    TCHAR szDomainName[MAX_PATH];
    TCHAR szServerName[MAX_PATH];
    TCHAR *pszParent = NULL;
    TCHAR *pszCommonName = NULL;
    DWORD dwObjectType = 0;
    DWORD i,dwStatus;

    LDAP_SCHEMA_HANDLE hSchema = NULL;
    BOOL fFound = FALSE;

    hr = ValidateSchemaObject(
                pObjectInfo,
                &dwObjectType
                );
    BAIL_ON_FAILURE(hr);

   if (pObjectInfo->TreeName) {
      _tcscpy(szDomainName, pObjectInfo->TreeName);

   }else {

      LPTSTR aAddresses[5];
      DWORD nCount = 5;
      BOOL fVerify = FALSE;

      dwStatus = GetDefaultServer(
                     dwPort,
                     fVerify,
                     szDomainName,
                     szServerName,
                     TRUE
                     );

      if (dwStatus) {
          hr = HRESULT_FROM_WIN32(dwStatus);
          BAIL_ON_FAILURE(hr);
      }
   }

    hr = SchemaOpen(
             szDomainName,
             &hSchema,
             Credentials,
             dwPort
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPathFromObjectInfo2(
             pObjectInfo,
             &pszParent,
             &pszCommonName
             );
    BAIL_ON_FAILURE(hr);

    switch (dwObjectType) {

    case LDAP_SCHEMA_ID:
        hr = CLDAPSchema::CreateSchema(
                    pszParent,
                    pszCommonName,
                    szDomainName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        BAIL_ON_FAILURE(hr);
        break;

    case LDAP_CLASS_ID:
    {
        CLASSINFO *pClassInfo = NULL;

        if ( pObjectInfo->NumComponents < 2 )
        {
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Look for the given class name
        //

        if (pObjectInfo->dwPathType == PATHTYPE_WINDOWS) {
                hr = SchemaGetClassInfo(
                     hSchema,
                     pObjectInfo->ComponentArray[1].szComponent,
                    &pClassInfo );
        }else {
              hr = SchemaGetClassInfo(
                        hSchema,
                        pObjectInfo->ComponentArray[0].szComponent,
                        &pClassInfo);
        }

        if ( SUCCEEDED(hr))
        {
            if ( pClassInfo == NULL )  // could not find the class name
            {
                // Do not bail on failure here since we might need to fall
                // through to the property case.

                hr = E_ADS_BAD_PATHNAME;
            }
        }

        if ( SUCCEEDED(hr))
        {
            //
            // Class name found, create and return the object
            //
            hr = CLDAPClass::CreateClass( pszParent,
                                          hSchema,
                                          pClassInfo->pszName,
                                          pClassInfo,
                                          Credentials,
                                          ADS_OBJECT_BOUND,
                                          IID_IUnknown,
                                          ppObject );
        }

        if ( SUCCEEDED(hr)
           || ( pObjectInfo->ObjectType == TOKEN_CLASS )
           )
        {
            BAIL_ON_FAILURE(hr);
            break;
        }
        hr = S_OK;
        // Else the exact type was not specified and we guessed it to be class
        // but since CreateClass failed, we need to try and see if it is a
        // property object. Hence, falls through
    }

    case LDAP_PROPERTY_ID:
    {
        PROPERTYINFO *pPropertyInfo = NULL;

        if ( pObjectInfo->NumComponents < 2)
        {
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Look for the given property name
        //


        if (pObjectInfo->dwPathType == PATHTYPE_WINDOWS) {
            hr = SchemaGetPropertyInfo(
                     hSchema,
                    pObjectInfo->ComponentArray[1].szComponent,
                    &pPropertyInfo );
        }else{
            hr = SchemaGetPropertyInfo(
                        hSchema,
                        pObjectInfo->ComponentArray[0].szComponent,
                        &pPropertyInfo
                        );

        }

        if ( SUCCEEDED(hr))
        {
            if ( pPropertyInfo == NULL ) // could not find the property name
            {
                // Do not bail on failure here since we might need to fall
                // through to the syntax case.

                hr = E_ADS_BAD_PATHNAME;
            }
        }

        if ( SUCCEEDED(hr))
        {
            //
            // Property name found, so create and return the object
            //
            hr = CLDAPProperty::CreateProperty(
                                     pszParent,
                                     hSchema,
                                     pPropertyInfo->pszPropertyName,
                                     pPropertyInfo,
                                     Credentials,
                                     ADS_OBJECT_BOUND,
                                     IID_IUnknown,
                                     ppObject );
        }

        if ( SUCCEEDED(hr)
           || ( pObjectInfo->ObjectType == TOKEN_PROPERTY )
           )
        {
            BAIL_ON_FAILURE(hr);
            break;
        }
        hr = S_OK;
        // Else the exact type was not specified and we guessed it to be
        // property but since CreateProperty failed, we need to try and see if
        // it is a syntax object. Hence, falls through
    }

    case LDAP_SYNTAX_ID:
        if ( pObjectInfo->NumComponents < 2 )
        {
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Look for the given syntax name
        //

        for ( i = 0; i < g_cLDAPSyntax; i++ )
        {
            if ( _tcsicmp( g_aLDAPSyntax[i].pszName,
                       (pObjectInfo->dwPathType == PATHTYPE_WINDOWS)?
                       pObjectInfo->ComponentArray[1].szComponent:
                       pObjectInfo->ComponentArray[0].szComponent ) == 0 )
                break;
        }

        if ( i == g_cLDAPSyntax )
        {
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Syntax name found, create and return the object
        //

        hr = CLDAPSyntax::CreateSyntax(
                  pszParent,
                  &(g_aLDAPSyntax[i]),
                  Credentials,
                  ADS_OBJECT_BOUND,
                  IID_IUnknown,
                  ppObject
                  );
        BAIL_ON_FAILURE(hr);
        break;

    default:
        hr = E_ADS_UNKNOWN_OBJECT;
        break;

    }

error:

    if ( pszParent )
        FreeADsStr( pszParent );

    if ( pszCommonName )
        FreeADsStr( pszCommonName );

    if ( hSchema )
        SchemaClose( &hSchema );

    RRETURN(hr);
}

HRESULT
ValidateSchemaObject(
    POBJECTINFO pObjectInfo,
    PDWORD pdwObjectType
    )
{
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;

    switch ( pObjectInfo->ObjectType )
    {

    case TOKEN_CLASS:
        *pdwObjectType = LDAP_CLASS_ID;
        break;

    case TOKEN_SYNTAX:
        *pdwObjectType = LDAP_SYNTAX_ID;
        break;

    case TOKEN_PROPERTY:
        *pdwObjectType = LDAP_PROPERTY_ID;
        break;

    case TOKEN_SCHEMA:
        dwNumComponents = pObjectInfo->NumComponents;

        switch (dwNumComponents) {

        case 1:
            if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,
                          SCHEMA_NAME))
                *pdwObjectType = LDAP_SCHEMA_ID;
            break;

        case 2:

            if (pObjectInfo->dwPathType == PATHTYPE_WINDOWS) {
                if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,
                              SCHEMA_NAME))
                    *pdwObjectType = LDAP_CLASS_ID;

                    // Might also be a property or syntax object
                    // see function GetSchemaObject()
                }else {
                    if (!_tcsicmp(pObjectInfo->ComponentArray[dwNumComponents - 1].szComponent,
                                  SCHEMA_NAME))
                        *pdwObjectType = LDAP_CLASS_ID;

                        // Might also be a property or syntax object
                        // see function GetSchemaObject()
                }

            break;

        default:
            hr = E_FAIL;
            break;
        }
        break;


    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
ValidateObjectType(
    POBJECTINFO pObjectInfo
    )
{

    if ( pObjectInfo->ObjectType != TOKEN_LDAPOBJECT )
    {
        // The type has already been specified in this case using COMMA
        RRETURN(S_OK);
    }

    if (  pObjectInfo->NamespaceName
       && !pObjectInfo->TreeName
       && !pObjectInfo->NumComponents
       )
    {
        pObjectInfo->ObjectType = TOKEN_NAMESPACE;
    }
    else if (  pObjectInfo->NamespaceName
            && pObjectInfo->TreeName
            && pObjectInfo->NumComponents)
    {

        switch (pObjectInfo->dwPathType) {
        case PATHTYPE_WINDOWS:
            if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,SCHEMA_NAME))
                pObjectInfo->ObjectType = TOKEN_SCHEMA;
             else if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,ROOTDSE_NAME))
                     pObjectInfo->ObjectType = TOKEN_ROOTDSE;
            break;


        case PATHTYPE_X500:
        default:
            if (!_tcsicmp(pObjectInfo->ComponentArray[pObjectInfo->NumComponents - 1].szComponent,SCHEMA_NAME))
                pObjectInfo->ObjectType = TOKEN_SCHEMA;
             else if (!_tcsicmp(pObjectInfo->ComponentArray[pObjectInfo->NumComponents - 1].szComponent,ROOTDSE_NAME))
                      pObjectInfo->ObjectType = TOKEN_ROOTDSE;
            break;

        }


    }else if (  pObjectInfo->NamespaceName
            && !pObjectInfo->TreeName
            && pObjectInfo->NumComponents)
    {
        switch (pObjectInfo->dwPathType) {
        case PATHTYPE_WINDOWS:
            if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,SCHEMA_NAME))
                pObjectInfo->ObjectType = TOKEN_SCHEMA;
             else if (!_tcsicmp(pObjectInfo->ComponentArray[0].szComponent,ROOTDSE_NAME))
                      pObjectInfo->ObjectType = TOKEN_ROOTDSE;
            break;


        case PATHTYPE_X500:
        default:
            if (!_tcsicmp(pObjectInfo->ComponentArray[pObjectInfo->NumComponents - 1].szComponent,SCHEMA_NAME))
                pObjectInfo->ObjectType = TOKEN_SCHEMA;
             else if (!_tcsicmp(pObjectInfo->ComponentArray[pObjectInfo->NumComponents - 1].szComponent,ROOTDSE_NAME))
                      pObjectInfo->ObjectType = TOKEN_ROOTDSE;
            break;

        }

    }

    RRETURN(S_OK);
}


HRESULT
GetServerLessBasedObject(
    LPWSTR szBuffer,
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD   dwStatus = NO_ERROR;

    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszLDAPDn = NULL;

    TCHAR *pszParent = NULL;
    TCHAR *pszCommonName = NULL;

    TCHAR szADsClassName[64];
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];
    WCHAR *pszServerName=NULL;

    IADs *pADs = NULL;

    LPTSTR *aValues = NULL;
    int nCount = 0;

    TCHAR *pszLast = NULL;
    BOOL fVerify = FALSE ;

    DWORD dwPort = 0;
    ADS_LDP *ld = NULL;

    BOOL fFastBind = Credentials.GetAuthFlags() & ADS_FAST_BIND;
    BOOL fUseSpecifiedServer = (gpszStickyServerName != NULL);

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is LDAP:
    //

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateObjectType(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                       pObjectInfo,
                       Credentials,
                       ppObject
                       );
        BAIL_ON_FAILURE(hr);
        break;

    case TOKEN_ROOTDSE:
       //
       // This means taht this is a namespace object;
       // instantiate the namespace object
       //
       hr = GetRootDSEObject(
               pObjectInfo,
               Credentials,
               ppObject
               );
       BAIL_ON_FAILURE(hr);
       break;

    case TOKEN_SCHEMA:
    case TOKEN_CLASS:
    case TOKEN_PROPERTY:
    case TOKEN_SYNTAX:

        hr = GetSchemaObject(
                pObjectInfo,
                Credentials,
                pObjectInfo->PortNumber,
                ppObject
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:

        if ( pObjectInfo->TreeName == NULL )
        {
            LPTSTR pszName;
            LPTSTR aAddresses[5];

            //
            // fVerify is initially FALSE. If TRUE DsGetDCName will hit the net.
            //

RetryGetDefaultServer:

            dwStatus = GetDefaultServer(
                           pObjectInfo->PortNumber,
                           fVerify,
                           szDomainName,
                           szServerName,
                           TRUE
                           );
            if (dwStatus) {
                hr = HRESULT_FROM_WIN32(dwStatus);
                BAIL_ON_FAILURE(hr);
            }
            pszServerName=szServerName;

            if (fUseSpecifiedServer) {
                //
                // We need to change the name of the domain to be that of
                // the server we want to target. The swap is made if
                // 1) gpszDomainName == NULL, that implies that just
                // a serverName was set and not which domain it applies to.
                // 2) If a domainName is specified, then the domainName
                // from above should be that set in the global pointer for
                // the target server to be changed.
                //
                if ((gpszStickyDomainName
                     && (!_wcsicmp(szDomainName, gpszStickyDomainName))
                     )
                    || (gpszStickyDomainName == NULL)
                    ) {
                    //
                    // We need to change the target to the server.
                    //
                    wcscpy(szDomainName,gpszStickyServerName);
                    pszServerName = NULL;
                    //
                    // Make sure if server is down we go to another
                    // server on the retryGetDefault server path.
                    //
                    fUseSpecifiedServer = FALSE;
                }

            }

            hr = BuildLDAPPathFromADsPath2(
                        szBuffer,
                        &pszLDAPServer,
                        &pszLDAPDn,
                        &dwPort
                        );

            nCount = 0;

            // We need to open object here because we want to
            // keep the handle open, read will open/close if there
            // are no outstanding connections which is likely the case
            hr = LdapOpenObject2(
                     szDomainName,
                     pszServerName,
                     pszLDAPDn,
                     &ld,
                     Credentials,
                     dwPort
                     );

            if (SUCCEEDED(hr) && !fFastBind) {

                hr = LdapReadAttributeFast(
                         ld,
                         pszLDAPDn,
                         TEXT("objectClass"),
                         &aValues,
                         &nCount
                         );

                BAIL_ON_FAILURE(hr);

            }

            //
            // If server not present and we have NOT tried with fVerify
            // set to TRUE.
            //
            if (((hr == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH)) ||
                 (hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN)))
                        && !fVerify)
            {
                DWORD Last = LastVerifyDefaultServer ;
                DWORD Current = GetTickCount() ;

                //
                // If tick is zero, assume first time. In the very unlikely
                // event we wrapped managed to get exactly zero, we pay the
                // cost of the DsGetDcName (with verify).
                //
                if ((Last == 0) ||
                    ((Last <= Current) && ((Current-Last) > DC_NORETRY)) ||
                    ((Last >  Current) &&
                        ((Current+(((DWORD)(-1))- Last)) > DC_NORETRY))) {


                    //
                    // Set the time. Note this is not critical section
                    // protected and in this case it is not necessary.
                    //
                    LastVerifyDefaultServer = GetTickCount() ;

                    fVerify = TRUE ;

                    goto RetryGetDefaultServer ;
                }
            }
        }

        BAIL_ON_FAILURE(hr);

        if ( (nCount == 0) && !fFastBind)
        {
            // This object exists but does not have an objectClass. We
            // can't do anything without the objectClass. Hence, return
            // bad path error.
            hr = E_ADS_BAD_PATHNAME;
            BAIL_ON_FAILURE(hr);
        }

        hr = BuildADsParentPathFromObjectInfo2(
                    pObjectInfo,
                    &pszParent,
                    &pszCommonName
                    );
        BAIL_ON_FAILURE(hr);

        if (fFastBind) {

            hr = CLDAPGenObject::CreateGenericObject(
                        pszParent,
                        pszCommonName,
                        L"Top",
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **) &pADs,
                        fFastBind
                       );

        } else {

            hr = CLDAPGenObject::CreateGenericObject(
                        pszParent,
                        pszCommonName,
                        aValues,
                        nCount,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **) &pADs,
                        fFastBind
                       );

        }

        BAIL_ON_FAILURE(hr);

        //
        // InstantiateDerivedObject should add-ref this pointer for us.
        //

        hr = pADs->QueryInterface(
                        IID_IUnknown,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    }

error:

    if (pADs)
        pADs->Release();

    if ( aValues )
        LdapValueFree( aValues );

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

     if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
     }

    if ( pszParent )
        FreeADsStr( pszParent );

    if ( pszCommonName )
        FreeADsStr( pszCommonName );

    // If ld is open, we need to close it, note that if the object
    // was created successfuly, the Generic object created will have
    // the outstanding reference, if not the connection will be torn
    // down as should be expected.
    if (ld) {
        LdapCloseObject(ld);
    }


    RRETURN(hr);
}


HRESULT
GetObject(
    LPTSTR szBuffer,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
      HRESULT hr = S_OK;
      OBJECTINFO ObjectInfo;
      POBJECTINFO pObjectInfo = &ObjectInfo;

      if (!szBuffer || !ppObject) {
        hr = E_INVALIDARG;
        RRETURN_EXP_IF_ERR(hr);
      }

      memset(pObjectInfo, 0, sizeof(OBJECTINFO));
      pObjectInfo->ObjectType = TOKEN_LDAPOBJECT;
      hr = ADsObject(szBuffer, pObjectInfo);
      BAIL_ON_FAILURE(hr);

      switch (pObjectInfo->dwServerPresent) {

      case TRUE:
         hr = GetServerBasedObject(
                       szBuffer,
                       pObjectInfo,
                       Credentials,
                       ppObject
                       );
        break;

      case FALSE:
         hr = GetServerLessBasedObject(
                     szBuffer,
                     pObjectInfo,
                     Credentials,
                     ppObject
                     );

      }

      BAIL_ON_FAILURE(hr);


error:

      if (pObjectInfo) {
         FreeObjectInfo(pObjectInfo);
      }

      RRETURN_EXP_IF_ERR(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\extension.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP";
LPCWSTR lpszExtensions = L"Extensions";

PCLASS_ENTRY gpClassHead = NULL;


PCLASS_ENTRY
BuildClassesList()
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;
    HKEY hExtensionRootKey = NULL;

    HKEY hClassKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszClassName[MAX_PATH];
    DWORD dwchClassName = 0;
    PCLASS_ENTRY pClassHead = NULL;
    PCLASS_ENTRY pClassEntry = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszExtensions,
                     0,
                     KEY_READ,
                     &hExtensionRootKey
                     ) != ERROR_SUCCESS)

    {
        goto CleanupAndExit;

    }

    memset(lpszClassName, 0, sizeof(lpszClassName));
    dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);

    while(RegEnumKeyEx(hExtensionRootKey,
                     dwIndex,
                     lpszClassName,
                     &dwchClassName,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hExtensionRootKey,
                         lpszClassName,
                         0,
                         KEY_READ,
                         &hClassKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        pClassEntry  = BuildClassEntry(
                                lpszClassName,
                                hClassKey
                                );

        if (pClassEntry) {

            pClassEntry->pNext = pClassHead;
            pClassHead = pClassEntry;
        }

        if (hClassKey) {
            CloseHandle(hClassKey);
        }

        memset(lpszClassName, 0, sizeof(lpszClassName));
        dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);
        dwIndex++;
    }

CleanupAndExit:

    if (hExtensionRootKey) {
        RegCloseKey(hExtensionRootKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pClassHead);
}


VOID
FreeClassesList(
    PCLASS_ENTRY pClassHead
    )
{
    PCLASS_ENTRY pDelete;

    while (pClassHead) {

        pDelete = pClassHead;
        pClassHead = pClassHead->pNext;

        FreeClassEntry(pDelete);
    }

    return;
}


PCLASS_ENTRY
BuildClassEntry(
    LPWSTR lpszClassName,
    HKEY hClassKey
    )
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;

    DWORD dwIndex = 0;
    DWORD dwchExtensionCLSID = 0;
    WCHAR lpszExtensionCLSID[MAX_PATH];
    PCLASS_ENTRY pClassEntry = NULL;
    PEXTENSION_ENTRY pExtensionHead = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;

    pClassEntry =  (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (!pClassEntry) {

        goto CleanupAndExit;
    }

    wcscpy(pClassEntry->szClassName, lpszClassName);

    memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
    dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);

    while(RegEnumKeyEx(hClassKey,
                     dwIndex,
                     lpszExtensionCLSID,
                     &dwchExtensionCLSID,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hClassKey,
                         lpszExtensionCLSID,
                         0,
                         KEY_READ,
                         &hExtensionKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        //
        // Read the Interfaces that this Extension supports
        //

        pExtensionEntry = BuildExtensionEntry(
                                lpszExtensionCLSID,
                                hExtensionKey
                                );

        if (pExtensionEntry) {

            wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);

            pExtensionEntry->pNext = pExtensionHead;
            pExtensionHead = pExtensionEntry;
        }


        if (hExtensionKey) {

            CloseHandle(hExtensionKey);
        }

        memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
        dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);
        dwIndex++;

    }

CleanupAndExit:

    if (pExtensionHead)
    {
        pClassEntry->pExtensionHead = pExtensionHead;
    }
    else
    {
        //
        // There are no values under the key
        //
        if(pClassEntry)
        {
            FreeADsMem(pClassEntry);
            pClassEntry = NULL;        
        }
    } 

    return(pClassEntry);
}


PEXTENSION_ENTRY
BuildExtensionEntry(
    LPWSTR lpszExtensionCLSID,
    HKEY hExtensionKey
    )
{
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pInterfaceHead = NULL;
    WCHAR lpszInterfaces[MAX_PATH];
    DWORD dwchInterfaces = 0;
    LPWSTR psz = NULL;
    WCHAR Interface[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR;


    pExtensionEntry =  (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (!pExtensionEntry) {
        
        goto CleanupAndExit;
    }

    memset(lpszInterfaces, 0, sizeof(lpszInterfaces));
    dwchInterfaces = sizeof(lpszInterfaces);

    dwStatus = RegQueryValueEx(
                   hExtensionKey,
                   L"Interfaces",
                   NULL,
                   NULL,
                   (LPBYTE) lpszInterfaces,
                   &dwchInterfaces
                   );

    if(dwStatus)
    {
        // we should bail here
        goto CleanupAndExit;
    }

    psz = lpszInterfaces;

    while (psz && *psz) {

       wcscpy(Interface, psz);

       // skip (length) + 1
       // lstrlen returns length sans '\0'


       pInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

       if (pInterfaceEntry) {

           wcscpy(pInterfaceEntry->szInterfaceIID, Interface);
           hr = IIDFromString(Interface, &(pInterfaceEntry->iid));

           pInterfaceEntry->pNext = pInterfaceHead;
           pInterfaceHead = pInterfaceEntry;

       }

       psz = psz + lstrlen(psz) + 1;

    }

    wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);
    hr = CLSIDFromString(lpszExtensionCLSID, &(pExtensionEntry->ExtCLSID));
    if(FAILED(hr))
    {
        // we should bail out since ExtCLSID is the one we use to cocreate the extensions
        goto CleanupAndExit;
    }

    pExtensionEntry->pIID = pInterfaceHead;

    return pExtensionEntry;

CleanupAndExit:

    pInterfaceEntry = pInterfaceHead;

    while(pInterfaceEntry)
    {
        pInterfaceHead = pInterfaceHead->pNext;
        FreeADsMem(pInterfaceEntry);

        pInterfaceEntry = pInterfaceHead;
        
    }

    if(pExtensionEntry)
    {
        FreeADsMem(pExtensionEntry);
        pExtensionEntry = NULL;
    }
    
    return(pExtensionEntry);
}


void
FreeInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    if (pInterfaceEntry) {

        FreeADsMem(pInterfaceEntry);
    }
}


void
FreeExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pTemp = NULL;

    if (pExtensionEntry) {

        pInterfaceEntry = pExtensionEntry->pIID;

        while (pInterfaceEntry) {

            pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }

        //
        // Now unload the Extension Object
        //

        if (pExtensionEntry->pUnknown) {

            //
            // Call non-delegating Release to release ref. count on innner
            // object to inner object -> inner object self destroyed.
            //
            (pExtensionEntry->pUnknown)->Release();

        }


        FreeADsMem(pExtensionEntry);
    }

    return;
}

void
FreeClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{

    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PEXTENSION_ENTRY pTemp = NULL;

    if (pClassEntry) {

        pExtensionEntry = pClassEntry->pExtensionHead;

        while (pExtensionEntry) {

            pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;

        }

        FreeADsMem(pClassEntry);
    }

    return;
}


PINTERFACE_ENTRY
MakeCopyofInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    pNewInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

    if (pNewInterfaceEntry) {

        wcscpy(pNewInterfaceEntry->szInterfaceIID, pInterfaceEntry->szInterfaceIID);
        memcpy(&(pNewInterfaceEntry->iid), &(pInterfaceEntry->iid), sizeof(GUID));
    }

    return(pNewInterfaceEntry);
}



PEXTENSION_ENTRY
MakeCopyofExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PINTERFACE_ENTRY pInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceHead = NULL;


    pInterfaceEntry = pExtensionEntry->pIID;

    while (pInterfaceEntry) {

        pNewInterfaceEntry = MakeCopyofInterfaceEntry(pInterfaceEntry);

        if (pNewInterfaceEntry) {

            pNewInterfaceEntry->pNext = pNewInterfaceHead;
            pNewInterfaceHead = pNewInterfaceEntry;
        }

        pInterfaceEntry = pInterfaceEntry->pNext;

    }

    pNewExtensionEntry = (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (pNewExtensionEntry) {

        wcscpy(
            pNewExtensionEntry->szExtensionCLSID,
            pExtensionEntry->szExtensionCLSID
            );

        memcpy(
            &(pNewExtensionEntry->ExtCLSID),
            &(pExtensionEntry->ExtCLSID),
            sizeof(GUID)
            );

        pNewExtensionEntry->pIID = pNewInterfaceHead;


        //
        // Initialize fields we won't know the values of until an instacne of
        // the extension is created and aggregated (loaded).
        //

        pNewExtensionEntry->pUnknown=NULL;
        pNewExtensionEntry->pPrivDisp=NULL;
        pNewExtensionEntry->pADsExt=NULL;
        pNewExtensionEntry->fDisp=FALSE;
        pNewExtensionEntry->dwExtensionID = (DWORD) -1; //invalid dwExtensionID

        //
        // let class entry handle pNext
        //
    }
    else
    {
        // clear out the memory of interface entries
        pInterfaceEntry = pNewInterfaceHead;

        while (pInterfaceEntry) {

            pNewInterfaceHead = pNewInterfaceHead->pNext;
            
            FreeADsMem(pInterfaceEntry);

            pInterfaceEntry = pNewInterfaceHead;

        }
        
    }

    return(pNewExtensionEntry);
}


PCLASS_ENTRY
MakeCopyofClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{
    PCLASS_ENTRY pNewClassEntry = NULL;

    PEXTENSION_ENTRY pExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionHead = NULL;


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pNewExtensionEntry = MakeCopyofExtensionEntry(pExtensionEntry);

        if (pNewExtensionEntry) {

            pNewExtensionEntry->pNext = pNewExtensionHead;
            pNewExtensionHead = pNewExtensionEntry;
        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    pNewClassEntry = (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (pNewClassEntry) {

        wcscpy(pNewClassEntry->szClassName, pClassEntry->szClassName);

        pNewClassEntry->pExtensionHead = pNewExtensionHead;

    }
    else
    {
        // clear the memory of extension entries
        pExtensionEntry = pNewExtensionHead;

        while(pExtensionEntry)
        {
            pNewExtensionHead = pNewExtensionHead->pNext;
            FreeExtensionEntry(pExtensionEntry);

            pExtensionEntry = pNewExtensionHead;
        }
    }

    return(pNewClassEntry);
}


CRITICAL_SECTION g_ExtCritSect;

#define ENTER_EXTENSION_CRITSECT()  EnterCriticalSection(&g_ExtCritSect)
#define LEAVE_EXTENSION_CRITSECT()  LeaveCriticalSection(&g_ExtCritSect)

HRESULT
ADSIGetExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{

    PCLASS_ENTRY pTempClassEntry = NULL;
    PCLASS_ENTRY pClassEntry = NULL;
    ENTER_EXTENSION_CRITSECT();

    //
    // Initialize global extensions list if not already
    // initialized.  Note that this takes place inside the
    // g_ExtCritSect to protect against multiple threads trying
    // to simultaneously initialize it.
    //
    if (!gpClassHead) {
        gpClassHead = BuildClassesList();
    }

    pTempClassEntry = gpClassHead;

    while (pTempClassEntry) {


        if (!_wcsicmp(pTempClassEntry->szClassName, pszClassName)) {

            //
            // Make a copy of this entire extension and
            // hand it over to the calling entity.
            //

            pClassEntry = MakeCopyofClassEntry(pTempClassEntry);

            *ppClassEntry = pClassEntry;

            LEAVE_EXTENSION_CRITSECT();

            RRETURN(S_OK);

        }

        pTempClassEntry = pTempClassEntry->pNext;

   }


   *ppClassEntry = NULL;

   LEAVE_EXTENSION_CRITSECT();

   RRETURN(S_OK);

}


//+------------------------------------------------------------------------
//
//  Function:   ADSIAppendToExntesionList
//
//  Synopsis:   Adds to the end of the current class entry,
//           the extensions of the class pszClassName. This is
//           used in scenarios as follows - suppose fooUser
//           is derived from User, then we want to load the extensions
//           defined for User too apart from the extensions available
//           directly on fooUser.
//
//              The first cut is not going to see if the class is already
//           there in the list. This optimization can be done later if
//           needed.
//
//  Arguments:  [pszClassName]      -- name of class.
//              [ppClassEntry]      -- class entry returned
//
//              The class entry will be modified only if there were no
//           entries, if not we will append the new entry at the end.
//           AjayR 11-17-98 (added)
//-------------------------------------------------------------------------
HRESULT
ADSIAppendToExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pLocalExtEntry = NULL;
    PCLASS_ENTRY pLocClassEntry = NULL;


    //
    // Check if there are no extensions on the list
    //
    if (!*ppClassEntry) {
        RRETURN(ADSIGetExtensionList(pszClassName, ppClassEntry));
    }

    pLocalExtEntry = (*ppClassEntry)->pExtensionHead;
    while(pLocalExtEntry->pNext) {
        pLocalExtEntry = pLocalExtEntry->pNext;
    }

    //
    // Now get the extension list for the current class
    //
    hr = ADSIGetExtensionList(pszClassName, &pLocClassEntry);

    if (FAILED(hr)) {
        //
        // not a critical failure
        //
        hr = S_OK;
    }
    else {
        //
        // Add to the end of the current list.
        //
        if (pLocClassEntry) {

            pLocalExtEntry->pNext = pLocClassEntry->pExtensionHead;

            FreeADsMem((void*)pLocClassEntry);
        }
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:  
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

TCHAR *szProviderName = TEXT("LDAP");
TCHAR *szLDAPNamespaceName = TEXT("LDAP");
TCHAR *szGCNamespaceName = TEXT("GC");

//
// List of interface properties for Generic Objects
//
INTF_PROP_DATA IntfPropsGeneric[] =
{
    // 9999 implies BSTR value got using pIADs ptr.
    { TEXT("__Class"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__GUID"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Path"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Parent"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Schema"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__URL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    // end of list from IADs::get_ methods.
    { TEXT("__Genus"), OPERATION_CODE_READABLE,
      UMI_TYPE_I4,  FALSE, {UMI_GENUS_INSTANCE}},
    { TEXT("__Name"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__KEY"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__RELURL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__RELPATH"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__FULLRELURL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__PADS_SCHEMA_CONTAINER_PATH"), OPERATION_CODE_READABLE,
      9999, FALSE, {NULL}},
    { TEXT("__SECURITY_DESCRIPTOR"), OPERATION_CODE_READWRITE,
      9999, FALSE, {NULL}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};

//
// Same as generic save that genus is set to schema value.
//
INTF_PROP_DATA IntfPropsSchema[] =
{
    // 9999 implies BSTR value got using pIADs ptr.
    { TEXT("__Class"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Path"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__Parent"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__URL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    // end of list from IADs::get_ methods.
    { TEXT("__Genus"), OPERATION_CODE_READABLE,
      UMI_TYPE_I4, FALSE, {UMI_GENUS_CLASS}},
    { TEXT("__Name"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__RELURL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__RELPATH"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__FULLRELURL"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { TEXT("__SUPERCLASS"), OPERATION_CODE_READABLE, 9999, FALSE, {NULL}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};

//
// Interface property data for connection objects.
//
INTF_PROP_DATA IntfPropsConnection[] =
{
    { TEXT("Class"), OPERATION_CODE_READABLE,
         UMI_TYPE_LPWSTR, FALSE, {NULL} },
    { TEXT("__UserId"), OPERATION_CODE_READWRITE, 
        UMI_TYPE_LPWSTR, FALSE, {NULL}},
    { TEXT("__Password"), OPERATION_CODE_WRITEABLE,
        UMI_TYPE_LPWSTR, FALSE, {NULL}},
    { TEXT("__SECURE_AUTHENTICATION"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {TRUE}},
    { TEXT("__NO_AUTHENTICATION"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_READONLY_SERVER"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_PROMPT_CREDENTIALS"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SERVER_BIND"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_FAST_BIND"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_USE_SIGNING"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_USE_SEALING"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
//    { TEXT("SecurityFlags"), OPERATION_CODE_READWRITE,
//        UMI_TYPE_I4, FALSE, {1}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};


//
// Interface property data for cursor objects.
//
INTF_PROP_DATA IntfPropsCursor[] =
{
    { TEXT("__Filter"), OPERATION_CODE_READWRITE, 
        UMI_TYPE_LPWSTR, TRUE, {NULL}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};

//
// Interface properties for query object.
//
INTF_PROP_DATA IntfPropsQuery[]=
{
    { TEXT("__SEARCH_SCOPE"), OPERATION_CODE_READWRITE, UMI_TYPE_I4,
         FALSE, {LDAP_SCOPE_SUBTREE} },
    { TEXT("__PADS_SEARCHPREF_ASYNCHRONOUS"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_DEREF_ALIASES"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_SIZE_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_TIME_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_ATTRIBTYPES_ONLY"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_TIMEOUT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_PAGESIZE"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_PAGED_TIME_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_CHASE_REFERRALS"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {ADS_CHASE_REFERRALS_EXTERNAL}},
    //
    // BugBug do we keep this similar to IDirectorySearch or do we not cache.
    //
    { TEXT("__PADS_SEARCHPREF_CACHE_RESULTS"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {TRUE}},
    { TEXT("__PADS_SEARCHPREF_TOMBSTONE"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_FILTER"), OPERATION_CODE_READWRITE,
         UMI_TYPE_LPWSTR, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_ATTRIBUTES"), OPERATION_CODE_READWRITE,
         UMI_TYPE_LPWSTR, TRUE, {0}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};

BOOL   g_fDllsLoaded = FALSE;
HANDLE g_hDllNtdsapi = NULL;
HANDLE g_hDllSecur32 = NULL;
CRITICAL_SECTION g_csLoadLibsCritSect;

// load library helper

HMODULE LoadLibraryHelper(
    LPTSTR pszFileName
    )
{
    const DWORD iSize = GetSystemDirectory(NULL, 0);
    TCHAR* buffer = NULL;
    DWORD dwTemp = 0;
    HMODULE handle = NULL;

    if(iSize == 0)
    {        
        goto error;
    }

    buffer = new TCHAR[iSize + _tcslen(__TEXT("\\")) + _tcslen(pszFileName)];  // iSize includes the NULL terminiator
    if(!buffer)
    {        
        goto error;
    }

    dwTemp = GetSystemDirectory(buffer, iSize);
    if(dwTemp == 0)
    {
        goto error;
    }

    _tcscat(buffer, __TEXT("\\"));
    _tcscat(buffer, pszFileName);

    handle = LoadLibrary(buffer);

error:

    if(buffer)
    {
        delete [] buffer;
        buffer = NULL;
    }
    return handle;    
        
}



//
// Loads all the dynamic libs we need.
//
void BindToDlls()
{
    DWORD dwErr = 0;

    if (g_fDllsLoaded) {
        return;
    }

    ENTER_LOADLIBS_CRITSECT();
    if (g_fDllsLoaded) {
        LEAVE_LOADLIBS_CRITSECT();
        return;
    }

    if (!(g_hDllNtdsapi = LoadLibraryHelper(L"NTDSAPI.DLL"))) {
        dwErr = GetLastError();
    }

    if (g_hDllSecur32 = LoadLibraryHelper(L"SECUR32.DLL")) {
        if (dwErr) {
            //
            // Set the last error for whatever it is worth.
            // This does not really matter cause any dll we
            // cannot load, we will not get functions on that
            // dll. If secur32 load failed, then that call
            // would have set a relevant last error.
            //
            SetLastError(dwErr);
        }
    }

    g_fDllsLoaded = TRUE;
    LEAVE_LOADLIBS_CRITSECT();

    return;
}

//
// Loads the appropriate ntdsapi fn.
//
PVOID LoadNtDsApiFunction(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllNtdsapi) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllNtdsapi, function));
    }

    return NULL;
}


//
// Loads the appropriate secur32 fn.
//
PVOID LoadSecur32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllSecur32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllSecur32, function));
    }

    return NULL;
}

//
// DsUnquoteRdnValueWrapper
//
DWORD DsUnquoteRdnValueWrapper(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCWSTR  psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPWSTR   psUnquotedRdnValue
    )
{
    static PF_DsUnquoteRdnValueW pfDsUnquoteRdnVal = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsUnquoteRdnVal == NULL) {
        pfDsUnquoteRdnVal =
            (PF_DsUnquoteRdnValueW) LoadNtDsApiFunction(DSUNQUOTERDN_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsUnquoteRdnVal != NULL) {
        return ((*pfDsUnquoteRdnVal)(
                      cQuotedRdnValueLength,
                      psQuotedRdnValue,
                      pcUnquotedRdnValueLength,
                      psUnquotedRdnValue
                      )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }

}


//
// DsMakePasswordCredentialsWrapper
//
DWORD DsMakePasswordCredentialsWrapper(
    LPCWSTR User,
    LPCWSTR Domain,
    LPCWSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )
{
    static PF_DsMakePasswordCredentialsW pfMakePwdCreds = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfMakePwdCreds == NULL) {
        pfMakePwdCreds = (PF_DsMakePasswordCredentialsW)
                                LoadNtDsApiFunction(DSMAKEPASSWD_CRED_API);
        f_LoadAttempted = TRUE;
    }

    if (pfMakePwdCreds != NULL) {
        return ((*pfMakePwdCreds)(
                       User,
                       Domain,
                       Password,
                       pAuthIdentity
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsFreePasswordCredentialsWrapper
//
DWORD DsFreePasswordCredentialsWrapper(
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity
    )
{
    static PF_DsFreePasswordCredentials pfFreeCreds = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfFreeCreds == NULL) {
        pfFreeCreds = (PF_DsFreePasswordCredentials)
                          LoadNtDsApiFunction(DSFREEPASSWD_CRED_API);
        f_LoadAttempted = TRUE;
    }

    if (pfFreeCreds != NULL) {
        return ((*pfFreeCreds)(
                       AuthIdentity
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsBindWrapper.
//
DWORD DsBindWrapper(
    LPCWSTR         DomainControllerName,
    LPCWSTR         DnsDomainName,
    HANDLE          *phDS
    )
{
    static PF_DsBindW pfDsBind = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsBind == NULL) {
        pfDsBind = (PF_DsBindW) LoadNtDsApiFunction(DSBIND_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsBind != NULL) {
        return ((*pfDsBind)(
                       DomainControllerName,
                       DnsDomainName,
                       phDS
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsUnBindWrapper.
//
DWORD DsUnBindWrapper(
     HANDLE          *phDS
     )
{
    static PF_DsUnbindW pfDsUnbind = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsUnbind == NULL) {
        pfDsUnbind = (PF_DsUnbindW) LoadNtDsApiFunction(DSUNBIND_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsUnbind != NULL) {
        return ((*pfDsUnbind)(
                       phDS
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsCrackNamesWrapper.
//
DWORD DsCrackNamesWrapper(
    HANDLE              hDS,
    DS_NAME_FLAGS       flags,
    DS_NAME_FORMAT      formatOffered,
    DS_NAME_FORMAT      formatDesired,
    DWORD               cNames,
    const LPCWSTR       *rpNames,
    PDS_NAME_RESULTW    *ppResult
    )
{
    static PF_DsCrackNamesW pfDsCrackNames = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsCrackNames == NULL) {
        pfDsCrackNames = (PF_DsCrackNamesW)
                              LoadNtDsApiFunction(DSCRACK_NAMES_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsCrackNames != NULL) {
        return ((*pfDsCrackNames)(
                      hDS,
                      flags,
                      formatOffered,
                      formatDesired,
                      cNames,
                      rpNames,
                      ppResult
                      )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsBindWithCredWrapper.
//
DWORD DsBindWithCredWrapper(
    LPCWSTR         DomainControllerName,
    LPCWSTR         DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    HANDLE          *phDS
    )
{
    static PF_DsBindWithCredW pfDsBindWithCred = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsBindWithCred == NULL) {
        pfDsBindWithCred = (PF_DsBindWithCredW)
                                LoadNtDsApiFunction(DSBINDWITHCRED_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsBindWithCred != NULL) {
        return ((*pfDsBindWithCred)(
                       DomainControllerName,
                       DnsDomainName,
                       AuthIdentity,
                       phDS
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//
// DsFreeNameResultWrapper.
//
DWORD DsFreeNameResultWrapper(
    DS_NAME_RESULTW *pResult
    )
{
    static PF_DsFreeNameResultW pfDsFreeNameResult = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfDsFreeNameResult == NULL) {
        pfDsFreeNameResult = (PF_DsFreeNameResultW)
                                  LoadNtDsApiFunction(DSFREENAME_RESULT_API);
        f_LoadAttempted = TRUE;
    }

    if (pfDsFreeNameResult != NULL) {
        return ((*pfDsFreeNameResult)(
                       pResult
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}

//
// QueryContextAttributesWrapper.
//
DWORD QueryContextAttributesWrapper(
    PCtxtHandle phContext,
    unsigned long ulAttribute,
    void SEC_FAR * pBuffer
    )
{
    static PF_QueryContextAttributes pfQueryCtxtAttr = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfQueryCtxtAttr == NULL) {
        pfQueryCtxtAttr = (PF_QueryContextAttributes)
                                  LoadSecur32Function(QUERYCONTEXT_ATTR_API);
        f_LoadAttempted = TRUE;
    }

    if (pfQueryCtxtAttr != NULL) {
        return ((*pfQueryCtxtAttr)(
                       phContext,
                       ulAttribute,
                       pBuffer
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


//+---------------------------------------------------------------------------
// Function:   UrlToClassAndDn - global scope, helper function.
//
// Synopsis:   This function takes strings of the following formats and 
//          returns the class name and dn part in the appropriate return
//          values :
//          1) Fully qualified = user.cn=MyTestUser,
//          2) Full Name (umi) = .cn=MyTestUser,
//          3) ADSI style RDN  = cn=MyTestUser.
//
// Arguments:  pUrl            -  IUmiURL pointer.
//             ppszDN          -  Contains returned DN (callee must free
//                              using FreeADsStr.
//             ppszClass       -  Contains returned class name string. It
//                              is the callees responsiblity to free using 
//                              FreeADsStrResult.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *ppszDN && *ppszClass.
//
//----------------------------------------------------------------------------
HRESULT
UrlToClassAndDn(
    IN  IUmiURL *pUrl,
    OUT LPWSTR *ppszClass,
    OUT LPWSTR *ppszDN
    )
{
    HRESULT hr;
    WCHAR pszTxt[1024];
    ULONG ulLen = 1023;
    WCHAR *pszUrlTxt = pszTxt;
    LPCWSTR pszUrlTxtCopy = NULL;
    LPWSTR pszDN = NULL, pszClass = NULL;
    DWORD dwClassCount = 0;

    *ppszDN = *ppszClass = NULL;

    ADsAssert(pUrl);
    //
    // Something on the url object telling us what is wrong will help.
    //

    //
    // We need to get hold of the string from the url.
    //
    hr = pUrl->Get(0, &ulLen, pszUrlTxt);
    // replace the correct error code below WBEM_E_BUFFER_TOO_SMALL
    if (hr == 0x8004103c) {
        //
        // not enough space in our buffer, lets try again.
        //
        pszUrlTxt = (WCHAR*) AllocADsMem(ulLen * sizeof(WCHAR));
        if (!pszUrlTxt) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = pUrl->Get(0, &ulLen, pszUrlTxt);
    }

    BAIL_ON_FAILURE(hr);

    pszUrlTxtCopy = pszUrlTxt;
    //
    // Look for the . if there is one that is.
    //
    while (*pszUrlTxtCopy
           && (*pszUrlTxtCopy != L'.')
           && (*pszUrlTxtCopy != L'=')
           ) {
        dwClassCount++;
        pszUrlTxtCopy++;
    }

    if (!*pszUrlTxtCopy) {
        //
        // There was no = in the url has to be a bad RDN.
        //
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Urls without a . or not valid.
    //
    if (*pszUrlTxtCopy != L'.') {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (*pszUrlTxtCopy == L'=') {
        //
        // We do not have any class name
        //
        pszDN = AllocADsStr(pszUrlTxt);

        if (!pszDN) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    } 
    else {
        //
        // If the count is zero then we have .cn=something
        //
        if (dwClassCount == 0) {
            pszDN = AllocADsStr(++pszUrlTxtCopy);

            if (!pszDN) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        } 
        else {
            //
            // A valid class name is present.
            //
            pszClass = (LPWSTR) AllocADsMem(sizeof(WCHAR) * (dwClassCount+1));
        
            if (!pszClass) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            wcsncpy(pszClass, pszUrlTxt, dwClassCount);

            //
            // Advance beyond the . in the url and copy the rdn.
            //
            pszUrlTxtCopy++;

            if (!*pszUrlTxtCopy) {
                //
                // Only class name, no RDN.
                //
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            pszDN = AllocADsStr(pszUrlTxtCopy);

            if (!pszDN) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        } // end of else that is dwClassCount != 0
    } // end of else corresponding to class name or . present

    //
    // Alloc class name into new str so we can free using FreeADsStr.
    // 
    if (pszClass) {
        *ppszClass = AllocADsStr(pszClass);

        if (!*ppszClass) {
            BAIL_ON_FAILURE(hr);
        }
        FreeADsMem(pszClass);
    }

    *ppszDN = pszDN;

error:

    if (pszUrlTxt && (pszUrlTxt != pszTxt)) {
        FreeADsMem(pszUrlTxt);
    }

    //
    // Free the DN and Class only if applicable.
    //
    if (FAILED(hr)) {
        if (pszDN) {
            FreeADsStr(pszDN);
        }

        if (pszClass) {
            FreeADsMem(pszClass);
        }
    }

    RRETURN(hr);
}

HRESULT
GetRDn(
    IUmiURL *pURL,
    DWORD  dwComponent,
    LPWSTR pszRDn,
    DWORD  dwRDnLen
    )
{
    HRESULT hr = S_OK;
    IUmiURLKeyList * pKeyList = NULL;
    DWORD dwLen = dwRDnLen;
    DWORD dwKeyNameLen = 64;
    WCHAR szKeyName[64];
    LPWSTR pszTmpStr = NULL;
    BOOL fSchema = FALSE;

    pszTmpStr = (WCHAR*)AllocADsMem(dwRDnLen);
    if (!pszTmpStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Get the component we need, num is passed in.
    //
    hr = pURL->GetComponent(
             dwComponent,
             &dwLen,
             pszRDn,
             &pKeyList
             );
    BAIL_ON_FAILURE(hr);

    if (!pKeyList) {
        BAIL_ON_FAILURE(hr = UMI_E_NOT_FOUND);
    }

    //
    // Make sure that the key count is only one, anything 
    //else cannot be an LDAP path component.
    //  
    hr = pKeyList->GetCount(&dwLen);
    BAIL_ON_FAILURE(hr);

    if (dwLen != 1) {
        //
        // Need to see if we have the pszRDN set, if so that is the
        // RDN itself - for example Schema or RootDSE.
        //
        if (pszRDn) {
            goto error;
        }
        BAIL_ON_FAILURE(hr = UMI_E_NOT_FOUND);
    }

    dwLen = dwRDnLen;
    //
    // Get the RDN from the key !.
    //
    hr = pKeyList->GetKey(
             0,
             0,
             &dwKeyNameLen,
             szKeyName,
             &dwLen,
             pszTmpStr
             );
    BAIL_ON_FAILURE(hr);

    //
    // We need to special case class.Name=User. This means
    // we are looking for a class called user not an instance
    // of class with RDN Name=User.
    //
    fSchema = !_wcsicmp(pszRDn, L"Class")
              || !_wcsicmp(pszRDn, L"Schema")
              || !_wcsicmp(pszRDn, L"Property")
              || !_wcsicmp(pszRDn, L"Syntax");

    if (fSchema
        && szKeyName
        && !_wcsicmp(szKeyName, L"Name")
        ) {
        //
        // We have class.Name=User.
        //
        wsprintf(pszRDn, L"%s", pszTmpStr);
    }
    else {
        //
        // We have right values and this is the normal code path.
        //
        wsprintf(pszRDn, L"%s=",szKeyName);
        wcscat(pszRDn, pszTmpStr);
    }

error:

    if (pKeyList) {
        pKeyList->Release();
    }

    if (pszTmpStr) {
        FreeADsMem(pszTmpStr);
    }

    RRETURN(hr);
}

HRESULT
GetDNFromURL(
    IUmiURL *pURL,
    LPWSTR *pszDnStr,
    DWORD dwTotalLen
    )
{
    HRESULT hr = S_OK;
    DWORD dwNumComponents = 0, dwCtr = 0;
    LPWSTR pszLocalDn = NULL;
    LPWSTR pszRDn = NULL;

    *pszDnStr = NULL;
    hr = pURL->GetComponentCount(&dwNumComponents);
    BAIL_ON_FAILURE(hr);

    if (dwNumComponents == 0) {
        //
        // DnStr is NULL in this case.
        //
        RRETURN(hr);
    }

    //
    // This is for the retval.
    //
    pszLocalDn = (LPWSTR) AllocADsMem(dwTotalLen * sizeof(WCHAR));
    if (!pszLocalDn) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // This is for the rdn's, this buffer should be more than enough
    //
    pszRDn = (LPWSTR) AllocADsMem(dwTotalLen * sizeof(WCHAR));
    if (!pszRDn) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // We need to get each of the individuals dn's and keep adding
    // them to the dn we return.
    //
    for (dwCtr = 0; dwCtr < dwNumComponents; dwCtr++) {
        *pszRDn = NULL;
        hr = GetRDn(pURL, (dwNumComponents-1) - dwCtr, pszRDn, dwTotalLen);
        BAIL_ON_FAILURE(hr);
        if (*pszRDn) {
            wcscat(pszLocalDn, pszRDn);
            if (dwCtr != (dwNumComponents - 1)) {
                wcscat(pszLocalDn, L",");
            }
        } 
        else {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

    //
    // We must have the correct DN !
    //
    *pszDnStr = pszLocalDn;


error:

    if (FAILED(hr)) {
        if (pszLocalDn) {
            FreeADsMem(pszLocalDn);
        }
    }

    if (pszRDn) {
        FreeADsMem(pszRDn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   UrlToLDAPPath - global scope, helper function.
//
// Synopsis:   This routine converts the URL to the 
//
// Arguments:  pURL            -  URL to be converted to path. Note
//                              that this can be native or Umi.
//             pszLDAPPath     -  Path is allocated into this var.
//             ppszDn          -  
//             ppszClass       -  Contains returned class name string. It
//                              is the callees responsiblity to free using 
//                              FreeADsStrResult.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *ppszDN && *ppszClass.
//
//----------------------------------------------------------------------------
HRESULT
UrlToLDAPPath(
    IN  IUmiURL *pURL,
    OUT LPWSTR *ppszLDAPPath,
    OPTIONAL OUT LPWSTR *ppszDn,
    OPTIONAL OUT LPWSTR *ppszServer
    )
{
    HRESULT hr = S_OK;
    DWORD dwURLType = 0;
    DWORD dwLen = 1023;
    DWORD dwTxtLen = 1023;
    WCHAR pszTxt[1024];
    LPWSTR pszDn = NULL;
    LPWSTR pszLdapPath = NULL;
    BOOL fAddSlash = FALSE;
    ULONGLONG ululPathType = UMIPATH_INFO_INSTANCE_PATH;

    //
    // We need the type of the url, if it is an ldap native path.
    // For now though this support is not available. We assume that
    // this is a umi path for now.
    //
    
    //
    // Get the total length needed for the path.
    //
    hr = pURL->Get(0, &dwLen, pszTxt);
    // replace the correct error code below WBEM_E_BUFFER_TOO_SMALL
    if ((FAILED(hr) && (hr != 0x8004103c))
        || (dwLen == 0)) {
        //
        // Failure was either length was zero or error was someting
        // other than buffer too small.
        //
        BAIL_ON_FAILURE(hr);
    }

    dwLen++; // for the terminating \0.
    pszLdapPath = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));
    if (!pszLdapPath) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = pURL->GetPathInfo(0, &ululPathType);
    BAIL_ON_FAILURE(hr);

    if (ululPathType == UMIPATH_INFO_NATIVE_STRING) {
        //
        // Just get the path in pszLdapPath and return.
        //
        hr = pURL->Get(0, &dwLen, pszLdapPath);
        BAIL_ON_FAILURE(hr);
    } 
    else {
    
    
        //
        // Make sure that the namespace is either LDAP or GC.
        // We bail on failure cause we cannot possibly have a locator
        // that is more than our buffer size !
        //
        hr = pURL->GetRootNamespace(&dwTxtLen, pszTxt);
        BAIL_ON_FAILURE(hr);
    
        if (!_wcsicmp(L"LDAP", pszTxt)) {
            wsprintf(pszLdapPath, L"%s", L"LDAP:");
        } 
        else if (!_wcsicmp(L"GC", pszTxt)) {
            wsprintf(pszLdapPath, L"%s", L"GC:");
        } 
        else {
            BAIL_ON_FAILURE(hr = UMI_E_NOT_FOUND);
        }
    
        //
        // We now need to add the server and the // if applicable.
        //
        dwTxtLen = 1023;
        hr = pURL->GetLocator(&dwTxtLen, pszTxt);
        if (hr == 0x8004103c) {
            //
            // Unexpected cause locator is too big !.
            //
            hr = E_FAIL;
        }
        BAIL_ON_FAILURE(hr);
    
        if (!wcscmp(pszTxt, L".")) {
            //
            // This would mean we are going serverless.
            //
            wcscat(pszLdapPath, L"/");
        } 
        else if (!*pszTxt)  {
            //
            // Means that we have the LDAP namespace or no server.
            //
            fAddSlash = TRUE;
        } 
        else {
            //
            // Add the // and the servername given.
            //
            wcscat(pszLdapPath, L"//");
            wcscat(pszLdapPath, pszTxt);
        }
    
        //
        // Now we need to get the DN and tag it along.
        //
        hr = GetDNFromURL(pURL, &pszDn, dwLen);
        BAIL_ON_FAILURE(hr);
    
        if (pszDn && *pszDn) {
            if (fAddSlash) {
                //
                // Serverless path.
                //
                wcscat(pszLdapPath, L"/");
            }
            //
            // Tag on the DN now, it will do the right thing for 
            // both server and serverless paths.
            //
            wcscat(pszLdapPath,L"/");
            wcscat(pszLdapPath,pszDn);
        }
    } // this was not a native path.

    *ppszLDAPPath = pszLdapPath;

error:

    if (FAILED(hr)) {
        if (pszLdapPath) {
            FreeADsMem(pszLdapPath);
        }
    }

    if (pszDn) {
        FreeADsMem(pszDn);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   ADsPathToUmiUrl - global scope, helper function.
//
// Synopsis:   This routine converts the ADsPath to UMI URL txt.
//
// Arguments:  ADsPath         -  Input string.
//             ppszUrlTxt      -  Output converted url txt.
//
// Returns:    HRESULT - S_OK or any failure ecode.
//
// Modifies:   *ppszUrlTxt - to point to the correct 
//
//----------------------------------------------------------------------------
HRESULT
ADsPathToUmiURL(
    IN  LPWSTR ADsPath,
    OUT LPWSTR *ppszUrlTxt
    )
{
    HRESULT hr = S_OK;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    DWORD dwNumComponents = 0, dwCtr;
    LPWSTR pszUrl = NULL;
    BOOL fReverseOrder = TRUE;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    ADsAssert(ADsPath && ppszUrlTxt);
    *ppszUrlTxt = NULL;

    //
    // We build our ObjectInfo struct and then build the url
    // from the objectInfo struct.
    //
    pObjectInfo->ObjectType = TOKEN_LDAPOBJECT;
    hr = ADsObject(ADsPath, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;
    //
    // We can make a guess as to the size we need for the string.
    //
    pszUrl = (WCHAR *) AllocADsMem(
                           ( sizeof(WCHAR) * wcslen(ADsPath) )
                           // for the actual name
                           + (sizeof(WCHAR) * dwNumComponents)
                           // for all the .'s we need as in .DC=test
                           + (sizeof(WCHAR) * 15)
                           );
    //
    // sizeof(WCHAR) * 15 has been added so that we can handle
    // the umi:// (6) which is extra + if we have a GC path, then 
    // we would need to add LDAP/ (5) just in case a small buffer
    // of 4 giving the 15
    //
    if (!pszUrl) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Get the umi:// in the output, then add the server if applicable,
    // then the LDAP/GC or LDAP alone as applicable.
    //
    wsprintf(pszUrl, L"%s", L"umi://");

    if (pObjectInfo->dwServerPresent) {
        if (pObjectInfo->TreeName) {
            wcscat(pszUrl, pObjectInfo->TreeName);
        }
    }

    wcscat(pszUrl, L"/"); // need if there is a server or not.
    wcscat(pszUrl, L"LDAP"); // needed if LDAP or GC.

    if (!_wcsicmp(pObjectInfo->ProviderName, szGCNamespaceName)) {
        wcscat(pszUrl, L"/GC");
    }

    //
    // This is to check if we were given an LDAP windows style path,
    // with reverse order rather than LDAP dn style path.
    //
    if (pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
        //
        // Already reversed so just use the order directly.
        //
        for (dwCtr = 0; dwCtr < dwNumComponents; dwCtr++) {
            //
            // When you have a path like LDAP://RootDSE, then the szComponent
            // alone is set and not the value in these cases we need to 
            // build the path in a different manner.
            //
            if (pObjectInfo->ComponentArray[dwCtr].szValue) {

                wcscat(pszUrl, L"/.");
                wcscat(
                    pszUrl,
                    pObjectInfo->ComponentArray[dwCtr].szComponent
                    );
                wcscat(pszUrl, L"=");
                wcscat(pszUrl, pObjectInfo->ComponentArray[dwCtr].szValue);
            } 
            else {
                //
                // We just have a component as in RootDSE or Schema so.
                //
                wcscat(pszUrl, L"/");
                wcscat(
                    pszUrl,
                    pObjectInfo->ComponentArray[dwCtr].szComponent
                    );
            }
        }
    }
    else {
        //
        // Need to do this reverse order.
        //
        for (dwCtr = dwNumComponents; dwCtr > 0; dwCtr--) {
            //
            // When you have a path like LDAP://RootDSE, then the szComponent
            // alone is set and not the value in these cases we need to 
            // build the path in a different manner.
            //
            if (pObjectInfo->ComponentArray[dwCtr-1].szValue) {

                wcscat(pszUrl, L"/.");
                wcscat(
                    pszUrl,
                    pObjectInfo->ComponentArray[dwCtr-1].szComponent
                    );
                wcscat(pszUrl, L"=");
                wcscat(pszUrl, pObjectInfo->ComponentArray[dwCtr-1].szValue);
            } 
            else {
                //
                // We just have a component as in RootDSE or Schema so.
                //
                wcscat(pszUrl, L"/");
                wcscat(
                    pszUrl,
                    pObjectInfo->ComponentArray[dwCtr-1].szComponent
                    );
            }

        }
    }

    *ppszUrlTxt = pszUrl;

error:

    if (FAILED(hr)) {
        if (pszUrl) {
            FreeADsMem(pszUrl);
        }
    }

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN(hr);
}


BOOL
IsPreDefinedErrorCode(HRESULT hr)
{
    switch (hr) {
    case E_UNEXPECTED :
    case E_NOTIMPL :
    case E_OUTOFMEMORY :
    case E_INVALIDARG :
    case E_NOINTERFACE :
    case E_HANDLE :
    case E_ABORT :
    case E_FAIL :
    case E_ACCESSDENIED :
    case E_PENDING :
    case E_POINTER :
    case UMI_E_CONNECTION_FAILURE :
    case UMI_E_TIMED_OUT :
    case UMI_E_TYPE_MISMATCH :
    case UMI_E_NOT_FOUND : 
    case UMI_E_INVALID_FLAGS : 
    case UMI_E_UNSUPPORTED_FLAGS :
    case UMI_E_SYNCHRONIZATION_REQUIRED :
    case UMI_E_UNSUPPORTED_OPERATION : 
    case UMI_E_TRANSACTION_FAILURE : 
        RRETURN(TRUE);
        break;

    default:
        RRETURN(FALSE);
        break;
    }
}

//+---------------------------------------------------------------------------
// Function:   MapHrToUmiError - global scope, helper function.
//
// Synopsis:   This routine converts the given hr to an equivalent umi err.
//
// Arguments:  hr      -   hr to convert to umi error.
//
// Returns:    HRESULT -   umi error code corresponing to hr passed in.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
MapHrToUmiError(HRESULT hr)
{
    HRESULT retHr = hr;

    if (IsPreDefinedErrorCode(hr)) {
        RRETURN(hr);
    }

    switch (hr) {

    case E_ADS_INVALID_DOMAIN_OBJECT:
    case E_ADS_INVALID_USER_OBJECT:
    case E_ADS_INVALID_COMPUTER_OBJECT:
    case E_ADS_UNKNOWN_OBJECT:
        retHr = UMI_E_NOT_FOUND;
        break;

    case E_ADS_PROPERTY_NOT_FOUND:
        retHr = UMI_E_NOT_FOUND;
        break;

    case E_ADS_BAD_PARAMETER:
        retHr = E_INVALIDARG;
        break;

    case E_ADS_CANT_CONVERT_DATATYPE:
        retHr = UMI_E_TYPE_MISMATCH;
        break;

    case E_ADS_BAD_PATHNAME:
        retHr = E_INVALIDARG;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE) :
        // LDAP_NO_SUCH_ATTRIBUTE
        retHr = UMI_E_NOT_FOUND;
        break;
    
    case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) :
        // LDAP_NO_SUCH_OBJECT
        retHr = UMI_E_NOT_FOUND;
        break;

    default:
        retHr = E_FAIL;
        break;
    } // end of case
            
    RRETURN(retHr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldap2.h ===
#define LDAP_LIBIID_LDAPOle        228D9A80-C302-11cf-9AA4-00AA004A5691
#define DBGUID_LDAPDialect         83889f20-07d5-11d0-831a-00aa00b505db

#define LDAP_CLSID_LDAPProvider    228D9A81-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPNamespace   228D9A82-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPGenObject   228D9A83-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPUser        228D9A84-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPGroup       228D9A85-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPSchema      228D9A86-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPClass       228D9A87-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPProperty    228D9A88-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPSyntax      228D9A89-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPLocality    228D9A8A-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPO           228D9A8B-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPOU          228D9A8C-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPCountry     228D9A8D-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPDomain      228D9A8E-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPComputer    228D9A8F-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPPrintQueue  228D9A90-C302-11cf-9AA4-00AA004A5691

#define LDAP_CLSID_DSOObject       549365d0-ec26-11cf-8310-00aa00b505db
#define LDAP_CLSID_MSDATT          2dbed740-0819-11d0-831a-00aa00b505db
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for LDAP guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// LDAPOle CLSIDs
//
//-------------------------------------------


//
// LDAPOle objects
//

extern const CLSID LIBID_LDAPOle;

extern const CLSID CLSID_LDAPProvider;

extern const CLSID CLSID_LDAPNamespace;

extern const CLSID CLSID_LDAPGenObject;

extern const CLSID CLSID_LDAPUser;

extern const CLSID CLSID_LDAPGroup;

extern const CLSID CLSID_LDAPSchema;

extern const CLSID CLSID_LDAPClass;

extern const CLSID CLSID_LDAPProperty;

extern const CLSID CLSID_LDAPSyntax;

extern const CLSID CLSID_LDAPLocality;

extern const CLSID CLSID_LDAPO;

extern const CLSID CLSID_LDAPOU;

extern const CLSID CLSID_LDAPCountry;

extern const CLSID CLSID_LDAPDomain;

extern const CLSID CLSID_LDAPComputer;

extern const CLSID CLSID_LDAPPrintQueue;

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  LDAP CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(LIBID_LDAPOle, 0x228d9a80, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPProvider, 0x228d9a81, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPNamespace, 0x228d9a82, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPGenObject, 0x228d9a83, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPUser, 0x228d9a84, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPGroup, 0x228d9a85, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPSchema, 0x228d9a86, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPClass, 0x228d9a87, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPProperty, 0x228d9a88, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPSyntax, 0x228d9a89, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPLocality, 0x228d9a8A, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPO, 0x228d9a8B, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPOU, 0x228d9a8C, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPCountry, 0x228d9a8D, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPDomain, 0x228d9a8E, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPComputer, 0x228d9a8F, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);

DEFINE_GUID(CLSID_LDAPPrintQueue, 0x228d9a90, 0xc302, 0x11cf, 0x9a, 0xa4, 0x0, 0xaa, 0x0, 0x4a, 0x56, 0x91);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldapres.h ===
#define LDAP_PROVIDER_ID 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}


//
// Use this if the object needs to go on the wire to
// get any of the core properties (will be case for FAST_BIND
// and GUID in all cases). Also takes care of <WkGuid=...> case.
//
#define DEFINE_IADs_Shorter_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}





#define DEFINE_IDispatch_ExtMgr_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pExtMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pExtMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


/* Macro to call the ADsSetLastError function */
#define Macro_ClearADsLastError(providerString)                             \
ADsSetLastError(NO_ERROR, NULL, providerString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

BOOL fInitializeCritSect = FALSE;
HINSTANCE g_hInst = NULL;
extern HMODULE g_hActiveDs;

typedef DWORD (*PF_DllGetClassObject) (
    REFCLSID clsid,
    REFIID iid,
    LPVOID FAR* ppverved
);

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

extern CRITICAL_SECTION  g_RootDSECritSect;

extern CRITICAL_SECTION  g_ExtCritSect;

extern CRITICAL_SECTION  g_TypeInfoCritSect;

extern CRITICAL_SECTION  g_DispTypeInfoCritSect;

extern CRITICAL_SECTION g_SystemAPICritSect;

CRITICAL_SECTION g_LockCritSect;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    TCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(TEXT("LDAP"),TEXT("heapInfoLevel"), TEXT("00000003"), awcs,MAXINFOLEN))
        heapInfoLevel = _tcstoul(awcs, NULL, 16);

    if (GetProfileString(TEXT("LDAP"),TEXT("Ot"), TEXT("00000003"), awcs, MAXINFOLEN))
        OtInfoLevel = _tcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(TEXT("LDAP"),TEXT("ADsInfoLevel"), TEXT("00000003"), awcs,MAXINFOLEN))
        ADsInfoLevel = _tcstoul(awcs, NULL, 16);
#endif
}

//  Globals

ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll
ULONG  g_ulLocks = 0;    // Number of Provider objects alive

CLDAPProviderCF g_cfProvider;
CLDAPNamespaceCF g_cfNamespace;
CADSystemInfoCF  g_cfADSystemInfo;
CNameTranslateCF g_cfNameTranslate;

//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};


CLSCACHE g_aclscache[] =
{
    &CLSID_LDAPProvider,                        &g_cfProvider,
    &CLSID_LDAPNamespace,                       &g_cfNamespace,
    &CLSID_NameTranslate,                       &g_cfNameTranslate,
    &CLSID_ADSystemInfo,                        &g_cfADSystemInfo    
};

extern PCLASS_ENTRY gpClassHead;

//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr = E_NOINTERFACE;
    size_t          i;
    HKEY hKey = NULL;
    HINSTANCE hDll = NULL ;

    if (ppv)
        *ppv = NULL;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    //
    // This workaround is for the special case where an old version of ADSI
    // is installed in the system. Installing that will overwrite the registry
    // with the old setting for pathcracker. The pathcracker object used to live
    // on adsldp.
    // The following code redirects the call to the DllGetClassObject in
    // activeds if the Pathname object is being requested. It also fixes the
    // registry to point to the correct DLL.
    //
    if (IsEqualCLSID(clsid, CLSID_Pathname)) {
        PF_DllGetClassObject pfDllGetClassObject= NULL ;
        WCHAR szPathDescriptor[] = L"ADs Pathname Object";
        WCHAR szDllName[] = L"activeds.dll";
        DWORD WinError;

        if (!(hDll = LoadLibraryHelper(szDllName))) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        if (!(pfDllGetClassObject = (PF_DllGetClassObject)GetProcAddress(hDll, "DllGetClassObject"))) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        hr = (*pfDllGetClassObject)(clsid,
                              iid,
                              ppv);
        BAIL_ON_FAILURE(hr);

        //
        // Setting the general description
        // Even if any of the operations below fails, we'll just bail with the
        // hr from DllGetClassObject.
        //
        WinError = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                L"CLSID\\{080d0d78-f421-11d0-a36e-00c04fb950dc}",
                                NULL,
                                KEY_ALL_ACCESS,
                                &hKey);
        if (WinError != ERROR_SUCCESS) {
            goto error;
        }

        WinError = RegSetValueEx(hKey,
                                NULL,
                                0,
                                REG_SZ,
                                (BYTE *)szPathDescriptor,
                                (wcslen(szPathDescriptor)+1) * sizeof(WCHAR));
        if (WinError != ERROR_SUCCESS) {
            goto error;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        //
        // Setting the inprocserver
        //
        WinError = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                L"CLSID\\{080d0d78-f421-11d0-a36e-00c04fb950dc}\\InprocServer32",
                                NULL,
                                KEY_ALL_ACCESS,
                                &hKey);
        if (WinError != ERROR_SUCCESS) {
            goto error;
        }

        WinError = RegSetValueEx(hKey,
                                NULL,
                                0,
                                REG_SZ,
                                (BYTE *)szDllName,
                                (wcslen(szDllName)+1) * sizeof(WCHAR));
        if (WinError != ERROR_SUCCESS) {
            goto error;
        }
    }

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

error:
    if (hDll) {
        FreeLibrary(hDll);
    }
    if (hKey) {
        RegCloseKey(hKey);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;    

    hr = S_FALSE;

    //
    // Both the ldap and utils\cdispmgr count need to be 0
    //
    if (AggregatorDllCanUnload() && DllReadyToUnload()) {

        EnterCriticalSection(&g_LockCritSect);
        if(0 == g_ulLocks)
        {
            hr = S_OK;
        }
        LeaveCriticalSection(&g_LockCritSect);              

    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    DWORD dwCritSectIniStage = 0;     

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // In try to catch possibily of init crit sects failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

            g_hActiveDs = GetModuleHandle(TEXT("activeds.dll"));

            // Maybe we should check the handle.

            InitializeCriticalSection(&g_RootDSECritSect);
            dwCritSectIniStage = 1;
            
            InitializeCriticalSection(&g_ExtCritSect);
            dwCritSectIniStage = 2;
            
            InitializeCriticalSection(&g_TypeInfoCritSect);
            dwCritSectIniStage = 3;
            
            InitializeCriticalSection(&g_DispTypeInfoCritSect);
            dwCritSectIniStage = 4;
            
            InitializeCriticalSection(&g_csLoadLibsCritSect);
            dwCritSectIniStage = 5;
            
            InitializeCriticalSection(&g_LockCritSect);
            dwCritSectIniStage = 6;

            InitializeCriticalSection(&g_SystemAPICritSect);
            dwCritSectIniStage = 7;

#if DBG==1
            InitializeCriticalSection(&g_csDP);
            dwCritSectIniStage = 8;
            
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            dwCritSectIniStage = 9;
            
            InitializeCriticalSection(&g_csMem);
            dwCritSectIniStage = 10;
#endif
            
#endif         

            fInitializeCritSect = TRUE;
            
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // Something went wrong
            //
            switch(dwCritSectIniStage)
            {
#if DBG==1
#ifndef MSVC            
                case 10:
                    DeleteCriticalSection(&g_csMem);
                case 9:
                    DeleteCriticalSection(&g_csOT);
            
#endif
                case 8:
                    DeleteCriticalSection(&g_csDP);
            
#endif
                case 7:
                    DeleteCriticalSection(&g_SystemAPICritSect);
                case 6:
                    DeleteCriticalSection(&g_LockCritSect);
                case 5:
                    DeleteCriticalSection(&g_csLoadLibsCritSect);
                case 4:
                    DeleteCriticalSection(&g_DispTypeInfoCritSect);
                case 3:
                    DeleteCriticalSection(&g_TypeInfoCritSect);
                case 2:
                    DeleteCriticalSection(&g_ExtCritSect);
                case 1:
                    DeleteCriticalSection(&g_RootDSECritSect);
            

            }
            
            return FALSE;
        }

            break;


    case DLL_PROCESS_DETACH:

        //
        // free global list of class entries for 3rd party ext
        //

        if (gpClassHead) {
            FreeClassesList(gpClassHead);
        }

        if (gpszStickyServerName) {
            FreeADsStr(gpszStickyServerName);
            gpszStickyServerName = NULL;
        }

        if (gpszStickyDomainName) {
            FreeADsStr(gpszStickyDomainName);
            gpszStickyDomainName = NULL;
        }

        
        //
        // Good idea to delete all the critical sections
        //

        if(fInitializeCritSect)
        {
            FreeServerType();
        
#if DBG==1
#ifndef MSVC
            DeleteCriticalSection(&g_csOT);
            DeleteCriticalSection(&g_csMem);
#endif
            DeleteCriticalSection(&g_csDP);
#endif            
            DeleteCriticalSection(&g_RootDSECritSect);
            DeleteCriticalSection(&g_ExtCritSect);
            DeleteCriticalSection(&g_TypeInfoCritSect);
            DeleteCriticalSection(&g_DispTypeInfoCritSect);
            DeleteCriticalSection(&g_csLoadLibsCritSect);
            DeleteCriticalSection(&g_LockCritSect);
            DeleteCriticalSection(&g_SystemAPICritSect);

        }

        //
        // Should be ok to free the dynamically loaded libs.
        //
        if (g_hDllNtdsapi) {
            FreeLibrary((HMODULE) g_hDllNtdsapi);
            g_hDllNtdsapi = NULL;
        }

        if (g_hDllSecur32) {
            FreeLibrary((HMODULE) g_hDllSecur32);
        }

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldap2umi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       ldap2umi.cxx
//
//  Contents: File containing the implemenation of the conversion routines
//       that conver the cached ldap values to UMI data types.
//       LdapTypeToUMITypeCopyConstruct. 
//
//  History:    02-14-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//+---------------------------------------------------------------------------
// Function:   ConvertLdapSyntaxIdToUmiType.
//
// Synopsis:   Converts the ldapsyntaxId to the corresponding Umi type.
//
//
// Arguments:  dwLdapSyntax    -   Input ldapSyntaxId to convert.
//             uUmiType        -   Reference to return value.
//
// Returns:    HRESULT - S_OK or any failure code.
//
// Modifies:   uUmiType.
//
//----------------------------------------------------------------------------
HRESULT 
ConvertLdapSyntaxIdToUmiType(
    DWORD dwLdapSyntaxId,
    ULONG &uUmiType
    )
{
    HRESULT hr = S_OK;

    switch (dwLdapSyntaxId) {
    
    case LDAPTYPE_BITSTRING:
    case LDAPTYPE_PRINTABLESTRING:
    case LDAPTYPE_DIRECTORYSTRING:
    case LDAPTYPE_COUNTRYSTRING:
    case LDAPTYPE_DN:
    case LDAPTYPE_NUMERICSTRING:
    case LDAPTYPE_IA5STRING:
    case LDAPTYPE_CASEIGNORESTRING:
    case LDAPTYPE_CASEEXACTSTRING:
//    case LDAPTYPE_CASEIGNOREIA5STRING:
    case LDAPTYPE_OID:
    case LDAPTYPE_TELEPHONENUMBER:
    case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
    case LDAPTYPE_OBJECTCLASSDESCRIPTION:

    case LDAPTYPE_DELIVERYMETHOD:
    case LDAPTYPE_ENHANCEDGUIDE:
    case LDAPTYPE_FACSIMILETELEPHONENUMBER:
    case LDAPTYPE_GUIDE:
    case LDAPTYPE_NAMEANDOPTIONALUID:
    case LDAPTYPE_POSTALADDRESS:
    case LDAPTYPE_PRESENTATIONADDRESS:
    case LDAPTYPE_TELEXNUMBER:
    case LDAPTYPE_DSAQUALITYSYNTAX:
    case LDAPTYPE_DATAQUALITYSYNTAX:
    case LDAPTYPE_MAILPREFERENCE:
    case LDAPTYPE_OTHERMAILBOX:
    case LDAPTYPE_ACCESSPOINTDN:
    case LDAPTYPE_ORNAME:
    case LDAPTYPE_ORADDRESS:
        uUmiType = UMI_TYPE_LPWSTR;
        break;
    
    case LDAPTYPE_BOOLEAN:
        uUmiType = UMI_TYPE_BOOL;
        break;
    
    case LDAPTYPE_INTEGER:
        uUmiType = UMI_TYPE_I4;
        break;
    
    case LDAPTYPE_OCTETSTRING:
    case LDAPTYPE_CERTIFICATE:
    case LDAPTYPE_CERTIFICATELIST:
    case LDAPTYPE_CERTIFICATEPAIR:
    case LDAPTYPE_PASSWORD:
    case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
    case LDAPTYPE_AUDIO:
    case LDAPTYPE_JPEG:
    case LDAPTYPE_FAX:
        uUmiType = UMI_TYPE_OCTETSTRING;
        break;
    
    case LDAPTYPE_GENERALIZEDTIME:  
        uUmiType = UMI_TYPE_SYSTEMTIME;
        break;
    
    case LDAPTYPE_UTCTIME:
        uUmiType = UMI_TYPE_SYSTEMTIME;
        break;
    
    case LDAPTYPE_SECURITY_DESCRIPTOR:
        uUmiType = UMI_TYPE_IUNKNOWN;
        break;
    
    case LDAPTYPE_INTEGER8:
        uUmiType = UMI_TYPE_I8;
        break;
    
    case LDAPTYPE_DNWITHBINARY:
        uUmiType = UMI_TYPE_IUNKNOWN;
        break;
    
    case LDAPTYPE_DNWITHSTRING:
        uUmiType = UMI_TYPE_IUNKNOWN;
        break;
    
    default:

        //
        // LDAPTYPE_UNKNOWN  (schemaless server property) will be
        // not be converted.
        //
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;
    } // end of switch.

    RRETURN(hr);
}

//
// Note about functions in this file and the difference between the functions
// in Ldap2var.cxx. In that file, we allocate everything into variants
// and then we put all the variants in a safe array.
// The functions in this file are also different from those in 
// ldapc\ldap2ods.cxx in that each of the actual conversion routines deals 
// with a native data type rather than the UMI_VALUE as a whole (or ADSVALUE
// in the case of ldap2ods.cxx). This is because in UMI_VALUE's each UMI_VALUE
// struct can contain an array in itself, so you do not need multiple
// UMI_VALUE's to represent all values of an attribute.
//

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeLPWSTR
//
// Synopsis:   Converts an ldap string value to a LPWSTR. Note that the
//        output is not a UMI_VALUE but a string.   
//
// Arguments:  Self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pszUmiString to point to the string being copied.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeLPWSTR(
    PLDAPOBJECT pLdapSrcObject,
    LPWSTR *pszUmiString
    )
{
    HRESULT hr = S_OK;
    
    ADsAssert(pszUmiString);

    //
    // We should not have NULL values but it is a good idea to check.
    //
    if (LDAPOBJECT_STRING(pLdapSrcObject)) {
        *pszUmiString = AllocADsStr(LDAPOBJECT_STRING(pLdapSrcObject));
    
        if (!pszUmiString) {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyStrings
//
// Synopsis:   Converts the ldap source objects into an array of strings
//            and assigns the array to the values in the UMI_VALUE *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp       - ptr to UMI_Property we modify the pValue.
//             uCount&         - used to return the number of values.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the string array.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyStrings(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    LPWSTR *pszStrArray = NULL;
    LPWSTR pszTmpString = NULL;

    //
    // Allocate string array to hold all the entries.
    //
    pszStrArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * dwCount);
    
    if (!pszStrArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeLPWSTR(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &pszTmpString
                 );
        if (SUCCEEDED(hr)) {
            pszStrArray[dwCtr] = pszTmpString;
            pszTmpString = NULL;
        }
    }

    BAIL_ON_FAILURE(hr);

    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pszStrArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:

    //
    // Do not think this is really necessary but cannot hurt.
    //
    if (pszTmpString) {
        FreeADsStr(pszTmpString);
    }

    if (pszStrArray) {
        if (dwCtr) {
            //
            // Need to go through the array and free the other strings
            //
            for (; dwCtr > 0; dwCtr --) {
                if (pszStrArray[dwCtr-1]) {
                    FreeADsStr(pszStrArray[dwCtr-1]);
                }
            }
        } // if (dwCtr)

        //
        // Still need to free the array itself.
        //
        FreeADsMem((void*) pszStrArray);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeBool
//
// Synopsis:   Converts an ldap boolean value to a BOOL value
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pfBool points to the returned value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeBool(
    PLDAPOBJECT pLdapSrcObject,
    PBOOL pfBool
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);

    ADsAssert(pfBool);

    if ( _tcsicmp( pszSrc, TEXT("TRUE")) == 0 ) {
        *pfBool = TRUE;
    }
    else if ( _tcsicmp( pszSrc, TEXT("FALSE")) == 0 ) {
        *pfBool = FALSE;
    }
    else
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyBooleans
//
// Synopsis:   Converts the ldap source objects into an array of booleans
//            and assigns the array to the values in the UMI_PROPERTY *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp       - ptr to UMI_Property we modify the pValue.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the newly created array of bools.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyBooleans(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    BOOL *pfBoolArray = NULL;
    BOOL fTempVal;

    //
    // Allocate array of boolean values to hold all the entries.
    //
    pfBoolArray = (BOOL *) AllocADsMem(sizeof(BOOL) * dwCount);
    
    if (!pfBoolArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeBool(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &fTempVal
                 );
        if (SUCCEEDED(hr)) {
            pfBoolArray[dwCtr] = fTempVal;
        }
    }

    BAIL_ON_FAILURE(hr);
    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pfBoolArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:


    if (pfBoolArray) {
        FreeADsMem( (void *) pfBoolArray);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeInteger
//
// Synopsis:   Converts an ldap boolean value to a BOOL value. It appears
//        that if _ttol fails, there is no real way to tell cause 0 is
//        returned in that case. There is no way to distinguish a value
//        0 coming back from ldap and 0 because the conversion failed. 
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLong points to the returned value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeInteger(
    PLDAPOBJECT pLdapSrcObject,
    LONG *pLong
    )
{
    HRESULT hr = S_OK;
    
    ADsAssert(pLong);

    *pLong = _ttol(LDAPOBJECT_STRING(pLdapSrcObject));

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyIntegers
//
// Synopsis:   Converts the ldap source objects into an array of integers
//            and assigns the array to the values in the UMI_PROPERTY *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp        - ptr to UMI_Property we modify the pValue.
//             uCount&         - used to return the number of values.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the newly created array of integers.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyIntegers(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    LONG *pLongArray = NULL;
    LONG lTempVal;

    //
    // Allocate array of boolean values to hold all the entries.
    //
    pLongArray = (LONG *) AllocADsMem(sizeof(LONG) * dwCount);
    
    if (!pLongArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeInteger(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &lTempVal
                 );
        if (SUCCEEDED(hr)) {
            pLongArray[dwCtr] = lTempVal;
        }
    }

    BAIL_ON_FAILURE(hr);
    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pLongArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:


    if (pLongArray) {
        FreeADsMem( (void *) pLongArray);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeOctetString
//
// Synopsis:   Converts an ldap security ber value to an octet string.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pOctetStr points to the returned binary blob value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeOctetString(
    PLDAPOBJECT pLdapSrcObject,
    PUMI_OCTET_STRING pUmiOctetString
    )
{
    DWORD dwLength;

    dwLength = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);

    pUmiOctetString->lpValue = (byte*)AllocADsMem(dwLength);
    pUmiOctetString->uLength = dwLength;

    if (!pUmiOctetString->lpValue) {
        RRETURN(E_OUTOFMEMORY);
    }

    memcpy( 
        pUmiOctetString->lpValue,
        LDAPOBJECT_BERVAL_VAL(pLdapSrcObject),
        dwLength
        );

    RRETURN(S_OK);

}



//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyOctetStrings
//
// Synopsis:   Converts the ldap source objects into an array of octet strings
//            and assigns the array to the values in the UMI_VALUE *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp       - ptr to UMI_Property we modify the pValue.
//             uCount&         - used to return the number of values.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the octet string array.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyOctetStrings(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    PUMI_OCTET_STRING pOctetArray = NULL;

    //
    // Allocate string array to hold all the entries.
    //
    pOctetArray = (PUMI_OCTET_STRING) 
                      AllocADsMem(sizeof(UMI_OCTET_STRING) * dwCount);
    
    if (!pOctetArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeOctetString(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &pOctetArray[dwCtr]
                 );

    }

    BAIL_ON_FAILURE(hr);

    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pOctetArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:

    if (pOctetArray) {
        if (dwCtr) {
            //
            // Need to go through the array and free the other strings
            //
            for (; dwCtr > 0; dwCtr --) {
                if (pOctetArray[dwCtr-1].lpValue) {
                    FreeADsMem(pOctetArray[dwCtr-1].lpValue);
                }
            }
        } // if (dwCtr)

        //
        // Still need to free the array itself.
        //
        FreeADsMem((void*) pOctetArray);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeDNWithBinary
//
// Synopsis:   Converts ldap DNWithBinary data to a UMI_COM_OBJECT with
//          the interface IADsDNWithBinary.
//
// Arguments:  pLdapSrcObject -  Binary security descriptor to convert.
//             pUmiComObject  -  Return value. 
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiComObject has valid data if successful.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeDNWithBinary(
    PLDAPOBJECT pLdapSrcObject,
    PUMI_COM_OBJECT pUmiComObject
    )
{
    HRESULT hr = S_OK;
    VARIANT vVar;
    IADsDNWithBinary *pDNBin = NULL;

    VariantInit(&vVar);

    hr = LdapTypeToVarTypeDNWithBinary(
             pLdapSrcObject,
             &vVar
             );

    if (vVar.vt != VT_DISPATCH) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Now we need to QI for IID_IADsSecurityDescriptor.
    //
    hr = vVar.pdispVal->QueryInterface(
             IID_IADsDNWithBinary,
             (void **) &pDNBin
             );

    BAIL_ON_FAILURE(hr);

    //
    // We need to fill in the details in the com object.
    //
    pUmiComObject->priid = (IID*) AllocADsMem(sizeof(IID));
    if (!pUmiComObject->priid) {
        //
        // Need to free the secdesc as this is a failure case.
        //
        pDNBin->Release();
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pUmiComObject->priid, &(IID_IADsDNWithBinary), sizeof(IID));

    pUmiComObject->pInterface = (void *) pDNBin;

error:

    //
    // Need to clear even in success case.
    //
    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeDNWithString
//
// Synopsis:   Converts ldap DNWithString data to a UMI_COM_OBJECT with
//          the interface IADsDNWithString.
//
// Arguments:  pLdapSrcObject -  Binary security descriptor to convert.
//             pUmiComObject  -  Return value. 
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiComObject has valid data if successful.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeDNWithString(
    PLDAPOBJECT pLdapSrcObject,
    PUMI_COM_OBJECT pUmiComObject
    )
{
    HRESULT hr = S_OK;
    VARIANT vVar;
    IADsDNWithString *pDNStr = NULL;

    VariantInit(&vVar);

    hr = LdapTypeToVarTypeDNWithString(
             pLdapSrcObject,
             &vVar
             );

    if (vVar.vt != VT_DISPATCH) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Now we need to QI for IID_IADsSecurityDescriptor.
    //
    hr = vVar.pdispVal->QueryInterface(
             IID_IADsDNWithString,
             (void **) &pDNStr
             );

    BAIL_ON_FAILURE(hr);

    //
    // We need to fill in the details in the com object.
    //
    pUmiComObject->priid = (IID*) AllocADsMem(sizeof(IID));
    if (!pUmiComObject->priid) {
        //
        // Need to free the secdesc as this is a failure case.
        //
        pDNStr->Release();
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pUmiComObject->priid, &(IID_IADsDNWithString), sizeof(IID));

    pUmiComObject->pInterface = (void *) pDNStr;

error:

    //
    // Need to clear even in success case.
    //
    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeSecurityDescriptor
//
// Synopsis:   Converts an ldap security descriptor to an 
//         IADsSecurityDescriptor Com object. Note that this routine assumes
//         that we are dealing only with NT style SD's and that specifically
//         we do not have the old SS type SD's.
//
// Arguments:  pLdapSrcObject -  Binary security descriptor to convert.
//             pCreds         -  Pointer to credentials (for conversion).
//             pszServerName  -  Name of server we got this blob from.
//             pUmiComObject  -  Return value. 
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiComObject has valid data if succesful.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeSecurityDescriptor(
    PLDAPOBJECT pLdapSrcObject,
    CCredentials *pCreds,
    LPWSTR pszServerName,
    PUMI_COM_OBJECT pUmiComObject
    )
{
    HRESULT hr = S_OK;
    CCredentials creds;
    VARIANT vVar;
    IADsSecurityDescriptor *pSecDesc = NULL;

    VariantInit(&vVar);

    //
    // Update the credentials object with value passed in if applicable.
    //
    if (pCreds) {
        creds = *pCreds;
    }

    hr = ConvertSecDescriptorToVariant(
             pszServerName,
             creds,
             LDAPOBJECT_BERVAL_VAL(pLdapSrcObject),
             &vVar,
             TRUE // fNTDS type flag
             );
    BAIL_ON_FAILURE(hr);

    if (vVar.vt != VT_DISPATCH) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Now we need to QI for IID_IADsSecurityDescriptor.
    //
    hr = vVar.pdispVal->QueryInterface(
             IID_IADsSecurityDescriptor,
             (void **) &pSecDesc
             );

    BAIL_ON_FAILURE(hr);

    //
    // We need to fill in the details in the com object.
    //
    pUmiComObject->priid = (IID*) AllocADsMem(sizeof(IID));
    if (!pUmiComObject->priid) {
        //
        // Need to free the secdesc as this is a failure case.
        //
        pSecDesc->Release();
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pUmiComObject->priid, &(IID_IADsSecurityDescriptor), sizeof(IID));

    pUmiComObject->pInterface = (void *) pSecDesc;

error:

    //
    // Need to clear even in success case.
    //
    VariantClear(&vVar);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeComObjects
//
// Synopsis:   Converts the ldap data to the corresponding com objects.
//          This routine calls the individual conversion routines,
//          converting one object at a time and packages the result into
//          the output values.
//
// Arguments:  pLdapSrcObjects  -  raw ldap data that needs to be converted.
//             pCreds           -  Credentials used for SD's can be NULL.
//             pszServerName    -  Server Name again only for SD's NULL legal.
//             requiredIID      -  Tells us what type of COM_OBJECT to return.
//             pUmiProp         -  Return value.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the COM_OBJECT array.
//
//----------------------------------------------------------------------------
LdapTypeToUmiTypeCopyComObjects(
    LDAPOBJECTARRAY pLdapSrcObjects,
    CCredentials *pCreds,
    LPWSTR pszServerName,
    IID requiredIID,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    PUMI_COM_OBJECT pComObjectArray = NULL;

    //
    // Allocate string array to hold all the entries.
    //
    pComObjectArray = (PUMI_COM_OBJECT) 
                      AllocADsMem(sizeof(UMI_COM_OBJECT) * dwCount);
    
    if (!pComObjectArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Call the appropriate conversion routine based on the
        // IID that we need to return.
        //
        if (requiredIID == IID_IADsSecurityDescriptor) {
            //
            // Copy over security descriptor.
            //
            hr = LdapTypeToUmiTypeSecurityDescriptor(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     pCreds,
                     pszServerName,
                     &pComObjectArray[dwCtr]
                     );
        } 
        else if (requiredIID == IID_IADsDNWithBinary) {
            //
            // Copy over the Dn With Binary object.
            //
            hr = LdapTypeToUmiTypeDNWithBinary(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     &pComObjectArray[dwCtr]
                     );
        
        }
        else if (requiredIID == IID_IADsDNWithString) {
            //
            // Copy over the Dn With String object.
            //
            hr = LdapTypeToUmiTypeDNWithString(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     &pComObjectArray[dwCtr]
                     );
        } 
        else {
            //
            // Got to be bad data.
            //
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE)
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pComObjectArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:

    if (pComObjectArray) {
        if (dwCtr) {
            //
            // Need to go through the array and free the other strings
            //
            for (; dwCtr > 0; dwCtr --) {
                if (pComObjectArray[dwCtr-1].pInterface) {
                    //
                    // Releasing the object will delete it if appropriate.
                    //
                    ((IUnknown*)
                     pComObjectArray[dwCtr-1].pInterface)->Release();
                }

                if (pComObjectArray[dwCtr-1].priid) {
                    FreeADsMem((void *)pComObjectArray[dwCtr-1].priid);
                }
            }
        } // if (dwCtr)

        //
        // Still need to free the array itself.
        //
        FreeADsMem((void*) pComObjectArray);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeI8
//
// Synopsis:   Converts an ldap security large integer to an I8.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pInt8 points to the returned large integer value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeI8(
    PLDAPOBJECT pLdapSrcObject,
    __int64 *pInt64
    )
{
    ADsAssert(pInt64);

    *pInt64 = _ttoi64(LDAPOBJECT_STRING(pLdapSrcObject));

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopyLargeIntegers
//
// Synopsis:   Converts the ldap source objects into an array of int64's
//            and assigns the array to the values in the UMI_PROPERTY *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp        - ptr to UMI_Property we modify the pValue.
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the newly created array of int64's.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyLargeIntegers(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    __int64 *pInt64Array = NULL;
    __int64 int64Val;

    //
    // Allocate array of boolean values to hold all the entries.
    //
    pInt64Array = (__int64 *) AllocADsMem(sizeof(__int64) * dwCount);
    
    if (!pInt64Array) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each of the elements in the ldap array
        //
        hr = LdapTypeToUmiTypeI8(
                 pLdapSrcObjects.pLdapObjects + dwCtr,
                 &int64Val
                 );

        if (SUCCEEDED(hr)) {
            pInt64Array[dwCtr] = int64Val;
        }
    }

    BAIL_ON_FAILURE(hr);
    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pInt64Array;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:


    if (pInt64Array) {
        FreeADsMem( (void *) pInt64Array);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeTime
//
// Synopsis:   Converts an ldap time value to a SystemTime value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pSysTime points to the returned time value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeUTCTimeToUmiTypeTime(
    PLDAPOBJECT pLdapSrcObject,
    SYSTEMTIME *pSystemTime
    )
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;

    ADsAssert(pSystemTime);

    //
    // This converts to a SYSTEMTIME.
    //
    hr = LdapTypeToAdsTypeUTCTime(
             pLdapSrcObject,
             &AdsValue
             );
    BAIL_ON_FAILURE(hr);

    *pSystemTime = AdsValue.UTCTime;

error:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeGeneralizedTimeToUmiTypeTime
//
// Synopsis:   Converts an ldap time value to a SystemTime value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pSysTime points to the returned time value.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeGeneralizedTimeToUmiTypeTime(
    PLDAPOBJECT pLdapSrcObject,
    SYSTEMTIME *pSystemTime
    )
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;

    //
    // This converts to a SYSTEMTIME.
    //
    hr = LdapTypeToAdsTypeGeneralizedTime(
             pLdapSrcObject,
             &AdsValue
             );
    BAIL_ON_FAILURE(hr);

    *pSystemTime = AdsValue.UTCTime;

error:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeTimeObjects
//
// Synopsis:   Converts the ldap source objects into an array of systemtimes
//            and assigns the array to the values in the UMI_PROPERTY *.
//
// Arguments:  pLdapSrcObjects - array of ldap values.
//             pUmiProp        - ptr to UMI_Property we modify the pValue.
//             dwSyntaxId      - tells us what type of time this is (rather
//                              write the same code again for UTC and Gen).
// 
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pUmiProp->pValue points to the new array of systimes.
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopyTimeObjects(
    LDAPOBJECTARRAY pLdapSrcObjects,
    PUMI_PROPERTY pUmiProp,
    DWORD dwSyntaxId
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr = 0;
    SYSTEMTIME *pSysTimeArray = NULL;
    SYSTEMTIME sysTimeVal;

    //
    // Allocate array of boolean values to hold all the entries.
    //
    pSysTimeArray = (SYSTEMTIME *) AllocADsMem(sizeof(SYSTEMTIME) * dwCount);
    
    if (!pSysTimeArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; (dwCtr < dwCount && SUCCEEDED(hr)); dwCtr++) {
        //
        // Go through and convert each element appropriately.
        //
        switch (dwSyntaxId) {

        case LDAPTYPE_UTCTIME :
            hr = LdapTypeGeneralizedTimeToUmiTypeTime(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     &sysTimeVal
                     );
            break;

        case LDAPTYPE_GENERALIZEDTIME :
            hr = LdapTypeGeneralizedTimeToUmiTypeTime(
                     pLdapSrcObjects.pLdapObjects + dwCtr,
                     &sysTimeVal
                     );
            break;

        default:
            hr = E_ADS_CANT_CONVERT_DATATYPE;
        }

        BAIL_ON_FAILURE(hr);

        if (SUCCEEDED(hr)) {
            pSysTimeArray[dwCtr] = sysTimeVal;
        }
    }

    BAIL_ON_FAILURE(hr);
    //
    // Have the valid string array, need to set the data into UMI_VALUE.
    //
    pUmiProp->pUmiValue = (UMI_VALUE *)(void *)pSysTimeArray;
    pUmiProp->uCount = dwCount;

    RRETURN(hr);
error:


    if (pSysTimeArray) {
        FreeADsMem( (void *) pSysTimeArray);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   LdapTypeToUmiTypeCopy.
//
// Synopsis:   Helper routine to convert ldap values to the required UMI
//            data type. 
//
// Arguments:  pLdapSrcObjects   -  The source objects to convert.
//             pProp             -  Return value.
//             dwStatus          -  Indicates status of property in cache.
//             dwLdapSyntaxId    -  Ldap syntax of the data.
//             pCreds            -  Ptr to credentials to use for conversion.
//             pszServerName     -  Name of the server to use for conversion.
//             uUmiFlags         -  UMI flag corresponding to dwStatus.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pProp and dwLdapSyntaxId
//
//----------------------------------------------------------------------------
HRESULT
LdapTypeToUmiTypeCopy(
    LDAPOBJECTARRAY pLdapSrcObjects,
    UMI_PROPERTY_VALUES **pProp,
    DWORD dwStatus,
    DWORD dwLdapSyntaxId,
    CCredentials *pCreds, // needed for sd's
    LPWSTR pszServerName, // needed for sd's
    ULONG uUmiFlags
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = pLdapSrcObjects.dwCount, dwCtr;
    UMI_PROPERTY *pProperty = NULL;
    LPVOID lpVoid = NULL;

    //
    // Allocate the UMI_PROPERTY_VALUES needed, only one element for now.
    //
    *pProp = (UMI_PROPERTY_VALUES*)AllocADsMem(sizeof(UMI_PROPERTY_VALUES));

    if (!*pProp) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // We are only going to have one value.
    //
    (*pProp)->uCount = 1;
    
    //
    // Now allocate the actual property object.
    //
    pProperty = (UMI_PROPERTY*) AllocADsMem(sizeof(UMI_PROPERTY));

    if (!pProperty) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    (*pProp)->pPropArray = pProperty;

    //
    // If the operation is clear/delete, then we do not have anything
    // to return. There is one Umi object with no values in it and 
    // possibly no datatype.
    //
    if (dwStatus == PROPERTY_DELETE) {
        pProperty->pUmiValue = NULL;
        pProperty->uType = 0;
    } 
    else {
    
            
        switch (dwLdapSyntaxId) {
    
        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_PRINTABLESTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING:
        case LDAPTYPE_DN:
        case LDAPTYPE_NUMERICSTRING:
        case LDAPTYPE_IA5STRING:
        case LDAPTYPE_CASEIGNORESTRING:
        case LDAPTYPE_CASEEXACTSTRING:
    //    case LDAPTYPE_CASEIGNOREIA5STRING:
        case LDAPTYPE_OID:
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:
    
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER:
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_PRESENTATIONADDRESS:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_DSAQUALITYSYNTAX:
        case LDAPTYPE_DATAQUALITYSYNTAX:
        case LDAPTYPE_MAILPREFERENCE:
        case LDAPTYPE_OTHERMAILBOX:
        case LDAPTYPE_ACCESSPOINTDN:
        case LDAPTYPE_ORNAME:
        case LDAPTYPE_ORADDRESS:
    
            hr = LdapTypeToUmiTypeCopyStrings(
                     pLdapSrcObjects,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_LPWSTR;
            pProperty->pszPropertyName = NULL;
    
            break;
    
        case LDAPTYPE_BOOLEAN:
    
            hr = LdapTypeToUmiTypeCopyBooleans(
                     pLdapSrcObjects,
                     pProperty
                     );
    
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_BOOL;
            pProperty->pszPropertyName = NULL;
    
            break;
    
        case LDAPTYPE_INTEGER:
    
            hr = LdapTypeToUmiTypeCopyIntegers(
                     pLdapSrcObjects,
                     pProperty
                     );
    
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_I4;
            pProperty->pszPropertyName = NULL;
    
            break;
    
    
        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
    
            hr = LdapTypeToUmiTypeCopyOctetStrings(
                     pLdapSrcObjects,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_OCTETSTRING;
            pProperty->pszPropertyName = NULL;
    
            break;
    
    
        case LDAPTYPE_GENERALIZEDTIME:
            
            hr = LdapTypeToUmiTypeCopyTimeObjects(
                     pLdapSrcObjects,
                     pProperty,
                     LDAPTYPE_GENERALIZEDTIME
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_SYSTEMTIME;
            pProperty->pszPropertyName = NULL;
    
            break;
    
        case LDAPTYPE_UTCTIME:
    
            hr = LdapTypeToUmiTypeCopyTimeObjects(
                     pLdapSrcObjects,
                     pProperty,
                     LDAPTYPE_UTCTIME
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_SYSTEMTIME;
            pProperty->pszPropertyName = NULL;
            break;
    
    
        case LDAPTYPE_SECURITY_DESCRIPTOR:
    
            hr = LdapTypeToUmiTypeCopyComObjects(
                     pLdapSrcObjects,
                     pCreds,
                     pszServerName,
                     IID_IADsSecurityDescriptor,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_IUNKNOWN;
            pProperty->pszPropertyName = NULL;
    
            break;
    
        case LDAPTYPE_INTEGER8:
    
            hr = LdapTypeToUmiTypeCopyLargeIntegers(
                     pLdapSrcObjects,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);
    
            pProperty->uType = UMI_TYPE_I8;
            pProperty->pszPropertyName = NULL;
    
            break;
    /*
    #if 0
            case LDAPTYPE_CASEEXACTLIST:
            case LDAPTYPE_CASEIGNORELIST:
    #endif
    */
    
        case LDAPTYPE_DNWITHBINARY:

            hr = LdapTypeToUmiTypeCopyComObjects(
                     pLdapSrcObjects,
                     pCreds,
                     pszServerName,
                     IID_IADsDNWithBinary,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);

            pProperty->uType = UMI_TYPE_IUNKNOWN;
            pProperty->pszPropertyName = NULL;
            break;
    
        case LDAPTYPE_DNWITHSTRING:

            hr = LdapTypeToUmiTypeCopyComObjects(
                     pLdapSrcObjects,
                     pCreds,
                     pszServerName,
                     IID_IADsDNWithString,
                     pProperty
                     );
            BAIL_ON_FAILURE(hr);

            pProperty->uType = UMI_TYPE_IUNKNOWN;
            pProperty->pszPropertyName = NULL;
            break;
    
        default:
    
            //
            // LDAPTYPE_UNKNOWN  (schemaless server property) will be
            // not be converted.
            //
    
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;
        } // end of case.
    } // end of if property != DELETE.
    
    //
    // Need to set the property type on the operation if we get here.
    //
    pProperty->uOperationType = uUmiFlags;

    RRETURN(hr);

error:

    //
    // Free the Property array as needed.
    //
    // FreeUmiPropertyArray();

    // DO NOT FREE pProperty it will be handled byt FreeUmiPropertyArray
    // Write code to free lpVoid as it will have valid data in failure cases.

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\name.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cNameTranslate.cxx
//
//  Contents:  NameTranslate object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------


#include "ldap.hxx"
#pragma hdrstop

#define ABORT_ON_ERROR(err)                                         \
    if ( 0 != (err) )                                               \
    {                                                               \
        hr = E_FAIL;                                                \
        goto error;                                                 \
    }


//  Class CNameTranslate
DEFINE_IDispatch_Implementation(CNameTranslate)

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::CNameTranslate
//
// Synopsis:    Constructor
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CNameTranslate::CNameTranslate():
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNameTranslate);
    _hDS = NULL;
    _rgszGuid = NULL;
    _rgDomainHandle = NULL;
    _cGuid = 0;
    _bChaseReferral = TRUE;
    _bAuthSet = FALSE;
    _pDomainHandle = NULL;
    
    _pDomainHandle = new CDomainToHandle;
    if(!_pDomainHandle)
    {
        RaiseException(STATUS_INSUFFICIENT_MEM, 0, 0, 0);
    }
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::CreateNameTranslate
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
HRESULT
CNameTranslate::CreateNameTranslate(
    REFIID riid,
    void **ppvObj
    )
{
    CNameTranslate FAR * pNameTranslate = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNameTranslateObject(&pNameTranslate);
    BAIL_ON_FAILURE(hr);

    hr = pNameTranslate->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNameTranslate->Release();
    RRETURN(hr);

error:
    delete pNameTranslate;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    CNameTranslate::~CNameTranslate
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CNameTranslate::~CNameTranslate( )
{
    DWORD i;
    if (_hDS) {
        DsUnBindWrapper(&_hDS);
        _hDS = NULL;
    }
    delete _pDispMgr;
    if (_rgszGuid) {
        for (i=0;i<_cGuid;i++) {
            FreeADsMem(_rgszGuid[i]);
        }
        FreeADsMem(_rgszGuid);
    }
    if (_rgDomainHandle) {
        FreeADsMem(_rgDomainHandle);
    }
    if (_bAuthSet) {
        DsFreePasswordCredentialsWrapper(_AuthIdentity);
        _bAuthSet = FALSE;
    }
    if (_pDomainHandle) {
        delete _pDomainHandle;
    }
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::QueryInterface
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        return E_POINTER;
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsNameTranslate FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsNameTranslate))
    {
        *ppv = (IADsNameTranslate FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsNameTranslate FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT MapCrackErrToHR(DWORD dwErr)
{
    HRESULT hr = S_OK;

    switch (dwErr) {
        case DS_NAME_NO_ERROR:
            hr = S_OK;
            break;

        case DS_NAME_ERROR_RESOLVING:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_RESOLVING);
            break;

        case DS_NAME_ERROR_NOT_FOUND:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_FOUND);
            break;

        case DS_NAME_ERROR_NOT_UNIQUE:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_UNIQUE);
            break;

        case DS_NAME_ERROR_NO_MAPPING:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NO_MAPPING);
            break;

        case DS_NAME_ERROR_DOMAIN_ONLY:
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_DOMAIN_ONLY);
            break;

        case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
            hr = HRESULT_FROM_WIN32(
                     ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
                     );
            break;

        case DS_NAME_ERROR_TRUST_REFERRAL:
            
            hr = HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_TRUST_REFERRAL);
            break;

        default:
            hr = E_FAIL;
    }
    return hr;
}

HRESULT MapAdsToCrack(DWORD dwType, DS_NAME_FORMAT *pdwReturn)
{
    HRESULT hr = S_OK;
    switch (dwType) {
        case ADS_NAME_TYPE_1779:
            *pdwReturn = DS_FQDN_1779_NAME;
            break;
        case ADS_NAME_TYPE_CANONICAL:
            *pdwReturn = DS_CANONICAL_NAME;
            break;
        case ADS_NAME_TYPE_NT4:
            *pdwReturn = DS_NT4_ACCOUNT_NAME;
            break;
        case ADS_NAME_TYPE_DISPLAY:
            *pdwReturn = DS_DISPLAY_NAME;
            break;
        case ADS_NAME_TYPE_DOMAIN_SIMPLE:
            *pdwReturn = DS_DOMAIN_SIMPLE_NAME;
            break;
        case ADS_NAME_TYPE_ENTERPRISE_SIMPLE:
            *pdwReturn = DS_ENTERPRISE_SIMPLE_NAME;
            break;
        case ADS_NAME_TYPE_GUID:
            *pdwReturn = DS_UNIQUE_ID_NAME;
            break;
        case ADS_NAME_TYPE_USER_PRINCIPAL_NAME:
            *pdwReturn = DS_USER_PRINCIPAL_NAME;
            break;
        case ADS_NAME_TYPE_CANONICAL_EX:
            *pdwReturn = DS_CANONICAL_NAME_EX;
            break;
        case ADS_NAME_TYPE_SERVICE_PRINCIPAL_NAME:
            *pdwReturn = DS_SERVICE_PRINCIPAL_NAME;
            break;
        case ADS_NAME_TYPE_UNKNOWN:
            *pdwReturn = DS_UNKNOWN_NAME;
            break;
        case ADS_NAME_TYPE_SID_OR_SID_HISTORY_NAME:
            *pdwReturn = DS_SID_OR_SID_HISTORY_NAME;
            break;

        default:
            hr = E_ADS_BAD_PARAMETER;
            break;
    }
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::AllocateNameTranslateObject
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
HRESULT
CNameTranslate::AllocateNameTranslateObject(
    CNameTranslate ** ppNameTranslate
    )
{
    CNameTranslate FAR * pNameTranslate = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    __try
    {
        pNameTranslate = new CNameTranslate();
    }
    __except (GetExceptionCode() == STATUS_INSUFFICIENT_MEM) 
    {
        if(pNameTranslate)
        {
            delete pNameTranslate;            
        }

        return E_OUTOFMEMORY;
    }
    
    if (pNameTranslate == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsNameTranslate,
                (IADsNameTranslate *)pNameTranslate,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pNameTranslate->_pDispMgr = pDispMgr;
    *ppNameTranslate = pNameTranslate;

    RRETURN(hr);

error:

    delete pNameTranslate;
    delete  pDispMgr;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    CNameTranslate::Set
//
// Synopsis:    Sets the values of the NameTranslate object
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::Set(long dwSetType,BSTR bstrADsPath)
{
    DWORD           dwErr = 0;
    DS_NAME_RESULTW *pResult = NULL;
    HANDLE          hDS = NULL;
    HRESULT         hr = E_FAIL;
    DS_NAME_FORMAT  dsFormat;
    DWORD i;
    BOOL fDoNotFree = FALSE;

    //
    // fDoNotFree is used to determine if we need to free
    // the dsresul pResult or not. There are some cases when
    // the call can fail but the ptr modified, and in those
    // cases it should not be freed.
    //
    if (!bstrADsPath) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    if (!_hDS) {
        hr = Init(ADS_NAME_INITTYPE_GC,NULL);
        BAIL_ON_FAILURE(hr);
    }

    if (_rgDomainHandle) {
        FreeADsMem(_rgDomainHandle);
        _rgDomainHandle = NULL;
    }


    hr = MapAdsToCrack(dwSetType,
                       &dsFormat);
    BAIL_ON_FAILURE(hr);

    dwErr = DsCrackNamesWrapper(
                    _hDS,
                    DS_NAME_NO_FLAGS,   // flags
                    dsFormat,           // format in
                    DS_UNIQUE_ID_NAME,  // format out
                    1,                  // name count
                    &bstrADsPath,
                    &pResult);
    if (dwErr) {
        fDoNotFree = TRUE;
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    if (_bChaseReferral && pResult->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY) {
        if (!pResult->rItems[0].pDomain) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
        //
        // Chasing Referral
        //

        hr = _pDomainHandle->Find(bstrADsPath,
                                  &hDS);
        if (hr == E_FAIL ) {

            if (!_bAuthSet) {
                dwErr = DsBindWrapper(
                            NULL,
                            pResult->rItems[0].pDomain,
                            &hDS);
            }
            else {
                dwErr = DsBindWithCredWrapper(
                            NULL,
                            pResult->rItems[0].pDomain,
                            _AuthIdentity,
                            &hDS);
            }
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
            hr = _pDomainHandle->AddElement(bstrADsPath, hDS);
            BAIL_ON_FAILURE(hr);
        }

        dwErr = DsCrackNamesWrapper(
                        hDS,
                        DS_NAME_NO_FLAGS,   // flags
                        dsFormat,           // format in
                        DS_UNIQUE_ID_NAME,  // format out
                        1,                  // name count
                        &bstrADsPath,
                        &pResult);
        if (dwErr) {
            fDoNotFree = FALSE;
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
        }

        if (!_rgDomainHandle) {
            _rgDomainHandle = (HANDLE*)AllocADsMem(sizeof(HANDLE));
            if (!_rgDomainHandle) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        _rgDomainHandle [0] = hDS;

    }

    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    //
    // All below will essentially return E_FAIL on failure.
    //
    ABORT_ON_ERROR(1 != pResult->cItems);
    ABORT_ON_ERROR(NULL == pResult->rItems);
    ABORT_ON_ERROR(pResult->rItems[0].status);
    ABORT_ON_ERROR(NULL == (pResult->rItems[0].pName));
    ABORT_ON_ERROR(0 == wcslen(pResult->rItems[0].pName));
    ABORT_ON_ERROR(NULL == pResult->rItems[0].pDomain);

    if (_rgszGuid) {
        for (i=0;i<_cGuid;i++) {
            FreeADsMem(_rgszGuid[i]);
        }
        FreeADsMem(_rgszGuid);
        _rgszGuid = NULL;
    }

    _rgszGuid = (LPWSTR*)AllocADsMem(sizeof(LPWSTR));
    if (!_rgszGuid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    _rgszGuid[0] = AllocADsStr(pResult->rItems[0].pName);
    if (!_rgszGuid[0]) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    _cGuid = 1;

    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }

    if (pResult) {
        DsFreeNameResultWrapper(pResult);
    }
    return hr;

error:
    if (hDS) {
        DsUnBindWrapper(&hDS);
        hDS = NULL;
    }
    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }
    if (pResult && !fDoNotFree) {
        DsFreeNameResultWrapper(pResult);
    }

    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::Init
//
// Synopsis:    Initialize the object
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::Init(long lnType,BSTR bstrADsPath)
{
    DWORD           dwErr;
    HANDLE          hDS;
    HRESULT         hr = E_FAIL;

    if (_hDS) {
        DsUnBindWrapper(&_hDS);
        _hDS = NULL;
    }

    _pDomainHandle->Init();

    switch (lnType) {
        case ADS_NAME_INITTYPE_SERVER:
            if (!bstrADsPath) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            dwErr = DsBindWrapper(
                        bstrADsPath,
                        NULL,
                        &hDS);
            break;

        case ADS_NAME_INITTYPE_DOMAIN:
            if (!bstrADsPath) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            dwErr = DsBindWrapper(
                        NULL,
                        bstrADsPath,
                        &hDS);
            break;

        case ADS_NAME_INITTYPE_GC:
            dwErr = DsBindWrapper(
                        NULL,
                        NULL,
                        &hDS);
            break;

        default:
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
            break;
    }
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    _hDS = hDS;
    hr = S_OK;
error:
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::InitEx
//
// Synopsis:    Initialize the object with Credentials
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    14-2-98   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::InitEx(long lnType,BSTR bstrADsPath,BSTR bstrUserID, BSTR bstrDomain, BSTR bstrPassword)
{
    DWORD           dwErr;
    HANDLE          hDS;
    HRESULT         hr = E_FAIL;

    if (_hDS) {
        DsUnBindWrapper(&_hDS);
        _hDS = NULL;
    }

    hr = _pDomainHandle->Init();

    BAIL_ON_FAILURE(hr);

    if (_bAuthSet) {
        DsFreePasswordCredentialsWrapper(_AuthIdentity);
        _bAuthSet = FALSE;
    }

    dwErr = DsMakePasswordCredentialsWrapper(
                bstrUserID,
                bstrDomain,
                bstrPassword,
                &_AuthIdentity
                );
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    _bAuthSet = TRUE;

    switch (lnType) {
        case ADS_NAME_INITTYPE_SERVER:
            if (!bstrADsPath) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            dwErr = DsBindWithCredWrapper(
                        bstrADsPath,
                        NULL,
                        _AuthIdentity,
                        &hDS);
            break;

        case ADS_NAME_INITTYPE_DOMAIN:
            if (!bstrADsPath) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            dwErr = DsBindWithCredWrapper(
                        NULL,
                        bstrADsPath,
                        _AuthIdentity,
                        &hDS);
            break;

        case ADS_NAME_INITTYPE_GC:
            dwErr = DsBindWithCredWrapper(
                        NULL,
                        NULL,
                        _AuthIdentity,
                        &hDS);
            break;

        default:
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
            break;
    }
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    _hDS = hDS;
    hr = S_OK;
    return hr;
error:
    if (_bAuthSet) {
        DsFreePasswordCredentialsWrapper(_AuthIdentity);
        _bAuthSet = FALSE;
    }
    return hr;
}


STDMETHODIMP
CNameTranslate::put_ChaseReferral(THIS_ long lnChase)
{
    _bChaseReferral = (BOOLEAN)lnChase;
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::Get
//
// Synopsis:    Retrive the pathname as different formats
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::Get(THIS_ long dwFormatType, BSTR FAR *pbstrName)
{
    DS_NAME_RESULTW *pResult = NULL;
    HRESULT         hr = E_FAIL;
    DWORD           dwErr = 0;
    HANDLE          hDS;
    DS_NAME_FORMAT  dsFormat;
    BOOL fDoNotFree = FALSE;

    //
    // Look at ::Set for more info on fDoNotFree
    //

    if (!_hDS) {
        hr = Init(ADS_NAME_INITTYPE_GC,NULL);
        BAIL_ON_FAILURE(hr);
    }

    if (!pbstrName) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    if (dwFormatType == ADS_NAME_TYPE_UNKNOWN) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    if ((_cGuid) != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = MapAdsToCrack(dwFormatType,
                       &dsFormat);
    BAIL_ON_FAILURE(hr);

    if (_bChaseReferral && _rgDomainHandle && _rgDomainHandle[0]) {
        dwErr = DsCrackNamesWrapper(
                        _rgDomainHandle[0],
                        DS_NAME_NO_FLAGS,   // flags
                        DS_UNIQUE_ID_NAME,  // format in
                        dsFormat,           // format out
                        _cGuid,             // name count
                        _rgszGuid,
                        &pResult);
    }
    else {
        dwErr = DsCrackNamesWrapper(
                        _hDS,
                        DS_NAME_NO_FLAGS,   // flags
                        DS_UNIQUE_ID_NAME,  // format in
                        dsFormat,           // format out
                        _cGuid,             // name count
                        _rgszGuid,
                        &pResult);
    }

    if (dwErr) {
        fDoNotFree = TRUE;
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    ABORT_ON_ERROR(1 != pResult->cItems);
    ABORT_ON_ERROR(NULL == pResult->rItems);
    ABORT_ON_ERROR(pResult->rItems[0].status);
    ABORT_ON_ERROR(NULL == (pResult->rItems[0].pName));
    ABORT_ON_ERROR(0 == wcslen(pResult->rItems[0].pName));
    ABORT_ON_ERROR(NULL == pResult->rItems[0].pDomain);
    hr = ADsAllocString(pResult->rItems[0].pName,
                        pbstrName);
error:
    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }
    if (pResult && !fDoNotFree) {
        DsFreeNameResultWrapper(pResult);
    }
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::GetEx
//
// Synopsis:    Retrive the pathname as different formats
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::GetEx(THIS_ long dwFormatType, VARIANT FAR *pvarstrName)
{
    long i = 0;
    DWORD           dwErr = 0;
    DS_NAME_RESULTW *pResult = NULL;
    HANDLE          hDS;
    HRESULT         hr = E_FAIL;
    DS_NAME_FORMAT dsFormat;
    LPWSTR szGuid = (LPWSTR)_szGuid;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BOOL fDoNotFree = FALSE;
    //
    // Look at ::Set for info on fDoNotFree
    //

    if (!_hDS) {
        hr = Init(ADS_NAME_INITTYPE_GC,NULL);
        BAIL_ON_FAILURE(hr);
    }

    if (!pvarstrName) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    if (dwFormatType == ADS_NAME_TYPE_UNKNOWN) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    hr = MapAdsToCrack(dwFormatType,
                       &dsFormat);
    BAIL_ON_FAILURE(hr);

    dwErr = DsCrackNamesWrapper(
                    _hDS,
                    DS_NAME_NO_FLAGS,   // flags
                    DS_UNIQUE_ID_NAME,  // format in
                    dsFormat,           // format out
                    _cGuid,                  // name count
                    _rgszGuid,
                    &pResult);

    if (dwErr) {
        fDoNotFree = TRUE;
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    ABORT_ON_ERROR(NULL == pResult->rItems);
    ABORT_ON_ERROR(pResult->rItems[0].status);
    ABORT_ON_ERROR(NULL == (pResult->rItems[0].pName));
    ABORT_ON_ERROR(0 == wcslen(pResult->rItems[0].pName));
    ABORT_ON_ERROR(NULL == pResult->rItems[0].pDomain);

    VariantInit( pvarstrName );

    aBound.lLbound = 0;
    aBound.cElements = pResult->cItems;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) pResult->cItems; i++ )
    {
        VARIANT v;

        VariantInit(&v);

        hr = ADsAllocString(
                 pResult->rItems[i].pName,
                 &(v.bstrVal)
                 );
        BAIL_ON_FAILURE(hr);

        v.vt = VT_BSTR;

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pvarstrName) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarstrName) = aList;

    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
        BAIL_ON_FAILURE(hr);
    }
    if (pResult) {
        DsFreeNameResultWrapper(pResult);
    }

    RRETURN(S_OK);

error:
    if ((dwErr == 0) && (pResult) && (pResult->rItems[0].status != 0)) {
        hr = MapCrackErrToHR(pResult->rItems[0].status);
    }
    if (pResult && !fDoNotFree) {
        DsFreeNameResultWrapper(pResult);
    }
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    return hr;
}

HRESULT
ConvertSafeArrayToBstrArray(
    VARIANT *pvarSafeArray,
    BSTR **ppVarArray,
    DWORD *pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    BSTR * pVarArray = NULL;
    SAFEARRAY * pArray = NULL;

    *pdwNumVariants = 0;
    *ppVarArray  = 0;

    if(!((V_VT(pvarSafeArray) & VT_BSTR) && V_ISARRAY(pvarSafeArray)))
        return(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(pvarSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(pvarSafeArray));
    else
        pArray = V_ARRAY(pvarSafeArray);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        return(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    pVarArray = (BSTR*)AllocADsMem(
                                sizeof(BSTR)*dwNumVariants
                                );
    if (!pVarArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                (pVarArray + i)
                                );
        if (FAILED(hr)) {
                continue;
        }
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    return(hr);
}

//+---------------------------------------------------------------------------
// Function:    CNameTranslate::SetEx
//
// Synopsis:    Set multiple objects names
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    15-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslate::SetEx(THIS_ long dwSetType, VARIANT varstrName)
{
    DWORD           dwErr = 0;
    DS_NAME_RESULTW *pResult = NULL;
    HANDLE          hDS;
    HRESULT         hr = E_FAIL;
    DS_NAME_FORMAT  dsFormat;
    VARIANT *vVarArray = NULL;
    PWSTR *ppszStrArray = NULL;
    DWORD dwNum,i;
    BOOL fDoNotFree = FALSE;
    int iFailureIndex = -1;
    //
    // Look at ::Set for more info on fDoNotFree
    //

    if (!_hDS) {
        hr = Init(ADS_NAME_INITTYPE_GC,NULL);
        BAIL_ON_FAILURE(hr);
    }

    hr = MapAdsToCrack(dwSetType,
                       &dsFormat);
    BAIL_ON_FAILURE(hr);

    hr = ConvertSafeArrayToVariantArray(
             varstrName,
             &vVarArray,
             &dwNum
             );
    // returns E_FAIL if varstrname is invalid
    if (hr == E_FAIL)
        hr = E_ADS_BAD_PARAMETER;
             
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantArrayToLDAPStringArray(
             vVarArray,
             &ppszStrArray,
             dwNum
             );
    BAIL_ON_FAILURE(hr);

    dwErr = DsCrackNamesWrapper(
                    _hDS,
                    DS_NAME_NO_FLAGS,   // flags
                    dsFormat,           // format in
                    DS_UNIQUE_ID_NAME,  // format out
                    dwNum,              // name count
                    ppszStrArray,
                    &pResult
                    );

    if (dwErr) {
        fDoNotFree = TRUE;
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    ABORT_ON_ERROR(NULL == pResult->rItems);
    for(i=0;i<pResult->cItems;i++)
    {
        if(pResult->rItems[i].status)
        {
            iFailureIndex = i;
            hr = E_FAIL;
            goto error;
        }       
    }
    
    ABORT_ON_ERROR(NULL == (pResult->rItems[0].pName));
    ABORT_ON_ERROR(0 == wcslen(pResult->rItems[0].pName));
    ABORT_ON_ERROR(NULL == pResult->rItems[0].pDomain);


    if (_rgszGuid) {
        for (i=0;i<_cGuid;i++) {
            FreeADsMem(_rgszGuid[i]);
        }
        FreeADsMem(_rgszGuid);
    }

    _rgszGuid = (LPWSTR*)AllocADsMem(dwNum * sizeof(LPWSTR));
    if (!_rgszGuid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    for (i=0;i<dwNum;i++) {
        ADsAssert(pResult->rItems[i].pName);
        _rgszGuid[i] = AllocADsStr(pResult->rItems[i].pName);
        if (!_rgszGuid[i]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    _cGuid = dwNum;

error:
    if (ppszStrArray) {

        for (i=0; i < dwNum; i++) {
            if (ppszStrArray[i]) {
                FreeADsStr(ppszStrArray[i]);
            }
        }
        FreeADsMem(ppszStrArray);
    }

    if (vVarArray) {

        for (i=0; i < dwNum; i++) {
            VariantClear(vVarArray + i);
        }
        FreeADsMem(vVarArray);
    }

    if ((dwErr == 0) && (pResult) && (iFailureIndex != -1)) {
        hr = MapCrackErrToHR(pResult->rItems[iFailureIndex].status);
    }
    if (pResult && !fDoNotFree) {
        DsFreeNameResultWrapper(pResult);
    }

    return hr;
}


CDomainToHandle::CDomainToHandle()
{
    m_cszMax = 0;
    m_iszNext = 0;
    m_rgMap = NULL;
}

CDomainToHandle::~CDomainToHandle()
{
    Free();
}

DWORD CDomainToHandle::NumElements()
{
    return m_iszNext;
}

HRESULT CDomainToHandle::Init()
{
    HRESULT hr = S_OK;

    Free();

    m_rgMap = (DomainToHandle*)AllocADsMem( STRINGPLEX_INC * sizeof(DomainToHandle) );
    if (!m_rgMap) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    m_cszMax = STRINGPLEX_INC;
    m_iszNext = 0;
    memset(m_rgMap, 0, STRINGPLEX_INC * sizeof(DomainToHandle) );

error:
    return hr;
}

HRESULT CDomainToHandle::AddElement(LPWSTR szValue, HANDLE hDS)
{
    HRESULT hr = S_OK;
    DomainToHandle *rgMap = NULL;

    if (!szValue) {
        return E_ADS_BAD_PARAMETER;
    }

    //
    // If next index is larger than largest index
    //
    if (m_iszNext > (m_cszMax-1)) {
        rgMap = (DomainToHandle*)ReallocADsMem(m_rgMap ,
                                m_cszMax*sizeof(DomainToHandle),
                                (m_cszMax + STRINGPLEX_INC)*sizeof(DomainToHandle));
        if (!rgMap) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        m_rgMap = rgMap;
        m_cszMax+=STRINGPLEX_INC;
    }

    m_rgMap[m_iszNext].szDomain = AllocADsStr(szValue);
    if (!m_rgMap[m_iszNext].szDomain) {
         hr = E_OUTOFMEMORY;
         BAIL_ON_FAILURE(hr);
    }
    m_rgMap[m_iszNext].hDS = hDS;

    m_iszNext++;
error:
    return hr;
}

HRESULT CDomainToHandle::Find(LPWSTR szValue, HANDLE *phDS)
{
    HRESULT hr = E_FAIL;
    UINT i;

    if (!szValue) {
        return E_ADS_BAD_PARAMETER;
    }

    for (i=0;i<m_iszNext;i++) {
        if (wcscmp(m_rgMap[i].szDomain, szValue) == 0) {
            *phDS = m_rgMap[i].hDS;
            return S_OK;
        }
    }

    return hr;
}

void CDomainToHandle::Free()
{
    DWORD isz = 0;

    if (m_rgMap) {
        for (isz=0;isz<m_iszNext;isz++) {
            if (m_rgMap[isz].szDomain) {
                FreeADsMem(m_rgMap[isz].szDomain);
                DsUnBindWrapper(&m_rgMap[isz].hDS);
            }
        }
        FreeADsMem(m_rgMap);
        m_rgMap = NULL;
    }
    m_cszMax = 0;
    m_iszNext = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldap2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ldap2var.cxx
//
//  Contents:   LDAP Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Jun-96   yihsins  Created.
//
//
//  Issues:
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//
// LdapType objects copy code
//

HRESULT
LdapTypeToVarTypeString(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;

    pVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
             LDAPOBJECT_STRING(pLdapSrcObject),
             &(pVarDestObject->bstrVal)
             );

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeBoolean(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);

    pVarDestObject->vt = VT_BOOL;

    if ( _tcsicmp( pszSrc, TEXT("TRUE")) == 0 )
    {
        pVarDestObject->boolVal = VARIANT_TRUE;
    }
    else if ( _tcsicmp( pszSrc, TEXT("FALSE")) == 0 )
    {
        pVarDestObject->boolVal = VARIANT_FALSE;
    }
    else
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
    }

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeInteger(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;

    pVarDestObject->vt = VT_I4;

    pVarDestObject->lVal = _ttol(LDAPOBJECT_STRING(pLdapSrcObject));

    RRETURN(hr);
}


HRESULT
LdapTypeToVarTypeSecDes(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    BOOL fNTDS = TRUE;

    pVarDestObject->vt = VT_DISPATCH;

    hr = ReadServerType(
             pszServerName,
             &Credentials,
             &fNTDS
             );
    BAIL_ON_FAILURE(hr);


    hr = ConvertSecDescriptorToVariant(
                pszServerName,
                Credentials,
                LDAPOBJECT_BERVAL_VAL(pLdapSrcObject),
                pVarDestObject,
                fNTDS
                );

error:

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeLargeInteger(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
   HRESULT hr = S_OK;
   IADsLargeInteger * pLargeInteger = NULL;
   IDispatch * pDispatch = NULL;
   LARGE_INTEGER largeint;

   hr = CoCreateInstance(
            CLSID_LargeInteger,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsLargeInteger,
            (void **) &pLargeInteger);
   BAIL_ON_FAILURE(hr);

   swscanf (LDAPOBJECT_STRING(pLdapSrcObject), L"%I64d", &largeint);

   hr = pLargeInteger->put_LowPart(largeint.LowPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_HighPart(largeint.HighPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   V_VT(pVarDestObject) = VT_DISPATCH;
   V_DISPATCH(pVarDestObject) =  pDispatch;

error:

   if (pLargeInteger) {
      pLargeInteger->Release();
   }
   RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeDNWithBinary(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;
    IADsDNWithBinary *pDNWithBinary = NULL;
    IDispatch *pDispatch = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    BSTR bstrTemp = NULL;

    memset(&AdsValue, 0, sizeof(AdsValue));

    hr = CoCreateInstance(
             CLSID_DNWithBinary,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithBinary,
             (void **) &pDNWithBinary
             );
    BAIL_ON_FAILURE(hr);


    //
    // Convert the ldapString to an adsvalue and then take it
    // to DNWithBinary object
    //
    hr = LdapTypeToAdsTypeDNWithBinary(
             pLdapSrcObject,
             &AdsValue
             );

    BAIL_ON_FAILURE(hr);

    if (AdsValue.pDNWithBinary->pszDNString) {
        hr = ADsAllocString(AdsValue.pDNWithBinary->pszDNString, &bstrTemp);
        BAIL_ON_FAILURE(hr);

        //
        // Put the value in the object - we can only set BSTR's
        //
        hr = pDNWithBinary->put_DNString(bstrTemp);
        BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = AdsValue.pDNWithBinary->dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, AdsValue.pDNWithBinary->lpBinaryValue, aBound.cElements );

    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    hr = pDNWithBinary->put_BinaryValue(*pVarDestObject);
    VariantClear(pVarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pDNWithBinary->QueryInterface(
                            IID_IDispatch,
                            (void **) &pDispatch
                            );
    BAIL_ON_FAILURE(hr);

    V_VT(pVarDestObject) = VT_DISPATCH;
    V_DISPATCH(pVarDestObject) = pDispatch;

error:

    if (pDNWithBinary) {
        pDNWithBinary->Release();
    }

    if (AdsValue.pDNWithBinary) {
        if (AdsValue.pDNWithBinary->lpBinaryValue) {
            FreeADsMem(AdsValue.pDNWithBinary->lpBinaryValue);
        }

        if (AdsValue.pDNWithBinary->pszDNString) {
            FreeADsStr(AdsValue.pDNWithBinary->pszDNString);
        }
        FreeADsMem(AdsValue.pDNWithBinary);
    }

    if (bstrTemp) {
        ADsFreeString(bstrTemp);
    }

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeDNWithString(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;
    IADsDNWithString *pDNWithString = NULL;
    IDispatch *pDispatch = NULL;
    BSTR bstrStrVal = NULL;
    BSTR bstrDNVal = NULL;

    memset(&AdsValue, 0, sizeof(AdsValue));

    hr = CoCreateInstance(
             CLSID_DNWithString,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithString,
             (void **) &pDNWithString
             );
    BAIL_ON_FAILURE(hr);


    //
    // Convert the ldapString to an adsvalue and then take it
    // to DNWithString object
    //
    hr = LdapTypeToAdsTypeDNWithString(
             pLdapSrcObject,
             &AdsValue
             );

    BAIL_ON_FAILURE(hr);

    if (AdsValue.pDNWithString->pszDNString) {
        hr = ADsAllocString(AdsValue.pDNWithString->pszDNString, &bstrDNVal);
        BAIL_ON_FAILURE(hr);

        hr = pDNWithString->put_DNString(bstrDNVal);
        BAIL_ON_FAILURE(hr);
    }

    if (AdsValue.pDNWithString->pszStringValue) {
        hr = ADsAllocString(
                 AdsValue.pDNWithString->pszStringValue,
                 &bstrStrVal
                 );
        BAIL_ON_FAILURE(hr);

        hr = pDNWithString->put_StringValue(bstrStrVal);

        BAIL_ON_FAILURE(hr);
    }

    hr = pDNWithString->QueryInterface(
                            IID_IDispatch,
                            (void **) &pDispatch
                            );
    BAIL_ON_FAILURE(hr);

    V_VT(pVarDestObject) = VT_DISPATCH;
    V_DISPATCH(pVarDestObject) = pDispatch;

error:

    if (pDNWithString) {
        pDNWithString->Release();
    }

    if (AdsValue.pDNWithString) {
        if (AdsValue.pDNWithString->pszStringValue) {
            FreeADsStr(AdsValue.pDNWithString->pszStringValue);
        }

        if (AdsValue.pDNWithString->pszDNString) {
            FreeADsStr(AdsValue.pDNWithString->pszDNString);
        }
        FreeADsMem(AdsValue.pDNWithString);
    }

    if (bstrDNVal) {
        ADsFreeString(bstrDNVal);
    }

    if (bstrStrVal) {
        ADsFreeString(bstrStrVal);
    }

    RRETURN(hr);
}



HRESULT
LdapTypeToVarTypeBinaryData(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, LDAPOBJECT_BERVAL_VAL(pLdapSrcObject), aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeUTCTime(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    int nSuccess = 0;
    ADSVALUE AdsValue;

    pVarDestObject->vt = VT_DATE;

    //
    // This converts to a SYSTEMTIME.
    //
    hr = LdapTypeToAdsTypeUTCTime(
        pLdapSrcObject,
        &AdsValue);
    BAIL_ON_FAILURE(hr);

    nSuccess = SystemTimeToVariantTime(
                    &AdsValue.UTCTime,
                    &pVarDestObject->date
                    );
    if (!nSuccess) {
        hr =E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

error:
    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeGeneralizedTime(
    PLDAPOBJECT pLdapSrcObject,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr = S_OK;
    BOOL fSuccess = FALSE;
    ADSVALUE AdsValue;

    pVarDestObject->vt = VT_DATE;

    //
    // This converts to a SYSTEMTIME.
    //
    hr = LdapTypeToAdsTypeGeneralizedTime(
        pLdapSrcObject,
        &AdsValue);
    BAIL_ON_FAILURE(hr);

    fSuccess = SystemTimeToVariantTime(
                   &AdsValue.UTCTime,
                   &pVarDestObject->date);
    if (!fSuccess) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

error:
    RRETURN(hr);
}

HRESULT
LdapTypeToVarTypeCopy(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PLDAPOBJECT pLdapSrcObject,
    DWORD       dwSyntaxId,
    PVARIANT    pVarDestObject
    )
{
    HRESULT hr = S_OK;

    switch (dwSyntaxId) {

        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_PRINTABLESTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING:
        case LDAPTYPE_DN:
        case LDAPTYPE_NUMERICSTRING:
        case LDAPTYPE_IA5STRING:
        case LDAPTYPE_CASEIGNORESTRING:
        case LDAPTYPE_CASEEXACTSTRING:
//      case LDAPTYPE_CASEIGNOREIA5STRING:
        case LDAPTYPE_OID:
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:

        //
        // These types are treatable as strings
        // (see RFCs 2252, 2256)
        //
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER:
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_PRESENTATIONADDRESS:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_DSAQUALITYSYNTAX:
        case LDAPTYPE_DATAQUALITYSYNTAX:
        case LDAPTYPE_MAILPREFERENCE:
        case LDAPTYPE_OTHERMAILBOX:
        case LDAPTYPE_ACCESSPOINTDN:
        case LDAPTYPE_ORNAME:
        case LDAPTYPE_ORADDRESS:

            hr = LdapTypeToVarTypeString(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;

        case LDAPTYPE_BOOLEAN:
            hr = LdapTypeToVarTypeBoolean(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;

        case LDAPTYPE_INTEGER:
            hr = LdapTypeToVarTypeInteger(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;


        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
            hr = LdapTypeToVarTypeBinaryData(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;

        case LDAPTYPE_GENERALIZEDTIME:
            hr = LdapTypeToVarTypeGeneralizedTime(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;

        case LDAPTYPE_UTCTIME:
            hr = LdapTypeToVarTypeUTCTime(
                    pLdapSrcObject,
                    pVarDestObject
                    );
            break;


    case LDAPTYPE_SECURITY_DESCRIPTOR:
        hr = LdapTypeToVarTypeSecDes(
                    pszServerName,
                    Credentials,
                    pLdapSrcObject,
                    pVarDestObject
                    );
        break;

    case LDAPTYPE_INTEGER8:
        hr = LdapTypeToVarTypeLargeInteger(
                    pLdapSrcObject,
                    pVarDestObject
                    );
        break;

#if 0
        case LDAPTYPE_CASEEXACTLIST:
        case LDAPTYPE_CASEIGNORELIST:
#endif

        case LDAPTYPE_DNWITHBINARY:
            hr = LdapTypeToVarTypeDNWithBinary(
                     pLdapSrcObject,
                     pVarDestObject
                     );
            break;

        case LDAPTYPE_DNWITHSTRING:
            hr = LdapTypeToVarTypeDNWithString(
                     pLdapSrcObject,
                     pVarDestObject
                     );

            break;

        default:

            //
            // LDAPTYPE_UNKNOWN  (schemaless server property) will be
            // not be converted.
            //

            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;
    }

    RRETURN(hr);

}


HRESULT
LdapTypeToVarTypeCopyConstruct(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    LDAPOBJECTARRAY ldapSrcObjects,
    DWORD dwSyntaxId,
    PVARIANT pVarDestObjects
    )
{

    long i = 0;
    HRESULT hr = S_OK;

    VariantInit( pVarDestObjects );

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = ldapSrcObjects.dwCount;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) ldapSrcObjects.dwCount; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = LdapTypeToVarTypeCopy(
                    pszServerName,
                    Credentials,
                    ldapSrcObjects.pLdapObjects + i,
                    dwSyntaxId,
                    &v
                    );


        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);

        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\namecf.cxx ===
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNameTranslateCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNameTranslateCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNameTranslate::CreateNameTranslate(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\pathutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pathmgmt.cxx
//
//  Contents:
//
//  Functions:
//
//  History:    25-April-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop


HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    LPWSTR pszADsPath = NULL;
    HRESULT hr = S_OK;

    hr = BuildADsPathFromParent( Parent, Name, &pszADsPath );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pszADsPath, pADsPath);
    BAIL_ON_FAILURE(hr);

error:

    if ( pszADsPath )
        FreeADsMem( pszADsPath );

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR bstrADsPath,
    BSTR bstrClass,
    BSTR *pSchemaPath
    )
{
    TCHAR *pszADsSchema = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    HRESULT hr = S_OK;
    WCHAR szPort[32];
    DWORD dwLen;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (bstrClass && *bstrClass) {

        hr = ADsObject(bstrADsPath, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        if (pObjectInfo->TreeName) {

            dwLen =  wcslen(pObjectInfo->NamespaceName) + 
                     wcslen(pObjectInfo->TreeName) +
                     wcslen(bstrClass) +
                     11 +        // ":///schema/"
                     1;

            if ( IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
                wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
                dwLen += wcslen(szPort);
            }
                
            pszADsSchema = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );
            if ( pszADsSchema == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            wsprintf(pszADsSchema,TEXT("%s://"),pObjectInfo->NamespaceName);
            wcscat(pszADsSchema, pObjectInfo->TreeName);

            if (IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
                wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
                wcscat(pszADsSchema, szPort);
            }

            wcscat(pszADsSchema, TEXT("/schema/"));
            wcscat(pszADsSchema, bstrClass);

        }else {

           pszADsSchema = (LPTSTR) AllocADsMem(
                              ( _tcslen(pObjectInfo->NamespaceName) +
                                _tcslen(bstrClass) +
                                12 ) * sizeof(TCHAR)); //includes ":///schema/"

           if ( pszADsSchema == NULL )
           {
               hr = E_OUTOFMEMORY;
               BAIL_ON_FAILURE(hr);
           }

           _stprintf(pszADsSchema,TEXT("%s://"),pObjectInfo->NamespaceName);
           _tcscat(pszADsSchema, TEXT("schema/"));
           _tcscat(pszADsSchema, bstrClass);

        }
    }

    hr = ADsAllocString( pszADsSchema? pszADsSchema : TEXT(""), pSchemaPath);

error:

    if ( pszADsSchema )
        FreeADsStr( pszADsSchema );

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);
}


HRESULT
BuildADsPathFromLDAPDN(
    BSTR bstrParent,
    BSTR bstrObject,
    LPTSTR *ppszADsPath
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszTemp = NULL;
    int i;
    int j;
    int nCount;
    int *aIndex = NULL;

    if ( bstrObject == NULL || *bstrObject == 0 )
    {
        BAIL_ON_FAILURE(hr=E_ADS_BAD_PATHNAME);
    }

    *ppszADsPath = (LPTSTR) AllocADsMem( ( _tcslen(bstrParent)
                                         + _tcslen(bstrObject)
                                         + 1) * sizeof(TCHAR) );

    if ( *ppszADsPath == NULL )
    {
        BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);
    }

    _tcscpy( *ppszADsPath, bstrParent );

    pszTemp = _tcschr( *ppszADsPath, TEXT(':'));

    if ( pszTemp )
    {
        pszTemp += _tcslen(TEXT("://"));

        if ( pszTemp )
        {
            pszTemp = _tcschr( pszTemp, TEXT('/'));
        }
    }

    if ( pszTemp == NULL )
    {
        BAIL_ON_FAILURE(hr=E_ADS_BAD_PATHNAME);
    }

    i = 0;
    nCount = 1;
    while ( bstrObject[i] != 0 )
    {
        if ( bstrObject[i++] == TEXT(',') )
            nCount++;
    }

    aIndex = (int *) AllocADsMem( nCount * sizeof(int));
    if ( aIndex == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    i = 0; j = 0;
    aIndex[j++] = 0;
    while ( bstrObject[i] != 0 )
    {
        if ( bstrObject[i++] == TEXT(',') )
            aIndex[j++] = i;
    }

    for ( i = nCount; i > 0; i-- )
    {
        *(pszTemp++) = TEXT('/');
        j = aIndex[i-1];
        while ( ( bstrObject[j] != 0 ) && ( bstrObject[j] != TEXT(',') ))
            *(pszTemp++) = bstrObject[j++];
    }

    *pszTemp = 0;

error:

    if ( aIndex )
        FreeADsMem( aIndex );

    if ( FAILED(hr))
    {
        if ( *ppszADsPath )
            FreeADsStr( *ppszADsPath );

        *ppszADsPath = NULL;
    }

    return hr;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    return(hr);

}


HRESULT
IsValidFilter(
    LPTSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_tcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!(V_VT(&var) ==  (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\property.cxx ===
#include "ldap.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}


//
// Helper to set octetstring property on the object
//
HRESULT
put_OCTETSTRING_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BYTE byteArr[],
    DWORD  dwLen
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    VARIANT vDestObject;

    VariantInit(&vDestObject);

    aBound.lLbound = 0;
    aBound.cElements = dwLen;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, byteArr, dwLen );
    SafeArrayUnaccessData( aList );

    V_VT(&vDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(&vDestObject) = aList;


    hr = pADsObject->Put(
            bstrPropertyName,
            vDestObject
            );

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\proplist.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cgenobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   08-30-96  yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
CLDAPGenObject::get_PropertyCount(
    THIS_ long FAR *plCount
    )
{
    HRESULT hr = E_FAIL;

    BSTR bstrProperty = NULL;
    SAFEARRAY *psaProperty = NULL;
    SAFEARRAYBOUND rgsabound[1];
    long lsaDim[1];
    VARIANT varProperty;


    //  ??? _pPropertyCache canNOT be NULL or bailed out during
    //      CLDAPGenObject creation already
    //  assert(_PropertyCache);

    if (_pPropertyCache) {
          hr = _pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }


    RRETURN_EXP_IF_ERR(hr);

}


////////////////////////////////////////////////////////////////////////////
//
// - Return the "next" item (item with the current index) in cache, if any,
//   in a property entry [*pVariant].
// - Return E_ADS_PROPERTY_NOT_FOUND when current index is out of bound.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CLDAPGenObject::Next(
    THIS_ VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    IDispatch * pDispatch = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;
    DWORD dwPropStatus = 0;
    DWORD dwCtrlCode = 0;

    if(!_pPropertyCache->index_valid())
       RRETURN_EXP_IF_ERR(E_FAIL);

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    hr = _pPropertyCache->unboundgetproperty(
                _pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwPropStatus,
                &ldapSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);

    //
    // translate the LDAP objects to variants
    //

    hr = ConvertLdapValuesToVariant(
            _pPropertyCache->get_CurrentPropName(),
            &ldapSrcObjects,
            dwSyntaxId,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );
    BAIL_ON_FAILURE(hr);


error:

    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the sucess of Skip().
    //

    Skip(1);

    LdapTypeFreeLdapObjects(&ldapSrcObjects);


    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::Skip(
    THIS_ long cElements
    )
{
   HRESULT hr = S_OK;

   hr = _pPropertyCache->skip_propindex(
                cElements
                );
   RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::Reset(

    )
{
    _pPropertyCache->reset_propindex();

    RRETURN_EXP_IF_ERR(S_OK);
}

STDMETHODIMP
CLDAPGenObject::ResetPropertyItem(THIS_ VARIANT varEntry)
{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;

    switch (V_VT(&varEntry)) {

    case VT_BSTR:

        hr = _pPropertyCache->findproperty(
                            V_BSTR(&varEntry),
                            &dwIndex
                            );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I4:
        dwIndex = V_I4(&varEntry);
        break;


    case VT_I2:
        dwIndex = V_I2(&varEntry);
        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->deleteproperty(
                        dwIndex
                        );
error:


    RRETURN_EXP_IF_ERR(hr);
}


//////////////////////////////////////////////////////////////////////////
//
// Retrieve property [bstrName] from the cache (only, no wire calls) as
// a PropertyEntry.
//
// [*pVariant]
//      - store ptr to IDispatch of the PropertyEntry.
//
// If the property in cache has control code = ADS_PROPERTY_DELETE,
//      - PropertyEntry will contain an empty variant and
//      - adstype = ADSTYPE_INVALID.
//
// If property in cache has UNKNWON type, (not deleted, for schemaless-server
// property which is not in ADSI default schema)
//      - [lnAdsType] must be a valid type (NO ADSTYPE_UNKNWON/INVALID)
//      - property will be retrieved as [lnADsType]
//
// If property in cache has KNOWN type,
//      - [lnADsType] must either match type in cache or == ADSTYPE_UNKNOWN
//      - property will be retreived as the type in cache.
//
/////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CLDAPGenObject::GetPropertyItem(
    THIS_
    IN  BSTR bstrName,
    IN  LONG lnADsType,
    IN OUT VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwCachedSyntax = LDAPTYPE_UNKNOWN;
    DWORD dwUserSyntax = LDAPTYPE_UNKNOWN;
    DWORD dwSyntaxUsed = LDAPTYPE_UNKNOWN;  // extra, make code easier to read
    DWORD dwPropStatus = 0;
    DWORD dwCtrlCode = 0;
    LDAPOBJECTARRAY ldapSrcObjects;
    LDAPOBJECTARRAY ldapSrc2Objects;
    LDAPOBJECTARRAY * pLdapSrcObjects = NULL;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);
    LDAPOBJECTARRAY_INIT(ldapSrc2Objects);


    if (!bstrName || !pVariant)
        RRETURN(E_ADS_BAD_PARAMETER);


    //
    // retrieve property from cache; CONTINUE if property exist but
    // has no value (control code flag as a DELETE)
    //

    hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwCachedSyntax,
                    &dwPropStatus,
                    &ldapSrcObjects
                    );
    BAIL_ON_FAILURE(hr);

    // For backward compatibility -- no issue as you
    // need to return a value even if it is delete.


    //
    // map adstype from client to ldap type;
    //

    dwUserSyntax =  MapADSTypeToLDAPType((ADSTYPE)lnADsType);


    //
    // determine the syntax to retrieve property in
    //

    if ( (dwCachedSyntax == LDAPTYPE_UNKNOWN)
            ||
         (dwCachedSyntax == 0) // should NOT be 0, but misuse of 0 everywhere
       )                       // and in case i didn't clean up all
    {
        //
        // syntax not stored in cache, user must spcify a valid sytax
        // Exception: cleared property values have LDAPTYPE_UNKNOWN, and we
        // return them as ADSTYPE_UNKNOWN
        //

        if ((dwUserSyntax == LDAPTYPE_UNKNOWN) && (dwPropStatus != PROPERTY_DELETE))
        {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            BAIL_ON_FAILURE(hr);
        }

        dwSyntaxUsed = dwUserSyntax;

        //
        // convert from cached data from ldap binary format to ldap string
        // IFF necessary based on dwUserSyntax
        //

        hr = LdapTypeBinaryToString(
                dwSyntaxUsed,
                &ldapSrcObjects,
                &ldapSrc2Objects
                );

        //
        // dwSyntaxUsed (dwUserSyntax) must be valid from
        // MapADSTypeToLDAPType() or code bug in MapADsTypeToLDAPType() !!
        //

        ADsAssert(SUCCEEDED(hr));

        if (hr==S_OK)
        {
            pLdapSrcObjects = &ldapSrc2Objects;     // conversion done
        }
        else // hr == S_FALSE
        {
            pLdapSrcObjects = &ldapSrcObjects;      // no conversion
        }
    }

    else // dwCachedSyntax known and valid
    {
        //
        // syntax stored in cache, user MUST either specify
        //  1) ADSTYPE_UNKNWON  or
        //  2) a syntax which matches the one in cache. The comparision must
        //     be done in ADsType, not LdapType, since LdapType To ADSType
        //     is n to 1 mapping and as long as ADsType match, ok.
        //

        if ( ! (
                (dwUserSyntax == LDAPTYPE_UNKNOWN)
                    ||
                ( (ADSTYPE) lnADsType == MapLDAPTypeToADSType(dwCachedSyntax))
               )
           )
        {

            if (dwUserSyntax != dwCachedSyntax) {

                //
                // Check if the user wants the data back for the
                // security descriptor as an octet or vice versa
                //
                if (  (dwUserSyntax == LDAPTYPE_OCTETSTRING
                       && dwCachedSyntax == LDAPTYPE_SECURITY_DESCRIPTOR)
                      ||(dwUserSyntax == LDAPTYPE_SECURITY_DESCRIPTOR
                         && dwCachedSyntax == LDAPTYPE_OCTETSTRING))
                {
                    dwCachedSyntax = dwUserSyntax;

                } else {
                    //
                    // Check for UTC/GenTime mismatch before ret error.
                    //
                    if (!((dwCachedSyntax == LDAPTYPE_GENERALIZEDTIME)
                            && (dwUserSyntax == LDAPTYPE_UTCTIME))) {

                        hr = E_ADS_CANT_CONVERT_DATATYPE;
                        BAIL_ON_FAILURE(hr);
                    }
                }
            } // if dwUserSyntax != dwCachedSyntax
        }

        dwSyntaxUsed = dwCachedSyntax;

        pLdapSrcObjects = &ldapSrcObjects;           // no conversion needed
    }


    //
    // translate ldap prop status to ads control code
    //

    dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);


    //
    // translate the property from Ldap objects to a PropertyEntry
    //

    hr = ConvertLdapValuesToVariant(
            bstrName,
            pLdapSrcObjects,
            dwSyntaxUsed,
            dwCtrlCode,
            pVariant,
            _pszLDAPServer,
            &_Credentials
            );

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );
    LdapTypeFreeLdapObjects( &ldapSrc2Objects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::PutPropertyItem(
    THIS_ VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    DWORD dwControlCode = 0;
    LDAPOBJECTARRAY ldapDestObjects;
    WCHAR* pszPropertyName = NULL;
    DWORD dwSyntaxId = 0;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    hr = ConvertVariantToLdapValues(
                varData,
                &pszPropertyName,
                &dwControlCode,
                &ldapDestObjects,
                &dwSyntaxId,
                _pszLDAPServer,
                &_Credentials,
                _dwPort
                );
    BAIL_ON_FAILURE(hr);

    switch ( dwControlCode ) {

    case 0 :
        //
        // Users better know what they are doing here,
        // This the property as cleared so we do not send it
        // on the wire on th next SetInfo.
        //
        dwFlags = PROPERTY_INIT;
        break;

    case ADS_PROPERTY_CLEAR:

        //
        // Clears an entire property
        //

        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:

        //
        // Updates the entire property
        //

        dwFlags = PROPERTY_UPDATE;
        break;

    case ADS_PROPERTY_APPEND:
        //
        // Appends a set of values to the property
        //

        dwFlags = PROPERTY_ADD;
        break;

    case ADS_PROPERTY_DELETE:
        //
        // Delete a value(s) from the property

        dwFlags = PROPERTY_DELETE_VALUE;
        break;


    default:
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }



    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        pszPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( pszPropertyName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);
    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    pszPropertyName,
                    dwFlags,
                    dwSyntaxId,
                    ldapDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if(pszPropertyName)
    {
        FreeADsStr(pszPropertyName);
    }

    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    DWORD ADsType,
    DWORD numValues,
    DWORD dwOperation,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(ADsType);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);

    if (dwOperation) {
        hr = pPropEntry->put_ControlCode((long)dwOperation);
    }

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}

STDMETHODIMP
CLDAPGenObject::Item(
    THIS_ VARIANT varIndex,
    VARIANT * pVariant
    )

{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    LDAPOBJECTARRAY ldapSrcObjects;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;
    DWORD dwNumValues = 0;
    LPWSTR szPropName = NULL;
    DWORD dwPropStatus = 0;
    DWORD dwCtrlCode = (DWORD) -1;
    VARIANT * pvVar = &varIndex;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // retrieve data object from cache; if one exis
    //

    // If the object has been deleted (and is in the cache
    // marked for deletion), we return
    // the item with DELETE ctrl code in all
    // the cases below.  This is consistent with GetPropertyItem's
    // behavior as well.

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:

        //
        // retrieve data object from cache; if one exists
        //

        hr = _pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwPropStatus,
                        &ldapSrcObjects
                        );
        BAIL_ON_FAILURE(hr);

        dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);

        hr = ConvertLdapValuesToVariant(
                V_BSTR(pvVar),
                &ldapSrcObjects,
                dwSyntaxId,
                dwCtrlCode,
                pVariant,
                _pszLDAPServer,
                &_Credentials
                );

        BAIL_ON_FAILURE(hr);

       break;

    case VT_I4:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I4(pvVar),
                    &dwSyntaxId,
                    &dwPropStatus,
                    &ldapSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(
                        (DWORD)V_I4(pvVar)
                        );

        dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);

        hr = ConvertLdapValuesToVariant(
                szPropName,
                &ldapSrcObjects,
                dwSyntaxId,
                dwCtrlCode,
                pVariant,
                _pszLDAPServer,
                &_Credentials
                );

        BAIL_ON_FAILURE(hr);

        break;


    case VT_I2:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwPropStatus,
                    &ldapSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(
                        (DWORD)V_I2(pvVar)
                        );

        dwCtrlCode = MapPropCacheFlagToControlCode(dwPropStatus);

        hr = ConvertLdapValuesToVariant(
                szPropName,
                &ldapSrcObjects,
                dwSyntaxId,
                dwCtrlCode,
                pVariant,
                _pszLDAPServer,
                &_Credentials
                );
        BAIL_ON_FAILURE(hr);

        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    //
    // translate the Ldap objects to variants
    //


error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::PurgePropertyList()
{
    _pPropertyCache->flushpropertycache();
    RRETURN(S_OK);
}


DWORD
MapPropCacheFlagToControlCode(
    DWORD dwPropStatus
    )
{
    DWORD dwADsCtrlCode = (DWORD) -1;

    switch (dwPropStatus) {

    case PROPERTY_INIT:
        //
        // 0 is not defined as any of the ADS_PROPERTY_ flags
        // use it to indicate that property is in init state
        //
        dwADsCtrlCode = 0;
        break;

    case PROPERTY_UPDATE:
        dwADsCtrlCode = ADS_PROPERTY_UPDATE;
        break;

    case PROPERTY_ADD:
        dwADsCtrlCode = ADS_PROPERTY_APPEND;
        break;

    case PROPERTY_DELETE:
        dwADsCtrlCode = ADS_PROPERTY_CLEAR;
        break;

    case PROPERTY_DELETE_VALUE:
        dwADsCtrlCode = ADS_PROPERTY_DELETE;
        break;

    default:
        // set to speical value to indicate unknow code
        dwADsCtrlCode = (DWORD) -1;
        break;
    }

    return dwADsCtrlCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\umi_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_UMI_V6,0x12575a7a,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiURLKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);


MIDL_DEFINE_GUID(IID, IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCustomInterfaceFactory,0x14CD599E,0x2BE7,0x4c6f,0xB9,0x5B,0xB1,0x50,0xDC,0xD9,0x35,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_UMI_V6,0x12575a7a,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiURLKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);


MIDL_DEFINE_GUID(IID, IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCustomInterfaceFactory,0x14CD599E,0x2BE7,0x4c6f,0xB9,0x5B,0xB1,0x50,0xDC,0xD9,0x35,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\system.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cPathname.cxx
//
//  Contents:  Pathname object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

#define DEFAULT_NC _T(LDAP_OPATT_DEFAULT_NAMING_CONTEXT)
#define SCHEMA_NC  _T(LDAP_OPATT_SCHEMA_NAMING_CONTEXT)

CRITICAL_SECTION g_SystemAPICritSect;
#define ENTER_SYSTEMAPI_CRITICAL_SECTION() EnterCriticalSection(&g_SystemAPICritSect);
#define LEAVE_SYSTEMAPI_CRITICAL_SECTION() LeaveCriticalSection(&g_SystemAPICritSect);


HANDLE g_hSecur32Dll = NULL;

//  Class CADSystemInfo

DEFINE_IDispatch_Implementation(CADSystemInfo)

//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::CADSystemInfo
//
// Synopsis:    Constructor
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
CADSystemInfo::CADSystemInfo():
        _pDispMgr(NULL),
        _hSecur32(NULL),
        _Secur32LoadAttempted(FALSE),
        _hNetApi32(NULL),
        _NetApi32LoadAttempted(FALSE)
{
    ENLIST_TRACKING(CADSystemInfo);
}


//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::CreateADSystemInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CADSystemInfo::CreateADSystemInfo(
    REFIID riid,
    void **ppvObj
    )
{
    CADSystemInfo FAR * pADSystemInfo = NULL;
    HRESULT hr = S_OK;

    hr = AllocateADSystemInfoObject(&pADSystemInfo);
    BAIL_ON_FAILURE(hr);

    hr = pADSystemInfo->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pADSystemInfo->Release();

    RRETURN(hr);

error:
    delete pADSystemInfo;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::~CADSystemInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
CADSystemInfo::~CADSystemInfo( )
{

    delete _pDispMgr;

    if (_hSecur32)
        FreeLibrary(_hSecur32);

    if (_hNetApi32)
        FreeLibrary(_hNetApi32);
}

//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::QueryInterface
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADSystemInfo::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsADSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsADSystemInfo))
    {
        *ppv = (IADsADSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsADSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::AllocateADSystemInfoObject
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CADSystemInfo::AllocateADSystemInfoObject(
    CADSystemInfo  ** ppADSystemInfo
    )
{
    CADSystemInfo FAR * pADSystemInfo = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pADSystemInfo = new CADSystemInfo();
    if (pADSystemInfo == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsADSystemInfo,
                (IADsADSystemInfo *)pADSystemInfo,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pADSystemInfo->_pDispMgr = pDispMgr;
    *ppADSystemInfo = pADSystemInfo;

    RRETURN(hr);

error:

    delete pADSystemInfo;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
// Function:    CADSystemInfo::InterfaceSupportsErrorInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CADSystemInfo::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsADSystemInfo)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}


HRESULT
CADSystemInfo::get_UserName(
    BSTR * bstrUserName
    )
{
    PWSTR pszUserDN = NULL;
    ULONG uLength;
    GETUSERNAMEEX pGetUserNameEx;
    HRESULT hr;
    HINSTANCE hModule;

    //
    // Validate parameters
    //
    if ( !bstrUserName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get handle to secur32.dll, and get required entry point
    //
    hr = GetSecur32Handle(&hModule);
    BAIL_ON_FAILURE(hr);

    pGetUserNameEx = (GETUSERNAMEEX) GetProcAddress(hModule, "GetUserNameExW");
    if (!pGetUserNameEx)
    {
        RRETURN(E_FAIL);
    }

    //
    // Get length of buffer to be allocated
    //
    uLength = 0;
    (*pGetUserNameEx)(NameFullyQualifiedDN,
                      NULL,
                      &uLength);

    if (uLength > 0)
    {
        //
        // Allocated memory and do the real work
        //
        pszUserDN = (PWSTR)AllocADsMem(uLength * sizeof(WCHAR));
        if (!pszUserDN)
        {
            RRETURN(E_OUTOFMEMORY);
        }

        if ((*pGetUserNameEx)(NameFullyQualifiedDN,
                              pszUserDN,
                              &uLength))
        {

            hr = ADsAllocString(pszUserDN, bstrUserName);
            BAIL_ON_FAILURE(hr);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

error:
    if (pszUserDN)
    {
        FreeADsMem(pszUserDN);
    }

    RRETURN(hr);
}

HRESULT
CADSystemInfo::get_ComputerName(
    BSTR * bstrComputerName
    )
{
    PWSTR pszComputerName = NULL;
    ULONG uLength;
    GETCOMPUTEROBJECTNAME pGetComputerObjectName;
    HRESULT hr;
    HINSTANCE hModule;

    //
    // Validate parameters
    //
    if (!bstrComputerName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get handle to secur32.dll, and get required entry point
    //
    hr = GetSecur32Handle(&hModule);
    BAIL_ON_FAILURE(hr);

    pGetComputerObjectName = (GETCOMPUTEROBJECTNAME)GetProcAddress(hModule, "GetComputerObjectNameW");
    if (!pGetComputerObjectName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Get length of buffer to be allocated
    //
    uLength = 0;
    (*pGetComputerObjectName)(NameFullyQualifiedDN,
                              NULL,
                              &uLength);

    if (uLength > 0)
    {
        //
        // Allocated memory and do the real work
        //
        pszComputerName = (PWSTR)AllocADsMem(uLength * sizeof(WCHAR));
        if (!pszComputerName)
        {
            RRETURN(E_OUTOFMEMORY);
        }

        if ((*pGetComputerObjectName)(NameFullyQualifiedDN,
                                      pszComputerName,
                                      &uLength))
        {

            hr = ADsAllocString(pszComputerName, bstrComputerName);
            BAIL_ON_FAILURE(hr);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

error:
    if (pszComputerName)
    {
        FreeADsMem(pszComputerName);
    }

    RRETURN(hr);
}

HRESULT
CADSystemInfo::get_SiteName(
    BSTR * bstrSiteName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrSiteName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find client site
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, 0, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->ClientSiteName, bstrSiteName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}

HRESULT
CADSystemInfo::get_DomainShortName(
    BSTR * bstrDomainName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrDomainName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find domain short name
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, DS_RETURN_FLAT_NAME, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->DomainName, bstrDomainName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}


HRESULT
CADSystemInfo::get_DomainDNSName(
    BSTR * bstrDomainDNSName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrDomainDNSName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find domain DNS name
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->DomainName, bstrDomainDNSName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}

HRESULT
CADSystemInfo::get_ForestDNSName(
    BSTR * bstrForestDNSName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrForestDNSName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find forest DNS name
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, 0, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->DnsForestName, bstrForestDNSName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}


HRESULT
CADSystemInfo::get_PDCRoleOwner(
    BSTR * bstrPDCRoleOwner
    )
{
    RRETURN(GetfSMORoleOwner(DEFAULT_NC, bstrPDCRoleOwner));
}

HRESULT
CADSystemInfo::get_SchemaRoleOwner(
    BSTR * bstrSchemaRoleOwner
    )
{
    RRETURN(GetfSMORoleOwner(SCHEMA_NC, bstrSchemaRoleOwner));
}

HRESULT
CADSystemInfo::get_IsNativeMode(
    VARIANT_BOOL *retVal
    )
{
    IADs *pADs = NULL;
    IDirectoryObject *pDir = NULL;
    HRESULT hr;
    ADS_ATTR_INFO *pAttrInfo = NULL;
    DWORD  dwReturn = 0;
    LPWSTR  pAttrNames[] = {L"nTMixedDomain" };
    DWORD  dwNumAttr = sizeof(pAttrNames)/sizeof(LPWSTR);

    //
    // Validate parameters
    //
    if (!retVal)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    hr = GetNCHead(DEFAULT_NC,  &pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(IID_IDirectoryObject, (void**) &pDir);
    BAIL_ON_FAILURE(hr);

    //
    // Get the nTMixedDomain attribute
    //
    hr = pDir->GetObjectAttributes(pAttrNames,
                                   dwNumAttr,
                                   &pAttrInfo,
                                   &dwReturn);
    BAIL_ON_FAILURE(hr);

    if (dwReturn == 0)
    {
        BAIL_ON_FAILURE(hr=E_FAIL);
    }

    *retVal = pAttrInfo->pADsValues->Boolean == FALSE ? VARIANT_TRUE : VARIANT_FALSE;

error:

    //
    // Clean-up
    //
    if (pAttrInfo)
        FreeADsMem(pAttrInfo);

    if (pDir)
        pDir->Release();

    if (pADs)
        pADs->Release();

    return hr;
}


HRESULT
CADSystemInfo::GetAnyDCName(
    BSTR *bstrDCName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrDCName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find DC name
    //
    err = (*pDsGetDcName)(NULL, NULL, NULL, NULL, 0, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(&pdcInfo->DomainControllerName[2], bstrDCName); // skip "\\"
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}

HRESULT
CADSystemInfo::GetDCSiteName(
    BSTR bstrDCName,
    BSTR *bstrSiteName
    )
{
    DOMAIN_CONTROLLER_INFO *pdcInfo = NULL;
    DSGETDCNAME pDsGetDcName;
    DWORD err;
    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    if (!bstrDCName|| !bstrSiteName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to DsGetDcName
    //
    pDsGetDcName = GetDsGetDcName();
    if (! pDsGetDcName)
    {
        RRETURN(E_FAIL);
    }

    //
    // Call DsGetDcName to find DC site name
    //
    err = (*pDsGetDcName)(bstrDCName, NULL, NULL, NULL, 0, &pdcInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString(pdcInfo->DcSiteName, bstrSiteName);
    BAIL_ON_FAILURE(hr);

error:
    if (pdcInfo)
    {
        NetApiBufferFree(pdcInfo);
    }
    RRETURN(hr);
}


HRESULT
CADSystemInfo::RefreshSchemaCache(
    void
    )
{
    IADs *pRootDSE = NULL;
    VARIANT var;
    HRESULT hr;

    VariantInit( &var );

    hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void**) &pRootDSE);
    BAIL_ON_FAILURE(hr);

    V_VT(&var) = VT_I4;
    V_I4(&var) = 1;

    hr = pRootDSE->Put(LDAP_OPATT_SCHEMA_UPDATE_NOW_W, var);
    BAIL_ON_FAILURE(hr);

    hr = pRootDSE->SetInfo();
    BAIL_ON_FAILURE(hr);

error:
    VariantClear( &var );

    if (pRootDSE)
        pRootDSE->Release();

    RRETURN(hr);
}

HRESULT
CADSystemInfo::GetTrees(
    VARIANT *pVar
    )
{
    PDS_DOMAIN_TRUSTS pDomains = NULL;
    DSENUMERATEDOMAINTRUSTS pDsEnumerateDomainTrusts;
    SAFEARRAYBOUND rgsabound[1];
    SAFEARRAY *psa = NULL;
    DWORD dwErr = 0;
    ULONG i, lCount;
    HRESULT hr = S_OK;
    DWORD count;

    //
    // Validate parameters
    //
    if (!pVar )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get function pointer to NetEnumerateTrustedDomainsEx
    //
    pDsEnumerateDomainTrusts = GetDsEnumerateDomainTrusts();
    if (! pDsEnumerateDomainTrusts)
    {
        RRETURN(E_FAIL);
    }

    //
    // Enumerate all trusted domains
    //
    dwErr = (*pDsEnumerateDomainTrusts)(
                NULL,
                DS_DOMAIN_PRIMARY
                | DS_DOMAIN_IN_FOREST
                | DS_DOMAIN_DIRECT_OUTBOUND,
                &pDomains,
                &lCount
                );

    if (dwErr) {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    BAIL_ON_FAILURE(hr);

    //
    // Count number of domains that are tree roots
    //
    count = 0;
    for(i = 0; i < lCount; i++)
    {
        if (pDomains[i].Flags & DS_DOMAIN_TREE_ROOT)
        {
            ASSERT(pDomains[i].DnsDomainName);

            count++;
        }
    }

    //
    // We have no tree roots - we must be on an NT4 domain, return
    // an empty variant
    //
    if (count == 0)
    {
        VariantClear(pVar);
        V_VT(pVar) = VT_EMPTY;
        RRETURN(S_OK);
    }

    //
    // Create Safe Array
    //
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = count;

    psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
    if (! psa)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    VariantClear(pVar);
    V_VT(pVar) = VT_VARIANT|VT_ARRAY;
    V_ARRAY(pVar) = psa;

    VARIANT varItem;

    //
    // Now iterate through each returned element and
    // add it to the variant array if it is a tree root
    //
    count = 0;
    for(i = 0; i < lCount; i++)
    {
        if (pDomains[i].Flags & DS_DOMAIN_TREE_ROOT)
        {
            VariantInit(&varItem);

            V_VT(&varItem) = VT_BSTR;
            hr = ADsAllocString(pDomains[i].DnsDomainName, &(V_BSTR(&varItem)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement(psa, (long *) &count, &varItem);
            VariantClear(&varItem);

            BAIL_ON_FAILURE(hr);
            count++;
        }
    }

error:
    if (pDomains)
        NetApiBufferFree(pDomains);

    if (FAILED(hr) && psa)
        SafeArrayDestroy(psa);

    return hr;
}


HRESULT
CADSystemInfo::GetNCHead(
    LPTSTR szNCName,
    IADs **pADs
    )
{
    WCHAR szPathName[MAX_PATH];
    VARIANT var;
    HRESULT hr;
    IADs *pRootDSE = NULL;

    //
    // Open RootDSE and query for NC object name
    //
    hr = ADsGetObject(L"LDAP://RootDSE", IID_IADs, (void**) &pRootDSE );
    BAIL_ON_FAILURE(hr);

    hr = pRootDSE->Get(szNCName, &var);
    BAIL_ON_FAILURE(hr);

    //
    // Build LDAP://<naming context>
    //
    wcscpy(szPathName, L"LDAP://");
    wcscat(szPathName, V_BSTR(&var));

    //
    // Get pointer to NC object
    //
    hr = ADsGetObject(szPathName, IID_IADs, (void**) pADs);
    BAIL_ON_FAILURE(hr);

error:
   if (pRootDSE)
   {
       pRootDSE->Release();
   }

   RRETURN(hr);

}

HRESULT
CADSystemInfo::GetfSMORoleOwner(
    LPTSTR szNCName,
    BSTR *bstrRoleOwner
    )
{
    IADs             *pADs = NULL;
    IDirectoryObject *pDir = NULL;
    ADS_ATTR_INFO    *pAttrInfo = NULL;
    LPWSTR           pAttrNames[] = {L"fSMORoleOwner" };
    DWORD            dwNumAttrs = sizeof(pAttrNames)/sizeof(LPWSTR);
    HRESULT          hr;
    DWORD            dwReturn;

    //
    // Validate parameters
    //
    if (!bstrRoleOwner )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    hr = GetNCHead(szNCName, &pADs);
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(IID_IDirectoryObject, (void**) &pDir);
    BAIL_ON_FAILURE(hr);

    //
    // Get the fSMORoleOwner
    //
    hr = pDir->GetObjectAttributes(pAttrNames,
                                   dwNumAttrs,
                                   &pAttrInfo,
                                   &dwReturn);
    BAIL_ON_FAILURE(hr);

    if (dwReturn == 0)
    {
        BAIL_ON_FAILURE(hr=E_FAIL);
    }

    hr = ADsAllocString(pAttrInfo->pADsValues->CaseIgnoreString, bstrRoleOwner);
    BAIL_ON_FAILURE(hr);

error:

    //
    // Clean-up
    //
    if (pDir)
        pDir->Release();

    if (pADs)
        pADs->Release();

    FreeADsMem(pAttrInfo);

    RRETURN(hr);
}

HRESULT
CADSystemInfo::GetSecur32Handle(
    HINSTANCE *pHandle
    )
{
    if(!_Secur32LoadAttempted)
    {
        ENTER_SYSTEMAPI_CRITICAL_SECTION()
            
        if (! _Secur32LoadAttempted)
        {
            _hSecur32 = LoadLibraryHelper(__TEXT("secur32.dll"));
            _Secur32LoadAttempted = TRUE;
        }

        LEAVE_SYSTEMAPI_CRITICAL_SECTION()

    }

    *pHandle = _hSecur32;
    if (_hSecur32)
        RRETURN(S_OK);
    else
        RRETURN(E_FAIL);
}


DSGETDCNAME
CADSystemInfo::GetDsGetDcName(
    void
    )
{
    DSGETDCNAME pDsGetDcName = NULL;

    if(!_NetApi32LoadAttempted)
    {
        ENTER_SYSTEMAPI_CRITICAL_SECTION()
        if (! _NetApi32LoadAttempted)
        {
            _hNetApi32 = LoadLibraryHelper(__TEXT("netapi32.dll"));
            _NetApi32LoadAttempted = TRUE;
        }
        LEAVE_SYSTEMAPI_CRITICAL_SECTION()
    }

    if (_hNetApi32)
    {
        pDsGetDcName = (DSGETDCNAME)GetProcAddress(_hNetApi32, "DsGetDcNameW");
    }

    return pDsGetDcName;
}

DSENUMERATEDOMAINTRUSTS
CADSystemInfo::GetDsEnumerateDomainTrusts(
    void
    )
{
    DSENUMERATEDOMAINTRUSTS pDsEnumerateDomainTrusts = NULL;

    if(!_NetApi32LoadAttempted)
    {
        ENTER_SYSTEMAPI_CRITICAL_SECTION()
        
        if (! _NetApi32LoadAttempted)
        {
            _hNetApi32 = LoadLibraryHelper(__TEXT("netapi32.dll"));
            _NetApi32LoadAttempted = TRUE;
        }

        LEAVE_SYSTEMAPI_CRITICAL_SECTION()
    }

    if (_hNetApi32)
    {
        pDsEnumerateDomainTrusts = (DSENUMERATEDOMAINTRUSTS)
                    GetProcAddress(
                        _hNetApi32,
                        "DsEnumerateDomainTrustsW"
                        );
    }

    return pDsEnumerateDomainTrusts;
}


STDMETHODIMP
CADSystemInfoCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID * ppv
    )
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CADSystemInfo::CreateADSystemInfo(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\putget.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  putget.cxx
//
//  Contents:
//
//
//  History:   01-14-97  krishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


STDMETHODIMP
CLDAPGenObject::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // In case some person decides to randomize us with a NULL
    //
    if (!pvProp || !bstrName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // For backward compatibility
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // this will make sure we do not break existing code
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    if ( ldapSrcObjects.dwCount == 1 ) {

        hr = LdapTypeToVarTypeCopy(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects.pLdapObjects,
                 dwSyntaxId,
                 pvProp
                 );
    } else {

        hr = LdapTypeToVarTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 ldapSrcObjects,
                 dwSyntaxId,
                 pvProp
                 );
    }
    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPGenObject::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    BOOL fIndexValid = TRUE;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // In case some person decides to randomize us with a NULL
    //
    if (!bstrName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) & VT_VARIANT) &&  V_ISARRAY(pvProp) && V_ISBYREF(pvProp)){

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else if ((V_VT(pvProp) &  VT_VARIANT) &&  V_ISARRAY(pvProp)) {

        hr  = ConvertSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        // returns E_FAIL if *pvProp is invalid
        if (hr == E_FAIL)
            hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }
    else {

        dwNumValues = 1;
    }

    if (pvProp == NULL) {
        dwSyntaxId = LDAPTYPE_UNKNOWN;
    }
    else {

        hr = GetLdapSyntaxFromVariant(
                 pvProp,
                 &dwSyntaxId,
                 _pszLDAPServer,
                 bstrName,
                 _Credentials,
                 _dwPort
                 );

        BAIL_ON_FAILURE(hr);

        if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
        {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (!_wcsicmp(bstrName, L"ntSecurityDescriptor")){
        dwSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;
    }


#if 0
    //
    // check if this is a legal property for this object,
    //
    // No Schema??
    // mattrim 5/16/00 - doesn't matter if no schema since
    // this isn't getting built, it's #if'ed out
    //

    hr = ValidatePropertyinCache(
                szLDAPTreeName,
                _ADsClass,
                bstrName,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);
#endif

    //
    // check if the variant maps to the syntax of this property
    //

    if ( dwNumValues > 0 )
    {
        hr = VarTypeToLdapTypeCopyConstruct(
                 _pszLDAPServer,
                 _Credentials,
                 dwSyntaxId,
                 pvProp,
                 dwNumValues,
                 &ldapDestObjects
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);

        // Set the flag as the dwIndex is not valid in this case
        fIndexValid = FALSE;
    }

    //
    // Now update the property in the cache
    //

    if (fIndexValid) {
        // do an optimized put
        hr = _pPropertyCache->putproperty(
                                  dwIndex,
                                  PROPERTY_UPDATE,
                                  dwSyntaxId,
                                  ldapDestObjects
                                  );
    } else {

        // Index is not valid so let the cache figure it out.
        hr = _pPropertyCache->putproperty(
                                  bstrName,
                                  PROPERTY_UPDATE,
                                  dwSyntaxId,
                                  ldapDestObjects
                                  );
    }

    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPGenObject::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwStatus = 0;
    LDAPOBJECTARRAY ldapSrcObjects;

    LDAPOBJECTARRAY_INIT(ldapSrcObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // For those who know no not what they do
    //
    if (!pvProp || !bstrName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if ( GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // this will make sure we do not break existing code
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

    } else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwStatus,
                    &ldapSrcObjects
                    );

        // this will make sure we do not break existing code
        if (!ldapSrcObjects.pLdapObjects && SUCCEEDED(hr)) {
            hr = E_ADS_PROPERTY_NOT_FOUND;
        }

    }

    BAIL_ON_FAILURE(hr);

    //
    // translate the Ldap objects to variants
    //

    hr = LdapTypeToVarTypeCopyConstruct(
                _pszLDAPServer,
                _Credentials,
                ldapSrcObjects,
                dwSyntaxId,
                pvProp
                );
    BAIL_ON_FAILURE(hr);

error:
    LdapTypeFreeLdapObjects( &ldapSrcObjects );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CLDAPGenObject::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwFlags = 0;

    DWORD dwIndex = 0;
    LDAPOBJECTARRAY ldapDestObjects;

    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    BOOL fIndexValid = TRUE;

    LDAPOBJECTARRAY_INIT(ldapDestObjects);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    //
    // In case some person decides to randomize us with a NULL
    //
    if (!bstrName) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    switch ( lnControlCode ) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = PROPERTY_DELETE;
        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = PROPERTY_UPDATE;
        break;

    case ADS_PROPERTY_APPEND:
        dwFlags = PROPERTY_ADD;
        break;

    case ADS_PROPERTY_DELETE:
        dwFlags = PROPERTY_DELETE_VALUE;
        break;


    default:
        RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);
    }


    if ( dwFlags != PROPERTY_DELETE )
    {
        //
            // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
            // We should dereference a VT_BYREF|VT_VARIANT once and see
            // what's inside.
            //
            pvProp = &vProp;

            if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
                pvProp = V_VARIANTREF(&vProp);
            }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
            (V_VT(pvProp) ==  (VT_VARIANT|VT_ARRAY))) {

            hr  = ConvertSafeArrayToVariantArray(
                      *pvProp,
                      &pVarArray,
                      &dwNumValues
                      );
            // returns E_FAIL if *pvProp is invalid
            if (hr == E_FAIL)
                hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        } else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }


        if (pvProp == NULL) {
            //
            // If array is empty, set dwSyntaxId to Unknown. This value will not be used
            //
            dwSyntaxId = LDAPTYPE_UNKNOWN;
        }
        else {

            hr = GetLdapSyntaxFromVariant(
                     pvProp,
                     &dwSyntaxId,
                     _pszLDAPServer,
                     bstrName,
                     _Credentials,
                     _dwPort
                     );

            BAIL_ON_FAILURE(hr);

            if ( dwSyntaxId == LDAPTYPE_UNKNOWN )
            {
                //
                // If array is empty, set dwSyntaxId to Unknown. This value will
                // not be used
                //
                hr = E_ADS_CANT_CONVERT_DATATYPE;
                BAIL_ON_FAILURE(hr);
            }
        }

        //
        // check if the variant maps to the syntax of this property
        //

        if ( dwNumValues > 0 )
        {
            hr = VarTypeToLdapTypeCopyConstruct(
                     _pszLDAPServer,
                     _Credentials,
                     dwSyntaxId,
                     pvProp,
                     dwNumValues,
                     &ldapDestObjects
                     );
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {

        hr = _pPropertyCache->addproperty( bstrName );

        //
        // If dwNumValues == 0 ( delete the property ) but couldn't find
        // the property, or if the add operation fails, return the error.
        //
        BAIL_ON_FAILURE(hr);
        fIndexValid = FALSE;
    }

    //
    // Now update the property in the cache
    //
    if (fIndexValid) {

        // do an optimized put property with the index
        hr = _pPropertyCache->putproperty(
                                  dwIndex,
                                  dwFlags,
                                  dwSyntaxId,
                                  ldapDestObjects
                                  );
    } else {

        // we need to use the property name in this case
        hr = _pPropertyCache->putproperty(
                                  bstrName,
                                  dwFlags,
                                  dwSyntaxId,
                                  ldapDestObjects
                                  );
    }

    BAIL_ON_FAILURE(hr);

error:

    LdapTypeFreeLdapObjects( &ldapDestObjects );

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\servtype.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#define ENTER_ROOTDSE_CRITSECT()  EnterCriticalSection(&g_RootDSECritSect)
#define LEAVE_ROOTDSE_CRITSECT()  LeaveCriticalSection(&g_RootDSECritSect)

CRITICAL_SECTION  g_RootDSECritSect;

typedef struct _rootdselist {
   LPWSTR pszLDAPServer;
   BOOL fNTDS;
   struct _rootdselist *pNext;
} ROOTDSELIST, *PROOTDSELIST;

PROOTDSELIST gpRootDSEList = NULL;

static DWORD dwRootDSECount = 0;

BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    );


HRESULT
ReadServerType(
    LPWSTR pszLDAPServer,
    CCredentials* pCredentials,
    BOOL * pfNTDS
    )
{

    LPTSTR *aValues = NULL;
    DWORD nCount = 0;
    HRESULT hr = S_OK;

    PROOTDSELIST pTemp = NULL;
    PROOTDSELIST pNewNode = NULL;
    BOOL fNTDS = FALSE;
    CCredentials localCredentials(NULL, NULL, 0);

    ENTER_ROOTDSE_CRITSECT();

    //
    // Let's see how many times we called this guy
    //

    dwRootDSECount++;

    pTemp = gpRootDSEList;

    while (pTemp) {

        if (EquivalentServers(pszLDAPServer, pTemp->pszLDAPServer)){

            *pfNTDS = pTemp->fNTDS;

            LEAVE_ROOTDSE_CRITSECT();

            RRETURN(hr);
       }

       pTemp = pTemp->pNext;

    }

    LEAVE_ROOTDSE_CRITSECT();

    if (pCredentials) {
        localCredentials = *pCredentials;
    }

    hr = LdapReadAttribute(
                pszLDAPServer,
                NULL,
                TEXT("SecurityMode"),
                &aValues,
                (int *)&nCount,
                localCredentials,
                (unsigned long)USE_DEFAULT_LDAP_PORT
                );
    if (SUCCEEDED(hr)) {

        if (!aValues || aValues[0] == NULL) {

            fNTDS = TRUE;

        }else if (!_wcsicmp(aValues[0], L"NT")) {

            fNTDS = TRUE;
        }else {

            fNTDS = FALSE;
        }
    }else {

        fNTDS = TRUE;
        hr = S_OK;

    }


    ENTER_ROOTDSE_CRITSECT();

    pTemp =  gpRootDSEList;

    while (pTemp) {

        if (EquivalentServers(pszLDAPServer, pTemp->pszLDAPServer)) {
            //
            // Found a match -looks like someone has come in before us
            //

            *pfNTDS = pTemp->fNTDS;

            goto exit;
        }

        pTemp = pTemp->pNext;

    }

    pNewNode = (PROOTDSELIST)AllocADsMem(sizeof(ROOTDSELIST));

    if (!pNewNode) {

        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pNewNode->pNext = gpRootDSEList;


    pNewNode->pszLDAPServer = AllocADsStr(pszLDAPServer);
    //
    // pszLDAPServer might be NULL, in which case NULL is the
    // expected return value from the alloc.
    //
    if ((!(pNewNode->pszLDAPServer)) && pszLDAPServer) {

        FreeADsMem(pNewNode);
    
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pNewNode->fNTDS = fNTDS;

    gpRootDSEList = pNewNode;

    *pfNTDS =  fNTDS;

exit:

    LEAVE_ROOTDSE_CRITSECT();

    if (aValues) {

        LdapValueFree(aValues);
    }

    RRETURN(hr);
}



BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    )
{
    if (!pszTargetServer && !pszSourceServer) {
        return(TRUE);
    }

    if (pszTargetServer && pszSourceServer) {
#ifdef WIN95
        if (!_wcsicmp(pszTargetServer, pszSourceServer)) { 
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszTargetServer,
                -1,
                pszSourceServer,
                -1
                ) == CSTR_EQUAL ) {
#endif

            return(TRUE);
        }
    }

    return(FALSE);
}


VOID
FreeServerType(
    )
{
    PROOTDSELIST pTemp = NULL;
    PROOTDSELIST pNext = NULL;

    ENTER_ROOTDSE_CRITSECT();

    pTemp = gpRootDSEList;

    while (pTemp) {

        pNext = pTemp->pNext;

        if (pTemp->pszLDAPServer) {

            FreeADsStr(pTemp->pszLDAPServer);
            pTemp->pszLDAPServer = NULL;

        }

        FreeADsMem(pTemp);

        pTemp = NULL;

        pTemp = pNext;

    }

    LEAVE_ROOTDSE_CRITSECT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\umi2ldap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       umi2ldap.cxx
//
//  Contents: File containing the implemenation of the conversion routines
//       that convert the user given UMI values to ldap values that can 
//       subsequently be cached if required.
//
//  History:    02-17-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"


//+---------------------------------------------------------------------------
// Function:   UmiTypeLPWSTRToLdapString
//
// Synopsis:   Converts a string value to an equivalent ldap value.
//
// Arguments:  Self explanatory
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   LDAPOBJECT_STRING(pLdaDestObject)
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeLPWSTRToLdapString(
    LPWSTR pszSourceString,
    PLDAPOBJECT pLdapDestObject
    )
{
    ADsAssert(pszSourceString);

    //
    // We should not have NULL values but it is a good idea to check.
    //
    if (pszSourceString) {
        LDAPOBJECT_STRING(pLdapDestObject) = AllocADsStr(pszSourceString);

        if (!LDAPOBJECT_STRING(pLdapDestObject)) {
            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeBoolean
//
// Synopsis:   Converts a bool value to an ldap boolean value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   LDAPOBJECT_STRING(pLdaDestObject) appropriately.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeBoolean(
    BOOL fBool,
    PLDAPOBJECT pLdapDestObject
    )
{
    if (fBool) {
        LDAPOBJECT_STRING(pLdapDestObject) = AllocADsStr(L"TRUE");
    } 
    else {
        LDAPOBJECT_STRING(pLdapDestObject) = AllocADsStr(L"FALSE");
    }

    if (!LDAPOBJECT_STRING(pLdapDestObject)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyI4
//
// Synopsis:   Converts a long (I4) value to an equivalent ldap value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   LDAPOBJECT_STRING(pLdaDestObject) contains the new values.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyI4(
    LONG lVal,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    ADsAssert(pLdapDestObject);

    _ltot(lVal, Buffer, 10);

    LDAPOBJECT_STRING(pLdapDestObject) = AllocADsStr(Buffer);
    
    if (!LDAPOBJECT_STRING(pLdapDestObject)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeOctetString
//
// Synopsis:   Converts an UmiOctetString to an ldap ber value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject is updated suitably with the ber value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeOctetString(
    UMI_OCTET_STRING umiOctetStr,
    PLDAPOBJECT pLdapDestObject
    )
{
    DWORD dwLength = 0;

    if (umiOctetStr.lpValue) {
        dwLength = umiOctetStr.uLength;

        LDAPOBJECT_BERVAL(pLdapDestObject) = (struct berval *) 
            AllocADsMem(dwLength + sizeof(struct berval));

        if (!LDAPOBJECT_BERVAL(pLdapDestObject)) {
            RRETURN(E_OUTOFMEMORY);
        }

        //
        // Set the pointer to data and the length in the dest object.
        //
        LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwLength;
        LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = (CHAR *) 
            ( (LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) 
                      + sizeof(struct berval));
       
        memcpy(
            LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
            umiOctetStr.lpValue,
            dwLength
            );
    } // umiOctetStr.lpValue

    RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeSecurityDescriptor.
//
// Synopsis:   Converts a UmiComObject that is an SD to an equivalent
//          ldap binary blob.
//
// Arguments:  umiComObject      -  Has the IADsSecDesc to convert.
//             pLdapDestObjects  -  Return value of encoded ldap data.
//             pCreds            -  Credentials to use for conversion.
//             pszServerName     -  ServerName associated with SD.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject is updated suitably with the ber value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopySecurityDescriptor(
    UMI_COM_OBJECT umiComObject,
    PLDAPOBJECT pLdapDestObject,
    CCredentials *pCreds,
    LPWSTR pszServerName
    )
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pBinarySecDesc = NULL;
    IUnknown *pUnk = (IUnknown *) umiComObject.pInterface;
    IADsSecurityDescriptor*  pADsSecDesc = NULL;
    CCredentials creds;
    DWORD dwSDLength = 0;

    //
    // QI for the IADsSecDesc, that way we can be sure of the interface.
    //
    hr = pUnk->QueryInterface(
             IID_IADsSecurityDescriptor,
             (void **) &pADsSecDesc
             );
    BAIL_ON_FAILURE(hr);
    
    //
    // Update the credentials if needed.
    //
    if (pCreds) {
        creds = *pCreds;
    }

    //
    // Call the helper that does the conversion in activeds.dll
    //
    hr = ConvertSecurityDescriptorToSecDes(
             pszServerName,
             creds,
             pADsSecDesc,
             &pBinarySecDesc,
             &dwSDLength,
             TRUE // NT style SD.
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now we need to copy over the data into the ldap struct.
    //
    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwSDLength);

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwSDLength;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = 
        (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) 
                  + sizeof(struct berval));

    memcpy( 
        LDAPOBJECT_BERVAL_VAL(pLdapDestObject), 
        pBinarySecDesc,
        dwSDLength
        );

error:

    if (pBinarySecDesc) {
        FreeADsMem(pBinarySecDesc);
    }

    if (pADsSecDesc) {
        pADsSecDesc->Release();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyDNWithBinary.
//
// Synopsis:   Converts a UmiComObject that is DNWithBinary obj to 
//          and equivalent ldap data.
//
// Arguments:  umiComObject      -  Has the IADsDNWithBinary to convert.
//             pLdapDestObjects  -  Return value of encoded ldap data.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject is updated suitably with the ber value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyDNWithBinary(
    UMI_COM_OBJECT umiComObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IUnknown * pUnk = (IUnknown *)umiComObject.pInterface;
    VARIANT vVar;

    VariantInit(&vVar);

    vVar.vt = VT_DISPATCH;

    hr = pUnk->QueryInterface(IID_IDispatch, (void **) &vVar.pdispVal);
    BAIL_ON_FAILURE(hr);

    //
    // Call the var2ldap conversion helper to do all the hard work !.
    //
    hr = VarTypeToLdapTypeDNWithBinary(
             &vVar,
             pLdapDestObject
             );

error:

    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyDNWithString.
//
// Synopsis:   Converts a UmiComObject that is DNWithString obj to 
//          and equivalent ldap data.
//
// Arguments:  umiComObject      -  Has the IADsDNWithString to convert.
//             pLdapDestObjects  -  Return value of encoded ldap data.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject is updated suitably with the ber value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyDNWithString(
    UMI_COM_OBJECT umiComObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IUnknown * pUnk = (IUnknown *)umiComObject.pInterface;
    VARIANT vVar;

    VariantInit(&vVar);

    vVar.vt = VT_DISPATCH;

    hr = pUnk->QueryInterface(IID_IDispatch, (void **) &vVar.pdispVal);
    BAIL_ON_FAILURE(hr);

    //
    // Call the var2ldap conversion helper to do all the hard work !.
    //
    hr = VarTypeToLdapTypeDNWithString(
             &vVar,
             pLdapDestObject
             );

error:

    VariantClear(&vVar);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyI8
//
// Synopsis:   Convert an int64 value to the corresponding ldap value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject contains the encoded large integer object.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyI8(
    __int64 int64Val,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    if (!swprintf (Buffer, L"%I64d", int64Val))
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

    LDAPOBJECT_STRING(pLdapDestObject) = /*(LPTSTR)*/ AllocADsStr( Buffer );

    if (!LDAPOBJECT_STRING(pLdapDestObject)) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

error :

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyUTCTime
//
// Synopsis:   Convert a SYSTEMTIME object to the corresponding ldap value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject contains the encoded utc time value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyUTCTime(
    SYSTEMTIME sysTimeObj,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;
    ADSVALUE adsValue;

    adsValue.dwType = ADSTYPE_UTC_TIME;
    adsValue.UTCTime = sysTimeObj;

    //
    // Use the helper to convert the value appropriately.
    //
    hr = AdsTypeToLdapTypeCopyTime(
             &adsValue,
             pLdapDestObject,
             &dwSyntaxId
             );

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopyGeneralizedTime
//
// Synopsis:   Converts a SystemTime value to a ldap generalized time value.
//
// Arguments:  Self explanatory
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObject contains the encoded generalized time value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopyGeneralizedTime(
    SYSTEMTIME sysTimeObj,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;
    ADSVALUE adsValue;

    adsValue.dwType = ADSTYPE_UTC_TIME;
    adsValue.UTCTime = sysTimeObj;

    //
    // Use the helper to convert the value appropriately.
    //
    hr = AdsTypeToLdapTypeCopyGeneralizedTime(
             &adsValue,
             pLdapDestObject,
             &dwSyntaxId
             );

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   UmiTypeEnumToLdapTypeEnum
//
// Synopsis:   Converts the passed in umiType to the equivalent ldapType.
//          Note that the conversion is just for the type and not the actual
//          data itself. Example UMI_TYPE_I4 to LDAPTYPE_INTEGER.
//
// Arguments:  ulUmiType       -   Umi type to convert.
//             pdwSyntax       -   Return ldap syntax.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   *pdwSyntax with appropriate value.
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeEnum(
    ULONG  ulUmiType,
    PDWORD pdwSyntax
    )
{
    HRESULT hr = S_OK;

    switch (ulUmiType) {
    
    case UMI_TYPE_I4 :
        *pdwSyntax = LDAPTYPE_INTEGER;
        break;

    case UMI_TYPE_I8 :
        *pdwSyntax = LDAPTYPE_INTEGER8;
        break;

    case UMI_TYPE_SYSTEMTIME :
        //
        // What about utc Time ?
        //
        *pdwSyntax = LDAPTYPE_GENERALIZEDTIME;
        break;

    case UMI_TYPE_BOOL :
        *pdwSyntax = LDAPTYPE_BOOLEAN;
        break;

    case UMI_TYPE_IUNKNOWN :
        //
        // How about the other IUnknowns ?
        //
        *pdwSyntax = LDAPTYPE_SECURITY_DESCRIPTOR;
        break;

    case UMI_TYPE_LPWSTR :
        *pdwSyntax = LDAPTYPE_CASEIGNORESTRING;
        break;

    case UMI_TYPE_OCTETSTRING :
        *pdwSyntax = LDAPTYPE_OCTETSTRING;
        break;

    case UMI_TYPE_UNDEFINED:
    case UMI_TYPE_NULL :
    case UMI_TYPE_I1 :
    case UMI_TYPE_I2 :
    case UMI_TYPE_UI1 :
    case UMI_TYPE_UI2 :
    case UMI_TYPE_UI4 :
    case UMI_TYPE_UI8 :
    case UMI_TYPE_R4 :
    case UMI_TYPE_R8 :
    case UMI_TYPE_FILETIME :
    case UMI_TYPE_IDISPATCH :
    case UMI_TYPE_VARIANT :
    case UMI_TYPE_UMIARRAY :
    case UMI_TYPE_DISCOVERY :
    case UMI_TYPE_DEFAULT :
    default:
        *pdwSyntax = (DWORD) -1;
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
// Function:   UmiTypeToLdapTypeCopy
//
// Synopsis:   Helper routine to convert ldap values to the required UMI
//            data type. 
//
// Arguments:  umiPropArray     - input UMI data.
//             ulFlags          - flags indicating type of operation.
//             pLdapDestObjects - Ptr to hold the output from routine.
//             dwLdapSyntaxId   - ref to dword.
//             fUtcTime         - optional defaulted to False.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   pLdapDestObjects to point to valid data.
//             dwLdapSyntaxId with the ldap syntax id for the data type (this
//             will enable us to return the data correctly to the user).
//
//----------------------------------------------------------------------------
HRESULT
UmiTypeToLdapTypeCopy(
    UMI_PROPERTY_VALUES umiPropArray,
    ULONG ulFlags,
    LDAPOBJECTARRAY *pLdapDestObjects,
    DWORD &dwLdapSyntaxId,
    CCredentials *pCreds,
    LPWSTR pszServerName,
    BOOL fUtcTime
    )
{
    HRESULT hr = S_OK;
    ULONG ulUmiType, ulCount, ulCtr;
    PUMI_PROPERTY pUmiProp;

    //
    // Internal routine so an assert should be enough.
    //
    ADsAssert(pLdapDestObjects);

    //
    // Initalize count on ldapobjects to zero and 
    // default is string values for the contents.
    //
    pLdapDestObjects->dwCount = 0;
    pLdapDestObjects->fIsString = TRUE;

    //
    // Verify that we have some valid data.
    //
    if (!umiPropArray.pPropArray || (umiPropArray.uCount != 1)) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    pUmiProp = umiPropArray.pPropArray;
    ulUmiType = pUmiProp->uType;
    ulCount = pUmiProp->uCount;

    if ( ulCount == 0 ) {
        pLdapDestObjects->dwCount = 0;
        pLdapDestObjects->pLdapObjects = NULL;
        RRETURN(S_OK);
    }

    pLdapDestObjects->pLdapObjects =
        (PLDAPOBJECT)AllocADsMem( ulCount * sizeof(LDAPOBJECT));

    if (pLdapDestObjects->pLdapObjects == NULL)
        RRETURN(E_OUTOFMEMORY);

    //
    // If we are here, then pUmiValue has to be valid.
    //
    if (!pUmiProp->pUmiValue) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    for (ulCtr =0; ulCtr < ulCount; ulCtr++) {
        //
        // Need to go through and convert each of the values.
        //
        switch (ulUmiType) {
        //
        // Call appropriate routine based on type.
        //
        case UMI_TYPE_I1 :
        case UMI_TYPE_I2 :

            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;

        case UMI_TYPE_I4 :

            if (!pUmiProp->pUmiValue->lValue) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            hr = UmiTypeToLdapTypeCopyI4(
                     pUmiProp->pUmiValue->lValue[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_INTEGER;
            break;
            
        case UMI_TYPE_I8 :

            if (!pUmiProp->pUmiValue->nValue64) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            
            hr = UmiTypeToLdapTypeCopyI8(
                     pUmiProp->pUmiValue->nValue64[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_INTEGER8;
            break;

        case UMI_TYPE_UI1 :
        case UMI_TYPE_UI2 :
        case UMI_TYPE_UI4 :
        case UMI_TYPE_UI8 :
        case UMI_TYPE_R4  :
        case UMI_TYPE_R8  :
            //
            // We do not handle any of the unsigned data types or 
            // the real data types..
            //
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;

        case UMI_TYPE_SYSTEMTIME :

            if (!pUmiProp->pUmiValue->sysTimeValue) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            
            //
            // Need to use the special info to see if this is an UTC Time
            // value or if this is a Generalized time value - GenTime is
            // always the default value though.
            //
            if (fUtcTime) {
                hr = UmiTypeToLdapTypeCopyUTCTime(
                         pUmiProp->pUmiValue->sysTimeValue[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr
                         );
                dwLdapSyntaxId = LDAPTYPE_UTCTIME;
            }
            else {
                hr = UmiTypeToLdapTypeCopyGeneralizedTime(
                         pUmiProp->pUmiValue->sysTimeValue[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr
                         );
                dwLdapSyntaxId = LDAPTYPE_GENERALIZEDTIME;
            }
            
            break;

        case UMI_TYPE_BOOL :

            if (!pUmiProp->pUmiValue->bValue) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            hr = UmiTypeToLdapTypeBoolean(
                     pUmiProp->pUmiValue->bValue[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_BOOLEAN;
            break;

        case UMI_TYPE_IDISPATCH :
        case UMI_TYPE_VARIANT  :
            //
            // We do not support these.
            //
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;

        case UMI_TYPE_LPWSTR :

            if (!pUmiProp->pUmiValue->pszStrValue) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            
            hr = UmiTypeLPWSTRToLdapString(
                     pUmiProp->pUmiValue->pszStrValue[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_CASEEXACTSTRING;
            break;

        case UMI_TYPE_OCTETSTRING :
            
            if (!pUmiProp->pUmiValue->octetStr) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            //
            // Override default settings as this is no longer true.
            //
            pLdapDestObjects->fIsString = FALSE;

            hr = UmiTypeToLdapTypeOctetString(
                     pUmiProp->pUmiValue->octetStr[ulCtr],
                     pLdapDestObjects->pLdapObjects + ulCtr
                     );
            dwLdapSyntaxId = LDAPTYPE_OCTETSTRING;
            break;

        case UMI_TYPE_IUNKNOWN:

            if (!pUmiProp->pUmiValue->comObject
                || !pUmiProp->pUmiValue->comObject[ulCtr].pInterface
                ) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            //
            // Based on the type we should call the appropriate function.
            //
            IID *priid;
            priid = pUmiProp->pUmiValue->comObject[ulCtr].priid;

            if (!priid) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            if (*priid == IID_IADsSecurityDescriptor) {
                //
                // SD is stored as berval in cache.
                //
                pLdapDestObjects->fIsString = FALSE;
                
                //
                // SD needs the servername and credentials for conversion.
                //
                hr = UmiTypeToLdapTypeCopySecurityDescriptor(
                         pUmiProp->pUmiValue->comObject[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr,
                         pCreds,
                         pszServerName
                         );
                dwLdapSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;
            } 
            else if (*priid == IID_IADsDNWithBinary) {
                //
                // Convert DNBin obj to ldap equivalent.
                //
                hr = UmiTypeToLdapTypeCopyDNWithBinary(
                         pUmiProp->pUmiValue->comObject[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr
                         );
                dwLdapSyntaxId = LDAPTYPE_DNWITHBINARY;
            }
            else if (*priid == IID_IADsDNWithString) {
                //
                // Convert DNStr obj to ldap equivalent.
                //
                hr = UmiTypeToLdapTypeCopyDNWithString(
                         pUmiProp->pUmiValue->comObject[ulCtr],
                         pLdapDestObjects->pLdapObjects + ulCtr
                         );
                dwLdapSyntaxId = LDAPTYPE_DNWITHSTRING;
            }
            else {
                //
                // Unknown type.
                //
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }                
            break;

        case UMI_TYPE_UMIARRAY :
        case UMI_TYPE_DISCOVERY :
        case UMI_TYPE_UNDEFINED :
        case UMI_TYPE_DEFAULT :
            
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            break;

        default :
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            break;

        } // end of case statement
        
        //
        // if hr is set there was a problem converting value.
        //
        BAIL_ON_FAILURE(hr);
        
        //
        // In case of failure we now have one more object to free
        // in the ldap object array.
        //
        pLdapDestObjects->dwCount++;

    } // end of for statement

    BAIL_ON_FAILURE(hr);

    RRETURN(hr);

error:

    //
    // Free the ldapProperty array as needed.
    //
    LdapTypeFreeLdapObjects(pLdapDestObjects);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\var2ldap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       var2ldap.cxx
//
//  Contents:   Variant to LDAP object Copy Routines
//
//  Functions:
//
//  History:      25-Jun-96   yihsins  Created.
//
//
//  Issues:
//
//----------------------------------------------------------------------------
#include "ldap.hxx"

//
// LdapType objects copy code
//

HRESULT
VarTypeToLdapTypeString(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD nStrLen;

    if(pVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!pVarSrcObject->bstrVal) {
        RRETURN(hr = E_ADS_BAD_PARAMETER);
    }

    nStrLen = _tcslen( pVarSrcObject->bstrVal );

    LDAPOBJECT_STRING(pLdapDestObject) =
        (LPTSTR) AllocADsMem( (nStrLen + 1) * sizeof(TCHAR));

    if ( LDAPOBJECT_STRING(pLdapDestObject) == NULL)
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    if ( nStrLen == 0 ) {
        _tcscpy( LDAPOBJECT_STRING(pLdapDestObject), L"");
        RRETURN(S_OK);
    }

    _tcscpy( LDAPOBJECT_STRING(pLdapDestObject), pVarSrcObject->bstrVal );

    RRETURN(S_OK);
}

HRESULT
VarTypeToLdapTypeBoolean(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszStr = NULL;

    if(pVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if ( pVarSrcObject->boolVal )
        pszStr = TEXT("TRUE");
    else
        pszStr = TEXT("FALSE");

    LDAPOBJECT_STRING(pLdapDestObject) =
        (LPTSTR) AllocADsMem( (_tcslen(pszStr) + 1) * sizeof(TCHAR));

    if ( LDAPOBJECT_STRING(pLdapDestObject) == NULL)
    {
        RRETURN(hr = E_OUTOFMEMORY);

    }

    _tcscpy( LDAPOBJECT_STRING(pLdapDestObject), pszStr );

    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeUTCTime(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    int nSuccess = 0;
    ADSVALUE adsValue;
    DWORD dwSyntaxId = 0;

    if (pVarSrcObject->vt != VT_DATE)
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);

    adsValue.dwType = ADSTYPE_UTC_TIME;
    nSuccess = VariantTimeToSystemTime(
                        pVarSrcObject->date,
                        &adsValue.UTCTime
                        );
    if (!nSuccess) {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        BAIL_ON_FAILURE(hr);
    }

    hr = AdsTypeToLdapTypeCopyTime(
                &adsValue,
                pLdapDestObject,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeGeneralizedTime(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    ADSVALUE adsValue;
    DWORD dwErr = 0;
    DWORD dwSyntaxId = 0;

    if (pVarSrcObject->vt != VT_DATE)
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);

    adsValue.dwType = ADSTYPE_UTC_TIME;

    dwErr = VariantTimeToSystemTime(
                pVarSrcObject->date,
                &adsValue.UTCTime
                );

    if (dwErr != TRUE) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }


    hr = AdsTypeToLdapTypeCopyGeneralizedTime(
                    &adsValue,
                    pLdapDestObject,
                    &dwSyntaxId
                    );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeInteger(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    if( pVarSrcObject->vt != VT_I4 && pVarSrcObject->vt != VT_I2){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if(pVarSrcObject->vt == VT_I4)
       _ltot( pVarSrcObject->lVal, Buffer, 10 );
    else
       _itot( pVarSrcObject->iVal, Buffer, 10 );

    LDAPOBJECT_STRING(pLdapDestObject) =
        (LPTSTR) AllocADsMem( (_tcslen(Buffer) + 1) * sizeof(TCHAR));

    if ( LDAPOBJECT_STRING(pLdapDestObject) == NULL)
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    _tcscpy( LDAPOBJECT_STRING(pLdapDestObject), Buffer );

    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeBinaryData(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwSUBound - dwSLBound + 1);

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwSUBound - dwSLBound + 1;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) + sizeof(struct berval));

    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject), pArray,dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

error:

    RRETURN(hr);
}


HRESULT
VarTypeToLdapTypeSecDes(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )

{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor FAR * pSecDes = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD dwSDLength = 0;
    IDispatch FAR * pDispatch = NULL;
    BOOL fNTDS = TRUE;

    if (V_VT(pVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    pDispatch = V_DISPATCH(pVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsSecurityDescriptor,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);


    hr = ReadServerType(
             pszServerName,
             &Credentials,
             &fNTDS
             );
    BAIL_ON_FAILURE(hr);

    hr = ConvertSecurityDescriptorToSecDes(
                pszServerName,
                Credentials,
                pSecDes,
                &pSecurityDescriptor,
                &dwSDLength,
                fNTDS
                );
    BAIL_ON_FAILURE(hr);

    LDAPOBJECT_BERVAL(pLdapDestObject) =

        (struct berval *) AllocADsMem( sizeof(struct berval) + dwSDLength);


    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwSDLength;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) =(CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject), pSecurityDescriptor, dwSDLength);


error:
    if (pSecurityDescriptor) {
        FreeADsMem(pSecurityDescriptor);
    }
    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToLdapTypeLargeInteger(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IDispatch FAR * pDispatch = NULL;
    IADsLargeInteger *pLargeInteger = NULL;
    TCHAR Buffer[64];
    LARGE_INTEGER LargeInteger;

    if (V_VT(pVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pVarSrcObject);
    hr = pDispatch->QueryInterface(
                             IID_IADsLargeInteger,
                             (void **)&pLargeInteger
                             );
    BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->get_HighPart(&LargeInteger.HighPart);
    BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->get_LowPart((LONG*)&LargeInteger.LowPart);
    BAIL_ON_FAILURE(hr);

    swprintf (Buffer, L"%I64d", LargeInteger);

    LDAPOBJECT_STRING(pLdapDestObject) = (LPTSTR) AllocADsStr( Buffer );

    if ( LDAPOBJECT_STRING(pLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

error:
    if (pLargeInteger) {
        pLargeInteger->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToLdapTypeDNWithBinary(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IDispatch FAR * pDispatch = NULL;
    IADsDNWithBinary *pDNBinary = NULL;
    PADSVALUE pADsValue = NULL;
    VARIANT vBinary;
    BSTR bstrDN = NULL;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    DWORD dwSyntaxId = 0;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;
    CHAR HUGEP *pArray = NULL;

    VariantInit(&vBinary);

    if (V_VT(pVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pVarSrcObject);
    hr = pDispatch->QueryInterface(
                             IID_IADsDNWithBinary,
                             (void **)&pDNBinary
                             );
    BAIL_ON_FAILURE(hr);

    //
    // Convert to ADSVALUE and then to ldap representation.
    // This way the code to and from LDAP lives in one place.
    //
    hr = pDNBinary->get_BinaryValue(&vBinary);
    BAIL_ON_FAILURE(hr);

    if ((vBinary.vt != (VT_ARRAY | VT_UI1))
        && vBinary.vt != VT_EMPTY) {

        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = pDNBinary->get_DNString(&bstrDN);
    BAIL_ON_FAILURE(hr);

    //
    // Get the byte array in a usable format.
    //
    hr = SafeArrayGetLBound(
             V_ARRAY(&vBinary),
             1,
             (long FAR *) &dwSLBound
             );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
             V_ARRAY(&vBinary),
             1,
             (long FAR *) &dwSUBound
             );
    BAIL_ON_FAILURE(hr);

    dwLength = dwSUBound - dwSLBound + 1;

    lpByte = (LPBYTE) AllocADsMem(dwLength);

    if (dwLength && !lpByte) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData(
             V_ARRAY(&vBinary),
             (void HUGEP * FAR *) &pArray
             );
    BAIL_ON_FAILURE(hr);

    memcpy(lpByte, pArray, dwLength);

    SafeArrayUnaccessData( V_ARRAY(&vBinary) );

    pADsValue = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));

    if (!pADsValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pADsValue->dwType = ADSTYPE_DN_WITH_BINARY;
    pADsValue->pDNWithBinary = (PADS_DN_WITH_BINARY)
                                 AllocADsMem(sizeof(ADS_DN_WITH_BINARY));

    if (!pADsValue->pDNWithBinary) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pADsValue->pDNWithBinary->dwLength = dwLength;
    pADsValue->pDNWithBinary->lpBinaryValue = lpByte;


    pADsValue->pDNWithBinary->pszDNString = AllocADsStr(bstrDN);

    if (bstrDN && !pADsValue->pDNWithBinary->pszDNString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // At this point the ADSIValue object is ready
    //
    hr = AdsTypeToLdapTypeCopyDNWithBinary(
             pADsValue,
             pLdapDestObject,
             &dwSyntaxId
             );

    BAIL_ON_FAILURE(hr);

error:

    if (pDNBinary) {
        pDNBinary->Release();
    }

    VariantClear(&vBinary);

    if (bstrDN) {
        ADsFreeString(bstrDN);
    }

    //
    // Since we just have ptr to the byte array in the adsvalue
    // struct, if that is freed, we do not have to seperately
    // free the lpByte - if not we have to.
    //
    if (pADsValue) {
        //
        // Maybe we should replace with ADsTypeFreeAdsObjects.
        //
        if (pADsValue->pDNWithBinary) {
            if (pADsValue->pDNWithBinary->pszDNString) {
                FreeADsStr(pADsValue->pDNWithBinary->pszDNString);
            }
            if (pADsValue->pDNWithBinary->lpBinaryValue) {
                FreeADsMem(pADsValue->pDNWithBinary->lpBinaryValue);
            }
            FreeADsMem(pADsValue->pDNWithBinary);
        }

        FreeADsMem(pADsValue);
    }
    else if (lpByte) {
        FreeADsMem(lpByte);
    }


    RRETURN(hr);
}



HRESULT
VarTypeToLdapTypeDNWithString(
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject
    )
{
    HRESULT hr = S_OK;
    IDispatch FAR * pDispatch = NULL;
    IADsDNWithString *pDNString = NULL;
    PADSVALUE pADsValue = NULL;
    BSTR bstrStringValue = NULL;
    BSTR bstrDN = NULL;
    DWORD dwSyntaxId = 0;
    DWORD dwLength = 0;


    if (V_VT(pVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pVarSrcObject);
    hr = pDispatch->QueryInterface(
                             IID_IADsDNWithString,
                             (void **)&pDNString
                             );
    BAIL_ON_FAILURE(hr);

    //
    // Convert to ADSVALUE and then to ldap representation.
    // This way the code to and from LDAP lives in one place.
    //
    hr = pDNString->get_StringValue(&bstrStringValue);
    BAIL_ON_FAILURE(hr);

    hr = pDNString->get_DNString(&bstrDN);
    BAIL_ON_FAILURE(hr);

    pADsValue = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));

    if (!pADsValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pADsValue->dwType = ADSTYPE_DN_WITH_STRING;
    pADsValue->pDNWithString = (PADS_DN_WITH_STRING)
                                AllocADsMem(sizeof(ADS_DN_WITH_STRING));

    if (!pADsValue->pDNWithString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Put String value in the DNString struct.
    //
    pADsValue->pDNWithString->pszStringValue = AllocADsStr(bstrStringValue);

    if (bstrStringValue && !pADsValue->pDNWithString->pszStringValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pADsValue->pDNWithString->pszDNString = AllocADsStr(bstrDN);

    if (bstrDN && !pADsValue->pDNWithString->pszDNString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // At this point the ADSIValue object is ready
    //
    hr = AdsTypeToLdapTypeCopyDNWithString(
             pADsValue,
             pLdapDestObject,
             &dwSyntaxId
             );

    BAIL_ON_FAILURE(hr);

error:

    if (pDNString) {
        pDNString->Release();
    }

    if (bstrStringValue) {
        ADsFreeString(bstrStringValue);
    }

    if (bstrDN) {
        ADsFreeString(bstrDN);
    }

    if (pADsValue) {
        //
        // Maybe we should replace with ADsTypeFreeAdsObjects.
        //
        if (pADsValue->pDNWithString) {

            if (pADsValue->pDNWithString->pszDNString) {
                FreeADsStr(pADsValue->pDNWithString->pszDNString);
            }

            if (pADsValue->pDNWithString->pszStringValue) {
                FreeADsMem(pADsValue->pDNWithString->pszStringValue);
            }
            FreeADsMem(pADsValue->pDNWithString);
        }

        FreeADsMem(pADsValue);
    }

    RRETURN(hr);
}


HRESULT
VarTypeToLdapTypeCopy(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    DWORD dwLdapType,
    PVARIANT pVarSrcObject,
    PLDAPOBJECT pLdapDestObject,
    BOOL *pfIsString
    )
{
    HRESULT hr = S_OK;

    *pfIsString = TRUE;  // This will only be FALSE when the variant
                         // contains binary data

    switch (dwLdapType){
        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_PRINTABLESTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING:
        case LDAPTYPE_DN:
        case LDAPTYPE_NUMERICSTRING:
        case LDAPTYPE_IA5STRING:
        case LDAPTYPE_CASEIGNORESTRING:
        case LDAPTYPE_CASEEXACTSTRING:
//      case LDAPTYPE_CASEIGNOREIA5STRING:

        case LDAPTYPE_OID:
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:

        //
        // These types are treatable as strings
        // (see RFCs 2252, 2256)
        //
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER:
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_PRESENTATIONADDRESS:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_DSAQUALITYSYNTAX:
        case LDAPTYPE_DATAQUALITYSYNTAX:
        case LDAPTYPE_MAILPREFERENCE:
        case LDAPTYPE_OTHERMAILBOX:
        case LDAPTYPE_ACCESSPOINTDN:
        case LDAPTYPE_ORNAME:
        case LDAPTYPE_ORADDRESS:

            hr = VarTypeToLdapTypeString(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_BOOLEAN:
            hr = VarTypeToLdapTypeBoolean(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_INTEGER:
            hr = VarTypeToLdapTypeInteger(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
            *pfIsString = FALSE;
            hr = VarTypeToLdapTypeBinaryData(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_GENERALIZEDTIME:
            hr = VarTypeToLdapTypeGeneralizedTime(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_UTCTIME:
            hr = VarTypeToLdapTypeUTCTime(
                    pVarSrcObject,
                    pLdapDestObject
                    );
            break;

        case LDAPTYPE_SECURITY_DESCRIPTOR:
            *pfIsString = FALSE;
            hr = VarTypeToLdapTypeSecDes(
                        pszServerName,
                        Credentials,
                        pVarSrcObject,
                        pLdapDestObject
                        );
            break;

        case LDAPTYPE_INTEGER8:
            hr = VarTypeToLdapTypeLargeInteger(
                        pVarSrcObject,
                        pLdapDestObject
                        );
            break;

#if 0
        case LDAPTYPE_CASEEXACTLIST:
        case LDAPTYPE_CASEIGNORELIST:
#endif

        case LDAPTYPE_DNWITHBINARY:
            hr = VarTypeToLdapTypeDNWithBinary(
                     pVarSrcObject,
                     pLdapDestObject
                     );
            break;

        case LDAPTYPE_DNWITHSTRING:
            hr = VarTypeToLdapTypeDNWithString(
                     pVarSrcObject,
                     pLdapDestObject
                     );
            break;

        default:
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;
    }

    RRETURN(hr);
}


HRESULT
VarTypeToLdapTypeCopyConstruct(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    DWORD dwLdapType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LDAPOBJECTARRAY *pLdapDestObjects
    )
{

    DWORD i = 0;
    HRESULT hr = S_OK;


    if ( dwNumObjects == 0 )
    {
        pLdapDestObjects->dwCount = 0;
        pLdapDestObjects->pLdapObjects = NULL;
        RRETURN(S_OK);
    }

    pLdapDestObjects->pLdapObjects =
        (PLDAPOBJECT)AllocADsMem( dwNumObjects * sizeof(LDAPOBJECT));

    if (pLdapDestObjects->pLdapObjects == NULL)
        RRETURN(E_OUTOFMEMORY);

    pLdapDestObjects->dwCount = dwNumObjects;

    for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToLdapTypeCopy(
                    pszServerName,
                    Credentials,
                    dwLdapType,
                    pVarSrcObjects + i,
                    pLdapDestObjects->pLdapObjects + i,
                    &(pLdapDestObjects->fIsString)
                    );
         BAIL_ON_FAILURE(hr);
     }

     RRETURN(S_OK);

error:

     LdapTypeFreeLdapObjects( pLdapDestObjects );

     RRETURN(hr);
}

HRESULT
GetLdapSyntaxFromVariant(
    VARIANT * pvProp,
    PDWORD pdwSyntaxId,
    LPTSTR pszServer,
    LPTSTR pszAttrName,
    CCredentials& Credentials,
    DWORD dwPort
    )
{

//    IADsSecurityDescriptor * pSecDes = NULL;
//    IADsLargeInteger * pLargeInt = NULL;
    IDispatch * pDispObj = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    if (!pvProp) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    switch (pvProp->vt) {
    case VT_BSTR:
        *pdwSyntaxId = LDAPTYPE_CASEIGNORESTRING;
        break;

    case VT_I8:
        *pdwSyntaxId = LDAPTYPE_INTEGER8;
        break;

    case VT_I4:
        *pdwSyntaxId = LDAPTYPE_INTEGER;
        break;

    case VT_I2:
        *pdwSyntaxId = LDAPTYPE_INTEGER;
        break;

    case VT_BOOL:
        *pdwSyntaxId = LDAPTYPE_BOOLEAN;
        break;

    case VT_DATE:
        //
        // We need to determine if it is a GeneralizedTime
        // or UTCTime property. If the lookup fails on the
        // server we will failover to GenTime.
        //
        hr = E_FAIL;

        if (pszAttrName) {

            //
            // pszAttrName will be null if we are coming in
            // from the property cache on putproperty
            //
            hr = LdapGetSyntaxOfAttributeOnServer(
                     pszServer,
                     pszAttrName,
                     pdwSyntaxId,
                     Credentials,
                     dwPort
                     );
        }

        if (FAILED(hr)) {
            // Default to GenTime
            *pdwSyntaxId = LDAPTYPE_GENERALIZEDTIME;
        }

        break;

    case (VT_ARRAY | VT_UI1):
        *pdwSyntaxId = LDAPTYPE_OCTETSTRING;
        break;


    case (VT_DISPATCH):
        pDispatch = V_DISPATCH(pvProp);

        // Security Descriptor
        hr = pDispatch->QueryInterface(
                        IID_IADsSecurityDescriptor,
                        (void **)&pDispObj
                        );

        if (SUCCEEDED(hr)) {
            pDispObj->Release();
            *pdwSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;
            break;
        }

        // Large Integer
        hr = pDispatch->QueryInterface(
                        IID_IADsLargeInteger,
                        (void **)&pDispObj
                        );
        if (SUCCEEDED(hr)) {
            pDispObj->Release();
            *pdwSyntaxId = LDAPTYPE_INTEGER8;
            break;
        }

        // DN With Binary
        hr = pDispatch->QueryInterface(
                        IID_IADsDNWithBinary,
                        (void **)&pDispObj
                        );
        if (SUCCEEDED(hr)) {
            pDispObj->Release();
            *pdwSyntaxId = LDAPTYPE_DNWITHBINARY;
            break;
        }

        // DN With String
        hr = pDispatch->QueryInterface(
                        IID_IADsDNWithString,
                        (void **)&pDispObj
                        );
        if (SUCCEEDED(hr)) {
            pDispObj->Release();
            *pdwSyntaxId = LDAPTYPE_DNWITHSTRING;
            break;
        }

        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER)
        break;

    default:
       RRETURN(E_FAIL);


    }

    RRETURN(S_OK);

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\wmiutils.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for wmiutils.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmiutils_h__
#define __wmiutils_h__

/* Forward Declarations */ 

#ifndef __IWbemPathKeyList_FWD_DEFINED__
#define __IWbemPathKeyList_FWD_DEFINED__
typedef interface IWbemPathKeyList IWbemPathKeyList;
#endif 	/* __IWbemPathKeyList_FWD_DEFINED__ */


#ifndef __IWbemPath_FWD_DEFINED__
#define __IWbemPath_FWD_DEFINED__
typedef interface IWbemPath IWbemPath;
#endif 	/* __IWbemPath_FWD_DEFINED__ */


#ifndef __WbemDefPath_FWD_DEFINED__
#define __WbemDefPath_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemDefPath WbemDefPath;
#else
typedef struct WbemDefPath WbemDefPath;
#endif /* __cplusplus */

#endif 	/* __WbemDefPath_FWD_DEFINED__ */


#ifndef __IWbemQuery_FWD_DEFINED__
#define __IWbemQuery_FWD_DEFINED__
typedef interface IWbemQuery IWbemQuery;
#endif 	/* __IWbemQuery_FWD_DEFINED__ */


#ifndef __WbemQuery_FWD_DEFINED__
#define __WbemQuery_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemQuery WbemQuery;
#else
typedef struct WbemQuery WbemQuery;
#endif /* __cplusplus */

#endif 	/* __WbemQuery_FWD_DEFINED__ */


#ifndef __IWbemQuery_FWD_DEFINED__
#define __IWbemQuery_FWD_DEFINED__
typedef interface IWbemQuery IWbemQuery;
#endif 	/* __IWbemQuery_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __WbemUtilities_v1_LIBRARY_DEFINED__
#define __WbemUtilities_v1_LIBRARY_DEFINED__

/* library WbemUtilities_v1 */
/* [uuid] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_PATH_STATUS_FLAG
    {	WBEMPATH_INFO_ANON_LOCAL_MACHINE	= 0x1,
	WBEMPATH_INFO_HAS_MACHINE_NAME	= 0x2,
	WBEMPATH_INFO_IS_CLASS_REF	= 0x4,
	WBEMPATH_INFO_IS_INST_REF	= 0x8,
	WBEMPATH_INFO_HAS_SUBSCOPES	= 0x10,
	WBEMPATH_INFO_IS_COMPOUND	= 0x20,
	WBEMPATH_INFO_HAS_V2_REF_PATHS	= 0x40,
	WBEMPATH_INFO_HAS_IMPLIED_KEY	= 0x80,
	WBEMPATH_INFO_CONTAINS_SINGLETON	= 0x100,
	WBEMPATH_INFO_V1_COMPLIANT	= 0x200,
	WBEMPATH_INFO_V2_COMPLIANT	= 0x400,
	WBEMPATH_INFO_CIM_COMPLIANT	= 0x800,
	WBEMPATH_INFO_IS_SINGLETON	= 0x1000,
	WBEMPATH_INFO_IS_PARENT	= 0x2000,
	WBEMPATH_INFO_SERVER_NAMESPACE_ONLY	= 0x4000,
	WBEMPATH_INFO_NATIVE_PATH	= 0x8000,
	WBEMPATH_INFO_WMI_PATH	= 0x10000
    } 	tag_WBEM_PATH_STATUS_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_PATH_CREATE_FLAG
    {	WBEMPATH_CREATE_ACCEPT_RELATIVE	= 0x1,
	WBEMPATH_CREATE_ACCEPT_ABSOLUTE	= 0x2,
	WBEMPATH_CREATE_ACCEPT_ALL	= 0x4,
	WBEMPATH_TREAT_SINGLE_IDENT_AS_NS	= 0x8
    } 	tag_WBEM_PATH_CREATE_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_GET_TEXT_FLAGS
    {	WBEMPATH_COMPRESSED	= 0x1,
	WBEMPATH_GET_RELATIVE_ONLY	= 0x2,
	WBEMPATH_GET_SERVER_TOO	= 0x4,
	WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY	= 0x8
    } 	tag_WBEM_GET_TEXT_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_GET_KEY_FLAGS
    {	WBEMPATH_TEXT	= 0x1,
	WBEMPATH_QUOTEDTEXT	= 0x2
    } 	tag_WBEM_GET_KEY_FLAGS;



EXTERN_C const IID LIBID_WbemUtilities_v1;

#ifndef __IWbemPathKeyList_INTERFACE_DEFINED__
#define __IWbemPathKeyList_INTERFACE_DEFINED__

/* interface IWbemPathKeyList */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemPathKeyList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9AE62877-7544-4bb0-AA26-A13824659ED6")
    IWbemPathKeyList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ LPVOID pKeyVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey2( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ VARIANT __RPC_FAR *pKeyVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
            /* [out][in] */ LPVOID pKeyVal,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey2( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeSingleton( 
            /* [in] */ boolean bSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemPathKeyListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemPathKeyList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemPathKeyList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puKeyCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ LPVOID pKeyVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey2 )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ VARIANT __RPC_FAR *pKeyVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKey )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
            /* [out][in] */ LPVOID pKeyVal,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKey2 )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveKey )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllKeys )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeSingleton )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ boolean bSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IWbemPathKeyList __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszText);
        
        END_INTERFACE
    } IWbemPathKeyListVtbl;

    interface IWbemPathKeyList
    {
        CONST_VTBL struct IWbemPathKeyListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemPathKeyList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemPathKeyList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemPathKeyList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemPathKeyList_GetCount(This,puKeyCount)	\
    (This)->lpVtbl -> GetCount(This,puKeyCount)

#define IWbemPathKeyList_SetKey(This,wszName,uFlags,uCimType,pKeyVal)	\
    (This)->lpVtbl -> SetKey(This,wszName,uFlags,uCimType,pKeyVal)

#define IWbemPathKeyList_SetKey2(This,wszName,uFlags,uCimType,pKeyVal)	\
    (This)->lpVtbl -> SetKey2(This,wszName,uFlags,uCimType,pKeyVal)

#define IWbemPathKeyList_GetKey(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,puKeyValBufSize,pKeyVal,puApparentCimType)	\
    (This)->lpVtbl -> GetKey(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,puKeyValBufSize,pKeyVal,puApparentCimType)

#define IWbemPathKeyList_GetKey2(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,pKeyValue,puApparentCimType)	\
    (This)->lpVtbl -> GetKey2(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,pKeyValue,puApparentCimType)

#define IWbemPathKeyList_RemoveKey(This,wszName,uFlags)	\
    (This)->lpVtbl -> RemoveKey(This,wszName,uFlags)

#define IWbemPathKeyList_RemoveAllKeys(This,uFlags)	\
    (This)->lpVtbl -> RemoveAllKeys(This,uFlags)

#define IWbemPathKeyList_MakeSingleton(This,bSet)	\
    (This)->lpVtbl -> MakeSingleton(This,bSet)

#define IWbemPathKeyList_GetInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetInfo(This,uRequestedInfo,puResponse)

#define IWbemPathKeyList_GetText(This,lFlags,puBuffLength,pszText)	\
    (This)->lpVtbl -> GetText(This,lFlags,puBuffLength,pszText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetCount_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puKeyCount);


void __RPC_STUB IWbemPathKeyList_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_SetKey_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uCimType,
    /* [in] */ LPVOID pKeyVal);


void __RPC_STUB IWbemPathKeyList_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_SetKey2_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uCimType,
    /* [in] */ VARIANT __RPC_FAR *pKeyVal);


void __RPC_STUB IWbemPathKeyList_SetKey2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetKey_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ ULONG uKeyIx,
    /* [in] */ ULONG uFlags,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
    /* [out][in] */ LPWSTR pszKeyName,
    /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
    /* [out][in] */ LPVOID pKeyVal,
    /* [out] */ ULONG __RPC_FAR *puApparentCimType);


void __RPC_STUB IWbemPathKeyList_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetKey2_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ ULONG uKeyIx,
    /* [in] */ ULONG uFlags,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
    /* [out][in] */ LPWSTR pszKeyName,
    /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
    /* [out] */ ULONG __RPC_FAR *puApparentCimType);


void __RPC_STUB IWbemPathKeyList_GetKey2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_RemoveKey_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemPathKeyList_RemoveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_RemoveAllKeys_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemPathKeyList_RemoveAllKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_MakeSingleton_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ boolean bSet);


void __RPC_STUB IWbemPathKeyList_MakeSingleton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetInfo_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IWbemPathKeyList_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPathKeyList_GetText_Proxy( 
    IWbemPathKeyList __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszText);


void __RPC_STUB IWbemPathKeyList_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemPathKeyList_INTERFACE_DEFINED__ */


#ifndef __IWbemPath_INTERFACE_DEFINED__
#define __IWbemPath_INTERFACE_DEFINED__

/* interface IWbemPath */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemPath;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3BC15AF2-736C-477e-9E51-238AF8667DCC")
    IWbemPath : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ ULONG uMode,
            /* [in] */ LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServer( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServer( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [string][in] */ LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveNamespaceAt( 
            /* [in] */ ULONG uIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllNamespaces( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScope( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScopeFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScope( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScope( 
            /* [in] */ ULONG uIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllScopes( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClassName( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassPart( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemPathVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemPath __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemPath __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uMode,
            /* [in] */ LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetServer )( 
            IWbemPath __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServer )( 
            IWbemPath __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespaceCount )( 
            IWbemPath __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNamespaceAt )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [string][in] */ LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespaceAt )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveNamespaceAt )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllNamespaces )( 
            IWbemPath __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScopeCount )( 
            IWbemPath __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScope )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScopeFromText )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScope )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScopeAsText )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScope )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ ULONG uIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllScopes )( 
            IWbemPath __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClassName )( 
            IWbemPath __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassName )( 
            IWbemPath __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeyList )( 
            IWbemPath __RPC_FAR * This,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassPart )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClassPart )( 
            IWbemPath __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemPathVtbl;

    interface IWbemPath
    {
        CONST_VTBL struct IWbemPathVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemPath_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemPath_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemPath_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemPath_SetText(This,uMode,pszPath)	\
    (This)->lpVtbl -> SetText(This,uMode,pszPath)

#define IWbemPath_GetText(This,lFlags,puBuffLength,pszText)	\
    (This)->lpVtbl -> GetText(This,lFlags,puBuffLength,pszText)

#define IWbemPath_GetInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetInfo(This,uRequestedInfo,puResponse)

#define IWbemPath_SetServer(This,Name)	\
    (This)->lpVtbl -> SetServer(This,Name)

#define IWbemPath_GetServer(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetServer(This,puNameBufLength,pName)

#define IWbemPath_GetNamespaceCount(This,puCount)	\
    (This)->lpVtbl -> GetNamespaceCount(This,puCount)

#define IWbemPath_SetNamespaceAt(This,uIndex,pszName)	\
    (This)->lpVtbl -> SetNamespaceAt(This,uIndex,pszName)

#define IWbemPath_GetNamespaceAt(This,uIndex,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetNamespaceAt(This,uIndex,puNameBufLength,pName)

#define IWbemPath_RemoveNamespaceAt(This,uIndex)	\
    (This)->lpVtbl -> RemoveNamespaceAt(This,uIndex)

#define IWbemPath_RemoveAllNamespaces(This)	\
    (This)->lpVtbl -> RemoveAllNamespaces(This)

#define IWbemPath_GetScopeCount(This,puCount)	\
    (This)->lpVtbl -> GetScopeCount(This,puCount)

#define IWbemPath_SetScope(This,uIndex,pszClass)	\
    (This)->lpVtbl -> SetScope(This,uIndex,pszClass)

#define IWbemPath_SetScopeFromText(This,uIndex,pszText)	\
    (This)->lpVtbl -> SetScopeFromText(This,uIndex,pszText)

#define IWbemPath_GetScope(This,uIndex,puClassNameBufSize,pszClass,pKeyList)	\
    (This)->lpVtbl -> GetScope(This,uIndex,puClassNameBufSize,pszClass,pKeyList)

#define IWbemPath_GetScopeAsText(This,uIndex,puTextBufSize,pszText)	\
    (This)->lpVtbl -> GetScopeAsText(This,uIndex,puTextBufSize,pszText)

#define IWbemPath_RemoveScope(This,uIndex)	\
    (This)->lpVtbl -> RemoveScope(This,uIndex)

#define IWbemPath_RemoveAllScopes(This)	\
    (This)->lpVtbl -> RemoveAllScopes(This)

#define IWbemPath_SetClassName(This,Name)	\
    (This)->lpVtbl -> SetClassName(This,Name)

#define IWbemPath_GetClassName(This,puBuffLength,pszName)	\
    (This)->lpVtbl -> GetClassName(This,puBuffLength,pszName)

#define IWbemPath_GetKeyList(This,pOut)	\
    (This)->lpVtbl -> GetKeyList(This,pOut)

#define IWbemPath_CreateClassPart(This,lFlags,Name)	\
    (This)->lpVtbl -> CreateClassPart(This,lFlags,Name)

#define IWbemPath_DeleteClassPart(This,lFlags)	\
    (This)->lpVtbl -> DeleteClassPart(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemPath_SetText_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uMode,
    /* [in] */ LPCWSTR pszPath);


void __RPC_STUB IWbemPath_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetText_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszText);


void __RPC_STUB IWbemPath_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetInfo_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IWbemPath_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetServer_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IWbemPath_SetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetServer_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][out][in] */ LPWSTR pName);


void __RPC_STUB IWbemPath_GetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetNamespaceCount_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB IWbemPath_GetNamespaceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetNamespaceAt_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [string][in] */ LPCWSTR pszName);


void __RPC_STUB IWbemPath_SetNamespaceAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetNamespaceAt_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][out][in] */ LPWSTR pName);


void __RPC_STUB IWbemPath_GetNamespaceAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_RemoveNamespaceAt_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex);


void __RPC_STUB IWbemPath_RemoveNamespaceAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_RemoveAllNamespaces_Proxy( 
    IWbemPath __RPC_FAR * This);


void __RPC_STUB IWbemPath_RemoveAllNamespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetScopeCount_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB IWbemPath_GetScopeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetScope_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszClass);


void __RPC_STUB IWbemPath_SetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetScopeFromText_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszText);


void __RPC_STUB IWbemPath_SetScopeFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetScope_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
    /* [out][in] */ LPWSTR pszClass,
    /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList);


void __RPC_STUB IWbemPath_GetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetScopeAsText_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
    /* [out][in] */ LPWSTR pszText);


void __RPC_STUB IWbemPath_GetScopeAsText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_RemoveScope_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ ULONG uIndex);


void __RPC_STUB IWbemPath_RemoveScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_RemoveAllScopes_Proxy( 
    IWbemPath __RPC_FAR * This);


void __RPC_STUB IWbemPath_RemoveAllScopes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_SetClassName_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IWbemPath_SetClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetClassName_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszName);


void __RPC_STUB IWbemPath_GetClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_GetKeyList_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut);


void __RPC_STUB IWbemPath_GetKeyList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_CreateClassPart_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IWbemPath_CreateClassPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPath_DeleteClassPart_Proxy( 
    IWbemPath __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemPath_DeleteClassPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemPath_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemDefPath;

#ifdef __cplusplus

class DECLSPEC_UUID("cf4cc405-e2c5-4ddd-b3ce-5e7582d8c9fa")
WbemDefPath;
#endif

#ifndef __IWbemQuery_INTERFACE_DEFINED__
#define __IWbemQuery_INTERFACE_DEFINED__

/* interface IWbemQuery */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81166f58-dd98-11d3-a120-00105a1f515a")
    IWbemQuery : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Empty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguageFeatures( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestLanguageFeatures( 
            /* [out][in] */ ULONG __RPC_FAR *uArraySize,
            /* [out] */ ULONG __RPC_FAR *puFeatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Parse( 
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAnalysis( 
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pAnalysis) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ LPVOID pMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQueryInfo( 
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uInfoId,
            /* [in] */ ULONG uBufSize,
            /* [out] */ LPVOID pDestBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AttachClassDef( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pClassDef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestObject( 
            /* [in] */ ULONG uTestType,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringTest( 
            /* [in] */ ULONG uTestType,
            /* [in] */ LPCWSTR pszTestStr,
            /* [in] */ LPCWSTR pszExpr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemQuery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Empty )( 
            IWbemQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLanguageFeatures )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TestLanguageFeatures )( 
            IWbemQuery __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *uArraySize,
            /* [out] */ ULONG __RPC_FAR *puFeatures);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Parse )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAnalysis )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pAnalysis);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQueryInfo )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uInfoId,
            /* [in] */ ULONG uBufSize,
            /* [out] */ LPVOID pDestBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachClassDef )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pClassDef);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TestObject )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ ULONG uTestType,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StringTest )( 
            IWbemQuery __RPC_FAR * This,
            /* [in] */ ULONG uTestType,
            /* [in] */ LPCWSTR pszTestStr,
            /* [in] */ LPCWSTR pszExpr);
        
        END_INTERFACE
    } IWbemQueryVtbl;

    interface IWbemQuery
    {
        CONST_VTBL struct IWbemQueryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQuery_Empty(This)	\
    (This)->lpVtbl -> Empty(This)

#define IWbemQuery_SetLanguageFeatures(This,lFlags,uArraySize,puFeatures)	\
    (This)->lpVtbl -> SetLanguageFeatures(This,lFlags,uArraySize,puFeatures)

#define IWbemQuery_TestLanguageFeatures(This,uArraySize,puFeatures)	\
    (This)->lpVtbl -> TestLanguageFeatures(This,uArraySize,puFeatures)

#define IWbemQuery_Parse(This,pszLang,pszQuery,uFlags)	\
    (This)->lpVtbl -> Parse(This,pszLang,pszQuery,uFlags)

#define IWbemQuery_GetAnalysis(This,uAnalysisType,uFlags,pAnalysis)	\
    (This)->lpVtbl -> GetAnalysis(This,uAnalysisType,uFlags,pAnalysis)

#define IWbemQuery_FreeMemory(This,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,pMem)

#define IWbemQuery_GetQueryInfo(This,uAnalysisType,uInfoId,uBufSize,pDestBuf)	\
    (This)->lpVtbl -> GetQueryInfo(This,uAnalysisType,uInfoId,uBufSize,pDestBuf)

#define IWbemQuery_AttachClassDef(This,riid,pClassDef)	\
    (This)->lpVtbl -> AttachClassDef(This,riid,pClassDef)

#define IWbemQuery_TestObject(This,uTestType,uFlags,riid,pObj)	\
    (This)->lpVtbl -> TestObject(This,uTestType,uFlags,riid,pObj)

#define IWbemQuery_StringTest(This,uTestType,pszTestStr,pszExpr)	\
    (This)->lpVtbl -> StringTest(This,uTestType,pszTestStr,pszExpr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemQuery_Empty_Proxy( 
    IWbemQuery __RPC_FAR * This);


void __RPC_STUB IWbemQuery_Empty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_SetLanguageFeatures_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uArraySize,
    /* [in] */ ULONG __RPC_FAR *puFeatures);


void __RPC_STUB IWbemQuery_SetLanguageFeatures_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_TestLanguageFeatures_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *uArraySize,
    /* [out] */ ULONG __RPC_FAR *puFeatures);


void __RPC_STUB IWbemQuery_TestLanguageFeatures_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_Parse_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ LPCWSTR pszLang,
    /* [in] */ LPCWSTR pszQuery,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemQuery_Parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_GetAnalysis_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ ULONG uAnalysisType,
    /* [in] */ ULONG uFlags,
    /* [out] */ LPVOID __RPC_FAR *pAnalysis);


void __RPC_STUB IWbemQuery_GetAnalysis_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_FreeMemory_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ LPVOID pMem);


void __RPC_STUB IWbemQuery_FreeMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_GetQueryInfo_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ ULONG uAnalysisType,
    /* [in] */ ULONG uInfoId,
    /* [in] */ ULONG uBufSize,
    /* [out] */ LPVOID pDestBuf);


void __RPC_STUB IWbemQuery_GetQueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_AttachClassDef_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pClassDef);


void __RPC_STUB IWbemQuery_AttachClassDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_TestObject_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ ULONG uTestType,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pObj);


void __RPC_STUB IWbemQuery_TestObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQuery_StringTest_Proxy( 
    IWbemQuery __RPC_FAR * This,
    /* [in] */ ULONG uTestType,
    /* [in] */ LPCWSTR pszTestStr,
    /* [in] */ LPCWSTR pszExpr);


void __RPC_STUB IWbemQuery_StringTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQuery_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemQuery;

#ifdef __cplusplus

class DECLSPEC_UUID("EAC8A024-21E2-4523-AD73-A71A0AA2F56A")
WbemQuery;
#endif
#endif /* __WbemUtilities_v1_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_wmiutils_0107 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmiutils_0107_0001
    {	WMIQ_ANALYSIS_RPN_SEQUENCE	= 0x1,
	WMIQ_ANALYSIS_ASSOC_QUERY	= 0x2,
	WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX	= 0x3
    } 	WMIQ_ANALYSIS_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmiutils_0107_0002
    {	WMIQ_RPN_TOKEN_EXPRESSION	= 1,
	WMIQ_RPN_TOKEN_AND	= 2,
	WMIQ_RPN_TOKEN_OR	= 3,
	WMIQ_RPN_TOKEN_NOT	= 4,
	WMIQ_RPN_OP_UNDEFINED	= 0,
	WMIQ_RPN_OP_EQ	= 1,
	WMIQ_RPN_OP_NE	= 2,
	WMIQ_RPN_OP_GE	= 3,
	WMIQ_RPN_OP_LE	= 4,
	WMIQ_RPN_OP_LT	= 5,
	WMIQ_RPN_OP_GT	= 6,
	WMIQ_RPN_OP_LIKE	= 7,
	WMIQ_RPN_OP_ISA	= 8,
	WMIQ_RPN_OP_ISNOTA	= 9,
	WMIQ_RPN_LEFT_PROPERTY_NAME	= 0x1,
	WMIQ_RPN_RIGHT_PROPERTY_NAME	= 0x2,
	WMIQ_RPN_CONST2	= 0x4,
	WMIQ_RPN_CONST	= 0x8,
	WMIQ_RPN_RELOP	= 0x10,
	WMIQ_RPN_LEFT_FUNCTION	= 0x20,
	WMIQ_RPN_RIGHT_FUNCTION	= 0x30,
	WMIQ_RPN_GET_TOKEN_TYPE	= 1,
	WMIQ_RPN_GET_EXPR_SHAPE	= 2,
	WMIQ_RPN_GET_LEFT_FUNCTION	= 3,
	WMIQ_RPN_GET_RIGHT_FUNCTION	= 4,
	WMIQ_RPN_GET_RELOP	= 5,
	WMIQ_RPN_NEXT_TOKEN	= 1,
	WMIQ_RPN_FROM_UNARY	= 0x1,
	WMIQ_RPN_FROM_PATH	= 0x2,
	WMIQ_RPN_FROM_CLASS_LIST	= 0x4
    } 	WMIQ_RPN_TOKEN_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmiutils_0107_0003
    {	WMIQ_ASSOCQ_ASSOCIATORS	= 0x1,
	WMIQ_ASSOCQ_REFERENCES	= 0x2,
	WMIQ_ASSOCQ_RESULTCLASS	= 0x4,
	WMIQ_ASSOCQ_ROLE	= 0x8,
	WMIQ_ASSOCQ_RESULTROLE	= 0x10,
	WMIQ_ASSOCQ_REQUIREDQUALIFIER	= 0x20,
	WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER	= 0x40,
	WMIQ_ASSOCQ_CLASSDEFSONLY	= 0x80,
	WMIQ_ASSOCQ_KEYSONLY	= 0x100,
	WMIQ_ASSOCQ_SCHEMAONLY	= 0x200,
	WMIQ_ASSOCQ_CLASSREFSONLY	= 0x400
    } 	WMIQ_ASSOCQ_FLAGS;

typedef struct tag_SWbemQueryQualifiedName
    {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uNameListSize;
    LPCWSTR __RPC_FAR *m_ppszNameList;
    BOOL m_bArraysUsed;
    BOOL __RPC_FAR *m_pbArrayElUsed;
    ULONG __RPC_FAR *m_puArrayIndex;
    } 	SWbemQueryQualifiedName;

typedef union tag_SWbemRpnConst
    {
    LPCWSTR m_pszStrVal;
    BOOL m_bBoolVal;
    LONG m_lLongVal;
    ULONG m_uLongVal;
    double m_dblVal;
    __int64 m_lVal64;
    __int64 m_uVal64;
    } 	SWbemRpnConst;

typedef struct tag_SWbemRpnQueryToken
    {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uSubexpressionShape;
    ULONG m_uOperator;
    SWbemQueryQualifiedName __RPC_FAR *m_pRightIdent;
    SWbemQueryQualifiedName __RPC_FAR *m_pLeftIdent;
    ULONG m_uConstApparentType;
    SWbemRpnConst m_Const;
    ULONG m_uConst2ApparentType;
    SWbemRpnConst m_Const2;
    LPCWSTR m_pszRightFunc;
    LPCWSTR m_pszLeftFunc;
    } 	SWbemRpnQueryToken;

typedef struct tag_SWbemRpnTokenList
    {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uNumTokens;
    } 	SWbemRpnTokenList;

typedef 
enum tag_WMIQ_LANGUAGE_FEATURES
    {	WMIQ_LF1_BASIC_SELECT	= 1,
	WMIQ_LF2_CLASS_NAME_IN_QUERY	= 2,
	WMIQ_LF3_STRING_CASE_FUNCTIONS	= 3,
	WMIQ_LF4_PROP_TO_PROP_TESTS	= 4,
	WMIQ_LF5_COUNT_STAR	= 5,
	WMIQ_LF6_ORDER_BY	= 6,
	WMIQ_LF7_DISTINCT	= 7,
	WMIQ_LF8_ISA	= 8,
	WMIQ_LF9_THIS	= 9,
	WMIQ_LF10_COMPEX_SUBEXPRESSIONS	= 10,
	WMIQ_LF11_ALIASING	= 11,
	WMIQ_LF12_GROUP_BY_HAVING	= 12,
	WMIQ_LF13_WMI_WITHIN	= 13,
	WMIQ_LF14_SQL_WRITE_OPERATIONS	= 14,
	WMIQ_LF15_GO	= 15,
	WMIQ_LF16_SINGLE_LEVEL_TRANSACTIONS	= 16,
	WMIQ_LF17_QUALIFIED_NAMES	= 17,
	WMIQ_LF18_ASSOCIATONS	= 18,
	WMIQ_LF19_SYSTEM_PROPERTIES	= 19,
	WMIQ_LF20_EXTENDED_SYSTEM_PROPERTIES	= 20,
	WMIQ_LF21_SQL89_JOINS	= 21,
	WMIQ_LF22_SQL92_JOINS	= 22,
	WMIQ_LF23_SUBSELECTS	= 23,
	WMIQ_LF24_UMI_EXTENSIONS	= 24,
	WMIQ_LF25_DATEPART	= 25,
	WMIQ_LF26_LIKE	= 26,
	WMIQ_LF27_CIM_TEMPORAL_CONSTRUCTS	= 27,
	WMIQ_LF28_STANDARD_AGGREGATES	= 28,
	WMIQ_LF29_MULTI_LEVEL_ORDER_BY	= 29,
	WMIQ_LF30_WMI_PRAGMAS	= 30,
	WMIQ_LF31_QUALIFIER_TESTS	= 31,
	WMIQ_LF32_SP_EXECUTE	= 32,
	WMIQ_LF33_ARRAY_ACCESS	= 33,
	WMIQ_LF34_UNION	= 34,
	WMIQ_LF35_COMPLEX_SELECT_TARGET	= 35,
	WMIQ_LF36_REFERENCE_TESTS	= 36,
	WMIQ_LF37_SELECT_INTO	= 37,
	WMIQ_LF38_BASIC_DATETIME_TESTS	= 38,
	WMIQ_LF_LAST	= 39
    } 	WMIQ_LANGUAGE_FEATURES;

typedef 
enum tag_WMIQ_RPNQ_FEATURE
    {	WMIQ_RPNF_WHERE_CLAUSE_PRESENT	= 0x1,
	WMIQ_RPNF_QUERY_IS_CONJUNCTIVE	= 0x2,
	WMIQ_RPNF_QUERY_IS_DISJUNCTIVE	= 0x4,
	WMIQ_RPNF_PROJECTION	= 0x8,
	WMIQ_RPNF_FEATURE_SELECT_STAR	= 0x10,
	WMIQ_RPNF_EQUALITY_TESTS_ONLY	= 0x20,
	WMIQ_RPNF_COUNT_STAR	= 0x40,
	WMIQ_RPNF_QUALIFIED_NAMES_IN_SELECT	= 0x80,
	WMIQ_RPNF_QUALIFIED_NAMES_IN_WHERE	= 0x100,
	WMIQ_RPNF_PROP_TO_PROP_TESTS	= 0x200,
	WMIQ_RPNF_ORDER_BY	= 0x400,
	WMIQ_RPNF_ISA_USED	= 0x800,
	WMIQ_RPNF_ISNOTA_USED	= 0x1000,
	WMIQ_RPNF_GROUP_BY_HAVING	= 0x2000,
	WMIQ_RPNF_WITHIN_INTERVAL	= 0x4000,
	WMIQ_RPNF_WITHIN_AGGREGATE	= 0x8000,
	WMIQ_RPNF_SYSPROP_CLASS	= 0x10000,
	WMIQ_RPNF_REFERENCE_TESTS	= 0x20000,
	WMIQ_RPNF_DATETIME_TESTS	= 0x40000,
	WMIQ_RPNF_ARRAY_ACCESS	= 0x80000,
	WMIQ_RPNF_QUALIFIER_FILTER	= 0x100000,
	WMIQ_RPNF_SELECTED_FROM_PATH	= 0x200000
    } 	WMIQ_RPNF_FEATURE;

typedef struct tag_SWbemRpnEncodedQuery
    {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uParsedFeatureMask1;
    ULONG m_uParsedFeatureMask2;
    ULONG m_uDetectedArraySize;
    ULONG __RPC_FAR *m_puDetectedFeatures;
    ULONG m_uSelectListSize;
    SWbemQueryQualifiedName __RPC_FAR *__RPC_FAR *m_ppSelectList;
    ULONG m_uFromTargetType;
    LPCWSTR m_pszOptionalFromPath;
    ULONG m_uFromListSize;
    LPCWSTR __RPC_FAR *m_ppszFromList;
    ULONG m_uWhereClauseSize;
    SWbemRpnQueryToken __RPC_FAR *__RPC_FAR *m_ppRpnWhereClause;
    double m_dblWithinPolling;
    double m_dblWithinWindow;
    ULONG m_uOrderByListSize;
    LPCWSTR __RPC_FAR *m_ppszOrderByList;
    ULONG __RPC_FAR *m_uOrderDirectionEl;
    } 	SWbemRpnEncodedQuery;

typedef struct tag_SWbemAnalysisMatrix
    {
    ULONG m_uVersion;
    ULONG m_uMatrixType;
    LPCWSTR m_pszProperty;
    ULONG m_uPropertyType;
    ULONG m_uEntries;
    LPVOID __RPC_FAR *m_pValues;
    BOOL __RPC_FAR *m_pbTruthTable;
    } 	SWbemAnalysisMatrix;

typedef struct tag_SWbemAnalysisMatrixList
    {
    ULONG m_uVersion;
    ULONG m_uMatrixType;
    ULONG m_uNumMatrices;
    SWbemAnalysisMatrix __RPC_FAR *m_pMatrices;
    } 	SWbemAnalysisMatrixList;

typedef struct tag_SWbemAssocQueryInf
    {
    ULONG m_uVersion;
    ULONG m_uAnalysisType;
    ULONG m_uFeatureMask;
    IWbemPath __RPC_FAR *m_pPath;
    LPWSTR m_pszPath;
    LPWSTR m_pszQueryText;
    LPWSTR m_pszResultClass;
    LPWSTR m_pszAssocClass;
    LPWSTR m_pszRole;
    LPWSTR m_pszResultRole;
    LPWSTR m_pszRequiredQualifier;
    LPWSTR m_pszRequiredAssocQualifier;
    } 	SWbemAssocQueryInf;



extern RPC_IF_HANDLE __MIDL_itf_wmiutils_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmiutils_0107_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldapinc\disptmpl.h ===
/*
 * Copyright (c) 1993, 1994 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 *
 * disptmpl.h:  display template library defines
 * 7 March 1994 by Mark C Smith
 */

#ifndef _DISPTMPL_H
#define _DISPTMPL_H

#ifdef __cplusplus
extern "C" {
#endif


#define LDAP_TEMPLATE_VERSION	1

/*
 * general types of items (confined to most significant byte)
 */
#define LDAP_SYN_TYPE_TEXT		0x01000000L
#define LDAP_SYN_TYPE_IMAGE		0x02000000L
#define LDAP_SYN_TYPE_BOOLEAN		0x04000000L
#define LDAP_SYN_TYPE_BUTTON		0x08000000L
#define LDAP_SYN_TYPE_ACTION		0x10000000L


/*
 * syntax options (confined to second most significant byte)
 */
#define LDAP_SYN_OPT_DEFER		0x00010000L


/* 
 * display template item syntax ids (defined by common agreement)
 * these are the valid values for the ti_syntaxid of the tmplitem
 * struct (defined below).  A general type is encoded in the
 * most-significant 8 bits, and some options are encoded in the next
 * 8 bits.  The lower 16 bits are reserved for the distinct types.
 */
#define LDAP_SYN_CASEIGNORESTR	( 1 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_MULTILINESTR	( 2 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_DN		( 3 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_BOOLEAN	( 4 | LDAP_SYN_TYPE_BOOLEAN )
#define LDAP_SYN_JPEGIMAGE	( 5 | LDAP_SYN_TYPE_IMAGE )
#define LDAP_SYN_JPEGBUTTON	( 6 | LDAP_SYN_TYPE_BUTTON | LDAP_SYN_OPT_DEFER )
#define LDAP_SYN_FAXIMAGE	( 7 | LDAP_SYN_TYPE_IMAGE )
#define LDAP_SYN_FAXBUTTON	( 8 | LDAP_SYN_TYPE_BUTTON | LDAP_SYN_OPT_DEFER )
#define LDAP_SYN_AUDIOBUTTON	( 9 | LDAP_SYN_TYPE_BUTTON | LDAP_SYN_OPT_DEFER )
#define LDAP_SYN_TIME		( 10 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_DATE		( 11 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_LABELEDURL	( 12 | LDAP_SYN_TYPE_TEXT )
#define LDAP_SYN_SEARCHACTION	( 13 | LDAP_SYN_TYPE_ACTION )
#define LDAP_SYN_LINKACTION	( 14 | LDAP_SYN_TYPE_ACTION )
#define LDAP_SYN_ADDDNACTION	( 15 | LDAP_SYN_TYPE_ACTION )
#define LDAP_SYN_VERIFYDNACTION ( 16 | LDAP_SYN_TYPE_ACTION )
#define LDAP_SYN_RFC822ADDR	( 17 | LDAP_SYN_TYPE_TEXT )


/*
 * handy macros
 */
#define LDAP_GET_SYN_TYPE( syid )	((syid) & 0xFF000000L )
#define LDAP_GET_SYN_OPTIONS( syid )	((syid) & 0x00FF0000L )


/*
 * display options for output routines (used by entry2text and friends)
 */
/*
 * use calculated label width (based on length of longest label in
 * template) instead of contant width
 */
#define LDAP_DISP_OPT_AUTOLABELWIDTH	0x00000001L
#define LDAP_DISP_OPT_HTMLBODYONLY	0x00000002L

/*
 * perform search actions (applies to ldap_entry2text_search only) 
 */
#define LDAP_DISP_OPT_DOSEARCHACTIONS	0x00000002L

/*
 * include additional info. relevant to "non leaf" entries only
 * used by ldap_entry2html and ldap_entry2html_search to include "Browse"
 * and "Move Up" HREFs
 */
#define LDAP_DISP_OPT_NONLEAF		0x00000004L


/*
 * display template item options (may not apply to all types)
 * if this bit is set in ti_options, it applies.
 */
#define LDAP_DITEM_OPT_READONLY		0x00000001L
#define LDAP_DITEM_OPT_SORTVALUES	0x00000002L
#define LDAP_DITEM_OPT_SINGLEVALUED	0x00000004L
#define LDAP_DITEM_OPT_HIDEIFEMPTY	0x00000008L
#define LDAP_DITEM_OPT_VALUEREQUIRED	0x00000010L
#define LDAP_DITEM_OPT_HIDEIFFALSE	0x00000020L	/* booleans only */



/*
 * display template item structure
 */
struct ldap_tmplitem {
    unsigned long		ti_syntaxid;
    unsigned long		ti_options;
    char  			*ti_attrname;
    char			*ti_label;
    char			**ti_args;
    struct ldap_tmplitem	*ti_next_in_row;
    struct ldap_tmplitem	*ti_next_in_col;
    void			*ti_appdata;
};


#define NULLTMPLITEM	((struct ldap_tmplitem *)0)

#define LDAP_SET_TMPLITEM_APPDATA( ti, datap )	\
	(ti)->ti_appdata = (void *)(datap)

#define LDAP_GET_TMPLITEM_APPDATA( ti, type )	\
	(type)((ti)->ti_appdata)

#define LDAP_IS_TMPLITEM_OPTION_SET( ti, option )	\
	(((ti)->ti_options & option ) != 0 )


/*
 * object class array structure
 */
struct ldap_oclist {
    char		**oc_objclasses;
    struct ldap_oclist	*oc_next;
};

#define NULLOCLIST	((struct ldap_oclist *)0)


/*
 * add defaults list
 */
struct ldap_adddeflist {
    int			ad_source;
#define LDAP_ADSRC_CONSTANTVALUE	1
#define LDAP_ADSRC_ADDERSDN		2
    char		*ad_attrname;
    char		*ad_value;
    struct ldap_adddeflist	*ad_next;
};

#define NULLADLIST	((struct ldap_adddeflist *)0)


/*
 * display template global options
 * if this bit is set in dt_options, it applies.
 */
/*
 * users should be allowed to try to add objects of these entries
 */
#define LDAP_DTMPL_OPT_ADDABLE		0x00000001L

/*
 * users should be allowed to do "modify RDN" operation of these entries
 */
#define LDAP_DTMPL_OPT_ALLOWMODRDN	0x00000002L

/*
 * this template is an alternate view, not a primary view
 */
#define LDAP_DTMPL_OPT_ALTVIEW		0x00000004L


/*
 * display template structure
 */
struct ldap_disptmpl {
    char			*dt_name;
    char			*dt_pluralname;
    char			*dt_iconname;
    unsigned long		dt_options;
    char			*dt_authattrname;
    char			*dt_defrdnattrname;
    char			*dt_defaddlocation;
    struct ldap_oclist		*dt_oclist;
    struct ldap_adddeflist	*dt_adddeflist;
    struct ldap_tmplitem	*dt_items;
    void			*dt_appdata;
    struct ldap_disptmpl	*dt_next;
};

#define NULLDISPTMPL	((struct ldap_disptmpl *)0)

#define LDAP_SET_DISPTMPL_APPDATA( dt, datap )	\
	(dt)->dt_appdata = (void *)(datap)

#define LDAP_GET_DISPTMPL_APPDATA( dt, type )	\
	(type)((dt)->dt_appdata)

#define LDAP_IS_DISPTMPL_OPTION_SET( dt, option )	\
	(((dt)->dt_options & option ) != 0 )

#define LDAP_TMPL_ERR_VERSION	1
#define LDAP_TMPL_ERR_MEM	2
#define LDAP_TMPL_ERR_SYNTAX	3
#define LDAP_TMPL_ERR_FILE	4

/*
 * buffer size needed for entry2text and vals2text
 */
#define LDAP_DTMPL_BUFSIZ	8192


#ifndef NEEDPROTOS

typedef int (*writeptype)();

int ldap_init_templates();
int ldap_init_templates_buf();
void ldap_free_templates();
struct ldap_disptmpl *ldap_first_disptmpl();
struct ldap_disptmpl *ldap_next_disptmpl();
struct ldap_disptmpl *ldap_name2template();
struct ldap_disptmpl *ldap_oc2template();
char **ldap_tmplattrs();
struct ldap_tmplitem *ldap_first_tmplrow();
struct ldap_tmplitem *ldap_next_tmplrow();
struct ldap_tmplitem *ldap_first_tmplcol();
struct ldap_tmplitem *ldap_next_tmplcol();
int ldap_entry2text_search();
int ldap_entry2text();
int ldap_vals2text();
int ldap_entry2html_search();
int ldap_entry2html();
int ldap_vals2html();

#else /* !NEEDPROTOS */

typedef int (*writeptype)( void *writeparm, char *p, int len );

LDAPFUNCDECL int
ldap_init_templates( char *file, struct ldap_disptmpl **tmpllistp );

LDAPFUNCDECL int
ldap_init_templates_buf( char *buf, long buflen,
	struct ldap_disptmpl **tmpllistp );

LDAPFUNCDECL void
ldap_free_templates( struct ldap_disptmpl *tmpllist );

LDAPFUNCDECL struct ldap_disptmpl *
ldap_first_disptmpl( struct ldap_disptmpl *tmpllist );

LDAPFUNCDECL struct ldap_disptmpl *
ldap_next_disptmpl( struct ldap_disptmpl *tmpllist,
	struct ldap_disptmpl *tmpl );

LDAPFUNCDECL struct ldap_disptmpl *
ldap_name2template( char *name, struct ldap_disptmpl *tmpllist );

LDAPFUNCDECL struct ldap_disptmpl *
ldap_oc2template( char **oclist, struct ldap_disptmpl *tmpllist );

LDAPFUNCDECL char **
ldap_tmplattrs( struct ldap_disptmpl *tmpl, char **includeattrs, int exclude,
	 unsigned long syntaxmask );

LDAPFUNCDECL struct ldap_tmplitem *
ldap_first_tmplrow( struct ldap_disptmpl *tmpl );

LDAPFUNCDECL struct ldap_tmplitem *
ldap_next_tmplrow( struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row );

LDAPFUNCDECL struct ldap_tmplitem *
ldap_first_tmplcol( struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row );

LDAPFUNCDECL struct ldap_tmplitem *
ldap_next_tmplcol( struct ldap_disptmpl *tmpl, struct ldap_tmplitem *row,
	struct ldap_tmplitem *col );

LDAPFUNCDECL int
ldap_entry2text( LDAP *ld, char *buf, LDAPMessage *entry,
	struct ldap_disptmpl *tmpl, char **defattrs, char ***defvals,
	writeptype writeproc, void *writeparm, char *eol, int rdncount,
	unsigned long opts );

LDAPFUNCDECL int
ldap_vals2text( LDAP *ld, char *buf, char **vals, char *label, int labelwidth,
	unsigned long syntaxid, writeptype writeproc, void *writeparm,
	char *eol, int rdncount );

LDAPFUNCDECL int
ldap_entry2text_search( LDAP *ld, char *dn, char *base, LDAPMessage *entry,
	struct ldap_disptmpl *tmpllist, char **defattrs, char ***defvals,
	writeptype writeproc, void *writeparm, char *eol, int rdncount,
	unsigned long opts );

LDAPFUNCDECL int
ldap_entry2html( LDAP *ld, char *buf, LDAPMessage *entry,
	struct ldap_disptmpl *tmpl, char **defattrs, char ***defvals,
	writeptype writeproc, void *writeparm, char *eol, int rdncount,
	unsigned long opts, char *urlprefix, char *base );

LDAPFUNCDECL int
ldap_vals2html( LDAP *ld, char *buf, char **vals, char *label, int labelwidth,
	unsigned long syntaxid, writeptype writeproc, void *writeparm,
	char *eol, int rdncount, char *urlprefix );

LDAPFUNCDECL int
ldap_entry2html_search( LDAP *ld, char *dn, char *base, LDAPMessage *entry,
	struct ldap_disptmpl *tmpllist, char **defattrs, char ***defvals,
	writeptype writeproc, void *writeparm, char *eol, int rdncount,
	unsigned long opts, char *urlprefix );
#endif /* !NEEDPROTOS */


#ifdef __cplusplus
}
#endif
#endif /* _DISPTMPL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldapinc\lber.h ===
/*
 * Copyright (c) 1990 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 */

#ifndef _LBER_H
#define _LBER_H

#ifdef __cplusplus
extern "C" {
#endif

#if !defined( NEEDPROTOS ) && defined(__STDC__)
#define NEEDPROTOS	1
#endif

/* BER classes and mask */
#define LBER_CLASS_UNIVERSAL	0x00
#define LBER_CLASS_APPLICATION	0x40
#define LBER_CLASS_CONTEXT	0x80
#define LBER_CLASS_PRIVATE	0xc0
#define LBER_CLASS_MASK		0xc0

/* BER encoding type and mask */
#define LBER_PRIMITIVE		0x00
#define LBER_CONSTRUCTED	0x20
#define LBER_ENCODING_MASK	0x20

#define LBER_BIG_TAG_MASK	0x1f
#define LBER_MORE_TAG_MASK	0x80

/*
 * Note that LBER_ERROR and LBER_DEFAULT are values that can never appear
 * as valid BER tags, and so it is safe to use them to report errors.  In
 * fact, any tag for which the following is true is invalid:
 *     (( tag & 0x00000080 ) != 0 ) && (( tag & 0xFFFFFF00 ) != 0 )
 */
#define LBER_ERROR		0xffffffffL
#define LBER_DEFAULT		0xffffffffL

/* general BER types we know about */
#define LBER_BOOLEAN		0x01L
#define LBER_INTEGER		0x02L
#define LBER_BITSTRING		0x03L
#define LBER_OCTETSTRING	0x04L
#define LBER_NULL		0x05L
#define LBER_ENUMERATED		0x0aL
#define LBER_SEQUENCE		0x30L	/* constructed */
#define LBER_SET		0x31L	/* constructed */

#define OLD_LBER_SEQUENCE	0x10L	/* w/o constructed bit - broken */
#define OLD_LBER_SET		0x11L	/* w/o constructed bit - broken */

#ifdef NEEDPROTOS
typedef int (*BERTranslateProc)( char **bufp, unsigned long *buflenp,
	int free_input );
#else /* NEEDPROTOS */
typedef int (*BERTranslateProc)();
#endif /* NEEDPROTOS */

typedef struct berelement {
	char		*ber_buf;
	char		*ber_ptr;
	char		*ber_end;
	struct seqorset	*ber_sos;
	unsigned long	ber_tag;
	unsigned long	ber_len;
	int		ber_usertag;
	char		ber_options;
#define LBER_USE_DER		0x01
#define LBER_USE_INDEFINITE_LEN	0x02
#define LBER_TRANSLATE_STRINGS	0x04
	char		*ber_rwptr;
	BERTranslateProc ber_encode_translate_proc;
	BERTranslateProc ber_decode_translate_proc;
} BerElement;
#define NULLBER	((BerElement *) 0)

typedef struct sockbuf {
#ifndef MACOS
	int		sb_sd;
#else /* MACOS */
	void		*sb_sd;
#endif /* MACOS */
	BerElement	sb_ber;

	int		sb_naddr;	/* > 0 implies using CLDAP (UDP) */
	void		*sb_useaddr;	/* pointer to sockaddr to use next */
	void		*sb_fromaddr;	/* pointer to message source sockaddr */
	void		**sb_addrs;	/* actually an array of pointers to
						sockaddrs */

	int		sb_options;	/* to support copying ber elements */
#define LBER_TO_FILE		0x01	/* to a file referenced by sb_fd   */
#define LBER_TO_FILE_ONLY	0x02	/* only write to file, not network */
#define LBER_MAX_INCOMING_SIZE	0x04	/* impose limit on incoming stuff  */
#define LBER_NO_READ_AHEAD	0x08	/* read only as much as requested  */
	int		sb_fd;
	long		sb_max_incoming;
} Sockbuf;
#define READBUFSIZ	8192

typedef struct seqorset {
	BerElement	*sos_ber;
	unsigned long	sos_clen;
	unsigned long	sos_tag;
	char		*sos_first;
	char		*sos_ptr;
	struct seqorset	*sos_next;
} Seqorset;
#define NULLSEQORSET	((Seqorset *) 0)

/* structure for returning a sequence of octet strings + length */
struct berval {
	unsigned long	bv_len;
	char		*bv_val;
};

#ifndef NEEDPROTOS
extern BerElement *ber_alloc();
extern BerElement *der_alloc();
extern BerElement *ber_alloc_t();
extern BerElement *ber_dup();
extern int lber_debug;
extern void ber_bvfree();
extern void ber_bvecfree();
extern struct berval *ber_bvdup();
extern void ber_dump();
extern void ber_sos_dump();
extern void lber_bprint();
extern void ber_reset();
extern void ber_init();
#else /* NEEDPROTOS */
#if defined(WINSOCK)
#include "proto-lb.h"
#else
#include "proto-lber.h"
#endif
#endif /* NEEDPROTOS */

#if !defined(__alpha) || defined(VMS)

#define LBER_HTONL( l )	htonl( l )
#define LBER_NTOHL( l )	ntohl( l )

#else /* __alpha */
/*
 * htonl and ntohl on the DEC Alpha under OSF 1 seem to only swap the
 * lower-order 32-bits of a (64-bit) long, so we define correct versions
 * here.
 */
#define LBER_HTONL( l )	(((long)htonl( (l) & 0x00000000FFFFFFFF )) << 32 \
    			| htonl( ( (l) & 0xFFFFFFFF00000000 ) >> 32 ))

#define LBER_NTOHL( l )	(((long)ntohl( (l) & 0x00000000FFFFFFFF )) << 32 \
    			| ntohl( ( (l) & 0xFFFFFFFF00000000 ) >> 32 ))
#endif /* __alpha */


/*
 * SAFEMEMCPY is an overlap-safe copy from s to d of n bytes
 */
#ifdef MACOS
#define SAFEMEMCPY( d, s, n )	BlockMoveData( (Ptr)s, (Ptr)d, n )
#else /* MACOS */
#ifdef sunos4
#define SAFEMEMCPY( d, s, n )	bcopy( s, d, n )
#else /* sunos4 */
#define SAFEMEMCPY( d, s, n )	memmove( d, s, n )
#endif /* sunos4 */
#endif /* MACOS */


#ifdef __cplusplus
}
#endif
#endif /* _LBER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldapinc\ldap.h ===
/*
 * Copyright (c) 1990 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 */

#ifndef _LDAP_H
#define _LDAP_H

#ifdef __cplusplus
extern "C" {
#endif


#ifdef WINSOCK
#include "msdos.h"
#include <winsock.h>
#endif

#if !defined( NEEDPROTOS ) && defined(__STDC__)
#define NEEDPROTOS	1
#endif

#define LDAP_PORT	389
#define LDAP_VERSION1	1
#define LDAP_VERSION2	2
#define LDAP_VERSION	LDAP_VERSION2

#define COMPAT20
#define COMPAT30
#if defined(COMPAT20) || defined(COMPAT30)
#define COMPAT
#endif

#define LDAP_MAX_ATTR_LEN	100

/* debugging stuff */
#ifdef LDAP_DEBUG
extern int	ldap_debug;
#ifdef LDAP_SYSLOG
extern int	ldap_syslog;
extern int	ldap_syslog_level;
#endif
#define LDAP_DEBUG_TRACE	0x001
#define LDAP_DEBUG_PACKETS	0x002
#define LDAP_DEBUG_ARGS		0x004
#define LDAP_DEBUG_CONNS	0x008
#define LDAP_DEBUG_BER		0x010
#define LDAP_DEBUG_FILTER	0x020
#define LDAP_DEBUG_CONFIG	0x040
#define LDAP_DEBUG_ACL		0x080
#define LDAP_DEBUG_STATS	0x100
#define LDAP_DEBUG_STATS2	0x200
#define LDAP_DEBUG_SHELL	0x400
#define LDAP_DEBUG_PARSE	0x800
#define LDAP_DEBUG_ANY		0xffff

#ifdef LDAP_SYSLOG
#define Debug( level, fmt, arg1, arg2, arg3 )	\
	{ \
		if ( ldap_debug & level ) \
			fprintf( stderr, fmt, arg1, arg2, arg3 ); \
		if ( ldap_syslog & level ) \
			syslog( ldap_syslog_level, fmt, arg1, arg2, arg3 ); \
	}
#else /* LDAP_SYSLOG */
#ifndef WINSOCK
#define Debug( level, fmt, arg1, arg2, arg3 ) \
		if ( ldap_debug & level ) \
			fprintf( stderr, fmt, arg1, arg2, arg3 );
#else /* !WINSOCK */
extern void Debug( int level, char* fmt, ... );
#endif /* !WINSOCK */
#endif /* LDAP_SYSLOG */
#else /* LDAP_DEBUG */
#define Debug( level, fmt, arg1, arg2, arg3 )
#endif /* LDAP_DEBUG */

/* 
 * specific LDAP instantiations of BER types we know about
 */

/* general stuff */
#define LDAP_TAG_MESSAGE	0x30L	/* tag is 16 + constructed bit */
#define OLD_LDAP_TAG_MESSAGE	0x10L	/* forgot the constructed bit  */
#define LDAP_TAG_MSGID		0x02L

/* possible operations a client can invoke */
#define LDAP_REQ_BIND			0x60L	/* application + constructed */
#define LDAP_REQ_UNBIND			0x42L	/* application + primitive   */
#define LDAP_REQ_SEARCH			0x63L	/* application + constructed */
#define LDAP_REQ_MODIFY			0x66L	/* application + constructed */
#define LDAP_REQ_ADD			0x68L	/* application + constructed */
#define LDAP_REQ_DELETE			0x4aL	/* application + primitive   */
#define LDAP_REQ_MODRDN			0x6cL	/* application + constructed */
#define LDAP_REQ_COMPARE		0x6eL	/* application + constructed */
#define LDAP_REQ_ABANDON		0x50L	/* application + primitive   */

/* version 3.0 compatibility stuff */
#define LDAP_REQ_UNBIND_30		0x62L
#define LDAP_REQ_DELETE_30		0x6aL
#define LDAP_REQ_ABANDON_30		0x70L

/* 
 * old broken stuff for backwards compatibility - forgot application tag
 * and constructed/primitive bit
 */
#define OLD_LDAP_REQ_BIND		0x00L
#define OLD_LDAP_REQ_UNBIND		0x02L
#define OLD_LDAP_REQ_SEARCH		0x03L
#define OLD_LDAP_REQ_MODIFY		0x06L
#define OLD_LDAP_REQ_ADD		0x08L
#define OLD_LDAP_REQ_DELETE		0x0aL
#define OLD_LDAP_REQ_MODRDN		0x0cL
#define OLD_LDAP_REQ_COMPARE		0x0eL
#define OLD_LDAP_REQ_ABANDON		0x10L

/* possible result types a server can return */
#define LDAP_RES_BIND			0x61L	/* application + constructed */
#define LDAP_RES_SEARCH_ENTRY		0x64L	/* application + constructed */
#define LDAP_RES_SEARCH_RESULT		0x65L	/* application + constructed */
#define LDAP_RES_MODIFY			0x67L	/* application + constructed */
#define LDAP_RES_ADD			0x69L	/* application + constructed */
#define LDAP_RES_DELETE			0x6bL	/* application + constructed */
#define LDAP_RES_MODRDN			0x6dL	/* application + constructed */
#define LDAP_RES_COMPARE		0x6fL	/* application + constructed */
#define LDAP_RES_ANY			(-1L)

/* old broken stuff for backwards compatibility */
#define OLD_LDAP_RES_BIND		0x01L
#define OLD_LDAP_RES_SEARCH_ENTRY	0x04L
#define OLD_LDAP_RES_SEARCH_RESULT	0x05L
#define OLD_LDAP_RES_MODIFY		0x07L
#define OLD_LDAP_RES_ADD		0x09L
#define OLD_LDAP_RES_DELETE		0x0bL
#define OLD_LDAP_RES_MODRDN		0x0dL
#define OLD_LDAP_RES_COMPARE		0x0fL

/* authentication methods available */
#define LDAP_AUTH_NONE		0x00L	/* no authentication		  */
#define LDAP_AUTH_SIMPLE	0x80L	/* context specific + primitive   */
#define LDAP_AUTH_KRBV4		0xffL	/* means do both of the following */
#define LDAP_AUTH_KRBV41	0x81L	/* context specific + primitive   */
#define LDAP_AUTH_KRBV42	0x82L	/* context specific + primitive   */

/* 3.0 compatibility auth methods */
#define LDAP_AUTH_SIMPLE_30	0xa0L	/* context specific + constructed */
#define LDAP_AUTH_KRBV41_30	0xa1L	/* context specific + constructed */
#define LDAP_AUTH_KRBV42_30	0xa2L	/* context specific + constructed */

/* old broken stuff */
#define OLD_LDAP_AUTH_SIMPLE	0x00L
#define OLD_LDAP_AUTH_KRBV4	0x01L
#define OLD_LDAP_AUTH_KRBV42	0x02L

/* filter types */
#define LDAP_FILTER_AND		0xa0L	/* context specific + constructed */
#define LDAP_FILTER_OR		0xa1L	/* context specific + constructed */
#define LDAP_FILTER_NOT		0xa2L	/* context specific + constructed */
#define LDAP_FILTER_EQUALITY	0xa3L	/* context specific + constructed */
#define LDAP_FILTER_SUBSTRINGS	0xa4L	/* context specific + constructed */
#define LDAP_FILTER_GE		0xa5L	/* context specific + constructed */
#define LDAP_FILTER_LE		0xa6L	/* context specific + constructed */
#define LDAP_FILTER_PRESENT	0x87L	/* context specific + primitive   */
#define LDAP_FILTER_APPROX	0xa8L	/* context specific + constructed */

/* 3.0 compatibility filter types */
#define LDAP_FILTER_PRESENT_30	0xa7L	/* context specific + constructed */

/* old broken stuff */
#define OLD_LDAP_FILTER_AND		0x00L
#define OLD_LDAP_FILTER_OR		0x01L
#define OLD_LDAP_FILTER_NOT		0x02L
#define OLD_LDAP_FILTER_EQUALITY	0x03L
#define OLD_LDAP_FILTER_SUBSTRINGS	0x04L
#define OLD_LDAP_FILTER_GE		0x05L
#define OLD_LDAP_FILTER_LE		0x06L
#define OLD_LDAP_FILTER_PRESENT		0x07L
#define OLD_LDAP_FILTER_APPROX		0x08L

/* substring filter component types */
#define LDAP_SUBSTRING_INITIAL	0x80L	/* context specific */
#define LDAP_SUBSTRING_ANY	0x81L	/* context specific */
#define LDAP_SUBSTRING_FINAL	0x82L	/* context specific */

/* 3.0 compatibility substring filter component types */
#define LDAP_SUBSTRING_INITIAL_30	0xa0L	/* context specific */
#define LDAP_SUBSTRING_ANY_30		0xa1L	/* context specific */
#define LDAP_SUBSTRING_FINAL_30		0xa2L	/* context specific */

/* old broken stuff */
#define OLD_LDAP_SUBSTRING_INITIAL	0x00L
#define OLD_LDAP_SUBSTRING_ANY		0x01L
#define OLD_LDAP_SUBSTRING_FINAL	0x02L

/* search scopes */
#define LDAP_SCOPE_BASE		0x00
#define LDAP_SCOPE_ONELEVEL	0x01
#define LDAP_SCOPE_SUBTREE	0x02

/* for modifications */
typedef struct ldapmod {
	int		mod_op;
#define LDAP_MOD_ADD		0x00
#define LDAP_MOD_DELETE		0x01
#define LDAP_MOD_REPLACE	0x02
#define LDAP_MOD_BVALUES	0x80
	char		*mod_type;
	union {
		char		**modv_strvals;
		struct berval	**modv_bvals;
	} mod_vals;
#define mod_values	mod_vals.modv_strvals
#define mod_bvalues	mod_vals.modv_bvals
	struct ldapmod	*mod_next;
} LDAPMod;

/* 
 * possible error codes we can return
 */

#define LDAP_SUCCESS			0x00
#define LDAP_OPERATIONS_ERROR		0x01
#define LDAP_PROTOCOL_ERROR		0x02
#define LDAP_TIMELIMIT_EXCEEDED		0x03
#define LDAP_SIZELIMIT_EXCEEDED		0x04
#define LDAP_COMPARE_FALSE		0x05
#define LDAP_COMPARE_TRUE		0x06
#define LDAP_STRONG_AUTH_NOT_SUPPORTED	0x07
#define LDAP_STRONG_AUTH_REQUIRED	0x08
#define LDAP_PARTIAL_RESULTS		0x09

#define LDAP_NO_SUCH_ATTRIBUTE		0x10
#define LDAP_UNDEFINED_TYPE		0x11
#define LDAP_INAPPROPRIATE_MATCHING	0x12
#define LDAP_CONSTRAINT_VIOLATION	0x13
#define LDAP_TYPE_OR_VALUE_EXISTS	0x14
#define LDAP_INVALID_SYNTAX		0x15

#define LDAP_NO_SUCH_OBJECT		0x20
#define LDAP_ALIAS_PROBLEM		0x21
#define LDAP_INVALID_DN_SYNTAX		0x22
#define LDAP_IS_LEAF			0x23
#define LDAP_ALIAS_DEREF_PROBLEM	0x24

#define NAME_ERROR(n)	((n & 0xf0) == 0x20)

#define LDAP_INAPPROPRIATE_AUTH		0x30
#define LDAP_INVALID_CREDENTIALS	0x31
#define LDAP_INSUFFICIENT_ACCESS	0x32
#define LDAP_BUSY			0x33
#define LDAP_UNAVAILABLE		0x34
#define LDAP_UNWILLING_TO_PERFORM	0x35
#define LDAP_LOOP_DETECT		0x36

#define LDAP_NAMING_VIOLATION		0x40
#define LDAP_OBJECT_CLASS_VIOLATION	0x41
#define LDAP_NOT_ALLOWED_ON_NONLEAF	0x42
#define LDAP_NOT_ALLOWED_ON_RDN		0x43
#define LDAP_ALREADY_EXISTS		0x44
#define LDAP_NO_OBJECT_CLASS_MODS	0x45
#define LDAP_RESULTS_TOO_LARGE		0x46

#define LDAP_OTHER			0x50
#define LDAP_SERVER_DOWN		0x51
#define LDAP_LOCAL_ERROR		0x52
#define LDAP_ENCODING_ERROR		0x53
#define LDAP_DECODING_ERROR		0x54
#define LDAP_TIMEOUT			0x55
#define LDAP_AUTH_UNKNOWN		0x56
#define LDAP_FILTER_ERROR		0x57
#define LDAP_USER_CANCELLED		0x58
#define LDAP_PARAM_ERROR		0x59
#define LDAP_NO_MEMORY			0x5a


/* default limit on nesting of referrals */
#define LDAP_DEFAULT_REFHOPLIMIT	5

/*
 * This structure represents both ldap messages and ldap responses.
 * These are really the same, except in the case of search responses,
 * where a response has multiple messages.
 */

typedef struct ldapmsg {
	int		lm_msgid;	/* the message id */
	int		lm_msgtype;	/* the message type */
	BerElement	*lm_ber;	/* the ber encoded message contents */
	struct ldapmsg	*lm_chain;	/* for search - next msg in the resp */
	struct ldapmsg	*lm_next;	/* next response */
	unsigned long	lm_time;	/* used to maintain cache */
} LDAPMessage;
#define NULLMSG	((LDAPMessage *) NULL)


#ifdef LDAP_REFERRALS
/*
 * structure for tracking LDAP server host, ports, DNs, etc.
 */
typedef struct ldap_server {
	char			*lsrv_host;
	char			*lsrv_dn;	/* if NULL, use default */
	int			lsrv_port;
	struct ldap_server	*lsrv_next;
} LDAPServer;


/*
 * structure for representing an LDAP server connection
 */
typedef struct ldap_conn {
	Sockbuf			*lconn_sb;
	int			lconn_refcnt;
	unsigned long		lconn_lastused;	/* time */
	int			lconn_status;
#define LDAP_CONNST_NEEDSOCKET		1
#define LDAP_CONNST_CONNECTING		2
#define LDAP_CONNST_CONNECTED		3
	LDAPServer		*lconn_server;
	char			*lconn_krbinstance;
	struct ldap_conn	*lconn_next;
} LDAPConn;


/*
 * structure used to track outstanding requests
 */
typedef struct ldapreq {
	int		lr_msgid;	/* the message id */
	int		lr_status;	/* status of request */
#define LDAP_REQST_INPROGRESS	1
#define LDAP_REQST_CHASINGREFS	2
#define LDAP_REQST_NOTCONNECTED	3
#define LDAP_REQST_WRITING	4
	int		lr_outrefcnt;	/* count of outstanding referrals */
	int		lr_origid;	/* original request's message id */
	int		lr_parentcnt;	/* count of parent requests */
	int		lr_res_msgtype;	/* result message type */
	int		lr_res_errno;	/* result LDAP errno */
	char		*lr_res_error;	/* result error string */
	char		*lr_res_matched;/* result matched DN string */
	BerElement	*lr_ber;	/* ber encoded request contents */
	LDAPConn	*lr_conn;	/* connection used to send request */
	struct ldapreq	*lr_parent;	/* request that spawned this referral */
	struct ldapreq	*lr_refnext;	/* next referral spawned */
	struct ldapreq	*lr_prev;	/* previous request */
	struct ldapreq	*lr_next;	/* next request */
} LDAPRequest;
#endif /* LDAP_REFERRALS */


/*
 * structure for client cache
 */
#define LDAP_CACHE_BUCKETS	31	/* cache hash table size */
typedef struct ldapcache {
	LDAPMessage	*lc_buckets[LDAP_CACHE_BUCKETS];/* hash table */
	LDAPMessage	*lc_requests;			/* unfulfilled reqs */
	long		lc_timeout;			/* request timeout */
	long		lc_maxmem;			/* memory to use */
	long		lc_memused;			/* memory in use */
	int		lc_enabled;			/* enabled? */
	unsigned long	lc_options;			/* options */
#define LDAP_CACHE_OPT_CACHENOERRS	0x00000001
#define LDAP_CACHE_OPT_CACHEALLERRS	0x00000002
}  LDAPCache;
#define NULLLDCACHE ((LDAPCache *)NULL)

/*
 * structures for ldap getfilter routines
 */

typedef struct ldap_filt_info {
	char			*lfi_filter;
	char			*lfi_desc;
	int			lfi_scope;	/* LDAP_SCOPE_BASE, etc */
	int			lfi_isexact;	/* exact match filter? */
	struct ldap_filt_info	*lfi_next;
} LDAPFiltInfo;

typedef struct ldap_filt_list {
    char			*lfl_tag;
    char			*lfl_pattern;
    char			*lfl_delims;
    LDAPFiltInfo		*lfl_ilist;
    struct ldap_filt_list	*lfl_next;
} LDAPFiltList;


#define LDAP_FILT_MAXSIZ	1024

typedef struct ldap_filt_desc {
	LDAPFiltList		*lfd_filtlist;
	LDAPFiltInfo		*lfd_curfip;
	LDAPFiltInfo		lfd_retfi;
	char			lfd_filter[ LDAP_FILT_MAXSIZ ];
	char			*lfd_curval;
	char			*lfd_curvalcopy;
	char			**lfd_curvalwords;
	char			*lfd_filtprefix;
	char			*lfd_filtsuffix;
} LDAPFiltDesc;


/*
 * structure representing an ldap connection
 */

typedef struct ldap {
	Sockbuf		ld_sb;		/* socket descriptor & buffer */
	char		*ld_host;
	int		ld_version;
	char		ld_lberoptions;
	int		ld_deref;
#define LDAP_DEREF_NEVER	0
#define LDAP_DEREF_SEARCHING	1
#define LDAP_DEREF_FINDING	2
#define LDAP_DEREF_ALWAYS	3

	int		ld_timelimit;
	int		ld_sizelimit;
#define LDAP_NO_LIMIT		0

	LDAPFiltDesc	*ld_filtd;	/* from getfilter for ufn searches */
	char		*ld_ufnprefix;	/* for incomplete ufn's */

	int		ld_errno;
	char		*ld_error;
	char		*ld_matched;
	int		ld_msgid;

	/* do not mess with these */
#ifdef LDAP_REFERRALS
	LDAPRequest	*ld_requests;	/* list of outstanding requests */
#else /* LDAP_REFERRALS */
	LDAPMessage	*ld_requests;	/* list of outstanding requests */
#endif /* LDAP_REFERRALS */
	LDAPMessage	*ld_responses;	/* list of outstanding responses */
	int		*ld_abandoned;	/* array of abandoned requests */
	char		ld_attrbuffer[LDAP_MAX_ATTR_LEN];
	LDAPCache	*ld_cache;	/* non-null if cache is initialized */
	char		*ld_cldapdn;	/* DN used in connectionless search */

	/* it is OK to change these next four values directly */
	int		ld_cldaptries;	/* connectionless search retry count */
	int		ld_cldaptimeout;/* time between retries */
	int		ld_refhoplimit;	/* limit on referral nesting */
	unsigned long	ld_options;	/* boolean options */
#ifdef LDAP_DNS
#define LDAP_OPT_DNS		0x00000001	/* use DN & DNS */
#endif /* LDAP_DNS */
#ifdef LDAP_REFERRALS
#define LDAP_OPT_REFERRALS	0x00000002	/* chase referrals */
#endif /* LDAP_REFERRALS */
#define LDAP_OPT_RESTART	0x00000004	/* restart if EINTR occurs */

	/* do not mess with the rest though */
	char		*ld_defhost;	/* full name of default server */
	int		ld_defport;	/* port of default server */
	BERTranslateProc ld_lber_encode_translate_proc;
	BERTranslateProc ld_lber_decode_translate_proc;
#ifdef LDAP_REFERRALS
	LDAPConn	*ld_defconn;	/* default connection */
	LDAPConn	*ld_conns;	/* list of server connections */
	void		*ld_selectinfo;	/* platform specifics for select */
	int		(*ld_rebindproc)( struct ldap *ld, char **dnp,
				char **passwdp, int *authmethodp, int freeit );
				/* routine to get info needed for re-bind */
#endif /* LDAP_REFERRALS */
} LDAP;


/*
 * structure for ldap friendly mapping routines
 */

typedef struct friendly {
	char	*f_unfriendly;
	char	*f_friendly;
} FriendlyMap;


/*
 * handy macro to check whether LDAP struct is set up for CLDAP or not
 */
#define LDAP_IS_CLDAP( ld )	( ld->ld_sb.sb_naddr > 0 )


/*
 * types for ldap URL handling
 */
typedef struct ldap_url_desc {
    char	*lud_host;
    int		lud_port;
    char	*lud_dn;
    char	**lud_attrs;
    int		lud_scope;
    char	*lud_filter;
    char	*lud_string;	/* for internal use only */
} LDAPURLDesc;
#define NULLLDAPURLDESC	((LDAPURLDesc *)NULL)

#define LDAP_URL_ERR_NOTLDAP	1	/* URL doesn't begin with "ldap://" */
#define LDAP_URL_ERR_NODN	2	/* URL has no DN (required) */
#define LDAP_URL_ERR_BADSCOPE	3	/* URL scope string is invalid */
#define LDAP_URL_ERR_MEM	4	/* can't allocate memory space */


#ifndef NEEDPROTOS
extern LDAP * ldap_open();
extern LDAP *ldap_init();
#ifdef STR_TRANSLATION
extern void ldap_set_string_translators();
#ifdef LDAP_CHARSET_8859
extern int ldap_t61_to_8859();
extern int ldap_8859_to_t61();
#endif /* LDAP_CHARSET_8859 */
#endif /* STR_TRANSLATION */
extern LDAPMessage *ldap_first_entry();
extern LDAPMessage *ldap_next_entry();
extern char *ldap_get_dn();
extern char *ldap_dn2ufn();
extern char **ldap_explode_dn();
extern char *ldap_first_attribute();
extern char *ldap_next_attribute();
extern char **ldap_get_values();
extern struct berval **ldap_get_values_len();
extern void ldap_value_free();
extern void ldap_value_free_len();
extern int ldap_count_values();
extern int ldap_count_values_len();
extern char *ldap_err2string();
extern void ldap_getfilter_free();
extern LDAPFiltDesc *ldap_init_getfilter();
extern LDAPFiltDesc *ldap_init_getfilter_buf();
extern LDAPFiltInfo *ldap_getfirstfilter();
extern LDAPFiltInfo *ldap_getnextfilter();
extern void ldap_setfilteraffixes();
extern void ldap_build_filter();
extern void ldap_flush_cache();
extern void ldap_set_cache_options();
extern void ldap_uncache_entry();
extern void ldap_uncache_request();
extern char *ldap_friendly_name();
extern void ldap_free_friendlymap();
extern LDAP *cldap_open();
extern void cldap_setretryinfo();
extern void cldap_close();
extern LDAPFiltDesc *ldap_ufn_setfilter();
extern int ldap_ufn_timeout();
extern int ldap_sort_entries();
extern int ldap_sort_values();
extern int ldap_sort_strcasecmp();
void ldap_free_urldesc();
void ldap_set_rebind_proc();
void ldap_enable_translation();


#if defined(ultrix) || defined(VMS) || defined( nextstep )
extern char *strdup();
#endif

#else /* NEEDPROTOS */
#if !defined(MACOS) && !defined(DOS) && !defined(_WIN32) && !defined(WINSOCK)
#include <sys/time.h>
#endif
#if defined(WINSOCK)
#include "proto-ld.h"
#else
#include "proto-ldap.h"
#endif

#ifdef VMS
extern char *strdup( const char *s );
#endif
#if defined(ultrix) || defined( nextstep )
extern char *strdup();
#endif

#endif /* NEEDPROTOS */

#ifdef __cplusplus
}
#endif
#endif /* _LDAP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldapinc\msdos.h ===
/* wsa.h */
/*
 * Copyright (c) 1993 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 */

#ifndef _MSDOS_H
#define _MSDOS_H

/*
 * NOTE: This file should be included via ldap.h.  Many symbols are
 * defined here that are needed BEFORE anything else is included.
 * Be careful !!!
 */
/*
 * The following are defined within the Integrated Development Environment
 * of Microsoft's Visual C++ Compiler (v1.52c)
 * (Options/Project/Compiler/Preprocessor/Symbols and Macros to Define)
 * But there's a (buffer length) limit to how long this list can be, so 
 * I'm doing the rest here in msdos.h
 * WINSOCK, DOS, NEEDPROTOS, NO_USERINTERFACE
 */
/*
 * MIT's krb.h doesn't use the symbols provided by Microsoft.
 * It needs __MSDOS__ and WINDOWS.  Normally _WINDOWS is provided by MS
 * but it's based on having the prolog/epilog optimization switches set
 * in a way that we don't set them. So define it manually.
 *
 * kbind.c needs __MSDOS__ for krb.h to include osconf.h 
 * which includes conf-pc.h which defines byte order and such
 */
#define __MSDOS__
/*
 * conf-pc.h wants WINDOWS rather than _WINDOWS which Microsoft provides
 */
#define WINDOWS

/*
 * Where two of the config files live in the windows environment
 * There are two others also; ldfriend.cfg, & srchpref.cfg
 * These names are different that the unix names due to 8.3 rule
 */
#define FILTERFILE 	"ldfilter.cfg"
#define TEMPLATEFILE 	"disptmpl.cfg"
/*
 * These are not automatically defined for us even though we're a DLL.  They
 * are triggered by prolog/epilog configuration options that we don't use.
 * But be careful not to redefine them for other apps that include this file.
 */
#ifndef _WINDLL
/*
 * Needed by wshelper.h
 */
#define _WINDLL
#endif

#ifndef _WINDOWS
/*
 * Needed by authlib.h via kerberos.c via AUTHMAN
 */
#define _WINDOWS 1
#endif
  
/*
 * KERBEROS must be defined as a preprocessor symbol in the compiler.
 * It's too late to define it in this file.
 */

/*
 * AUTHMAN - Use Authlib.dll as a higher level interface to krbv4win.dll 
 * (kerberos).  If defined, get_kerberosv4_credentials in kerberos.c is
 * used and authlib.dll (and krbv4win.dll) are dynamically loaded and used.  
 * If AUTHMAN is not defined, the get_kerberosv4_credentials in 
 * kbind.c works just fine, but requires the presence of krbv4win.dll at
 * load time.
 */
/* don't want to be dependent on authman
 * #define AUTHMAN
 */

/*
 * define WSHELPER if you want wsockip.c to use rgethostbyaddr() (in
 * WSHELPER.DLL) rather than gethostbyaddr().  You might want this if your
 * gethostbyaddr() returns the WRONG host name and you want to use
 * kerberos authentication (need host name to form service ticket
 * request).  Most won't want kerberos, and of those, there might actually
 * be some vendors who really do the lookup rather than use cached info
 * from gethostbyname() calls.
 */
#define WSHELPER
/*
 * The new slapd stuff
 */
#define LDAP_REFERRALS
/*
 * LDAP character string translation routines
 * I compiled and tested these and they seemed to work.
 * The thing to test with is: 
 *   cn=Charset Test Entry, ou=SWITCHdirectory, o=SWITCH, c=CH
 *
 * I'm disabling it for release.
#define STR_TRANSLATION
#define LDAP_CHARSET_8859 88591
#define LDAP_DEFAULT_CHARSET LDAP_CHARSET_8859
 */



#define LDAP_DEBUG
#include <winsock.h>


#include <string.h>
#include <malloc.h>
#ifndef _WIN32
#define memcpy( a, b, n )	_fmemcpy( a, b, n )
#define strcpy( a, b )		_fstrcpy( a, b )
#define strchr( a, c )		_fstrchr( a, c )
#endif /* !_WIN32 */
#define strcasecmp(a,b) 	stricmp(a,b)
#define strncasecmp(a,b,len) 	strnicmp(a,b,len)

#endif /* _MSDOS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldapinc\proto-ld.h ===
/*
 * proto-ldap.h
 * function prototypes for ldap library
 */


#ifndef LDAPFUNCDECL
#ifdef _WIN32
#define LDAPFUNCDECL	__declspec( dllexport ) 
#else /* _WIN32 */
#define LDAPFUNCDECL    
#endif /* _WIN32 */
#endif /* LDAPFUNCDECL */


/*
 * in abandon.c:
 */
LDAPFUNCDECL int __cdecl ldap_abandon( LDAP *ld, int msgid );

/*
 * in add.c:
 */
LDAPFUNCDECL int __cdecl ldap_add( LDAP *ld, char *dn, LDAPMod **attrs );
LDAPFUNCDECL int __cdecl ldap_add_s( LDAP *ld, char *dn, LDAPMod **attrs );

/*
 * in bind.c:
 */
LDAPFUNCDECL int __cdecl ldap_bind( LDAP *ld, char *who, char *passwd, int authmethod );
LDAPFUNCDECL int __cdecl ldap_bind_s( LDAP *ld, char *who, char *cred, int method );
#ifdef LDAP_REFERRALS
LDAPFUNCDECL void __cdecl ldap_set_rebind_proc( LDAP *ld, int (*rebindproc)( LDAP *ld,
	char **dnp, char **passwdp, int *authmethodp, int freeit ));
#endif /* LDAP_REFERRALS */

/*
 * in sbind.c:
 */
LDAPFUNCDECL int __cdecl ldap_simple_bind( LDAP *ld, char *who, char *passwd );
LDAPFUNCDECL int __cdecl ldap_simple_bind_s( LDAP *ld, char *who, char *passwd );

/*
 * in kbind.c:
 */
LDAPFUNCDECL int __cdecl ldap_kerberos_bind_s( LDAP *ld, char *who );
LDAPFUNCDECL int __cdecl ldap_kerberos_bind1( LDAP *ld, char *who );
LDAPFUNCDECL int __cdecl ldap_kerberos_bind1_s( LDAP *ld, char *who );
LDAPFUNCDECL int __cdecl ldap_kerberos_bind2( LDAP *ld, char *who );
LDAPFUNCDECL int __cdecl ldap_kerberos_bind2_s( LDAP *ld, char *who );
 

#ifndef NO_CACHE
/*
 * in cache.c
 */
LDAPFUNCDECL int __cdecl ldap_enable_cache( LDAP *ld, long timeout, long maxmem );
LDAPFUNCDECL void __cdecl ldap_disable_cache( LDAP *ld );
LDAPFUNCDECL void __cdecl ldap_set_cache_options( LDAP *ld, unsigned long opts );
LDAPFUNCDECL void __cdecl ldap_destroy_cache( LDAP *ld );
LDAPFUNCDECL void __cdecl ldap_flush_cache( LDAP *ld );
LDAPFUNCDECL void __cdecl ldap_uncache_entry( LDAP *ld, char *dn );
LDAPFUNCDECL void __cdecl ldap_uncache_request( LDAP *ld, int msgid );
#endif /* !NO_CACHE */

/*
 * in compare.c:
 */
LDAPFUNCDECL int __cdecl ldap_compare( LDAP *ld, char *dn, char *attr, char *value );
LDAPFUNCDECL int __cdecl ldap_compare_s( LDAP *ld, char *dn, char *attr, char *value );

/*
 * in delete.c:
 */
LDAPFUNCDECL int __cdecl ldap_delete( LDAP *ld, char *dn );
LDAPFUNCDECL int __cdecl ldap_delete_s( LDAP *ld, char *dn );

/*
 * in error.c:
 */
LDAPFUNCDECL int __cdecl ldap_result2error( LDAP *ld, LDAPMessage *r, int freeit );
LDAPFUNCDECL char * __cdecl ldap_err2string( int err );
LDAPFUNCDECL void __cdecl ldap_perror( LDAP *ld, char *s );

/*
 * in modify.c:
 */
LDAPFUNCDECL int __cdecl ldap_modify( LDAP *ld, char *dn, LDAPMod **mods );
LDAPFUNCDECL int __cdecl ldap_modify_s( LDAP *ld, char *dn, LDAPMod **mods );

/*
 * in modrdn.c:
 */
LDAPFUNCDECL int __cdecl ldap_modrdn( LDAP *ld, char *dn, char *newrdn );
LDAPFUNCDECL int __cdecl ldap_modrdn_s( LDAP *ld, char *dn, char *newrdn );
LDAPFUNCDECL int __cdecl ldap_modrdn2( LDAP *ld, char *dn, char *newrdn,
	int deleteoldrdn );
LDAPFUNCDECL int __cdecl ldap_modrdn2_s( LDAP *ld, char *dn, char *newrdn,
	int deleteoldrdn);

/*
 * in open.c:
 */
LDAPFUNCDECL LDAP * __cdecl ldap_open( char *host, int port );
LDAPFUNCDECL LDAP * __cdecl ldap_init( char *defhost, int defport );

/*
 * in getentry.c:
 */
LDAPFUNCDECL LDAPMessage * __cdecl ldap_first_entry( LDAP *ld, LDAPMessage *chain );
LDAPFUNCDECL LDAPMessage * __cdecl ldap_next_entry( LDAP *ld, LDAPMessage *entry );
LDAPFUNCDECL int  __cdecl ldap_count_entries( LDAP *ld, LDAPMessage *chain );

/*
 * in addentry.c
 */
LDAPFUNCDECL LDAPMessage * __cdecl ldap_delete_result_entry( LDAPMessage **list,
	LDAPMessage *e );
LDAPFUNCDECL void  __cdecl ldap_add_result_entry( LDAPMessage **list, LDAPMessage *e );

/*
 * in getdn.c
 */
LDAPFUNCDECL char * __cdecl ldap_get_dn( LDAP *ld, LDAPMessage *entry );
LDAPFUNCDECL char * __cdecl ldap_dn2ufn( char *dn );
LDAPFUNCDECL char ** __cdecl ldap_explode_dn( char *dn, int notypes );
LDAPFUNCDECL char ** __cdecl ldap_explode_dns( char *dn );
LDAPFUNCDECL int __cdecl  ldap_is_dns_dn( char *dn );

/*
 * in getattr.c
 */
LDAPFUNCDECL char * __cdecl ldap_first_attribute( LDAP *ld, LDAPMessage *entry,
	BerElement **ber );
LDAPFUNCDECL char * __cdecl ldap_next_attribute( LDAP *ld, LDAPMessage *entry,
	BerElement *ber );

/*
 * in getvalues.c
 */
LDAPFUNCDECL char ** __cdecl ldap_get_values( LDAP *ld, LDAPMessage *entry, char *target );
LDAPFUNCDECL struct berval ** __cdecl ldap_get_values_len( LDAP *ld, LDAPMessage *entry,
	char *target );
LDAPFUNCDECL int  __cdecl ldap_count_values( char **vals );
LDAPFUNCDECL int  __cdecl ldap_count_values_len( struct berval **vals );
LDAPFUNCDECL void  __cdecl ldap_value_free( char **vals );
LDAPFUNCDECL void  __cdecl ldap_value_free_len( struct berval **vals );

/*
 * in result.c:
 */
LDAPFUNCDECL int  __cdecl ldap_result( LDAP *ld, int msgid, int all,
	struct timeval *timeout, LDAPMessage **result );
LDAPFUNCDECL int  __cdecl ldap_msgfree( LDAPMessage *lm );
LDAPFUNCDECL int  __cdecl ldap_msgdelete( LDAP *ld, int msgid );

/*
 * in search.c:
 */
LDAPFUNCDECL int  __cdecl ldap_search( LDAP *ld, char *base, int scope, char *filter,
	char **attrs, int attrsonly );
LDAPFUNCDECL int  __cdecl ldap_search_s( LDAP *ld, char *base, int scope, char *filter,
	char **attrs, int attrsonly, LDAPMessage **res );
LDAPFUNCDECL int  __cdecl ldap_search_st( LDAP *ld, char *base, int scope, char *filter,
    char **attrs, int attrsonly, struct timeval *timeout, LDAPMessage **res );

/*
 * in ufn.c
 */
LDAPFUNCDECL int  __cdecl ldap_ufn_search_c( LDAP *ld, char *ufn, char **attrs,
	int attrsonly, LDAPMessage **res, int (*cancelproc)( void *cl ),
	void *cancelparm );
LDAPFUNCDECL int  __cdecl ldap_ufn_search_ct( LDAP *ld, char *ufn, char **attrs,
	int attrsonly, LDAPMessage **res, int (*cancelproc)( void *cl ),
	void *cancelparm, char *tag1, char *tag2, char *tag3 );
LDAPFUNCDECL int  __cdecl ldap_ufn_search_s( LDAP *ld, char *ufn, char **attrs,
	int attrsonly, LDAPMessage **res );
LDAPFUNCDECL LDAPFiltDesc * __cdecl ldap_ufn_setfilter( LDAP *ld, char *fname );
LDAPFUNCDECL void  __cdecl ldap_ufn_setprefix( LDAP *ld, char *prefix );
LDAPFUNCDECL int __cdecl  ldap_ufn_timeout( void *tvparam );


/*
 * in unbind.c
 */
LDAPFUNCDECL int  __cdecl ldap_unbind( LDAP *ld );
LDAPFUNCDECL int  __cdecl ldap_unbind_s( LDAP *ld );


/*
 * in getfilter.c
 */
LDAPFUNCDECL LDAPFiltDesc * __cdecl ldap_init_getfilter( char *fname );
LDAPFUNCDECL LDAPFiltDesc * __cdecl ldap_init_getfilter_buf( char *buf, long buflen );
LDAPFUNCDECL LDAPFiltInfo * __cdecl ldap_getfirstfilter( LDAPFiltDesc *lfdp, char *tagpat,
	char *value );
LDAPFUNCDECL LDAPFiltInfo * __cdecl ldap_getnextfilter( LDAPFiltDesc *lfdp );
LDAPFUNCDECL void  __cdecl ldap_setfilteraffixes( LDAPFiltDesc *lfdp, char *prefix, char *suffix );
LDAPFUNCDECL void  __cdecl ldap_build_filter( char *buf, unsigned long buflen,
	char *pattern, char *prefix, char *suffix, char *attr,
	char *value, char **valwords );

/*
 * in free.c
 */
LDAPFUNCDECL void  __cdecl ldap_getfilter_free( LDAPFiltDesc *lfdp );
LDAPFUNCDECL void  __cdecl ldap_mods_free( LDAPMod **mods, int freemods );

/*
 * in friendly.c
 */
LDAPFUNCDECL char * __cdecl ldap_friendly_name( char *filename, char *uname,
	FriendlyMap **map );
LDAPFUNCDECL void  __cdecl ldap_free_friendlymap( FriendlyMap **map );


/*
 * in cldap.c
 */
LDAPFUNCDECL LDAP *cldap_open( char *host, int port );
LDAPFUNCDECL void cldap_close( LDAP *ld );
LDAPFUNCDECL int cldap_search_s( LDAP *ld, char *base, int scope, char *filter,
	char **attrs, int attrsonly, LDAPMessage **res, char *logdn );
LDAPFUNCDECL void cldap_setretryinfo( LDAP *ld, int tries, int timeout );


/*
 * in sort.c
 */
LDAPFUNCDECL int ldap_sort_entries( LDAP *ld, LDAPMessage **chain, char *attr,
	int (*cmp)() );
LDAPFUNCDECL int ldap_sort_values( LDAP *ld, char **vals, int (*cmp)() );
LDAPFUNCDECL int ldap_sort_strcasecmp( char **a, char **b );


/*
 * in url.c
 */
LDAPFUNCDECL int  __cdecl ldap_is_ldap_url( char *url );
LDAPFUNCDECL int  __cdecl ldap_url_parse( char *url, LDAPURLDesc **ludpp );
LDAPFUNCDECL void  __cdecl ldap_free_urldesc( LDAPURLDesc *ludp );
LDAPFUNCDECL int  __cdecl ldap_url_search( LDAP *ld, char *url, int attrsonly );
LDAPFUNCDECL int  __cdecl ldap_url_search_s( LDAP *ld, char *url, int attrsonly,
	LDAPMessage **res );
LDAPFUNCDECL int  __cdecl ldap_url_search_st( LDAP *ld, char *url, int attrsonly,
	struct timeval *timeout, LDAPMessage **res );


/*
 * in charset.c
 */
#ifdef STR_TRANSLATION
LDAPFUNCDECL void  __cdecl ldap_set_string_translators( LDAP *ld,
	BERTranslateProc encode_proc, BERTranslateProc decode_proc );
LDAPFUNCDECL int  __cdecl ldap_translate_from_t61( LDAP *ld, char **bufp,
	unsigned long *lenp, int free_input );
LDAPFUNCDECL int  __cdecl ldap_translate_to_t61( LDAP *ld, char **bufp,
	unsigned long *lenp, int free_input );
LDAPFUNCDECL void  __cdecl ldap_enable_translation( LDAP *ld, LDAPMessage *entry,
	int enable );

#ifdef LDAP_CHARSET_8859
LDAPFUNCDECL int  __cdecl ldap_t61_to_8859( char **bufp, unsigned long *buflenp,
	int free_input );
LDAPFUNCDECL int  __cdecl ldap_8859_to_t61( char **bufp, unsigned long *buflenp,
	int free_input );
#endif /* LDAP_CHARSET_8859 */
#endif /* STR_TRANSLATION */


#ifdef WINSOCK
/*
 * in msdos/winsock/wsa.c
 */
LDAPFUNCDECL void  __cdecl ldap_memfree( void *p );
#endif /* WINSOCK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldapinc\srchpref.h ===
/*
 * Copyright (c) 1993, 1994 Regents of the University of Michigan.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and that due credit is given
 * to the University of Michigan at Ann Arbor. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
 *
 * searchpref.h:  display template library defines
 * 16 May 1994 by Gordon Good
 */


#ifndef _SRCHPREF_H
#define _SRCHPREF_H

#ifdef __cplusplus
extern "C" {
#endif


struct ldap_searchattr {
	char				*sa_attrlabel;
	char				*sa_attr;
					/* max 32 matchtypes for now */
	unsigned long			sa_matchtypebitmap;
	char				*sa_selectattr;
	char				*sa_selecttext;
	struct ldap_searchattr		*sa_next;
};

struct ldap_searchmatch {
	char				*sm_matchprompt;
	char				*sm_filter;
	struct ldap_searchmatch		*sm_next;
};

struct ldap_searchobj {
	char				*so_objtypeprompt;
	unsigned long			so_options;
	char				*so_prompt;
	short				so_defaultscope;
	char				*so_filterprefix;
	char				*so_filtertag;
	char				*so_defaultselectattr;
	char				*so_defaultselecttext;
	struct ldap_searchattr		*so_salist;
	struct ldap_searchmatch		*so_smlist;
	struct ldap_searchobj		*so_next;
};

#define NULLSEARCHOBJ			((struct ldap_searchobj *)0)

/*
 * global search object options
 */
#define LDAP_SEARCHOBJ_OPT_INTERNAL	0x00000001

#define LDAP_IS_SEARCHOBJ_OPTION_SET( so, option )	\
	(((so)->so_options & option ) != 0 )

#define LDAP_SEARCHPREF_VERSION_ZERO	0
#define LDAP_SEARCHPREF_VERSION		1

#define LDAP_SEARCHPREF_ERR_VERSION	1
#define LDAP_SEARCHPREF_ERR_MEM		2
#define LDAP_SEARCHPREF_ERR_SYNTAX	3
#define LDAP_SEARCHPREF_ERR_FILE	4


#ifndef NEEDPROTOS
int			ldap_init_searchprefs();
int			ldap_init_searchprefs_buf();
void			ldap_free_searchprefs();
struct ldap_searchobj	*ldap_first_searchobj();
struct ldap_searchobj	*ldap_next_searchobj();

#else /* !NEEDPROTOS */

LDAPFUNCDECL int
ldap_init_searchprefs( char *file, struct ldap_searchobj **solistp );

LDAPFUNCDECL int
ldap_init_searchprefs_buf( char *buf, long buflen,
	struct ldap_searchobj **solistp );

LDAPFUNCDECL void
ldap_free_searchprefs( struct ldap_searchobj *solist );

LDAPFUNCDECL struct ldap_searchobj *
ldap_first_searchobj( struct ldap_searchobj *solist );

LDAPFUNCDECL struct ldap_searchobj *
ldap_next_searchobj( struct ldap_searchobj *sollist,
	struct ldap_searchobj *so );

#endif /* !NEEDPROTOS */


#ifdef __cplusplus
}
#endif
#endif /* _SRCHPREF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\ldapinc\proto-lb.h ===
/*
 * lber-proto.h
 * function prototypes for lber library
 */

#ifdef LDAP_DEBUG
extern int lber_debug;
#endif

#ifndef LDAPFUNCDECL
#ifdef _WIN32
#define LDAPFUNCDECL	__declspec( dllexport )
#else /* _WIN32 */
#define LDAPFUNCDECL
#endif /* _WIN32 */
#endif /* LDAPFUNCDECL */

/*
 * in bprint.c:
 */
LDAPFUNCDECL void lber_bprint( char *data, int len );

/*
 * in decode.c:
 */
LDAPFUNCDECL unsigned long ber_get_tag( BerElement *ber );
LDAPFUNCDECL unsigned long ber_skip_tag( BerElement *ber, unsigned long *len );
LDAPFUNCDECL unsigned long ber_peek_tag( BerElement *ber, unsigned long *len );
LDAPFUNCDECL unsigned long ber_get_int( BerElement *ber, long *num );
LDAPFUNCDECL unsigned long ber_get_stringb( BerElement *ber, char *buf,
	unsigned long *len );
LDAPFUNCDECL unsigned long ber_get_stringa( BerElement *ber, char **buf );
LDAPFUNCDECL unsigned long ber_get_stringal( BerElement *ber, struct berval **bv );
LDAPFUNCDECL unsigned long ber_get_bitstringa( BerElement *ber, char **buf,
	unsigned long *len );
LDAPFUNCDECL unsigned long ber_get_null( BerElement *ber );
LDAPFUNCDECL unsigned long ber_get_boolean( BerElement *ber, int *boolval );
LDAPFUNCDECL unsigned long ber_first_element( BerElement *ber, unsigned long *len,
	char **last );
LDAPFUNCDECL unsigned long ber_next_element( BerElement *ber, unsigned long *len,
	char *last );
#if defined( MACOS ) || defined( BC31 ) || defined( _WIN32 )
LDAPFUNCDECL unsigned long ber_scanf( BerElement *ber, char *fmt, ... );
#else
LDAPFUNCDECL unsigned long ber_scanf();
#endif
LDAPFUNCDECL void ber_bvfree( struct berval *bv );
LDAPFUNCDECL void ber_bvecfree( struct berval **bv );
LDAPFUNCDECL struct berval *ber_bvdup( struct berval *bv );
#ifdef STR_TRANSLATION
LDAPFUNCDECL void ber_set_string_translators( BerElement *ber,
	BERTranslateProc encode_proc, BERTranslateProc decode_proc );
#endif /* STR_TRANSLATION */

/*
 * in encode.c
 */
LDAPFUNCDECL int ber_put_enum( BerElement *ber, long num, unsigned long tag );
LDAPFUNCDECL int ber_put_int( BerElement *ber, long num, unsigned long tag );
LDAPFUNCDECL int ber_put_ostring( BerElement *ber, char *str, unsigned long len,
	unsigned long tag );
LDAPFUNCDECL int ber_put_string( BerElement *ber, char *str, unsigned long tag );
LDAPFUNCDECL int ber_put_bitstring( BerElement *ber, char *str,
	unsigned long bitlen, unsigned long tag );
LDAPFUNCDECL int ber_put_null( BerElement *ber, unsigned long tag );
LDAPFUNCDECL int ber_put_boolean( BerElement *ber, int boolval,
	unsigned long tag );
LDAPFUNCDECL int ber_start_seq( BerElement *ber, unsigned long tag );
LDAPFUNCDECL int ber_start_set( BerElement *ber, unsigned long tag );
LDAPFUNCDECL int ber_put_seq( BerElement *ber );
LDAPFUNCDECL int ber_put_set( BerElement *ber );
#if defined( MACOS ) || defined( BC31 ) || defined( _WIN32 )
LDAPFUNCDECL int ber_printf( BerElement *ber, char *fmt, ... );
#else
LDAPFUNCDECL int ber_printf();
#endif

/*
 * in io.c:
 */
LDAPFUNCDECL long ber_read( BerElement *ber, char *buf, unsigned long len );
LDAPFUNCDECL long ber_write( BerElement *ber, char *buf, unsigned long len,
	int nosos );
LDAPFUNCDECL void ber_free( BerElement *ber, int freebuf );
LDAPFUNCDECL int ber_flush( Sockbuf *sb, BerElement *ber, int freeit );
LDAPFUNCDECL BerElement *ber_alloc( void );
LDAPFUNCDECL BerElement *der_alloc( void );
LDAPFUNCDECL BerElement *ber_alloc_t( int options );
LDAPFUNCDECL BerElement *ber_dup( BerElement *ber );
LDAPFUNCDECL void ber_dump( BerElement *ber, int inout );
LDAPFUNCDECL void ber_sos_dump( Seqorset *sos );
LDAPFUNCDECL unsigned long ber_get_next( Sockbuf *sb, unsigned long *len,
	BerElement *ber );
LDAPFUNCDECL void ber_init( BerElement *ber, int options );
LDAPFUNCDECL void ber_reset( BerElement *ber, int was_writing );

#ifdef NEEDGETOPT
/*
 * in getopt.c
 */
int getopt( int nargc, char **nargv, char *ostr );
#endif /* NEEDGETOPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\encode.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#define UNICODE
#define _UNICODE


#include "dswarn.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>
#include <winldap.h>
#include <adserr.h>


#include "memory.h"


#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )

HRESULT 
ADsEncodeBinaryData (
   PBYTE   pbSrcData,
   DWORD   dwSrcLen,
   LPWSTR  * ppszDestData
   )
{
    LPWSTR pszDest = NULL;
    DWORD dwDestLen, dwDestSize = 0;
    WCHAR wch;

    if (!ppszDestData || (!pbSrcData && dwSrcLen))
        return (E_ADS_BAD_PARAMETER);

    *ppszDestData = NULL;

    //
    //  figure out how long of a buffer we need.
    //

    dwDestLen = ldap_escape_filter_element (
                         (char *) pbSrcData,
                         dwSrcLen,
                         NULL,
                         0
                         );

    if (dwDestLen == 0) {
        return S_OK;
    }

    dwDestSize = dwDestLen * sizeof (WCHAR);

    pszDest = (LPWSTR) AllocADsMem(  dwDestSize );
    if (pszDest == NULL) 
        return  (E_OUTOFMEMORY );

    dwDestLen = ldap_escape_filter_element (
                    (char *) pbSrcData,
                    dwSrcLen,
                    pszDest,
                    dwDestSize
                    );
    if(dwDestLen)
    {
        if(pszDest)
        {
            FreeADsMem(pszDest);
        }
        return (E_FAIL);
    }

    *ppszDestData = pszDest;

    return (S_OK);

}

HRESULT 
ADsDecodeBinaryData (
   LPWSTR szSrcData,
   PBYTE  *ppbDestData,
   ULONG  *pdwDestLen
   )
{
    HRESULT hr = S_OK;
    ULONG dwDestLen = 0;
    LPWSTR szSrc = NULL;
    PBYTE pbDestData = NULL;
    PBYTE pbDestDataCurrent = NULL;
    WCHAR ch = 0;

    if (szSrcData == NULL) {
        return E_FAIL;
    }

    // 
    // Counting length of output binary string
    //
    szSrc = szSrcData;
    while (*szSrc != L'\0') {
        ch = *(szSrc++);

        if (ch == L'\\') {
            szSrc = szSrc + 2;
        }
        dwDestLen++;
    }
    

    // 
    // Allocating return binary string
    //
    pbDestData = (PBYTE) AllocADsMem(dwDestLen);
    if (pbDestData == NULL) {
        hr = E_OUTOFMEMORY;
        return (hr);
    }

    // 
    // Decoding String
    //
    szSrc = szSrcData;
        pbDestDataCurrent = pbDestData;
    while (*szSrc != L'\0') {
        ch = *szSrc ++;

        if (ch == L'\\') {
            *(pbDestDataCurrent++) = MAPHEXTODIGIT( *szSrc ) * 16 +
                                     MAPHEXTODIGIT( *(szSrc+1) );
            szSrc+=2;
        }
        else {
            *(pbDestDataCurrent++) = (BYTE)ch;
        }
    }

    *ppbDestData = pbDestData;
    *pdwDestLen = dwDestLen;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\adsi.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

class ADS_OBJECT_HANDLE
{
public:
    ADS_LDP *_ld;
    LPWSTR  _pszADsPath;
    LPWSTR  _pszLDAPServer;
    LPWSTR  _pszLDAPDn;
    CCredentials _Credentials;
    LDAP_SEARCH_PREF  _SearchPref;
    DWORD   _dwPort;

    ADS_OBJECT_HANDLE( ADS_LDP *ld,
                       LPWSTR pszADsPath,
                       LPWSTR pszLDAPServer,
                       LPWSTR pszLDAPDn,
                       CCredentials Credentials,
                       DWORD dwPort
                       );

    ~ADS_OBJECT_HANDLE();

};

ADS_OBJECT_HANDLE::ADS_OBJECT_HANDLE( ADS_LDP *ld,
                                      LPWSTR pszADsPath,
                                      LPWSTR pszLDAPServer,
                                      LPWSTR pszLDAPDn,
                                      CCredentials Credentials,
                                      DWORD dwPort
                                      )
{

    _ld = ld;
    _pszADsPath = pszADsPath;
    _pszLDAPServer = pszLDAPServer;
    _pszLDAPDn = pszLDAPDn;
    _Credentials = Credentials;
    _dwPort = dwPort;
    LdapInitializeSearchPreferences(&_SearchPref, FALSE);
}

ADS_OBJECT_HANDLE::~ADS_OBJECT_HANDLE()
{
    if ( _ld )
    {
        LdapCloseObject( _ld);
        _ld = NULL;
    }

    if ( _pszADsPath )
    {
        FreeADsStr( _pszADsPath );
        _pszADsPath = NULL;
    }

    if (_pszLDAPServer) {
        FreeADsStr(_pszLDAPServer);
        _pszLDAPServer = NULL;
    }

    if (_pszLDAPDn) {
        FreeADsStr(_pszLDAPDn);
        _pszLDAPDn = NULL;
    }

    //
    // Free sort keys if applicable.
    //
    if (_SearchPref._pSortKeys) {
        FreeSortKeys(_SearchPref._pSortKeys, _SearchPref._nSortKeys);
    }

    //
    // Free the VLV information if applicable
    //
    if (_SearchPref._pVLVInfo) {
        FreeLDAPVLVInfo(_SearchPref._pVLVInfo);
    }    

    //
    // Free the attribute-scoped query information if applicable
    //
    if (_SearchPref._pAttribScoped) {
        FreeADsStr(_SearchPref._pAttribScoped);
    }
}


HRESULT
ADSIOpenDSObject(
    LPWSTR pszDNName,
    LPWSTR pszUserName,
    LPWSTR pszPassword,
    LONG   lnReserved,
    PHANDLE phDSObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwPort = 0;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    ADS_LDP *ld = NULL;
    LPWSTR pszADsPath = NULL;
    LPWSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    ADS_OBJECT_HANDLE *pADsObjectHandle = NULL;

    LPWSTR szAttributes[2] = { L"objectClass", NULL };
    int nCount;
    LDAPMessage *res = NULL;
    LONG lnFlags = lnReserved;


    if (lnFlags & ADS_FAST_BIND) {
        // mask it out as openobject does not know about the flag
        lnFlags &= ~ADS_FAST_BIND;
    }

    CCredentials Credentials( pszUserName, pszPassword, lnFlags );


    pszADsPath = AllocADsStr( pszDNName );
    if ( pszADsPath == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildLDAPPathFromADsPath2(
             pszDNName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE( hr);

    if (pszLDAPDn == NULL) {
        //
        // LDAP://Server is not valid in ldapc
        // LDAP://RootDSE is valid though
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    if (!_wcsicmp(pszLDAPDn, L"rootdse")) {
        FreeADsStr(pszLDAPDn);
        pszLDAPDn = NULL;
    }

    hr = LdapOpenObject(
                    pszLDAPServer,
                    pszLDAPDn,
                    &ld,
                    Credentials,
                    dwPort
                    );

    BAIL_ON_FAILURE(hr);


    if (!(lnReserved & ADS_FAST_BIND)) {

        // if fast bind is not specified we need to get the objectClass

        hr = LdapSearchS(
                 ld,
                 pszLDAPDn,
                 LDAP_SCOPE_BASE,
                 L"(objectClass=*)",
                 szAttributes,
                 0,
                 &res
                 );

        if (  FAILED(hr)
              || ((nCount = LdapCountEntries( ld, res)) == 0))
        {
            if (!FAILED(hr)) {
                hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
            }
        }

        // Need to free the message if one came back
        if (res) {
            LdapMsgFree(res);
            res = NULL;
        }

        BAIL_ON_FAILURE(hr);
    }

    pADsObjectHandle = new ADS_OBJECT_HANDLE(
                               ld, pszADsPath,
                               pszLDAPServer, pszLDAPDn,
                               Credentials, dwPort
                               );

    if ( pADsObjectHandle == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *phDSObject = (HANDLE) pADsObjectHandle;

    RRETURN(S_OK);

error:

    if ( pszADsPath )
        FreeADsStr( pszADsPath );

    if ( pszLDAPServer )
        FreeADsStr( pszLDAPServer );

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    if ( ld )
        LdapCloseObject( ld );

    *phDSObject = NULL;

    RRETURN(hr);

}


HRESULT
ADSICloseDSObject(
    HANDLE hDSObject
    )
{
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    delete pADsObjectHandle;

    RRETURN(S_OK);
}


HRESULT
ADSISetObjectAttributes(
    HANDLE hDSObject,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;
    SECURITY_INFORMATION seInfo = OWNER_SECURITY_INFORMATION
                                 | GROUP_SECURITY_INFORMATION
                                 | DACL_SECURITY_INFORMATION;

    //
    // seInfo is the default value for now anyone wanting to set
    // the SACL will have to use IDirectoryObject.
    //


    hr = ADsSetObjectAttributes(
             pADsObjectHandle->_ld,
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort,
             seInfo,
             pAttributeEntries,
             dwNumAttributes,
             pdwNumAttributesModified
             );

    RRETURN(hr);
}


HRESULT
ADSIGetObjectAttributes(
    HANDLE hDSObject,
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;
    SECURITY_INFORMATION seInfo = OWNER_SECURITY_INFORMATION
                                 | GROUP_SECURITY_INFORMATION
                                 | DACL_SECURITY_INFORMATION;

    //
    // seInfo is the default value for now anyone wanting to read
    // the SACL will have to use IDirectoryObject.
    //

    hr = ADsGetObjectAttributes(
             pADsObjectHandle->_ld,
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort,
             seInfo,
             pAttributeNames,
             dwNumberAttributes,
             ppAttributeEntries,
             pdwNumAttributesReturned
             );

    RRETURN(hr);
}


HRESULT
ADSICreateDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hParentDSObject;

    hr = ADsCreateDSObject(
             pADsObjectHandle->_ld,
             pADsObjectHandle->_pszADsPath,
             pszRDNName,
             pAttributeEntries,
             dwNumAttributes
             );

    RRETURN(hr);
}


HRESULT
ADSIDeleteDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hParentDSObject;

    hr = ADsDeleteDSObject(
             pADsObjectHandle->_ld,
             pADsObjectHandle->_pszADsPath,
             pszRDNName
             );

    RRETURN(hr);
}


HRESULT
ADSISetSearchPreference(
    HANDLE hDSObject,
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsSetSearchPreference(
             pSearchPrefs,
             dwNumPrefs,
             &(pADsObjectHandle->_SearchPref),
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort
             );

    RRETURN(hr);
}



HRESULT
ADSIExecuteSearch(
    HANDLE hDSObject,
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsExecuteSearch(
             pADsObjectHandle->_SearchPref,
             pADsObjectHandle->_pszADsPath,
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pszSearchFilter,
             pAttributeNames,
             dwNumberAttributes,
             phSearchHandle
             );

    RRETURN(hr);
}


HRESULT
ADSIAbandonSearch(
    HANDLE hDSObject,
    IN PADS_SEARCH_HANDLE phSearchHandle
    )
{
    HRESULT hr = S_OK;

    ADsAssert(phSearchHandle);

    hr = ADsAbandonSearch(
             *phSearchHandle
             );

    RRETURN(hr);
}



HRESULT
ADSICloseSearchHandle (
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    hr = ADsCloseSearchHandle(
             hSearchHandle
             );

    RRETURN(hr);
}


HRESULT
ADSIGetFirstRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetFirstRow(
             hSearchHandle,
             pADsObjectHandle->_Credentials
             );

    RRETURN(hr);
}


HRESULT
ADSIGetNextRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetNextRow(
             hSearchHandle,
             pADsObjectHandle->_Credentials
             );

    RRETURN(hr);
}


HRESULT
ADSIGetPreviousRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetPreviousRow(
             hSearchHandle,
             pADsObjectHandle->_Credentials
             );

    RRETURN(hr);
}


HRESULT
ADSIGetColumn(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetColumn(
             hSearchHandle,
             pszColumnName,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort,
             pColumn
             );

    RRETURN(hr);
}


HRESULT
ADSIGetNextColumnName(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsGetNextColumnName(
             hSearchHandle,
             ppszColumnName
             );

    RRETURN(hr);
}


HRESULT
ADSIFreeColumn(
    HANDLE hDSObject,
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsFreeColumn(
             pColumn
             );

    RRETURN(hr);
}

HRESULT
ADSIEnumAttributes(
    HANDLE hDSObject,
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;

    hr = ADsEnumAttributes(
             pADsObjectHandle->_pszLDAPServer,
             pADsObjectHandle->_pszLDAPDn,
             pADsObjectHandle->_Credentials,
             pADsObjectHandle->_dwPort,
             ppszAttrNames,
             dwNumAttributes,
             ppAttrDefinition,
             pdwNumAttributes
             );

    RRETURN(hr);
}


HRESULT
ADSICreateAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsCreateAttributeDefinition(
             pszAttributeName,
             pAttributeDefinition
             );
    RRETURN(hr);
}


HRESULT
ADSIWriteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsWriteAttributeDefinition(
             pszAttributeName,
             pAttributeDefinition
             );

    RRETURN(hr);
}

HRESULT
ADSIDeleteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName
    )
{
    HRESULT hr = S_OK;

    hr = ADsDeleteAttributeDefinition(
             pszAttributeName
             );

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   ADSIModifyRDN
//
//  Synopsis: Rename the object from the ldapc layer. This is just
//           a wrapper for LDAPModRdnS.
//
//
//  Arguments:  Handle to the object being renamed.
//              new RDN of the object.
//
//-------------------------------------------------------------------------

HRESULT
ADSIModifyRdn(
    HANDLE hDSObject,
    LPWSTR pszOldRdn,
    LPWSTR pszNewRdn
    )
{
    HRESULT hr = S_OK;
    ADS_OBJECT_HANDLE *pADsObjectHandle = (ADS_OBJECT_HANDLE *) hDSObject;
    TCHAR *pszOldDN = NULL;
    DWORD dwLen = 0;

    if (!pszOldRdn || !pszNewRdn) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    dwLen = wcslen(pADsObjectHandle->_pszLDAPDn) + wcslen(pszOldRdn) + 2;

    pszOldDN = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );

    if (!pszOldDN) {
        RRETURN (hr = E_OUTOFMEMORY);
    }

    // Build the DN of the object being renamed
    wsprintf(pszOldDN, L"%s,", pszOldRdn);

    wcscat(pszOldDN, pADsObjectHandle->_pszLDAPDn);


    hr = LdapModRdnS(
             pADsObjectHandle->_ld,
             pszOldDN,
             pszNewRdn
             );

    if (pszOldDN) {
        FreeADsStr(pszOldDN);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\adsiutil.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

//
//Hard Coded Support for RootDSE object
//

LPWSTR SpecialSyntaxesTable[] =
{
   LDAP_OPATT_CURRENT_TIME_W,
   LDAP_OPATT_SUBSCHEMA_SUBENTRY_W,
   LDAP_OPATT_SERVER_NAME_W,
   LDAP_OPATT_NAMING_CONTEXTS_W,
   LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
   LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W,
   LDAP_OPATT_CONFIG_NAMING_CONTEXT_W,
   LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W,
   LDAP_OPATT_SUPPORTED_CONTROL_W,
   LDAP_OPATT_SUPPORTED_LDAP_VERSION_W,
   L"lowestUncommittedUSN",
   L"allowedAttributesEffective",
   L"supportedExtension",
   L"altServer",
   NULL
};



HRESULT
ComputeAttributeBufferSize(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize,
    PDWORD pdwNumValues
    );

LPBYTE
CopyAttributeName(
    PADS_ATTR_INFO pThisAdsSrcAttribute,
    PADS_ATTR_INFO pThisAdsTargAttribute,
    LPBYTE pDataBuffer
    );

HRESULT
ADsSetObjectAttributes(
    ADS_LDP *ld,
    LPTSTR  pszLDAPServer,
    LPTSTR  pszLDAPDn,
    CCredentials Credentials,
    DWORD dwPort,
    SECURITY_INFORMATION seInfo,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;

    DWORD i = 0;
    DWORD j = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    LDAPOBJECTARRAY ldapObjectArray;
    DWORD dwSyntaxId = 0;

    LDAPMod  **aMods = NULL;
    LDAPModW *aModsBuffer = NULL;
    DWORD dwNumAttributesReturn = 0;
    BOOL fNTSecDescriptor = FALSE;
    int ldaperr = 0;
    DWORD dwOptions = 0;

    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;
    BOOL fModifyDone = FALSE;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)seInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    LDAPControl     ModifyControl =
                    {
                        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                        {
                            0, NULL
                        },
                        FALSE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    PLDAPControl    ServerControlsOnlyModify[2] =
                    {
                        &ModifyControl,
                        NULL
                    };

    PLDAPControl    ServerControlsAll[3] =
                    {
                        &SeInfoControl,
                        &ModifyControl,
                        NULL
                    };

    BOOL fServerIsAD = FALSE;


    *pdwNumAttributesModified = 0;

    //
    // Allocate memory to send the modify request
    //

    aMods = (LDAPModW **) AllocADsMem((dwNumAttributes+1) * sizeof(LDAPModW*));
    if ( aMods == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    aModsBuffer = (LDAPModW *) AllocADsMem( dwNumAttributes * sizeof(LDAPModW));
    if ( aModsBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Format the modify request
    //
    for (i = 0; i < dwNumAttributes; i++) {

        BOOL fGenTime = FALSE;
        LDAPOBJECTARRAY_INIT(ldapObjectArray);

        pThisAttribute = pAttributeEntries + i;

        if(!pThisAttribute)
        {
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
        }

        if (!fNTSecDescriptor
            && _wcsicmp(L"ntSecurityDescriptor", pThisAttribute->pszAttrName)
                        == 0)
        {

            {
                // we need to use appropriate controls if the operation
                // is modify the security descriptor. Specifically we do
                // not want to use any control if the operation is a clear
                // and default to whatever the server deems fit.
                if (pThisAttribute->dwControlCode != ADS_ATTR_CLEAR) {
                   fNTSecDescriptor = TRUE;
                }
            }
        }

        if (pThisAttribute->dwControlCode != ADS_ATTR_CLEAR) {
            //
            // If this is a time attribute, see if it is GenTime or
            // UTCTime and set the syntax the flag appropriately
            //
            if (pThisAttribute->dwADsType == ADSTYPE_UTC_TIME) {

                hr = LdapGetSyntaxOfAttributeOnServer(
                         pszLDAPServer,
                         pThisAttribute->pszAttrName,
                         &dwSyntaxId,
                         Credentials,
                         dwPort
                         );
                if (SUCCEEDED(hr) && (dwSyntaxId == LDAPTYPE_GENERALIZEDTIME)) {
                    //
                    // Use GenTime conversion
                    //
                    fGenTime = TRUE;
                }

            }

        }

        switch (pThisAttribute->dwControlCode) {
        case ADS_ATTR_UPDATE:
            hr = AdsTypeToLdapTypeCopyConstruct(
                        pThisAttribute->pADsValues,
                        pThisAttribute->dwNumValues,
                        &ldapObjectArray,
                        &dwSyntaxId,
                        fGenTime
                        );
            BAIL_ON_FAILURE(hr);

            aMods[i] = &aModsBuffer[i];
            aModsBuffer[i].mod_type = pThisAttribute->pszAttrName;

            if ( ldapObjectArray.fIsString )
            {
                aModsBuffer[i].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
            }
            else
            {
                aModsBuffer[i].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
                aModsBuffer[i].mod_op = LDAP_MOD_BVALUES;
            }

            aModsBuffer[i].mod_op |= LDAP_MOD_REPLACE;
            dwNumAttributesReturn++;
            break;

        case ADS_ATTR_APPEND:
            hr = AdsTypeToLdapTypeCopyConstruct(
                        pThisAttribute->pADsValues,
                        pThisAttribute->dwNumValues,
                        &ldapObjectArray,
                        &dwSyntaxId,
                        fGenTime
                        );
            BAIL_ON_FAILURE(hr);

            aMods[i] = &aModsBuffer[i];
            aModsBuffer[i].mod_type = pThisAttribute->pszAttrName;

            if ( ldapObjectArray.fIsString )
            {
                aModsBuffer[i].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
            }
            else
            {
                aModsBuffer[i].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
                aModsBuffer[i].mod_op = LDAP_MOD_BVALUES;
            }

            aModsBuffer[i].mod_op |= LDAP_MOD_ADD;
            dwNumAttributesReturn++;
            break;

        case ADS_ATTR_CLEAR:
            aMods[i] = &aModsBuffer[i];
            aModsBuffer[i].mod_type   = pThisAttribute->pszAttrName;
            aModsBuffer[i].mod_bvalues = NULL;
            aModsBuffer[i].mod_op |= LDAP_MOD_DELETE;
            dwNumAttributesReturn++;
            break;

        case ADS_ATTR_DELETE:
            hr = AdsTypeToLdapTypeCopyConstruct(
                        pThisAttribute->pADsValues,
                        pThisAttribute->dwNumValues,
                        &ldapObjectArray,
                        &dwSyntaxId,
                        fGenTime
                        );
            BAIL_ON_FAILURE(hr);

            aMods[i] = &aModsBuffer[i];
            aModsBuffer[i].mod_type = pThisAttribute->pszAttrName;

            if ( ldapObjectArray.fIsString )
            {
                aModsBuffer[i].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
            }
            else
            {
                aModsBuffer[i].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
                aModsBuffer[i].mod_op = LDAP_MOD_BVALUES;
            }

            aModsBuffer[i].mod_op |= LDAP_MOD_DELETE;
            dwNumAttributesReturn++;
            break;


        default:
            //
            // ignore this attribute and move on
            //
            break;


        }


    }

    //
    // Find out if server is AD.
    //
    hr = ReadServerSupportsIsADControl(
             pszLDAPServer,
             &fServerIsAD,
             Credentials,
             dwPort
             );
    if (FAILED(hr)) {
        //
        // Assume it is not AD and continue, there is no
        // good reason for this to fail on AD.
        //
        fServerIsAD = FALSE;
    }

    //
    // Modify the object with appropriate call
    //
    if (fNTSecDescriptor) {
        //
        // Check if we are V3
        //
        ldaperr = ldap_get_option(
                      ld->LdapHandle,
                      LDAP_OPT_VERSION,
                      &dwOptions
                      );

        //
        // check supported controls and set accordingly
        //

        if (ldaperr == LDAP_SUCCESS && (dwOptions == LDAP_VERSION3)) {


            //
            // Read the security descriptor type if applicable
            //
            hr = ReadSecurityDescriptorControlType(
                     pszLDAPServer,
                     &dwSecDescType,
                     Credentials,
                     dwPort
                     );

            if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT)) {

                hr = LdapModifyExtS(
                         ld,
                         pszLDAPDn,
                         aMods,
                         fServerIsAD ?
                            (PLDAPControl *) &ServerControlsAll :
                            (PLDAPControl *) &ServerControls,
                         NULL
                         );

                fModifyDone = TRUE;

            }
        } // If Read Version succeeded
    }

    //
    // Perform a simple modify - only if fModifyDone is false
    //

    if (!fModifyDone) {

        if (fServerIsAD) {

            //
            // Need to send the OID that allows delete on empty attributes
            // without sending an error - for clients that have gotten used
            // to bad practices.
            //
            hr = LdapModifyExtS(
                     ld,
                     pszLDAPDn,
                     aMods,
                     (PLDAPControl *)&ServerControlsOnlyModify,
                     NULL
                     );
        }
        else {

            //
            // Regular calls from most folks not using AD.
            //
            hr = LdapModifyS(
                 ld,
                 pszLDAPDn,
                 aMods
                 );
        }
    }

    BAIL_ON_FAILURE(hr);

    *pdwNumAttributesModified = dwNumAttributesReturn;

error:

    if ( aModsBuffer )
    {
        for ( j = 0; j < i; j++ )
        {
             if ( aModsBuffer[j].mod_op & LDAP_MOD_BVALUES )
             {
                 if ( aModsBuffer[j].mod_bvalues )
                 {
                     for ( DWORD k = 0; aModsBuffer[j].mod_bvalues[k]; k++ )
                         FreeADsMem( aModsBuffer[j].mod_bvalues[k] );

                     FreeADsMem( aModsBuffer[j].mod_bvalues );
                 }
             }
             else if ( aModsBuffer[j].mod_values )
             {
                 for ( DWORD k = 0; aModsBuffer[j].mod_values[k]; k++ )
                     FreeADsMem( aModsBuffer[j].mod_values[k] );

                 FreeADsMem( aModsBuffer[j].mod_values );
             }
        }

        FreeADsMem( aModsBuffer );
    }

    if ( aMods )
        FreeADsMem( aMods );

    return hr;
}


HRESULT
ADsGetObjectAttributes(
    ADS_LDP *ld,
    LPTSTR  pszLDAPServer,
    LPTSTR  pszLDAPDn,
    CCredentials Credentials,
    DWORD dwPort,
    SECURITY_INFORMATION seInfo,
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;

    DWORD i = 0;
    DWORD j = 0;

    LPWSTR *aStrings = NULL;

    LDAPMessage *res = NULL;
    LDAPMessage *entry = NULL;
    void *ptr;
    DWORD dwNumberOfEntries = 0;
    LPTSTR pszAttrName = NULL;
    LDAPOBJECTARRAY ldapObjectArray;
    PADSVALUE pAdsDestValues = NULL;
    DWORD dwNumAdsValues = 0;
    DWORD dwAdsType = 0;

    DWORD dwSyntaxId = 0;

    PADS_ATTR_INFO pAdsAttributes = NULL;
    PADS_ATTR_INFO pThisAttributeDef = NULL;

    LPBYTE pAttributeBuffer = NULL;
    DWORD dwAttrCount = 0;

    DWORD dwMemSize = 0;
    DWORD dwTotalValues = 0;
    DWORD dwNumValues = 0;
    LPBYTE pValueBuffer = NULL;
    LPBYTE pDataBuffer = NULL;
    PADS_ATTR_INFO pAttrEntry = NULL;
    PADSVALUE pAttrValue  = NULL;

    PADS_ATTR_INFO pThisAdsSrcAttribute = NULL;
    PADS_ATTR_INFO pThisAdsTargAttribute = NULL;
    PADSVALUE pThisAdsSrcValue = NULL;
    PADSVALUE pThisAdsTargValue = NULL;

    *ppAttributeEntries = NULL;
    *pdwNumAttributesReturned = 0;

    DWORD ldaperr = 0;
    DWORD dwOptions = 0;

    BOOLEAN getSecDesc = FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;
    BOOLEAN fSearchDone = FALSE;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)seInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    LDAPOBJECTARRAY_INIT(ldapObjectArray);

    if (dwNumberAttributes != (DWORD)-1)
    {

        if ( dwNumberAttributes == 0 )
            return S_OK;

        if(!pAttributeNames)
        {
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Package attributes
        //

        aStrings = (LPWSTR *) AllocADsMem( sizeof(LPTSTR) * (dwNumberAttributes + 1));

        if ( aStrings == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for ( i = 0; i < dwNumberAttributes; i++)
        {
            if(!pAttributeNames[i])
            {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            
            }
            
            aStrings[i] = pAttributeNames[i];

            if (!getSecDesc &&
                _wcsicmp(L"ntSecurityDescriptor", pAttributeNames[i]) == 0) {
                // we need go to get the security descriptor
                getSecDesc = TRUE;
            }
        }
    }
    else
    {
        //
        // If all attributes are requested, we will mark as read
        // security descriptor also. Further down, the decision to
        // use or not use a control is made.
        //
        getSecDesc = TRUE;
    }

    //
    // Read the DS Object
    //

    // modified from LdapSearchS to LdapSearchExtS to get all attributes
    // including SecurityDescriptor by one call

    if (getSecDesc) {

        ldaperr = ldap_get_option(
                        ld->LdapHandle,
                        LDAP_OPT_VERSION,
                        &dwOptions
                        );

        if (dwOptions == LDAP_VERSION3) {

            //
            // Read the security descriptor type if applicable
            //
            hr = ReadSecurityDescriptorControlType(
                     pszLDAPServer,
                     &dwSecDescType,
                     Credentials,
                     dwPort
                     );

            //
            // If we could no get the control information for whatever reason,
            // just try the SearchS.
            //

            if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT)) {

                hr = LdapSearchExtS(
                         ld,
                         pszLDAPDn,
                         LDAP_SCOPE_BASE,
                         TEXT("(objectClass=*)"),
                         aStrings,
                         0,
                         (PLDAPControl *)&ServerControls,
                         NULL,
                         NULL,
                         10000,
                         &res
                         );

                fSearchDone = TRUE;


            }
        }
    }

    //
    // Perform just a LdapSearchS if the flag indicates that
    // no search has been done. We do not try a second search
    // if the first tone failed (saves packets on the wire).
    //
    if (!fSearchDone) {

        hr = LdapSearchS(
                    ld,
                    pszLDAPDn,
                    LDAP_SCOPE_BASE,
                    TEXT("(objectClass=*)"),
                    aStrings,
                    0,
                    &res
                    );

        fSearchDone = TRUE;

        BAIL_ON_FAILURE(hr);

    }


    //
    // Should only contain one entry
    //

    if ( LdapCountEntries( ld, res ) == 0 )
        goto error;

    hr = LdapFirstEntry( ld, res, &entry );
    BAIL_ON_FAILURE(hr);

    //
    // Compute the number of attributes in the
    // read buffer.
    //

    hr = LdapFirstAttribute( ld, entry, &ptr, &pszAttrName );
    BAIL_ON_FAILURE(hr);

    while ( pszAttrName != NULL )
    {
        dwNumberOfEntries++;
        LdapAttributeFree( pszAttrName );
        pszAttrName = NULL;

        hr = LdapNextAttribute( ld, entry, ptr, &pszAttrName );
        if (FAILED(hr))
            break;   // error occurred, ignore the rest of the attributes
    }

    //
    // Allocate an attribute buffer which is as large as the
    // number of attributes present
    //
    //

    // Note that pADsAttributes is inited to Null
    if (dwNumberOfEntries != 0) {

        pAdsAttributes = (PADS_ATTR_INFO)AllocADsMem(
                               sizeof(ADS_ATTR_INFO) * dwNumberOfEntries
                               );
        if (!pAdsAttributes)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    dwAttrCount = 0;
    ptr = NULL;
    hr = LdapFirstAttribute( ld, entry, &ptr, &pszAttrName );

    while (  SUCCEEDED(hr)
          && ( pszAttrName != NULL )
          && ( dwAttrCount < dwNumberOfEntries )
          )
    {
        //
        // Get the syntax of the attribute. Force only
        // if we know that the this is not the RootDSE
        // as RootDSE attributes are not in schema.
        //
        hr = LdapGetSyntaxOfAttributeOnServer(
                 pszLDAPServer,
                 pszAttrName,
                 &dwSyntaxId,
                 Credentials,
                 dwPort,
                 pszLDAPDn ? TRUE : FALSE
                 );

        //
        // If it failed with errorcode 0x8000500D which is
        // E_ADS_PROPERTY_NOT_FOUND,
        // see if it is one of the RootDSE syntaxes,
        // if so set Syntax to ADSTYPE_CASE_IGNORE_STRING
        //

        if (hr == E_ADS_PROPERTY_NOT_FOUND) {

            //
            // search the hardcoded table to see if it is a known entry
            //

            BOOLEAN valFound = FALSE;
            DWORD ctr = 0;
            while (SpecialSyntaxesTable[ctr] && !valFound) {
                if (!_wcsicmp(pszAttrName, SpecialSyntaxesTable[ctr])) {
                    dwSyntaxId = ADSTYPE_CASE_IGNORE_STRING;
                    hr = S_OK;
                    valFound = TRUE;
                }
                ctr++;
            }
        }else {

            if (!_wcsicmp(pszAttrName, L"ntSecurityDescriptor")) {
                dwSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;
            }
        }

        if ( hr == E_ADS_PROPERTY_NOT_FOUND ) {
            //
            // We will default to provider specific
            //
            dwSyntaxId = LDAPTYPE_UNKNOWN;
        }
        else if (FAILED(hr)) {
            //
            // Some other failure so skip attribute
            //
            goto NextAttr;
        }

        //
        // Get the values of the current attribute
        //
        hr = UnMarshallLDAPToLDAPSynID(
                    pszAttrName,
                    ld,
                    entry,
                    dwSyntaxId,
                    &ldapObjectArray
                    );

        if ( FAILED(hr))
            goto NextAttr;

        hr = LdapTypeToAdsTypeCopyConstruct(
                    ldapObjectArray,
                    dwSyntaxId,
                    &pAdsDestValues,
                    &dwNumAdsValues,
                    &dwAdsType
                    );

        if (FAILED(hr))
            goto NextAttr;

        pThisAttributeDef = pAdsAttributes + dwAttrCount;
        pThisAttributeDef->pszAttrName = AllocADsStr(pszAttrName);

        if ( !pThisAttributeDef->pszAttrName )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pThisAttributeDef->pADsValues = pAdsDestValues;
        if ( pThisAttributeDef->dwNumValues = ldapObjectArray.dwCount )
            pThisAttributeDef->dwADsType = pAdsDestValues[0].dwType;
        dwAttrCount++;

NextAttr:

        if ( pszAttrName ) {
            LdapAttributeFree( pszAttrName );
            pszAttrName = NULL;
        }

        if ( ldapObjectArray.pLdapObjects )
        {
            if ( ldapObjectArray.fIsString )
                LdapValueFree( (TCHAR **) ldapObjectArray.pLdapObjects );
            else
                LdapValueFreeLen( (struct berval **) ldapObjectArray.pLdapObjects );

            LDAPOBJECTARRAY_INIT(ldapObjectArray);
        }

        if ( hr == E_OUTOFMEMORY )  // break on serious error
            break;

        hr = LdapNextAttribute( ld, entry, ptr, &pszAttrName );
    }

    BAIL_ON_FAILURE(hr);

    if ( dwAttrCount == 0 )
        goto error;

    //
    // Now package this data into a single contiguous buffer
    //

    hr =  ComputeAttributeBufferSize(
                pAdsAttributes,
                dwAttrCount,
                &dwMemSize,
                &dwTotalValues
                );
    BAIL_ON_FAILURE(hr);

    pAttributeBuffer = (LPBYTE) AllocADsMem( dwMemSize );

    if (!pAttributeBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pValueBuffer = pAttributeBuffer + dwAttrCount * (sizeof(ADS_ATTR_INFO));
    pDataBuffer = pValueBuffer + dwTotalValues * sizeof(ADSVALUE);

    pAttrEntry = (PADS_ATTR_INFO) pAttributeBuffer;
    pAttrValue = (PADSVALUE) pValueBuffer;

    for (i = 0; i < dwAttrCount; i++) {

        pThisAdsSrcAttribute = pAdsAttributes + i;
        pThisAdsTargAttribute = pAttrEntry + i;

        dwNumValues = pThisAdsSrcAttribute->dwNumValues;

        pThisAdsTargAttribute->dwNumValues = dwNumValues;
        pThisAdsTargAttribute->dwADsType =  pThisAdsSrcAttribute->dwADsType;
        pThisAdsTargAttribute->pADsValues = pAttrValue;

        pThisAdsSrcValue = pThisAdsSrcAttribute->pADsValues;
        pThisAdsTargValue = pAttrValue;

        if (!pDataBuffer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for ( j = 0; j < dwNumValues; j++) {

            pDataBuffer = AdsTypeCopy(
                                pThisAdsSrcValue,
                                pThisAdsTargValue,
                                pDataBuffer
                                );
            pAttrValue++;
            pThisAdsTargValue = pAttrValue;
            pThisAdsSrcValue++;

        }

        if (!pDataBuffer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pDataBuffer = CopyAttributeName(
                                pThisAdsSrcAttribute,
                                pThisAdsTargAttribute,
                                pDataBuffer
                                );

    }

    hr = S_OK;

error:

    if ( aStrings )
        FreeADsMem( aStrings );

    if ( res )
        LdapMsgFree( res );

    //
    // Clean up the header based Ods structures
    //

    if ( pAdsAttributes ) {

        for (i = 0; i < dwAttrCount; i++)
        {
            pThisAttributeDef = pAdsAttributes + i;
            FreeADsStr( pThisAttributeDef->pszAttrName );

            AdsTypeFreeAdsObjects( pThisAttributeDef->pADsValues,
                                   pThisAttributeDef->dwNumValues );
        }

        FreeADsMem( pAdsAttributes );
    }

    if (FAILED(hr))
    {
        if ( pAttributeBuffer )
            FreeADsMem(pAttributeBuffer);

        *ppAttributeEntries = NULL;
        *pdwNumAttributesReturned = 0;
    }
    else
    {
        *ppAttributeEntries = (PADS_ATTR_INFO)pAttributeBuffer;
        *pdwNumAttributesReturned = dwAttrCount;
    }

    return hr;
}

HRESULT
ADsCreateDSObjectExt(
    ADS_LDP *ld,
    LPTSTR ADsPath,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    SECURITY_INFORMATION seInfo,
    BOOL fSecDesc
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszAbsoluteName = NULL;
    TCHAR *pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwSyntaxId = 0;

    DWORD dwPort = 0;

    DWORD i = 0;
    DWORD j = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    LDAPOBJECTARRAY ldapObjectArray;
    LDAPMod  **aMods = NULL;
    LDAPModW *aModsBuffer = NULL;

    BYTE berValue[8];

    memset(berValue, 0, 8);

    berValue[0] = 0x30; // Start sequence tag
    berValue[1] = 0x03; // Length in bytes of following
    berValue[2] = 0x02; // Actual value this and next 2
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)seInfo);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    //
    // Get the LDAP path of the object to create
    //
    hr = BuildADsPathFromParent(
                ADsPath,
                pszRDNName,
                &pszAbsoluteName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             pszAbsoluteName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Allocate memory to store the add request
    //
    aMods = (LDAPModW **) AllocADsMem((dwNumAttributes+1) * sizeof(LDAPModW*));
    if ( aMods == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    aModsBuffer = (LDAPModW *) AllocADsMem( dwNumAttributes * sizeof(LDAPModW));
    if ( aModsBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Format the add request
    //
    for (i = 0; i < dwNumAttributes; i++) {

        BOOL fGenTime = FALSE;

        LDAPOBJECTARRAY_INIT(ldapObjectArray);

        pThisAttribute = pAttributeEntries + i;
        
        if (pThisAttribute->dwControlCode != ADS_ATTR_CLEAR) {
            //
            // If this is a time attribute, see if it is GenTime or
            // UTCTime and set the syntax the flag appropriately
            //
            if (pThisAttribute->dwADsType == ADSTYPE_UTC_TIME) {

                hr = LdapGetSyntaxOfAttributeOnServer(
                         pszLDAPServer,
                         pThisAttribute->pszAttrName,
                         &dwSyntaxId,
                         (*ld->pCredentials),
                         ld->PortNumber
                         );
                if (SUCCEEDED(hr) && (dwSyntaxId == LDAPTYPE_GENERALIZEDTIME)) {
                    //
                    // Use GenTime conversion
                    //
                    fGenTime = TRUE;
                }

            }

        }

        hr = AdsTypeToLdapTypeCopyConstruct(
                    pThisAttribute->pADsValues,
                    pThisAttribute->dwNumValues,
                    &ldapObjectArray,
                    &dwSyntaxId,
                    fGenTime
                    );
        BAIL_ON_FAILURE(hr);

        aMods[i] = &aModsBuffer[i];
        aModsBuffer[i].mod_type = pThisAttribute->pszAttrName;

        if ( ldapObjectArray.fIsString )
        {
            aModsBuffer[i].mod_values = (TCHAR **) ldapObjectArray.pLdapObjects;
        }
        else
        {
            aModsBuffer[i].mod_bvalues = (struct berval **) ldapObjectArray.pLdapObjects;
            aModsBuffer[i].mod_op = LDAP_MOD_BVALUES;
        }

        aModsBuffer[i].mod_op |= LDAP_MOD_REPLACE;
    }

    if (fSecDesc) {

        hr = LdapAddExtS(
                 ld,
                 pszLDAPDn,
                 aMods,
                 (PLDAPControl *)&ServerControls,
                 NULL
                 );
    }
    else {

        //
        // Now, send the add request
        //
        hr = LdapAddS(
                 ld,
                 pszLDAPDn,
                 aMods
                 );
    }

        BAIL_ON_FAILURE(hr);

error:

    if ( pszAbsoluteName ) {
        FreeADsStr( pszAbsoluteName );
    }

    if ( pszLDAPServer ) {
        FreeADsStr( pszLDAPServer );
    }

    if (pszLDAPDn) {
        FreeADsStr( pszLDAPDn);
    }


    if ( aModsBuffer )
    {
        for ( j = 0; j < i; j++ )
        {
             if ( aModsBuffer[j].mod_op & LDAP_MOD_BVALUES )
             {
                 if ( aModsBuffer[j].mod_bvalues )
                 {
                     for ( DWORD k = 0; aModsBuffer[j].mod_bvalues[k]; k++ )
                         FreeADsMem( aModsBuffer[j].mod_bvalues[k] );

                     FreeADsMem( aModsBuffer[j].mod_bvalues );
                 }
             }
             else if ( aModsBuffer[j].mod_values )
             {
                 for ( DWORD k = 0; aModsBuffer[j].mod_values[k]; k++ )
                     FreeADsMem( aModsBuffer[j].mod_values[k] );

                 FreeADsMem( aModsBuffer[j].mod_values );
             }
        }

        FreeADsMem( aModsBuffer );
    }

    if ( aMods )
        FreeADsMem( aMods );

    return hr;
}


HRESULT
ADsCreateDSObject(
    ADS_LDP *ld,
    LPTSTR  ADsPath,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes
    )
{

    RRETURN ( ADsCreateDSObjectExt(
                  ld,
                  ADsPath,
                  pszRDNName,
                  pAttributeEntries,
                  dwNumAttributes,
                  0, // for seInfo since it is ignored
                  FALSE
                  )
              );

}


HRESULT
ADsDeleteDSObject(
    ADS_LDP *ld,
    LPTSTR  ADsPath,
    LPWSTR pszRDNName
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszAbsoluteName = NULL;
    TCHAR *pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    DWORD dwPort = 0;


    //
    // Get the LDAP path of the object to delete
    //

    hr = BuildADsPathFromParent(
                ADsPath,
                pszRDNName,
                &pszAbsoluteName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             pszAbsoluteName,
             &pszLDAPServer,
             &pszLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now, send the delete request
    //
    hr = LdapDeleteS(
                    ld,
                    pszLDAPDn
                    );
    BAIL_ON_FAILURE(hr);

error:

    if ( pszAbsoluteName ) {
        FreeADsStr( pszAbsoluteName );
    }

    if ( pszLDAPServer ) {
        FreeADsStr( pszLDAPServer );
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }


    return hr;
}

HRESULT
ComputeAttributeBufferSize(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize,
    PDWORD pdwNumValues
    )
{
    PADS_ATTR_INFO pThisAttribute = NULL;
    PADSVALUE pAdsSrcValues = NULL;
    DWORD dwNumValues = 0;

    DWORD dwSize = 0;
    DWORD dwTotalNumValues = 0;


    for ( DWORD i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAdsAttributes + i;

        dwNumValues = pThisAttribute->dwNumValues;

        dwTotalNumValues += dwNumValues;

        pAdsSrcValues = pThisAttribute->pADsValues;

        for ( DWORD j = 0; j < dwNumValues; j++)
            dwSize += AdsTypeSize(pAdsSrcValues + j) + sizeof(ADSVALUE);

        dwSize += sizeof(ADS_ATTR_INFO);
        dwSize += ((wcslen(pThisAttribute->pszAttrName) + 1)*sizeof(WCHAR)) + (ALIGN_WORD-1);
    }

    *pdwSize = dwSize;
    *pdwNumValues = dwTotalNumValues;

    return S_OK;
}

LPBYTE
CopyAttributeName(
    PADS_ATTR_INFO pThisAdsSrcAttribute,
    PADS_ATTR_INFO pThisAdsTargAttribute,
    LPBYTE pDataBuffer
    )
{

    //
    // strings should be WCHAR (i.e., WORD) aligned
    //
    pDataBuffer = (LPBYTE) ROUND_UP_POINTER(pDataBuffer, ALIGN_WORD);

    LPWSTR pCurrentPos = (LPWSTR)pDataBuffer;

    wcscpy(pCurrentPos, pThisAdsSrcAttribute->pszAttrName);

    pThisAdsTargAttribute->pszAttrName = pCurrentPos;

    pDataBuffer = pDataBuffer + (wcslen(pThisAdsSrcAttribute->pszAttrName) + 1)*sizeof(WCHAR);

    return(pDataBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\ldapres.h ===
#define LDAP_PROVIDER_ID 1

#define GC_PORT 3268
#define GC_SSL_PORT 3269

#define USE_DEFAULT_LDAP_PORT -1
#define USE_DEFAULT_GC_PORT -2

#define LDAPC_NT_AUTHORITY   7000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\ldaptype.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ldaptype.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      25-Jun-96   yihsins   Created.
//
//  Warnings:

//----------------------------------------------------------------------------
#include "ldapc.hxx"


HRESULT
LdapFormatBinaryToString(
    IN PLDAPOBJECTARRAY pldapBinaryArray,
    IN OUT PLDAPOBJECTARRAY pldapStringArray
    );


VOID
LdapTypeFreeLdapObjects(
    LDAPOBJECTARRAY *pLdapObjectArray
    )
{
    DWORD i = 0;
    PLDAPOBJECT pLdapObject = pLdapObjectArray->pLdapObjects;

    if ( pLdapObjectArray->pLdapObjects == NULL )
        return;

    for ( i = 0; i < pLdapObjectArray->dwCount; i++ )
    {
        if ( pLdapObjectArray->fIsString )
        {
            if ( LDAPOBJECT_STRING( pLdapObject + i))
                FreeADsMem( LDAPOBJECT_STRING( pLdapObject + i));
        }
        else
        {
            if ( LDAPOBJECT_BERVAL( pLdapObject + i))
                FreeADsMem( LDAPOBJECT_BERVAL( pLdapObject + i));
        }
    }

    FreeADsMem( pLdapObjectArray->pLdapObjects );

    pLdapObjectArray->dwCount = 0;
    pLdapObjectArray->pLdapObjects = NULL;

    return;
}

HRESULT
LdapTypeCopy(
    PLDAPOBJECT pLdapSrcObject,
    PLDAPOBJECT pLdapDestObject,
    BOOL        fIsString
    )
{
    HRESULT hr = S_OK;

    if ( fIsString )
    {
        if ( (LDAPOBJECT_STRING(pLdapDestObject) =
                 AllocADsStr(LDAPOBJECT_STRING(pLdapSrcObject))) == NULL )

        {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }
    }
    else
    {
        DWORD nSize = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);

        if ( (LDAPOBJECT_BERVAL(pLdapDestObject) =
                 (struct berval *) AllocADsMem(sizeof(struct berval) + nSize))
            == NULL )
        {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }

        LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = nSize;
        LDAPOBJECT_BERVAL_VAL(pLdapDestObject) =
            (char *) ( (LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject)
                     + sizeof(struct berval));

        memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
                LDAPOBJECT_BERVAL_VAL(pLdapSrcObject),
                LDAPOBJECT_BERVAL_LEN(pLdapSrcObject) );
    }

    RRETURN(S_OK);
}

HRESULT
LdapTypeCopyConstruct(
    LDAPOBJECTARRAY ldapSrcObjects,
    LDAPOBJECTARRAY *pLdapDestObjects
    )
{
    DWORD i = 0;
    PLDAPOBJECT pLdapTempObjects = NULL;
    HRESULT hr = S_OK;
    LDAPOBJECTARRAY DummyObjectArray;
    //
    // Init as we will need info on failures
    //
    LDAPOBJECTARRAY_INIT(DummyObjectArray);

    pLdapTempObjects = (PLDAPOBJECT)AllocADsMem(
                           (ldapSrcObjects.dwCount + 1) * sizeof(LDAPOBJECT));

    DummyObjectArray.pLdapObjects = pLdapTempObjects;


    if (!pLdapTempObjects) {
        RRETURN(E_OUTOFMEMORY);
    }

     for (i = 0; i < ldapSrcObjects.dwCount; i++ ) {
         hr = LdapTypeCopy( &(ldapSrcObjects.pLdapObjects[i]),
                            pLdapTempObjects + i,
                            ldapSrcObjects.fIsString );
         if ( hr != S_OK )
             break;
         DummyObjectArray.dwCount = i + 1;
     }

     if ( hr == S_OK )
     {
         pLdapDestObjects->fIsString = ldapSrcObjects.fIsString;
         pLdapDestObjects->dwCount = ldapSrcObjects.dwCount;
         pLdapDestObjects->pLdapObjects = pLdapTempObjects;
     }

     //
     // Need to free if we failed an pLdapTempObjects is valid.
     //
     if (FAILED(hr) && pLdapTempObjects) {
         LdapTypeFreeLdapObjects(&DummyObjectArray);
     }
     RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////////
//
// If [dwLdapSyntax] indicates binary format,
//      return S_FALSE and an empty [ldapStringArray].
//
// If [dwLdapSyntax] indicates string format,
//      convert data from binary format [ldapBinaryArray] to string format
//      [ldapStringArray] and return S_OK.
//
// If [dwldapSyntax] is invalid,
//      return E_ADS_CANT_CONVERT_DATATYPE.
//
////////////////////////////////////////////////////////////////////////////

HRESULT
LdapTypeBinaryToString(
    IN DWORD dwLdapSyntax,
    IN PLDAPOBJECTARRAY pldapBinaryArray,
    IN OUT PLDAPOBJECTARRAY pldapStringArray
    )
{
    HRESULT hr = S_FALSE;


    //
    // dll exported function, don't use assert
    //

    if (!pldapBinaryArray || !pldapStringArray)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }


    switch (dwLdapSyntax) {

        //
        // syntax indicates binary data
        //

        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_SECURITY_DESCRIPTOR:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
        case LDAPTYPE_UNKNOWN:
        {
            //
            // no conversion needed, return empty string objects for efficiency
            //

            pldapStringArray->dwCount = 0;
            pldapStringArray->pLdapObjects = NULL;

            hr = S_FALSE;
            break;
        }


        //
        // syntax indicates string data
        //

        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_PRINTABLESTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING :
        case LDAPTYPE_DN:
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER :
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_NUMERICSTRING:
        case LDAPTYPE_OID:
        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_PRESENTATIONADDRESS :
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_UTCTIME:
        case LDAPTYPE_BOOLEAN:
        case LDAPTYPE_DSAQUALITYSYNTAX   :
        case LDAPTYPE_DATAQUALITYSYNTAX  :
        case LDAPTYPE_IA5STRING          :
        case LDAPTYPE_MAILPREFERENCE     :
        case LDAPTYPE_OTHERMAILBOX       :
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_GENERALIZEDTIME    :
        case LDAPTYPE_INTEGER            :
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:
        // The following are for NTDS
        case LDAPTYPE_CASEIGNORESTRING   :
        case LDAPTYPE_INTEGER8           :
        case LDAPTYPE_ACCESSPOINTDN      :
        case LDAPTYPE_ORNAME             :
        case LDAPTYPE_CASEEXACTSTRING    :
        case LDAPTYPE_DNWITHBINARY       :
        case LDAPTYPE_DNWITHSTRING       :
        case LDAPTYPE_ORADDRESS:
        {
            //
            // convert to string format
            //
            hr = LdapFormatBinaryToString(
                        pldapBinaryArray,
                        pldapStringArray
                        );
            BAIL_ON_FAILURE(hr);

            break;
        }


        //
        // syntax is invalid
        //

        default:
        {
            pldapStringArray->dwCount = 0;
            pldapStringArray->pLdapObjects = NULL;

            hr = E_FAIL;
            break;
        }
    }


error:


    RRETURN(hr);

}


///////////////////////////////////////////////////////////////////////////
//
// Convert LDAPOBJECTARRAY from binary [pldapBinaryArray] to string
// [pldaStringArray] format.
//
// Return S_OK or E_ADS_CANT_CONVERT_DATATYPE.
//
///////////////////////////////////////////////////////////////////////////

HRESULT
LdapFormatBinaryToString(
    IN PLDAPOBJECTARRAY pldapBinaryArray,
    IN OUT PLDAPOBJECTARRAY pldapStringArray
    )
{
    HRESULT hr = S_OK;
    PLDAPOBJECT pldapBinary = NULL;
    PLDAPOBJECT pldapString = NULL;
    LPTSTR lpszMaxString = NULL;
    DWORD i =0;
    DWORD dwMaxLen = 0;
    DWORD dwCurrentLen = 0;
    DWORD dwObjectCount = 0;
    DWORD dwObjectBlockSize = 0;


    //
    // in case of dll exporting this funct'n later, don't use assert
    //

    if (!pldapBinaryArray || !pldapStringArray)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    dwObjectCount = pldapBinaryArray->dwCount;
    dwObjectBlockSize = dwObjectCount * sizeof (PLDAPOBJECT);

    //
    // initialize in ldapStringArray structure
    //

    pldapStringArray->fIsString = TRUE;
    pldapStringArray->dwCount = dwObjectCount;
    pldapStringArray->pLdapObjects = (PLDAPOBJECT) AllocADsMem(
                                                        dwObjectBlockSize
                                                        );
    if (!(pldapStringArray->pLdapObjects))
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset( pldapStringArray->pLdapObjects, 0, dwObjectBlockSize);

    //
    // find max size of binary object in pldapBinaryArray
    //

    for (i=0; i<dwObjectCount; i++)
    {
        pldapBinary = &(pldapBinaryArray->pLdapObjects[i]);

        dwCurrentLen = LDAPOBJECT_BERVAL_LEN(pldapBinary);

        (dwCurrentLen > dwMaxLen) ? (dwMaxLen = dwCurrentLen) : 1;
    }


    //
    // allocate string of max size in pldapStringArray:
    //      - binary data in UTF8 (a MBCS) format, worst case each UTF8 char
    //        represents one char in string
    //      - +1 for '\0' just in case
    //

    lpszMaxString = (LPTSTR) AllocADsMem(
                                (dwMaxLen + 1) * sizeof (WCHAR)
                                );
    if (!lpszMaxString)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    //
    // convert each ldap object from binary to string format
    //

    for (i=0; i<pldapBinaryArray->dwCount; i++)
    {
        pldapBinary = &(pldapBinaryArray->pLdapObjects[i]);
        pldapString = &(pldapStringArray->pLdapObjects[i]);

        memset (lpszMaxString, 0, (dwMaxLen+1) * sizeof(WCHAR));


        if (LDAPOBJECT_BERVAL_LEN(pldapBinary)>0)
        {

            (VOID)  LdapUTF8ToUnicode(
                        LDAPOBJECT_BERVAL_VAL(pldapBinary),
                        LDAPOBJECT_BERVAL_LEN(pldapBinary),
                        (LPWSTR) lpszMaxString,
                        dwMaxLen+1
                        );

            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);

            LDAPOBJECT_STRING(pldapString) = AllocADsStr(
                                                lpszMaxString
                                                );
            if (!pldapString)
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }

        else
        {
            //
            // in case ldap binary object empty, string counter part already
            // set to null during initialization
            //
        }
    }


error:

    if (lpszMaxString)
        FreeADsStr(lpszMaxString);


    if (FAILED(hr))
    {
        pldapStringArray->dwCount = i;  // clean up object 0th to (i-1)th
        LdapTypeFreeLdapObjects(pldapStringArray);  //return empty string array
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\ldap2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       ldap2ods.cxx
//
//  Contents:   LDAP Object to DSObject Copy Routines
//
//  Functions:
//
//  History:    2/20/96 yihsins Created.
//
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"

void
AdsTypeFreeAdsObjects(
    PADSVALUE pAdsDestValues,
    DWORD dwNumObjects
    )
{
    LPBYTE pMem = NULL;
    PADS_DN_WITH_BINARY pDNBin = NULL;
    PADS_DN_WITH_STRING pDNStr = NULL;

    for ( DWORD i = 0; i < dwNumObjects; i++ )
    {
        pMem = NULL;

        switch ( pAdsDestValues[i].dwType )
        {
            case ADSTYPE_DN_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].DNString;
                break;

            case ADSTYPE_CASE_EXACT_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].CaseExactString;
                break;

            case ADSTYPE_CASE_IGNORE_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].CaseIgnoreString;
                break;

            case ADSTYPE_PRINTABLE_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].PrintableString;
                break;

            case ADSTYPE_NUMERIC_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].NumericString;
                break;

            case ADSTYPE_OCTET_STRING:
                pMem = pAdsDestValues[i].OctetString.lpValue;
                break;

            case ADSTYPE_PROV_SPECIFIC:
                pMem = pAdsDestValues[i].ProviderSpecific.lpValue;
                break;

            case ADSTYPE_NT_SECURITY_DESCRIPTOR:
                pMem = pAdsDestValues[i].SecurityDescriptor.lpValue;
                break;

            case ADSTYPE_DN_WITH_STRING:
                pDNStr = pAdsDestValues[i].pDNWithString;

                if (pDNStr) {
                    if (pDNStr->pszStringValue) {
                        FreeADsStr(pDNStr->pszStringValue);
                    }
                    if (pDNStr->pszDNString) {
                        FreeADsStr(pDNStr->pszDNString);
                    }
                }

                FreeADsMem(pDNStr);
                pDNStr = NULL;

                break;

            case ADSTYPE_DN_WITH_BINARY:

                pDNBin = pAdsDestValues[i].pDNWithBinary;

                if (pDNBin) {
                    if (pDNBin->lpBinaryValue) {
                        FreeADsMem(pDNBin->lpBinaryValue);
                    }

                    if (pDNBin->pszDNString) {
                        FreeADsStr(pDNBin->pszDNString);
                    }
                }

                FreeADsMem(pDNBin);
                pDNBin = NULL;

                break;

            default:
                break;
        }

        if ( pMem )
            FreeADsMem( pMem );
    }

    FreeADsMem( pAdsDestValues );
    return;
}

HRESULT
LdapTypeToAdsTypeDNString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_DN_STRING;

    pAdsDestValue->DNString = AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->DNString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeCaseExactString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    pAdsDestValue->CaseExactString =
                        AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->CaseExactString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}


HRESULT
LdapTypeToAdsTypeCaseIgnoreString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )

{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    pAdsDestValue->CaseIgnoreString =
                        AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->CaseIgnoreString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}


HRESULT
LdapTypeToAdsTypePrintableString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    pAdsDestValue->PrintableString =
                        AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->PrintableString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeNumericString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    pAdsDestValue->NumericString =
                        AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->NumericString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeBoolean(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);

    pAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    if ( _tcsicmp( pszSrc, TEXT("TRUE")) == 0 )
    {
        pAdsDestValue->Boolean = TRUE;
    }
    else if ( _tcsicmp( pszSrc, TEXT("FALSE")) == 0 )
    {
        pAdsDestValue->Boolean = FALSE;
    }
    else
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
    }

    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeInteger(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_INTEGER;

    pAdsDestValue->Integer = _ttol(LDAPOBJECT_STRING(pLdapSrcObject));

    RRETURN(hr);

}

HRESULT
LdapTypeToAdsTypeOctetString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLen = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);
    LPBYTE pBuffer = NULL;

    pAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    if ( (pBuffer = (LPBYTE) AllocADsMem( dwLen )) == NULL )
        RRETURN(E_OUTOFMEMORY);

    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL(pLdapSrcObject), dwLen );

    pAdsDestValue->OctetString.dwLength = dwLen;

    pAdsDestValue->OctetString.lpValue = pBuffer;

    RRETURN(hr);

}


HRESULT
LdapTypeToAdsTypeNTSecurityDescriptor(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLen = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);
    LPBYTE pBuffer = NULL;

    pAdsDestValue->dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;

    if ( (pBuffer = (LPBYTE) AllocADsMem( dwLen )) == NULL )
        RRETURN(E_OUTOFMEMORY);

    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL(pLdapSrcObject), dwLen );

    pAdsDestValue->SecurityDescriptor.dwLength = dwLen;

    pAdsDestValue->SecurityDescriptor.lpValue = pBuffer;

    RRETURN(hr);

}

HRESULT
UTCTimeStringToUTCTime(
    LPWSTR szTime,
    SYSTEMTIME *pst)
{
    FILETIME ft;
    TCHAR sz[3];
    LPWSTR pszSrc = szTime;
    SYSTEMTIME st;
    BOOL fSucceeded = FALSE;
    HRESULT hr = S_OK;

    //
    // Year
    //
    sz[0] = pszSrc[0];
    sz[1] = pszSrc[1];
    sz[2] = TEXT('\0');
    st.wYear = (WORD)_ttoi(sz);
    if (st.wYear < 50)
    {
        st.wYear += 2000;
    }
    else
    {
        st.wYear += 1900;
    }
    //
    // Month
    //
    sz[0] = pszSrc[2];
    sz[1] = pszSrc[3];
    st.wMonth = (WORD)_ttoi(sz);
    //
    // Day
    //
    sz[0] = pszSrc[4];
    sz[1] = pszSrc[5];
    st.wDay = (WORD)_ttoi(sz);
    //
    // Hour
    //
    sz[0] = pszSrc[6];
    sz[1] = pszSrc[7];
    st.wHour = (WORD)_ttoi(sz);
    //
    // Minute
    //
    sz[0] = pszSrc[8];
    sz[1] = pszSrc[9];
    st.wMinute = (WORD)_ttoi(sz);
    //
    // Second
    //
    sz[0] = pszSrc[10];
    sz[1] = pszSrc[11];
    st.wSecond = (WORD)_ttoi(sz);
    st.wMilliseconds = 0;

    //
    // This gets us the day of week, as per bug 87387.
    // SystemTimeToFileTime ignores the wDayOfWeek member, and
    // FileTimeToSystemTime sets it.  A FileTime is precise down to
    // 100 nanoseconds, so there will never be conversion loss.
    //

    fSucceeded = SystemTimeToFileTime(&st, &ft);
    if (!fSucceeded) {
        BAIL_ON_FAILURE (hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    fSucceeded = FileTimeToSystemTime(&ft, &st);
    if (!fSucceeded) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    *pst = st;

error:

    RRETURN(hr);

}

//
// GenTimeStringToUTCTime -- parse a GeneralizedTime string.
//
// An LDAP GeneralizedTime is the same as the ASN.1 GeneralizedTime.
// Format given by:
//
//   Type GeneralizedTime takes values of the year, month, day, hour,
//   time, minute, second, and second fraction in any of three forms.
//     1. Local time only. "YYYYMMDDHHMMSS.fff", where the optional fff
//        is accurate to three decimal places.
//     2. Universal time (UTC time) only. "YYYYMMDDHHMMSS.fffZ".
//     3. Difference between local and UTC times.
//         "YYYYMMDDHHMMSS.fff+-HHMM".
//
// I'm being a little more lenient; if the string ends "early", i.e.
// doesn't fill in all the required fields, it sets the rest to zero.
// I'm doing this in particular because it's not clear if the "SS" for
// seconds is optional.  If this is a bad thing, change the #if below so
// it signals an error conditions.
//
#if 1
#define FINISH goto cleanup
#else
#define FINISH do { BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE); } while(0)
#endif
HRESULT
GenTimeStringToUTCTime(
    LPWSTR szTime,
    SYSTEMTIME *pst)
{
    HRESULT hr = S_OK;

    PWSTR pszSrc = szTime;
    DWORD dwStrlen = wcslen(pszSrc);

    SYSTEMTIME st, stZulu;
    WCHAR sz[5];

    // Make sure everything is zero first, in case we bail.
    memset((void *)&st, 0, sizeof(st));

    //
    // Year
    //
    if (dwStrlen < 4) FINISH;
    sz[0] = pszSrc[0];
    sz[1] = pszSrc[1];
    sz[2] = pszSrc[2];
    sz[3] = pszSrc[3];
    sz[4] = TEXT('\0');
    st.wYear = (WORD)_wtoi(sz);

    //
    // Month
    //
    if (dwStrlen < 6)
        goto cleanup;
    sz[0] = pszSrc[4];
    sz[1] = pszSrc[5];
    sz[2] = TEXT('\0');
    st.wMonth = (WORD)_wtoi(sz);

    //
    // Day
    //
    if (dwStrlen < 8) FINISH;
    sz[0] = pszSrc[6];
    sz[1] = pszSrc[7];
    st.wDay = (WORD)_wtoi(sz);

    //
    // Hour
    //
    if (dwStrlen < 10) FINISH;
    sz[0] = pszSrc[8];
    sz[1] = pszSrc[9];
    st.wHour = (WORD)_wtoi(sz);

    //
    // Minute
    //
    if (dwStrlen < 12) FINISH;
    sz[0] = pszSrc[10];
    sz[1] = pszSrc[11];
    st.wMinute = (WORD)_wtoi(sz);

    //
    // Second
    //
    if (dwStrlen < 14) FINISH;
    sz[0] = pszSrc[12];
    sz[1] = pszSrc[13];
    st.wSecond = (WORD)_wtoi(sz);

    //
    // Check for milliseconds.
    //
    pszSrc = pszSrc + 14;       // we've read the first 14 characters
    if (*pszSrc == TEXT('.')) {
        pszSrc++;

        //
        // Milliseconds are defined as "optional", but it's unclear if this
        // means "all three digits or none at all".  So play it safe.
        //
        PWSTR psz = sz;
        WORD wDigits = 0;
        while (*pszSrc != TEXT('\0') && iswdigit(*pszSrc) && wDigits < 3) {
            wDigits++;
            *psz++ = *pszSrc++;
        }
        while (wDigits < 3) {
            wDigits++;
            *psz++ = TEXT('0');
        }
        *psz = TEXT('\0');

        st.wMilliseconds = (WORD)_wtoi(sz);
    }

    //
    // Copy the systemTime into stZulu so it has the correct val.
    //
    memcpy((void *)&stZulu,(const void *)&st, sizeof(SYSTEMTIME));

    //
    // Now check if there's a time zone listed.
    //
    if (*pszSrc != TEXT('\0')) {
        switch (*pszSrc) {

            case TEXT('-'):
            case TEXT('+'):
                {
                    BOOL fPositive = (*pszSrc == (TEXT('+')));
                    pszSrc++;

                    WORD wHours, wMinutes;
                    sz[0] = *pszSrc++;
                    sz[1] = *pszSrc++;
                    sz[2] = 0;
                    wHours = (WORD)_wtoi(sz);
                    sz[0] = *pszSrc++;
                    sz[1] = *pszSrc++;
                    wMinutes = _wtoi(sz) + 60 * wHours;

                    TIME_ZONE_INFORMATION tziOffset;
                    tziOffset.Bias = wMinutes * (fPositive ? 1 : -1);
                    tziOffset.StandardName[0] = TEXT('0');
                    tziOffset.StandardDate.wMonth = 0;
                    tziOffset.DaylightName[0] = TEXT('0');
                    tziOffset.DaylightDate.wMonth = 0;
                    if (!SystemTimeToTzSpecificLocalTime(
                        &tziOffset,
                        &st,
                        &stZulu)) {
                        RRETURN(hr = GetLastError());
                    }

                }
                //
                // Now it's converted to Zulu time, so convert it back
                // to local time.
                //
                /*FALLTHROUGH*/

            case TEXT('Z'):
                {
                    /*
                    //
                    // We want to return zulu time
                    // not local uncomment to enable conversion
                    // to localTime.
                    //
                    if (*pszSrc == TEXT('Z'))
                        // and not '+' or '-'...
                        memcpy((void *)&stZulu,
                            (const void *)&st,
                            sizeof(SYSTEMTIME));

                    TIME_ZONE_INFORMATION tziLocal;
                    GetTimeZoneInformation(&tziLocal);
                    if (!SystemTimeToTzSpecificLocalTime(
                        &tziLocal,
                        &stZulu,
                        &st)) {
                        RRETURN(hr = GetLastError());
                    }
                    */

                    //
                    // At this point we have the correct value
                    // in stZulu either way.
                    //
                    memcpy(
                        (void *) &st,
                        (const void *)&stZulu,
                        sizeof(SYSTEMTIME)
                    );

                }
                break;

            default:
                RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }
    }

cleanup:
    *pst = st;

    RRETURN(hr);
}


HRESULT
LdapTypeToAdsTypeUTCTime(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME st;

    PTSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);
    hr = UTCTimeStringToUTCTime(pszSrc,
                         &st);
    BAIL_ON_FAILURE(hr);

    pAdsDestValue->dwType = ADSTYPE_UTC_TIME;
    pAdsDestValue->UTCTime = st;
error:
    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeGeneralizedTime(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME st;

    PWSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);
    hr = GenTimeStringToUTCTime(pszSrc,
                                &st);
    BAIL_ON_FAILURE(hr);

    pAdsDestValue->dwType = ADSTYPE_UTC_TIME;
    pAdsDestValue->UTCTime = st;
error:
    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeLargeInteger(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{

    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_LARGE_INTEGER;

    swscanf (LDAPOBJECT_STRING(pLdapSrcObject), L"%I64d", &pAdsDestValue->LargeInteger);

    RRETURN(hr);

}



//
// Just calls the helper routine - the helper is needed
// because of the way in which IDirectorySearch works
//
HRESULT
LdapTypeToAdsTypeDNWithBinary(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{

    RRETURN(LdapDNWithBinToAdsTypeHelper(
                LDAPOBJECT_STRING(pLdapSrcObject),
                pAdsDestValue
                )
            );
}


//
// Wire format of DNWithBinary is :
// B:32:a9d1ca15768811d1aded00c04fd8d5cd:dc=ntdev,dc=microsoft,dc=com
//
HRESULT
LdapDNWithBinToAdsTypeHelper(
    LPWSTR pszLdapSrcString,
    PADSVALUE pAdsDestValue
    )
{

    HRESULT hr = S_OK;
    DWORD dwCount = 0;
    DWORD dwBinLen = 0;
    LPWSTR pszLdapStr = NULL;
    LPBYTE lpByte = NULL;
    PADS_DN_WITH_BINARY pDNBin = NULL;
    WCHAR wCurChar;

    pAdsDestValue->dwType = ADSTYPE_DN_WITH_BINARY;

    pDNBin = (PADS_DN_WITH_BINARY) AllocADsMem(sizeof(ADS_DN_WITH_BINARY));

    if (!pDNBin) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pszLdapStr = pszLdapSrcString;

    if (!pszLdapStr) {
        //
        // NULL value
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (wcslen(pszLdapStr) < 5 ) {
        //
        // B:x:: is the smallest string
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    wCurChar = *pszLdapStr++;

    //
    // String should begin with B
    //
    if (wCurChar != L'B') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    //
    // Skip the : and get the length
    //
    *pszLdapStr++;

    dwCount = swscanf(pszLdapStr, L"%ld", &dwBinLen);

    //
    // This is the actual length of the byte array
    //
    dwBinLen /= 2;

    if (dwCount != 1) {
        //
        // Trouble reading the length
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    //
    // Go onto the start of the encoded string
    //
    while(*pszLdapStr && (wCurChar != L':')) {
        wCurChar = *pszLdapStr++;
    }

    if (wCurChar != L':') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }


    //
    // Get the byte array from string if there are any elements in it
    //
    if (dwCount != 0) {

        //
        // The DWORD cushion is to make sure we do not overwrite
        // the buffer while reading from the string.
        //
        lpByte = (LPBYTE) AllocADsMem(dwBinLen + sizeof(DWORD));

        if (!lpByte) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (dwCount = 0; dwCount < dwBinLen; dwCount++) {
            swscanf(pszLdapStr, L"%02X", &lpByte[dwCount]);
            pszLdapStr += 2;
        }

        pDNBin->lpBinaryValue = lpByte;
    }

    //
    // Get the DN
    //
    wCurChar = *pszLdapStr++;

    if (wCurChar != L':') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pDNBin->pszDNString = AllocADsStr(pszLdapStr);

    if (!pszLdapStr && !pDNBin->pszDNString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pDNBin->dwLength = dwBinLen;
    pAdsDestValue->pDNWithBinary = pDNBin;

    RRETURN(hr);

error:

    if (pDNBin) {
        if (pDNBin->pszDNString) {
            FreeADsStr(pDNBin->pszDNString);
        }
        FreeADsMem(pDNBin);
    }

    if (lpByte) {
        FreeADsMem(lpByte);
    }

    RRETURN(hr);

}

//
// Calls the helper that does the work - helper is needed by
// IDirectorySearch when returning columns.
//
HRESULT
LdapTypeToAdsTypeDNWithString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{

    RRETURN(LdapDNWithStrToAdsTypeHelper(
                LDAPOBJECT_STRING(pLdapSrcObject),
                pAdsDestValue
                )
            );
}



//
// Wire format of DNWithString is :
// S:9:OurDomain:dc=ntdev,dc=microsoft,dc=com
//
HRESULT
LdapDNWithStrToAdsTypeHelper(
    LPWSTR pszLdapSrcString,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = 0;
    DWORD dwStrLen = 0;
    LPWSTR pszLdapStr = NULL;
    PADS_DN_WITH_STRING pDNStr = NULL;
    WCHAR wCurChar;

    pAdsDestValue->dwType = ADSTYPE_DN_WITH_STRING;

    pDNStr = (PADS_DN_WITH_STRING) AllocADsMem(sizeof(ADS_DN_WITH_STRING));

    if (!pDNStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pszLdapStr = pszLdapSrcString;

    if (!pszLdapStr) {
        //
        // NULL value
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (wcslen(pszLdapStr) < 5) {
        //
        // S:x:: being the minimum
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    wCurChar = *pszLdapStr++;

    if (wCurChar != L'S') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    //
    // Skip : and go onto the length
    //
    *pszLdapStr++;

    dwCount = swscanf(pszLdapStr, L"%ld:", &dwStrLen);

    wCurChar = *pszLdapStr;

    //
    // Go onto the start of the string
    //
    while (*pszLdapStr && (wCurChar != L':')) {
        wCurChar = *pszLdapStr++;
    }

    if (wCurChar != L':') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    //
    // Copy over the string value if applicable
    //
    if (dwStrLen != 0) {

        pDNStr->pszStringValue = (LPWSTR)
                                    AllocADsMem((dwStrLen + 1) * sizeof(WCHAR));

        if (!pDNStr->pszStringValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcsncat(pDNStr->pszStringValue, pszLdapStr, dwStrLen);
    }

    //
    // Move past to begining of the DN
    //
    pszLdapStr += (dwStrLen+1);

    pDNStr->pszDNString = AllocADsStr(pszLdapStr);

    if (pszLdapStr && !pDNStr->pszDNString) {
        //
        // DN was not NULL and we could not alloc.
        //
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pAdsDestValue->pDNWithString = pDNStr;

    RRETURN(hr);

error:

    if (pDNStr) {

        if (pDNStr->pszStringValue) {
            FreeADsStr(pDNStr->pszStringValue);
        }

        if (pDNStr->pszDNString) {
            FreeADsStr(pDNStr->pszDNString);
        }

        FreeADsMem(pDNStr);
    }

    RRETURN(hr);

}


HRESULT
LdapTypeToAdsTypeProvSpecific(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLen = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);
    LPBYTE pBuffer = NULL;

    pAdsDestValue->dwType = ADSTYPE_PROV_SPECIFIC;

    if ( (pBuffer = (LPBYTE) AllocADsMem( dwLen )) == NULL )
        RRETURN(E_OUTOFMEMORY);

    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL(pLdapSrcObject), dwLen );

    pAdsDestValue->ProviderSpecific.dwLength = dwLen;

    pAdsDestValue->ProviderSpecific.lpValue = pBuffer;

    RRETURN(hr);

}

HRESULT
LdapTypeToAdsTypeCopy(
    PLDAPOBJECT pLdapSrcObject,
    DWORD dwSyntaxId,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch ( dwSyntaxId ) {

        case LDAPTYPE_DN:
            hr = LdapTypeToAdsTypeDNString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_CASEEXACTSTRING:
            hr = LdapTypeToAdsTypeCaseExactString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_CASEIGNORESTRING:
//      case LDAPTYPE_CASEIGNOREIA5STRING:
        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING:
        case LDAPTYPE_IA5STRING:
        case LDAPTYPE_OID:
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:

        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER:
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_PRESENTATIONADDRESS:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_DSAQUALITYSYNTAX:
        case LDAPTYPE_DATAQUALITYSYNTAX:
        case LDAPTYPE_MAILPREFERENCE:
        case LDAPTYPE_OTHERMAILBOX:
        case LDAPTYPE_ACCESSPOINTDN:
        case LDAPTYPE_ORNAME:
        case LDAPTYPE_ORADDRESS:

            hr = LdapTypeToAdsTypeCaseIgnoreString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_PRINTABLESTRING:
            hr = LdapTypeToAdsTypePrintableString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;


        case LDAPTYPE_NUMERICSTRING:
            hr = LdapTypeToAdsTypeNumericString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_BOOLEAN:
            hr = LdapTypeToAdsTypeBoolean(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_INTEGER:
            hr = LdapTypeToAdsTypeInteger(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
            hr = LdapTypeToAdsTypeOctetString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;


        case LDAPTYPE_SECURITY_DESCRIPTOR:
            hr = LdapTypeToAdsTypeNTSecurityDescriptor(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_UTCTIME:
            hr = LdapTypeToAdsTypeUTCTime(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_GENERALIZEDTIME:
            hr = LdapTypeToAdsTypeGeneralizedTime(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_INTEGER8:
            hr = LdapTypeToAdsTypeLargeInteger(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;


#if 0
        case LDAPTYPE_CASEEXACTLIST:
        case LDAPTYPE_CASEIGNORELIST:
#endif

        case LDAPTYPE_DNWITHBINARY:
            hr = LdapTypeToAdsTypeDNWithBinary(
                     pLdapSrcObject,
                     pAdsDestValue
                     );
            break;

        case LDAPTYPE_DNWITHSTRING:
            hr = LdapTypeToAdsTypeDNWithString(
                     pLdapSrcObject,
                     pAdsDestValue
                     );
            break;

        //
        // Treat unknown as provider specific blob.
        //

        case LDAPTYPE_UNKNOWN:
            hr = LdapTypeToAdsTypeProvSpecific(
                     pLdapSrcObject,
                     pAdsDestValue
                     );
            break;


        default:

            //
            // LDPATYPE_UNKNOWN (e.g schemaless server property)
            //

            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;
    }

    RRETURN(hr);
}


HRESULT
LdapTypeToAdsTypeCopyConstruct(
    LDAPOBJECTARRAY ldapSrcObjects,
    DWORD dwSyntaxId,
    LPADSVALUE *ppAdsDestValues,
    PDWORD pdwNumAdsValues,
    PDWORD pdwAdsType
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;
    DWORD dwNumObjects = ldapSrcObjects.dwCount;

    *ppAdsDestValues = NULL;
    *pdwNumAdsValues = dwNumObjects;
    *pdwAdsType = ADSTYPE_UNKNOWN;

    if (dwNumObjects != 0) {

        pAdsDestValues = (LPADSVALUE) AllocADsMem(
                                        dwNumObjects * sizeof(ADSVALUE)
                                        );

        if (!pAdsDestValues)
            RRETURN(E_OUTOFMEMORY);

        for ( i = 0; i < dwNumObjects; i++ ) {
            hr = LdapTypeToAdsTypeCopy(
                     ldapSrcObjects.pLdapObjects + i,
                     dwSyntaxId,
                     pAdsDestValues + i
                     );
            BAIL_ON_FAILURE(hr);
        }

        *ppAdsDestValues = pAdsDestValues;

        //
        // We will set the pdwAdsType value to the first type
        //

        *pdwAdsType = (pAdsDestValues)->dwType;
    } else {

        // Set the pddwAdsType appropriately, values are null.
        *pdwAdsType = MapLDAPTypeToADSType(dwSyntaxId);
    }


    RRETURN(S_OK);

error:

    if (pAdsDestValues) {

        AdsTypeFreeAdsObjects(
            pAdsDestValues,
            i
            );
    }

    *ppAdsDestValues = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\ldaputil.cxx ===
#include "ldapc.hxx"
#pragma hdrstop

//
// Local helpers
//

extern "C" {
DWORD
GetDefaultLdapServer(
    LPWSTR Addresses[],
    LPDWORD Count,
    BOOL Verify,
    DWORD dwPort
    ) ;

}

WINLDAPAPI ULONG LDAPAPI ldap_get_optionW(
                             LDAP *ld,
                             int option,
                             void *outvalue
                             );

DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

int ConvertToAscii( WCHAR *pszUnicode, char **pszAscii );
int ConvertLDAPMod( LDAPModW **mods, LDAPModA ***modsA );
void FreeLDAPMod( LDAPModA **modsA );
BOOLEAN LDAPCodeWarrantsRetry(HRESULT hr);


HRESULT LdapSearchHelper(
    LDAP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
);


HRESULT
GetOneToken(
    LPWSTR pszSource,
    LPWSTR * ppszToken,
    DWORD * pdwTokenLen,
    BOOL * pfMore
    );

DWORD
    MaskKnownFlagsNotChecked(DWORD dwFlags)
{
    DWORD dwRetVal = dwFlags;

    dwRetVal &= ~(ADS_PROMPT_CREDENTIALS
                        | ADS_FAST_BIND
                        | ADS_READONLY_SERVER
                        | ADS_USE_SIGNING
                        | ADS_USE_SEALING
                        | ADS_USE_DELEGATION
                        | ADS_SERVER_BIND
                        | ADS_AUTH_RESERVED
                        );

    return dwRetVal;

}


LPWSTR gpszServerName = NULL;
LPWSTR gpszDomainName = NULL;

//
// High level Open/Close object functions
//
HRESULT LdapOpenObject(
    LPWSTR szLDAPServer,
    LPWSTR szLDAPDn,
    ADS_LDP  **ld,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    return LdapOpenObject2(
               szLDAPServer,
               NULL,
               szLDAPDn,
               ld,
               Credentials,
               dwPort
               );
}


HRESULT LdapOpenObject2(
    LPWSTR szDomainName,
    LPWSTR szLDAPServer,
    LPWSTR szLDAPDn,
    ADS_LDP  **ld,
    CCredentials& Credentials,
    DWORD dwPort
)
{

    HRESULT hr = S_OK;
    int     err = NO_ERROR;
    LUID Luid, ModifiedId;
    PADS_LDP pCacheEntry = NULL ;
    BOOL fAddToCache = TRUE ;

    LPWSTR aAddresses[5];
    BOOL fServerNotSpecified = FALSE;
    BOOL fVerify = FALSE;
    WCHAR szDomainDnsName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];

    DWORD dwFlags = Credentials.GetAuthFlags();
    BOOL fStickyServerSpecified = (gpszServerName != NULL);

    //
    // start by nulling out this return value
    //
    *ld = NULL ;

    //
    //  Now if the server name is Null - Get a serverName
    //

    if (!szDomainName) {


RetryGetDefaultServer:

        err = GetDefaultServer(
                  dwPort,
                  fVerify,
                  szDomainDnsName,
                  szServerName,
                  !(dwFlags & ADS_READONLY_SERVER) ? TRUE : FALSE
                  );

        if (err != NOERROR) {
            return HRESULT_FROM_WIN32(err);
        }

        if (fStickyServerSpecified) {
            //
            // We need to change the name of the domain to be that of
            // the server we want to target. The swap is made if 
            // 1) gpszDomainName == NULL, that implies that just 
            // a serverName was set and not which domain it applies to.
            // 2) If a domainName is specified, then the domainName
            // from above should be that set in the global pointer for
            // the target server to be changed.
            //
            if ((gpszDomainName
                 && (!_wcsicmp(szDomainDnsName, gpszDomainName))
                 )
                || (gpszDomainName == NULL)
                ) {
                //
                // We need to change the target to the server.
                //
                wcscpy(szDomainDnsName,gpszServerName);
                szServerName[0] = L'\0';
                //
                // Make sure if server is down we go to another
                // server on the retryGetDefault server path.
                //
                fStickyServerSpecified = FALSE;
            }
        }

        szDomainName = szDomainDnsName;
        szLDAPServer = szServerName;
        fServerNotSpecified = TRUE;
    }

#ifndef WIN95
    //
    // try the cache first. if find entry, just use it (this bumps ref count
    // up by one). if we cant get LUID, we dont use the cache.
    //
    if ((err = BindCacheGetLuid(&Luid, &ModifiedId)) == NO_ERROR) {

        //
        // Try the cache for the passed in credentials.
        //

        if (pCacheEntry = BindCacheLookup(szDomainName, Luid, ModifiedId, Credentials, dwPort)) {

             *ld = pCacheEntry ;
             return S_OK ;
        }


    }
    else {

        //
        // pick something that would NOT match anything else. and
        // never put this in the cache
        //
        Luid = ReservedLuid ;
        ModifiedId = ReservedLuid;

        fAddToCache = FALSE ;

    }

#else
    //
    // In the case of win95, however, we always make the Luid to be the reserved
    // one and lookup the cache. If found use it, otherwise, add it.
    //

    Luid = ReservedLuid ;
    ModifiedId = ReservedLuid;

    if (pCacheEntry = BindCacheLookup(szDomainName, Luid, ModifiedId, Credentials, dwPort)) {

         *ld = pCacheEntry ;
         return S_OK ;
    }

#endif



    //
    // allocate the pseudo handle (also the cache entry).
    //

    err = BindCacheAllocEntry(&pCacheEntry) ;

    if (err != NO_ERROR) {

        return HRESULT_FROM_WIN32(err);
    }


    if (!Credentials.IsNullCredentials()) {

        hr = LdapOpenBindWithCredentials(
                  szDomainName,
                  szLDAPServer,
                  Credentials,
                  pCacheEntry,
                  dwPort
                  );

    }else {

        //
        // We just want to try with NULL and NULL and
        // whatever flags were passed in. No longer want
        // to try and get credentials from registry.
        //


        hr = LdapOpenBindWithDefaultCredentials(
                    szDomainName,
                    szLDAPServer,
                    Credentials,
                    pCacheEntry,
                    dwPort
                    );

    }


    //
    // This is the Server-Less case; where we retry with a force
    // server to get a valid ServerName.
    //

    if (((hr == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH)) ||
         (hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN))) &&
        !fVerify && fServerNotSpecified) {
        fVerify = TRUE;
        LdapUnbind(pCacheEntry);
        goto RetryGetDefaultServer ;
    }



    //
    // if success we add to cache. else unbind & cleanup.
    //
    if (SUCCEEDED(hr)) {

        if (!fAddToCache) {

            //
            // do not insert in cache since we didnt get LUID
            //

        }
        else {


            err = BindCacheAdd(szDomainName, Luid, ModifiedId, Credentials, dwPort, pCacheEntry) ;

            if (err != NO_ERROR) {

                LdapUnbind(pCacheEntry) ;
                hr = HRESULT_FROM_WIN32(err);
            }
        }
    }
    else {
        //
        // Bind failed, force err so that we will clean up
        // and return correct value
        //

        LdapUnbind(pCacheEntry) ;   // needed to close out connection
        //
        // Set error value so that we do not return pCacheEntry.
        //
        err = ERROR_GEN_FAILURE;

    }

    if (err == NO_ERROR) {

             *ld = pCacheEntry ;
    }
    else {

        FreeADsMem(pCacheEntry) ;
    }

    return hr;
}


void LdapCloseObject(
    ADS_LDP *ld
)
{
    //
    // We will delete only if the count is zero and the keeparound
    // flag is not set.
    //
    if ((BindCacheDeref(ld) == 0) && !ld->fKeepAround) {

        //
        // ref count has dropped to zero and its gone from cache.
        //
        LdapUnbind(ld);
        FreeADsMem(ld);
    }
}

//
// This routine adds a ref to the pointer. Note that to release
// you use the LdapCloseObject routine.
//
void LdapCacheAddRef(
    ADS_LDP *ld
    )
{
    ADsAssert(ld);
    BindCacheAddRef(ld);
}


//
// NOTE: Ldap\ibute returns S_OK if attribute [szAttr] has no
//       values (*[aValues]=NULL, *[ncount]=0) but all else ok.
//

HRESULT LdapReadAttribute(
    WCHAR *szLDAPServer,
    LPWSTR szLDAPDn,
    WCHAR *szAttr,
    WCHAR ***aValues,
    int   *nCount,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    return LdapReadAttribute2(
               szLDAPServer,
               NULL,
               szLDAPDn,
               szAttr,
               aValues,
               nCount,
               Credentials,
               dwPort
               );

}


//
// NOTE: LdapReadAttribute2 returns S_OK if attribute [szAttr] has no
//       values (*[aValues]=NULL, *[ncount]=0) but all else ok.
//

HRESULT LdapReadAttribute2(
    WCHAR *szDomainName,
    WCHAR *szLDAPServer,
    LPWSTR szLDAPDn,
    WCHAR *szAttr,
    WCHAR ***aValues,
    int   *nCount,
    CCredentials& Credentials,
    DWORD dwPort,
    LPWSTR szFilter // defaulted to NULL
)
{
    HRESULT hr = S_OK;
    ADS_LDP *ld = NULL;
    LPWSTR aStrings[2];
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPWSTR szFilterString = L"(objectClass=*)";

    if (szFilter != NULL) {
        szFilterString = szFilter;
    }

    hr = LdapOpenObject2(
                szDomainName,
                szLDAPServer,
                szLDAPDn,
                &ld,
                Credentials,
                dwPort
                );

    if (FAILED(hr))
        goto CleanExit;

    aStrings[0] = szAttr;
    aStrings[1] = NULL;

    ADsAssert(ld && ld->LdapHandle);

    hr = LdapSearchS( ld,
                      szLDAPDn,
                      LDAP_SCOPE_BASE,
                      szFilterString,
                      aStrings,
                      0,
                      &res );

    // Only one entry should be returned

    if (  FAILED(hr)
       || FAILED(hr = LdapFirstEntry( ld, res, &e ))
       || FAILED(hr = LdapGetValues( ld, e, szAttr, aValues, nCount ))
       )
    {
       goto CleanExit;
    }

CleanExit:

    if ( res )
        LdapMsgFree( res );

    if ( ld ){
        LdapCloseObject( ld );
    }

    return hr;
}


//
// This is similar to ReadAttribute but uses a handle to avoid
// the lookup in the bindCache
//
HRESULT LdapReadAttributeFast(
            ADS_LDP *ld,
            LPWSTR szLDAPDn,
            WCHAR *szAttr,
            WCHAR ***aValues,
            int   *nCount
            )
{
    HRESULT hr = S_OK;
    LPWSTR aStrings[2];
    LDAPMessage *res = NULL;
    LDAPMessage *entry = NULL;

    aStrings[0] = szAttr;
    aStrings[1] = NULL;

    hr = LdapSearchS(
             ld,
             szLDAPDn,
             LDAP_SCOPE_BASE,
             L"(objectClass=*)",
             aStrings,
             0,
             &res
             );

    // Only one entry should be returned

    if (  FAILED(hr)
          || FAILED(hr = LdapFirstEntry( ld, res, &entry ))
          || FAILED(hr = LdapGetValues( ld, entry, szAttr, aValues, nCount ))
          )
    {
        goto CleanExit;
    }

CleanExit:

    if ( res )
        LdapMsgFree( res );

    RRETURN(hr);

}



//
// Wrappers around the ldap functions
//

HRESULT LdapOpen( WCHAR *domainName, WCHAR *hostName, int portno, ADS_LDP *ld, DWORD dwFlags )
{
    HRESULT hr = 0;
    int ldaperr = 0;
    PADS_LDP pCacheEntry = ld ;
    DWORD dwOptions = 0;

    void *ldapOption;

    //
    // Reset the handle first
    //
    pCacheEntry->LdapHandle = NULL;

    if(dwFlags & ADS_USE_SSL)
        pCacheEntry->LdapHandle = ldap_sslinit( domainName, portno, 1);
    else    
        pCacheEntry->LdapHandle = ldap_init( domainName, portno );

    if ( (pCacheEntry->LdapHandle) == NULL ) {

        hr = HRESULT_FROM_WIN32(ERROR_BAD_NETPATH);
        goto error;
    }

    ldaperr = ldap_get_option(pCacheEntry->LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &dwOptions);

    if (ldaperr != LDAP_SUCCESS) {
        CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
        goto error;
    }

    if (portno == GC_PORT || portno == GC_SSL_PORT) {

        dwOptions |= DS_GC_SERVER_REQUIRED;

    } else if (!(dwFlags & ADS_READONLY_SERVER) ) {

        dwOptions |= DS_WRITABLE_REQUIRED;

    }

    ldaperr = ldap_set_option(pCacheEntry->LdapHandle, LDAP_OPT_GETDSNAME_FLAGS,(void *)&dwOptions);

    if (ldaperr != LDAP_SUCCESS) {
        CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
        goto error;
    }

    //
    // Now process prompt for credentials
    //

    if (dwFlags & ADS_PROMPT_CREDENTIALS) {

        ldapOption = (void *) LDAP_OPT_ON;
    }else {
        ldapOption = (void *) LDAP_OPT_OFF;
    }

    ldaperr = ldap_set_option(pCacheEntry->LdapHandle, LDAP_OPT_PROMPT_CREDENTIALS, &(ldapOption));

    if (ldaperr != LDAP_SUCCESS) {
        CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
        goto error;
    }

    //
    // Now init SSL if encryption is required. This is essentially if this option is on and the
    // user did not specify an SSL port.
    //

    if (dwFlags & ADS_USE_ENCRYPTION) {
        ldapOption = (void *) LDAP_OPT_ON;
        ldaperr = ldap_set_option(pCacheEntry->LdapHandle, LDAP_OPT_SSL, &(ldapOption));

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }
    }

    //
    // Process the other options that can be set in the flags.
    //
    //
    if (dwFlags & ADS_USE_SIGNING) {
        //
        // User has requested that packets be signed
        //
        ldapOption = (void *) LDAP_OPT_ON;
        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_SIGN,
                      &(ldapOption)
                      );

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }
    }

    if (dwFlags & ADS_USE_SEALING) {
        //
        // User has requested that packet are sealed
        //
        ldapOption = (void *) LDAP_OPT_ON;
        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_ENCRYPT,
                      &(ldapOption)
                      );

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }
    }

    //
    // Now process versioning
    //

    ldapOption = (void *) LDAP_VERSION3;

    ldaperr = ldap_set_option(
                  pCacheEntry->LdapHandle,
                  LDAP_OPT_VERSION,
                  &(ldapOption)
                  );

    //
    // Non critical if the above fails
    //

    if (hostName) {
        ldapOption = (void *) hostName;

        ldaperr = ldap_set_optionW(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_HOST_NAME,
                      &(ldapOption)
                      );

        // Does not matter even if this setoption fails.
    }

    //
    // Process delegation if set
    //
    if (dwFlags & ADS_USE_DELEGATION) {

#ifndef Win95
        //
        // Relying on LDAP/server to enforce the requirement for
        // secure auth for this to work.
        //
        DWORD dwSSPIFlags = 0;

        //
        // Get the current values.
        //
        ldapOption = (void *)&dwSSPIFlags;
        ldaperr = ldap_get_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_SSPI_FLAGS,
                      ldapOption
                      );

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }

        //
        // Add delegation to the list.
        //
        dwSSPIFlags |= ISC_REQ_DELEGATE;

        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_SSPI_FLAGS,
                      ldapOption
                      );

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }
#else
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
#endif

    }

    //
    // Set the AREC exclusive option if applicable.
    //
    if (dwFlags & ADS_SERVER_BIND) {

        ldapOption = (void *) LDAP_OPT_ON;
        
        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_AREC_EXCLUSIVE,
                      &(ldapOption)
                      );

        //
        // Should we ignore this error ?
        //
        if (ldaperr) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }

    }

    ldaperr = ldap_connect(pCacheEntry->LdapHandle, NULL);

    if (ldaperr) {

        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );
        goto error;

    }

    if (pCacheEntry->LdapHandle) {

        //
        // Set the option for this connection giving our Callback functions
        //
        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_REFERRAL_CALLBACK,
                      &g_LdapReferralCallBacks
                      );

        ldapOption = (void *) LDAP_CHASE_EXTERNAL_REFERRALS;

        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_REFERRALS,
                      &(ldapOption)
                      );

    }

    return hr;

error:

    if (pCacheEntry->LdapHandle != NULL) {

        LdapUnbind(pCacheEntry);
    }

    return hr;
}

HRESULT LdapBindS( ADS_LDP *ld, WCHAR *dn, WCHAR *passwd, BOOL fSimple )
{
    LPWSTR pszNTLMUser = NULL;
    LPWSTR pszNTLMDomain = NULL;

    HRESULT hr = 0;
    int ldaperr = 0;
    DWORD dwLastLdapError = 0;

    ADsAssert(ld && ld->LdapHandle);

    if (fSimple)  {

        ldaperr = ldap_simple_bind_s( ld->LdapHandle, dn, passwd ) ;
    }
    else {

        if (dn || passwd) {

            //
            // If we have a non-null dn and/or a non-null password, we pass in
            // a SEC_WINNT_AUTH_IDENTITY blob with the NTLM credentials
            //

            hr = LdapCrackUserDNtoNTLMUser2(
                        dn,
                        &pszNTLMUser,
                        &pszNTLMDomain
                        );

            if (FAILED(hr)) {
                hr = LdapCrackUserDNtoNTLMUser(
                        dn,
                        &pszNTLMUser,
                        &pszNTLMDomain
                        );
                BAIL_ON_FAILURE(hr);
            }


            SEC_WINNT_AUTH_IDENTITY AuthI;

            AuthI.User = (PWCHAR)pszNTLMUser;
            AuthI.UserLength = (pszNTLMUser == NULL)? 0: wcslen(pszNTLMUser);
            AuthI.Domain = (PWCHAR)pszNTLMDomain;
            AuthI.DomainLength = (pszNTLMDomain == NULL)? 0: wcslen(pszNTLMDomain);
            AuthI.Password = (PWCHAR)passwd;
            AuthI.PasswordLength = (passwd == NULL)? 0: wcslen(passwd);
            AuthI.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;




            ldaperr = ldap_bind_s( ld->LdapHandle, NULL, (WCHAR*)(&AuthI), LDAP_AUTH_SSPI );

        }else {

            //
            // Otherwise we've come in with NULL, NULL - pass in NULL, NULL. The reason we
            // do this is that ldap bind code oes not process NULL, NULL, NULL in the
            // SEC_WINNT_AUTH_IDENTITY blob !!!
            //


            ldaperr = ldap_bind_s( ld->LdapHandle, NULL, NULL, LDAP_AUTH_SSPI );

        }

    }

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    //
    // If it is a local error for secure bind try and get
    // more error info and store in ADsLastError.
    //
    if (!fSimple && (ldaperr == LDAP_LOCAL_ERROR)) {

        dwLastLdapError = LdapGetLastError();

        if (dwLastLdapError) {
            //
            // Set ADSI extended error code.
            //
            ADsSetLastError(
                dwLastLdapError,
                L"",
                L"LDAP Provider"
                );
        }
    }

error:

    if (pszNTLMUser) {

        FreeADsStr(pszNTLMUser);
    }

    if (pszNTLMDomain) {

        FreeADsStr(pszNTLMDomain);
    }


    return hr;
}

HRESULT LdapUnbind( ADS_LDP *ld )
{
    HRESULT hr = NO_ERROR;

    ADsAssert(ld);

    if (ld->LdapHandle) {

        int ldaperr = ldap_unbind( ld->LdapHandle );
        // Need to set the handle to null as we may call
        // unbind twice otherwise

        ld->LdapHandle = NULL;

        // There is nothing much we can do about err status
        // CheckAndSetExtendedError could cause further problems
        // if the handle is not valid so we return E_FAIL
        // if the unbind failed.

        if (ldaperr ) {
           hr = E_FAIL;
        }

    }


    return hr;
}

HRESULT LdapSearchHelper(
    LDAP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
)
{
    HRESULT hr = 0;
    int ldaperr = 0;

    if ( timeout == NULL )
    {
        ldaperr = ldap_search_s( ld,
                                 base,
                                 scope,
                                 filter,
                                 attrs,
                                 attrsonly,
                                 res );
    }
    else
    {
        ldaperr = ldap_search_st( ld,
                                  base,
                                  scope,
                                  filter,
                                  attrs,
                                  attrsonly,
                                  timeout,
                                  res );
    }

    if (ldaperr) {

       if (!ldap_count_entries( ld, *res )) {

           CheckAndSetExtendedError( ld, &hr, ldaperr, *res );
       }
    }else {

        hr = S_OK;
    }

    return hr;
}

HRESULT LdapSearchS(
    ADS_LDP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    LDAPMessage **res
)
{
    ADsAssert(ld && ld->LdapHandle);

    HRESULT hr = LdapSearchHelper(
                  ld->LdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  NULL,
                  res );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapSearchST(
    ADS_LDP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
)
{
    ADsAssert(ld && ld->LdapHandle);

    HRESULT hr = LdapSearchHelper(
                  ld->LdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  timeout,
                  res );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapSearch(
    ADS_LDP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    int   *msgid
)
{

    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *msgid = ldap_search( ld->LdapHandle,
                          base,
                          scope,
                          filter,
                          attrs,
                          attrsonly );

    if ( *msgid == -1 )
    {
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);
    }

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapModifyS(
    ADS_LDP  *ld,
    WCHAR *dn,
    LDAPModW *mods[]
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_modify_s( ld->LdapHandle, dn, mods);

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapModifyExtS(
    ADS_LDP  *ld,
    WCHAR *dn,
    LDAPModW *mods[],
    PLDAPControlW * ServerControls,
    PLDAPControlW * ClientControls
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_modify_ext_s( ld->LdapHandle, dn, mods, ServerControls, ClientControls);

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapModRdnS(
    ADS_LDP *ld,
    WCHAR *dn,
    WCHAR *newrdn
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_modrdn_s( ld->LdapHandle, dn, newrdn );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}



//+------------------------------------------------------------------------
//
//  Function:   LdapRenameExtS
//
//  Synopsis: Extended renam/modifyRDN which will move objects across
//          namespaces as opposed to modifyRDN which cannot do the same.
//
//
//  Arguments:  [ld]            -- ldap handle.
//              [dn]            -- dn of object to be moved.
//              [newRDN]        -- New RDN of the object being moved.
//              [newParent]     -- New Parent.
//              [deleteOldRDN]  --
//              [ServerControls]-- Server Control to be used.
//              [ClientControls]-- Client Control to be used.
//-------------------------------------------------------------------------
HRESULT LdapRenameExtS(
    ADS_LDP  *ld,
    WCHAR *dn,
    WCHAR *newRDN,
    WCHAR *newParent,
    int deleteOldRDN,
    PLDAPControlW * ServerControls,
    PLDAPControlW * ClientControls
    )
{
    HRESULT hr = S_OK;
    int ldaperr = 0;


    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_rename_ext_sW(
                  ld->LdapHandle,
                  dn,
                  newRDN,
                  newParent,
                  deleteOldRDN,
                  ServerControls,
                  ClientControls
                  );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;

    }

    return hr;
}


HRESULT LdapModDnS(
    ADS_LDP  *ld,
    WCHAR *dn,
    WCHAR *newdn,
    int   deleteoldrdn
    )
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_modrdn2_s(
                  ld->LdapHandle,
                  dn,
                  newdn,
                  deleteoldrdn );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;

    }

    return hr;
}

HRESULT LdapAddS(
    ADS_LDP  *ld,
    WCHAR *dn,
    LDAPModW *attrs[]
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_add_s( ld->LdapHandle, dn, attrs );

    CheckAndSetExtendedError( ld->LdapHandle , &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


//
// Add ext wrapper function
//
HRESULT LdapAddExtS(
    ADS_LDP  *ld,
    WCHAR *dn,
    LDAPModW *attrs[],
    PLDAPControl * ServerControls,
    PLDAPControl * ClientControls
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_add_ext_s(
                  ld->LdapHandle,
                  dn,
                  attrs,
                  ServerControls,
                  ClientControls
                  );

    CheckAndSetExtendedError( ld->LdapHandle , &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapDeleteS(
    ADS_LDP  *ld,
    WCHAR *dn
)
{
    HRESULT hr = 0;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_delete_s( ld->LdapHandle, dn );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapDeleteExtS(
    ADS_LDP  *ld,
    WCHAR *dn,
    PLDAPControlW * ServerControls,
    PLDAPControlW * ClientControls
    )
{
    HRESULT hr = 0;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_delete_ext_s(
                    ld->LdapHandle,
                    dn,
                    ServerControls,
                    ClientControls
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;

}


HRESULT
LdapCompareExt(
    ADS_LDP *ld,
    const LPWSTR pszDn,
    const LPWSTR pszAttribute,
    const LPWSTR pszValue,
    struct berval *berData,
    PLDAPControlW * ServerControls,
    PLDAPControlW * ClientControls
    )
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_compare_ext_s(
                  ld->LdapHandle,
                  pszDn,
                  pszAttribute,
                  pszValue,
                  berData,
                  ServerControls,
                  ClientControls
                  );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {
        BindCacheInvalidateEntry(ld) ;
    }

    RRETURN(hr);
}


HRESULT LdapAbandon(
    ADS_LDP  *ld,
    int   msgid
)
{
    ADsAssert(ld && ld->LdapHandle);

    // No error code, 0 if success, -1 otherwise
    return ldap_abandon( ld->LdapHandle, msgid );
}

HRESULT LdapResult(
    ADS_LDP   *ld,
    int    msgid,
    int    all,
    struct l_timeval *timeout,
    LDAPMessage **res,
    int    *restype
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *restype = ldap_result( ld->LdapHandle, msgid, all, timeout, res );

    if ( *restype == -1 )  // error
        ldaperr = LdapGetLastError();

    if (ldaperr) {

       if (!ldap_count_entries( ld->LdapHandle, *res )) {

           CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, *res );

            if ( LdapConnectionErr(hr, 0, NULL)) {

                BindCacheInvalidateEntry(ld) ;
            }
       }
    }else {

        hr = S_OK;
    }

    return hr;

}

void LdapMsgFree(
    LDAPMessage *res
)
{
    ldap_msgfree( res );  // Returns the type of message freed which
                          // is not interesting
}

int LdapResult2Error(
    ADS_LDP  *ld,
    LDAPMessage *res,
    int freeit
)
{
    ADsAssert(ld && ld->LdapHandle);

    return ldap_result2error( ld->LdapHandle, res, freeit );
}

HRESULT LdapFirstEntry(
    ADS_LDP *ld,
    LDAPMessage *res,
    LDAPMessage **pfirst
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *pfirst = ldap_first_entry( ld->LdapHandle, res );

    if ( *pfirst == NULL )
    {
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, res);
    }

    return hr;
}

HRESULT LdapNextEntry(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    LDAPMessage **pnext
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *pnext = ldap_next_entry( ld->LdapHandle, entry );

    if ( *pnext == NULL )
    {
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
    }

    return hr;
}
int LdapCountEntries(
    ADS_LDP  *ld,
    LDAPMessage *res
)
{
    ADsAssert(ld && ld->LdapHandle);

    return ldap_count_entries( ld->LdapHandle, res );
}

HRESULT LdapFirstAttribute(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    void  **ptr,
    WCHAR **pattr
)
{
    ADsAssert(ld && ld->LdapHandle);
    LPWSTR pAttrTemp = NULL;

    // NOTE: The return value from ldap_first_attribute is static and
    //       should not be freed

    pAttrTemp = ldap_first_attribute( ld->LdapHandle, entry,
                                   (struct berelement **) ptr );  // static data

    if ( pAttrTemp == NULL )
    {
        HRESULT hr = S_OK;
        int ldaperr = 0;

        // Error occurred or end of attributes

        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
        return hr;
    }

    //
    // Copy over the value as we can loose state if this fn is
    // called again - for example we read the attribute and are
    // now looking for schema information about it and end up
    // fetching the schema from the server.
    //
    *pattr = AllocADsStr(pAttrTemp);

    return NO_ERROR;

}

HRESULT LdapNextAttribute(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    void  *ptr,
    WCHAR **pattr
)
{
    ADsAssert(ld && ld->LdapHandle);
    LPWSTR pAttrTemp = NULL;

    // NOTE: The return value from ldap_next_attribute is static and
    //       should not be freed
    pAttrTemp = ldap_next_attribute( ld->LdapHandle, entry,
                                  (struct berelement *) ptr );  // static data

    if (pAttrTemp) {
        *pattr = AllocADsStr(pAttrTemp);
    } else {
        *pattr = NULL;
    }

#if 0   // Ignore the error code here since at the end of the enumeration,
        // we will probably get an error code here ( both Andy and umich's
        // dll will return errors sometimes. No error returned from NTDS,
        // but errors are returned from Exchange server  )

    if ( *pattr == NULL )
    {
        HRESULT hr = NO_ERROR;
        int ldaperr = 0;

        // Error occurred or end of attributes
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);
        return hr;
    }
#endif

    return S_OK;
}


//
// NOTE: LdapGetValues return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

HRESULT LdapGetValues(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    WCHAR *attr,
    WCHAR ***pvalues,
    int   *pcount
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *pvalues = ldap_get_values( ld->LdapHandle, entry, attr );

    if ( *pvalues == NULL ) {

        *pcount=0;

        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //

        ldaperr = LdapGetLastError();

        if (ldaperr) {
            CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
        }

        return hr;
    }

    *pcount = ldap_count_values( *pvalues );

    return S_OK;
}


//
// NOTE: LdapGetValuesLen return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

HRESULT LdapGetValuesLen(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    WCHAR *attr,
    struct berval ***pvalues,
    int   *pcount
)
{
    //
    // NOTE: this can contain binary data as well as strings,
    //       strings are ascii, no conversion is done here
    //

    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *pvalues = ldap_get_values_len( ld->LdapHandle, entry, attr );

    if ( *pvalues == NULL ){

        *pcount=0;

        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //

        ldaperr = LdapGetLastError();

        if (ldaperr) {
            CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
        }

        return hr;
    }

    *pcount = ldap_count_values_len( *pvalues );

    return S_OK;
}


void LdapValueFree(
    WCHAR **vals
)
{
    ldap_value_free( vals );
}

void LdapValueFreeLen(
    struct berval **vals
)
{
    ldap_value_free_len( vals );
}

void LdapMemFree(
    WCHAR *pszString
)
{
    ldap_memfree( pszString );
}

void LdapAttributeFree(
    WCHAR *pszString
)
{
    //
    // Since we made a copy of the string returned by LDAP, we
    // need to free it here.
    //

    FreeADsStr(pszString);
}

HRESULT LdapGetDn(
    ADS_LDP *ld,
    LDAPMessage *entry,
    WCHAR **pdn
)
{
    int ldaperr = 0;
    HRESULT hr = S_OK;

    ADsAssert(ld && ld->LdapHandle);

    *pdn = ldap_get_dn( ld->LdapHandle, entry );
    if ( *pdn == NULL )
    {
        // Error occurred
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
        return hr;
    }

    return hr;
}

int ConvertToAscii( WCHAR *pszUnicode, char **pszAscii )
{

    int nSize;

    if ( pszUnicode == NULL )
    {
        *pszAscii = NULL;
        return NO_ERROR;
    }

    nSize = WideCharToMultiByte( CP_ACP,
                                 0,
                                 pszUnicode,
                                 -1,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL );

    if ( nSize == 0 )
        return GetLastError();

    *pszAscii = (char * ) AllocADsMem( nSize );

    if ( *pszAscii == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    if ( !WideCharToMultiByte( CP_ACP,
                               0,
                               pszUnicode,
                               -1,
                               *pszAscii,
                               nSize,
                               NULL,
                               NULL ))
    {
        FreeADsMem( *pszAscii );
        *pszAscii = NULL;
        return GetLastError();
    }

    return NO_ERROR;
}

int ConvertToUnicode( char *pszAscii, WCHAR **pszUnicode )
{
    int nSize;

    *pszUnicode = NULL;

    if ( pszAscii == NULL )
    {
        return NO_ERROR;
    }

    nSize = MultiByteToWideChar( CP_ACP,
                                 0,
                                 pszAscii,
                                 -1,
                                 NULL,
                                 0 );

    if ( nSize == 0 )
        return GetLastError();

    *pszUnicode = (WCHAR * ) AllocADsMem( nSize * sizeof(WCHAR));

    if ( *pszUnicode == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    if ( !MultiByteToWideChar( CP_ACP,
                               0,
                               pszAscii,
                               -1,
                               *pszUnicode,
                               nSize ))
    {
        FreeADsMem( *pszUnicode );
        *pszUnicode = NULL;
        return GetLastError();
    }

    return NO_ERROR;
}

// Dead function?
int ConvertLDAPMod( LDAPModW **mods, LDAPModA ***modsA )
{
    int nCount = 0;
    LDAPModA *aMods = NULL;
    int err = NO_ERROR;

    if ( mods == NULL )
    {
        *modsA = NULL;
        return NO_ERROR;
    }

    while ( mods[nCount] )
        nCount++;

    *modsA = (LDAPModA **) AllocADsMem((nCount+1) * sizeof(LDAPModA *));

    if ( *modsA == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    aMods = (LDAPModA *) AllocADsMem(nCount * sizeof(LDAPModA));

    if ( aMods == NULL )
    {
        FreeADsMem( *modsA );
        *modsA = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for ( int i = 0; i < nCount; i++ )
    {
        aMods[i].mod_op = mods[i]->mod_op;

        if ( err = ConvertToAscii( mods[i]->mod_type, &(aMods[i].mod_type)))
            break;

        if ( aMods[i].mod_op & LDAP_MOD_BVALUES )
        {
            aMods[i].mod_bvalues = mods[i]->mod_bvalues;
        }
        else
        {
            int nStrCount = 0;
            WCHAR **aStrings = mods[i]->mod_values;

            while ( aStrings[nStrCount] )
                   nStrCount++;

            aMods[i].mod_values = (char **) AllocADsMem(
                                            (nStrCount+1) * sizeof(char *));

            if ( aMods[i].mod_values != NULL )
            {
                for ( int j = 0; j < nStrCount; j++ )
                {
                    err =  ConvertToAscii( mods[i]->mod_values[j],
                                           &(aMods[i].mod_values[j]));
                    if ( err )
                    {
                        for ( int k = 0; k < j; k++ )
                            FreeADsMem( aMods[i].mod_values[k] );
                        FreeADsMem( aMods[i].mod_values );

                        break;
                    }
                }
            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }

            if ( err )
                break;
        }

        (*modsA)[i] = &aMods[i];
    }

    if ( err )
    {
        for ( int k = 0; k < i; k++ )
        {
            FreeADsMem( aMods[k].mod_type );

            if ( !(aMods[k].mod_op & LDAP_MOD_BVALUES ))
            {
                int j = 0;
                while ( aMods[k].mod_values[j] )
                    FreeADsMem( aMods[k].mod_values[j++] );

                if ( aMods[k].mod_values )
                    FreeADsMem( aMods[k].mod_values );
            }
        }

        FreeADsMem( aMods );
        FreeADsMem( *modsA );
        *modsA = NULL;
    }

    return err;
}

// Dead function?
void FreeLDAPMod( LDAPModA **modsA )
{
    int i = 0;
    while ( modsA[i] )
    {
        FreeADsMem( modsA[i]->mod_type );

        if ( !(modsA[i]->mod_op & LDAP_MOD_BVALUES ))
        {
            int j = 0;
            while ( modsA[i]->mod_values[j] )
                FreeADsMem( modsA[i]->mod_values[j++] );

            if ( modsA[i]->mod_values )
                FreeADsMem( modsA[i]->mod_values );
        }

        i++;
    }

    if ( modsA[0] )
        FreeADsMem( modsA[0] );

    FreeADsMem( modsA );
}


void
LdapGetCredentialsFromRegistry(
    CCredentials& Credentials
    )
{

    HKEY   hKey ;
    WCHAR  UserName[128], Password[128] ;
    LPWSTR pUserName = NULL;
    LPWSTR pPassword = NULL;
    DWORD  dwType, cbUserName = sizeof(UserName),
    cbPassword = sizeof(Password);
    int err = NO_ERROR;


    UserName[0] = Password[0] = 0 ;

    //
    // Open the registry Key
    //

    err = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services\\TcpIp\\Parameters",
                        0L,
                        KEY_READ,
                        &hKey) ;

    if (err == NO_ERROR) {

        err = RegQueryValueEx (hKey,
                               L"LdapUserName",
                               NULL,
                               &dwType,
                               (LPBYTE) UserName,
                               &cbUserName) ;

        if (err == NO_ERROR) {

            pUserName = UserName;
        }

        err = RegQueryValueEx (hKey,
                               L"LdapPassword",
                               NULL,
                               &dwType,
                               (LPBYTE) Password,
                               &cbPassword) ;

        if (err == NO_ERROR) {

            pPassword = Password;
        }

        Credentials.SetUserName(pUserName);

        Credentials.SetPassword(pPassword);

        RegCloseKey(hKey) ;
    }
}


HRESULT
LdapOpenBindWithCredentials(
    WCHAR *szDomainName,
    WCHAR *szServerName,
    CCredentials& Credentials,
    PADS_LDP pCacheEntry,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;
    DWORD dwFlagsChecked = 0;
    DWORD dwAuthFlags = 0;

    ULONG ulSSLPort, ulPort;

    hr = Credentials.GetUserName(&UserName);
    BAIL_ON_FAILURE(hr);


    hr = Credentials.GetPassword(&Password);
    BAIL_ON_FAILURE(hr);

    //
    // dwAuthFlags are the acutal flags set by the user
    //
    dwAuthFlags = Credentials.GetAuthFlags();

    //
    // dwFlagsChecked are the flags that we handle in this fn.
    //
    dwFlagsChecked = MaskKnownFlagsNotChecked(dwAuthFlags);

    if (dwPort == USE_DEFAULT_LDAP_PORT) {
        //
        // We can choose the appropriate LDAP port no.
        //
        ulSSLPort = LDAP_SSL_PORT;
        ulPort = LDAP_PORT;
    }
    else if ( dwPort == USE_DEFAULT_GC_PORT ) {
        //
        // We can choose the appropriate GC port no.
        //
        ulSSLPort = GC_SSL_PORT;
        ulPort = GC_PORT;
    }
    else {
        //
        // Port number explicitly specified; go with that
        //
        ulSSLPort = dwPort;
        ulPort = dwPort;
    }

    switch (dwFlagsChecked) {


    case (ADS_USE_ENCRYPTION |  ADS_SECURE_AUTHENTICATION):

        //
        // Case 1 - ADS_USE_ENCRYPTION AND  ADS_SECURE_AUTHENTICATION
        // We do a negotiate bind over ssl channel
        //

        hr = LdapOpen( szDomainName, szServerName, ulSSLPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );

        if (FAILED(hr) && LDAPCodeWarrantsRetry(hr)) {

            //
            // Try setting the version number to V2.

            void *ldapOption = (void *) LDAP_VERSION2;

            ldap_set_option(
                pCacheEntry->LdapHandle,
                LDAP_OPT_VERSION,
                &(ldapOption)
                );

            hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );


            BAIL_ON_FAILURE(hr);

        }
        break;


    case (ADS_SECURE_AUTHENTICATION):

        //
        // Case 2 - ADS_SECURE_AUTHENTICATION
        // we will try  opening the LDAP port and authenticate with
        // SSPI.
        //

        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags);
        if (FAILED(hr)) {

            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );
        BAIL_ON_FAILURE(hr);

        break;

    case (ADS_USE_ENCRYPTION):

        //
        // Case 3 - ADS_USE_ENCRYPTION
        // We will first try open the SSL port. If this succeeds, we
        // will try a simple bind. If the open to the SSL port fails,
        // we will error out - (we can't provide encryption)
        //


        hr = LdapOpen( szDomainName, szServerName, ulSSLPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

        if (FAILED(hr) && LDAPCodeWarrantsRetry(hr)) {

            //
            // Try setting the version number to V2.

            void *ldapOption = (void *) LDAP_VERSION2;

            ldap_set_option(
                pCacheEntry->LdapHandle,
                LDAP_OPT_VERSION,
                &(ldapOption)
                );

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

            BAIL_ON_FAILURE(hr);
        }

        break;


    case 0:

        //
        // Case 4 - NOT ADS_SECURE_AUTHENTICATION AND NOT ADS_USE_ENCRYPTION

        // We will first try opening the LDAP port. Then we will do
        // a simple bind and "clear-text" authenticate.
        //

        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        //
        // Note there is no need to try an SSPI bind, as the user came with
        // explicit credentials and requested no authentication / no encryption
        // We just need to do a simple bind.

        // err = LdapBindS( pCacheEntry, UserName, Password, FALSE );
        hr = HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
        if (FAILED(hr)) {

            //
            // SSPI bind failed - try a simple bind.
            //

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );
            if (FAILED(hr) && LDAPCodeWarrantsRetry(hr)) {

                //
                // Try setting the version number to V2.

                void *ldapOption = (void *) LDAP_VERSION2;

                ldap_set_option(
                    pCacheEntry->LdapHandle,
                    LDAP_OPT_VERSION,
                    &(ldapOption)
                    );

                hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

                if (FAILED(hr)) {
                    goto error;
                }
            }
        }
        break;


    case ADS_NO_AUTHENTICATION:

        //
        // Case 10 - ADS_NO_AUTHENTICATION
        //
        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags);
        if (FAILED(hr)) {
            goto error;
        }
        break;


    default:

        //
        // Case 5 - Bogus values - if we come in with any bogus flags, we
        // will fail with ERROR_INVALID_PARAMETER.
        //

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        break;

    }


error:

    if (UserName) {
        FreeADsStr(UserName);
    }

    if (Password) {
        SecureZeroMemory(Password, wcslen(Password)*sizeof(WCHAR));
        FreeADsStr(Password);
    }


    return(hr);
}


HRESULT
LdapOpenBindWithDefaultCredentials(
    WCHAR *szDomainName,
    WCHAR *szServerName,
    CCredentials& Credentials,
    PADS_LDP pCacheEntry,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;
    DWORD dwFlagsChecked = 0;
    DWORD dwAuthFlags = 0;

    ULONG ulSSLPort, ulPort;


    hr = Credentials.GetUserName(&UserName);
    BAIL_ON_FAILURE(hr);

    hr = Credentials.GetPassword(&Password);
    BAIL_ON_FAILURE(hr);

    //
    // These are the flags actually passed in.
    //
    dwAuthFlags = Credentials.GetAuthFlags();

    //
    // dwFlagsChecked contains only those flags we check for here.
    //
    dwFlagsChecked = MaskKnownFlagsNotChecked(dwAuthFlags);

    if (dwPort == USE_DEFAULT_LDAP_PORT) {
        //
        // We can choose the LDAP port number
        //
        ulSSLPort = LDAP_SSL_PORT;
        ulPort = LDAP_PORT;
    }
    else if ( dwPort == USE_DEFAULT_GC_PORT ) {
        //
        // We can choose the appropriate GC port number
        //
        ulSSLPort = GC_SSL_PORT;
        ulPort = GC_PORT;
    }
    else {
        //
        // Port number explicitly specified; go with that
        //
        ulSSLPort = dwPort;
        ulPort = dwPort;
    }

    switch (dwFlagsChecked) {

    case (ADS_USE_ENCRYPTION | ADS_SECURE_AUTHENTICATION):


        //
        // Case 1 - ADS_USE_ENCRYPTION AND  ADS_SECURE_AUTHENTICATION
        // We do negotiate bind over SSL channel
        //

        hr = LdapOpen( szDomainName, szServerName, ulSSLPort, pCacheEntry, dwAuthFlags );
        BAIL_ON_FAILURE(hr);

        hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );

        if (FAILED(hr)) {

            //
            // Try setting the version number to V2.

            void *ldapOption = (void *) LDAP_VERSION2;

            ldap_set_option(
                pCacheEntry->LdapHandle,
                LDAP_OPT_VERSION,
                &(ldapOption)
                );

            hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );

            BAIL_ON_FAILURE(hr);

        }
        break;


    case (ADS_SECURE_AUTHENTICATION):

        //
        // Case 2 - ADS_SECURE_AUTHENTICATION
        // we will try  opening the LDAP port and authenticate with
        // SSPI.
        //

        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags);
        if (FAILED(hr)) {

            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );
        BAIL_ON_FAILURE(hr);

        break;

    case (ADS_USE_ENCRYPTION):

        //
        // Case 3 - ADS_USE_ENCRYPTION
        // We will first try open the SSL port. If this succeeds, we
        // will try a simple bind. If the open to the SSL port fails,
        // we will error out - (we can't provide encryption)
        //

        hr = LdapOpen( szDomainName, szServerName, ulSSLPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

        if (FAILED(hr)) {

            //
            // Try setting the version number to V2.

            void *ldapOption = (void *) LDAP_VERSION2;

            ldap_set_option(
                pCacheEntry->LdapHandle,
                LDAP_OPT_VERSION,
                &(ldapOption)
                );

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

            BAIL_ON_FAILURE(hr);

        }

        break;

    case 0:

        //
        // Case 4 - NOT ADS_SECURE_AUTHENTICATION AND NOT ADS_USE_ENCRYPTION

        // We will first try opening the LDAP port. If this succeeds, we
        // will try an SSPI bind. We still want to try and provide the user
        // with a secure authentication even though he/she is crazy enough
        // to unsecurely authenticate. If the SSPI bind fails, we will do
        // a simple bind and "clear-text" authenticate.
        //

        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );
        if (FAILED(hr) && hr != ERROR_LOGON_FAILURE) {

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

            if (FAILED(hr)) {

                //
                // Try setting the version number to V2.
                //
                void *ldapOption = (void *) LDAP_VERSION2;

                ldap_set_option(
                    pCacheEntry->LdapHandle,
                    LDAP_OPT_VERSION,
                    &(ldapOption)
                    );

                hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

                if (FAILED(hr)) {
                    goto error;
                }
            }
        }
        break;


    default:

        //
        // Case 5 - Bogus values - if we come in with any bogus flags, we
        // will fail with ERROR_INVALID_PARAMETER.
        //

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        break;

    }


error:

    if (UserName) {
        FreeADsStr(UserName);
    }

    if (Password) {
        FreeADsStr(Password);
    }


    return(hr);
}



//+---------------------------------------------------------------------------
//  Function:  LdapCrackUserDNToNTLMUser
//
//  Synopsis:   This call attempts to translate an LDAP-style DN into an NTLM
//              domain password form. The algorithm is to assume that the first
//              component will be of the form "CN=krishnaG" . This first component
//              will be taken as the user name. The subsequent components are
//              scanned till we find the first DC= component.
//
//  Arguments:  [LPTSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
LdapCrackUserDNtoNTLMUser(
    LPWSTR pszDN,
    LPWSTR * ppszNTLMUser,
    LPWSTR * ppszNTLMDomain
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;    
    WCHAR szDomainName[MAX_PATH];
    LPWSTR szToken = NULL;

    LPWSTR pszSrcComp = NULL;
    LPWSTR pszSrcValue = NULL;

    DWORD i = 0;
    DWORD dwNumComponents = 0;

    HRESULT hr = S_OK;

    CLexer Lexer;
    hr = Lexer.InitializePath(pszDN);
    BAIL_ON_FAILURE(hr);
    
    CLexer * pTokenizer = &Lexer;

    DWORD dwToken = 0;

    LPWSTR pszUserName = NULL;
    LPWSTR pszDomainName = NULL;


    *ppszNTLMUser = NULL;
    *ppszNTLMDomain = NULL;

    if (pszDN && !*pszDN) {
        //
        // Empty string.
        //
        *ppszNTLMUser = AllocADsStr(L"");

        if (!*ppszNTLMUser) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *ppszNTLMDomain = AllocADsStr(L"");

        if (!*ppszNTLMDomain) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        RRETURN(hr);
    }

    hr = InitObjectInfo(pszDN, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    szDomainName[0] = L'\0';

    //
    // We don't want to treat ! as a special character
    //
    pTokenizer->SetExclaimnationDisabler(TRUE);

    while (1) {
                
        hr = Component(pTokenizer, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_ON_FAILURE(hr);

        if (dwToken == TOKEN_COMMA || dwToken == TOKEN_SEMICOLON) {
            continue;
        }

        if (dwToken == TOKEN_ATSIGN) {
            //
            // Need to return entire dn as username and no domain
            //
            *ppszNTLMUser = AllocADsStr(pszDN);

            if (!*ppszNTLMUser) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            *ppszNTLMDomain = AllocADsStr(L"");

            if (!*ppszNTLMDomain) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            goto exit;

        }

        if (dwToken == TOKEN_END) {
            break;
        }

    }

    dwNumComponents = pObjectInfo->NumComponents;

    if (dwNumComponents) {

        pszSrcComp = pObjectInfo->ComponentArray[0].szComponent;
        pszSrcValue = pObjectInfo->ComponentArray[0].szValue;

        if (pszSrcComp) {

            // if there was a LHS as in CN=krishnag

            if (!_wcsicmp(pszSrcComp, L"CN") && pszSrcValue) {

                pszUserName = (LPWSTR) AllocADsMem((wcslen(pszSrcValue) + 1) * sizeof(WCHAR));
                if(!pszUserName)
                {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }

                wcscpy(pszUserName, pszSrcValue);
            }else if (!pszSrcValue){

                pszUserName = (LPWSTR) AllocADsMem((wcslen(pszSrcComp) + 1) * sizeof(WCHAR));
                if(!pszUserName)
                {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
                wcscpy(pszUserName, pszSrcComp);
            }
        }

        for (i = 1; i < dwNumComponents; i++) {

            pszSrcComp = pObjectInfo->ComponentArray[i].szComponent;
            pszSrcValue = pObjectInfo->ComponentArray[i].szValue;
            if (pszSrcComp) {

                // if there was a LHS as in DC=NTWKSTA

                if (!_wcsicmp(pszSrcComp, L"DC")) {

                    if((!pszSrcValue) || (pszSrcValue && (wcslen(pszSrcValue) >= MAX_PATH)))
                    {
                        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
                    }
                    wcscpy(szDomainName, pszSrcValue);
                    break;
                }else if (!pszSrcValue){

                    if(wcslen(pszSrcComp) >= MAX_PATH)
                    {
                        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
                    }
                    wcscpy(szDomainName, pszSrcComp);
                    break;
                }
            }
        }
    }

    if (pszUserName) {      

        if (szDomainName[0]) {

            pszDomainName = AllocADsStr(szDomainName);
            if (!pszDomainName) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

        }

    }else {

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        BAIL_ON_FAILURE(hr);
    }

    *ppszNTLMUser = pszUserName;
    *ppszNTLMDomain = pszDomainName;

exit:
    //
    // Clean up the parser object
    //
    FreeObjectInfo(pObjectInfo);

    return(hr);

error:

    //
    // Clean up the parser object
    //
    FreeObjectInfo(pObjectInfo);


    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszDomainName) {
        FreeADsStr(pszDomainName);
    }

    if (*ppszNTLMUser) {
        FreeADsStr(*ppszNTLMUser);
    }

    if (*ppszNTLMDomain) {
        FreeADsStr(*ppszNTLMDomain);
    }

    //
    // Now we just return whatever is returned from the parser.
    //
    return(hr);
}


//
// would like to use WinNT codes path cracking codes - but doesn't
// work. Too messy, need to clean  up - move all path mgmt codes to common.
//

HRESULT
LdapCrackUserDNtoNTLMUser2(
    IN  LPWSTR pszDN,
    OUT LPWSTR * ppszNTLMUser,
    OUT LPWSTR * ppszNTLMDomain
    )
{
    HRESULT hr = E_ADS_BAD_PATHNAME;    
    DWORD credStatus = SEC_E_OK;


    ASSERT(ppszNTLMUser);
    ASSERT(ppszNTLMDomain);

    *ppszNTLMUser=NULL;
    *ppszNTLMDomain=NULL;

    if (!pszDN) {
        RRETURN(S_OK);
    }

    *ppszNTLMUser = (LPWSTR) AllocADsMem( (wcslen(pszDN)+1) * sizeof(WCHAR) );
    *ppszNTLMDomain = (LPWSTR) AllocADsMem( (wcslen(pszDN)+1) * sizeof(WCHAR) );
    if(!(*ppszNTLMUser) || !(*ppszNTLMDomain))
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        BAIL_ON_FAILURE(hr);        
    }


    //
    // CredUIParseUserName will parse NT4 type name, UPN and MarshalledCredentialReference
    //
    credStatus = CredUIParseUserName(pszDN, 
                            		*ppszNTLMUser, 
                            		wcslen(pszDN) + 1,  
                            		*ppszNTLMDomain, 
		                            wcslen(pszDN) + 1
		                            );   
    
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(credStatus));


    RRETURN (hr);


error:

    if (*ppszNTLMUser) {
        FreeADsStr(*ppszNTLMUser);
        *ppszNTLMUser=NULL;
    }

    if (*ppszNTLMDomain) {
        FreeADsStr(*ppszNTLMDomain);
        *ppszNTLMDomain=NULL;
    }

    RRETURN (hr);
}


HRESULT
GetOneToken(
    LPWSTR pszSource,
    LPWSTR * ppszToken,
    DWORD * pdwTokenLen,
    BOOL * pfMore
    )
{
    LPWSTR pszToken = NULL;
    DWORD dwTokenLen= 0;
    LPWSTR pszCurrChar = pszSource;

    ASSERT(pszSource);
    ASSERT(ppszToken);
    ASSERT(pdwTokenLen);
    ASSERT(pfMore);

    *ppszToken=NULL;
    *pdwTokenLen = 0;
    *pfMore = FALSE;


    //
    // do we use exception handling code here ? what if caller passed
    // in a bad string -> not terminated?
    //

    while (*pszCurrChar!=L'\0' && *pszCurrChar!=L'\\') {
        dwTokenLen++;
        pszCurrChar++;
    }

    pszToken = (LPWSTR) AllocADsMem( (dwTokenLen+1) * sizeof(WCHAR) );
    if (!pszToken) {
        RRETURN(E_OUTOFMEMORY);
    }
    memcpy( pszToken, pszSource, dwTokenLen * sizeof(WCHAR) );
    (pszToken)[dwTokenLen]=L'\0';

    *pdwTokenLen = dwTokenLen;
    *ppszToken = pszToken;
    *pfMore = (*pszCurrChar==L'\0') ? FALSE : TRUE;

    RRETURN(S_OK);
}


VOID
CheckAndSetExtendedError(
    LDAP    *ld,
    HRESULT *perr,
    int     ldaperr,
    LDAPMessage *ldapResMsg
    )
{
    WCHAR  pszProviderName[MAX_PATH];
    INT    numChars;
    void   *option;
    DWORD dwStatus = NO_ERROR;
    DWORD dwErr = NO_ERROR;
    DWORD dwLdapErrParse = NO_ERROR;
    PWCHAR ppszLdapMessage = NULL;
    LPWSTR pszStopChar = NULL;


    // first set the dwErr, then we can see if we can get
    // more information from ldap_parse_resultW
    switch (ldaperr) {

    case LDAP_SUCCESS :
        dwErr = NO_ERROR;
        break;

    case LDAP_OPERATIONS_ERROR :
        dwErr =  ERROR_DS_OPERATIONS_ERROR;
        break;

    case LDAP_PROTOCOL_ERROR :
        dwErr =  ERROR_DS_PROTOCOL_ERROR;
        break;

    case LDAP_TIMELIMIT_EXCEEDED :
        dwErr = ERROR_DS_TIMELIMIT_EXCEEDED;
        break;

    case LDAP_SIZELIMIT_EXCEEDED :
        dwErr = ERROR_DS_SIZELIMIT_EXCEEDED;
        break;

    case LDAP_COMPARE_FALSE :
        dwErr = ERROR_DS_COMPARE_FALSE;
        break;

    case LDAP_COMPARE_TRUE :
        dwErr = ERROR_DS_COMPARE_TRUE;
        break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        dwErr = ERROR_DS_AUTH_METHOD_NOT_SUPPORTED;
        break;

    case LDAP_STRONG_AUTH_REQUIRED :
        dwErr =  ERROR_DS_STRONG_AUTH_REQUIRED;
        break;

    // LDAP_REFERRAL_V2 has same value as LDAP_PARTIAL_RESULTS
    case LDAP_PARTIAL_RESULTS :
            //
            // If the referral chasing is off for the handle
            // we really don't worry about this error
            //
            dwStatus = ldap_get_option(
                           ld,
                           LDAP_OPT_REFERRALS,
                           &(option)
                           );

            if (dwStatus == NO_ERROR && option == LDAP_OPT_OFF) {
                dwErr = NO_ERROR;
            }
            else {
                dwErr = ERROR_MORE_DATA;
            }

            break ;


    case LDAP_REFERRAL :
        dwErr =  ERROR_DS_REFERRAL;
        break;

    case LDAP_ADMIN_LIMIT_EXCEEDED :
        dwErr   = ERROR_DS_ADMIN_LIMIT_EXCEEDED;
        break;

    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        dwErr = ERROR_DS_UNAVAILABLE_CRIT_EXTENSION;
        break;

    case LDAP_CONFIDENTIALITY_REQUIRED :
        dwErr = ERROR_DS_CONFIDENTIALITY_REQUIRED;
        break;

    case LDAP_NO_SUCH_ATTRIBUTE :
        dwErr = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        break;

    case LDAP_UNDEFINED_TYPE :
        dwErr = ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED;
        break;

    case LDAP_INAPPROPRIATE_MATCHING :
        dwErr = ERROR_DS_INAPPROPRIATE_MATCHING;
        break;

    case LDAP_CONSTRAINT_VIOLATION :
        dwErr = ERROR_DS_CONSTRAINT_VIOLATION;
        break;

    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        dwErr = ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS;
        break;

    case LDAP_INVALID_SYNTAX :
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        break;

    case LDAP_NO_SUCH_OBJECT :
        dwErr = ERROR_DS_NO_SUCH_OBJECT;
        break;

    case LDAP_ALIAS_PROBLEM :
        dwErr = ERROR_DS_ALIAS_PROBLEM;
        break;

    case LDAP_INVALID_DN_SYNTAX :
        dwErr = ERROR_DS_INVALID_DN_SYNTAX;
        break;

    case LDAP_IS_LEAF :
        dwErr = ERROR_DS_IS_LEAF;
        break;

    case LDAP_ALIAS_DEREF_PROBLEM :
        dwErr = ERROR_DS_ALIAS_DEREF_PROBLEM;
        break;

    case LDAP_INAPPROPRIATE_AUTH :
        dwErr = ERROR_DS_INAPPROPRIATE_AUTH;
        break;

    case LDAP_INVALID_CREDENTIALS :
        dwErr = ERROR_LOGON_FAILURE;
        break;

    case LDAP_INSUFFICIENT_RIGHTS :
        dwErr = ERROR_ACCESS_DENIED;
        break;

    case LDAP_BUSY :
        dwErr = ERROR_DS_BUSY;
        break;

    case LDAP_UNAVAILABLE :
        dwErr = ERROR_DS_UNAVAILABLE;
        break;

    case LDAP_UNWILLING_TO_PERFORM :
        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
        break;

    case LDAP_LOOP_DETECT :
        dwErr = ERROR_DS_LOOP_DETECT;
        break;

    case LDAP_NAMING_VIOLATION :
        dwErr = ERROR_DS_NAMING_VIOLATION;
        break;

    case LDAP_OBJECT_CLASS_VIOLATION :
        dwErr = ERROR_DS_OBJ_CLASS_VIOLATION;
        break;

    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        dwErr = ERROR_DS_CANT_ON_NON_LEAF;
        break;

    case LDAP_NOT_ALLOWED_ON_RDN :
        dwErr = ERROR_DS_CANT_ON_RDN;
        break;

    case LDAP_ALREADY_EXISTS :
        dwErr = ERROR_OBJECT_ALREADY_EXISTS;
        break;

    case LDAP_NO_OBJECT_CLASS_MODS :
        dwErr = ERROR_DS_CANT_MOD_OBJ_CLASS;
        break;

    case LDAP_RESULTS_TOO_LARGE :
        dwErr = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        break;

    case LDAP_AFFECTS_MULTIPLE_DSAS :
        dwErr = ERROR_DS_AFFECTS_MULTIPLE_DSAS;
        break;

    case LDAP_OTHER :
        dwErr = ERROR_GEN_FAILURE;
        break;

    case LDAP_SERVER_DOWN :
        dwErr = ERROR_DS_SERVER_DOWN;
        break;

    case LDAP_LOCAL_ERROR :
        dwErr = ERROR_DS_LOCAL_ERROR;
        break;

    case LDAP_ENCODING_ERROR :
        dwErr = ERROR_DS_ENCODING_ERROR;
        break;

    case LDAP_DECODING_ERROR :
        dwErr = ERROR_DS_DECODING_ERROR;
        break;

    case LDAP_TIMEOUT :
        dwErr = ERROR_TIMEOUT;
        break;

    case LDAP_AUTH_UNKNOWN :
        dwErr = ERROR_DS_AUTH_UNKNOWN;
        break;

    case LDAP_FILTER_ERROR :
        dwErr = ERROR_DS_FILTER_UNKNOWN;
        break;

    case LDAP_USER_CANCELLED :
       dwErr = ERROR_CANCELLED;
       break;

    case LDAP_PARAM_ERROR :
        dwErr = ERROR_DS_PARAM_ERROR;
        break;

    case LDAP_NO_MEMORY :
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case LDAP_CONNECT_ERROR :
        dwErr = ERROR_CONNECTION_REFUSED;
        break;

    case LDAP_NOT_SUPPORTED :
        dwErr = ERROR_DS_NOT_SUPPORTED;
        break;

    case LDAP_NO_RESULTS_RETURNED :
        dwErr = ERROR_DS_NO_RESULTS_RETURNED;
        break;

    case LDAP_CONTROL_NOT_FOUND :
        dwErr = ERROR_DS_CONTROL_NOT_FOUND;
        break;

    case LDAP_MORE_RESULTS_TO_RETURN :
        dwErr = ERROR_MORE_DATA;
        break;

    case LDAP_CLIENT_LOOP :
        dwErr = ERROR_DS_CLIENT_LOOP;
        break;

    case LDAP_REFERRAL_LIMIT_EXCEEDED :
        dwErr = ERROR_DS_REFERRAL_LIMIT_EXCEEDED;
        break;

    default:
        //
        // It may not be a bad idea to add range checking here
        //
        dwErr = (DWORD) LdapMapErrorToWin32(ldaperr);

    }

    //
    // Set extended error only if it was not success and the
    // handle was not NULL
    //
    if ((ldaperr != LDAP_SUCCESS) && (ld !=NULL)) {

        dwStatus = ldap_get_optionW(
                       ld,
                       LDAP_OPT_SERVER_ERROR,
                       (void *)&ppszLdapMessage
                       );

        if (ppszLdapMessage != NULL && dwStatus == NO_ERROR) {
            dwLdapErrParse = wcstoul(ppszLdapMessage, &pszStopChar, 16);
            //
            // If the error code is zero and the message and stopChar
            // point to the same location, we must have invalid data.
            // We also have invalid data if the return value from the
            // call is ULONG_MAX.
            //
            if ((!dwLdapErrParse && (ppszLdapMessage == pszStopChar))
                || (dwLdapErrParse == (DWORD) -1)
                ) {
                dwLdapErrParse = ERROR_INVALID_DATA;
            }
        }

        ADsSetLastError(
            dwLdapErrParse,
            ppszLdapMessage,
            L"LDAP Provider"
            );

        if (ppszLdapMessage) {
            LdapMemFree(ppszLdapMessage);
            ppszLdapMessage = NULL;
        }

    } else {

        // We need to reset the last error with a well known value
        ADsSetLastError(
            NO_ERROR,
            NULL,
            L"LDAP Provider"
            );
    }


    *perr = HRESULT_FROM_WIN32(dwErr);


}

//
// Return TRUE if the error is a connection error. Ie. this bind handle is
// no longer valid and should not be reused.
//
BOOL LdapConnectionErr(
    int err,
    int ldaperr,
    BOOL *fTryRebind
    )
{

   (void) fTryRebind ;  // currently not used

   switch (err) {

       case ERROR_DS_UNAVAILABLE :
       case ERROR_GEN_FAILURE :
       case ERROR_DS_LOCAL_ERROR :
       case ERROR_DS_SERVER_DOWN :
           return TRUE ;

       default:
           return FALSE ;
    }
}

HRESULT LdapSearchExtSHelper(
    LDAP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    PLDAPControlW * ServerControls,
    PLDAPControlW *ClientControls,
    struct l_timeval *Timeout,
    ULONG SizeLimit,
    LDAPMessage **res
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ldaperr = ldap_search_ext_s( ld,
                              base,
                              scope,
                              filter,
                              attrs,
                              attrsonly,
                              ServerControls,
                              ClientControls,
                              Timeout,
                              SizeLimit,
                              res );

    if (ldaperr) {
           CheckAndSetExtendedError( ld, &hr, ldaperr, *res );
    }

    return hr;

}

HRESULT LdapSearchExtS(
    ADS_LDP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    PLDAPControlW * ServerControls,
    PLDAPControlW *ClientControls,
    struct l_timeval *Timeout,
    ULONG           SizeLimit,
    LDAPMessage **res
)
{
    HRESULT hr = LdapSearchExtSHelper(
                  ld->LdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  ServerControls,
                  ClientControls,
                  Timeout,
                  SizeLimit,
                  res );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapSearchExt(
    ADS_LDP         *ld,
    WCHAR           *base,
    int             scope,
    WCHAR           *filter,
    WCHAR           *attrs[],
    int             attrsonly,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls,
    ULONG           TimeLimit,
    ULONG           SizeLimit,
    ULONG           *MessageNumber
)
{
    char *pszBaseA = NULL;
    int ldaperr = 0;
    HRESULT hr = 0;

    ldaperr = ldap_search_ext(
                  ld->LdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  ServerControls,
                  ClientControls,
                  TimeLimit,
                  SizeLimit,
                  MessageNumber
                  );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


ULONG _cdecl QueryForConnection(
    PLDAP       PrimaryConnection,
    PLDAP       ReferralFromConnection,
    PWCHAR      NewDN,
    PCHAR       HostName,
    ULONG       PortNumber,
    PVOID       SecAuthIdentity,    // if null, use CurrentUser below
    PVOID       CurrentUserToken,   // pointer to current user's LUID
    PLDAP       *ConnectionToUse
    )
{
    HRESULT hr = S_OK;
    PADS_LDP pCacheEntry = NULL;
    LPWSTR pszServer = NULL;

    PSEC_WINNT_AUTH_IDENTITY pSecAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) SecAuthIdentity;
    PLUID pLuid = (PLUID) CurrentUserToken;
    CCredentials Credentials;

    if (ConnectionToUse) {
        *ConnectionToUse = NULL;
    }

    if (!pLuid) {
        goto error;
    }

    if (pSecAuthIdentity) {
        hr = Credentials.SetUserName(pSecAuthIdentity->User);
        BAIL_ON_FAILURE(hr);

        hr = Credentials.SetPassword(pSecAuthIdentity->Password);
        BAIL_ON_FAILURE(hr);

        Credentials.SetAuthFlags(ADS_SECURE_AUTHENTICATION);
    }

    if (ConvertToUnicode(HostName, &pszServer ))
        goto error;

    if (!pszServer) {
        //
        // Cannot do a lookup without server name.
        //
        goto error;
    }
    if (pCacheEntry = BindCacheLookup(pszServer, *pLuid, ReservedLuid, Credentials, PortNumber)) {

         *ConnectionToUse = pCacheEntry->LdapHandle ;
    }

error:

    if (pszServer) {
        FreeADsMem(pszServer);
    }

    return 0;

}

BOOLEAN _cdecl NotifyNewConnection(
    PLDAP       PrimaryConnection,
    PLDAP       ReferralFromConnection,
    PWCHAR      NewDN,
    PCHAR       HostName,
    PLDAP       NewConnection,
    ULONG       PortNumber,
    PVOID       SecAuthIdentity,    // if null, use CurrentUser below
    PVOID       CurrentUser,        // pointer to current user's LUID
    ULONG       ErrorCodeFromBind
    )
{

    PADS_LDP pCacheEntry = NULL;
    PADS_LDP pPrimaryEntry = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszServer = NULL;
    DWORD err;

    BOOLEAN ret = FALSE;

    PSEC_WINNT_AUTH_IDENTITY pSecAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) SecAuthIdentity;
    PLUID pLuid = (PLUID) CurrentUser;
    CCredentials Credentials;

    if (!pLuid || !NewConnection) {
        goto error;
    }

    //
    // Get the cache entry corresponding to the Primary Connection
    // This is necessary so that we can link the new connection to the primary
    // connection so that we can decrease the reference
    //

    if ((pPrimaryEntry = GetCacheEntry(PrimaryConnection)) == NULL) {
        goto error;
    }

    err = BindCacheAllocEntry(&pCacheEntry) ;

    if (err != NO_ERROR) {
        goto error;
    }

    if ( ConvertToUnicode(HostName, &pszServer))
        goto error;

    if (pSecAuthIdentity) {
        hr = Credentials.SetUserName(pSecAuthIdentity->User);
        BAIL_ON_FAILURE(hr);

        hr = Credentials.SetPassword(pSecAuthIdentity->Password);
        BAIL_ON_FAILURE(hr);

        Credentials.SetAuthFlags(ADS_SECURE_AUTHENTICATION);
    }

    pCacheEntry->LdapHandle = NewConnection;

    err = BindCacheAdd(pszServer, *pLuid, ReservedLuid, Credentials, PortNumber, pCacheEntry) ;
    if (err == NO_ERROR) {

        if (!AddReferralLink(pPrimaryEntry, pCacheEntry)) {
            //
            // If the referral link could not be succesfully added, we don't
            // want to keep this connection.
            //
            BindCacheDeref(pCacheEntry);
            goto error;
        }

        //
        // return TRUE to indicate that we have succesfully cached the handle
        //
        ret = TRUE;
    }

error:

    if (pszServer) {
        FreeADsMem(pszServer);
    }

    if (!ret && pCacheEntry) {
        FreeADsMem(pCacheEntry);
    }

    return ret;
}


ULONG _cdecl DereferenceConnection(
    PLDAP       PrimaryConnection,
    PLDAP       ConnectionToDereference
    )
{

    PADS_LDP pCacheEntry;

    if (ConnectionToDereference) {

        if (pCacheEntry = GetCacheEntry(ConnectionToDereference)) {
            LdapCloseObject(pCacheEntry);
        }
    }

    return S_OK;
}

HRESULT LdapSearchInitPage(
    ADS_LDP         *ld,
    PWCHAR          base,
    ULONG           scope,
    PWCHAR          filter,
    PWCHAR          attrs[],
    ULONG           attrsonly,
    PLDAPControlW   *serverControls,
    PLDAPControlW   *clientControls,
    ULONG           pageTimeLimit,
    ULONG           totalSizeLimit,
    PLDAPSortKeyW   *sortKeys,
    PLDAPSearch     *ppSearch
    )
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ppSearch);

    *ppSearch = ldap_search_init_page(
                    ld->LdapHandle,
                    base,
                    scope,
                    filter,
                    attrs,
                    attrsonly,
                    serverControls,
                    clientControls,
                    pageTimeLimit,
                    totalSizeLimit,
                    sortKeys
                    );

    if (*ppSearch == NULL) {

        ldaperr = LdapGetLastError();
    }

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;

}


HRESULT LdapGetNextPage(
        ADS_LDP         *ld,
        PLDAPSearch     searchHandle,
        ULONG           pageSize,
        ULONG           *pMessageNumber
        )
{
    HRESULT hr = S_OK;

    int ldaperr = ldap_get_next_page(
                    ld->LdapHandle,
                    searchHandle,
                    pageSize,
                    pMessageNumber
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapGetNextPageS(
        ADS_LDP         *ld,
        PLDAPSearch     searchHandle,
        struct l_timeval  *timeOut,
        ULONG           pageSize,
        ULONG          *totalCount,
        LDAPMessage     **results
        )
{
    HRESULT hr = S_OK;

    int ldaperr = ldap_get_next_page_s(
                    ld->LdapHandle,
                    searchHandle,
                    timeOut,
                    pageSize,
                    totalCount,
                    results
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapGetPagedCount(
    ADS_LDP         *ld,
    PLDAPSearch     searchBlock,
    ULONG          *totalCount,
    PLDAPMessage    results
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_get_paged_count(
                    ld->LdapHandle,
                    searchBlock,
                    totalCount,
                    results
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, results );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapSearchAbandonPage(
    ADS_LDP         *ld,
    PLDAPSearch     searchBlock
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_search_abandon_page(
                    ld->LdapHandle,
                    searchBlock
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapEncodeSortControl(
    ADS_LDP *ld,
    PLDAPSortKeyW  *SortKeys,
    PLDAPControlW  Control,
    BOOLEAN Criticality
    )
{
    HRESULT hr = S_OK;

    int ldaperr = ldap_encode_sort_controlW (
                      ld->LdapHandle,
                      SortKeys,
                      Control,
                      Criticality
                      );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    return hr;
}

BOOL IsGCNamespace(
    LPWSTR szADsPath
    )
{

    WCHAR szNamespace[MAX_PATH];
    HRESULT hr = S_OK;

    hr = GetNamespaceFromADsPath(
             szADsPath,
             szNamespace
             );
    if (FAILED(hr))
        return FALSE;

    return (_wcsicmp(szNamespace, szGCNamespaceName) == 0);

}


HRESULT LdapCreatePageControl(
    ADS_LDP         *ld,
    ULONG           dwPageSize,
    struct berval   *Cookie,
    BOOL            fIsCritical,
    PLDAPControl    *Control        // Use LdapControlFree to free
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_create_page_control(
                    ld->LdapHandle,
                    dwPageSize,
                    Cookie,
                    (UCHAR) fIsCritical,
                     Control
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    return hr;
}

HRESULT LdapParsePageControl(
    ADS_LDP         *ld,
    PLDAPControl    *ServerControls,
    ULONG           *TotalCount,
    struct berval   **Cookie        // Use BerBvFree to free
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_parse_page_control(
                    ld->LdapHandle,
                    ServerControls,
                    TotalCount,
                    Cookie
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    return hr;
}


HRESULT LdapCreateVLVControl(
    ADS_LDP         *pld,
    PLDAPVLVInfo    pVLVInfo,
    UCHAR           fCritical,
    PLDAPControl    *ppControl        // Use LdapControlFree to free
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_create_vlv_control(
                    pld->LdapHandle,
                    pVLVInfo,
                    fCritical,
                    ppControl
                    );

    CheckAndSetExtendedError( pld->LdapHandle, &hr, ldaperr );

    return hr;
}



HRESULT LdapParseVLVControl(
    ADS_LDP         *pld,
    PLDAPControl    *ppServerControls,
    ULONG           *pTargetPos,
    ULONG           *pListCount,
    struct berval   **ppCookie        // Use BerBvFree to free
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_parse_vlv_control(
                    pld->LdapHandle,
                    ppServerControls,
                    pTargetPos,
                    pListCount,
                    ppCookie,
                    NULL
                    );

    CheckAndSetExtendedError( pld->LdapHandle, &hr, ldaperr );

    return hr;
}


HRESULT LdapParseResult(
    ADS_LDP         *ld,
    LDAPMessage *ResultMessage,
    ULONG *ReturnCode OPTIONAL,          // returned by server
    PWCHAR *MatchedDNs OPTIONAL,         // free with LdapMemFree
    PWCHAR *ErrorMessage OPTIONAL,       // free with LdapMemFree
    PWCHAR **Referrals OPTIONAL,         // free with LdapValueFree
    PLDAPControlW **ServerControls OPTIONAL,    // free with LdapFreeControls
    BOOL Freeit
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_parse_result(
                      ld->LdapHandle,
                      ResultMessage,
                      ReturnCode,
                      MatchedDNs,
                      ErrorMessage,
                      Referrals,
                      ServerControls,
                      (BOOLEAN) Freeit
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, ResultMessage );

    return hr;
}


void
LdapControlsFree(
    PLDAPControl    *ppControl
    )
{
    ldap_controls_free( ppControl );

}

void
LdapControlFree(
    PLDAPControl    pControl
    )
{
    ldap_control_free( pControl );

}

void
BerBvFree(
    struct berval *bv
    )
{
    ber_bvfree( bv );

}

//
// This function looks at the LDAP error code to see if we
// should try and bind again using a lower version level or
// alternate mechanism
//
BOOLEAN
LDAPCodeWarrantsRetry(
    HRESULT hr
    )
{
    BOOLEAN fretVal = FALSE;

    switch (hr) {

    case HRESULT_FROM_WIN32(ERROR_DS_OPERATIONS_ERROR) :
        fretVal = TRUE;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_PROTOCOL_ERROR) :
        fretVal = TRUE;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED) :
        fretVal = TRUE;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN) :
        fretVal = TRUE;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_NOT_SUPPORTED) :
        fretVal = TRUE;
        break;

    default:
        fretVal = FALSE;
        break;
    } // end case

    return fretVal;
}



HRESULT
LdapcSetStickyServer(
    LPWSTR pszDomainName,
    LPWSTR pszServerName
    )
    {
    HRESULT hr = S_OK;

    if (gpszServerName) {
        FreeADsStr(gpszServerName);
        gpszServerName = NULL;
    }

    if (pszServerName) {
        gpszServerName = AllocADsStr(pszServerName);

        if (!gpszServerName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    if (gpszDomainName) {
        FreeADsStr(gpszDomainName);
        gpszDomainName = NULL;
    }

    if (pszDomainName) {
        gpszDomainName = AllocADsStr(pszDomainName);
        
        if (!gpszDomainName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    RRETURN(hr);

error :

    if (gpszServerName) {
        FreeADsStr(gpszServerName);
        gpszServerName = NULL;
    }

    if (gpszDomainName) {
        FreeADsStr(gpszDomainName);
        gpszDomainName = NULL;
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

TCHAR *szProviderName = TEXT("LDAP");
TCHAR *szLDAPNamespaceName = TEXT("LDAP");
TCHAR *szGCNamespaceName = TEXT("GC");

//
// The default schema to use if the ldap server does not support schema
//
LPTSTR g_aDefaultAttributeTypes[] =
{ TEXT("( 2.5.4.0 NAME 'objectClass' EQUALITY objectIdentifierMatch SYNTAX 'OID' )"),
  TEXT("( 2.5.4.1 NAME 'aliasedObjectName' EQUALITY distinguishedNameMatch SYNTAX 'DN' SINGLE-VALUE )"),
  TEXT("( 2.5.4.2 NAME 'knowledgeInformation' EQUALITY caseIgnoreMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.3 NAME 'cn' SUP name )"),
  TEXT("( 2.5.4.4 NAME 'sn' SUP name )"),
  TEXT("( 2.5.4.5 NAME 'serialNumber' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'PrintableString' )"),
  TEXT("( 2.5.4.6 NAME 'c' SUP name SINGLE-VALUE )"),
  TEXT("( 2.5.4.7 NAME 'l' SUP name )"),
  TEXT("( 2.5.4.8 NAME 'st' SUP name )"),
  TEXT("( 2.5.4.9 NAME 'street' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.10 NAME 'o' SUP name )"),
  TEXT("( 2.5.4.11 NAME 'ou' SUP name )"),
  TEXT("( 2.5.4.12 NAME 'title' SUP name )"),
  TEXT("( 2.5.4.13 NAME 'description' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.14 NAME 'searchGuide' SYNTAX 'Guide' )"),
  TEXT("( 2.5.4.15 NAME 'businessCategory' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.16 NAME 'postalAddress' EQUALITY caseIgnoreListMatch SUBSTR caseIgnoreListSubstringsMatch SYNTAX 'PostalAddress' )"),
  TEXT("( 2.5.4.17 NAME 'postalCode' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.18 NAME 'postOfficeBox' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.19 NAME 'physicalDeliveryOfficeName' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.20 NAME 'telephoneNumber' EQUALITY telephoneNumberMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 'TelephoneNumber' )"),
  TEXT("( 2.5.4.21 NAME 'telexNumber' SYNTAX 'TelexNumber' )"),
  TEXT("( 2.5.4.22 NAME 'teletexTerminalIdentifier' SYNTAX 'TeletexTerminalIdentifier' )"),
  TEXT("( 2.5.4.23 NAME 'facsimileTelephoneNumber' SYNTAX 'FacsimileTelephoneNumber' )"),
  TEXT("( 2.5.4.24 NAME 'x121Address' EQUALITY numericStringMatch SUBSTR numericStringSubstringsMatch SYNTAX 'NumericString' )"),
  TEXT("( 2.5.4.25 NAME 'internationaliSDNNumber' EQUALITY numericStringMatch SUBSTR numericStringSubstringsMatch SYNTAX 'NumericString' )"),
  TEXT("( 2.5.4.26 NAME 'registeredAddress' SUP postalAddress SYNTAX 'PostalAddress' )"),
  TEXT("( 2.5.4.27 NAME 'destinationIndicator' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'PrintableString' )"),
  TEXT("( 2.5.4.28 NAME 'preferredDeliveryMethod' SYNTAX 'DeliveryMethod' SINGLE-VALUE )"),
  TEXT("( 2.5.4.29 NAME 'presentationAddress' EQUALITY presentationAddressMatch SYNTAX 'PresentationAddress' SINGLE-VALUE )"),
  TEXT("( 2.5.4.30 NAME 'supportedApplicationContext' EQUALITY objectIdentifierMatch SYNTAX 'OID' )"),
  TEXT("( 2.5.4.31 NAME 'member' SUP distinguishedName )"),
  TEXT("( 2.5.4.32 NAME 'owner' SUP distinguishedName )"),
  TEXT("( 2.5.4.33 NAME 'roleOccupant' SUP distinguishedName )"),
  TEXT("( 2.5.4.34 NAME 'seeAlso' SUP distinguishedName )"),
  TEXT("( 2.5.4.35 NAME 'userPassword' EQUALITY octetStringMatch SYNTAX 'Password')"),
  TEXT("( 2.5.4.36 NAME 'userCertificate' SYNTAX 'Certificate' )"),
  TEXT("( 2.5.4.37 NAME 'cACertificate' SYNTAX 'Certificate' )"),
  TEXT("( 2.5.4.38 NAME 'authorityRevocationList' SYNTAX 'CertificateList' )"),
  TEXT("( 2.5.4.39 NAME 'certificateRevocationList' SYNTAX 'CertificateList' )"),
  TEXT("( 2.5.4.40 NAME 'crossCertificatePair' SYNTAX 'CertificatePair' )"),
  TEXT("( 2.5.4.41 NAME 'name' DESC 'The name attribute type is the attribute supertype from which string attribute types typically used for naming may be formed.' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 2.5.4.42 NAME 'givenName' SUP name )"),
  TEXT("( 2.5.4.43 NAME 'initials' DESC 'The initials attribute type contains the initials of some or all of an individuals names, but not the surname(s).' SUP name )"),
  TEXT("( 2.5.4.44 NAME 'generationQualifier'  DESC 'e.g. Jr or II.' SUP name )"),
  TEXT("( 2.5.4.45 NAME 'x500UniqueIdentifier'  DESC 'used to distinguish between objects when a distinguished name has been reused.' EQUALITY bitStringMatch SYNTAX 'BitString' )"),
  TEXT("( 2.5.4.46 NAME 'dnQualifier' DESC 'The dnQualifier attribute type specifies disambiguating information to add to the relative distinguished name of an entry.  It is intended to be used for entries held in multiple DSAs which would otherwise have the same name, and that its value be the same in a given DSA for all entries to which this information has been added.' EQUALITY caseIgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'PrintableString' )"),
  TEXT("( 2.5.4.47 NAME 'enhancedSearchGuide' SYNTAX 'EnhancedGuide' )"),
  TEXT("( 2.5.4.48 NAME 'protocolInformation' EQUALITY protocolInformationMatch SYNTAX 'ProtocolInformation' )"),
  TEXT("( 2.5.4.49 NAME 'distinguishedName'  DESC 'This is not the name of the object itself, but a base type from which attributes with DN syntax inherit.' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 2.5.4.50 NAME 'uniqueMember' EQUALITY uniqueMemberMatch SYNTAX 'NameAndOptionalUID' )"),
  TEXT("( 2.5.4.51 NAME 'houseIdentifier' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.1 NAME 'uid' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.2 NAME 'textEncodedORaddress' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.3 NAME 'mail' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.4 NAME 'info' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.5 NAME 'drink' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.6 NAME 'roomNumber' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.7 NAME 'photo' SYNTAX 'Fax' )"),
  TEXT("( 0.9.2342.19200300.100.1.8 NAME 'userClass' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.9 NAME 'host' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.10 NAME 'manager' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.11 NAME 'documentIdentifier' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.12 NAME 'documentTitle' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.13 NAME 'documentVersion' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.14 NAME 'documentAuthor' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.15 NAME 'documentLocation' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch  SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.20 NAME 'homePhone' EQUALITY telephoneNumberMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 'TelephoneNumber' )"),
  TEXT("( 0.9.2342.19200300.100.1.21 NAME 'secretary' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.22 NAME 'otherMailbox' SYNTAX 'OtherMailbox' )"),
  TEXT("( 0.9.2342.19200300.100.1.25 NAME 'dc' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.26 NAME 'dNSRecord' EQUALITY caseExactIA5Match SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.37 NAME 'associatedDomain' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.38 NAME 'associatedName' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.39 NAME 'homePostalAddress' EQUALITY caseIgnoreListMatch SUBSTR caseIgnoreListSubstringsMatch SYNTAX 'PostalAddress' )"),
  TEXT("( 0.9.2342.19200300.100.1.40 NAME 'personalTitle' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.41 NAME 'mobile' EQUALITY telephoneNumberMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 'TelephoneNumber' )"),
  TEXT("( 0.9.2342.19200300.100.1.42 NAME 'pager' EQUALITY telephoneNumberMatch SUBSTR telephoneNumberSubstringsMatch SYNTAX 'TelephoneNumber' )"),
  TEXT("( 0.9.2342.19200300.100.1.43 NAME 'co' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.44 NAME 'pilotUniqueIdentifier' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.45 NAME 'organizationalStatus' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.46 NAME 'janetMailbox' EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch SYNTAX 'IA5String' )"),
  TEXT("( 0.9.2342.19200300.100.1.47 NAME 'mailPreferenceOption' SYNTAX 'INTEGER' SINGLE-VALUE NO-USER-MODIFICATION  USAGE directoryOperation )"),
  TEXT("( 0.9.2342.19200300.100.1.48 NAME 'buildingName' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.49 NAME 'dSAQuality' SYNTAX 'DSAQualitySyntax' SINGLE-VALUE )"),
  TEXT("( 0.9.2342.19200300.100.1.50 NAME 'singleLevelQuality' SYNTAX 'DataQualitySyntax' SINGLE-VALUE )"),
  TEXT("( 0.9.2342.19200300.100.1.51 NAME 'subtreeMinimumQuality' SYNTAX 'DataQualitySyntax' SINGLE-VALUE )"),
  TEXT("( 0.9.2342.19200300.100.1.52 NAME 'subtreeMaximumQuality' SYNTAX 'DataQualitySyntax' SINGLE-VALUE )"),
  TEXT("( 0.9.2342.19200300.100.1.53 NAME 'personalSignature' SYNTAX 'Fax' )"),
  TEXT("( 0.9.2342.19200300.100.1.54 NAME 'dITRedirect' EQUALITY distinguishedNameMatch SYNTAX 'DN' )"),
  TEXT("( 0.9.2342.19200300.100.1.55 NAME 'audio' SYNTAX 'Audio' )"),
  TEXT("( 0.9.2342.19200300.100.1.56 NAME 'documentPublisher' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 'DirectoryString' )"),
  TEXT("( 0.9.2342.19200300.100.1.60 NAME 'jpegPhoto' SYNTAX 'JPEG' )"),
  TEXT("( 2.5.18.1 NAME 'createTimestamp' EQUALITY generalizedTimeMatch ORDERING generalizedTimeOrderingMatch SYNTAX 'GeneralizedTime' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 2.5.18.2 NAME 'modifyTimestamp' EQUALITY generalizedTimeMatch ORDERING generalizedTimeOrderingMatch SYNTAX 'GeneralizedTime' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 2.5.18.3 NAME 'creatorsName' EQUALITY distinguishedNameMatch SYNTAX 'DN' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 2.5.18.4 NAME 'modifiersName' EQUALITY distinguishedNameMatch SYNTAX 'DN' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 2.5.18.10 NAME 'subschemaSubentry' DESC 'The value of this attribute is the name of a subschema subentry, an entry in which the server makes available attributes specifying the schema.' EQUALITY distinguishedNameMatch SYNTAX 'DN' NO-USER-MODIFICATION SINGLE-VALUE USAGE directoryOperation )"),
  TEXT("( 2.5.21.5 NAME 'attributeTypes' EQUALITY objectIdentifierFirstComponentMatch SYNTAX 'AttributeTypeDescription' USAGE directoryOperation )"),
  TEXT("( 2.5.21.6 NAME 'objectClasses' EQUALITY objectIdentifierFirstComponentMatch SYNTAX 'ObjectClassDescription' USAGE directoryOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.1 NAME 'administratorsAddress' DESC 'This attribute\27s values are string containing the addresses of the LDAP server\27s human administrator.  This information may be of use when tracking down problems in an Internet distributed directory.  For simplicity the syntax of the values are limited to being URLs of the mailto form with an RFC 822 address: \"mailto:user@domain\".  Future versions of this protocol may permit other forms of addresses.' SYNTAX 'IA5String' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.2 NAME 'currentTime' DESC 'This attribute has a single value, a string containing a GeneralizedTime character string.  This attribute need only be present if the server supports LDAP strong or protected simple authentication. Otherwise if the server does not know the current time, or does not choose to present it to clients, this attribute need not be present. The client may wish to use this value to detect whether a strong or protected bind is failing because the client and server clocks are not sufficiently synchronized.  Clients should not use this time field for setting their own system clock.' SYNTAX 'GeneralizedTime' SINGLE-VALUE USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.3 NAME 'serverName' DESC 'This attribute\27s value is the server\27s Distinguished Name.  If the server does not have a Distinguished Name it will not be able to accept X.509-style strong authentication, and this attribute should be absent.  However the presence of this attribute does not guarantee that the server will be able to perform strong authentication.  If the server acts as a gateway to more than one X.500 DSA capable of strong authentication, there may be multiple values of this attribute, one per DSA.  (Note: this attribute is distinct from myAccessPoint, for it is not required that a server have a presentation address in order to perform strong authentication.)  (Note: it is likely that clients will retrieve this attribute in binary.)' SYNTAX 'DN' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.4 NAME 'certificationPath' DESC 'This attribute contains a binary DER encoding of an AF.CertificatePath data type, which is the certificate path for a server.  If the server does not have a certificate path this attribute should be absent.  (Note: this attribute may only be retrieved in binary.)' SYNTAX 'CertificatePath' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.5 NAME 'namingContexts' DESC 'The values of this attribute correspond to naming contexts which this server masters or shadows.  If the server does not master any information (e.g. it is an LDAP gateway to a public X.500 directory) this attribute should be absent.  If the server believes it contains the entire directory, the attribute should have a single value, and that value should be the empty string (indicating the null DN of the root). This attribute will allow clients to choose suitable base objects for searching when it has contacted a server.' SYNTAX 'DN' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.6 NAME 'altServer' DESC 'The values of this attribute are URLs of other servers which may be contacted when this server becomes unavailable.  If the server does not know of any other servers which could be used this attribute should be absent. Clients should cache this information in case their preferred LDAP server later becomes unavailable.' SYNTAX 'IA5String' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.7 NAME 'supportedExtension' DESC 'The values of this attribute are OBJECT IDENTIFIERs, the names of supported extensions which the server supports.   If the server does not support any extensions this attribute should be absent.' SYNTAX 'OID' USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.8 NAME 'entryName' SYNTAX 'DN' SINGLE-VALUE NO-USER-MODIFICATION USAGE directoryOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.9 NAME 'modifyRights' SYNTAX 'ModifyRight' NO-USER-MODIFICATION USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.10 NAME 'incompleteEntry' SYNTAX 'BOOLEAN' NO-USER-MODIFICATION USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.120.11 NAME 'fromEntry' SYNTAX 'BOOLEAN' NO-USER-MODIFICATION USAGE dSAOperation )"),
  TEXT("( 1.3.6.1.4.1.1466.101.121.1 NAME 'url' DESC 'Uniform Resource Locator' EQUALITY caseExactIA5Match SYNTAX 'IA5String' )"),
  TEXT("( 2.16.840.1.113730.3.1.18 NAME 'mailHost' DESC 'mailHost attribute on some V2 servers' SYNTAX 'DirectoryString' )")
};

DWORD g_cDefaultAttributeTypes = sizeof(g_aDefaultAttributeTypes)/sizeof(g_aDefaultAttributeTypes[0]);

LPTSTR g_aDefaultObjectClasses[] = {
  TEXT("( 2.5.6.0 NAME 'top' ABSTRACT MUST objectClass )"),
  TEXT("( 2.5.6.1 NAME 'alias' SUP top STRUCTURAL MUST aliasedObjectName )"),
  TEXT("( 2.5.6.2 NAME 'country' SUP top STRUCTURAL MUST c MAY ( searchGuide $ description ) )"),
  TEXT("( 2.5.6.3 NAME 'locality' SUP top STRUCTURAL MAY ( street $ seeAlso $ searchGuide $ st $ l $ description ) )"),
  TEXT("( 2.5.6.4 NAME 'organization' SUP top STRUCTURAL MUST o MAY ( userPassword $ searchGuide $ seeAlso $ businessCategory $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ st $ l $ description ) )"),
  TEXT("( 2.5.6.5 NAME 'organizationalUnit' SUP top STRUCTURAL MUST ou MAY ( userPassword $ searchGuide $ seeAlso $ businessCategory $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ st $ l $ description ) )"),
  TEXT("( 2.5.6.6 NAME 'person' SUP top STRUCTURAL MUST ( sn $ cn ) MAY ( userPassword $ telephoneNumber $ seeAlso $ description ) )"),
  TEXT("( 2.5.6.7 NAME 'organizationalPerson' SUP person STRUCTURAL MAY ( title $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ ou $ st $ l ) )"),
  TEXT("( 2.5.6.8 NAME 'organizationalRole' SUP top STRUCTURAL MUST cn MAY ( x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ seeAlso $ roleOccupant $ preferredDeliveryMethod $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ ou $ st $ l $ description ) )"),
  TEXT("( 2.5.6.9 NAME 'groupOfNames' SUP top STRUCTURAL MUST ( member $ cn ) MAY ( businessCategory $ seeAlso $ owner $ ou $ o $ description ) )"),
  TEXT("( 2.5.6.10 NAME 'residentialPerson' SUP person STRUCTURAL MUST l MAY ( businessCategory $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ preferredDeliveryMethod $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ st ) )"),
  TEXT("( 2.5.6.11 NAME 'applicationProcess' SUP top STRUCTURAL MUST cn MAY ( seeAlso $ ou $ l $ description ) )"),
  TEXT("( 2.5.6.12 NAME 'applicationEntity' SUP top STRUCTURAL MUST ( presentationAddress $ cn ) MAY ( supportedApplicationContext $ seeAlso $ ou $ o $ l $ description ) )"),
  TEXT("( 2.5.6.13 NAME 'dSA' SUP applicationEntity STRUCTURAL MAY knowledgeInformation )"),
  TEXT("( 2.5.6.14 NAME 'device' SUP top STRUCTURAL MUST cn MAY ( serialNumber $ seeAlso $ owner $ ou $ o $ l $ description ) )"),
  TEXT("( 2.5.6.15 NAME 'strongAuthenticationUser' SUP top STRUCTURAL MUST userCertificate )"),
  TEXT("( 2.5.6.16 NAME 'certificationAuthority' SUP top STRUCTURAL MUST ( authorityRevocationList $ certificateRevocationList $ cACertificate ) MAY crossCertificatePair )"),
  TEXT("( 2.5.6.17 NAME 'groupOfUniqueNames' SUP top STRUCTURAL MUST ( uniqueMember $ cn ) MAY ( businessCategory $ seeAlso $ owner $ ou $ o $ description ) )"),
  TEXT("( 0.9.2342.19200300.100.4.3 NAME 'pilotObject' SUP top STRUCTURAL MAY ( jpegPhoto $ audio $ dITRedirect $ lastModifiedBy $ lastModifiedTime $  pilotUniqueIdentifier $ manager $ photo $ info ) )"),
  TEXT("( 0.9.2342.19200300.100.4.4 NAME 'newPilotPerson' SUP person STRUCTURAL MAY ( personalSignature $ mailPreferenceOption $ organizationalStatus $ pagerTelephoneNumber $ mobileTelephoneNumber $ otherMailbox $ janetMailbox $ businessCategory $ preferredDeliveryMethod $ personalTitle $ secretary $ homePostalAddress $ homePhone $ userClass $ roomNumber $ favouriteDrink $ rfc822Mailbox $ textEncodedORaddress $ userid ) )"),
  TEXT("( 0.9.2342.19200300.100.4.5 NAME 'account' SUP top STRUCTURAL MUST userid MAY ( host $ ou $ o $ l $ seeAlso $ description ) )"),
  TEXT("( 0.9.2342.19200300.100.4.6 NAME 'document' SUP ( top $ pilotObject ) STRUCTURAL MUST documentIdentifier MAY ( documentPublisher $ documentStore $ documentAuthorSurName $ documentAuthorCommonName $ abstract $ subject $ keywords $ updatedByDocument $ updatesDocument $ obsoletedByDocument $ obsoletesDocument $ documentLocation $ documentAuthor $ documentVersion $ documentTitle $ ou $ o $ l $ seeAlso $ description $ cn ) )"),
  TEXT("( 0.9.2342.19200300.100.4.7 NAME 'room' SUP top STRUCTURAL MUST cn MAY ( telephoneNumber $ seeAlso $ description $ roomNumber ) )"),
  TEXT("( 0.9.2342.19200300.100.4.9 NAME 'documentSeries' SUP top STRUCTURAL MUST cn MAY ( ou $ o $ l $ telephoneNumber $ seeAlso $ description ) )"),
  TEXT("( 0.9.2342.19200300.100.4.13 NAME 'domain' SUP top STRUCTURAL MUST dc MAY ( userPassword $ searchGuide $ seeAlso $ businessCategory $ x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ street $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ st $ l $ description $ o $ associatedName ) ) "),
  TEXT("( 0.9.2342.19200300.100.4.14 NAME 'rFC822localPart' SUP domain STRUCTURAL MAY ( x121Address $ registeredAddress $ destinationIndicator $ preferredDeliveryMethod $ telexNumber $ teletexTerminalIdentifier $ telephoneNumber $ internationaliSDNNumber $ facsimileTelephoneNumber $ streetAddress $ postOfficeBox $ postalCode $ postalAddress $ physicalDeliveryOfficeName $ telephoneNumber $ seeAlso $ description $ sn $ cn ) ) "),
  TEXT("( 0.9.2342.19200300.100.4.15 NAME 'dNSDomain' SUP domain STRUCTURAL MAY dNSRecord ) "),
  TEXT("( 0.9.2342.19200300.100.4.17 NAME 'domainRelatedObject' SUP top STRUCTURAL MUST associatedDomain )"),
  TEXT("( 0.9.2342.19200300.100.4.18 NAME 'friendlyCountry' SUP country STRUCTURAL MUST co )"),
  TEXT("( 0.9.2342.19200300.100.4.19 NAME 'simpleSecurityObject' SUP top STRUCTURAL MUST userPassword )"),
  TEXT("( 0.9.2342.19200300.100.4.20 NAME 'pilotOrganization' SUP ( organization $ organizationalUnit ) STRUCTURAL MAY buildingName )"),
  TEXT("( 0.9.2342.19200300.100.4.21 NAME 'pilotDSA' SUP dSA STRUCTURAL MUST dSAQuality )"),
  TEXT("( 0.9.2342.19200300.100.4.23 NAME 'qualityLabelledData' SUP top STRUCTURAL MUST singleLevelQuality MAY ( subtreeMaximumQuality $ subtreeMinimumQuality ) ) ")
};

DWORD g_cDefaultObjectClasses = sizeof(g_aDefaultObjectClasses)/sizeof(g_aDefaultObjectClasses[0]);


//
// Table mapping from LDAPType To ADsType
//
ADSTYPE g_MapLdapTypeToADsType[] = {
    ADSTYPE_INVALID,
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_BITSTRING                   */
    ADSTYPE_PRINTABLE_STRING,                  /* LDAPTYPE_PRINTABLESTRING             */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_DIRECTORYSTRING             */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_CERTIFICATE                 */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_CERTIFICATELIST             */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_CERTIFICATEPAIR             */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_COUNTRYSTRING               */
    ADSTYPE_DN_STRING,                         /* LDAPTYPE_DN                          */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_DELIVERYMETHOD              */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_ENHANCEDGUIDE               */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_FACSIMILETELEPHONENUMBER    */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_GUIDE                       */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_NAMEANDOPTIONALUID          */
    ADSTYPE_NUMERIC_STRING,                    /* LDAPTYPE_NUMERICSTRING               */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_OID                         */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_PASSWORD                    */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_POSTALADDRESS               */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_PRESENTATIONADDRESS         */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_TELEPHONENUMBER             */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_TELETEXTERMINALIDENTIFIER   */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_TELEXNUMBER                 */
    ADSTYPE_UTC_TIME,                          /* LDAPTYPE_UTCTIME                     */
    ADSTYPE_BOOLEAN,                           /* LDAPTYPE_BOOLEAN                     */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_AUDIO                       */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_DSAQUALITYSYNTAX            */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_DATAQUALITYSYNTAX           */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_IA5STRING                   */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_JPEG                        */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_MAILPREFERENCE              */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_OTHERMAILBOX                */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_FAX                         */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_ATTRIBUTETYPEDESCRIPRITION  */
    ADSTYPE_UTC_TIME,                          /* LDAPTYPE_GENERALIZEDTIME             */
    ADSTYPE_INTEGER,                           /* LDAPTYPE_INTEGER                     */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_OBJECTCLASSDESCRIPTION      */
    ADSTYPE_OCTET_STRING,                      /* LDAPTYPE_OCTETSTRING                 */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_CASEIGNORESTRING            */
    ADSTYPE_LARGE_INTEGER,                     /* LDAPTYPE_INTEGER8                    */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_ACCESSPOINTDN               */
    ADSTYPE_CASE_IGNORE_STRING,                /* LDAPTYPE_ORNAME                      */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_MASTERANDSHADOWACCESSPOINTS */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_MATCHINGRULEDESCRIPTION     */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_MATCHINGRULEUSEDESCRIPTION  */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_NAMEFORMDESCRIPTION         */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_SUBTREESPECIFICATION        */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_SUPPLIERINFORMATION         */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_SUPPLIERORCONSUMER          */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_SUPPLIERANDCONSUMERS        */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_PROTOCOLINFORMATION         */
    ADSTYPE_INVALID,                           /* // #define LDAPTYPE_MODIFYRIGHT                 */
    ADSTYPE_NT_SECURITY_DESCRIPTOR,            /* LDAPTYPE_SECURITY_DESCRIPTOR         */
    ADSTYPE_CASE_EXACT_STRING,                 /* LDAPTYPE_CASEEXACT_STRING            */
    ADSTYPE_DN_WITH_BINARY,                    /* LDAPTYPE_DNWITHBINARY                */
    ADSTYPE_DN_WITH_STRING,                    /* LDAPTYPE_DNWITHSTRING                */
    ADSTYPE_CASE_IGNORE_STRING                 /* LDAPTYPE_ORADDRESS                   */
};


DWORD g_cMapLdapTypeToADsType = ARRAY_SIZE(g_MapLdapTypeToADsType);


//
// Table mapping from ADsType To LDAPType
//
DWORD g_MapADsTypeToLdapType[] = {
    LDAPTYPE_UNKNOWN,               // ADSTYPE_UNKNOWN
	LDAPTYPE_DN,                    // ADSTYPE_DN_STRING
	LDAPTYPE_CASEIGNORESTRING,      // ADSTYPE_CASE_EXACT_STRING
	LDAPTYPE_CASEIGNORESTRING,      // ADSTYPE_CASE_IGNORE_STRING
	LDAPTYPE_PRINTABLESTRING,       // ADSTYPE_CASE_PRINTABLE_STRING
	LDAPTYPE_NUMERICSTRING,         // ADSTYPE_CASE_NUMERIC_STRING
	LDAPTYPE_BOOLEAN,               // ADSTYPE_BOOLEAN
	LDAPTYPE_INTEGER,               // ADSTYPE_INTEGER
	LDAPTYPE_OCTETSTRING,           // ADSTYPE_OCTET_STRING
	LDAPTYPE_UTCTIME,               // ADSTYPE_UTC_TIME
	LDAPTYPE_INTEGER8,              // ADSTYPE_LARGE_INTEGER
	LDAPTYPE_OCTETSTRING,           // ADSTYPE_PROV_SPECIFIC
	LDAPTYPE_UNKNOWN,               // ADSTYPE_OBJECT_CLASS
	LDAPTYPE_UNKNOWN,               // ADSTYPE_CASEIGNORE_LIST
	LDAPTYPE_UNKNOWN,               // ADSTYPE_OCTET_LIST
	LDAPTYPE_UNKNOWN,               // ADSTYPE_PATH
	LDAPTYPE_UNKNOWN,               // ADSTYPE_POSTALADDRESS
	LDAPTYPE_UNKNOWN,               // ADSTYPE_TIMESTAMP
	LDAPTYPE_UNKNOWN,               // ADSTYPE_BACKLINK
	LDAPTYPE_UNKNOWN,               // ADSTYPE_TYPEDNAME
	LDAPTYPE_UNKNOWN,               // ADSTYPE_HOLD
	LDAPTYPE_UNKNOWN,               // ADSTYPE_NETADDRESS
	LDAPTYPE_UNKNOWN,               // ADSTYPE_REPLICAPOINTER
	LDAPTYPE_UNKNOWN,               // ADSTYPE_FAXNUMBER
	LDAPTYPE_UNKNOWN,               // ADSTYPE_EMAIL
	LDAPTYPE_SECURITY_DESCRIPTOR,   // ADSTYPE_NT_SECURITY_DESCRIPTOR
	LDAPTYPE_UNKNOWN                // ADSTYPE_UNKNOWN
};


DWORD g_cMapADsTypeToLdapType = ARRAY_SIZE(g_MapADsTypeToLdapType);


//+------------------------------------------------------------------------
//
//  Function:   MapADsTypeToLDAPType
//
//  Synopsis: This function attempts a best effort map from
//      ADSTYPE to LDAPTTPE - this is a best effort map
//      because LDAPTYPE->ADSTYPE is not a 1 --> 1 mapping.
//
//  Arguments:  [dwADsType]    -- ADSTYPE to be mapped
//
//  RetVal   : DWORD giving the ldaptype
//
//-------------------------------------------------------------------------
DWORD
MapADSTypeToLDAPType(
    ADSTYPE dwAdsType
    )
{
    DWORD dwADSTYPE = (DWORD) dwAdsType;

    if (dwAdsType < 0 || (DWORD)dwAdsType >= g_cMapADsTypeToLdapType) {
        return (LDAPTYPE_UNKNOWN);
    } else {
        return (g_MapADsTypeToLdapType[(DWORD)dwAdsType]);
    }
}



ADSTYPE
MapLDAPTypeToADSType(
    DWORD dwLdapType
    )
{
    //
    // - LDAPTYPE_UNKNOWN or 0 -> ADSTYPE_UNKNOWN
    //   NOTE:  should not be but misuse of 0 everywhere and just in case
    //          I didn't clean up completely
    //
    // - other undefined ldaptypes -> ADSTYPE_INVALID
    //

    if (dwLdapType==LDAPTYPE_UNKNOWN || dwLdapType==0) {

        return ADSTYPE_UNKNOWN;
    }

    else if (dwLdapType < g_cMapLdapTypeToADsType) {

        return(g_MapLdapTypeToADsType[dwLdapType]);
    }

    else {

        return(ADSTYPE_INVALID);
    }
}


LDAP_REFERRAL_CALLBACK g_LdapReferralCallBacks = {
    sizeof( LDAP_REFERRAL_CALLBACK ),
    &QueryForConnection,
    &NotifyNewConnection,
    &DereferenceConnection
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\ldpcache.cxx ===
#include "ldapc.hxx"
#pragma hdrstop

ADS_LDP           BindCache ;
DWORD             BindCacheCount = 0 ;
CRITICAL_SECTION  BindCacheCritSect ;
LUID              ReservedLuid = { 0, 0 } ;

//
// Wait for 1000ms * 60 * minutes
//
#define RETIRE_HANDLE (1000 * 60 * 5)
//
// Return the LUID for current credentials. Note we only use LUID. In theory
// it may be better to use SourceName as well as identifier but the former
// doesnt seem to always return the same string.
//
DWORD BindCacheGetLuid(LUID *Luid, LUID *ModifiedId)
{
    HANDLE           TokenHandle = NULL ;
    TOKEN_STATISTICS TokenInformation ;
    DWORD            ReturnLength ;


    //
    // Try thread first. If fail, try process.
    //
    if (!OpenThreadToken(
             GetCurrentThread(),
             TOKEN_QUERY,
             TRUE,
             &TokenHandle)) {

        if (!OpenProcessToken(
                 GetCurrentProcess(),
                 TOKEN_QUERY,
                 &TokenHandle)) {

            return(GetLastError()) ;
        }
    }

    //
    // Get the TokenSource info.
    //
    if (!GetTokenInformation(
            TokenHandle,
            TokenStatistics,
            &TokenInformation,
            sizeof(TokenInformation),
            &ReturnLength)) {

        CloseHandle(TokenHandle) ;
        return(GetLastError()) ;
    }

    *Luid = TokenInformation.AuthenticationId ;
    *ModifiedId = TokenInformation.ModifiedId;

    CloseHandle(TokenHandle) ;
    return(NO_ERROR) ;
}

//
// Initializes a cache entry
//
DWORD BindCacheAllocEntry(ADS_LDP **ppCacheEntry)
{

    ADS_LDP *pCacheEntry ;

    *ppCacheEntry = NULL ;

    if (!(pCacheEntry = (PADS_LDP)AllocADsMem(sizeof(ADS_LDP)))) {

        return(GetLastError()) ;
    }

    pCacheEntry->RefCount = 0;
    pCacheEntry->Flags = 0;
    pCacheEntry->List.Flink = NULL ;
    pCacheEntry->List.Blink = NULL ;

    pCacheEntry->ReferralEntries = NULL ;
    pCacheEntry->nReferralEntries = 0 ;
    pCacheEntry->fKeepAround = FALSE;

    *ppCacheEntry =  pCacheEntry ;
    return NO_ERROR ;
}

//
// Invalidates a cache entry so it will not be used.
//
VOID BindCacheInvalidateEntry(ADS_LDP *pCacheEntry)
{
    pCacheEntry->Flags |= LDP_CACHE_INVALID ;
}


//
// !!!WARNING!!! Make sure you hold the bindcache critsect
// when calling this function.
//
VOID CommonRemoveEntry(ADS_LDP *pCacheEntry, LIST_ENTRY *DeleteReferralList)
{

    for (DWORD i=0; i < pCacheEntry->nReferralEntries; i++) {

        if (BindCacheDerefHelper( pCacheEntry->ReferralEntries[i], DeleteReferralList) == 0 ) {
            InsertTailList( DeleteReferralList, &(pCacheEntry->ReferralEntries[i])->ReferralList );           
        }
    }


    //
    // Cleanup the entry
    //
    //

    --BindCacheCount ;

    (void) FreeADsMem(pCacheEntry->Server) ;
    pCacheEntry->Server = NULL ;

    delete pCacheEntry->pCredentials;
    pCacheEntry->pCredentials = NULL;

    if (pCacheEntry->ReferralEntries) {
        FreeADsMem(pCacheEntry->ReferralEntries);
    }
    
    RemoveEntryList(&pCacheEntry->List) ;    

    return;
}

#if 0
VOID BindCacheCleanTimedOutEntries()
{
    DWORD dwCurrTick = 0;
    DWORD dwLastTick = 0;
    BOOL fRemoved = FALSE;
    ADS_LDP *ldRemove = NULL;

    ENTER_BIND_CRITSECT();

    PADS_LDP pEntry = (PADS_LDP) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     servername & LUID matches, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        //
        // See if this one is keepAround entry that is old
        //
        if (pEntry->RefCount == 0) {

            ADsAssert(pEntry->fKeepAround);

            //
            // GetCurrent tick and see if we need to del the entry
            //
            dwCurrTick = GetTickCount();
            dwLastTick = pEntry->dwLastUsed;

            if ((dwLastTick == 0)
                || ((dwLastTick <= dwCurrTick)
                    && ((dwCurrTick - dwLastTick) > RETIRE_HANDLE))
                || ((dwLastTick > dwCurrTick)
                    && ((dwCurrTick + (((DWORD)(-1)) - dwLastTick))
                                                    > RETIRE_HANDLE)))
                {

                //
                // Entry needs to be removed.
                //
                CommonRemoveEntry(pEntry);
                fRemoved = TRUE;
            }
        } // refCount == 0

        if (fRemoved) {
            LdapUnbind(pEntry);
            ldRemove = pEntry;
        }

        pEntry = (PADS_LDP)pEntry->List.Flink ;

        if (ldRemove) {
            FreeADsMem(ldRemove);
            ldRemove = NULL;
        }
    }

    LEAVE_BIND_CRITSECT();
    return;
}
#endif

//
// Lookup an entry in the cache. Does not take into account timeouts.
// Increments ref count if found.
//
PADS_LDP
BindCacheLookup(
    LPWSTR Address,
    LUID Luid,
    LUID ModifiedId,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    DWORD i ;
    BOOLEAN fLUIDMatch;    

    ENTER_BIND_CRITSECT() ;

    PADS_LDP pEntry = (PADS_LDP) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     servername & LUID matches, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        if ((pEntry->Server != NULL) &&
            !(pEntry->Flags & LDP_CACHE_INVALID) &&
            (_wcsicmp(pEntry->Server, Address) == 0) &&
            pEntry->PortNumber == dwPort) {
            

            //
            // If either credential (the cached one or the user-supplied
            // one) is default, we must test to make sure thread token
            // is identical before re-using
            //

            fLUIDMatch = FALSE;

            if (!AreCredentialsExplicit(pEntry->pCredentials) ||
                !AreCredentialsExplicit(&Credentials)) {

                if ((memcmp(&Luid,&(pEntry->Luid),sizeof(Luid))==0) &&
                    ((memcmp(&ModifiedId, &(pEntry->ModifiedId), sizeof(Luid)) == 0) ||
                     (memcmp(&ModifiedId, &ReservedLuid, sizeof(Luid)) == 0))) {
                
                    // tokens match
                    fLUIDMatch = TRUE;
                }
            }
            else {
                // both are explicit credentials --> skip the test
                fLUIDMatch = TRUE;
            }

            if (fLUIDMatch) {

                if ((*(pEntry->pCredentials) == Credentials) ||
                    CanCredentialsBeReused(pEntry->pCredentials, &Credentials))
                {
                    ++pEntry->RefCount ;

                    LEAVE_BIND_CRITSECT() ;
                    return(pEntry) ;
                }

            }
        }

        pEntry = (PADS_LDP)pEntry->List.Flink ;
    }

    LEAVE_BIND_CRITSECT() ;
    //
    // Before we leave clean out stale entries
    //
    //BindCacheCleanTimedOutEntries();

    return NULL ;
}


//
// Checks if credentials are explicit (both username and password
// are non-NULL)
//
BOOL
AreCredentialsExplicit(
    CCredentials *pCredentials
    )
{
    PWSTR pszUser = NULL;
    PWSTR pszPwd = NULL;
    HRESULT hr;
    BOOL rc = FALSE;

    hr = pCredentials->GetUserName(&pszUser);
    BAIL_ON_FAILURE(hr);

    hr = pCredentials->GetPassword(&pszPwd);
    BAIL_ON_FAILURE(hr);

    if (pszPwd && (pszPwd[0] != L'\0') && pszUser && (pszUser[0] != L'\0')) {
        rc = TRUE;
    }

error:

    if (pszUser)
    {
        FreeADsStr(pszUser);
    }

    if (pszPwd)
    {
        SecureZeroMemory(pszPwd, wcslen(pszPwd)*sizeof(WCHAR));
        FreeADsStr(pszPwd);
    }

    return rc;
}


//
// Check if credentials can be reused. They can be reused if username and
// non-ignored auth flags match and incoming credentials thesame password.  
// Ignored auth flags are those defined by
// BIND_CACHE_IGNORED_FLAGS as not to be used in considering whether to
// reuse a connection.
//

BOOL
CanCredentialsBeReused(
    CCredentials *pCachedCreds,
    CCredentials *pIncomingCreds
    )
{
    PWSTR pszIncomingUser = NULL;
    PWSTR pszIncomingPwd = NULL;
    PWSTR pszCachedUser = NULL;
    PWSTR pszCachedPwd = NULL;
    HRESULT hr;
    BOOL rc = FALSE;

    //
    // Test that the non-ignored auth flags match.
    // We need to be smart and reuse the credentials based on the flags.
    //
    if ( (~BIND_CACHE_IGNORED_FLAGS & pCachedCreds->GetAuthFlags()) != 
         (~BIND_CACHE_IGNORED_FLAGS & pIncomingCreds->GetAuthFlags()))
    {
        return FALSE;
    }


    //
    // Get the user names
    //
    hr = pCachedCreds->GetUserName(&pszCachedUser);
    BAIL_ON_FAILURE(hr);

    hr = pIncomingCreds->GetUserName(&pszIncomingUser);
    BAIL_ON_FAILURE(hr);

    
    //
    // Get the password
    //
    hr = pIncomingCreds->GetPassword(&pszIncomingPwd);
    BAIL_ON_FAILURE(hr);

    hr = pCachedCreds->GetPassword(&pszCachedPwd);
    BAIL_ON_FAILURE(hr);
    
    //
    // Only when both username and password match, will we reuse the connection handle
    //

    if (((pszCachedUser && pszIncomingUser &&
        wcscmp(pszCachedUser, pszIncomingUser) == 0) ||
        (!pszCachedUser && !pszIncomingUser)) 
        &&
        ((pszCachedPwd && pszIncomingPwd &&
    	wcscmp(pszCachedPwd, pszIncomingPwd) == 0) ||
    	(!pszCachedPwd && !pszIncomingPwd)))
    {
        rc = TRUE;
    }     
    
error:
    if (pszCachedUser)
    {
        FreeADsStr(pszCachedUser);
    }
    if (pszIncomingUser)
    {
        FreeADsStr(pszIncomingUser);
    }
    if (pszCachedPwd)
    {
        SecureZeroMemory(pszCachedPwd, wcslen(pszCachedPwd)*sizeof(WCHAR));
        FreeADsStr(pszCachedPwd);
    }
    if (pszIncomingPwd)
    {
        SecureZeroMemory(pszIncomingPwd, wcslen(pszIncomingPwd)*sizeof(WCHAR));
        FreeADsStr(pszIncomingPwd);
    }

    return rc;
}

//
// Lookup an entry in the cache based on the Ldap Handle
// DOES NOT Increment ref count
//
PADS_LDP
GetCacheEntry(PLDAP pLdap)
{

    ENTER_BIND_CRITSECT() ;


    PADS_LDP pEntry = (PADS_LDP) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     servername & LUID matches, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        if (pEntry->LdapHandle == pLdap) {

            LEAVE_BIND_CRITSECT() ;
            return(pEntry) ;
        }

        pEntry = (PADS_LDP)pEntry->List.Flink ;
    }

    LEAVE_BIND_CRITSECT() ;
    return NULL ;
}



//
// Add entry to cache
//
DWORD
BindCacheAdd(
    LPWSTR Address,
    LUID Luid,
    LUID ModifiedId,
    CCredentials& Credentials,
    DWORD dwPort,
    PADS_LDP pCacheEntry)
{

    ENTER_BIND_CRITSECT() ;



    if (BindCacheCount > MAX_BIND_CACHE_SIZE) {

        //
        // If exceed limit, just dont put in cache. Since we leave the
        // RefCount & the Links unset, the deref will simply note that
        // this entry is not in cache and allow it to be freed.
        //
        // We limit cache so that if someone leaks handles we dont over
        // time end up traversing this huge linked list.
        //
        LEAVE_BIND_CRITSECT() ;
        return(NO_ERROR) ;
    }

    LPWSTR pServer = (LPWSTR) AllocADsMem(
                                   (wcslen(Address)+1)*sizeof(WCHAR)) ;

    if (!pServer) {

        LEAVE_BIND_CRITSECT() ;
        return(GetLastError()) ;
    }

    CCredentials * pCredentials = new CCredentials(Credentials);

    if (!pCredentials) {

        FreeADsMem(pServer);

        LEAVE_BIND_CRITSECT();
        return(GetLastError());
    }



    //
    // setup the data
    //
    wcscpy(pServer,Address) ;



    pCacheEntry->pCredentials = pCredentials;
    pCacheEntry->PortNumber       = dwPort;
    pCacheEntry->Server    = pServer ;
    pCacheEntry->RefCount  = 1 ;
    pCacheEntry->Luid      = Luid ;
    pCacheEntry->ModifiedId = ModifiedId;



    //
    // insert into list
    //
    InsertHeadList(&BindCache.List, &pCacheEntry->List) ;
    ++BindCacheCount ;
    LEAVE_BIND_CRITSECT() ;

    return NO_ERROR ;
}

//
// Bump up the reference count of the particular cache entry
// Returns the final ref count or zero if not there.
//
BOOL BindCacheAddRef(ADS_LDP *pCacheEntry)
{

    DWORD dwCount = 0;

    ENTER_BIND_CRITSECT() ;

    if ((pCacheEntry->List.Flink == NULL) &&
        (pCacheEntry->List.Blink == NULL) &&
        (pCacheEntry->RefCount == NULL)) {

        //
        // this is one of them entries that has no LUID.
        // ie. it never got into the cache.
        //
        LEAVE_BIND_CRITSECT() ;
        return(0) ;
    }

    ADsAssert(pCacheEntry->List.Flink) ;
    ADsAssert(pCacheEntry->RefCount > 0) ;

    pCacheEntry->RefCount++ ;

    //
    // Save info onto stack variable as we are going
    // to leave the critsect before we exit.
    //
    dwCount = pCacheEntry->RefCount;

    LEAVE_BIND_CRITSECT() ;

    return(dwCount) ;
}

//
// Adds a referral entry of pNewEntry to pPrimaryEntry. Increments the reference
// count of pPrimaryEntry if succesful.
//

BOOL
AddReferralLink(
    PADS_LDP pPrimaryEntry,
    PADS_LDP pNewEntry
    )
{
    ENTER_BIND_CRITSECT() ;

    if (!pPrimaryEntry) {
        goto error;
    }
    if (!pPrimaryEntry->ReferralEntries) {
        pPrimaryEntry->ReferralEntries = (PADS_LDP *) AllocADsMem(
                                             sizeof(PADS_LDP) * MAX_REFERRAL_ENTRIES);

        if (!pPrimaryEntry->ReferralEntries) {
            goto error;
        }
        pPrimaryEntry->nReferralEntries = 0;
    }

    if (pPrimaryEntry->nReferralEntries >= MAX_REFERRAL_ENTRIES) {
        //
        // We won't remember more than this
        //
        goto error;
    }

    pPrimaryEntry->ReferralEntries[pPrimaryEntry->nReferralEntries] = pNewEntry;

    if (!BindCacheAddRef(pNewEntry)) {
        goto error;
    }

    pPrimaryEntry->nReferralEntries++;
    LEAVE_BIND_CRITSECT() ;
    return TRUE;

error:
    LEAVE_BIND_CRITSECT();
    return FALSE;

}

DWORD BindCacheDeref(ADS_LDP *pCacheEntry)
{

   DWORD dwCount = 0; 
   LIST_ENTRY DeleteReferralList;
   PLIST_ENTRY pEntry;
   PADS_LDP EntryInfo;

   InitializeListHead(&DeleteReferralList);

      
   dwCount = BindCacheDerefHelper(pCacheEntry, &DeleteReferralList);

  
    // Delete the cached entries
    //

    while (!IsListEmpty (&DeleteReferralList))  {

        pEntry = RemoveHeadList (&DeleteReferralList);
        EntryInfo = CONTAINING_RECORD (pEntry, ADS_LDP, ReferralList);


        LdapUnbind(EntryInfo);

        FreeADsMem(EntryInfo);
        
    }

    return dwCount;
        
}

//
// Dereference an entry in the cache. Removes if ref count is zero.
// Returns the final ref count or zero if not there. If zero, caller
// should close the handle.
//
DWORD BindCacheDerefHelper(ADS_LDP *pCacheEntry, LIST_ENTRY * DeleteReferralList)
{

    DWORD dwCount=0;
    
    ENTER_BIND_CRITSECT() ;

    if ((pCacheEntry->List.Flink == NULL) &&
        (pCacheEntry->List.Blink == NULL) &&
        (pCacheEntry->RefCount == NULL)) {

        //
        // this is one of them entries that has no LUID.
        // ie. it never got into the cache.
        //
        LEAVE_BIND_CRITSECT() ;
        return(0) ;
    }

    ADsAssert(pCacheEntry->List.Flink) ;
    ADsAssert(pCacheEntry->RefCount > 0) ;

    //
    // Dereference by one. If result is non zero, just return.
    //
    --pCacheEntry->RefCount ;

    if (pCacheEntry->RefCount) {

        //
        // Use a stack variable for this value as
        // we call return outside the critsect.
        //
        dwCount = pCacheEntry->RefCount;

        LEAVE_BIND_CRITSECT() ;

        return(dwCount);
    }

    //
    // Before clearing the entry away verify that
    // we do not need to KeepAround this one.
    //
    if (pCacheEntry->fKeepAround) {
        //
        // Set the timer on this entry and leave.
        //
        pCacheEntry->dwLastUsed = GetTickCount();
        LEAVE_BIND_CRITSECT() ;

    }
    else {

        //
        // Now that this entry is going away, deref all the referred entries.
        //
        CommonRemoveEntry(pCacheEntry, DeleteReferralList);
        LEAVE_BIND_CRITSECT() ;

               

    }

    
    //
    // Look for any other entries that need to be cleaned out
    //
    //BindCacheCleanTimedOutEntries();

    return 0 ;
}


VOID
BindCacheInit(
    VOID
    )
{    
    InitializeListHead(&BindCache.List) ;
}

VOID
BindCacheCleanup(
    VOID
    )
{
    PADS_LDP pEntry = (PADS_LDP) BindCache.List.Flink ;

    while (pEntry != &BindCache) {

        PADS_LDP pNext = (PADS_LDP) pEntry->List.Flink;

        (void) FreeADsMem(pEntry->Server) ;

        pEntry->Server = NULL ;

        if (pEntry->ReferralEntries) {
            FreeADsMem(pEntry->ReferralEntries);
        }

        RemoveEntryList(&pEntry->List) ;

        pEntry = pNext;
    }
   
}

//
// Mark handle so that we keep it even after the object count
// has hit zero and remove only after a x mins of zero count.
//
HRESULT
LdapcKeepHandleAround(ADS_LDP *ld)
{

    ADsAssert(ld);

    ld->fKeepAround = TRUE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\ldapsch.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  ldapsch.cxx
//
//  Contents:  LDAP Schema Parser
//
//  History:
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

#define ADSI_LDAP_KEY    TEXT("SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP")
#define SCHEMA_DIR_NAME  TEXT("SchCache\\")
#define SCHEMA_FILE_NAME_EXT TEXT(".sch")
#define DEFAULT_SCHEMA_FILE_NAME TEXT("Default")
#define DEFAULT_SCHEMA_FILE_NAME_WITH_EXT TEXT("Default.sch")
#define SCHEMA_FILE_NAME TEXT("File")
#define SCHEMA_TIME      TEXT("Time")
#define SCHEMA_PROCESSAUX    TEXT("ProcessAUX")


#define MAX_LOOP_COUNT  30  // Maximum depth of schema class tree
#define ENTER_SCHEMA_CRITSECT()  EnterCriticalSection(&g_SchemaCritSect)
#define LEAVE_SCHEMA_CRITSECT()  LeaveCriticalSection(&g_SchemaCritSect)

#define ENTER_SUBSCHEMA_CRITSECT()  EnterCriticalSection(&g_SubSchemaCritSect)
#define LEAVE_SUBSCHEMA_CRITSECT()  LeaveCriticalSection(&g_SubSchemaCritSect)

#define ENTER_DEFAULTSCHEMA_CRITSECT()  EnterCriticalSection(&g_DefaultSchemaCritSect)
#define LEAVE_DEFAULTSCHEMA_CRITSECT()  LeaveCriticalSection(&g_DefaultSchemaCritSect)



#define ID_ATTRTYPES       1
#define ID_OBJCLASSES      2
#define ID_DITCONTENTRULES 3

#ifdef WIN95
int ConvertToAscii( WCHAR *pszUnicode, char **pszAscii );
#endif

//
// Constants used to determine what elements of string array to free.
//
const int FREE_ALL = 0;
const int FREE_ARRAY_NOT_ELEMENTS = 1;
const int FREE_ALL_BUT_FIRST = 2;



//
// RFC 2252
//
KWDLIST g_aSchemaKeywordList[] =
{
    { TOKEN_NAME,        TEXT("NAME") },
    { TOKEN_DESC,        TEXT("DESC") },
    { TOKEN_OBSOLETE,    TEXT("OBSOLETE") },
    { TOKEN_SUP,         TEXT("SUP") },
    { TOKEN_EQUALITY,    TEXT("EQUALITY") },
    { TOKEN_ORDERING,    TEXT("ORDERING") },
    { TOKEN_SUBSTR,      TEXT("SUBSTR") },
    { TOKEN_SYNTAX,      TEXT("SYNTAX") },
    { TOKEN_SINGLE_VALUE, TEXT("SINGLE-VALUE") },
    { TOKEN_COLLECTIVE,  TEXT("COLLECTIVE") },
    { TOKEN_DYNAMIC,     TEXT("DYNAMIC") },
    { TOKEN_NO_USER_MODIFICATION, TEXT("NO-USER-MODIFICATION") },
    { TOKEN_USAGE,       TEXT("USAGE") },
    { TOKEN_ABSTRACT,    TEXT("ABSTRACT") },
    { TOKEN_STRUCTURAL,  TEXT("STRUCTURAL") },
    { TOKEN_AUXILIARY,   TEXT("AUXILIARY") },
    { TOKEN_MUST,        TEXT("MUST") },
    { TOKEN_MAY,         TEXT("MAY") },
    { TOKEN_AUX,         TEXT("AUX") },
    { TOKEN_NOT,         TEXT("NOT") }
    // FORM
};

DWORD g_dwSchemaKeywordListSize = sizeof(g_aSchemaKeywordList)/sizeof(KWDLIST);

CRITICAL_SECTION  g_SchemaCritSect;
CRITICAL_SECTION  g_DefaultSchemaCritSect;
CRITICAL_SECTION  g_SubSchemaCritSect;
SCHEMAINFO *g_pSchemaInfoList = NULL;  // Link list of cached schema info
SCHEMAINFO *g_pDefaultSchemaInfo = NULL;

//
// Non-AD sd control.
//
#define ADSI_LDAP_OID_SECDESC_OLD L"1.2.840.113556.1.4.416"

typedef struct _subschemalist {
   LPWSTR pszLDAPServer;
   LPWSTR pszSubSchemaEntry;
   BOOL fPagingSupported;
   BOOL fSortingSupported;
   BOOL fDomScopeSupported;
   BOOL fTalkingToAD;
   BOOL fTalkingToEnhancedAD;
   BOOL fVLVSupported;
   BOOL fAttribScopedSupported;
   struct _subschemalist *pNext;
   BOOL fNoDataGot;
   DWORD dwSecDescType;
} SCHEMALIST, *PSCHEMALIST;

//
// The fNoDataReturned will be set for v2 servers that do not
// have a subSchemaSubEntry, this will prevent hitting the server
// multiple times for the same data.
//

typedef SCHEMALIST ROOTDSENODE, *PROOTDSENODE;

PSCHEMALIST gpSubSchemaList = NULL;

static DWORD dwSubSchemaSubEntryCount = 0;

HRESULT
GetSchemaInfoTime(
    LPTSTR  pszServer,
    LPTSTR  pszSubSchemaSubEntry,
    LPTSTR  *ppszTimeReg,
    LPTSTR  *ppszTimeDS,
    CCredentials& Credentials,
    DWORD dwPort
);

HRESULT
LdapReadSchemaInfoFromServer(
    LPTSTR pszLDAPPath,
    LPTSTR pszSubSchemaSubEntry,
    LPTSTR  pszTimeReg,
    LPTSTR  pszTimeDS,
    SCHEMAINFO **ppSchemaInfo,
    CCredentials& Credentials,
    DWORD dwPort
);

HRESULT
ReadRootDSENode(
    LPWSTR pszLDAPServer,
    PROOTDSENODE pRootDSENode,
    OUT BOOL * pfBoundOk,           // optional, can be NULL
    CCredentials& Credentials,
    DWORD dwPort
    );

HRESULT
LdapReadDefaultSchema(
    LPTSTR  pszServer,
    CCredentials &Credentials,
    SCHEMAINFO **ppSchemaInfo
);

HRESULT FillPropertyInfoArray(
    LPTSTR *aAttrTypes,
    DWORD  dwCount,
    PROPERTYINFO **paProperties,
    DWORD *pnProperties,
    SEARCHENTRY **paSearchTable
);

HRESULT FillClassInfoArray(
    LPTSTR *aObjectClasses,
    DWORD  dwCount,
    SEARCHENTRY *aPropSearchTable,
    DWORD  dwSearchTableCount,
    CLASSINFO **paClasses,
    DWORD *pnClasses,
    SEARCHENTRY **paSearchTable
);

HRESULT FillAuxClassInfoArray(
    LPTSTR *aDITContentRules,
    DWORD  dwCount,
    SEARCHENTRY *aPropSearchTable,
    DWORD  dwSearchTableCount,
    CLASSINFO *aClasses,
    DWORD nClasses,
    SEARCHENTRY *aSearchTable
);

HRESULT ProcessClassInfoArray(
    CLASSINFO *aClasses,
    DWORD nClasses,
    SEARCHENTRY *paSearchTable,
    BOOL fProcessAUX = FALSE
);

HRESULT ProcessPropertyInfoArray(
    PROPERTYINFO *aProperties,
    DWORD nProperties,
    SEARCHENTRY **paSearchTable
);

DWORD ReadSchemaInfoFromRegistry(
    HKEY hKey,
    LPWSTR pszServer,
    LPTSTR **paValuesAttribTypes,
    int *pnCountAttribTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pBuffer
);

DWORD StoreSchemaInfoInRegistry(
    HKEY hKey,
    LPTSTR pszServer,
    LPTSTR pszTime,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules,
    BOOL fProcessAUX
);

HRESULT
AttributeTypeDescription(
    LPTSTR pszAttrType,
    PPROPERTYINFO pPropertyInfo,
    LPWSTR **pppszNames,
    PDWORD pdwNameCount
);

HRESULT
ObjectClassDescription(
    LPTSTR pszDescription,
    PCLASSINFO pClassInfo,
    SEARCHENTRY *aPropSearchTable,
    DWORD dwSearchTableCount,
    LPWSTR **pppszNames,
    PDWORD pdwNameCount
);

HRESULT DITContentRuleDescription(
    LPTSTR pszObjectClass,
    PCLASSINFO pClassInfo,
    SEARCHENTRY *aPropSearchTable,
    DWORD dwSearchTableCount
);

//
// Helper routine that adds new elements to the property info array.
//
HRESULT AddNewNamesToPropertyArray(
    PROPERTYINFO **ppPropArray,
    DWORD dwCurPos,
    DWORD dwCount,
    LPWSTR *ppszNewNames,
    DWORD dwNewNameCount
    );

//
// Helper routine that adds new elements to the class info array.
//
HRESULT AddNewNamesToClassArray(
    CLASSINFO **ppClassArray,
    DWORD dwCurPos,
    DWORD dwCount,
    LPWSTR *ppszNewNames,
    DWORD dwNewNameCount
    );

//
// The 3rd param was added to work around bad schema data.
//
HRESULT Oid(
    CSchemaLexer * pTokenizer,
    LPTSTR *ppszOID,
    BOOL fNoGuid = FALSE
);

HRESULT Oids(
    CSchemaLexer * pTokenizer,
    LPTSTR **pOIDs,
    DWORD *pnNumOfOIDs
);

HRESULT PropOids(
    CSchemaLexer * pTokenizer,
    int **pOIDs,
    DWORD *pnNumOfOIDs,
    SEARCHENTRY *aPropSearchTable,
    DWORD dwSearchTableCount
);

HRESULT DirectoryString(
    CSchemaLexer * pTokenizer,
    LPTSTR *ppszDirString
);

//
// Returns *pdwCount strings in ppszDirStrings.
//
HRESULT DirectoryStrings(
    CSchemaLexer * pTokenizer,
    LPTSTR **pppszDirStrings,
    PDWORD pdwCount
    );

void FreeDirectoryStrings(
    LPTSTR *ppszDirStrings,
    DWORD dwCount,
    DWORD dwElementsToFree= FREE_ALL
    );                

VOID SortAndRemoveDuplicateOIDs(
    int *pOIDs,
    DWORD *pnNumOfOIDs
);

int _cdecl searchentrycmp(
    const void *s1,
    const void *s2
);

long CompareUTCTime(
    LPTSTR pszTime1,
    LPTSTR pszTime2
);

BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    );

BOOL
EquivalentUsers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    );

DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

//
// Makes a copy of a string array that has NULL as the last element.
// If the copy failed because of lack of memory NULL is returned.
//
LPTSTR *
CopyStringArray(
    LPTSTR * ppszStr
    ) 
{
    LPTSTR * ppszRetVal = NULL;
    DWORD dwCount = 0;

    if (!ppszStr) {
        BAIL_ON_FAILURE(E_FAIL);
    }
       
    //
    // Get the count first.
    //
    while (ppszStr && ppszStr[dwCount]) {
        dwCount++;
    }

    //
    // Alloc memory for the array, + 1, is for the NULL string that
    // acts as the delimiter for the array.
    //
    ppszRetVal = (LPTSTR *) AllocADsMem((dwCount+1) * sizeof(LPTSTR));

    if (!ppszRetVal) {
        BAIL_ON_FAILURE(E_OUTOFMEMORY);
    }

    for (DWORD dwCtr = 0; dwCtr <= dwCount; dwCtr++) {
        if (ppszStr[dwCtr]) {
            ppszRetVal[dwCtr] = AllocADsStr(ppszStr[dwCtr]);
            
            if (!ppszRetVal[dwCtr]) {
                BAIL_ON_FAILURE(E_OUTOFMEMORY);
            }
        }
    }

    return ppszRetVal;

error:

   if (ppszRetVal) {
       for (DWORD i = 0; i < dwCtr; i++) {
           if (ppszRetVal[i]) {
               FreeADsStr(ppszRetVal[i]);
           }
       }
       FreeADsMem(ppszRetVal);
       ppszRetVal = NULL;
   }

   //
   // Null from this routine means there was a failure.
   //
   return NULL;
}


VOID
SchemaCleanup(
    VOID
)
{
    SCHEMAINFO *pList = g_pSchemaInfoList;

    while ( pList )
    {
        SCHEMAINFO *pNext = pList->Next;

        delete pList;
        pList = pNext;
    }

    delete g_pDefaultSchemaInfo;


    //
    // Delete the schema list containing the server infos
    //

    PSCHEMALIST pSubSchemaList = gpSubSchemaList;

    while ( pSubSchemaList )
    {
        PSCHEMALIST pNext = pSubSchemaList->pNext;

        if ( pSubSchemaList->pszLDAPServer )
            FreeADsStr( pSubSchemaList->pszLDAPServer );

        if ( pSubSchemaList->pszSubSchemaEntry )
            FreeADsStr( pSubSchemaList->pszSubSchemaEntry );

        FreeADsMem( pSubSchemaList );

        pSubSchemaList = pNext;
    }
    
}


HRESULT
LdapGetSchema(
    LPTSTR pszLDAPServer,
    SCHEMAINFO **ppSchemaInfo,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    LPTSTR pszTemp = NULL;

    SCHEMAINFO *pList = NULL;
    SCHEMAINFO *pPrev = NULL;

    LPTSTR pszTimeReg = NULL;
    LPTSTR pszTimeDS = NULL;
    BOOL fNotCurrent = FALSE;
    WCHAR szDomainDnsName[MAX_PATH];

    *ppSchemaInfo = NULL;

    DWORD nCount =0;

    LPWSTR pszSubSchemaEntry = NULL;

    BOOL fBoundOk = FALSE;    // has once bound to domain okay?
    BOOL fReuseSchema = FALSE;
    BOOL fTalktoAD = FALSE;


    //
    // In the case of a serverless path, we want to substitute the name
    // of the domain for the serverName. This is because we can get more
    // than one file called default.sch if a person logs on from different
    // forests on to the same domain.
    //
    if (!pszLDAPServer) {
        WCHAR szServerName[MAX_PATH];
        DWORD dwErr;
        
        dwErr = GetDefaultServer(
                    dwPort,
                    FALSE, // do not force verify
                    szDomainDnsName,
                    szServerName,
                    !(Credentials.GetAuthFlags() & ADS_READONLY_SERVER)
                        ? TRUE : FALSE
                    );
        if (dwErr == NO_ERROR) {
            //
            // Use the domainName returned.
            //
            pszLDAPServer = szDomainDnsName;
        }
    }

    //
    // Check if the server uses default schema and return the schema info
    //

    hr = Credentials.GetUserName(&pszTemp);
    BAIL_IF_ERROR(hr);


    ENTER_SCHEMA_CRITSECT();

    pList = g_pSchemaInfoList;
    pPrev = NULL;

    
    while ( pList )
    {
        //
        // Checking for Schemas can now use NULL and NULL
        //

        //
        // If the server is equivalent, and we've cached it as using
        // a default (V2) schema, then we want to immediately return
        // that cached schema, UNLESS (1) the server in question 
        // appeared to be a V3 server when we tried to retrieve the schema
        // (i.e., it had a rootDSE with a subschemasubentry), AND (2)
        // we're currently using different user credentials then when
        // we cached the server schema.  This is because we might be going
        // against a V3 server that has security restrictions on its schema.
        // If we previously tried to read the schema, but didn't have
        // sufficient access permissions to do so, we would have defaulted
        // to treating it as a v2 schema.  Now, if we're using different
        // credentials, we try again, in case we now have sufficient
        // access permissions to read the schema.
        //
        if (EquivalentServers(pList->pszServerName, pszLDAPServer)) {
        
            if ( pList->fDefaultSchema &&
                 !(pList->fAppearsV3 &&
                   !EquivalentUsers(pszTemp, pList->pszUserName)
                  )
               )
            {
                    *ppSchemaInfo = pList;
                    (*ppSchemaInfo)->AddRef();

                    LEAVE_SCHEMA_CRITSECT();
                    goto cleanup;
            }
            else if (pList->fDefaultSchema &&
                     pList->fAppearsV3 &&
                     !EquivalentUsers(pszTemp, pList->pszUserName))
            {
                //
                // Dump the cached schema in preparation for reading
                // it again.
                //
                if ( pList->IsRefCountZero())
                {                
                    if ( pPrev == NULL )
                        g_pSchemaInfoList = pList->Next;
                    else
                        pPrev->Next = pList->Next;

                    delete pList;
                    break;
                }   
            }
        }
        
        pPrev = pList;
        pList = pList->Next;
    }

    LEAVE_SCHEMA_CRITSECT();

    //
    // Read the schema path from the root of the DS
    //

    hr = ReadSubSchemaSubEntry(
                 pszLDAPServer,
                 &pszSubSchemaEntry,
                 &fBoundOk,
                 Credentials,
                 dwPort
                 ) ;

    if ( SUCCEEDED(hr))     // pszSubSchemaEntry!=NULL if hr = S_OK. Checked.
    {

        ENTER_SCHEMA_CRITSECT();

        pPrev = NULL;
        pList = g_pSchemaInfoList;
        while ( pList )
        {
            
            hr = ReadServerSupportsIsADControl(pszLDAPServer, &fTalktoAD, Credentials, dwPort);
            if (FAILED(hr)) {
                //
                // Assume it is not AD and continue, there is no
                // good reason for this to fail on AD.
                //
                fTalktoAD = FALSE;
            }

            if(fTalktoAD) {
            	// we talking to the server with AD, so then we don't have to compare the servername
            	fReuseSchema =  EquivalentServers(pList->pszSubSchemaSubEntry, pszSubSchemaEntry );
            }
            else
            {
                // otherwise, we need to compare the server name
                fReuseSchema = EquivalentServers(pList->pszServerName, pszLDAPServer) &&
            	               EquivalentServers(pList->pszSubSchemaSubEntry, pszSubSchemaEntry );
            }
            	
            if ( fReuseSchema )
            {
                if ( pList->IsObsolete())
                {
                    hr = GetSchemaInfoTime(
                             pszLDAPServer,
                             pszSubSchemaEntry,
                             &pszTimeReg,
                             &pszTimeDS,
                             Credentials,
                             dwPort );

                    if ( FAILED(hr))
                    {
                        // Cannot get the time, assume the cache is not
                        // current and read again.

                        fNotCurrent = TRUE;
                        break;
                    }
                    else
                    {
                        //
                        // If the servers are not the same, then we should
                        // not comparet the times. This is because
                        // each server has a ModifyTimeStamp that is not
                        // based on its update time not that of the domain.
                        // Note that at this point we know that the
                        // subSchemaSubEntry is the same.
                        //
                        if (!EquivalentServers(
                                 pList->pszServerName,
                                 pszLDAPServer
                                 )
                            ) {
                            fNotCurrent = TRUE;
                            break;
                        }
                        // Compare the time to see if we need to read
                        // the schema info from the file or from the DS

                        if ( CompareUTCTime( pList->pszTime, pszTimeReg ) >= 0 )
                        {
                            if ( CompareUTCTime( pszTimeReg, pszTimeDS ) < 0 )
                            {
                                fNotCurrent = TRUE;
                                break;
                            }
                        }
                        else
                        {
                            // The schema in memory is not as current as the
                            // the one stored in the registry, hence, we
                            // need to read it anyway.
                            fNotCurrent = TRUE;
                            break;
                        }
                    }

                    pList->MakeCurrent();
                }

                *ppSchemaInfo = pList;
                (*ppSchemaInfo)->AddRef();

                LEAVE_SCHEMA_CRITSECT();
                goto cleanup;
            }

            pPrev = pList;
            pList = pList->Next;
        }

        if ( fNotCurrent && pList != NULL )
        {
            if ( pList->IsRefCountZero())
            {
                SCHEMAINFO *pDelete = pList;

                if ( pPrev == NULL )
                    g_pSchemaInfoList = pDelete->Next;
                else
                    pPrev->Next = pDelete->Next;

                delete pDelete;
            }

            pList = NULL;
        }

        LEAVE_SCHEMA_CRITSECT();

        // pList should be NULL at this point

        hr = LdapReadSchemaInfoFromServer(
                 pszLDAPServer,
                 pszSubSchemaEntry,  // SubSchemaSubEntry
                 pszTimeReg,
                 pszTimeDS,
                 ppSchemaInfo,
                 Credentials,
                 dwPort
                 );

        if (SUCCEEDED(hr)) {

            ENTER_SCHEMA_CRITSECT();

            (*ppSchemaInfo)->Next = g_pSchemaInfoList;
            g_pSchemaInfoList = *ppSchemaInfo;
            (*ppSchemaInfo)->AddRef();

            LEAVE_SCHEMA_CRITSECT();
        }
        else {

            //
            // There was some problem in reading from the DS. If it was
            // because of some error like the attributes were not
            // obtained or were not of the proper form, we will fall
            // back to the default schema
            //
            hr = LdapReadDefaultSchema(pszLDAPServer, Credentials, ppSchemaInfo);
            BAIL_IF_ERROR(hr);

            //
            // We leave fAppearsV3 == TRUE because this server has a
            // subschemasubentry --- it's just that we can't read the
            // schema (e.g., maybe we don't have permission)
            //

            ENTER_SCHEMA_CRITSECT();

            (*ppSchemaInfo)->Next = g_pSchemaInfoList;
            g_pSchemaInfoList = *ppSchemaInfo;
            (*ppSchemaInfo)->AddRef();

            LEAVE_SCHEMA_CRITSECT();
        }

    } // end of if read of subSchemaSubEntry succeeded 
    else if ( fBoundOk )
    {
        //
        // If we cannot get subschemasubentry, use default schema if
        // fBoundOk; that is, we have at least
        // once bound to the domain successfully before.
        //

        hr = LdapReadDefaultSchema( pszLDAPServer, Credentials, ppSchemaInfo );
        BAIL_IF_ERROR(hr);

        (*ppSchemaInfo)->fAppearsV3 = FALSE;

        ENTER_SCHEMA_CRITSECT();

        (*ppSchemaInfo)->Next = g_pSchemaInfoList;
        g_pSchemaInfoList = *ppSchemaInfo;
        (*ppSchemaInfo)->AddRef();

        LEAVE_SCHEMA_CRITSECT();
    }

    else
    {

        //
        // we cannot read subschemasubentry, but we are not using
        // default schema since we have no indication that the
        // we had ever bound to the domain before
        //

        if ( SUCCEEDED(hr)) // i.e. we could not read the schema
        {
            hr = E_ADS_BAD_PATHNAME;
        }

        BAIL_IF_ERROR(hr);
    }

cleanup:

    if (pszSubSchemaEntry) {
        FreeADsStr(pszSubSchemaEntry);
        }

    if ( pszTimeReg )
        FreeADsMem( pszTimeReg );

    if ( pszTimeDS )
        FreeADsMem( pszTimeDS );

    if ( pszTemp )
        FreeADsStr( pszTemp );

    RRETURN(hr);
}

HRESULT
LdapRemoveSchemaInfoOnServer(
    LPTSTR pszLDAPPath,
    CCredentials& Credentials,
    DWORD dwPort,
    BOOL fForce
    )
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pList = NULL;
    LPWSTR pszSubSchemaSubEntry = NULL;
    BOOL fBoundOk = FALSE;

    //
    // Read the subschemaSubEntry only once.
    //
    hr = ReadSubSchemaSubEntry(
             pszLDAPPath,
             &pszSubSchemaSubEntry,
             &fBoundOk,
             Credentials,
             dwPort
             ) ;
    //
    // If we cannot read the subSchemaSubEntry it is not a
    // V3 server and we cannot refresh.
    //
    BAIL_ON_FAILURE(hr);

    ENTER_SCHEMA_CRITSECT();

    pList = g_pSchemaInfoList;
    while ( pList )
    {
        //
        // Both NULL and NULL and also check for the servers
        //

        if (!pList->pszServerName  && !pszLDAPPath) {

            pList->MakeObsolete();

            if (fForce) {
                //
                // Will reset time to something ancient so we
                // will always pick up the schema from server.
                //
                LPWSTR pszTempTime = NULL;

                if(pList->pszTime)
                {
                    pszTempTime = AllocADsStr(L"19800719000000.0Z");

                    if (pszTempTime) {
                        FreeADsStr(pList->pszTime);
                        pList->pszTime = pszTempTime;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    
                }
                
            }

        } else {

            //
            // The match at this point has to be made based on the
            // subschemaSubEntry and not on the server names.
            //


            if (EquivalentServers(
                    pList->pszSubSchemaSubEntry,
                    pszSubSchemaSubEntry
                    )
                )
            {
                pList->MakeObsolete();

                if (fForce) {
                    //
                    // Will reset time to something ancient so we
                    // will always pick up the schema from server.
                    //
                    LPWSTR pszTempTime = NULL;

                    if(pList->pszTime)
                    {
                        pszTempTime = AllocADsStr(L"19800719000000.0Z");

                        if (pszTempTime) {
                            FreeADsStr(pList->pszTime);
                            pList->pszTime = pszTempTime;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }                    

                }

            }
        } // the server name is not NULL
        pList = pList->Next;
    }

    LEAVE_SCHEMA_CRITSECT();

error :

    if (pszSubSchemaSubEntry) {
        FreeADsStr(pszSubSchemaSubEntry);
    }

    RRETURN(hr);
}

HRESULT
GetSchemaInfoTime(
    LPTSTR  pszLDAPServer,
    LPTSTR  pszSubSchemaSubEntry,
    LPTSTR  *ppszTimeReg,
    LPTSTR  *ppszTimeDS,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    DWORD   dwStatus = NO_ERROR;
    LPTSTR pszLDAPPath = NULL;
    LPTSTR pszRegPath = NULL;

    LPTSTR *aValues = NULL;
    int nCount = 0;

    TCHAR szTimeReg[64];
    HKEY hKey = NULL;
    DWORD dwLength;
    DWORD dwType;

    //
    // Read the schema timestamp on the DS server
    //

    hr = LdapReadAttribute2(
                   pszLDAPServer,
                   NULL,
                   pszSubSchemaSubEntry,
                   TEXT("modifyTimeStamp"),
                   &aValues,
                   &nCount,
                   Credentials,
                   dwPort,
                   L"(objectClass=subschema)"
                   );
    if (nCount==0) {

        //
        // cannot get to time stamp or get to a time stamp with no values:
        // both treat as E_FAIL
        //

        hr = E_FAIL;
    }

    BAIL_IF_ERROR(hr);

    ADsAssert( nCount == 1 );

    *ppszTimeDS = AllocADsStr( aValues[0] );
    LdapValueFree( aValues );

    if ( *ppszTimeDS == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    //
    // See if we can find the schema info in the registry
    //

    pszRegPath = (LPTSTR) AllocADsMem( (_tcslen(ADSI_LDAP_KEY) +
                                        _tcslen(pszSubSchemaSubEntry) +
                                        2 ) * sizeof(TCHAR));  // includes "\\"

    if ( pszRegPath == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    _tcscpy( pszRegPath, ADSI_LDAP_KEY );
    _tcscat( pszRegPath, TEXT("\\"));
    _tcscat( pszRegPath, pszSubSchemaSubEntry );

    dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             pszRegPath,
                             0,
                             KEY_READ,
                             &hKey
                             );

    if ( dwStatus != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_IF_ERROR(hr);
    }

    //
    //  Read the time stamp of the schema in registry.
    //

    dwLength = sizeof(szTimeReg);

    dwStatus = RegQueryValueEx( hKey,
                                SCHEMA_TIME,
                                NULL,
                                &dwType,
                                (LPBYTE) szTimeReg,
                                &dwLength );

    if ( dwStatus )
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_IF_ERROR(hr);
    }
    else
    {
        *ppszTimeReg = AllocADsStr( szTimeReg );

        if ( *ppszTimeReg == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

cleanup:

    if ( hKey )
        RegCloseKey( hKey );

    if ( pszLDAPPath != NULL )
        FreeADsStr( pszLDAPPath );

    if ( pszRegPath != NULL )
        FreeADsStr( pszRegPath );

    if ( FAILED(hr))
    {
        if ( *ppszTimeDS )
        {
            FreeADsMem( *ppszTimeDS );
            *ppszTimeDS = NULL;
        }

        if ( *ppszTimeReg )
        {
            FreeADsMem( *ppszTimeReg );
            *ppszTimeReg = NULL;
        }
    }

    RRETURN(hr);
}

HRESULT
LdapReadSchemaInfoFromServer(
    LPTSTR  pszLDAPServer,
    LPTSTR  pszSubSchemaSubEntry,
    LPTSTR  pszTimeReg,
    LPTSTR  pszTimeDS,
    SCHEMAINFO **ppSchemaInfo,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR;
    LPTSTR pszRegPath = NULL;
    SCHEMAINFO *pSchemaInfo = NULL;

    LPTSTR *aValues = NULL;
    int nCount = 0;
    TCHAR szTimeReg[64];


    LPWSTR aStrings[4] = { L"attributeTypes",
                           L"objectClasses",
                           L"ditContentRules",
                           NULL
                         };

    LPWSTR szNTFilter = L"objectClass=*";
    LPWSTR szGenericFilter = L"objectClass=subSchema";
    BOOL fNTDS = FALSE;
    DWORD dwSecDescType = 0;

    LPTSTR *aValuesAttribTypes = NULL;
    int nCountAttribTypes = 0;
    LPTSTR *aValuesObjClasses = NULL;
    int nCountObjClasses = 0;
    LPTSTR *aValuesRules = NULL;
    int nCountRules = 0;
    LPBYTE Buffer = NULL;

    HKEY hKeySchema = NULL;
    HKEY hKey = NULL;
    DWORD dwDisposition;
    BOOL fReadFromDS = TRUE;
    BOOL fProcessAUX = FALSE;
    DWORD dwRegPathLen = 0;

    *ppSchemaInfo = NULL;

    DWORD dwRegAUXType = REG_DWORD;
    DWORD dwRegProcessAUX = 0;
    DWORD dwRegLength = sizeof(dwRegProcessAUX);

    //
    // Allocate an entry for the schema info that we are going to read
    //

#if DBG

    static BOOL fSchemaRead = FALSE;
    static BOOL fGoSchemaLess = FALSE;
    WCHAR pszRegPathDbg[MAX_PATH];
    DWORD dwType = 0;
    DWORD dwRetVal = 0;
    DWORD dwLength = 0;

    if (!fSchemaRead) {

        _tcscpy( pszRegPathDbg, ADSI_LDAP_KEY );
        _tcscat( pszRegPathDbg, TEXT("\\"));
        _tcscat( pszRegPathDbg, TEXT("DBGSchema"));
        //DebugDisabled
        // If DBG, try and read the schema key and return
        // value if that is set to 1.
        dwStatus = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       pszRegPathDbg,
                       0,
                       KEY_READ,
                       &hKeySchema
                       );

        if (dwStatus != NO_ERROR) {
            // Do not want to keep coming back to this.
            fSchemaRead = TRUE;
        } else {

            dwLength = sizeof(DWORD);
            // Read the value of the DWORD DebugDisabled
            dwStatus = RegQueryValueEx(
                           hKeySchema,
                           L"DebugDisabled",
                           0,
                           &dwType,
                           (LPBYTE) &dwRetVal,
                           &dwLength
                           );

            if (dwStatus != NO_ERROR) {
                fSchemaRead = TRUE;
            } else {
                // Look at the value and proceed
                if (dwRetVal == 0) {
                    fGoSchemaLess = TRUE;
                    hr = E_FAIL;
                }

            } // else - we were able to read the DebugDisabled key
        } // else - we were able to open the key
    } // if fSchemaRead

    if ( hKeySchema )
        RegCloseKey( hKeySchema );

    // hr will be set only if we have schema disabled.
    // Note that hr is initialised to S_OK so default case
    // will fall through
    BAIL_IF_ERROR(hr);

#endif

    pSchemaInfo = new SCHEMAINFO;
    if ( pSchemaInfo == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }
    memset(pSchemaInfo, 0, sizeof(SCHEMAINFO));

    //
    // Store the server name
    //


    if (pszLDAPServer) {
        pSchemaInfo->pszServerName = AllocADsStr( pszLDAPServer );
        if ( pSchemaInfo->pszServerName == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

    //
    // Store the name of the user under whose credentials
    // we're reading the schema
    //
    hr = Credentials.GetUserName(&(pSchemaInfo->pszUserName));
    BAIL_IF_ERROR(hr);


    //
    // Store the subSchemaSubEntry path
    //

    pSchemaInfo->pszSubSchemaSubEntry = AllocADsStr( pszSubSchemaSubEntry );
    if ( pSchemaInfo->pszSubSchemaSubEntry == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    //
    // Try and see if this is NTDS or not to optimize schema calls.
    // This is very likely to be satisfied from our cache as we would
    // have already read the RootDSE at this point.
    //
    hr = ReadSecurityDescriptorControlType(
             pszLDAPServer,
             &dwSecDescType,
             Credentials,
             dwPort
             );

    if (SUCCEEDED(hr) && (dwSecDescType == ADSI_LDAPC_SECDESC_NT))
            fNTDS = TRUE;

    if ( pszTimeDS == NULL )
    {

        hr = LdapReadAttribute2(
                       pszLDAPServer,
                       NULL,
                       pszSubSchemaSubEntry,
                       TEXT("modifyTimeStamp"),
                       &aValues,
                       &nCount,
                       Credentials,
                       dwPort,
                       fNTDS ? szNTFilter : szGenericFilter
                       );

        if (FAILED(hr) || nCount==0)
        {
            //
            // cannot read modifyTimeStamp or modifyTimeStamp has no values:
            // - treat as same
            //

            hr = S_OK;
        }
        else
        {
            ADsAssert( nCount == 1 );

            pSchemaInfo->pszTime = AllocADsStr( aValues[0] );
            LdapValueFree( aValues );

            if ( pSchemaInfo->pszTime == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_IF_ERROR(hr);
            }
        }
    }
    else
    {
        pSchemaInfo->pszTime = AllocADsStr( pszTimeDS );

        if ( pSchemaInfo->pszTime == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

    //
    // See if we can find the schema info in the registry
    //
    dwRegPathLen = _tcslen(ADSI_LDAP_KEY)
                  + _tcslen(pszSubSchemaSubEntry)
                  + (pszLDAPServer ? _tcslen(pszLDAPServer) : 0)
                  + 3; // includes "\\" and . for serverName
    
    pszRegPath = (LPTSTR) AllocADsMem( dwRegPathLen * sizeof(TCHAR));  

    if ( pszRegPath == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    _tcscpy( pszRegPath, ADSI_LDAP_KEY );
    _tcscat( pszRegPath, TEXT("\\"));
    _tcscat( pszRegPath, pszSubSchemaSubEntry );
    
    //
    // If the server is not NTDS, and it has the subSchemaSubEntry cn=Schema,
    // to avoid schema key conflicts, we will add .ServerName to the key.
    //
    if (!fNTDS
        && pszSubSchemaSubEntry
        && pszLDAPServer // should alwasy be true 
        && !_tcsicmp(pszSubSchemaSubEntry, TEXT("cn=Schema"))
        ) {
        _tcscat( pszRegPath, TEXT("."));
        _tcscat( pszRegPath, pszLDAPServer);
    }

    dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               pszRegPath,
                               0,
                               TEXT(""),
                               REG_OPTION_NON_VOLATILE,  // or volatile
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &hKey,
                               &dwDisposition
                               );

    if (dwStatus == NO_ERROR) {

       if (  ( dwDisposition == REG_OPENED_EXISTING_KEY )
          && ( pSchemaInfo->pszTime != NULL )
          && ( pszTimeReg == NULL )
          )
       {
           //
           //  Read the time stamp of the schema in cache and the time stamp
           //  of the schema on the server. If the time stamp on the server is
           //  newer, then we need to read the info from the server. Else
           //  the info in the cache is current and hence don't need to read
           //  it again.
           //

           DWORD dwLength = sizeof(szTimeReg);
           DWORD dwType;


           dwStatus = RegQueryValueEx( hKey,
                                       SCHEMA_TIME,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) szTimeReg,
                                       &dwLength );

           if ( dwStatus )
           {
               dwStatus = NO_ERROR;
           }
           else
           {
               // Compare the two time
               if ( CompareUTCTime( szTimeReg, pSchemaInfo->pszTime ) >= 0 )
                   fReadFromDS = FALSE;
           }
       }
       else if ( ( pSchemaInfo->pszTime != NULL ) && ( pszTimeReg != NULL ))
       {
           if ( CompareUTCTime( pszTimeReg, pSchemaInfo->pszTime ) >= 0 )
               fReadFromDS = FALSE;
       }

    }else {

       fReadFromDS = TRUE;

    }

    
    if ( !fReadFromDS )
    {
        //
        // Read from registry, if we failed to read from the registry,
        // then read it from the DS.
        //

        //
        // We can av while reading bad info from a file
        // or while processing it
        //
        __try {

            dwStatus = ReadSchemaInfoFromRegistry(
                           hKey,
                           pszLDAPServer,
                           &aValuesAttribTypes,
                           &nCountAttribTypes,
                           &aValuesObjClasses,
                           &nCountObjClasses,
                           &aValuesRules,
                           &nCountRules,
                           &Buffer                                                   
                           );

            if ( dwStatus == NO_ERROR)
            {            
                //
                // At this stage we need to try and process the info
                // we got from the file. There is always a chance that
                // the read was successful but the schema data is bad
                //

                //
                // First we need to read from the registry to find whether we need to process
                // AUX class or not.
                //

                dwStatus = RegQueryValueExW( hKey,
                                       SCHEMA_PROCESSAUX,
                                       NULL,
                                       &dwRegAUXType,
                                       (LPBYTE) &dwRegProcessAUX,
                                       &dwRegLength);   
                
                if(ERROR_SUCCESS == dwStatus) {

                    fProcessAUX = (BOOL) dwRegProcessAUX;
                	                	
                    hr = ProcessSchemaInfo(
                             pSchemaInfo,
                             aValuesAttribTypes,
                             nCountAttribTypes,
                             aValuesObjClasses,
                             nCountObjClasses,
                             aValuesRules,
                             nCountRules,
                             fProcessAUX
                             );
                }
                
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

              dwStatus = GetExceptionCode();

              if (dwStatus != EXCEPTION_ACCESS_VIOLATION) {
                  ADsDebugOut((DEB_ERROR, "Processing Schema Info:Unknown Exception %d\n", dwStatus));
              }

              hr = E_FAIL;

        } // end of exception handler


        if (FAILED(hr) || dwStatus) {
            //
            // We can read the schema from the ds and upgrade our
            // local copy to get rid of the bad file
            //
            fReadFromDS = TRUE;

            //
            // Need to cleanup here so that we wont leak mem.
            //
            if ( aValuesAttribTypes ){
                FreeADsMem( aValuesAttribTypes );
                aValuesAttribTypes = NULL;
            }

            if ( aValuesObjClasses ) {
                FreeADsMem( aValuesObjClasses );
                aValuesObjClasses = NULL;
            }

            if ( aValuesRules ) {
                FreeADsMem( aValuesRules );
                aValuesRules = NULL;
            }

            if ( Buffer ) {
                FreeADsMem( Buffer );
                Buffer = NULL;
            }

            hr = E_FAIL;
            fReadFromDS = TRUE;
        }


    } // if !fReadFromDS

    if ( fReadFromDS )
    {          

        //
        // At this point, the info in the DS is newer or we have failed
        // to read the info from the registry, hence we need to read
        // from the DS and then store it in the registry.
        //

        //
        // As per the LDAP spec if the server does not know about
        // an attribute then it will ignore the attribute. So it should
        // be ok to ask for the ditContentRules even though the server
        // may not know about them.
        //
        hr = HelperReadLDAPSchemaInfo(
                 pszLDAPServer,
                 pszSubSchemaSubEntry,
                 aStrings,
                 fNTDS ? szNTFilter : szGenericFilter,
                 &aValuesAttribTypes,
                 &aValuesObjClasses,
                 &aValuesRules,
                 &nCountAttribTypes,
                 &nCountObjClasses,
                 &nCountRules,
                 Credentials,
                 dwPort);

        BAIL_IF_ERROR(hr);

        if (nCountAttribTypes == 0 || nCountObjClasses == 0) {
            BAIL_IF_ERROR(hr = E_FAIL);
        }
        

        //
        // We need to know if we need to process the aux classes
        // or not at this stage. If the server is enhanced AD (build 2220+),
        // we should not. Also if it is anything other than AD on Win2k we should
        // not as we will end up interpreting the schema incorrectly.
        // 
        BOOL fLaterThanAD, fAD;
        hr = ReadServerSupportsIsEnhancedAD(
                 pszLDAPServer,
                 &fLaterThanAD,
                 &fAD,
                 Credentials,
                 dwPort
                 );
        if (FAILED(hr)) {
            //
            // We will not process the aux classes.
            //
            fProcessAUX = FALSE;
        }

        if (fLaterThanAD) {
            fProcessAUX = FALSE;
        } 
        else if (!fLaterThanAD && fAD) {
            fProcessAUX = TRUE;
        }


        //
        // This is not expected to AV as this is info from the
        // server that is why it is not in a try except block
        //
        hr = ProcessSchemaInfo(
                 pSchemaInfo,
                 aValuesAttribTypes,
                 nCountAttribTypes,
                 aValuesObjClasses,
                 nCountObjClasses,
                 aValuesRules,
                 nCountRules,
                 fProcessAUX
                 );

        BAIL_IF_ERROR(hr);

    } // if fReadFromDS

    //
    // Store all the info in the registry only if the time stamp
    // is present and we have read just read it from the server.
    // Ignore the error since if we failed to store it, we can
    // still read it from the DS.
    //

    if ( fReadFromDS && pSchemaInfo->pszTime )
    {
        StoreSchemaInfoInRegistry( hKey,
                                   pszLDAPServer,
                                   pSchemaInfo->pszTime,
                                   aValuesAttribTypes,
                                   nCountAttribTypes,
                                   aValuesObjClasses,
                                   nCountObjClasses,
                                   aValuesRules,
                                   nCountRules,
                                   fProcessAUX);
    }

    *ppSchemaInfo = pSchemaInfo;

cleanup:

   if ( fReadFromDS )
    {
        if ( aValuesAttribTypes )
            LdapValueFree( aValuesAttribTypes );

        if ( aValuesObjClasses )
            LdapValueFree( aValuesObjClasses );

        if ( aValuesRules )
            LdapValueFree( aValuesRules );

    }
    else
    {
        if ( aValuesAttribTypes )
            FreeADsMem( aValuesAttribTypes );

        if ( aValuesObjClasses )
            FreeADsMem( aValuesObjClasses );

        if ( aValuesRules )
            FreeADsMem( aValuesRules );

        if ( Buffer )
            FreeADsMem( Buffer );
    }

    if ( hKey )
        RegCloseKey( hKey );

    if ( pszRegPath != NULL )
        FreeADsStr( pszRegPath );

    if ( FAILED(hr) && pSchemaInfo )
        delete pSchemaInfo;

    RRETURN(hr);
}


HRESULT
ProcessSchemaInfo(
    SCHEMAINFO *pSchemaInfo,
    LPTSTR *aValuesAttribTypes,
    DWORD  dwAttribCount,
    LPTSTR *aValuesObjClasses,
    DWORD  dwObjClassesCount,
    LPTSTR *aValuesRules,
    DWORD  dwRulesCount,
    BOOL fProcessAUX
)
{
    HRESULT hr = S_OK;

    hr = FillPropertyInfoArray(
             aValuesAttribTypes,
             dwAttribCount,
             &(pSchemaInfo->aProperties),
             &(pSchemaInfo->nNumOfProperties),
             &(pSchemaInfo->aPropertiesSearchTable)
             );

    BAIL_IF_ERROR(hr);

    hr = FillClassInfoArray(
             aValuesObjClasses,
             dwObjClassesCount,
             pSchemaInfo->aPropertiesSearchTable,
             pSchemaInfo->nNumOfProperties * 2,
             &(pSchemaInfo->aClasses),
             &(pSchemaInfo->nNumOfClasses),
             &(pSchemaInfo->aClassesSearchTable)
             );
    BAIL_IF_ERROR(hr);
    
    if ( aValuesRules )
    {
        hr = FillAuxClassInfoArray(
                 aValuesRules,
                 dwRulesCount,
                 pSchemaInfo->aPropertiesSearchTable,
                 pSchemaInfo->nNumOfProperties * 2,
                 pSchemaInfo->aClasses,
                 pSchemaInfo->nNumOfClasses,
                 pSchemaInfo->aClassesSearchTable
                 );
        BAIL_IF_ERROR(hr);
    }

    //
    // fProcssAUX tells us if we need to add the list of must
    // contain on each of the classes in the AUX list to the appopriate
    // classes list. Say :
    // 1.2.3.4 NAME 'OrganizationalUnit' AUX ($Class1 $CLASS2) MUST (List)
    // May (List). Then if the flag is true, we will add the Must and May
    // of class1 and class2 to the must and may of class OrganizationalUnit
    // (the must and may list is always processed - they are lists
    // of attributes).
    //
    hr = ProcessClassInfoArray(
             pSchemaInfo->aClasses,
             pSchemaInfo->nNumOfClasses,
             pSchemaInfo->aClassesSearchTable,
             fProcessAUX
             );
    BAIL_IF_ERROR(hr);

cleanup :
    //
    // Nothing to do for now
    //
    RRETURN(hr);

}


//
// Helper to read the schema information from subSchemaSubEntry
//
HRESULT
HelperReadLDAPSchemaInfo(
    LPWSTR pszLDAPServer,
    LPWSTR pszSubSchemaSubEntry,
    LPWSTR szAttributes[],
    LPWSTR pszFilter,
    LPTSTR **aValuesAttribTypes,
    LPTSTR **aValuesObjClasses,
    LPTSTR **aValuesRules,
    int *nCountAttributes,
    int *nCountObjClasses,
    int *nCountRules,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ADS_LDP *ld = NULL;
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;

    hr = LdapOpenObject2(
             pszLDAPServer,
             NULL,
             pszSubSchemaSubEntry,
             &ld,
             Credentials,
             dwPort
             );

    BAIL_ON_FAILURE(hr);

    ADsAssert(ld && ld->LdapHandle);

    hr = LdapSearchS(
             ld,
             pszSubSchemaSubEntry,
             LDAP_SCOPE_BASE,
             pszFilter,
             szAttributes,
             0,
             &res
             );

    BAIL_ON_FAILURE(hr);

    BAIL_ON_FAILURE((hr = LdapFirstEntry(ld, res, &e)));

    hr = LdapGetValues(
             ld,
             e,
             szAttributes[0],
             aValuesAttribTypes,
             nCountAttributes
             );
    BAIL_ON_FAILURE(hr);

    hr = LdapGetValues(
             ld,
             e,
             szAttributes[1],
             aValuesObjClasses,
             nCountObjClasses
             );

    BAIL_ON_FAILURE(hr);

    hr = LdapGetValues(
             ld,
             e,
             szAttributes[2],
             aValuesRules,
             nCountRules
             );

    if (FAILED(hr)) {
        //
        // This is non critical
        //
        *aValuesRules = NULL;
        nCountRules = 0;
        hr = S_OK;
    }

error:

    if (res) {
        LdapMsgFree(res);
    }

    if (ld) {
        LdapCloseObject(ld);
    }

    RRETURN(hr);
}

HRESULT
LdapReadDefaultSchema(
    LPTSTR  pszServer,
    CCredentials &Credentials,
    SCHEMAINFO **ppSchemaInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    *ppSchemaInfo = NULL;

    ENTER_DEFAULTSCHEMA_CRITSECT();

    if ( g_pDefaultSchemaInfo == NULL )
    {
        g_pDefaultSchemaInfo = new SCHEMAINFO;
        if ( g_pDefaultSchemaInfo == NULL )
        {
            LEAVE_DEFAULTSCHEMA_CRITSECT();
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        hr = FillPropertyInfoArray( g_aDefaultAttributeTypes,
                                    g_cDefaultAttributeTypes,
                                    &(g_pDefaultSchemaInfo->aProperties),
                                    &(g_pDefaultSchemaInfo->nNumOfProperties),
                                    &(g_pDefaultSchemaInfo->aPropertiesSearchTable));

        //
        // Now read the object classes from the schema
        //

        if ( SUCCEEDED(hr))
        {

            hr = FillClassInfoArray( g_aDefaultObjectClasses,
                                     g_cDefaultObjectClasses,
                                     g_pDefaultSchemaInfo->aPropertiesSearchTable,
                                     g_pDefaultSchemaInfo->nNumOfProperties * 2,
                                     &(g_pDefaultSchemaInfo->aClasses),
                                     &(g_pDefaultSchemaInfo->nNumOfClasses),
                                     &(g_pDefaultSchemaInfo->aClassesSearchTable));

            if ( SUCCEEDED(hr))
            {
                hr = ProcessClassInfoArray( g_pDefaultSchemaInfo->aClasses,
                                            g_pDefaultSchemaInfo->nNumOfClasses,
                                            g_pDefaultSchemaInfo->aClassesSearchTable );
            }
        }

        if (FAILED(hr))
        {
            delete g_pDefaultSchemaInfo;
            g_pDefaultSchemaInfo = NULL;
            LEAVE_DEFAULTSCHEMA_CRITSECT();
        }        

        BAIL_IF_ERROR(hr);
    }

    LEAVE_DEFAULTSCHEMA_CRITSECT();

    //
    // Allocate an entry for the schema info
    //

    pSchemaInfo = new SCHEMAINFO;
    if ( pSchemaInfo == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    //
    // Store the server name
    //

    if (pszServer) {

        pSchemaInfo->pszServerName = AllocADsStr( pszServer );
        if ( pSchemaInfo->pszServerName == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

    }

    //
    // Store the name of the user under whose credentials
    // we're reading the schema
    //
    hr = Credentials.GetUserName(&(pSchemaInfo->pszUserName));
    BAIL_IF_ERROR(hr);


    pSchemaInfo->aClasses = g_pDefaultSchemaInfo->aClasses;
    pSchemaInfo->nNumOfClasses = g_pDefaultSchemaInfo->nNumOfClasses;
    pSchemaInfo->aClassesSearchTable = g_pDefaultSchemaInfo->aClassesSearchTable;
    pSchemaInfo->aProperties = g_pDefaultSchemaInfo->aProperties;
    pSchemaInfo->nNumOfProperties = g_pDefaultSchemaInfo->nNumOfProperties;
    pSchemaInfo->aPropertiesSearchTable = g_pDefaultSchemaInfo->aPropertiesSearchTable;
    pSchemaInfo->fDefaultSchema = TRUE;

    *ppSchemaInfo = pSchemaInfo;

cleanup:

    if ( FAILED(hr) && pSchemaInfo )
        delete pSchemaInfo;

    RRETURN(hr);
}

HRESULT FillPropertyInfoArray(
    LPTSTR *aAttrTypes,
    DWORD  dwCount,
    PROPERTYINFO **paProperties,
    DWORD *pnProperties,
    SEARCHENTRY **paPropertiesSearchTable
)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    PROPERTYINFO * pPropArray = NULL;
    PROPERTYINFO * pNewPropArray = NULL;
    LPWSTR *ppszNewNames = NULL;
    DWORD dwNewNameCount = 0;
    DWORD dwDisplacement = 0;
    BOOL fFreeNames = TRUE;

    *paProperties = NULL;
    *pnProperties = 0;
    *paPropertiesSearchTable = NULL;

    if ( dwCount == 0 )
        RRETURN(S_OK);

    pPropArray = (PROPERTYINFO *)AllocADsMem( sizeof(PROPERTYINFO) * dwCount);
    if (!pPropArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < dwCount; i++) {

        fFreeNames = FREE_ALL_BUT_FIRST;
        dwNewNameCount = 0;

        pPropArray[i].dwUsage = ATTR_USAGE_USERAPPLICATIONS;
        
        hr = AttributeTypeDescription(
                 aAttrTypes[i],
                 pPropArray + (i+dwDisplacement),
                 &ppszNewNames,
                 &dwNewNameCount
                 );

        BAIL_ON_FAILURE(hr);

        if (ppszNewNames) {

            if (dwNewNameCount > 1) {
                hr = AddNewNamesToPropertyArray(
                         &pPropArray,
                         i + dwDisplacement, // current position in array
                         dwCount + dwDisplacement, // total number already in array
                         ppszNewNames, // array of names.
                         dwNewNameCount // number of names
                         );

                //
                // In the failure case, we can still continue, just
                // that the additional names will not be recognized.
                //
                if (SUCCEEDED(hr)) {
                    //
                    // In this case the new array has the data needed.
                    // The count is updated suitably only on success.
                    // 
                    fFreeNames = FALSE;
                    dwDisplacement += (dwNewNameCount - 1);
                }
            }
            
            FreeDirectoryStrings(
                ppszNewNames,
                dwNewNameCount,
                fFreeNames ?
                    FREE_ALL_BUT_FIRST : FREE_ARRAY_NOT_ELEMENTS
                );
            
            ppszNewNames = NULL; // freed in the above call.

        }
    }

    //
    // Reduce i by one in case we fail and call FreePropertyInfoArray below.
    //
    i--;
    dwCount += dwDisplacement;
    hr = ProcessPropertyInfoArray(pPropArray, dwCount, paPropertiesSearchTable);
    BAIL_ON_FAILURE(hr);

    *paProperties = pPropArray;
    *pnProperties = dwCount;

    RRETURN(S_OK);

error:

    FreePropertyInfoArray( pPropArray, i + 1);

    //
    // Need to free the new names list if it is valid.
    //
    if (ppszNewNames) {
        //
        // This function frees pszNames too.
        //
        FreeDirectoryStrings(
            ppszNewNames,
            dwNewNameCount,
            FREE_ALL_BUT_FIRST // do not free first element
            );
    }

    RRETURN(hr);
}

HRESULT
GetInfoFromSuperiorProperty(
    PROPERTYINFO *pPropertyInfo,
    PROPERTYINFO *pPropertyInfoSuperior
)
{
    HRESULT hr = S_OK;

    if ( pPropertyInfo->pszSyntax == NULL )
    {
        pPropertyInfo->pszSyntax =
            AllocADsStr( pPropertyInfoSuperior->pszSyntax );

        if ( pPropertyInfo->pszSyntax == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

#if 0
    if (  pPropertyInfo->lMaxRange == 0
       && pPropertyInfo->lMinRange == 0
       )
    {
        pPropertyInfo->lMaxRange = pPropertyInfoSuperior->lMaxRange;
        pPropertyInfo->lMinRange = pPropertyInfoSuperior->lMinRange;
    }
#endif

    if (  pPropertyInfoSuperior->fSingleValued
       && !pPropertyInfo->fSingleValued
       )
    {
        pPropertyInfo->fSingleValued = pPropertyInfoSuperior->fSingleValued;
    }

    if (  pPropertyInfo->pszOIDEquality == NULL
       && pPropertyInfoSuperior->pszOIDEquality != NULL
       )
    {
        pPropertyInfo->pszOIDEquality =
            AllocADsStr( pPropertyInfoSuperior->pszOIDEquality );

        if ( pPropertyInfo->pszOIDEquality == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

    if (  pPropertyInfo->pszOIDOrdering == NULL
       && pPropertyInfoSuperior->pszOIDOrdering != NULL
       )
    {
        pPropertyInfo->pszOIDOrdering =
            AllocADsStr( pPropertyInfoSuperior->pszOIDOrdering );

        if ( pPropertyInfo->pszOIDOrdering == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

    if (  pPropertyInfo->pszOIDSubstr == NULL
       && pPropertyInfoSuperior->pszOIDSubstr != NULL
       )
    {
        pPropertyInfo->pszOIDSubstr =
            AllocADsStr( pPropertyInfoSuperior->pszOIDSubstr );

        if ( pPropertyInfo->pszOIDSubstr == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

cleanup:

    RRETURN(hr);

}

HRESULT ProcessPropertyInfoArray(
    PROPERTYINFO *aProperties,
    DWORD nProperties,
    SEARCHENTRY **paPropertiesSearchTable
)
{
    HRESULT hr = S_OK;
    SEARCHENTRY *aSearchTable = NULL;
    SEARCHENTRY searchEntry;
    SEARCHENTRY *matchedEntry;
    DWORD i;
    BOOL  fProcessedAll = TRUE;
    DWORD nLoop = 0;

    *paPropertiesSearchTable = NULL;

    //
    // First, build a binary search table for faster lookup
    //

    aSearchTable = (SEARCHENTRY *) AllocADsMem(
                        sizeof(SEARCHENTRY) * nProperties * 2);

    if (!aSearchTable) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < nProperties; i++ )
    {
        // OIDs can be specified in 2.5.6.0 format or name.
        // So, we need both entries in the search table.

        //
        // Special case to handle no names or OID's
        //
        if (aProperties[i].pszPropertyName == NULL) {
            aProperties[i].pszPropertyName = AllocADsStr(aProperties[i].pszOID);
        }

        if (aProperties[i].pszOID == NULL) {
            aProperties[i].pszOID = AllocADsStr(aProperties[i].pszPropertyName);
        }

        if(!aProperties[i].pszPropertyName || !aProperties[i].pszOID)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        aSearchTable[2*i].pszName = aProperties[i].pszPropertyName;
        aSearchTable[2*i].nIndex = i;
        aSearchTable[2*i+1].pszName = aProperties[i].pszOID;
        aSearchTable[2*i+1].nIndex = i;
    }

    //
    // Sort the table
    //
    qsort( aSearchTable, 2*nProperties, sizeof(SEARCHENTRY), searchentrycmp );


    do {

        fProcessedAll = TRUE;

        for ( DWORD i = 0; i < nProperties; i++ )
        {
            LPTSTR pszOIDSup = NULL;

            if ( aProperties[i].fProcessedSuperiorClass )
                continue;

            pszOIDSup = aProperties[i].pszOIDSup;

            if ( pszOIDSup == NULL )
            {
                aProperties[i].fProcessedSuperiorClass = TRUE;
                continue;
            }

            searchEntry.pszName = pszOIDSup;
            matchedEntry = (SEARCHENTRY *) bsearch(
                                (SEARCHENTRY *) &searchEntry,
                                aSearchTable, 2*nProperties,
                                sizeof(SEARCHENTRY), searchentrycmp );

            if ( matchedEntry )  // found the superior class
            {
                if (!aProperties[matchedEntry->nIndex].fProcessedSuperiorClass)
                {
                    fProcessedAll = FALSE;
                    continue;
                }

                hr = GetInfoFromSuperiorProperty(
                         &(aProperties[i]), &(aProperties[matchedEntry->nIndex]));
                BAIL_ON_FAILURE(hr);
            }

            aProperties[i].fProcessedSuperiorClass = TRUE;
        }

        nLoop++;

    } while ( (nLoop < MAX_LOOP_COUNT) && !fProcessedAll );

    *paPropertiesSearchTable = aSearchTable;
    RRETURN(S_OK);

error:

    if ( aSearchTable )
        FreeADsMem( aSearchTable );

    RRETURN(hr);
}

VOID FreePropertyInfoArray(
    PROPERTYINFO *aProperties,
    DWORD  nProperties
)
{
    if ( aProperties )
    {
        DWORD j;

        for ( j = 0; j < nProperties; j++ )
        {
            FreeADsStr( aProperties[j].pszPropertyName );
            FreeADsStr( aProperties[j].pszOID );
            FreeADsStr( aProperties[j].pszSyntax );
            FreeADsStr( aProperties[j].pszDescription );
            FreeADsStr( aProperties[j].pszOIDSup );
            FreeADsStr( aProperties[j].pszOIDEquality );
            FreeADsStr( aProperties[j].pszOIDOrdering );
            FreeADsStr( aProperties[j].pszOIDSubstr );
        }

        FreeADsMem( aProperties );
    }
}

HRESULT FillClassInfoArray(
    LPTSTR *aObjectClasses,
    DWORD  dwCount,
    SEARCHENTRY *aPropSearchTable,
    DWORD  dwSearchTableCount,
    CLASSINFO **paClasses,
    DWORD *pnClasses,
    SEARCHENTRY **paClassesSearchTable
)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    CLASSINFO * pClassArray = NULL;
    SEARCHENTRY *aSearchTable = NULL;
    LPWSTR *ppszNewNames = NULL;
    DWORD dwNewNameCount = 0;
    DWORD dwDisplacement = 0;
    BOOL fFreeNames = FALSE;

    *paClasses= NULL;
    *pnClasses= 0;
    *paClassesSearchTable = NULL;

    if ( dwCount == 0 )
        RRETURN(S_OK);

    pClassArray = (CLASSINFO *)AllocADsMem( sizeof(CLASSINFO) * dwCount );
    if (!pClassArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < dwCount; i++) {

        ppszNewNames = NULL;
        dwNewNameCount = 0;
        fFreeNames = TRUE;

        pClassArray[i].IsContainer = -1;
        pClassArray[i].dwType = CLASS_TYPE_STRUCTURAL;
        
        hr = ObjectClassDescription(
                 aObjectClasses[i],
                 pClassArray + (i + dwDisplacement),
                 aPropSearchTable,
                 dwSearchTableCount,
                 &ppszNewNames,
                 &dwNewNameCount
                 );

        BAIL_ON_FAILURE(hr);

        if (ppszNewNames) {

            if (dwNewNameCount > 1) {
                //
                // ********************** IMPORTANT NOTE ************
                // In this routine, we specifically do not duplicate
                // the pCLSID and pPrimaryInterfaceGUID as these are not
                // freed when we exit and do not appear to be used anywehre.
                // If ObjectClasDescription is changed to add this info,
                // then the fn below needs to be update accordingly.
                // **************************************************
                //
                hr = AddNewNamesToClassArray(
                        &pClassArray,
                        i + dwDisplacement, // current position in array
                        dwCount + dwDisplacement, // total number already in array
                        ppszNewNames, // array of names.
                        dwNewNameCount // number of names
                        );

                //
                // In the failure case, we can still continue, just
                // that the additional names will not be recognized.
                //
                if (SUCCEEDED(hr)) {
                    //
                    // In this case the new array has the data needed.
                    // The count is updated suitably only on success.
                    // 
                    fFreeNames = FALSE;
                    dwDisplacement += (dwNewNameCount - 1);
                }
            }

            FreeDirectoryStrings(
                ppszNewNames,
                dwNewNameCount,
                fFreeNames ?
                    FREE_ALL_BUT_FIRST : FREE_ARRAY_NOT_ELEMENTS
                );

            ppszNewNames = NULL; // freed in the above call.

        } // if newNames is valid.

    } // for 

    //
    // Count should now include the new elements added.
    //
    dwCount += dwDisplacement;
    //
    // Build a binary search table for faster lookup
    //

    aSearchTable = (SEARCHENTRY *) AllocADsMem(
                                 sizeof(SEARCHENTRY) * dwCount * 2);

    if (!aSearchTable) {
        hr = E_OUTOFMEMORY;
        //
        // i is now dwCount but should be one less as
        // the free call is made with i+1
        //
        i--;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < dwCount; i++ )
    {

        //
        // Take care of the NULL name/OID in case of some servers
        //
        if (pClassArray[i].pszName == NULL) {
            pClassArray[i].pszName = AllocADsStr(pClassArray[i].pszOID);
        }

        if (pClassArray[i].pszOID == NULL) {
            pClassArray[i].pszOID = AllocADsStr(pClassArray[i].pszName);
        }

        if(!pClassArray[i].pszName || !pClassArray[i].pszOID)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        // OIDs can be specified in 2.5.6.0 format or name.
        // So, we need both entries in the search table.

        aSearchTable[2*i].pszName = pClassArray[i].pszName;
        aSearchTable[2*i].nIndex = i;
        aSearchTable[2*i+1].pszName = pClassArray[i].pszOID;
        aSearchTable[2*i+1].nIndex = i;
    }

    //
    // Sort the table
    //
    qsort( aSearchTable, 2*dwCount, sizeof(SEARCHENTRY), searchentrycmp );

    *paClasses = pClassArray;
    *pnClasses = dwCount;
    *paClassesSearchTable = aSearchTable;

    RRETURN(S_OK);

error:

    FreeClassInfoArray( pClassArray, i + 1 );

    if ( aSearchTable )
        FreeADsMem( aSearchTable );

    if (ppszNewNames) {
        FreeDirectoryStrings(
            ppszNewNames,
            dwNewNameCount,
            FREE_ALL_BUT_FIRST // first taken care of above.
            );
    }

    RRETURN(hr);
}

HRESULT FillAuxClassInfoArray(
    LPTSTR *aDITContentRules,
    DWORD  dwCount,
    SEARCHENTRY *aPropSearchTable,
    DWORD  dwSearchTableCount,
    CLASSINFO *aClasses,
    DWORD nClasses,
    SEARCHENTRY *aClassesSearchTable
)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    CLASSINFO ClassInfo;
    int index;

    int* pTemp = NULL;


    if ( dwCount == 0 )
        RRETURN(S_OK);

    for ( i = 0; i < dwCount; i++) {

        memset( &ClassInfo, 0, sizeof(ClassInfo));

        hr = DITContentRuleDescription( aDITContentRules[i], &ClassInfo,
                                        aPropSearchTable, dwSearchTableCount );

        BAIL_ON_FAILURE(hr);

        index = FindEntryInSearchTable( ClassInfo.pszOID,
                                        aClassesSearchTable,
                                        nClasses * 2 );

        if ( index == -1 )
            continue;  // Cannot find the class, ignore and continue


        aClasses[index].pOIDsNotContain = ClassInfo.pOIDsNotContain;
        aClasses[index].nNumOfNotContain = ClassInfo.nNumOfNotContain;

        aClasses[index].pOIDsAuxClasses = ClassInfo.pOIDsAuxClasses;

        if ( ClassInfo.pOIDsMustContain )
        {
            DWORD nMustContain = aClasses[index].nNumOfMustContain;
            
            if ( nMustContain == 0 )
            {
                aClasses[index].pOIDsMustContain = ClassInfo.pOIDsMustContain;
                aClasses[index].nNumOfMustContain = ClassInfo.nNumOfMustContain;
            }
            else
            {
                pTemp =
                     (int *) ReallocADsMem( aClasses[index].pOIDsMustContain,
                                 sizeof(int) * nMustContain,
                                 sizeof(int) * ( nMustContain +
                                             ClassInfo.nNumOfMustContain + 1));

                if ( pTemp == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                aClasses[index].pOIDsMustContain = pTemp;
                pTemp = NULL;

                memcpy( &(aClasses[index].pOIDsMustContain[nMustContain]),
                        ClassInfo.pOIDsMustContain,
                        ClassInfo.nNumOfMustContain * sizeof(int));

                aClasses[index].nNumOfMustContain += ClassInfo.nNumOfMustContain;
                //
                // Need to terminate with -1.
                //
                aClasses[index].pOIDsMustContain[nMustContain+ClassInfo.nNumOfMustContain] = -1;

                FreeADsMem( ClassInfo.pOIDsMustContain );
                ClassInfo.pOIDsMustContain = NULL;                
            }     
        }

        if ( ClassInfo.pOIDsMayContain )
        {
            DWORD nMayContain = aClasses[index].nNumOfMayContain;

            if ( nMayContain == 0 )
            {
                aClasses[index].pOIDsMayContain = ClassInfo.pOIDsMayContain;
                aClasses[index].nNumOfMayContain = ClassInfo.nNumOfMayContain;
            }
            else
            {
                pTemp =
                     (int *) ReallocADsMem( aClasses[index].pOIDsMayContain,
                                 sizeof(int) * nMayContain,
                                 sizeof(int) * ( nMayContain +
                                             ClassInfo.nNumOfMayContain + 1));

                if ( pTemp == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                aClasses[index].pOIDsMayContain = pTemp;
                pTemp = NULL;

                memcpy( &(aClasses[index].pOIDsMayContain[nMayContain]),
                        ClassInfo.pOIDsMayContain,
                        ClassInfo.nNumOfMayContain * sizeof(int));

                aClasses[index].nNumOfMayContain += ClassInfo.nNumOfMayContain;

                //
                // Need to terminate with -1.
                //
                aClasses[index].pOIDsMayContain[nMayContain+ClassInfo.nNumOfMayContain] = -1;

                FreeADsMem( ClassInfo.pOIDsMayContain );
                ClassInfo.pOIDsMayContain = NULL;
            }
            
        }

        FreeADsStr( ClassInfo.pszOID );
        ClassInfo.pszOID = NULL;

        FreeADsStr( ClassInfo.pszName );
        FreeADsStr( ClassInfo.pszDescription );
    }

    RRETURN(S_OK);

error:

    if ( ClassInfo.pszOID )
    {
        FreeADsStr( ClassInfo.pszOID );
        FreeADsStr( ClassInfo.pszName );
        FreeADsStr( ClassInfo.pszDescription );

        if ( ClassInfo.pOIDsMustContain )
        {
            FreeADsMem( ClassInfo.pOIDsMustContain );
        }

        if ( ClassInfo.pOIDsMayContain )
        {
            FreeADsMem( ClassInfo.pOIDsMayContain );
        }
    }

    RRETURN(hr);
}


HRESULT
GetInfoFromSuperiorClasses(
    CLASSINFO *pClassInfo,
    CLASSINFO *pClassInfoSuperior
)
{
    HRESULT hr = S_OK;
    DWORD i;


    int *pOIDsMustSup = pClassInfoSuperior->pOIDsMustContain;
    int *pOIDsMaySup = pClassInfoSuperior->pOIDsMayContain;
    DWORD nCountMustSup = pClassInfoSuperior->nNumOfMustContain;
    DWORD nCountMaySup = pClassInfoSuperior->nNumOfMayContain;

    int *pOIDsMust = pClassInfo->pOIDsMustContain;
    int *pOIDsMay = pClassInfo->pOIDsMayContain;
    DWORD nCountMust = pClassInfo->nNumOfMustContain;
    DWORD nCountMay = pClassInfo->nNumOfMayContain;

    int *pOIDsMustNew = NULL;
    int *pOIDsMayNew = NULL;

    if ( pOIDsMaySup == NULL && pOIDsMustSup == NULL )
        RRETURN(S_OK);

    if ( nCountMustSup > 0 )
    {
        pOIDsMustNew = (int *) AllocADsMem(
                            sizeof(int) * (nCountMust + nCountMustSup + 1));

        if ( pOIDsMustNew == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        for ( i = 0; i < nCountMustSup; i++ )
        {
            pOIDsMustNew[i] = pOIDsMustSup[i];
        }

        for ( i = 0; i < nCountMust; i++ )
        {
            pOIDsMustNew[i+nCountMustSup] = pOIDsMust[i];
        }

        pOIDsMustNew[nCountMustSup+nCountMust] = -1;

        pClassInfo->pOIDsMustContain = pOIDsMustNew;
        pClassInfo->nNumOfMustContain = nCountMust + nCountMustSup;
        if ( pOIDsMust )
            FreeADsMem( pOIDsMust );

        pOIDsMustNew = NULL;
    }

    if ( nCountMaySup > 0 )
    {
        pOIDsMayNew = (int *) AllocADsMem(
                            sizeof(int) * ( nCountMay + nCountMaySup + 1 ));

        if ( pOIDsMayNew == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        for ( i = 0; i < nCountMaySup; i++ )
        {
            pOIDsMayNew[i] = pOIDsMaySup[i];
        }

        for ( i = 0; i < nCountMay; i++ )
        {
            pOIDsMayNew[i+nCountMaySup] = pOIDsMay[i];
        }

        pOIDsMayNew[nCountMaySup+nCountMay] = -1;

        pClassInfo->pOIDsMayContain = pOIDsMayNew;
        pClassInfo->nNumOfMayContain = nCountMay + nCountMaySup;
        if ( pOIDsMay )
            FreeADsMem( pOIDsMay );

        pOIDsMayNew = NULL;
    }

cleanup:

    if (FAILED(hr))
    {
        if ( pOIDsMustNew )
            FreeADsMem( pOIDsMustNew );

        if ( pOIDsMayNew )
            FreeADsMem( pOIDsMayNew );
    }

    RRETURN(hr);

}


HRESULT ProcessClassInfoArray(
    CLASSINFO *aClasses,
    DWORD nClasses,
    SEARCHENTRY *aSearchTable,
    BOOL fProcessAUX // defaulted to false
)
{
    HRESULT hr = S_OK;
    SEARCHENTRY searchEntry;
    SEARCHENTRY *matchedEntry;
    DWORD i;
    BOOL fProcessedAll = TRUE;
    DWORD nLoop = 0;

    do
    {
        fProcessedAll = TRUE;

        for ( DWORD i = 0; i < nClasses; i++ )
        {
            LPTSTR *pOIDsSup = NULL;
            LPTSTR *pOIDsAux = NULL;
            DWORD j = 0;

            if ( aClasses[i].fProcessedSuperiorClasses )
                continue;

            pOIDsSup = aClasses[i].pOIDsSuperiorClasses;
            //
            // If fProcessAUX then we ne need to add the aux
            // class lists must and may to the classes own list.
            // Please look at where this flag is being set for
            // more details.
            //
            if (fProcessAUX) {
                pOIDsAux = aClasses[i].pOIDsAuxClasses;
            } 
            else {
                pOIDsAux = NULL;
            }

            if ( pOIDsSup == NULL )
            {
                aClasses[i].fProcessedSuperiorClasses = TRUE;
                continue;
            }

            // This is here just in case the schema description for class "top"
            // has other superior classes. "top" should not have any superior
            // classes.

            if ( _tcsicmp( aClasses[i].pszName, TEXT("top")) == 0 )
            {
                aClasses[i].fProcessedSuperiorClasses = TRUE;
                continue;
            }

            j = 0;
            while ( pOIDsSup[j] )
            {
                searchEntry.pszName = pOIDsSup[j];
                matchedEntry = (SEARCHENTRY *) bsearch(
                                    (SEARCHENTRY *) &searchEntry,
                                    aSearchTable, 2*nClasses,
                                    sizeof(SEARCHENTRY), searchentrycmp );

                if ( matchedEntry )  // found the superior class
                {
                    if (!aClasses[matchedEntry->nIndex].fProcessedSuperiorClasses)
                    {
                        fProcessedAll = FALSE;
                        break;
                    }

                    hr = GetInfoFromSuperiorClasses(
                             &(aClasses[i]), &(aClasses[matchedEntry->nIndex]));
                    BAIL_ON_FAILURE(hr);
                }

                j++;
            }

            if ( pOIDsSup[j] == NULL )
            {
                if ( pOIDsAux == NULL )
                {
                    aClasses[i].fProcessedSuperiorClasses = TRUE;
                }
                else
                {
                    j = 0;
                    while ( pOIDsAux[j] )
                    {
                        searchEntry.pszName = pOIDsAux[j];
                        matchedEntry = (SEARCHENTRY *) bsearch(
                                           (SEARCHENTRY *) &searchEntry,
                                           aSearchTable, 2*nClasses,
                                           sizeof(SEARCHENTRY), searchentrycmp);

                        if ( matchedEntry )  // found the superior class
                        {
                            if (!aClasses[matchedEntry->nIndex].fProcessedSuperiorClasses)
                            {
                                fProcessedAll = FALSE;
                                break;
                            }

                            hr = GetInfoFromSuperiorClasses(
                                     &(aClasses[i]),
                                     &(aClasses[matchedEntry->nIndex]));
                            BAIL_ON_FAILURE(hr);
                        }

                        j++;
                    }

                    if ( pOIDsAux[j] == NULL )
                        aClasses[i].fProcessedSuperiorClasses = TRUE;
                }
            }
        }

        nLoop++;

    } while ( (nLoop < MAX_LOOP_COUNT) && !fProcessedAll );

    for ( i = 0; i < nClasses; i++ )
    {
        CLASSINFO *pClass = &(aClasses[i]);
        DWORD j, k;

        //
        // Eliminate duplicates in MustContain
        //

        if ( pClass->pOIDsMustContain != NULL )
        {
            SortAndRemoveDuplicateOIDs( pClass->pOIDsMustContain,
                                        &pClass->nNumOfMustContain );
        }

        //
        // Eliminate duplicates in MayContain
        //

        if ( pClass->pOIDsMayContain != NULL )
        {
            SortAndRemoveDuplicateOIDs( pClass->pOIDsMayContain,
                                        &pClass->nNumOfMayContain );
        }

        //
        // Eliminate duplicates between MustContain and MayContain
        //
        if (  ( pClass->pOIDsMustContain == NULL )
           || ( pClass->pOIDsMayContain == NULL )
           )
        {
            continue;
        }

        j = 0; k = 0;
        while (  ( pClass->pOIDsMustContain[j] != -1 )
              && ( pClass->pOIDsMayContain[k] != -1 )
              )
        {
            int nMust = pClass->pOIDsMustContain[j];
            int nMay = pClass->pOIDsMayContain[k];

            if ( nMust < nMay )
            {
                j++;
            }
            else if ( nMust > nMay )
            {
                k++;
            }
            else  // nMust == nMay
            {
                j++;

                DWORD m = k;

                do {
                    pClass->pOIDsMayContain[m] = pClass->pOIDsMayContain[m+1];
                    m++;
                } while ( pClass->pOIDsMayContain[m] != -1 );
            }
        }

        //
        // Removes the NotContain from the MustContain or MayContain list
        //

        if ( pClass->pOIDsNotContain != NULL )
        {
            qsort( pClass->pOIDsNotContain, pClass->nNumOfNotContain,
                   sizeof(pClass->pOIDsNotContain[0]), intcmp );

            j = 0; k = 0;
            while (  ( pClass->pOIDsMustContain[j] != -1 )
                  && ( pClass->pOIDsNotContain[k] != -1 )
                  )
            {
                int nMust = pClass->pOIDsMustContain[j];
                int nNot = pClass->pOIDsNotContain[k];

                if ( nMust < nNot )
                {
                    j++;
                }
                else if ( nMust > nNot )
                {
                    k++;
                }
                else  // nMust == nNot
                {
                    k++;

                    DWORD m = j;

                    do {
                        pClass->pOIDsMustContain[m] = pClass->pOIDsMustContain[m+1];
                        m++;
                    } while ( pClass->pOIDsMustContain[m] != -1 );
                }
            }

            j = 0; k = 0;
            while (  ( pClass->pOIDsMayContain[j] != -1 )
                  && ( pClass->pOIDsNotContain[k] != -1 )
                  )
            {
                int nMay = pClass->pOIDsMayContain[j];
                int nNot = pClass->pOIDsNotContain[k];

                if ( nMay < nNot )
                {
                    j++;
                }
                else if ( nMay > nNot )
                {
                    k++;
                }
                else  // nMay == nNot
                {
                    k++;

                    DWORD m = j;

                    do {
                        pClass->pOIDsMayContain[m] = pClass->pOIDsMayContain[m+1];
                        m++;
                    } while ( pClass->pOIDsMayContain[m] != -1 );
                }
            }

            FreeADsMem( pClass->pOIDsNotContain );
            pClass->pOIDsNotContain = NULL;
        }
    }

    RRETURN(S_OK);

error:

    RRETURN(hr);
}

VOID SortAndRemoveDuplicateOIDs(
    int *aOIDs,
    DWORD *pnNumOfOIDs
)
{
    DWORD j, k;

    qsort( aOIDs, *pnNumOfOIDs, sizeof( aOIDs[0]), intcmp );

    // The following code removes duplicate strings in place.
    // index j is the index to walk the array, and index k is the
    // index of the last non-duplicate entry. The array is sorted
    // and so we compare the string at index j and index k.
    // (1) If they are the same, then j++
    // (2) If not the same, increment k, free the string at k and
    //     make k point to the string at j. Then increment j and
    //     continue.
    //
    // NOTE: aOIDs must be an array of integers that ends with -1.


    j = 1; k = 0;
    while ( aOIDs[j] != -1 )
    {
        while ( aOIDs[j] == aOIDs[k] )
        {
            j++;
            if ( aOIDs[j] == -1 )
                break;
        }

        if ( aOIDs[j] != -1 )
        {
            k++;

            if ( k != j )
            {
                aOIDs[k] = aOIDs[j];
                aOIDs[j] = -1;
            }
            j++;
        }
    }

    k++;
    aOIDs[k] = -1;
    *pnNumOfOIDs = k;
}

VOID FreeClassInfoArray(
    CLASSINFO *aClasses,
    DWORD  nClasses
)
{
    if ( aClasses )
    {
        DWORD j;
        for ( j = 0; j < nClasses; j++ )
        {
            FreeADsStr( aClasses[j].pszName );
            FreeADsStr( aClasses[j].pszOID );
            FreeADsStr( aClasses[j].pszHelpFileName );
            FreeADsStr( aClasses[j].pszDescription );

            DWORD k = 0;
            if ( aClasses[j].pOIDsSuperiorClasses )
            {
                while ( aClasses[j].pOIDsSuperiorClasses[k] )
                    FreeADsStr( aClasses[j].pOIDsSuperiorClasses[k++]);
                FreeADsMem( aClasses[j].pOIDsSuperiorClasses );
            }

            k = 0;
            if ( aClasses[j].pOIDsAuxClasses )
            {
                while ( aClasses[j].pOIDsAuxClasses[k] )
                    FreeADsStr( aClasses[j].pOIDsAuxClasses[k++]);
                FreeADsMem( aClasses[j].pOIDsAuxClasses );
            }

            if ( aClasses[j].pOIDsMustContain )
            {
                FreeADsMem( aClasses[j].pOIDsMustContain );
            }

            if ( aClasses[j].pOIDsMayContain )
            {
                FreeADsMem( aClasses[j].pOIDsMayContain );
            }

            if ( aClasses[j].pOIDsNotContain )
            {
                FreeADsMem( aClasses[j].pOIDsNotContain );
            }
        }

        FreeADsMem( aClasses );
    }
}



DWORD ReadSchemaInfoFromFileWithHandle(
    HANDLE hFile,
    LPTSTR **paValuesAttrTypes,
    int *pnCountAttrTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pFileBuffer
    )
{
    DWORD err = NO_ERROR;
    DWORD dwFileSize = 0;
    DWORD dwBytesRead = 0;
    LPTSTR pLine = NULL;
    LPTSTR pEndOfLine = NULL;
    DWORD nCount;
    DWORD nType;
    DWORD dwStatus = NO_ERROR;
    //
    // Even though the calling routine has an exception handler,
    // we need one over here also as this we need to close the file
    // over here, we do not have the file handle in the calling routine.
    //
    __try {

        dwFileSize = GetFileSize( hFile, NULL );

        if ( dwFileSize == -1 )
        {
            err = GetLastError();
            goto cleanup;
        }
        else if ( dwFileSize == 0 )
        {
            err = ERROR_FILE_INVALID;
            goto cleanup;
        }

        *pFileBuffer = (LPBYTE) AllocADsMem( dwFileSize );
        if ( *pFileBuffer == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        if ( !ReadFile( hFile,
                        *pFileBuffer,
                        dwFileSize,
                        &dwBytesRead,
                        NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }


        for ( pLine = ((LPTSTR) *pFileBuffer) + 1;  // go past Unicode BOM marker
             pLine < (LPTSTR) ( *pFileBuffer + dwFileSize );
             pLine = pEndOfLine + 1 )
        {
            if ( pEndOfLine = _tcschr( pLine, TEXT('\n')))
                *pEndOfLine = 0;

            if ( _tcsicmp( pLine, TEXT("[attributeTypes]")) == 0 )
            {
                nType = ID_ATTRTYPES;
                continue;
            }
            else if ( _tcsicmp( pLine, TEXT("[objectClasses]")) == 0 )
            {
                nType = ID_OBJCLASSES;
                continue;
            }
            else if ( _tcsicmp( pLine, TEXT("[DITContentRules]")) == 0 )
            {
                nType = ID_DITCONTENTRULES;
                continue;
            }

            switch ( nType )
            {
                case ID_ATTRTYPES:
                    (*pnCountAttrTypes)++;
                    break;

                case ID_OBJCLASSES:
                    (*pnCountObjClasses)++;
                    break;

                case ID_DITCONTENTRULES:
                    (*pnCountRules)++;
                    break;
            }
        }

        *paValuesAttrTypes = (LPTSTR *) AllocADsMem( *pnCountAttrTypes * sizeof(LPTSTR));
        if ( *paValuesAttrTypes == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        *paValuesObjClasses = (LPTSTR *) AllocADsMem( *pnCountObjClasses * sizeof(LPTSTR));
        if ( *paValuesObjClasses == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        *paValuesRules = (LPTSTR *) AllocADsMem( *pnCountRules * sizeof(LPTSTR));
        if ( *paValuesRules == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        for ( pLine = ((LPTSTR) *pFileBuffer) + 1;// go past Unicode BOM marker
             pLine < (LPTSTR) ( *pFileBuffer + dwFileSize );
             pLine += ( _tcslen(pLine) + 1) )
        {
            if ( _tcsicmp( pLine, TEXT("[attributeTypes]")) == 0 )
            {
                nCount = 0;
                nType = ID_ATTRTYPES;
                continue;
            }
            else if ( _tcsicmp( pLine, TEXT("[objectClasses]")) == 0 )
            {
                nCount = 0;
                nType = ID_OBJCLASSES;
                continue;
            }
            else if ( _tcsicmp( pLine, TEXT("[DITContentRules]")) == 0 )
            {
                nCount = 0;
                nType = ID_DITCONTENTRULES;
                continue;
            }

            switch ( nType )
            {
                case ID_ATTRTYPES:
                    (*paValuesAttrTypes)[nCount++] = pLine;
                    break;

                case ID_OBJCLASSES:
                    (*paValuesObjClasses)[nCount++] = pLine;
                    break;

                case ID_DITCONTENTRULES:
                    (*paValuesRules)[nCount++] = pLine;
                    break;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

          err = GetExceptionCode();

          if (dwStatus != EXCEPTION_ACCESS_VIOLATION) {
              ADsDebugOut((DEB_ERROR, "Processing Schema Info:Unknown Exception %d\n", err));

          }
    }

cleanup:

    CloseHandle( hFile );

    if ( err )
    {
        *pnCountAttrTypes = 0;
        *pnCountObjClasses = 0;
        *pnCountRules = 0;

        if ( *paValuesAttrTypes )
            FreeADsMem( *paValuesAttrTypes );

        if ( *paValuesObjClasses )
            FreeADsMem( *paValuesObjClasses );

        if ( *paValuesRules )
            FreeADsMem( *paValuesRules );

        if ( *pFileBuffer )
            FreeADsMem( *pFileBuffer );

        *paValuesAttrTypes = NULL;
        *paValuesObjClasses = NULL;
        *paValuesRules = NULL;
        *pFileBuffer = NULL;
    }

    return err;
}


#ifdef WIN95
DWORD ReadSchemaInfoFromFileA(
    LPSTR pszFile,
    LPTSTR **paValuesAttrTypes,
    int *pnCountAttrTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pFileBuffer
    )
{
    DWORD err = NO_ERROR;
    HANDLE hFile = NULL;


    *pnCountAttrTypes = 0;
    *pnCountObjClasses = 0;
    *pnCountRules = 0;


    hFile = CreateFileA( pszFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
        return GetLastError();

    return (
            ReadSchemaInfoFromFileWithHandle(
                hFile,
                paValuesAttrTypes,
                pnCountAttrTypes,
                paValuesObjClasses,
                pnCountObjClasses,
                paValuesRules,
                pnCountRules,
                pFileBuffer
                )
    );
}
#endif

DWORD ReadSchemaInfoFromFileW(
    LPTSTR pszFile,
    LPTSTR **paValuesAttrTypes,
    int *pnCountAttrTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pFileBuffer
    )
{
    DWORD err = NO_ERROR;
    HANDLE hFile = NULL;

    *pnCountAttrTypes = 0;
    *pnCountObjClasses = 0;
    *pnCountRules = 0;


    hFile = CreateFile( pszFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
        return GetLastError();

    return (
            ReadSchemaInfoFromFileWithHandle(
                hFile,
                paValuesAttrTypes,
                pnCountAttrTypes,
                paValuesObjClasses,
                pnCountObjClasses,
                paValuesRules,
                pnCountRules,
                pFileBuffer
                )
    );

}


DWORD StoreSchemaInfoToFileWithHandle(
    HANDLE hFile,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules
)
{
    DWORD err = NO_ERROR;
    TCHAR szEndOfLine[2] = TEXT("\n");
    TCHAR szSection[MAX_PATH];
    DWORD dwBytesWritten;
    int i;

    szSection[0] = 0xFEFF;   // Unicode BOM marker
    if ( !WriteFile( hFile,
                     szSection,
                     sizeof(TCHAR),
                     &dwBytesWritten,
                     NULL ))
    {
        err = GetLastError();
        goto cleanup;
    }

    _tcscpy( szSection, TEXT("[attributeTypes]\n"));
    if ( !WriteFile( hFile,
                     szSection,
                     _tcslen( szSection ) * sizeof(TCHAR),
                     &dwBytesWritten,
                     NULL ))
    {
        err = GetLastError();
        goto cleanup;
    }

    for ( i = 0; i < nCountAttribTypes; i++ )
    {
        if ( !WriteFile( hFile,
                         aValuesAttribTypes[i],
                         _tcslen( aValuesAttribTypes[i] ) * sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }

        if ( !WriteFile( hFile,
                         szEndOfLine,
                         sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    _tcscpy( szSection, TEXT("[objectClasses]\n"));
    if ( !WriteFile( hFile,
                     szSection,
                     _tcslen( szSection ) * sizeof(TCHAR),
                     &dwBytesWritten,
                     NULL ))
    {
        err = GetLastError();
        goto cleanup;
    }

    for ( i = 0; i < nCountObjClasses; i++ )
    {
        if ( !WriteFile( hFile,
                         aValuesObjClasses[i],
                         _tcslen( aValuesObjClasses[i] ) * sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }

        if ( !WriteFile( hFile,
                         szEndOfLine,
                         sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    _tcscpy( szSection, TEXT("[DITContentRules]\n"));
    if ( !WriteFile( hFile,
                     szSection,
                     _tcslen( szSection ) * sizeof(TCHAR),
                     &dwBytesWritten,
                     NULL ))
    {
        err = GetLastError();
        goto cleanup;
    }

    for ( i = 0; i < nCountRules; i++ )
    {
        if ( !WriteFile( hFile,
                         aValuesRules[i],
                         _tcslen( aValuesRules[i] ) * sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }

        if ( !WriteFile( hFile,
                         szEndOfLine,
                         sizeof(TCHAR),
                         &dwBytesWritten,
                         NULL ))
        {
            err = GetLastError();
            goto cleanup;
        }
    }

cleanup:

    CloseHandle( hFile );

    return err;
}

#ifdef WIN95
DWORD StoreSchemaInfoToFileA(
    LPSTR pszFile,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules
)
{
    DWORD err = NO_ERROR;
    HANDLE hFile = NULL;


    hFile = CreateFileA( pszFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        err = GetLastError();

        if ( err == ERROR_PATH_NOT_FOUND )
        {
            //
            // The directory is not created yet, create it now.
            //

            LPSTR pszTemp = strstr( pszFile, "SchCache\\");
            pszTemp += strlen("SchCache");
            *pszTemp = 0;

            if ( !CreateDirectoryA( pszFile, NULL ))
                return GetLastError();

            *pszTemp = '\\';
            hFile = CreateFileA( pszFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

            if ( hFile == INVALID_HANDLE_VALUE )
                return GetLastError();

            err = NO_ERROR;
        }
        else
        {
            return err;
        }
    }

    err = StoreSchemaInfoToFileWithHandle(
              hFile,
              aValuesAttribTypes,
              nCountAttribTypes,
              aValuesObjClasses,
              nCountObjClasses,
              aValuesRules,
              nCountRules
              );

    if ( err != NO_ERROR )
        DeleteFileA( pszFile );

    return err;

}

#endif

DWORD StoreSchemaInfoToFileW(
    LPTSTR pszFile,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules
)
{
    DWORD err = NO_ERROR;
    HANDLE hFile = NULL;


    hFile = CreateFile( pszFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        err = GetLastError();

        if ( err == ERROR_PATH_NOT_FOUND )
        {
            // The directory is not created yet, create it now.

            LPTSTR pszTemp = _tcsrchr( pszFile, TEXT('\\'));
            *pszTemp = 0;

            if ( !CreateDirectory( pszFile, NULL ))
                return GetLastError();

            *pszTemp = TEXT('\\');
            hFile = CreateFile( pszFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

            if ( hFile == INVALID_HANDLE_VALUE )
                return GetLastError();

            err = NO_ERROR;
        }
        else
        {
            return err;
        }
    }

    err = StoreSchemaInfoToFileWithHandle(
              hFile,
              aValuesAttribTypes,
              nCountAttribTypes,
              aValuesObjClasses,
              nCountObjClasses,
              aValuesRules,
              nCountRules
              );

    if ( err != NO_ERROR )
        DeleteFile( pszFile );

    return err;
}

DWORD ReadSchemaInfoFromRegistry(
    HKEY hKey,
    LPWSTR pszServer,
    LPTSTR **paValuesAttribTypes,
    int *pnCountAttribTypes,
    LPTSTR **paValuesObjClasses,
    int *pnCountObjClasses,
    LPTSTR **paValuesRules,
    int *pnCountRules,
    LPBYTE *pBuffer    
)
{
    DWORD err = NO_ERROR;
    LPTSTR pszPath = NULL;
    LPTSTR pszExpandedPath = NULL;
    LPSTR pszPathAscii = NULL;
    LPSTR pszExpandedPathAscii = NULL;
    LPTSTR pszTempPath = NULL;
    DWORD dwLength = 0;
    DWORD dwType;
    

    //
    // On chk bits would be good to make sure that this never
    // happens as some schema stuff is messed up in this case.
    //
    if (!pszServer) {
        ADsAssert(!"No server name was passed");
    }
    //
    // Get the file name that is used to store the schema info
    // from the registry.
    //

    err = RegQueryValueEx( hKey,
                           SCHEMA_FILE_NAME,
                           NULL,
                           &dwType,
                           NULL,
                           &dwLength );
#ifndef WIN95
    if ( err )
        goto cleanup;
#else
    if (err == ERROR_MORE_DATA ) {
        //
        // Continue cause Win9x is dumb.
        //
        err = 0;
    } else
        goto cleanup;
#endif

    pszPath = (LPTSTR) AllocADsMem( dwLength );
    if ( pszPath == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    err = RegQueryValueEx( hKey,
                           SCHEMA_FILE_NAME,
                           NULL,
                           &dwType,
                           (LPBYTE) pszPath,
                           &dwLength );

    if ( err )
        goto cleanup;

    //
    // Expand the path
    //
    pszExpandedPath = (LPTSTR) AllocADsMem( MAX_PATH * sizeof(WCHAR));
    if ( pszExpandedPath == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // At this point we want to rename all files called default.sch
    // We look for default.sch in the string and then create a new
    // string. For example if the string is %systemroot%\SCHEMA_DIR\
    // Default.sch we will replace with %systemroot%\SCHEMA_DIR\
    // pszServer.sch. This change will force schema to be dropped
    // and we will end up picking up and storing the schema under the 
    // correct name. This will ensure that 2 different forests do
    // not end up creating conflicting default.sch files that we 
    // never recover from internally. This excercise is futile unless
    // a server name was passed in (should be the case always).
    //
    if (pszPath && *pszPath && pszServer) {
        //
        // Look for default.sch
        //
        pszTempPath = wcsstr( pszPath, DEFAULT_SCHEMA_FILE_NAME_WITH_EXT);

        if (pszTempPath) {
            //
            // We now need to replace this string.
            //
            DWORD dwLenStr, dwLenNewPath;
            dwLenStr = pszTempPath - pszPath;
            
            //
            // Now build the new string from the old one. Length is 
            // pszServer + the old piece upto schema file name.
            //
            dwLenNewPath = wcslen(pszServer) 
                          + wcslen(SCHEMA_FILE_NAME_EXT)
                          + dwLenStr
                          + 1;

            pszTempPath = (LPTSTR) AllocADsMem(dwLenNewPath * sizeof(WCHAR));
            if (!pszTempPath) {
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            wcsncpy(pszTempPath, pszPath, dwLenStr);
            wcscat(pszTempPath, pszServer);
            wcscat(pszTempPath, SCHEMA_FILE_NAME_EXT);

            FreeADsMem(pszPath);
            pszPath = pszTempPath;
            pszTempPath = NULL;
            
            //
            // Now update the key in the registry. Ignore the error
            // cause there is nothing we can really do about it.
            //
            err = RegSetValueEx( 
                      hKey,
                      SCHEMA_FILE_NAME,
                      0,
                      REG_EXPAND_SZ,
                      (CONST BYTE *) pszPath,
                      (_tcslen(pszPath) + 1 ) * sizeof(TCHAR)
                      );
        }
    }

    dwLength = ExpandEnvironmentStrings( pszPath,
                                         pszExpandedPath,
                                         MAX_PATH );

#ifdef WIN95
    //
    // Just in case 3 bytes for each WCHAR rather than just 2.
    //
    pszExpandedPathAscii = (LPSTR) AllocADsMem( MAX_PATH * sizeof(char) * 3);
    if (!pszExpandedPathAscii) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if (err = ConvertToAscii(pszPath, &pszPathAscii)) {
        goto cleanup;
    }

    dwLength = ExpandEnvironmentStringsA(
                   pszPathAscii,
                   pszExpandedPathAscii,
                   MAX_PATH * sizeof(char) * 3
                   );
#endif

    if ( dwLength == 0 )
    {
        err = GetLastError();
        goto cleanup;
    }
    else if ( dwLength > MAX_PATH )
    {
        FreeADsMem( pszExpandedPath );
        pszExpandedPath = (LPTSTR) AllocADsMem( dwLength * sizeof(WCHAR));
        if ( pszExpandedPath == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        dwLength = ExpandEnvironmentStrings( pszPath,
                                             pszExpandedPath,
                                             dwLength );
        if ( dwLength == 0 )
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    //
    // Now, read the info from the file
    //
#ifndef WIN95
    err = ReadSchemaInfoFromFileW(
              pszExpandedPath,
              paValuesAttribTypes,
              pnCountAttribTypes,
              paValuesObjClasses,
              pnCountObjClasses,
              paValuesRules,
              pnCountRules,
              pBuffer
              );
#else
    err = ReadSchemaInfoFromFileA(
              pszExpandedPathAscii,
              paValuesAttribTypes,
              pnCountAttribTypes,
              paValuesObjClasses,
              pnCountObjClasses,
              paValuesRules,
              pnCountRules,
              pBuffer
              );

#endif


cleanup:

    if ( pszPath )
        FreeADsMem( pszPath );

    if ( pszExpandedPath )
        FreeADsMem( pszExpandedPath );

    if (pszTempPath) {
        FreeADsMem(pszTempPath);
    }

#ifdef WIN95
    if (pszPathAscii) {
        FreeADsMem(pszPathAscii);
    }

    if (pszExpandedPathAscii) {
        FreeADsMem(pszExpandedPathAscii);
    }
#endif

    return err;
}

DWORD StoreSchemaInfoInRegistry(
    HKEY hKey,
    LPTSTR pszServer,
    LPTSTR pszTime,
    LPTSTR *aValuesAttribTypes,
    int nCountAttribTypes,
    LPTSTR *aValuesObjClasses,
    int nCountObjClasses,
    LPTSTR *aValuesRules,
    int nCountRules,
    BOOL fProcessAUX
)
{
    DWORD err = NO_ERROR;
    LPTSTR pszPath = NULL;
    LPTSTR pszExpandedPath = NULL;
    LPSTR pszPathAscii = NULL;
    LPSTR pszExpandedPathAscii = NULL;
    DWORD dwLength = 0;
    DWORD dwType;
    DWORD dwProcessAUX;

    //
    // See if we can find the file name that is used to store the schema info
    // in the registry.
    //

    err = RegQueryValueEx( hKey,
                           SCHEMA_FILE_NAME,
                           NULL,
                           &dwType,
                           NULL,
                           &dwLength );

    if ( err == NO_ERROR )
    {
        pszPath = (LPTSTR) AllocADsMem( dwLength );
        if ( pszPath == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        err = RegQueryValueEx( hKey,
                               SCHEMA_FILE_NAME,
                               NULL,
                               &dwType,
                               (LPBYTE) pszPath,
                               &dwLength );

        if ( err )
            goto cleanup;

    }

    err = NO_ERROR;

    if ( pszPath == NULL )   // Cannot read from the registry
    {
        //
        // Allocate pszPath to be either MAX_PATH chars or sufficient
        // to hold %SystemRoot%/<SCHEMA_DIR_NAME>/<pszServer>.sch, whichever
        // is larger.
        //
        if (pszServer) {
            DWORD cbPath = (MAX_PATH > (_tcslen(TEXT("%SystemRoot%\\")) +
                                        _tcslen(SCHEMA_DIR_NAME) +
                                        _tcslen(pszServer) +
                                        _tcslen(SCHEMA_FILE_NAME_EXT))) ?
                           (MAX_PATH * sizeof(WCHAR)) :
                           (2 * _tcslen(pszServer) * sizeof(WCHAR));

                                        
            pszPath = (LPTSTR) AllocADsMem(cbPath);
        }
        else{
            //
            // pszServe can be NULL in the ldapc layer users case
            //
            pszPath = (LPTSTR) AllocADsMem(MAX_PATH * sizeof(WCHAR));
        }

        if ( pszPath == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        //
        // Build the path of the schema info file
        //
#ifndef WIN95
        _tcscpy( pszPath, TEXT("%SystemRoot%\\"));
#else
        _tcscpy( pszPath, TEXT("%WINDIR%\\"));
#endif
        _tcscat( pszPath, SCHEMA_DIR_NAME);
        if (pszServer) {

            //
            // Server strings may have a port number in them,
            // e.g., "ntdev:389".  We need to change this to
            // "ntdev_389", otherwise the colon will give us trouble
            // in the filename.
            //
            LPTSTR pszColon = _tcschr(pszServer, (TCHAR)':');
            
            if (!pszColon) {
                _tcscat( pszPath, pszServer);
            }
            else {
                _tcsncat( pszPath, pszServer, pszColon-pszServer);
                _tcscat ( pszPath, TEXT("_"));
                _tcscat ( pszPath, pszColon+1); // the number after the colon 
            }
            
        }
        else {
            _tcscat( pszPath, DEFAULT_SCHEMA_FILE_NAME);
        }

        _tcscat( pszPath, SCHEMA_FILE_NAME_EXT );
    }

    pszExpandedPath = (LPTSTR) AllocADsMem( MAX_PATH * sizeof(WCHAR) );
    if ( pszExpandedPath == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    dwLength = ExpandEnvironmentStrings( pszPath,
                                         pszExpandedPath,
                                         MAX_PATH );
#ifdef WIN95

    pszExpandedPathAscii = (LPSTR) AllocADsMem(MAX_PATH * sizeof(char) * 3);
    if (!pszExpandedPathAscii) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if (err = ConvertToAscii(pszPath, &pszPathAscii)) {
        goto cleanup;
    }

    dwLength = ExpandEnvironmentStringsA(
                   pszPathAscii,
                   pszExpandedPathAscii,
                   MAX_PATH * sizeof(char) * 3
                   );
#endif

    if ( dwLength == 0 )
    {
        err = GetLastError();
        goto cleanup;
    }
    else if ( dwLength > MAX_PATH )
    {
        FreeADsMem( pszExpandedPath );
        pszExpandedPath = (LPTSTR) AllocADsMem( dwLength * sizeof(WCHAR) );
        if ( pszExpandedPath == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        dwLength = ExpandEnvironmentStrings( pszPath,
                                             pszExpandedPath,
                                             dwLength );
        if ( dwLength == 0 )
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    //
    // Write the schema information into the file
    //
#ifndef WIN95
    err = StoreSchemaInfoToFileW(
               pszExpandedPath,
               aValuesAttribTypes,
               nCountAttribTypes,
               aValuesObjClasses,
               nCountObjClasses,
               aValuesRules,
               nCountRules
               );
#else
    err = StoreSchemaInfoToFileA(
               pszExpandedPathAscii,
               aValuesAttribTypes,
               nCountAttribTypes,
               aValuesObjClasses,
               nCountObjClasses,
               aValuesRules,
               nCountRules
               );
#endif

    if ( err )
        goto cleanup;

    //
    // Write the information into the registry
    //

    err = RegSetValueEx( hKey,
                         SCHEMA_FILE_NAME,
                         0,
                         REG_EXPAND_SZ,
                         (CONST BYTE *) pszPath,
                         (_tcslen(pszPath) + 1 ) * sizeof(TCHAR));

    if ( err )
        goto cleanup;

    err = RegSetValueEx( hKey,
                         SCHEMA_TIME,
                         0,
                         REG_SZ,
                         (CONST BYTE *) pszTime,
                         (_tcslen(pszTime) + 1 ) * sizeof(TCHAR));

    if ( err )
        goto cleanup;

    
    dwProcessAUX = (TRUE == fProcessAUX) ? 1: 0;
    err = RegSetValueExW( hKey,
                         SCHEMA_PROCESSAUX,
                         0,
                         REG_DWORD,
                         (CONST BYTE *) &dwProcessAUX,
                         sizeof(dwProcessAUX));
   

cleanup:

    if ( pszPath )
        FreeADsMem( pszPath );

    if ( pszExpandedPath )
        FreeADsMem( pszExpandedPath );

#ifdef WIN95
    if (pszPathAscii) {
        FreeADsMem(pszPathAscii);
    }

    if (pszExpandedPathAscii) {
        FreeADsMem(pszExpandedPathAscii);
    }
#endif

    return err;
}


//+---------------------------------------------------------------------------
//  Function:   AttributeTypeDescription
//
//  Synopsis:   Parses an attribute type description.
//              It parses the following grammar rules
//
//  <AttributeTypeDescription> ::= "("
//          <oid>   -- AttributeType identifier
//          [ "NAME" <DirectoryStrings> ] -- name used in AttributeType
//          [ "DESC" <DirectoryString> ]
//          [ "OBSOLETE" ]
//          [ "SUP" <oid> ]         -- derived from this other AttributeType
//          [ "EQUALITY" <oid> ]    -- Matching Rule name
//          [ "ORDERING" <oid> ]    -- Matching Rule name
//          [ "SUBSTR" <oid> ]      -- Matching Rule name
//          [ "SYNTAX" <DirectoryString> ] -- see section 4.2
//          [ "SINGLE-VALUE" ]              -- default multi-valued
//          [ "COLLECTIVE" ]                -- default not collective
//          [ "DYNAMIC" ]                   -- default not dynamic
//          [ "NO-USER-MODIFICATION" ]      -- default user modifiable
//          [ "USAGE" <AttributeUsage> ]    -- default user applications
//          ")"
//
//   <AttributeUsage> ::=
//            "userApplications"
//          | "directoryOperation"
//          | "distributedOperation"  -- DSA-shared
//          | "dSAOperation"          -- DSA-specific, value depends on server
//
//
//  Arguments:  [LPTSTR] pszAttrType : The string to parse
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    9-3-96   yihsins    Created.
//
//----------------------------------------------------------------------------
HRESULT
AttributeTypeDescription(
    LPTSTR pszAttrType,
    PPROPERTYINFO pPropertyInfo,
    LPWSTR **pppszNames,
    PDWORD pdwNameCount
    )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    CSchemaLexer Tokenizer;
    hr = Tokenizer.InitializePath(pszAttrType);
    BAIL_IF_ERROR(hr);
    
    hr = Tokenizer.GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken != TOKEN_OPENBRACKET )
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    //
    // use TRUE flag as there is a chance that from
    // some schemas, we get bad data that has no GUID
    //
    hr = Oid( &Tokenizer, &(pPropertyInfo->pszOID), TRUE);
    BAIL_IF_ERROR(hr);

    while ( TRUE ) {
        LPWSTR *ppszDirStrings;
        DWORD dwCount,dwCtr;
        ppszDirStrings = NULL;
        dwCount = 0;

        hr = Tokenizer.GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if ( dwToken == TOKEN_IDENTIFIER )
            Tokenizer.IsKeyword( szToken, &dwToken );

        switch ( dwToken ) {
            case TOKEN_CLOSEBRACKET:
                RRETURN(S_OK);

            case TOKEN_NAME:
                hr = DirectoryStrings(
                         &Tokenizer,
                         &ppszDirStrings,
                         &dwCount
                         );
                BAIL_IF_ERROR(hr);

                if (!ppszDirStrings) {
                    //
                    // We need at least one name.
                    //
                    BAIL_IF_ERROR(
                        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
                        );
                }

                //
                // For now we will only support the first name in the list.
                //
                pPropertyInfo->pszPropertyName = ppszDirStrings[0];

                //
                // The remaining values if any will require additional 
                // processing in FillPropertyInfoArray.
                //
                *pppszNames = ppszDirStrings;
                *pdwNameCount = dwCount;

                break;

            case TOKEN_DESC:
                hr = DirectoryString( &Tokenizer,
                                      &(pPropertyInfo->pszDescription));
                break;

            case TOKEN_OBSOLETE:
                // attribute is obsolete (RFC 2252)
                pPropertyInfo->fObsolete = TRUE;
                break;

            case TOKEN_SUP:
                hr = Oid( &Tokenizer, &(pPropertyInfo->pszOIDSup));
                break;

            case TOKEN_EQUALITY:
                hr = Oid( &Tokenizer, &(pPropertyInfo->pszOIDEquality));
                break;

            case TOKEN_ORDERING:
                hr = Oid( &Tokenizer, &(pPropertyInfo->pszOIDOrdering));
                break;

            case TOKEN_SUBSTR:
                hr = Oid( &Tokenizer, &(pPropertyInfo->pszOIDSubstr));
                break;

            case TOKEN_SYNTAX:
                hr = DirectoryString( &Tokenizer, &(pPropertyInfo->pszSyntax));
                //
                // It need not necessarily be a DirectoryString can also be
                // an OID. So if DirectoryString fails, we should try OID.
                //
                if (FAILED(hr)
                    && (hr == HRESULT_FROM_WIN32(ERROR_INVALID_DATA))
                    ) {

                    Tokenizer.PushBackToken();
                    hr = Oid( &Tokenizer, &(pPropertyInfo->pszSyntax));
                }

                break;

            case TOKEN_SINGLE_VALUE:
                pPropertyInfo->fSingleValued = TRUE;
                break;

            case TOKEN_COLLECTIVE:
                pPropertyInfo->fCollective = TRUE;
                break;

            case TOKEN_DYNAMIC:
                pPropertyInfo->fDynamic = TRUE;
                break;

            case TOKEN_NO_USER_MODIFICATION:
                pPropertyInfo->fNoUserModification = TRUE;
                break;

            case TOKEN_USAGE:
                hr = Tokenizer.GetNextToken(szToken, &dwToken);
                BAIL_IF_ERROR(hr);

                if (_tcsicmp(szToken, TEXT("userApplications")) == 0)
                    pPropertyInfo->dwUsage = ATTR_USAGE_USERAPPLICATIONS;
                else if (_tcsicmp(szToken, TEXT("directoryOperation")) == 0)
                    pPropertyInfo->dwUsage = ATTR_USAGE_DIRECTORYOPERATION;
                else if (_tcsicmp(szToken, TEXT("distributedOperation")) == 0)
                    pPropertyInfo->dwUsage = ATTR_USAGE_DISTRIBUTEDOPERATION;
                else if (_tcsicmp(szToken, TEXT("dSAOperation")) == 0)
                    pPropertyInfo->dwUsage = ATTR_USAGE_DSAOPERATION;
                break;

            case TOKEN_OPEN_CURLY :
                hr = Tokenizer.GetNextToken(szToken, &dwToken);
                BAIL_IF_ERROR(hr);

                if (dwToken != TOKEN_IDENTIFIER) {
                    BAIL_IF_ERROR(hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
                }
                hr = Tokenizer.GetNextToken(szToken, &dwToken);
                BAIL_IF_ERROR(hr);

                if (dwToken != TOKEN_CLOSE_CURLY) {
                    BAIL_IF_ERROR(hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
                }
                break;

            case TOKEN_X :
                //
                // This means that this token and the following 
                // DirectoryStrings token (which can be empty string)
                // need to be ignored.
                //
                hr = DirectoryStrings(
                         &Tokenizer,
                         &ppszDirStrings,
                         &dwCount
                         );
                //
                // If we could not process this then we need to BAIL
                // as the Tokenizer is not in a recoverable state.
                //
                BAIL_IF_ERROR(hr);

                //
                // Free the strings that came back.
                //
                FreeDirectoryStrings(
                    ppszDirStrings,
                    dwCount
                    );

                ppszDirStrings = NULL;
                
                break;

            default:
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                break;
        }

        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//  Function:   ObjectClassDescription
//
//  Synopsis:   Parses an object class description.
//              It parses the following grammar rules
//
// <ObjectClassDescription> ::= "("
//          <oid>   -- ObjectClass identifier
//          [ "NAME" <DirectoryStrings> ]
//          [ "DESC" <DirectoryString> ]
//          [ "OBSOLETE" ]
//          [ "SUP" <oids> ]    -- Superior ObjectClasses
//          [ ( "ABSTRACT" | "STRUCTURAL" | "AUXILIARY" )] -- default structural
//          [ "MUST" <oids> ]   -- AttributeTypes
//          [ "MAY" <oids> ]    -- AttributeTypes
//      ")"
//
//  Arguments:  [LPTSTR] pszObjectClass : The string to parse
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    9-3-96   yihsins    Created.
//
//----------------------------------------------------------------------------
HRESULT
ObjectClassDescription(
    LPTSTR pszObjectClass,
    PCLASSINFO pClassInfo,
    SEARCHENTRY *aPropSearchTable,
    DWORD dwSearchTableCount,
    LPWSTR **pppszNewNames,
    PDWORD pdwNameCount
    )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    LPWSTR pszTemp;
    DWORD dwToken;
    HRESULT hr;

    CSchemaLexer Tokenizer;
    hr = Tokenizer.InitializePath(pszObjectClass);
    BAIL_IF_ERROR(hr);
    
    hr = Tokenizer.GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken != TOKEN_OPENBRACKET )
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    //
    // use TRUE flag as there is a chance that from
    // some schemas, we get bad data that has no GUID
    //
    hr = Oid( &Tokenizer, &(pClassInfo->pszOID), TRUE);
    BAIL_IF_ERROR(hr);

    while ( TRUE ) {
        LPWSTR *ppszDirStrings;
        DWORD dwCount,dwCtr;
        ppszDirStrings = NULL;
        dwCount = 0;

        hr = Tokenizer.GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if ( dwToken == TOKEN_IDENTIFIER )
            Tokenizer.IsKeyword( szToken, &dwToken );

        switch ( dwToken ) {
            case TOKEN_CLOSEBRACKET:
                RRETURN(S_OK);

            case TOKEN_NAME:
                hr = DirectoryStrings(
                         &Tokenizer,
                         &ppszDirStrings,
                         &dwCount
                         );
                BAIL_IF_ERROR(hr);

                if (!ppszDirStrings) {
                    //
                    // We need at least one name.
                    //
                    BAIL_IF_ERROR(
                        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
                        );
                }

                //
                // For now we will only support the first name in the list.
                //
                pClassInfo->pszName = ppszDirStrings[0];

                
                //
                // The remaining strings will need additional processing
                // in fillClassInfoArray
                //
                *pppszNewNames = ppszDirStrings;
                *pdwNameCount = dwCount;
                
                break;

            case TOKEN_DESC:
                hr = DirectoryString(&Tokenizer,&(pClassInfo->pszDescription));
                break;

            case TOKEN_OBSOLETE:
                // class is obsolete (RFC 2252)
                pClassInfo->fObsolete = TRUE;
                break;

            case TOKEN_SUP:
                hr = Tokenizer.GetNextToken(szToken, &dwToken);
                BAIL_IF_ERROR(hr);

                Tokenizer.PushBackToken();

                if ( dwToken == TOKEN_QUOTE )
                {

                    DWORD dwNumStrings = 0;
                    LPWSTR *ppszTmp = NULL;

                    while (dwToken == TOKEN_QUOTE) {

                        hr = DirectoryString( &Tokenizer,
                                              &(pszTemp));
                        BAIL_IF_ERROR(hr);

                        if (dwNumStrings == 0) {

                            pClassInfo->pOIDsSuperiorClasses
                                = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * 2);

                        } else {

                            ppszTmp
                                = (LPWSTR *)
                                    ReallocADsMem(
                                        pClassInfo->pOIDsSuperiorClasses,
                                        sizeof(LPWSTR) * (dwNumStrings + 1),
                                        sizeof(LPWSTR) * (dwNumStrings + 2)
                                        );
                            if(!ppszTmp)
                            {
                                BAIL_IF_ERROR(hr = E_OUTOFMEMORY);
                            }

                            pClassInfo->pOIDsSuperiorClasses = ppszTmp;
                            ppszTmp = NULL;
                        }

                        if ( pClassInfo->pOIDsSuperiorClasses == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            BAIL_IF_ERROR(hr);
                        }

                        pClassInfo->pOIDsSuperiorClasses[dwNumStrings] = pszTemp;
                        pClassInfo->pOIDsSuperiorClasses[++dwNumStrings] = NULL;

                        hr = Tokenizer.GetNextToken(szToken, &dwToken);
                        BAIL_IF_ERROR(hr);

                        Tokenizer.PushBackToken();

                    } // while

                } // the token was not a quote
                else {
                    hr = Oids(&Tokenizer, &(pClassInfo->pOIDsSuperiorClasses),NULL);
                }

                break;
            case TOKEN_ABSTRACT:
                pClassInfo->dwType = CLASS_TYPE_ABSTRACT;
                break;

            case TOKEN_STRUCTURAL:
                pClassInfo->dwType = CLASS_TYPE_STRUCTURAL;
                break;

            case TOKEN_AUXILIARY:
                pClassInfo->dwType = CLASS_TYPE_AUXILIARY;
                break;

            case TOKEN_MUST:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsMustContain),
                              &(pClassInfo->nNumOfMustContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            case TOKEN_MAY:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsMayContain),
                              &(pClassInfo->nNumOfMayContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            case TOKEN_X:
                //
                // This is provider specific info - parse and ignore.
                //
                hr = DirectoryStrings(
                         &Tokenizer,
                         &ppszDirStrings,
                         &dwCount
                         );
                //
                // If we could not process this then we need to BAIL
                // as the Tokenizer is not in a recoverable state.
                //
                BAIL_IF_ERROR(hr);
                
                if (ppszDirStrings) {
                    FreeDirectoryStrings(
                        ppszDirStrings,
                        dwCount
                        );
                    ppszDirStrings = NULL;
                }
                
                break;

            default:
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                break;
        }

        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//  Function:   DITContentRuleDescription
//
//  Synopsis:   Parses an DIT content rule description.
//              It parses the following grammar rules
//
// <DITContentDescription> ::= "("
//          <oid>   -- ObjectClass identifier
//          [ "NAME" <DirectoryStrings> ]
//          [ "DESC" <DirectoryString> ]
//          [ "OBSOLETE" ]
//          [ "AUX" <oids> ]    -- Auxiliary ObjectClasses
//          [ "MUST" <oids> ]   -- AttributeTypes
//          [ "MAY" <oids> ]    -- AttributeTypes
//          [ "NOT" <oids> ]    -- AttributeTypes
//      ")"
//
//  Arguments:  [LPTSTR] pszObjectClass : The string to parse
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    9-3-96   yihsins    Created.
//
//----------------------------------------------------------------------------
HRESULT
DITContentRuleDescription( LPTSTR pszObjectClass, PCLASSINFO pClassInfo,
                           SEARCHENTRY *aPropSearchTable,
                           DWORD dwSearchTableCount )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    CSchemaLexer Tokenizer;
    hr = Tokenizer.InitializePath(pszObjectClass);
    BAIL_IF_ERROR(hr);
    
    hr = Tokenizer.GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken != TOKEN_OPENBRACKET )
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    hr = Oid( &Tokenizer, &(pClassInfo->pszOID));
    BAIL_IF_ERROR(hr);

    while ( TRUE ) {

        hr = Tokenizer.GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if ( dwToken == TOKEN_IDENTIFIER )
            Tokenizer.IsKeyword( szToken, &dwToken );

        switch ( dwToken ) {
            case TOKEN_CLOSEBRACKET:
                RRETURN(S_OK);

            case TOKEN_NAME:
                hr = DirectoryString( &Tokenizer, NULL);
                // DirectoryStrings
                break;

            case TOKEN_DESC:
                hr = DirectoryString( &Tokenizer, NULL);
                break;

            case TOKEN_OBSOLETE:
                // rule is obsolete (RFC 2252)
                pClassInfo->fObsolete = TRUE;
                break;

            case TOKEN_AUX:
                hr = Oids(&Tokenizer, &(pClassInfo->pOIDsAuxClasses), NULL);
                break;

            case TOKEN_MUST:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsMustContain),
                              &(pClassInfo->nNumOfMustContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            case TOKEN_MAY:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsMayContain),
                              &(pClassInfo->nNumOfMayContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            case TOKEN_NOT:
                hr = PropOids(&Tokenizer, &(pClassInfo->pOIDsNotContain),
                              &(pClassInfo->nNumOfNotContain),
                              aPropSearchTable, dwSearchTableCount );
                break;

            default:
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                break;
        }

        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);

}

HRESULT
Oid(CSchemaLexer * pTokenizer, LPTSTR *ppszOID, BOOL fNoGuid )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    *ppszOID = NULL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken != TOKEN_IDENTIFIER )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        BAIL_IF_ERROR(hr);
    }

    //
    // Since some people do not like to have
    // an OID on all attributes, we need to work around them.
    // This should be changed once all schemas are compliant
    // AjayR 11-12-98.
    //
    if (fNoGuid && _wcsicmp(szToken, L"NAME") == 0) {
        *ppszOID = AllocADsStr(L"");
        pTokenizer->PushBackToken();
    } else
        *ppszOID = AllocADsStr( szToken );

    if ( *ppszOID == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

cleanup:

    if ( FAILED(hr))
    {
        if ( *ppszOID )
        {
            FreeADsStr( *ppszOID );
            *ppszOID = NULL;
        }
    }

    RRETURN(hr);

}

HRESULT
Oids(CSchemaLexer * pTokenizer, LPTSTR **pOIDs, DWORD *pnNumOfOIDs )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;
    DWORD nCount = 0;
    DWORD nCurrent = 0;

    LPTSTR * pTemp = NULL;

    *pOIDs = NULL;
    if ( pnNumOfOIDs )
        *pnNumOfOIDs = 0;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken == TOKEN_IDENTIFIER )
    {
        // All classes are subclasses of "top", and hence must contain
        // "objectClass" attribute. Add the "objectClass" attribute here
        // to prevent processing later.

        nCount = 2;

        *pOIDs = (LPTSTR *) AllocADsMem( sizeof(LPTSTR) * nCount);
        if ( *pOIDs == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        (*pOIDs)[nCurrent] = AllocADsStr( szToken );
        if ( (*pOIDs)[nCurrent] == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        (*pOIDs)[++nCurrent] = NULL;

    }
    else if ( dwToken == TOKEN_OPENBRACKET )
    {
        nCount = 10;
        *pOIDs = (LPTSTR *) AllocADsMem( sizeof(LPTSTR) * nCount);
        if ( *pOIDs == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        do {

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

            if ( dwToken == TOKEN_IDENTIFIER )
            {
                if ( nCurrent == nCount )
                {
                    pTemp = (LPTSTR *) ReallocADsMem( *pOIDs,
                                          sizeof(LPTSTR) * nCount,
                                          sizeof(LPTSTR) * nCount * 2);
                    if ( pTemp == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                        BAIL_IF_ERROR(hr);
                    }
                    *pOIDs = pTemp;
                    pTemp = NULL;

                    nCount *= 2;

                }

                (*pOIDs)[nCurrent] = AllocADsStr( szToken );
                if ( (*pOIDs)[nCurrent] == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_IF_ERROR(hr);
                }
                nCurrent++;
            }

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

        } while ( dwToken == TOKEN_DOLLAR );

        if ( dwToken != TOKEN_CLOSEBRACKET )
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            BAIL_IF_ERROR(hr);
        }

        if ( nCurrent == nCount )
        {
            // Need one extra NULL entry at the end of the array
            pTemp = (LPTSTR *) ReallocADsMem( *pOIDs,
                                      sizeof(LPTSTR) * nCount,
                                      sizeof(LPTSTR) * (nCount + 1));

            if ( pTemp == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_IF_ERROR(hr);
            }
            *pOIDs = pTemp;
            pTemp = NULL;

            nCount += 1;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        BAIL_IF_ERROR(hr);
    }

    if ( pnNumOfOIDs )
        *pnNumOfOIDs = nCurrent;

cleanup:

    if ( FAILED(hr))
    {
        if ( *pOIDs )
        {
            for ( DWORD i = 0; i < nCount; i++ )
            {
                if ( (*pOIDs)[i] )
                    FreeADsStr( (*pOIDs)[i] );
            }
            FreeADsMem( *pOIDs );
            *pOIDs = NULL;
        }
    }

    RRETURN(hr);
}

HRESULT
PropOids(CSchemaLexer * pTokenizer, int **pOIDs, DWORD *pnNumOfOIDs,
         SEARCHENTRY *aPropSearchTable, DWORD dwSearchTableCount )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;
    DWORD nCount = 0;
    DWORD nCurrent = 0;

    int * pTemp = NULL;

    *pOIDs = NULL;
    if ( pnNumOfOIDs )
        *pnNumOfOIDs = 0;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken == TOKEN_IDENTIFIER )
    {
        int nIndex = FindSearchTableIndex( szToken,
                                           aPropSearchTable,
                                           dwSearchTableCount );

        if ( nIndex != -1 )
        {
            nCount = 2;

            *pOIDs = (int *) AllocADsMem( sizeof(int) * nCount);
            if ( *pOIDs == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_IF_ERROR(hr);
            }

            (*pOIDs)[nCurrent] = nIndex;
            (*pOIDs)[++nCurrent] = -1;
        }

    }
    else if ( dwToken == TOKEN_OPENBRACKET )
    {
        nCount = 10;
        *pOIDs = (int *) AllocADsMem( sizeof(int) * nCount);
        if ( *pOIDs == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }

        do {

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

            if ( dwToken == TOKEN_CLOSEBRACKET )
            {
                FreeADsMem( *pOIDs );
                *pOIDs = NULL;
                goto cleanup;
            }

            if ( dwToken == TOKEN_IDENTIFIER )
            {
                int nIndex = FindSearchTableIndex( szToken,
                                                   aPropSearchTable,
                                                   dwSearchTableCount );

                if ( nIndex != -1 )
                {
                    if ( nCurrent == nCount )
                    {
                        pTemp = (int *) ReallocADsMem( *pOIDs,
                                              sizeof(int) * nCount,
                                              sizeof(int) * nCount * 2);
                        if ( pTemp == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                            BAIL_IF_ERROR(hr);
                        }

                        *pOIDs = pTemp;
                        pTemp = NULL;

                        nCount *= 2;

                    }

                    (*pOIDs)[nCurrent++] = nIndex;
                }

                // else we cannot find the property, so skip over it.
            }

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

        } while ( dwToken == TOKEN_DOLLAR );

        if ( dwToken != TOKEN_CLOSEBRACKET )
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            BAIL_IF_ERROR(hr);
        }

        if ( nCurrent == nCount )
        {
            // Need one extra NULL entry at the end of the array
            pTemp = (int *) ReallocADsMem( *pOIDs,
                                      sizeof(int) * nCount,
                                      sizeof(int) * (nCount + 1));

            if ( pTemp == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_IF_ERROR(hr);
            }

            *pOIDs = pTemp;
            pTemp = NULL;

            nCount += 1;
        }

        (*pOIDs)[nCurrent] = -1;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        BAIL_IF_ERROR(hr);
    }

    if ( pnNumOfOIDs )
        *pnNumOfOIDs = nCurrent;

cleanup:

    if ( FAILED(hr))
    {
        if ( *pOIDs )
        {
            FreeADsMem( *pOIDs );
            *pOIDs = NULL;
        }
    }

    RRETURN(hr);
}

HRESULT
DirectoryString(CSchemaLexer * pTokenizer, LPTSTR *ppszDirString )
{
    TCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    if ( ppszDirString )
        *ppszDirString = NULL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if ( dwToken == TOKEN_QUOTE )
    {
        hr = pTokenizer->GetNextToken2(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if ( dwToken == TOKEN_IDENTIFIER )
        {
            if ( ppszDirString )
            {
                *ppszDirString = AllocADsStr( szToken );
                if ( *ppszDirString == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_IF_ERROR(hr);
                }
            }

            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);

            if ( dwToken == TOKEN_QUOTE )
                RRETURN(S_OK);
        }
    }

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

cleanup:

    if ( FAILED(hr))
    {
        if ( ppszDirString && *ppszDirString )
        {
            FreeADsStr( *ppszDirString );
            *ppszDirString = NULL;
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   DirectoryStrings
//
// Synopsis:   This function is used to process ldap schema elements 
//          of the form qdstrings. This is defined in the RFC in detail :
//
//    space           = 1*" "
//    whsp            = [ space ]
//    utf8            = <any sequence of octets formed from the UTF-8 [9]
//                       transformation of a character from ISO10646 [10]>
//    dstring         = 1*utf8
//    qdstring        = whsp "'" dstring "'" whsp
//    qdstringlist    = [ qdstring *( qdstring ) ]
//    qdstrings       = qdstring / ( whsp "(" qdstringlist ")" whsp )
//
// Arguments:  pTokenizer       -   The schema lexer object to use.
//             pppszDirStrings  -   Return value for strings.
//             pdwCount         -   Return value of number of strings.
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   N/A.
//
// History:    7-12-2000 AjayR created.
//
//----------------------------------------------------------------------------
HRESULT
DirectoryStrings(
    CSchemaLexer * pTokenizer,
    LPTSTR **pppszDirStrings,
    PDWORD pdwCount
    )
{
    HRESULT hr = S_OK;
    TCHAR szToken[MAX_TOKEN_LENGTH];
    LPWSTR *ppszTmp = NULL;
    LPWSTR pszTmp = NULL;
    DWORD dwToken, dwNumStrings = 0;
    BOOL fNeedCloseBracket = FALSE;

    ADsAssert(pTokenizer);
    ADsAssert(pdwCount);

    DWORD dwDummy = sizeof(ADS_ATTR_INFO);
    *pdwCount = 0;
    //
    // Get the token type of the first token.
    //
    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_ON_FAILURE(hr);

    if (dwToken == TOKEN_OPENBRACKET) {
        //
        // In this case we know that there is more than one string.
        // We can ignore the open bracket and continue to the next
        // token which should be a quote.
        //
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_ON_FAILURE(hr);

        fNeedCloseBracket = TRUE;
    }

    //
    // Need to push what should be the quote in either case,
    // back into the tokenizer (only then will the dirString
    // routine work correctly.
    //
    hr = pTokenizer->PushBackToken();
    BAIL_ON_FAILURE(hr);

    if ( dwToken != TOKEN_QUOTE ) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // While there remain strings to be processed.
    //
    while (dwToken == TOKEN_QUOTE) {
    
        hr = DirectoryString(
                 pTokenizer,
                 &pszTmp
                 );
        BAIL_ON_FAILURE(hr);
    
        if (dwNumStrings == 0) {
            //
            // Since we NULL terminate the array it should have
            // at least 2 elements in this case.
            //
            ppszTmp = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * 2);
            if (!ppszTmp) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        } 
        else {
            LPWSTR *ppszLocal;
            //
            // To avoid passing the variable itself to local alloc.
            //
            ppszLocal = (LPWSTR *) ReallocADsMem(
                                       ppszTmp,
                                       sizeof(LPWSTR) * (dwNumStrings + 1),
                                       sizeof(LPWSTR) * (dwNumStrings + 2)
                                       );
            if (ppszLocal) {
                ppszTmp = ppszLocal;
            } 
            else {
                //
                // Realloc failed, the old ptr is still valid.
                //
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }
    
        ppszTmp[dwNumStrings] = pszTmp;
        ppszTmp[++dwNumStrings] = NULL;
    
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_ON_FAILURE(hr);
    
        pTokenizer->PushBackToken();
    } // end of while.

    //
    // If this was qdescrs and not just qdstring.
    //
    if (fNeedCloseBracket) {
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_ON_FAILURE(hr);

        if (dwToken != TOKEN_CLOSEBRACKET) {
            //
            // Not properly formed - should be just ignore ?
            //
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

    //
    // The count is the actual number not including the NULL string.
    //
    *pdwCount = dwNumStrings;
    *pppszDirStrings = ppszTmp;

error:
    if (FAILED(hr)) {
        if (ppszTmp) {
            //
            // Free the strings if any and then the array itself.
            //
            for (DWORD dwCount = 0; dwCount < dwNumStrings; dwCount++) {
                if (ppszTmp[dwCount]) {
                    FreeADsStr(ppszTmp[dwCount]);
                }
            }
            FreeADsMem(ppszTmp);
            ppszTmp = NULL;
        }
        //
        // Need to reset the count.
        //
        *pdwCount = 0;
    }


    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   FreeDirectoryStrings
//
// Synopsis:   This function is used to free the entries returned from
//          the DirectoryStrings routine.
//
// Arguments:  ppszDirStrings    -   List of strings to free.
//             dwCount           -   Number of strings to free.
//             fSkipFirstElement -   If true, do not free the 1st element.
//
//
// Returns:    N/A.
//
// Modifies:   ppszDirStrings contents is freed including the array.
//
// History:    8-01-2000 AjayR created.
//
//----------------------------------------------------------------------------
void FreeDirectoryStrings(
    LPTSTR *ppszDirStrings,
    DWORD dwCount,
    DWORD dwElementsToFree
    )
{
    DWORD dwCtr;
    if (!ppszDirStrings) {
        return;
    }

    switch (dwElementsToFree) {
    
    case FREE_ALL_BUT_FIRST :
        dwCtr = 1;
        break;

    case FREE_ALL :
        dwCtr = 0;
        break;
        
    case FREE_ARRAY_NOT_ELEMENTS :
        dwCtr = dwCount;
        break;
    }

    for (; dwCtr < dwCount; dwCtr++) {
        if (ppszDirStrings[dwCtr]) {
            FreeADsStr(ppszDirStrings[dwCtr]);
            ppszDirStrings[dwCtr] = NULL;
        }
    }

    FreeADsMem(ppszDirStrings);
    return;
}

//+---------------------------------------------------------------------------
// Function:   AddNewNamesToPropertyArray   --- Helper function.
//
// Synopsis:   This function adds new entries to the property info array.
//          Specifically, this fn is called when there are multiple names
//          associated with the description of a single property. The new
//          entries will have the same information as the current element
//          but the appropriate new name.
//
// Arguments:  ppPropArray       -   Property array containing current
//                                 elements. This array is updated to contain
//                                 the new elements on success and is
//                                 untouched otherwise.
//             dwCurPos          -   The current element being processed.
//             dwCount          -    The current count of elements.
//             ppszNewNames      -   Array of names to add (1st element is
//                                 already a part of the property array).
//
// Returns:    S_OK or E_OUTOFMEMORY.
//
// Modifies:   *ppPropArray is modified in all success cases and some failure
//          cases (realloc succeeds but not the subsequent string allocs).
//
// History:    10-03-2000 AjayR created.
//
//----------------------------------------------------------------------------
HRESULT 
AddNewNamesToPropertyArray(
    PROPERTYINFO **ppPropArray,
    DWORD dwCurPos,
    DWORD dwCount,
    LPWSTR *ppszNewNames,
    DWORD dwNewNameCount
    )
{
    HRESULT hr = S_OK;
    PPROPERTYINFO pNewPropArray = NULL;
    DWORD dwAdditions = 0;
    DWORD dwCurCount = dwCount;

    //
    // The first element is already in the array.
    //
    dwAdditions = --dwNewNameCount;

    if (!dwNewNameCount) {
        RRETURN(hr);
    }

    //
    // We need to realloc the new array and copy over the new elements.
    //
    pNewPropArray = (PROPERTYINFO *) 
                    ReallocADsMem(
                        *ppPropArray,
                        (dwCurCount) * sizeof(PROPERTYINFO),
                        (dwCurCount + dwAdditions) * sizeof(PROPERTYINFO)
                        );
    if (!pNewPropArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // If the alloc succeeded we must return the new array.
    //
    *ppPropArray = pNewPropArray;

    for (DWORD dwCtr = 0; dwCtr < dwAdditions; dwCtr++ ) {
        PROPERTYINFO propOriginal = pNewPropArray[dwCurPos];
        PROPERTYINFO *pPropNew = pNewPropArray + (dwCurPos + dwCtr + 1);

        //
        // Copy over the property. First all data that is not ptrs.
        //
        pPropNew->lMaxRange = propOriginal.lMaxRange;
        pPropNew->lMinRange = propOriginal.lMinRange;
        pPropNew->fSingleValued = propOriginal.fSingleValued;

        pPropNew->fObsolete = propOriginal.fObsolete;
        pPropNew->fCollective = propOriginal.fCollective;
        pPropNew->fDynamic = propOriginal.fDynamic;
        
        pPropNew->fNoUserModification = propOriginal.fNoUserModification;
        pPropNew->dwUsage = propOriginal.dwUsage;
        pPropNew->fProcessedSuperiorClass = propOriginal.fProcessedSuperiorClass;

        //
        // Now the strings.
        //
        pPropNew->pszOID = AllocADsStr(propOriginal.pszOID);
        if (propOriginal.pszOID && !pPropNew->pszOID) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pPropNew->pszSyntax = AllocADsStr(propOriginal.pszSyntax);
        if (propOriginal.pszSyntax && !pPropNew->pszSyntax) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        pPropNew->pszDescription = AllocADsStr(propOriginal.pszDescription);
        if (propOriginal.pszDescription && !pPropNew->pszDescription) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        pPropNew->pszOIDSup = AllocADsStr(propOriginal.pszOIDSup);
        if (propOriginal.pszOIDSup && !pPropNew->pszOIDSup) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pPropNew->pszOIDEquality = AllocADsStr(propOriginal.pszOIDEquality);
        if (propOriginal.pszOIDEquality && !pPropNew->pszOIDEquality) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pPropNew->pszOIDOrdering = AllocADsStr(propOriginal.pszOIDOrdering);
        if (propOriginal.pszOIDOrdering && !pPropNew->pszOIDOrdering) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pPropNew->pszOIDSubstr = AllocADsStr(propOriginal.pszOIDSubstr);
        if (propOriginal.pszOIDSubstr && !pPropNew->pszOIDSubstr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        //
        // This is just a copy from the array.
        //
        pPropNew->pszPropertyName = ppszNewNames[dwCtr + 1];
    }

    //
    // Success case.
    //
    RRETURN(hr);

error:

    //
    // Something failed, try and cleanup some pieces
    //
    if (pNewPropArray && (dwCtr != (DWORD)-1) ) {
        //
        // Cleanup the new elements added.
        //
        for (DWORD i = 0; i <= dwCtr; i++) {
            PROPERTYINFO *pPropFree = pNewPropArray + (dwCurPos + i + 1);
            //
            // Free all the strings in this element except name.
            //
            if (pPropFree->pszOID) {
                FreeADsStr(pPropFree->pszOID);
                pPropFree->pszOID = NULL;
            }

            if (pPropFree->pszSyntax) {
                FreeADsStr(pPropFree->pszSyntax);
                pPropFree->pszSyntax = NULL;
            }

            if (pPropFree->pszDescription) {
                FreeADsStr(pPropFree->pszDescription);
                pPropFree->pszDescription = NULL;
            }
            
            if (pPropFree->pszOIDSup) {
                FreeADsStr(pPropFree->pszOIDSup);
                pPropFree->pszOIDSup = NULL;
            }

            if (pPropFree->pszOIDEquality) {
                FreeADsStr(pPropFree->pszOIDEquality);
                pPropFree->pszOIDEquality = NULL;
            }

            if (pPropFree->pszOIDOrdering) {
                FreeADsStr(pPropFree->pszOIDOrdering);
                pPropFree->pszOIDOrdering = NULL;
            }

            if (pPropFree->pszOIDSubstr) {
                FreeADsStr(pPropFree->pszOIDSubstr);
                pPropFree->pszOIDSubstr = NULL;
            }
        } // for
    } // if we have elements to free

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   AddNewNamesToClassArray   --- Helper function.
//
// Synopsis:   This function adds new entries to the class info array.
//          Specifically, this fn is called when there are multiple names
//          associated with the description of a single class. The new
//          entries will have the same information as the current element
//          but the appropriate new name.
//
// Arguments:  ppClassArray      -   Class array containing current
//                                 elements. This array is updated to contain
//                                 the new elements on success and is
//                                 untouched otherwise.
//             dwCurPos          -   The current element being processed.
//             dwCount           -    The current count of elements.
//             ppszNewNames      -   Array of names to add (1st element is
//                                 already a part of the property array).
//             dwNewNameCount    -   Number of elements in the new array.
//
// Returns:    N/A.
//
// Modifies:   *ppClassArray always on success and in some failure cases.
//
// History:    10-06-2000 AjayR created.
//
//----------------------------------------------------------------------------
HRESULT
AddNewNamesToClassArray(
    CLASSINFO **ppClassArray,
    DWORD dwCurPos,
    DWORD dwCount,
    LPWSTR *ppszNewNames,
    DWORD dwNewNameCount
    )
{
    HRESULT hr = S_OK;
    PCLASSINFO pNewClassArray = NULL;
    DWORD dwAdditions = 0;
    DWORD dwCurCount = dwCount;
    int nCount;

    //
    // The first element is already in the array.
    //
    dwAdditions = --dwNewNameCount;

    if (!dwNewNameCount) {
        RRETURN(hr);
    }

    //
    // We need to realloc the new array and copy over the new elements.
    //
    pNewClassArray = (CLASSINFO *) 
                     ReallocADsMem(
                         *ppClassArray,
                         (dwCurCount) * sizeof(CLASSINFO),
                         (dwCurCount + dwAdditions) * sizeof(CLASSINFO)
                         );
    if (!pNewClassArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // If the alloc succeeded we must return the new array.
    //
    *ppClassArray = pNewClassArray;

    for (DWORD dwCtr = 0; dwCtr < dwAdditions; dwCtr++ ) {
        CLASSINFO classOriginal = pNewClassArray[dwCurPos];
        CLASSINFO *pClassNew = pNewClassArray + (dwCurPos + dwCtr + 1);

        //
        // Copy over the property. First all data that is not ptrs.
        //
        pClassNew->dwType = classOriginal.dwType;
        pClassNew->lHelpFileContext = classOriginal.lHelpFileContext;
        pClassNew->fObsolete = classOriginal.fObsolete;

        pClassNew->fProcessedSuperiorClasses = 
            classOriginal.fProcessedSuperiorClasses;
        pClassNew->IsContainer = classOriginal.IsContainer;

        //
        // Now the strings and other pointers.
        //
        pClassNew->pszOID = AllocADsStr(classOriginal.pszOID);
        if (classOriginal.pszOID && !pClassNew->pszOID) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        //
        // The GUIDs are not copied over as they are not used or freed.
        //
        
        pClassNew->pszHelpFileName = AllocADsStr(classOriginal.pszHelpFileName);
        if (classOriginal.pszHelpFileName && !pClassNew->pszHelpFileName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassNew->pszDescription = AllocADsStr(classOriginal.pszDescription);
        if (classOriginal.pszDescription && !pClassNew->pszDescription) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        //
        // pOIDsSuperiorClasses and pOIDsAuxClasses are arrays.
        //
        if (classOriginal.pOIDsSuperiorClasses) {
            pClassNew->pOIDsSuperiorClasses = 
                CopyStringArray(classOriginal.pOIDsSuperiorClasses);

            if (!pClassNew->pOIDsSuperiorClasses) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        if (classOriginal.pOIDsAuxClasses) {
            pClassNew->pOIDsAuxClasses = 
                CopyStringArray(classOriginal.pOIDsAuxClasses);

            if (!pClassNew->pOIDsAuxClasses) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        //
        // Now the int arrays. Note that all of these will tag on the
        // the last element (-1), -1 is not included in the count.
        //
        if (classOriginal.pOIDsMustContain) {

            nCount = classOriginal.nNumOfMustContain + 1;
            pClassNew->pOIDsMustContain = 
                (int *) AllocADsMem(sizeof(int) * nCount);

            if (!pClassNew->pOIDsMustContain) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pClassNew->pOIDsMustContain,
                classOriginal.pOIDsMustContain,
                sizeof(int) * nCount
                );

            pClassNew->nNumOfMustContain = --nCount;
        }

        if (classOriginal.pOIDsMayContain) {

            nCount = classOriginal.nNumOfMayContain + 1;
            pClassNew->pOIDsMayContain = 
                (int *) AllocADsMem(sizeof(int) * nCount);

            if (!pClassNew->pOIDsMayContain) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pClassNew->pOIDsMayContain,
                classOriginal.pOIDsMayContain,
                sizeof(int) * nCount
                );
            pClassNew->nNumOfMayContain = --nCount;
        }

        if (classOriginal.pOIDsNotContain) {
            
            nCount = classOriginal.nNumOfNotContain + 1;
            pClassNew->pOIDsNotContain = 
                (int *) AllocADsMem(sizeof(int) * nCount);
            
            if (!pClassNew->pOIDsNotContain) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pClassNew->pOIDsNotContain,
                classOriginal.pOIDsNotContain,
                sizeof(int) * nCount
                );
            pClassNew->nNumOfNotContain = --nCount;
        }


        //
        // This is just a copy from the array.
        //
        pClassNew->pszName = ppszNewNames[dwCtr + 1];
    }

    //
    // Success case.
    //
    RRETURN(hr);

error:

    //
    // Something failed, try and cleanup some pieces
    //
    if (pNewClassArray && (dwCtr != (DWORD)-1) ) {
        //
        // Cleanup the new elements added.
        //
        for (DWORD i = 0; i <= dwCtr; i++) {
            CLASSINFO *pClassFree = pNewClassArray + (dwCurPos + i + 1);
            //
            // Free all the strings in this element except name.
            //
            if (pClassFree->pszOID) {
                FreeADsStr(pClassFree->pszOID);
                pClassFree->pszOID = NULL;
            }

            if (pClassFree->pszHelpFileName) {
                FreeADsStr(pClassFree->pszHelpFileName);
                pClassFree->pszHelpFileName = NULL;
            }

            if (pClassFree->pszDescription) {
                FreeADsStr(pClassFree->pszDescription);
                pClassFree->pszDescription = NULL;
            }
            
            //
            // Now the string arrays.
            //
            if (pClassFree->pOIDsSuperiorClasses) {
                nCount = 0;
                LPTSTR pszTemp;
                
                while (pszTemp = (pClassFree->pOIDsSuperiorClasses)[nCount]) {
                    FreeADsStr(pszTemp);
                    nCount++;
                }

                FreeADsMem(pClassFree->pOIDsSuperiorClasses);
                pClassFree->pOIDsSuperiorClasses = NULL;
            }

            if (pClassFree->pOIDsAuxClasses) {
                nCount = 0;
                LPTSTR pszTemp;

                while (pszTemp = (pClassFree->pOIDsAuxClasses)[nCount]) {
                    FreeADsStr(pszTemp);
                    nCount++;
                }
                FreeADsMem(pClassFree->pOIDsAuxClasses);
                pClassFree->pOIDsAuxClasses = NULL;
            }

            if (pClassFree->pOIDsMustContain) {
                FreeADsMem(pClassFree->pOIDsMustContain);
                pClassFree->pOIDsMustContain = NULL;
                pClassFree->nNumOfMustContain = 0;
            }

            if (pClassFree->pOIDsMayContain) {
                FreeADsMem(pClassFree->pOIDsMayContain);
                pClassFree->pOIDsMayContain = NULL;
                pClassFree->nNumOfMayContain = 0;
            }

            if (pClassFree->pOIDsNotContain) {
                FreeADsMem(pClassFree->pOIDsNotContain);
                pClassFree->pOIDsNotContain = NULL;
                pClassFree->nNumOfNotContain = 0;
            }

        } // for
    } // if we have elements to free

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CSchemaLexer::CSchemaLexer():
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _fInQuotes(FALSE)
{}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CSchemaLexer::~CSchemaLexer()
{
    FreeADsStr(_Buffer);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CSchemaLexer::GetNextToken(LPTSTR szToken, LPDWORD pdwToken)
{
    TCHAR c;
    DWORD state = 0;
    LPTSTR pch = szToken;

    memset(szToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    _dwLastTokenLength = 0;

    while (1) {
        c = NextChar();
        switch (state) {

        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            switch (c) {
            case TEXT('(') :
                *pdwToken = TOKEN_OPENBRACKET;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(')') :
                *pdwToken = TOKEN_CLOSEBRACKET;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('\'') :
                *pdwToken = TOKEN_QUOTE;
                _dwLastToken = *pdwToken;
                _fInQuotes = !_fInQuotes;
                RRETURN(S_OK);
                break;

            case TEXT('$') :
                *pdwToken = TOKEN_DOLLAR;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(' ') :
                pch--;
                _dwLastTokenLength--;
                break;

            case TEXT('\0') :
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('{') :
                *pdwToken = TOKEN_OPEN_CURLY;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('}') :
                *pdwToken = TOKEN_CLOSE_CURLY;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            default:
                state = 1;
                break;

            } // end of switch c
            break;

        case 1:
            switch (c) {
            case TEXT('(')  :
            case TEXT(')')  :
            case TEXT('\'') :
            case TEXT('$')  :
            case TEXT(' ')  :
            case TEXT('\0') :
            case TEXT('{')  :
            case TEXT('}')  :

                if ( _fInQuotes && c != TEXT('\''))
                {
                    if ( c == TEXT('\0'))
                        RRETURN(E_FAIL);

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;
                }
                else // Not in quotes or in quotes and reach the matching quote
                {
                    PushbackChar();
                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN (S_OK);
                }
                break;

            default :
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            } // switch c

            break;

        default:
            RRETURN(E_FAIL);
        } // switch state
    }
}

HRESULT
CSchemaLexer::GetNextToken2(LPTSTR szToken, LPDWORD pdwToken)
{
    TCHAR c;
    DWORD state = 0;
    LPTSTR pch = szToken;

    memset(szToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    _dwLastTokenLength = 0;

    while (1) {
        c = NextChar();
        switch (state) {

        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            switch (c) {
            case TEXT('(') :
                *pdwToken = TOKEN_OPENBRACKET;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(')') :
                *pdwToken = TOKEN_CLOSEBRACKET;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('\'') :
                *pdwToken = TOKEN_QUOTE;
                _dwLastToken = *pdwToken;
                _fInQuotes = !_fInQuotes;
                RRETURN(S_OK);
                break;

            case TEXT('$') :
                *pdwToken = TOKEN_DOLLAR;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('\0') :
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('{') :
                *pdwToken = TOKEN_OPEN_CURLY;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('}') :
                *pdwToken = TOKEN_CLOSE_CURLY;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            default:
                state = 1;
                break;

            } // end of switch c
            break;

        case 1:
            switch (c) {
            case TEXT('(')  :
            case TEXT(')')  :
            case TEXT('\'') :
            case TEXT('$')  :
            case TEXT(' ')  :
            case TEXT('\0') :
            case TEXT('{')  :
            case TEXT('}')  :

                if ( _fInQuotes && c != TEXT('\''))
                {
                    if ( c == TEXT('\0'))
                        RRETURN(E_FAIL);

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;
                }
                else // Not in quotes or in quotes and reach the matching quote
                {
                    PushbackChar();
                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN (S_OK);
                }
                break;

            default :
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            } // switch c

            break;

        default:
            RRETURN(E_FAIL);
        } // switch state
    }
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
TCHAR
CSchemaLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == TEXT('\0')) {
        _dwEndofString = TRUE;
        return(TEXT('\0'));
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis: ONLY ONE TOKEN CAN BE PUSHED BACK.
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//

//----------------------------------------------------------------------------
HRESULT
CSchemaLexer::PushBackToken()
{

    DWORD i = 0;

    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }

    for (i=0; i < _dwLastTokenLength; i++) {
        if (*(--_ptr) == TEXT('\'') )  {
            _fInQuotes = !_fInQuotes;
        }
    }

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CSchemaLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CSchemaLexer::IsKeyword(LPTSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < g_dwSchemaKeywordListSize; i++) {
        if (!_tcsicmp(szToken, g_aSchemaKeywordList[i].Keyword)) {
            *pdwToken = g_aSchemaKeywordList[i].dwTokenId;
            return(TRUE);
        } 
        else if (!_wcsnicmp(szToken, L"X-", 2)) {
            //
            // Terms begining with X- are special tokens for schema.
            //
            *pdwToken = TOKEN_X;
            return(TRUE);                 
        }
    }
    *pdwToken = 0;
    return(FALSE);
}

HRESULT
CSchemaLexer::InitializePath(LPTSTR szBuffer)
{
    HRESULT hr = S_OK;
    
    _Buffer = AllocADsStr(szBuffer);
    if(!_Buffer && szBuffer)
    {
        hr = E_OUTOFMEMORY; 
    }
    _ptr = _Buffer;

    return hr;
}

int _cdecl searchentrycmp( const void *s1, const void *s2 )
{
    SEARCHENTRY *srch1 = (SEARCHENTRY *) s1;
    SEARCHENTRY *srch2 = (SEARCHENTRY *) s2;

    return ( _tcsicmp( srch1->pszName, srch2->pszName ));
}

int _cdecl intcmp( const void *s1, const void *s2 )
{
    int n1 = *((int *) s1);
    int n2 = *((int *) s2);
    int retval;

    if ( n1 == n2 )
        retval = 0;
    else if ( n1 < n2 )
        retval = -1;
    else
        retval = 1;

    return retval;
}


long CompareUTCTime(
    LPTSTR pszTime1,
    LPTSTR pszTime2
)
{
    SYSTEMTIME sysTime1;
    SYSTEMTIME sysTime2;
    FILETIME fTime1;
    FILETIME fTime2;

    memset( &sysTime1, 0, sizeof(sysTime1));
    memset( &sysTime2, 0, sizeof(sysTime2));

    //
    // We are ignoring the last part which might be a float.
    // The time window is sufficiently small for us not to
    // worry about this value.
    //
    _stscanf( pszTime1, TEXT("%4d%2d%2d%2d%2d%2d"),
              &sysTime1.wYear,
              &sysTime1.wMonth,
              &sysTime1.wDay,
              &sysTime1.wHour,
              &sysTime1.wMinute,
              &sysTime1.wSecond
              );

    _stscanf( pszTime2, TEXT("%4d%2d%2d%2d%2d%2d"),
              &sysTime2.wYear,
              &sysTime2.wMonth,
              &sysTime2.wDay,
              &sysTime2.wHour,
              &sysTime2.wMinute,
              &sysTime2.wSecond
              );

    if (  SystemTimeToFileTime( &sysTime1, &fTime1 )
       && SystemTimeToFileTime( &sysTime2, &fTime2 )
       )
    {
        return CompareFileTime( &fTime1, &fTime2 );
    }

    // If SystemTimeToFileTime failed, then assume that pszTime1 is in cache,
    // pszTime2 is on the server and if we cannot get the correct time, we
    // should always read from the server again. Hence, return -1;

    return -1;

}

int FindEntryInSearchTable( LPTSTR pszName, SEARCHENTRY *aSearchTable, DWORD nSearchTableSize)
{
    SEARCHENTRY searchEntry;
    SEARCHENTRY *matchedEntry = NULL;

    searchEntry.pszName = pszName;
    matchedEntry = (SEARCHENTRY *) bsearch(
                        (SEARCHENTRY *) &searchEntry,
                        aSearchTable, nSearchTableSize,
                        sizeof(SEARCHENTRY), searchentrycmp );

    if ( matchedEntry )
    {
        return matchedEntry->nIndex;
    }

    return -1;
}

int FindSearchTableIndex( LPTSTR pszName, SEARCHENTRY *aSearchTable, DWORD nSearchTableSize )
{
    SEARCHENTRY searchEntry;
    SEARCHENTRY *matchedEntry = NULL;

    searchEntry.pszName = pszName;
    matchedEntry = (SEARCHENTRY *) bsearch(
                        (SEARCHENTRY *) &searchEntry,
                        aSearchTable, nSearchTableSize,
                        sizeof(SEARCHENTRY), searchentrycmp );

    if ( matchedEntry )
    {
        return (int)( matchedEntry - aSearchTable );  // return index of search table
    }

    return -1;
}


HRESULT
ReadSubSchemaSubEntry(
    LPWSTR pszLDAPServer,
    LPWSTR * ppszSubSchemaEntry,
    OUT BOOL *pfBoundOk,           // have we at least once bound to domain
                                   // successfully, OPTIONAL (can be NULL)
    CCredentials& Credentials,
    DWORD dwPort
    )
{

    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(ppszSubSchemaEntry);

    *ppszSubSchemaEntry = NULL;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             pfBoundOk,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( !rootDSE.pszSubSchemaEntry ) {
        //
        // SubschemaEntry must be found
        //

        BAIL_ON_FAILURE(hr = E_FAIL);
    }
    else {
        *ppszSubSchemaEntry = rootDSE.pszSubSchemaEntry;
    }


error:

    RRETURN(hr);
}


HRESULT
ReadPagingSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfPagingSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfPagingSupported);
    *pfPagingSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfPagingSupported = rootDSE.fPagingSupported;

error:

    RRETURN(hr);
}


HRESULT
ReadSortingSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfSortingSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfSortingSupported);
    *pfSortingSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfSortingSupported = rootDSE.fSortingSupported;

error:

    RRETURN(hr);
}


HRESULT
ReadAttribScopedSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfAttribScopedSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfAttribScopedSupported);
    *pfAttribScopedSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfAttribScopedSupported = rootDSE.fAttribScopedSupported;

error:

    RRETURN(hr);
}


HRESULT
ReadVLVSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfVLVSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfVLVSupported);
    *pfVLVSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfVLVSupported = rootDSE.fVLVSupported;

error:

    RRETURN(hr);
}


//
// Returns the info about SecDesc Control if appropriate
//
HRESULT
ReadSecurityDescriptorControlType(
    LPWSTR pszLDAPServer,
    DWORD * pdwSecDescType,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pdwSecDescType);
    *pdwSecDescType = ADSI_LDAPC_SECDESC_NONE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pdwSecDescType = rootDSE.dwSecDescType;

error:

    //
    // Since the error case is uninteresting, if there was an
    // error, we will continue with no sec desc
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE))
        RRETURN (S_OK);
    else
        RRETURN(hr);
}


//
// This is to see if we support the domain scope control.
// If we do we can set it to reduce server load.
//
HRESULT
ReadDomScopeSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfDomScopeSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfDomScopeSupported);
    *pfDomScopeSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfDomScopeSupported = rootDSE.fDomScopeSupported;

error:

    RRETURN(hr);
}


//
// This is to see if we support the domain scope control.
// If we do we can set it to reduce server load.
//
HRESULT
ReadServerSupportsIsADControl(
    LPWSTR pszLDAPServer,
    BOOL * pfServerIsAD,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfServerIsAD);
    *pfServerIsAD = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfServerIsAD = rootDSE.fTalkingToAD;

error:

    RRETURN(hr);
}

//
// This is to see if we are talking to enhacned AD servers so we 
// can process the aux classes correctly.
//
HRESULT
ReadServerSupportsIsEnhancedAD(
    LPWSTR pszLDAPServer,
    BOOL * pfServerIsEnhancedAD,
    BOOL * pfServerIsADControl,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfServerIsEnhancedAD);
    ADsAssert(pfServerIsADControl);

    *pfServerIsEnhancedAD = FALSE;
    *pfServerIsADControl = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfServerIsEnhancedAD = rootDSE.fTalkingToEnhancedAD;
    *pfServerIsADControl = rootDSE.fTalkingToAD;

error:

    RRETURN(hr);
}

BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    )
{
    if (!pszTargetServer && !pszSourceServer) {
        return(TRUE);
    }

    if (pszTargetServer && pszSourceServer) {

#ifdef WIN95
        if (!_wcsicmp(pszTargetServer, pszSourceServer)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszTargetServer,
                -1,
                pszSourceServer,
                -1
                ) == CSTR_EQUAL ) {
#endif
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL
EquivalentUsers(
    LPWSTR pszUser1,
    LPWSTR pszUser2
    )
{
    if (!pszUser1 && !pszUser2) {
        return(TRUE);
    }

    if (pszUser1 && pszUser2) {

#ifdef WIN95
        if (!_wcsicmp(pszUser1, pszUser2)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszUser1,
                -1,
                pszUser2,
                -1
                ) == CSTR_EQUAL ) {
#endif
            return(TRUE);
        }
    }

    return(FALSE);
}

HRESULT
ReadRootDSENode(
    LPWSTR pszLDAPServer,
    PROOTDSENODE pRootDSE,
    OUT BOOL * pfBoundOk,           // have we at least once bound to domain
                                    // successfully, OPTIONAL (can be NULL)
    CCredentials& Credentials,
    DWORD dwPort
    )
{

    HRESULT hr = S_OK;

    PSCHEMALIST pTemp = NULL;
    PSCHEMALIST pNewNode = NULL;
    ADS_LDP * ld = NULL;
    int nCount1 = 0, nCount2 = 0, nCount3 = 0;
    LPWSTR *aValues1 = NULL, *aValues2 = NULL, *aValues3 = NULL;
    LDAPMessage * res = NULL;
    LDAPMessage *e = NULL;
    LPWSTR aStrings[4];             // Attributes to fetch.
    BOOL fBoundOk = FALSE;          // have we at least once bound to
                                    // domain successfully?
    BOOL fNoData = FALSE;

    ADsAssert(pRootDSE);

    memset (pRootDSE, 0x00, sizeof(ROOTDSENODE));

    ENTER_SUBSCHEMA_CRITSECT();

    pTemp = gpSubSchemaList;

    while (pTemp) {

        if (EquivalentServers(pszLDAPServer, pTemp->pszLDAPServer)){

            if (pTemp->fNoDataGot) {
                //
                // This is necessary for V2 server
                // If BoundOk is not set we may end up not loading
                // the default schema
                //
                fBoundOk = TRUE;

                LEAVE_SUBSCHEMA_CRITSECT();

                BAIL_ON_FAILURE(
                    hr = HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)
                    );
            }

            pRootDSE->fPagingSupported = pTemp->fPagingSupported;
            pRootDSE->fSortingSupported = pTemp->fSortingSupported;
            pRootDSE->fVLVSupported = pTemp->fVLVSupported;
            pRootDSE->fAttribScopedSupported = pTemp->fAttribScopedSupported;

            pRootDSE->dwSecDescType = pTemp->dwSecDescType;
            pRootDSE->fDomScopeSupported = pTemp->fDomScopeSupported;

            pRootDSE->fTalkingToAD = pTemp->fTalkingToAD;
            pRootDSE->fTalkingToEnhancedAD = pTemp->fTalkingToEnhancedAD;

            pRootDSE->fNoDataGot = pTemp->fNoDataGot;

            pRootDSE->pszSubSchemaEntry = AllocADsStr(pTemp->pszSubSchemaEntry);

            if (!pRootDSE->pszSubSchemaEntry) {

                hr = E_OUTOFMEMORY;
            }

            LEAVE_SUBSCHEMA_CRITSECT();

            //
            // we have at least once bound successfully to the domain
            //

            fBoundOk = TRUE;

            goto error;     // can't return direct, need clean up
       }

       pTemp = pTemp->pNext;

    }

    LEAVE_SUBSCHEMA_CRITSECT();

    hr = LdapOpenObject(
                pszLDAPServer,
                NULL,
                &ld,
                Credentials,
                dwPort
                );

    BAIL_ON_FAILURE(hr);

    //
    // we have once bound to the node successfully - just now
    //

    fBoundOk=TRUE;

    //
    // Ask only for the attributes we are intersted in.
    //
    aStrings[0] = LDAP_OPATT_SUBSCHEMA_SUBENTRY_W;
    aStrings[1] = LDAP_OPATT_SUPPORTED_CONTROL_W;
    aStrings[2] = LDAP_OPATT_SUPPORTED_CAPABILITIES_W;
    aStrings[3] = NULL;

    hr = LdapSearchS(
                ld,
                NULL,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                aStrings,
                0,
                &res );

    // Only one entry should be returned

    if (  FAILED(hr)
       || FAILED(hr = LdapFirstEntry( ld, res, &e ))
       )
    {
       goto error;
    }

    hr = LdapGetValues(
            ld,
            e,
            LDAP_OPATT_SUBSCHEMA_SUBENTRY_W,
            &aValues1,
            &nCount1
            );

    if (SUCCEEDED(hr) && nCount1==0) {
        //
        // No data flag indicates that we read nothing but the
        // search was a success.
        //
        fNoData = TRUE;

    }

    BAIL_ON_FAILURE(hr);


    hr = LdapGetValues(
            ld,
            e,
            LDAP_OPATT_SUPPORTED_CONTROL_W,
            &aValues2,
            &nCount2
            );

    //
    // okay to have no values for supportedControl
    //
    if (FAILED(hr)) {
        //
        // Reset the error because we were really succesful
        // in reading critical information.
        //
        hr = S_OK;
    }

    hr = LdapGetValues(
            ld,
            e,
            LDAP_OPATT_SUPPORTED_CAPABILITIES_W,
            &aValues3,
            &nCount3
            );

    //
    // okay to have no values for supportedControl
    //
    if (FAILED(hr)) {
        //
        // Reset the error because we were really succesful
        // in reading critical information.
        //
        hr = S_OK;
    }

    ENTER_SUBSCHEMA_CRITSECT();

    pTemp =  gpSubSchemaList;
    while (pTemp) {

        if (EquivalentServers(pszLDAPServer, pTemp->pszLDAPServer)) {
            //
            // Found a match -looks like someone has come in before us
            //
            if (pTemp->fNoDataGot) {
                //
                // This is necessary for V2 server
                //

                LEAVE_SUBSCHEMA_CRITSECT();
                
                BAIL_ON_FAILURE(
                    hr = HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)
                    );
            }

            pRootDSE->fPagingSupported = pTemp->fPagingSupported;
            pRootDSE->fSortingSupported = pTemp->fSortingSupported;
            pRootDSE->fVLVSupported = pTemp->fVLVSupported;
            pRootDSE->fAttribScopedSupported = pTemp->fAttribScopedSupported;
            
            pRootDSE->dwSecDescType = pTemp->dwSecDescType;
            pRootDSE->fDomScopeSupported = pTemp->fDomScopeSupported;

            pRootDSE->fTalkingToAD = pTemp->fTalkingToAD;
            pRootDSE->fTalkingToEnhancedAD = pTemp->fTalkingToEnhancedAD;

            pRootDSE->fNoDataGot = pTemp->fNoDataGot;

            pRootDSE->pszSubSchemaEntry = AllocADsStr(pTemp->pszSubSchemaEntry);

            if (!pRootDSE->pszSubSchemaEntry) {

                hr = E_OUTOFMEMORY;
            }

            LEAVE_SUBSCHEMA_CRITSECT();

            goto error;         // clean up first before return
        }

        pTemp = pTemp->pNext;

    }

    pNewNode = (PSCHEMALIST)AllocADsMem(sizeof(SCHEMALIST));

    if (!pNewNode) {

        hr = E_OUTOFMEMORY;
        LEAVE_SUBSCHEMA_CRITSECT();

        goto error;         // clean up first before return
    }

    pNewNode->pNext = gpSubSchemaList;

    pNewNode->pszLDAPServer = AllocADsStr(pszLDAPServer);

    if (aValues1 && aValues1[0]) {

        pNewNode->pszSubSchemaEntry = AllocADsStr(aValues1[0]);
        pNewNode->fNoDataGot = FALSE;
    }
    else {

        pNewNode->pszSubSchemaEntry = NULL;
        pNewNode->fNoDataGot = TRUE;
    }

    //
    // Default to this value
    //
    pNewNode->dwSecDescType = ADSI_LDAPC_SECDESC_NONE;

    if (aValues2) {

        for (int j=0; j<nCount2; j++) {

            if (_wcsicmp(aValues2[j], LDAP_PAGED_RESULT_OID_STRING_W) == 0) {
                pNewNode->fPagingSupported = TRUE;
            }
            else if (_wcsicmp(aValues2[j], LDAP_SERVER_SORT_OID_W) == 0) {
                pNewNode->fSortingSupported = TRUE;
            }
            else if (_wcsicmp(aValues2[j], LDAP_SERVER_SD_FLAGS_OID_W) == 0) {
                pNewNode->dwSecDescType = ADSI_LDAPC_SECDESC_NT;
            }
            else if (_wcsicmp(aValues2[j], ADSI_LDAP_OID_SECDESC_OLD) == 0) {
                pNewNode->dwSecDescType = ADSI_LDAPC_SECDESC_OTHER;
            }
            else if (_wcsicmp(aValues2[j], LDAP_SERVER_DOMAIN_SCOPE_OID_W)
                     == 0) {
                pNewNode->fDomScopeSupported = TRUE;
            }
            else if (_wcsicmp(aValues2[j], LDAP_CONTROL_VLVREQUEST_W) == 0) {
                pNewNode->fVLVSupported = TRUE;
            }
            else if (_wcsicmp(aValues2[j], LDAP_SERVER_ASQ_OID_W) == 0) {
                pNewNode->fAttribScopedSupported = TRUE;
            }
        }
    }
    else {

        pNewNode->fPagingSupported = FALSE;
        pNewNode->fSortingSupported = FALSE;
        pNewNode->fDomScopeSupported = FALSE;
        pNewNode->fVLVSupported = FALSE;
        pNewNode->fAttribScopedSupported = FALSE;
    }

    if (aValues3) {
        for (int j=0; j<nCount3; j++) {
            if (_wcsicmp(aValues3[j], LDAP_CAP_ACTIVE_DIRECTORY_OID_W)
                == 0) {
                pNewNode->fTalkingToAD = TRUE;
            } 
            else if (_wcsicmp(aValues3[j],
                              LDAP_CAP_ACTIVE_DIRECTORY_V51_OID_W)
                      == 0) {
                //
                // Replace with correct OID from ntldap.h.
                //
                pNewNode->fTalkingToEnhancedAD = TRUE;
            }
        }

    }
    else {
        //
        // Should already be false but just in case.
        //
        pNewNode->fTalkingToAD = FALSE;
        pNewNode->fTalkingToEnhancedAD = FALSE;
    }


    gpSubSchemaList = pNewNode;

    if (fNoData == FALSE) {

        pRootDSE->fPagingSupported = pNewNode->fPagingSupported;
        pRootDSE->fSortingSupported = pNewNode->fSortingSupported;
        pRootDSE->fVLVSupported = pNewNode->fVLVSupported;
        pRootDSE->fAttribScopedSupported = pNewNode->fAttribScopedSupported;

        pRootDSE->fNoDataGot = pNewNode->fNoDataGot;
        pRootDSE->dwSecDescType = pNewNode->dwSecDescType;
        pRootDSE->fDomScopeSupported = pNewNode->fDomScopeSupported;
        pRootDSE->fTalkingToAD = pNewNode->fTalkingToAD;
        pRootDSE->fTalkingToEnhancedAD = pNewNode->fTalkingToEnhancedAD;

        pRootDSE->pszSubSchemaEntry = AllocADsStr(pNewNode->pszSubSchemaEntry);

        if (!pRootDSE->pszSubSchemaEntry) {

            hr = E_OUTOFMEMORY;
        }
    }

    LEAVE_SUBSCHEMA_CRITSECT();

error:

    if (aValues1) {

        LdapValueFree(aValues1);
    }

    if (aValues2) {

        LdapValueFree(aValues2);
    }

    if (aValues3) {
        LdapValueFree(aValues3);
    }

    if (res) {

        LdapMsgFree(res);
    }

    if (ld) {

        LdapCloseObject(ld);
    }

    //
    // return to caller if we have at least once bound succsufully
    // to the node
    //

    if (pfBoundOk)
        *pfBoundOk = fBoundOk;

    //
    // Need to special case fNoData to ensure that the other code
    // that relies on this eCode from this routine continues to
    // work properly
    //
    if (fNoData) {
        RRETURN(HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE));
    } else
        RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

BOOL fInitializeCritSect = FALSE;

#if DBG==1

#include "formtrck.hxx"
extern "C" {
#include "caiheap.h"
}

extern CRITICAL_SECTION g_csDP;   // for debugprint
extern CRITICAL_SECTION g_csOT;   // for otracker
extern CRITICAL_SECTION g_csMem;  // for MemAlloc
#endif

extern CRITICAL_SECTION g_DomainDnsCache;
extern CRITICAL_SECTION  BindCacheCritSect ;
extern CRITICAL_SECTION  g_SchemaCritSect;
extern CRITICAL_SECTION  g_DefaultSchemaCritSect;
extern CRITICAL_SECTION  g_SubSchemaCritSect;

//
// External references to handles for libs we load dynamically.
//
extern HANDLE g_hDllNetApi32;
extern HANDLE g_hDllSecur32;

extern DWORD LsaDeregisterLogonProcessWrapper(
    IN HANDLE LsaHandle
    );

//
// Variables needed for localized strings.
//
WCHAR g_szNT_Authority[100];
BOOL g_fStringsLoaded = FALSE;


HINSTANCE g_hInst = NULL;

//
// LSA handle (needed by GetUserDomainFlatName)
//
extern HANDLE g_hLsa;

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     AllocArenaDump( NULL );
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    DWORD dwCritSectIniStage = 0;     

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Need to handle case of crit sect init failing.
        //
        __try {       
 
            InitADsMem() ;
 
            //
            // Initialize the error records
            //
            memset(&ADsErrorRecList, 0, sizeof(ERROR_RECORD));

            InitializeCriticalSection(&ADsErrorRecCritSec);
            dwCritSectIniStage = 1;

            BindCacheInit() ;

            InitializeCriticalSection(&BindCacheCritSect) ;
            dwCritSectIniStage = 2;
            
            InitializeCriticalSection(&g_SchemaCritSect);
            dwCritSectIniStage = 3;
            
            InitializeCriticalSection(&g_DefaultSchemaCritSect);
            dwCritSectIniStage = 4;
            
            InitializeCriticalSection(&g_SubSchemaCritSect);
            dwCritSectIniStage = 5;

            InitializeCriticalSection(&g_DomainDnsCache);
            dwCritSectIniStage = 6;

            g_hInst = hInst;

#if DBG==1
            InitializeCriticalSection(&g_csDP); // Used by ADsDebug
            dwCritSectIniStage = 7;

            InitializeCriticalSection(&ADsMemCritSect) ;
            dwCritSectIniStage = 8;
            
#ifndef MSVC
            InitializeCriticalSection(&g_csOT); // Used by Object Tracker
            dwCritSectIniStage = 9;
            
            InitializeCriticalSection(&g_csMem); // Used by Object Tracker
            dwCritSectIniStage = 10;
#endif
            
#endif
            fInitializeCritSect = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical faliure
            //
            switch(dwCritSectIniStage)
            {
#if DBG==1
#ifndef MSVC
                case 10:
                    DeleteCriticalSection(&g_csMem);
                case 9:
                    DeleteCriticalSection(&g_csOT);            
#endif
                case 8:
                    DeleteCriticalSection(&ADsMemCritSect);
                case 7:
                    DeleteCriticalSection(&g_csDP);            
#endif               
                case 6:
                    DeleteCriticalSection(&g_DomainDnsCache);
                case 5:
                    DeleteCriticalSection(&g_SubSchemaCritSect);
                case 4:
                    DeleteCriticalSection(&g_DefaultSchemaCritSect);
                case 3:
                    DeleteCriticalSection(&g_SchemaCritSect);
                case 2:
                    DeleteCriticalSection(&BindCacheCritSect) ;
                case 1:
                    DeleteCriticalSection(&ADsErrorRecCritSec);
            
            }
            
            return FALSE;
        }

        //
        // Time to load localized strings if applicable.
        //
        if (!g_fStringsLoaded) {
            //
            // Load NT AUthority
            //
            if (!LoadStringW(
                     g_hInst,
                     LDAPC_NT_AUTHORITY,
                     g_szNT_Authority,
                     sizeof( g_szNT_Authority ) / sizeof( WCHAR )
                     )
                ) {
                wcscpy(g_szNT_Authority, L"NT AUTHORITY");
            }
            g_fStringsLoaded = TRUE;
        }

        break;


    case DLL_PROCESS_DETACH:
        ADsFreeAllErrorRecords();

        SchemaCleanup();
        BindCacheCleanup();

#if (!defined WIN95)
        if (g_hLsa != INVALID_HANDLE_VALUE) {
            LsaDeregisterLogonProcessWrapper(g_hLsa);
        }
#endif

        if (g_hDllNetApi32) {
            FreeLibrary((HMODULE)g_hDllNetApi32);
            g_hDllNetApi32 = NULL;
        }

        if (g_hDllSecur32) {
            FreeLibrary((HMODULE)g_hDllSecur32);
            g_hDllSecur32 = NULL;
        }

        if(fInitializeCritSect)
        {
            DeleteCriticalSection(&ADsErrorRecCritSec);
            DeleteCriticalSection(&g_DomainDnsCache);

            //
            // Delete critsects initialized in SchemaInit
            //
            DeleteCriticalSection(&g_SchemaCritSect);
            DeleteCriticalSection(&g_SubSchemaCritSect);
            DeleteCriticalSection(&g_DefaultSchemaCritSect);

            //
            // Delte the critical section initialized in BindCacheInit
            //
            DeleteCriticalSection(&BindCacheCritSect) ;

            

#if DBG==1
#ifndef MSVC
            DeleteCriticalSection(&g_csOT); // Used by Object Tracker
            DeleteCriticalSection(&g_csMem); // Used by Object Tracker
#endif
            DeleteCriticalSection(&g_csDP); // Used by ADsDebug            
#endif
        }

        if (gpszServerName) {
            FreeADsStr(gpszServerName);
            gpszServerName = NULL;
        }

        if (gpszDomainName) {
            FreeADsStr(gpszDomainName);
            gpszDomainName = NULL;
        }

#if DBG==1
    DumpMemoryTracker();
#endif

#if DBG==1
        if(fInitializeCritSect)
        {
            DeleteCriticalSection(&ADsMemCritSect);
        }
#endif


        break;

    case DLL_THREAD_DETACH:
        ADsFreeThreadErrorRecords();
        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\memory.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include "dswarn.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "symhelp.h"
#include "oledsdbg.h"


#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemoryLog = 0;

#define MAXDEPTH 10

typedef struct _ADSMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} ADSMEMTAG, *PADSMEMTAG ;

LIST_ENTRY       ADsMemList ;
DWORD            ADsMemCount ;
CRITICAL_SECTION ADsMemCritSect ;

/*++

Routine Description:

    This function initializes the ADs mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitADsMem(
    VOID
)
{    
    InitializeListHead(&ADsMemList) ;
    ADsMemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertADsMemLeaks(
    VOID
)
{
    ADsAssert(IsListEmpty(&ADsMemList)) ;
}

#endif

LPVOID
AllocADsMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
#if DBG
    DWORD    cbNew ;
    PADSMEMTAG pMem ;

    ULONG ulHash;

    //
    // adjust size for our tag and one spare dword at end
    // and allocate the memory
    //
    cb = DWORD_ALIGN_UP(cb);

    cbNew = cb + ( sizeof(ADSMEMTAG) + sizeof(DWORD) );

    pMem=(PADSMEMTAG)LocalAlloc(LPTR, cbNew);

    if (!pMem) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    //
    // fill in deadbeef at end and tag info.
    // and insert it into the ADsMemList
    //

    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD)) = 0xdeadbeef;
    pMem->Tag = 0xB00FB00F ;
    pMem->Size = cb ;


    //
    // Capture a backtrace at this spot for debugging.
    //

#if (defined(i386) && !defined(WIN95))

    pMem->uDepth = RtlCaptureStackBackTrace(
                            0,
                            MAXDEPTH,
                            pMem->pvBackTrace,
                            &ulHash
                            );



#else

    pMem->uDepth = 0;

#endif


    EnterCriticalSection(&ADsMemCritSect) ;
    InsertHeadList(&ADsMemList, &pMem->List) ;
    ADsMemCount++ ;
    LeaveCriticalSection(&ADsMemCritSect) ;

    //
    // skip past the mem tag
    //
    pMem++ ;
    return (LPVOID)(pMem);
#else
    return(LocalAlloc(LPTR, cb));
#endif

}

BOOL
FreeADsMem(
   LPVOID pMem
)
{
#if DBG
    DWORD        cb;
    DWORD        cbNew = 0;
    PADSMEMTAG pNewMem ;
    LPDWORD      pRetAddr;
    DWORD i = 0;


    //
    // This apparently is a C++ requiremen - that you can call
    // delete on a null pointer and it should be handled
    //
    if (pMem == NULL) {
        return 0;
    }

    pNewMem = (PADSMEMTAG)pMem;
    pNewMem -- ;

    cb = pNewMem->Size;
    cbNew = cb + sizeof(DWORD) + sizeof(ADSMEMTAG);

    //
    // check the trailing deadbeef and remove from list
    //

    if (*(LPDWORD)(((LPBYTE)pNewMem) + cbNew - sizeof(DWORD)) != 0xdeadbeef) {
        ADsAssert(!"Freeing memory not allocated by AllocADsMem") ;
        return FALSE;
    }

    EnterCriticalSection(&ADsMemCritSect) ;
    RemoveEntryList(&pNewMem->List) ;
    ADsMemCount-- ;
    LeaveCriticalSection(&ADsMemCritSect) ;


    for (i = 0; i < pNewMem->uDepth; i++) {

        if (pNewMem->pszSymbol[i]) {
            LocalFree(pNewMem->pszSymbol[i]);
        }
    }


    //
    // Whack freed memory with known pattern
    //

    memset(pMem, 0x65, cb);
    return(LocalFree((LPVOID)pNewMem) == NULL);

#else

    return(LocalFree(pMem) == NULL);

#endif


}

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocADsMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreeADsMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocADsStr(
    LPCWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocADsMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreeADsStr(
   LPWSTR pStr
)
{
   return pStr ? FreeADsMem(pStr)
               : FALSE;
}

BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   if(!ppStr)
   {
       return FALSE;
   }
   
   FreeADsStr(*ppStr);
   *ppStr = NULL;
   
   *ppStr=AllocADsStr(pStr);

   if(!(*ppStr) && pStr)
   {
       return FALSE;
   }
   else
   {
       return TRUE;
   }
   
}


#if DBG
VOID
DumpMemoryTracker(
    VOID
    )
{
#if !defined(WIN95) && defined(_X86_)
   LIST_ENTRY* pEntry;
   ADSMEMTAG*  pMem;
   BYTE*       pTemp;
   DWORD i = 0;
   CHAR szSymbolPath[MAX_PATH+1];
   DWORD dwCount = 0;

   pEntry   = ADsMemList.Flink;

   if (!dwMemoryLog) {
      return;
   }


   if ( pEntry == &ADsMemList ) {
       OutputDebugStringA( "No Memory leaks found\n" );
   }

   while( pEntry != &ADsMemList )
   {
      CHAR szLeak[1024];

      pTemp = (BYTE*)pEntry;
      pTemp = pTemp - sizeof(DWORD) - sizeof(DWORD)
              - sizeof(DWORD) -
              (sizeof(CHAR*) + sizeof(LPVOID))*( MAXDEPTH +1);
      pMem  = (ADSMEMTAG*)pTemp;

      sprintf(
        szLeak,
        "[oleds] Memory leak!!! Addresss = %.8x Size = %ld \n",
        pMem + 1,
        pMem->Size
        );
      OutputDebugStringA( szLeak );


     for (i = 0; i < pMem->uDepth; i++) {

         dwCount = TranslateAddress(
                     (ULONG)pMem->pvBackTrace[ i ],
                     szSymbolPath,
                     MAX_PATH
                     );
         szSymbolPath[dwCount] = '\0';
         sprintf(szLeak, "%s\n",szSymbolPath);
         OutputDebugStringA( szLeak);

     }

      pEntry   = pEntry->Flink;
   }
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\odsmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       odsmrshl.cxx
//
//  Contents:   DSObject Copy Routines
//
//  Functions:
//
//  History:    25-Feb-97   yihsins   Created.
//
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"

LPBYTE
AdsTypeCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);


    lpAdsDestValue->DNString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->DNString);

    dwLength = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);

    lpAdsDestValue->CaseExactString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseExactString);

    dwLength = (wcslen(lpAdsSrcValue->CaseExactString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )

{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);

    lpAdsDestValue->CaseIgnoreString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseIgnoreString);

    dwLength = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);

    lpAdsDestValue->PrintableString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->PrintableString);

    dwLength = (wcslen(lpAdsSrcValue->PrintableString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);

    lpAdsDestValue->NumericString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->NumericString);

    dwLength = (wcslen(lpAdsSrcValue->NumericString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}



LPBYTE
AdsTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean = lpAdsSrcValue->Boolean;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer = lpAdsSrcValue->Integer;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;

    //
    // The target buffer should be worst-case aligned
    //

    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);

    memcpy(
        lpBuffer,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopySecurityDescriptor(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NT_SECURITY_DESCRIPTOR){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;

    dwNumBytes =  lpAdsSrcValue->SecurityDescriptor.dwLength;

    //
    // The target buffer should be worst-case aligned
    //

    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);

    memcpy(
        lpBuffer,
        lpAdsSrcValue->SecurityDescriptor.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->SecurityDescriptor.dwLength = dwNumBytes;

    lpAdsDestValue->SecurityDescriptor.lpValue =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyTime(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    lpAdsDestValue->UTCTime = lpAdsSrcValue->UTCTime;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyLargeInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_LARGE_INTEGER){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_LARGE_INTEGER;

    lpAdsDestValue->LargeInteger = lpAdsSrcValue->LargeInteger;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyProvSpecific(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PROV_SPECIFIC){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_PROV_SPECIFIC;

    dwNumBytes = lpAdsSrcValue->ProviderSpecific.dwLength;

    //
    // The target buffer should be worst-case aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);

    memcpy(
        lpBuffer,
        lpAdsSrcValue->ProviderSpecific.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->ProviderSpecific.dwLength = dwNumBytes;

    lpAdsDestValue->ProviderSpecific.lpValue = lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyDNWithBinary(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;
    PADS_DN_WITH_BINARY pDNBin = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_BINARY){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_WITH_BINARY;

    //
    // Worse-case align the target buffer for the structure itself
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);


    lpAdsDestValue->pDNWithBinary = (PADS_DN_WITH_BINARY) lpBuffer;
    lpBuffer += sizeof(ADS_DN_WITH_BINARY);

    if (!lpAdsSrcValue->pDNWithBinary) {
        return(lpBuffer);
    }

    pDNBin = lpAdsSrcValue->pDNWithBinary;

    dwLength = pDNBin->dwLength;

    //
    // Copy the byte array over if applicable.
    //
    if (dwLength) {

        //
        // Worse-case align the target buffer for the binary data
        //
        lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);


        memcpy(
               lpBuffer,
               pDNBin->lpBinaryValue,
               lpAdsSrcValue->pDNWithBinary->dwLength
               );

        lpAdsDestValue->pDNWithBinary->dwLength = dwLength;

        lpAdsDestValue->pDNWithBinary->lpBinaryValue = lpBuffer;

    }

    lpBuffer += dwLength;

    //
    // Now for the string
    //
    if (pDNBin->pszDNString) {

        //
        // The target buffer has to be WCHAR (WORD) aligned
        // for the string
        //
        lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);


        dwLength = wcslen(pDNBin->pszDNString);

        wcscpy((LPWSTR) lpBuffer, pDNBin->pszDNString);

        lpAdsDestValue->pDNWithBinary->pszDNString = (LPWSTR) lpBuffer;

        //
        // For the trailing \0 of the string
        //
        dwLength++;

        lpBuffer += (dwLength * sizeof(WCHAR));
    }

    return lpBuffer;
}



LPBYTE
AdsTypeCopyDNWithString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwStrLen = 0;
    DWORD dwDNLen = 0;
    PADS_DN_WITH_STRING pDNStr = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_WITH_STRING;

    //
    // Worst-case align the target buffer for the structure
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);


    lpAdsDestValue->pDNWithString = (PADS_DN_WITH_STRING) lpBuffer;
    lpBuffer += sizeof(ADS_DN_WITH_STRING);

    if (!lpAdsSrcValue->pDNWithString) {
        return(lpBuffer);
    }

    pDNStr = lpAdsSrcValue->pDNWithString;

    //
    // Copy the string over if applicable.
    //
    if (pDNStr->pszStringValue) {

        //
        // The target buffer has to be WCHAR (WORD) aligned
        //
        lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);


        dwStrLen = wcslen(pDNStr->pszStringValue);

        wcscpy((LPWSTR)lpBuffer, pDNStr->pszStringValue);

        lpAdsDestValue->pDNWithString->pszStringValue = (LPWSTR) lpBuffer;

        //
        // +1 for trailing \0
        //
        lpBuffer += (sizeof(WCHAR) * ( dwStrLen + 1));

    }

    //
    // Now for the DN String
    //
    if (pDNStr->pszDNString) {

        //
        // The target buffer has to be WCHAR (WORD) aligned
        //
        lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);


        dwDNLen = wcslen(pDNStr->pszDNString);

        wcscpy((LPWSTR) lpBuffer, pDNStr->pszDNString);

        lpAdsDestValue->pDNWithString->pszDNString = (LPWSTR) lpBuffer;

        //
        // For the trailing \0 of the string
        //
        dwDNLen++;

        lpBuffer += (dwDNLen * sizeof(WCHAR));
    }

    return lpBuffer;
}



LPBYTE
AdsTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        lpBuffer = AdsTypeCopyDNString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        lpBuffer = AdsTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        lpBuffer = AdsTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        lpBuffer = AdsTypeCopyPrintableString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        lpBuffer = AdsTypeCopyNumericString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_BOOLEAN:
        lpBuffer = AdsTypeCopyBoolean(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_INTEGER:
        lpBuffer = AdsTypeCopyInteger(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_OCTET_STRING:
        lpBuffer = AdsTypeCopyOctetString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_UTC_TIME:
        lpBuffer = AdsTypeCopyTime(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_LARGE_INTEGER:
        lpBuffer = AdsTypeCopyLargeInteger(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_PROV_SPECIFIC:
        lpBuffer = AdsTypeCopyProvSpecific(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        lpBuffer = AdsTypeCopySecurityDescriptor(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_DN_WITH_BINARY:
        lpBuffer = AdsTypeCopyDNWithBinary(
                       lpAdsSrcValue,
                       lpAdsDestValue,
                       lpBuffer
                       );
        break;

    case ADSTYPE_DN_WITH_STRING:
        lpBuffer = AdsTypeCopyDNWithString(
                       lpAdsSrcValue,
                       lpAdsDestValue,
                       lpBuffer
                       );
        break;

    default:

        break;
    }

    return(lpBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\ods2ldap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       ods2ldap.cxx
//
//  Contents:   DSObject to LDAP Object Copy Routines
//
//  Functions:
//
//  History:    25-Feb-97   yihsins   Created.
//
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"


HRESULT
AdsTypeToLdapTypeCopyDNString(
    PADSVALUE  lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr( lpAdsSrcValue->DNString );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_DN;

    RRETURN(S_OK);
}

HRESULT
AdsTypeToLdapTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr(lpAdsSrcValue->CaseExactString);

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_CASEEXACTSTRING;


    RRETURN(S_OK);
}


HRESULT
AdsTypeToLdapTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr(lpAdsSrcValue->CaseIgnoreString);

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_CASEIGNORESTRING;

    RRETURN(S_OK);
}


HRESULT
AdsTypeToLdapTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr( lpAdsSrcValue->PrintableString);

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_PRINTABLESTRING;

    RRETURN(S_OK);
}

HRESULT
AdsTypeToLdapTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr( lpAdsSrcValue->NumericString );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_NUMERICSTRING;

    RRETURN(S_OK);
}

HRESULT
AdsTypeToLdapTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    LPTSTR  pszStr = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if ( lpAdsSrcValue->Boolean )
        pszStr = TEXT("TRUE");
    else
        pszStr = TEXT("FALSE");

    LDAPOBJECT_STRING(lpLdapDestObject) = (LPTSTR) AllocADsStr( pszStr );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_BOOLEAN;

    RRETURN(S_OK);
}


HRESULT
AdsTypeToLdapTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    _itot( lpAdsSrcValue->Integer, Buffer, 10 );

    LDAPOBJECT_STRING(lpLdapDestObject) = (LPTSTR) AllocADsStr( Buffer );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_INTEGER;

    RRETURN(S_OK);
}

HRESULT
AdsTypeToLdapTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;

    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwNumBytes );

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
            lpAdsSrcValue->OctetString.lpValue,
            dwNumBytes );

    *pdwSyntaxId = LDAPTYPE_OCTETSTRING;


error:

    RRETURN(hr);
}


HRESULT
AdsTypeToLdapTypeCopySecurityDescriptor(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NT_SECURITY_DESCRIPTOR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    dwNumBytes =  lpAdsSrcValue->SecurityDescriptor.dwLength;

    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwNumBytes );

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) =
        (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject)
                  + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
            lpAdsSrcValue->SecurityDescriptor.lpValue,
            dwNumBytes );

    // Note that the type is set to OctetString as
    // LDAP does not know about the ntSecurityDescriptor type.
    *pdwSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;


error:

    RRETURN(hr);
}


HRESULT
AdsTypeToLdapTypeCopyTime(
    PADSVALUE pAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME *st = &pAdsSrcValue->UTCTime;

    //
    // For ldap server, we can only handle 1950 to 2049. So return an
    // error to user instead of translating time incorrectly without
    // warning. GeneralizedTime handles a much larger range and should
    // be used for new attributes.
    //
    if ( st->wYear<1950 || st->wYear>2049)
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);


    if (pAdsSrcValue->dwType != ADSTYPE_UTC_TIME)
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);

    // The string is just "YYMMDDHHMMSSZ".
    LDAPOBJECT_STRING(pLdapDestObject) =
        (PWSTR) AllocADsMem((13 + 1) * sizeof(WCHAR));
    if (LDAPOBJECT_STRING(pLdapDestObject) == NULL)
        RRETURN(hr = E_OUTOFMEMORY);

    wsprintf(LDAPOBJECT_STRING(pLdapDestObject),
        TEXT("%02d%02d%02d%02d%02d%02dZ"),
        st->wYear % 100, st->wMonth, st->wDay,
        st->wHour, st->wMinute, st->wSecond);


    *pdwSyntaxId = LDAPTYPE_UTCTIME;

    RRETURN(hr);
}

//
// This is currently only used in ldapc\var2ldap.cxx.
//
HRESULT
AdsTypeToLdapTypeCopyGeneralizedTime(
    PADSVALUE pAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME *st = &pAdsSrcValue->UTCTime;

    if (pAdsSrcValue->dwType != ADSTYPE_UTC_TIME)
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);

    //
    // ASN.1 spec says a GeneralizedTime can be no more than 24 chars.
    //
    LDAPOBJECT_STRING(pLdapDestObject) =
        (PWSTR) AllocADsMem((24 + 1) * sizeof(WCHAR));
    if (LDAPOBJECT_STRING(pLdapDestObject) == NULL)
        RRETURN(hr = E_OUTOFMEMORY);

    wsprintf(LDAPOBJECT_STRING(pLdapDestObject),
        TEXT("%04d%02d%02d%02d%02d%02d.%03dZ"),
        st->wYear, st->wMonth, st->wDay,
        st->wHour, st->wMinute, st->wSecond,
        st->wMilliseconds);

    *pdwSyntaxId = LDAPTYPE_GENERALIZEDTIME;

    RRETURN(hr);
}

HRESULT
AdsTypeToLdapTypeCopyLargeInteger(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{

    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    if(lpAdsSrcValue->dwType != ADSTYPE_LARGE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    swprintf (Buffer, L"%I64d", lpAdsSrcValue->LargeInteger);

    LDAPOBJECT_STRING(lpLdapDestObject) = (LPTSTR) AllocADsStr( Buffer );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_INTEGER8;

    RRETURN(S_OK);

}

HRESULT
AdsTypeToLdapTypeCopyProvSpecific(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PROV_SPECIFIC){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    dwNumBytes =  lpAdsSrcValue->ProviderSpecific.dwLength;

    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwNumBytes );

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
            lpAdsSrcValue->ProviderSpecific.lpValue,
            dwNumBytes );

    *pdwSyntaxId = LDAPTYPE_OCTETSTRING;

error:

    RRETURN(hr);
}



//
// Conversion routine for DN With String.
// Dn With String has the format :
//
//      S:9:OurDomain:dc=ntdev,dc=microsoft,dc=com
//
// (9 chars in OurDomain) on the server.
//
//
HRESULT
AdsTypeToLdapTypeCopyDNWithString(
    PADSVALUE   lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD      pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszLdapStrVal = NULL;
    DWORD dwLengthStr = 0;
    DWORD dwTotalLength = 0;
    PADS_DN_WITH_STRING pDNStr = NULL;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_STRING) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pDNWithString) {
        RRETURN(hr = E_FAIL);
    }

    pDNStr = lpAdsSrcValue->pDNWithString;

    //
    // Length is S:dwLength:Strval:
    //            2  10+1     dwLengthStr+2 (the : and \0)
    //

    dwTotalLength = 2 + 11 + 2;
    if (pDNStr->pszStringValue) {

        dwLengthStr = wcslen(pDNStr->pszStringValue);
        dwTotalLength += dwLengthStr;
    }

    if (pDNStr->pszDNString) {
        dwTotalLength += wcslen(pDNStr->pszDNString) + 1;
    }

    pszLdapStrVal = (LPWSTR) AllocADsMem(dwTotalLength * sizeof(WCHAR));

    if (!pszLdapStrVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wsprintf(pszLdapStrVal, L"S:%lu:",dwLengthStr);
    //
    // tag on the string val if appropriate
    //
    if (dwLengthStr) {
        wcscat(pszLdapStrVal, pDNStr->pszStringValue);
    }

    wcscat(pszLdapStrVal, L":");

    //
    // Now for the actual DN - if one is there
    //
    if (pDNStr->pszDNString) {
        wcscat(pszLdapStrVal, pDNStr->pszDNString);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) = pszLdapStrVal;

    *pdwSyntaxId = LDAPTYPE_DNWITHSTRING;

error:

    RRETURN(hr);

}



//
// Conversion routine for DN With Binary.
// Dn With Binary has the format :
//
//      B:32:a9d1ca15768811d1aded00c04fd8d5cd:dc=ntdev,dc=microsoft,dc=com
//
// (32 wchars = 16 bytes in this case a guid).
//
//
HRESULT
AdsTypeToLdapTypeCopyDNWithBinary(
    PADSVALUE   lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD      pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    WCHAR pszSmallStr[5];
    LPWSTR pszLdapStrVal = NULL;
    DWORD dwTotalLength = 0;
    PADS_DN_WITH_BINARY pDNBin = NULL;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_BINARY) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pDNWithBinary) {
        RRETURN(E_FAIL);
    }

    pDNBin = lpAdsSrcValue->pDNWithBinary;

    //
    // B:xxx:octStr:DNString\0 at the end
    //  2+11+  x + 1 +   y + 1 = 15 + x + y
    //
    dwTotalLength = 15;

    if (pDNBin->dwLength) {

        //
        // Add 2 * OctetString length as it is encoded as str.
        //
        dwTotalLength += 2 * (pDNBin->dwLength);
    }

    if (pDNBin->pszDNString) {
        dwTotalLength += wcslen(pDNBin->pszDNString);
    }

    pszLdapStrVal = (LPWSTR) AllocADsMem(dwTotalLength * sizeof(WCHAR));

    if (!pszLdapStrVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wsprintf(pszLdapStrVal, L"B:%lu:",(pDNBin->dwLength) * 2);
    //
    // tag on the hex encoded string if appropriate
    //
    if (pDNBin->dwLength) {
        if (!pDNBin->lpBinaryValue) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        for (DWORD i = 0; i < pDNBin->dwLength; i++) {
            wsprintf(pszSmallStr, L"%02x", pDNBin->lpBinaryValue[i]);
            wcscat(pszLdapStrVal, pszSmallStr);
        }
    }

    wcscat(pszLdapStrVal, L":");

    //
    // Now for the actual DN - if one is there
    //
    if (pDNBin->pszDNString) {
        wcscat(pszLdapStrVal, pDNBin->pszDNString);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) = pszLdapStrVal;

    *pdwSyntaxId = LDAPTYPE_DNWITHBINARY;

error:

    if (FAILED(hr)) {
        FreeADsMem(pszLdapStrVal);
    }

    RRETURN(hr);

}


HRESULT
AdsTypeToLdapTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    BOOL *pfIsString,
    PDWORD pdwSyntaxId,
    BOOL fGenTime
    )
{
    HRESULT hr = S_OK;

    *pfIsString = TRUE;  // This will only be FALSE when the ADSVALUE
                         // contains octet strings

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        hr = AdsTypeToLdapTypeCopyDNString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        hr = AdsTypeToLdapTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToLdapTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        hr = AdsTypeToLdapTypeCopyPrintableString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        hr = AdsTypeToLdapTypeCopyNumericString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToLdapTypeCopyBoolean(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToLdapTypeCopyInteger(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;


    case ADSTYPE_OCTET_STRING:
        *pfIsString = FALSE;
        hr = AdsTypeToLdapTypeCopyOctetString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_UTC_TIME:
        if (fGenTime) {
            //
            // Treat as gentime not UTCTime
            //
            hr = AdsTypeToLdapTypeCopyGeneralizedTime(
                     lpAdsSrcValue,
                     lpLdapDestObject,
                     pdwSyntaxId
                     );
        }
        else {

            hr = AdsTypeToLdapTypeCopyTime(
                    lpAdsSrcValue,
                    lpLdapDestObject,
                    pdwSyntaxId
                    );
        }

        break;

    case ADSTYPE_LARGE_INTEGER:
        hr = AdsTypeToLdapTypeCopyLargeInteger(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_PROV_SPECIFIC:
        *pfIsString = FALSE;
        hr = AdsTypeToLdapTypeCopyProvSpecific(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        *pfIsString = FALSE;
        hr = AdsTypeToLdapTypeCopySecurityDescriptor(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_DN_WITH_BINARY:
        *pfIsString = TRUE;
        hr = AdsTypeToLdapTypeCopyDNWithBinary(
                 lpAdsSrcValue,
                 lpLdapDestObject,
                 pdwSyntaxId
                 );
        break;

    case ADSTYPE_DN_WITH_STRING:
        *pfIsString = TRUE;
        hr = AdsTypeToLdapTypeCopyDNWithString(
                 lpAdsSrcValue,
                 lpLdapDestObject,
                 pdwSyntaxId
                 );
        break;

    default:
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        *pdwSyntaxId =0;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToLdapTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LDAPOBJECTARRAY *pLdapDestObjects,
    PDWORD pdwSyntaxId,
    BOOL fGenTime
    )
{

    DWORD i = 0;
    HRESULT hr = S_OK;

    if ( dwNumObjects == 0 )
    {
        pLdapDestObjects->dwCount = 0;
        pLdapDestObjects->pLdapObjects = NULL;
        RRETURN(S_OK);
    }

    pLdapDestObjects->pLdapObjects = (PLDAPOBJECT)AllocADsMem(
                                         (dwNumObjects+1) * sizeof(LDAPOBJECT));

    if ( pLdapDestObjects->pLdapObjects == NULL )
        RRETURN(E_OUTOFMEMORY);

    pLdapDestObjects->dwCount = dwNumObjects;

    for (i = 0; i < dwNumObjects; i++ ) {

         hr = AdsTypeToLdapTypeCopy(
                    pAdsSrcValues + i,
                    pLdapDestObjects->pLdapObjects + i,
                    &(pLdapDestObjects->fIsString),
                    pdwSyntaxId,
                    fGenTime
                    );
         BAIL_ON_FAILURE(hr);
    }

    RRETURN(S_OK);

error:

    LdapTypeFreeLdapObjects( pLdapDestObjects );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\oledserr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oledserr.c

Abstract:

    Contains the entry point for
        ADsGetLastError
        ADsSetLastError
        ADsFreeAllErrorRecords

    Also contains the following support routines:
        ADsAllocErrorRecord
        ADsFreeErrorRecord
        ADsFindErrorRecord

Author:


    Ram Viswanathan (ramv) 09-24-1996
    appropriated from mpr project. Originally written by danl.

Environment:

    User Mode - Win32

Revision History:

    09-Sep-1996 ramv
        Copied from mpr project and made the following modifications.
        Renamed all errors to Active Directory errors. ADsGetLastError and
        ADsSetLastError now return an HRESULT giving status.

--*/
//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>

#include "memory.h"
#include "oledsdbg.h"
#include "oledserr.h"


#if DBG
DECLARE_INFOLEVEL(ADsErr);
DECLARE_DEBUG(ADsErr);
#define ADsErrDebugOut(x) ADsErrInlineDebugOut x
#else
#define ADsErrDebugOut(x)
#endif

//
// Global Data Structures
//

ERROR_RECORD        ADsErrorRecList;    // Initialized to zeros by loader
CRITICAL_SECTION    ADsErrorRecCritSec; // Initialized in libmain.cxx


HRESULT
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    )

/*++

Routine Description:

    This function allows users to obtain the error code and accompanying
    text when they receive a ERROR_EXTENDED_ERROR in response to a ADs API
    function call.

Arguments:

    lpError - This is a pointer to the location that will receive the
        error code.

    lpErrorBuf - This points to a buffer that will receive the null
        terminated string describing the error.

    dwErrorBufLen - This value that indicates the size (in characters) of
        lpErrorBuf.
        If the buffer is too small to receive an error string, the
        string will simply be truncated.  (it is still guaranteed to be
        null terminated).  A buffer of at least 256 bytes is recommended.

    lpNameBuf - This points to a buffer that will receive the name of
        the provider that raised the error.

    dwNameBufLen - This value indicates the size (in characters) of lpNameBuf.
        If the buffer is too small to receive an error string, the
        string will simply be truncated.  (it is still guaranteed to be
        null terminated).

Return Value:

    S_OK- if the call was successful.

    E_POINTER - One or more of the passed in pointers is bad.

    ERROR_BAD_DEVICE - This indicates that the threadID for the current
        thread could not be found in that table anywhere.  This should
        never happen.

--*/
{
    LPERROR_RECORD  errorRecord;
    DWORD           dwNameStringLen;
    DWORD           dwTextStringLen;
    HRESULT         hr = S_OK;
    DWORD           dwStatus = ERROR_SUCCESS;


    //
    // Screen the parameters as best we can.
    //
    if (!lpError || !lpErrorBuf || !lpNameBuf) {

        // some error, the user is never going to see this
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        hr = E_POINTER;

    }

    if (dwStatus != ERROR_SUCCESS) {
        return(hr);
    }

    //
    // Get the current thread's error record.
    //
    errorRecord = ADsFindErrorRecord();

    if (errorRecord != NULL) {
        //
        // The record was found in the linked list.
        // See if there is a buffer to put data into.
        //
        if (dwErrorBufLen > 0) {
            //
            // Check to see if there is error text to return.
            // If not, indicate a 0 length string.
            //
            if(errorRecord->pszErrorText == NULL) {
                *lpErrorBuf = L'\0';
            }
            else {
                //
                // If the error text won't fit into the user buffer, fill it
                // as best we can, and NULL terminate it.
                //
                dwTextStringLen = (DWORD) wcslen(errorRecord->pszErrorText);

                if(dwErrorBufLen < dwTextStringLen + 1) {
                    dwTextStringLen = dwErrorBufLen - 1;
                }

                //
                // dwTextStringLen now contains the number of characters we
                // will copy without the NULL terminator.
                //
                wcsncpy(lpErrorBuf, errorRecord->pszErrorText, dwTextStringLen);
                *(lpErrorBuf + dwTextStringLen) = L'\0';
            }
        }

        //
        // If there is a Name Buffer to put the provider into, then...
        //
        if (dwNameBufLen > 0) {
            //
            // See if the Provider Name will fit in the user buffer.
            //
            dwNameStringLen = errorRecord->pszProviderName ?
                 ((DWORD)wcslen(errorRecord->pszProviderName) + 1) :
                 1 ;

            //
            // If the user buffer is smaller than the required size,
            // set up to copy the smaller of the two.
            //
            if(dwNameBufLen < dwNameStringLen + 1) {
                dwNameStringLen = dwNameBufLen - 1;
            }

            if (errorRecord->pszProviderName) {
                wcsncpy(lpNameBuf, errorRecord->pszProviderName, dwNameStringLen);
                *(lpNameBuf + dwNameStringLen) = L'\0';
            }
            else {
                *lpNameBuf = L'\0';
            }
        }
        *lpError = errorRecord->dwErrorCode;

        return(S_OK);
    }
    else {

        //
        // If we get here, a record for the current thread could not be found.
        //
        *lpError = ERROR_SUCCESS;
        if (dwErrorBufLen > 0) {
            *lpErrorBuf = L'\0';
        }
        if (dwNameBufLen > 0) {
            *lpNameBuf  = L'\0';
        }
        return(S_OK);
    }
}


VOID
ADsSetLastError(
    IN  DWORD   dwErr,
    IN  LPCWSTR  pszError,
    IN  LPCWSTR  pszProvider
    )

/*++

Routine Description:

    This function is used by Active Directory Providers to set extended errors.
    It saves away the error information in a "per thread" data structure.


Arguments:

    dwErr - The error that occured.  This may be a Windows defined error,
        in which case pszError is ignored.  or it may be ERROR_EXTENDED_ERROR
        to indicate that the provider has a network specific error to report.

    pszError - String describing a network specific error.

    pszProvider - String naming the network provider raising the error.

Return Value:

    none


--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPERROR_RECORD  errorRecord;

    //
    // Get the Error Record for the current thread.
    //
    errorRecord = ADsFindErrorRecord();

    //
    // if there isn't a record for the current thread, then add it.
    //
    if (errorRecord == NULL)
    {
        errorRecord = ADsAllocErrorRecord();

        if (errorRecord == NULL)
        {
            ADsErrDebugOut((DEB_TRACE,
                 "ADsSetLastError:Could not allocate Error Record\n"));
            return;
        }
    }

    //
    // Update the error code in the error record.  At the same time,
    // free up any old strings since they are now obsolete, and init
    // the pointer to NULL.  Also set the ProviderName pointer in the
    // ErrorRecord to point to the provider's name.
    //

    errorRecord->dwErrorCode = dwErr;

    if(errorRecord->pszProviderName){
        FreeADsMem(errorRecord->pszProviderName);
    }

    errorRecord->pszProviderName = NULL;

    if(errorRecord->pszErrorText){
        FreeADsMem(errorRecord->pszErrorText);
    }

    errorRecord->pszErrorText = NULL;

    //
    // Allocate memory for the provider name.
    //
    if (pszProvider) {

        errorRecord->pszProviderName = (WCHAR *)AllocADsMem(
            ((DWORD)wcslen(pszProvider) +1) * sizeof(WCHAR));

        if (!(errorRecord->pszProviderName)) {

            dwStatus = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // Copy the string to the newly allocated buffer.
            //
            wcscpy(errorRecord->pszProviderName, pszProvider);
        }
    }

    if (dwStatus != ERROR_SUCCESS) {
        return;
    }


    //
    //  Allocate memory for the storage of the error text.
    //
    if (pszError) {

        errorRecord->pszErrorText = (WCHAR *) AllocADsMem(
            ((DWORD)wcslen(pszError) +1)* sizeof(WCHAR));

        if (errorRecord->pszErrorText) {

            //
            // Copy the error text into the newly allocated buffer.
            //
            wcscpy(errorRecord->pszErrorText, pszError);
        }

        // We do not really care about an error because we
        // are going to return anyway.

    }
    return;
}


LPERROR_RECORD
ADsFindErrorRecord(
    VOID)

/*++

Routine Description:

    Looks through the linked list of ErrorRecords in search of one for
    the current thread.

Arguments:

    none

Return Value:

    Returns LPERROR_RECORD if an error record was found.  Otherwise, it
    returns NULL.

--*/
{
    LPERROR_RECORD  errorRecord;
    DWORD           dwCurrentThreadId = GetCurrentThreadId();

    EnterCriticalSection(&ADsErrorRecCritSec);
    for (errorRecord = ADsErrorRecList.Next;
         errorRecord != NULL;
         errorRecord = errorRecord->Next)
    {
        if (errorRecord->dwThreadId == dwCurrentThreadId)
        {
            break;
        }
    }
    LeaveCriticalSection(&ADsErrorRecCritSec);
    return(errorRecord);
}


LPERROR_RECORD
ADsAllocErrorRecord(
    VOID)

/*++

Routine Description:

    This function allocates and initializes an Error Record for the
    current thread.  Then it places the error record in the global
    ADsErrorRecList.
    Even if the thread exits, the record is not freed until the DLL unloads.
    This is OK because this function is called only if a provider calls
    ADsSetLastError, which is rare.

Arguments:

    none

Return Value:

    TRUE - The operation completed successfully

    FALSE - An error occured in the allocation.

Note:


--*/
{
    LPERROR_RECORD  record;
    LPERROR_RECORD  errorRecord;

    //
    //  Allocate memory for the storage of the error message
    //  and add the record to the linked list.
    //
    errorRecord = (LPERROR_RECORD)AllocADsMem(sizeof (ERROR_RECORD));

    if (errorRecord == NULL) {
        ADsErrDebugOut((
            DEB_TRACE,
            "ADsAllocErrorRecord:LocalAlloc Failed %d\n",
            GetLastError()
            ));
        return NULL;
    }

    //
    // Initialize the error record
    //
    errorRecord->dwThreadId = GetCurrentThreadId();
    errorRecord->dwErrorCode = ERROR_SUCCESS;
    errorRecord->pszErrorText = NULL;

    //
    // Add the record to the linked list.
    //
    EnterCriticalSection(&ADsErrorRecCritSec);

    record = &ADsErrorRecList;
    ADD_TO_LIST(record, errorRecord);

    LeaveCriticalSection(&ADsErrorRecCritSec);

    return errorRecord;
}


VOID
ADsFreeAllErrorRecords(
    VOID)

/*++

Routine Description:

    This function is called when the DLL is unloading due to a FreeLibrary
    call.  It frees all the error records (for all threads) that have been
    created since the DLL was loaded.  If there is a pointer to a text string
    in a record, the buffer for that string is freed also.

Arguments:


Return Value:


Note:


--*/
{
    LPERROR_RECORD nextRecord;
    LPERROR_RECORD record;

    EnterCriticalSection(&ADsErrorRecCritSec);

    for (record = ADsErrorRecList.Next;
         record != NULL;
         record = nextRecord)
    {
        ADsErrDebugOut(
            (DEB_TRACE,
             "ADsFreeErrorRecord: Freeing Record for thread 0x%x\n",
            record->dwThreadId ));

        if(record->pszErrorText){
            FreeADsMem(record->pszErrorText);
        }

        record->pszErrorText = NULL;

        if(record->pszProviderName){
            FreeADsMem(record->pszProviderName);
        }
        record->pszProviderName = NULL;

        nextRecord = record->Next;

        if(record){
            FreeADsMem(record);
        }
        record = NULL;
    }

    ADsErrorRecList.Next = NULL;

    LeaveCriticalSection(&ADsErrorRecCritSec);
}

VOID
ADsFreeThreadErrorRecords(
    VOID)

/*++

Routine Description:

    This function is called when the DLL is unloading due to a FreeLibrary
    call.  It frees all the error records (for all threads) that have been
    created since the DLL was loaded.  If there is a pointer to a text string
    in a record, the buffer for that string is freed also.

Arguments:


Return Value:


Note:


--*/
{
    LPERROR_RECORD record;
    DWORD dwThreadId = GetCurrentThreadId();

    EnterCriticalSection(&ADsErrorRecCritSec);

    for (record = ADsErrorRecList.Next;
         record != NULL;
         record = record->Next)
    {
        ADsErrDebugOut(
            (DEB_TRACE,
             "ADsFreeErrorRecord: Freeing Record for thread 0x%x\n",
            record->dwThreadId ));

        if (record->dwThreadId == dwThreadId) {
            REMOVE_FROM_LIST(record);
            if(record->pszErrorText){
                FreeADsMem(record->pszErrorText);
                record->pszErrorText = NULL;
            }
            if(record->pszProviderName){
                FreeADsMem(record->pszProviderName);
                record->pszProviderName = NULL;
            }
            FreeADsMem(record);
            break;
        }
    }
    LeaveCriticalSection(&ADsErrorRecCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\pathmgmt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pathmgmt.cxx
//
//  Contents:
//
//  Functions:
//
//  History:    25-April-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "ldapc.hxx"
#pragma hdrstop


#define STRING_LENGTH(p) ( p ? wcslen(p) : 0)

HRESULT
BuildADsParentPathFromObjectInfo2(
    POBJECTINFO pObjectInfo,
    LPWSTR *ppszParent,
    LPWSTR *ppszCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR pszComponent = NULL, pszValue = NULL;


    hr = ComputeAllocateParentCommonNameSize(pObjectInfo, ppszParent, ppszCommonName);
    BAIL_ON_FAILURE(hr);


    hr = BuildADsParentPathFromObjectInfo(
                    pObjectInfo,
                    *ppszParent,
                    *ppszCommonName
                    );
    BAIL_ON_FAILURE(hr);



    RRETURN(hr);


error:
    if (*ppszParent) {

        FreeADsMem(*ppszParent);
    }

    if (*ppszCommonName) {

        FreeADsMem(*ppszCommonName);
    }


    RRETURN(hr);
}


HRESULT
BuildADsParentPath(
    LPWSTR szBuffer,
    LPWSTR *ppszParent,
    LPWSTR *ppszCommonName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    HRESULT hr = S_OK;
    LPWSTR pszCommonName = NULL;
    LPWSTR pszParent = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(szBuffer, pObjectInfo);
    BAIL_ON_FAILURE(hr);


    // The length of pszParent or pszCommon is definitely less than the
    // length of the total buffer.

    pszParent = (LPWSTR) AllocADsMem( (_tcslen(szBuffer) + 1) * sizeof(TCHAR));

    if ( pszParent == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pszCommonName = (LPWSTR) AllocADsMem( (_tcslen(szBuffer) + 1) * sizeof(TCHAR));

    if ( pszCommonName == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildADsParentPathFromObjectInfo(
                 pObjectInfo,
                 pszParent,
                 pszCommonName
                );
    BAIL_ON_FAILURE(hr);

    *ppszParent = pszParent;
    *ppszCommonName = pszCommonName;

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (pszCommonName) {
        FreeADsMem(pszCommonName);
    }

    if (pszParent) {
        FreeADsMem(pszParent);
    }

    FreeObjectInfo( &ObjectInfo );


    RRETURN(hr);
}


HRESULT
BuildADsParentPathFromObjectInfo(
    POBJECTINFO pObjectInfo,
    LPWSTR pszParent,
    LPWSTR pszCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR pszComponent = NULL, pszValue = NULL;

    dwNumComponents = pObjectInfo->NumComponents;

    if (!dwNumComponents && !pObjectInfo->DisplayTreeName) {

        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(pszParent,L"ADs:");
        wsprintf(pszCommonName, L"%s:", pObjectInfo->NamespaceName);

        hr = S_OK;

    } else if (!dwNumComponents && pObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @NDS! object


        wsprintf(pszParent, L"%s:", pObjectInfo->NamespaceName);

        //
        // And the common name is the TreeName (and port)
        //

        if ( IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {

            wsprintf(pszCommonName,L"%s:%d", pObjectInfo->TreeName, pObjectInfo->PortNumber);
        }
        else {

            wsprintf(pszCommonName,L"%s", pObjectInfo->TreeName);
        }

        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        switch (pObjectInfo->dwServerPresent) {

        case TRUE:

            if ( IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {

                wsprintf(
                     pszParent, L"%s://%s:%d",
                     pObjectInfo->NamespaceName,
                     pObjectInfo->DisplayTreeName,
                     pObjectInfo->PortNumber
                     );
            }
            else {

                wsprintf(
                     pszParent, L"%s://%s",
                     pObjectInfo->NamespaceName,
                     pObjectInfo->DisplayTreeName
                     );
            }
            break;


        case FALSE:
                  wsprintf(
                       pszParent, L"%s:",
                       pObjectInfo->NamespaceName
                       );
                  break;

        }


        switch (pObjectInfo->dwPathType) {

        case PATHTYPE_X500:
        default: // where we cannot make a determination whether its X500 or Windows style

            if (dwNumComponents > 1) {

               if (pObjectInfo->dwServerPresent) {
                   wcscat(pszParent, L"/");
               }else {
                  wcscat(pszParent,L"//");
               }

                for (i = 1; i < dwNumComponents; i++) {

                    AppendComponent(pszParent, &(pObjectInfo->DisplayComponentArray[i]));

                    if (i < (dwNumComponents - 1)) {
                        wcscat(pszParent, L",");
                    }
                }
            }

            //
            // And the common name is the last component
            //

            pszComponent =  pObjectInfo->DisplayComponentArray[0].szComponent;
            pszValue = pObjectInfo->DisplayComponentArray[0].szValue;


            if (pszComponent && pszValue) {

                wsprintf(pszCommonName, L"%s=%s",pszComponent, pszValue);

            }else if (pszComponent){

                wsprintf(pszCommonName, L"%s", pszComponent);

            }else {
                //
                // Error - we should never hit this case!!
                //

            }
            hr = S_OK;
            break;




        case PATHTYPE_WINDOWS:

             switch (pObjectInfo->dwServerPresent) {
             case FALSE:

                if (dwNumComponents > 1) {

                   wcscat(pszParent,L"//");

                   for (i = 0; i < dwNumComponents - 1; i++) {
                      if (i ) {
                         wcscat(pszParent, L"/");
                      }

                      AppendComponent(pszParent, &(pObjectInfo->DisplayComponentArray[i]));

                   }

                }
                break;


             case TRUE:
                for (i = 0; i < dwNumComponents - 1; i++) {


                    wcscat(pszParent, L"/");

                    AppendComponent(pszParent, &(pObjectInfo->DisplayComponentArray[i]));

                }
                break;

             }

            //
            // And the common name is the last component
            //

            pszComponent =  pObjectInfo->DisplayComponentArray[dwNumComponents - 1].szComponent;
            pszValue = pObjectInfo->DisplayComponentArray[dwNumComponents - 1].szValue;


            if (pszComponent && pszValue) {

                wsprintf(pszCommonName, L"%s=%s",pszComponent, pszValue);

            }else if (pszComponent){

                wsprintf(pszCommonName, L"%s", pszComponent);

            }else {
                //
                // Error - we should never hit this case!!
                //

            }
            break;


        }

    }

    RRETURN(hr);
}

HRESULT
AppendComponent(
    LPWSTR pszADsPathName,
    PCOMPONENT pComponent
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszComponent = NULL, pszValue = NULL;

    pszComponent =  pComponent->szComponent;
    pszValue = pComponent->szValue;


    if (pszComponent && pszValue) {

        wcscat(
            pszADsPathName,
            pComponent->szComponent
            );
        wcscat(pszADsPathName,L"=");
        wcscat(
            pszADsPathName,
            pComponent->szValue
            );
    }else if (pszComponent){

        wcscat(
            pszADsPathName,
            pComponent->szComponent
            );

    }else {
        //
        // Error - we should never hit this case!!
        //

    }

    RRETURN(S_OK);
}



HRESULT
ComputeAllocateParentCommonNameSize(
    POBJECTINFO pObjectInfo,
    LPWSTR * ppszParent,
    LPWSTR * ppszCommonName
    )
{

    HRESULT hr = S_OK;
    LPWSTR pszParent = NULL;
    LPWSTR pszCommonName = NULL;
    DWORD dwPathSz = 0;
    WCHAR szPort[32];
    DWORD i = 0;


    //
    // the ADsPath of the Parent is atleast as long as the standard
    // pathname
    //

    //
    // the CommonName is atleast as long as the parent name
    //

    dwPathSz += STRING_LENGTH(pObjectInfo->NamespaceName);
    dwPathSz += STRING_LENGTH(pObjectInfo->ProviderName);
    dwPathSz += 2;
    dwPathSz += STRING_LENGTH(pObjectInfo->DisplayTreeName);

    //
    // If an explicit port has been specified
    //

    if ( IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
        wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
        dwPathSz += wcslen(szPort);
    }

    dwPathSz += 1;

    for (i = 0; i < pObjectInfo->NumComponents; i++) {

        dwPathSz += STRING_LENGTH(pObjectInfo->DisplayComponentArray[i].szComponent);
        dwPathSz += 1;
        dwPathSz += STRING_LENGTH(pObjectInfo->DisplayComponentArray[i].szValue);
        dwPathSz += 1;
    }

    dwPathSz += 1;

    pszCommonName = (LPWSTR)AllocADsMem((dwPathSz)*sizeof(WCHAR));
    if (!pszCommonName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    pszParent = (LPWSTR)AllocADsMem((dwPathSz)*sizeof(WCHAR));
    if (!pszParent) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *ppszCommonName = pszCommonName;

    *ppszParent  = pszParent;

    RRETURN(hr);


error:

    if (pszCommonName ) {
        FreeADsMem(pszCommonName);
    }

    if (pszParent) {
        FreeADsMem(pszParent);
    }


    RRETURN(hr);


}

HRESULT
BuildADsPathFromParent(
    LPWSTR Parent,
    LPWSTR Name,
    LPWSTR *ppszADsPath
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pParentObjectInfo = &ObjectInfo;
    HRESULT hr = S_OK;
    LPWSTR pszCommonName = NULL;
    LPWSTR pszADsPath  = NULL;

    memset(pParentObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(Parent, pParentObjectInfo);
    BAIL_ON_FAILURE(hr);

    // The length of the pszADsPath is the total path + name + 1;

    //
    // The length of pszParent or pszCommon is definitely less than the
    // length of the total buffer.
    //
    // The Name part may be expanded to include escaping characters. In
    // the worst case, the number of characters will double. Extra 2+1 is for
    // the "//" and a NULL
    //

    pszADsPath = (LPWSTR) AllocADsMem( (_tcslen(Parent) + (_tcslen(Name)*2) +  2 + 1) * sizeof(TCHAR));

    if (!pszADsPath) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildADsPathFromParentObjectInfo(
                 pParentObjectInfo,
                 Name,
                 pszADsPath
                );
    BAIL_ON_FAILURE(hr);

    *ppszADsPath = pszADsPath;


cleanup:

    if (pParentObjectInfo) {

        FreeObjectInfo( pParentObjectInfo );
    }


    RRETURN(hr);

error:

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }

    goto cleanup;
}



HRESULT
BuildADsPathFromParentObjectInfo(
    POBJECTINFO pParentObjectInfo,
    LPWSTR pszName,
    LPWSTR pszADsPath
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName = NULL;

    //
    // Get the display name for the name; The display name will have the proper
    // escaping for characters that have special meaning in an ADsPath like
    // '/' etc.
    //
    hr = GetDisplayName(
             pszName,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pParentObjectInfo->NumComponents;

    if (!dwNumComponents && !pParentObjectInfo->DisplayTreeName) {

        //
        // Should never happen --- ADs is the root of the tree,
        // and has no parent
        //
        ADsAssert(_wcsicmp(pszDisplayName, L"ADs:") != 0);

        if (!_wcsicmp(pParentObjectInfo->NamespaceName, L"ADs")) {

            //
            // In this one particular case we take in LDAP: as the Name
            // or GC: as the name
            //

            //
            // Do not add another : - so bogus!! Krishna
            //



            wsprintf(pszADsPath, L"%s", pszDisplayName);
        }else {

            //
            // There are no CNs in this pathname and
            // no tree name specified. This is the
            // namespace object

            //
            // Its pszName is a TreeName and we will concatenate
            // the treename with a slash slash
            //

            wsprintf(pszADsPath,
                     L"%s://%s",
                     pParentObjectInfo->NamespaceName,
                     pszDisplayName
                     );

        }

        hr = S_OK;

    } else if (!dwNumComponents && pParentObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified.
        //

        if (IS_EXPLICIT_PORT(pParentObjectInfo->PortNumber) ) {

            wsprintf(
                pszADsPath,
                L"%s://%s:%d/%s",
                pParentObjectInfo->NamespaceName,
                pParentObjectInfo->DisplayTreeName,
                pParentObjectInfo->PortNumber,
                pszDisplayName
                );
        }
        else {

            wsprintf(
                pszADsPath,
                L"%s://%s/%s",
                pParentObjectInfo->NamespaceName,
                pParentObjectInfo->DisplayTreeName,
                pszDisplayName
                );
        }

        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //
        switch (pParentObjectInfo->dwServerPresent) {
        case TRUE:

            if ( IS_EXPLICIT_PORT(pParentObjectInfo->PortNumber) ) {

                wsprintf(
                   pszADsPath, L"%s://%s:%d",
                   pParentObjectInfo->NamespaceName,
                   pParentObjectInfo->DisplayTreeName,
                   pParentObjectInfo->PortNumber
                   );
            }
            else {

                wsprintf(
                   pszADsPath, L"%s://%s",
                   pParentObjectInfo->NamespaceName,
                   pParentObjectInfo->DisplayTreeName
                   );
            }
            break;

        case FALSE:
           wsprintf(
               pszADsPath, L"%s://",
               pParentObjectInfo->NamespaceName
               );
        }
        switch (pParentObjectInfo->dwPathType) {
        case PATHTYPE_WINDOWS:

            switch (pParentObjectInfo->dwServerPresent) {
            case TRUE:
               for (i = 0; i < dwNumComponents; i++) {

                   wcscat(pszADsPath, L"/");

                   AppendComponent(pszADsPath, &(pParentObjectInfo->DisplayComponentArray[i]));

               }
               wcscat(pszADsPath, L"/");
               wcscat(pszADsPath, pszDisplayName);

               hr = S_OK;
               break;

            case FALSE:
                for (i = 0; i < dwNumComponents; i++) {

                   if (i ) {
                       wcscat(pszADsPath, L"/");
                   }

                    AppendComponent(pszADsPath, &(pParentObjectInfo->DisplayComponentArray[i]));

                }
                wcscat(pszADsPath, L"/");
                wcscat(pszADsPath, pszDisplayName);

                hr = S_OK;
                break;
            }
            break;

        case PATHTYPE_X500:
        default:

           switch (pParentObjectInfo->dwServerPresent) {
           case TRUE:
              wcscat(pszADsPath, L"/");
              break;

           case FALSE:
              break;
           }

            wcscat(pszADsPath, pszDisplayName);
            wcscat(pszADsPath, L",");

            for (i = 0; i < dwNumComponents; i++) {

                AppendComponent(pszADsPath, &(pParentObjectInfo->DisplayComponentArray[i]));

                if (i < (dwNumComponents - 1)) {
                    wcscat(pszADsPath, L",");
                }
            }
            hr = S_OK;
            break;

        }

    }

error:

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);

}

HRESULT
BuildLDAPPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR *pszLDAPPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR szLDAPPathName = NULL;

    *pszLDAPPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(szADsPathName, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    //
    // Assumption LDAPPath is always less than the ADsPath
    //

    szLDAPPathName = AllocADsStr(szADsPathName);
    if (!szLDAPPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!pObjectInfo->TreeName) {

        //
        // At the very minimum, we need a treename
        //

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }else if (pObjectInfo->TreeName && !dwNumComponents){

        _tcscpy(szLDAPPathName, TEXT("\\\\"));
        _tcscat(szLDAPPathName, pObjectInfo->TreeName);

    }else if (pObjectInfo->TreeName && dwNumComponents){

        _tcscpy(szLDAPPathName, TEXT("\\\\"));
        _tcscat(szLDAPPathName, pObjectInfo->TreeName);
        _tcscat(szLDAPPathName, TEXT("\\"));

        switch (pObjectInfo->dwPathType) {

        case PATHTYPE_X500:
        default:
            for (i = 0; i < dwNumComponents; i++) {

                AppendComponent(
                    szLDAPPathName,
                     &(pObjectInfo->ComponentArray[i])
                    );

                if (i < (dwNumComponents - 1)){
                    _tcscat(szLDAPPathName, TEXT(","));
                }
            }
            break;


        case PATHTYPE_WINDOWS:
            for (i = dwNumComponents; i >  0; i--) {

                AppendComponent(
                    szLDAPPathName,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

                if ((i - 1) > 0){
                    _tcscat(szLDAPPathName, TEXT(","));
                }
            }
            break;

        }

    }

    *pszLDAPPathName = szLDAPPathName;

error:

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}

HRESULT
BuildADsPathFromLDAPPath(
    LPWSTR szADsPathContext,
    LPWSTR szTargetLdapDN,
    LPWSTR * ppszADsPathName
    )
{
    LPWSTR pszADsPathName = NULL;
    PKEYDATA pKeyData = NULL;
    DWORD dwCount = 0, dwLen = 0;
    DWORD i = 0;
    int cHostNameLen;
    HRESULT hr;
    LPWSTR pszHostName = NULL, pszTemp = NULL;
    LPWSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    WCHAR szPort[32];
    DWORD dwPortNumber = 0;

    OBJECTINFO ObjectInfo, ObjectInfo2;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    POBJECTINFO pObjectInfo2 = &ObjectInfo2;

    LPWSTR pszDisplayDN = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    memset(pObjectInfo2, 0, sizeof(OBJECTINFO));

    if (!szADsPathContext || !szTargetLdapDN) {
        RRETURN(E_FAIL);
    }

    hr = GetDisplayName(
             szTargetLdapDN,
             &pszDisplayDN
             );
    BAIL_ON_FAILURE(hr);

    if (!pszDisplayDN) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    *ppszADsPathName = NULL;

    hr = ADsObject(szADsPathContext, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
                  szADsPathContext,
                  &pszLDAPServer,
                  &pszLDAPDn,
                  &dwPortNumber
                  );
    BAIL_ON_FAILURE(hr);

    dwLen = STRING_LENGTH(pObjectInfo->NamespaceName) +
            STRING_LENGTH(pszLDAPServer) +
            STRING_LENGTH(pszDisplayDN) +
            STRING_LENGTH(L"://") +
            STRING_LENGTH(L"/") +
            1;

    if (IS_EXPLICIT_PORT(dwPortNumber) ) {
        wsprintf(szPort, L":%d", dwPortNumber);
        dwLen += wcslen(szPort);
    }

    pszADsPathName = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );
    if(!pszADsPathName)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    
    pszTemp = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );

    if(!pszTemp) {
        if(pszADsPathName)
        {
            FreeADsMem(pszADsPathName);
        }
        hr = E_OUTOFMEMORY;
        goto error;
    }

    switch (pObjectInfo->dwPathType) {

    case PATHTYPE_WINDOWS:

        //
        // Simplistic way to do this is to create the X500 based name and then
        // reparse it to generate the Windows style name
        //

        switch (pObjectInfo->dwServerPresent) {
        case TRUE:

            wsprintf(pszADsPathName,L"%s://", pObjectInfo->NamespaceName);
            wcscat(pszADsPathName, pszLDAPServer);
            if (IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
                wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
                wcscat(pszADsPathName, szPort);
            }
            wcscat(pszADsPathName, L"/");
            wcscpy(pszTemp, pszADsPathName);

            wcscat(pszADsPathName, pszDisplayDN);
            break;

        case FALSE:
            wsprintf(pszADsPathName,L"%s://", pObjectInfo->NamespaceName);
            wcscpy(pszTemp, pszADsPathName);

            wcscat(pszADsPathName, pszDisplayDN);
            break;
        }

        hr = ADsObject(pszADsPathName, pObjectInfo2);
        BAIL_ON_FAILURE(hr);


        wcscpy (pszADsPathName, pszTemp);
        for (i = pObjectInfo2->NumComponents; i >  0; i--) {

            AppendComponent(
                pszADsPathName,
                &(pObjectInfo2->DisplayComponentArray[i-1])
                );

            if ((i - 1) > 0){
                _tcscat(pszADsPathName, TEXT("/"));
            }
        }
        break;


    case PATHTYPE_X500:
    default:

        switch (pObjectInfo->dwServerPresent) {
        case TRUE:
            wsprintf(pszADsPathName,L"%s://", pObjectInfo->NamespaceName);
            wcscat(pszADsPathName, pszLDAPServer);

            if (IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
                wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
                wcscat(pszADsPathName, szPort);
            }

            wcscat(pszADsPathName, L"/");
            wcscat(pszADsPathName, pszDisplayDN);
            break;

        case FALSE:
            wsprintf(pszADsPathName,L"%s://", pObjectInfo->NamespaceName);
            wcscat(pszADsPathName, pszDisplayDN);
            break;
        }

        break;

    }

    *ppszADsPathName = pszADsPathName;

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    if (pObjectInfo2) {
        FreeObjectInfo(pObjectInfo2);
    }

    if (pszTemp) {
        FreeADsMem(pszTemp);
    }

    if (pszLDAPServer) {
       FreeADsStr(pszLDAPServer);
    }

    if (pszLDAPDn) {
       FreeADsStr(pszLDAPDn);
    }

    if (pszDisplayDN) {
        FreeADsMem(pszDisplayDN);
    }

    RRETURN(hr);
}



PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData,
    WCHAR ch
    )
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;
    WCHAR szTokenList[MAX_PATH];


    if (!psz || !*psz)
        return NULL;

    _stprintf(szTokenList, TEXT("%c"), ch);

    cTokens=1;

    // Scan through the string looking for commas,
    // ensuring that each is followed by a non-NULL character:

    while ((psz = wcschr(psz, ch)) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +
         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocADsMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    // Then copy the key data buffer there:

    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;


    // Remember, wcstok has the side effect of replacing the delimiter
    // by NULL, which is precisely what we want:

    psz = wcstok (pDest, szTokenList);

    while (psz) {

        *ppToken++ = psz;
        psz = wcstok (NULL, szTokenList);
    }

    pResult->cTokens = cTokens;

    return( pResult );
}



HRESULT
BuildLDAPPathFromADsPath2(
    LPWSTR szADsPathName,
    LPWSTR *pszLDAPServer,
    LPWSTR *pszLDAPDn,
    DWORD * pdwPort
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR szLDAPServer = NULL;
    LPWSTR szLDAPDn = NULL;
    DWORD dwPortNumber = 0;

    *pszLDAPServer = NULL;
    *pszLDAPDn = NULL;
    *pdwPort = 0;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(szADsPathName, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwPortNumber = pObjectInfo->PortNumber;


    dwNumComponents = pObjectInfo->NumComponents;

    //
    // Assumption LDAPPath is always less than the ADsPath
    //

    if (!pObjectInfo->TreeName && !dwNumComponents) {

        //
        // At the very minimum, we need a treename
        //

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (pObjectInfo->TreeName){

       szLDAPServer = (LPWSTR)AllocADsMem((wcslen(szADsPathName) +1)*sizeof(WCHAR));
       if (!szLDAPServer) {
           hr = E_OUTOFMEMORY;
           BAIL_ON_FAILURE(hr);
       }

        _tcscat(szLDAPServer, pObjectInfo->TreeName);

    }

    if (dwNumComponents){

       szLDAPDn = (LPWSTR)AllocADsMem((wcslen(szADsPathName) +1)*sizeof(WCHAR));

       if (!szLDAPDn) {
          hr = E_OUTOFMEMORY;
          BAIL_ON_FAILURE(hr);
       }

        switch (pObjectInfo->dwPathType) {

        case PATHTYPE_X500:
        default:
            for (i = 0; i < dwNumComponents; i++) {

                AppendComponent(
                    szLDAPDn,
                     &(pObjectInfo->ComponentArray[i])
                    );

                if (i < (dwNumComponents - 1)){
                    _tcscat(szLDAPDn, TEXT(","));
                }
            }
            break;


        case PATHTYPE_WINDOWS:
            for (i = dwNumComponents; i >  0; i--) {

                AppendComponent(
                    szLDAPDn,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

                if ((i - 1) > 0){
                    _tcscat(szLDAPDn, TEXT(","));
                }
            }
            break;

        }

    }

    if (szLDAPServer  && *szLDAPServer) {
       *pszLDAPServer = szLDAPServer;
    }

   if (szLDAPDn && *szLDAPDn) {
       *pszLDAPDn = szLDAPDn;
   }

   *pdwPort =  dwPortNumber;

error:

    if (szLDAPServer  && (*szLDAPServer == NULL)) {
       FreeADsMem(szLDAPServer);
    }

    if (szLDAPDn  && (*szLDAPDn == NULL)) {
       FreeADsMem(szLDAPDn);
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}


HRESULT
BuildADsPathFromLDAPPath2(
    DWORD  dwServerPresent,
    LPWSTR szADsNamespace,
    LPWSTR szLDAPServer,
    DWORD  dwPort,
    LPWSTR szLDAPDn,
    LPWSTR * ppszADsPathName
    )
{
    LPWSTR pszADsPathName = NULL;
    HRESULT hr = S_OK;
    DWORD dwLen;
    WCHAR szPort[32];
    LPWSTR pszDisplayDN = NULL;

    hr = GetDisplayName(
             szLDAPDn,
             &pszDisplayDN
             );
    BAIL_ON_FAILURE(hr);

    dwLen = STRING_LENGTH(szADsNamespace) +
            STRING_LENGTH(szLDAPServer) +
            STRING_LENGTH(pszDisplayDN) +
            STRING_LENGTH(L"//") +
            STRING_LENGTH(L"/") +
            1;

    if (IS_EXPLICIT_PORT(dwPort) ) {
        wsprintf(szPort, L":%d", dwPort);
        dwLen += STRING_LENGTH(szPort);
    }


    pszADsPathName = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );

    if(!pszADsPathName) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wsprintf(pszADsPathName,L"%s//", szADsNamespace);

    if (dwServerPresent) {

        if (szLDAPServer && *szLDAPServer) {

            wcscat(pszADsPathName, szLDAPServer);

            if (IS_EXPLICIT_PORT(dwPort) ) {

                wsprintf(szPort, L":%d", dwPort);
                wcscat(pszADsPathName, szPort);

            }

        }

        if (pszDisplayDN && *pszDisplayDN) {

            wcscat(pszADsPathName, L"/");
            wcscat(pszADsPathName, pszDisplayDN);

        }

    }else {

        if (pszDisplayDN && *pszDisplayDN) {
            wcscat(pszADsPathName, pszDisplayDN);
        }


    }

    *ppszADsPathName = pszADsPathName;

error:
    if (pszDisplayDN) {
        FreeADsMem(pszDisplayDN);
    }

    RRETURN(hr);
}


HRESULT
GetNamespaceFromADsPath(
    LPWSTR szADsPath,
    LPWSTR pszNamespace
    )
{
    LPWSTR pszTemp;

    // Get the namespace name

    pszTemp = _tcschr( szADsPath, TEXT(':'));
    if (!pszTemp) {
        RRETURN(E_FAIL);
    }
    _tcsncpy (pszNamespace, szADsPath, (int)(pszTemp - szADsPath));
    pszNamespace[pszTemp - szADsPath] = L'\0';

    RRETURN(S_OK);

}

//
// Change the separator of a DN from '\' to '/' so that it can be used in
// an ADsPath

HRESULT
ChangeSeparator(
    LPWSTR pszDN
    )
{

    LPWSTR ptr;

    if (pszDN) {

        while (ptr = wcschr(pszDN, '\\')) {
            *ptr = '/';
        }

    }

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\odssz.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       odssz.cxx
//
//  Contents:   DSObject Size Routines
//
//  Functions:
//
//  History:    25-Feb-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"

DWORD
AdsTypeDNStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}

DWORD
AdsTypeCaseExactStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->CaseExactString) + 1) *sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}


DWORD
AdsTypeCaseIgnoreStringSize(
    PADSVALUE lpAdsSrcValue
    )

{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1) *sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}


DWORD
AdsTypePrintableStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->PrintableString) + 1) *sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}

DWORD
AdsTypeNumericStringSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->NumericString) + 1)* sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}



DWORD
AdsTypeBooleanSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(0);
    }

    return(0);
}


DWORD
AdsTypeIntegerSize(
    PADSVALUE lpAdsSrcValue
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeOctetStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(0);
    }

    //
    // Add bytes to the size as we need to align all the
    // OctetStrings on at least 8 byte boundaries.  We'll
    // worst-case align to be conservative for IA64.
    // ALIGN_WORST is defined in priv inc which also defines
    // the ROUND_UP macro used.
    //
    dwNumBytes = lpAdsSrcValue->OctetString.dwLength + ALIGN_WORST - 1;

    return(dwNumBytes);
}


DWORD
AdsTypeSecurityDescriptorSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NT_SECURITY_DESCRIPTOR){
        return(0);
    }

    //
    // Security Descriptors need to be DWORD aligned but we
    // provide worst case alignment as C structs have 8 bytes alignment
    // (at least on x86).
    // ALIGN_WORST defined in align.h in priv inc, which also
    // has the round up macro used.
    //
    dwNumBytes = lpAdsSrcValue->SecurityDescriptor.dwLength + ALIGN_WORST - 1;

    return(dwNumBytes);
}


DWORD
AdsTypeTimeSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeLargeIntegerSize(
    PADSVALUE lpAdsSrcValue
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_LARGE_INTEGER){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeProvSpecificSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PROV_SPECIFIC){
        return(0);
    }

    //
    // We don't know what it contains, so assume worst-case alignment
    //
    dwNumBytes =  lpAdsSrcValue->ProviderSpecific.dwLength + (ALIGN_WORST-1);

    return(dwNumBytes);
}


//
// Computes size of the data in the DNWithBinary object
//
DWORD
AdsTypeDNWithBinarySize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwStrLen = 0;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_BINARY) {
        return 0;
    }

    if (!lpAdsSrcValue->pDNWithBinary) {
        return(0);
    }

    //
    // The length is EncodedBinLen+dnlen+:+:+:+B+10 (for int len)
    //

    if (lpAdsSrcValue->pDNWithBinary->pszDNString) {
        dwStrLen = (wcslen(lpAdsSrcValue->pDNWithBinary->pszDNString)+1);

        //
        // strings must be WCHAR (WORD) aligned
        //
        dwSize += dwStrLen * sizeof(WCHAR) + (ALIGN_WORD-1);

    }

    //
    // Each byte is 2 wchars in the final string
    //
    if (lpAdsSrcValue->pDNWithBinary->dwLength) {
        dwSize += (lpAdsSrcValue->pDNWithBinary->dwLength);
        //
        // our cushion when reading from string encoded binary value
        // to byte array and one WCHAR for \0 of string
        //
        // worst-case align the binary data, since we don't know
        // how it will be accessed
        //
        dwSize += sizeof(DWORD) + sizeof(WCHAR) + (ALIGN_WORST-1);
    }

    //
    // provide worst-case alignment of the structure
    //
    dwSize += sizeof(ADS_DN_WITH_BINARY) + (ALIGN_WORST-1);
    return dwSize;
}

//
// Computes size of the data in the DNWithString object.
//
DWORD
AdsTypeDNWithStringSize(
    PADSVALUE pAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwStrLen = 0;

    if (pAdsSrcValue->dwType != ADSTYPE_DN_WITH_STRING) {
        return 0;
    }

    if (!pAdsSrcValue->pDNWithString) {
        return(0);
    }

    //
    // align the strings on WCHAR (WORD) boundaries
    // provide worst-case alignment for the structure
    //
    if (pAdsSrcValue->pDNWithString->pszDNString) {
        dwStrLen = wcslen(pAdsSrcValue->pDNWithString->pszDNString) + 1;
        dwSize += dwStrLen * sizeof(WCHAR) + (ALIGN_WORD-1);
    }

    if (pAdsSrcValue->pDNWithString->pszStringValue) {
        dwStrLen = wcslen(pAdsSrcValue->pDNWithString->pszStringValue) + 1;
        dwSize += dwStrLen * sizeof(WCHAR) + (ALIGN_WORD-1);
    }

    //
    // Now for the strcut itself.
    //

    dwSize += sizeof(ADS_DN_WITH_STRING) + (ALIGN_WORST-1);

    return dwSize;
}


DWORD
AdsTypeSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        dwSize = AdsTypeDNStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        dwSize = AdsTypeCaseExactStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        dwSize = AdsTypeCaseIgnoreStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        dwSize = AdsTypePrintableStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        dwSize = AdsTypeNumericStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_BOOLEAN:
        dwSize = AdsTypeBooleanSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_INTEGER:
        dwSize = AdsTypeIntegerSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_OCTET_STRING:
        dwSize = AdsTypeOctetStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_UTC_TIME:
        dwSize = AdsTypeTimeSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_LARGE_INTEGER:
        dwSize = AdsTypeLargeIntegerSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_PROV_SPECIFIC:
        dwSize = AdsTypeProvSpecificSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        dwSize = AdsTypeSecurityDescriptorSize(
                lpAdsSrcValue
                );
    break;

    case ADSTYPE_DN_WITH_BINARY:
        dwSize = AdsTypeDNWithBinarySize(
                     lpAdsSrcValue
                     );
        break;

    case ADSTYPE_DN_WITH_STRING:
        dwSize = AdsTypeDNWithStringSize(
                     lpAdsSrcValue
                     );
        break;

    default:
        break;
    }

    return(dwSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\parse.cxx ===
//--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  parse.cxx
//
//  Contents:  LDAP Pathname Parser
//
//    The Pathname Parser is a key component in ADs providers. It checks for
//    syntactic validity of an ADs pathname that has been passed to this
//    provider. If the syntax is valid, then an OBJECTINFO structure is
//    constructed. This OBJECTINFO structure contains a componentized version
//    of the ADs pathname for this object.
//
//    Note all that is being done is a syntax check. Rather than special-case
//    every single new nuance to pathnames, all path checking must conform to
//    the grammar rules laid out by the parser.
//
//
//
//  History:
//----------------------------------------------------------------------------

#include <stdlib.h>
#include "ldapc.hxx"

#pragma hdrstop

// Object -> PathName, Type, eos
// Object -> PathName, eos

KWDLIST KeywordList[] =
{
    { TOKEN_DOMAIN,      DOMAIN_CLASS_NAME },
    { TOKEN_USER,        USER_CLASS_NAME },
    { TOKEN_GROUP,       GROUP_CLASS_NAME },
    { TOKEN_COMPUTER,    COMPUTER_CLASS_NAME },
    { TOKEN_PRINTER,     PRINTER_CLASS_NAME },
    { TOKEN_SERVICE,     SERVICE_CLASS_NAME },
    { TOKEN_FILESERVICE, FILESERVICE_CLASS_NAME },
    { TOKEN_FILESHARE,   FILESHARE_CLASS_NAME },
    { TOKEN_SCHEMA,      SCHEMA_CLASS_NAME },
    { TOKEN_CLASS,       CLASS_CLASS_NAME },
    { TOKEN_PROPERTY,    PROPERTY_CLASS_NAME },
    { TOKEN_SYNTAX,      SYNTAX_CLASS_NAME },
    { TOKEN_LOCALITY,     LOCALITY_CLASS_NAME },
    { TOKEN_ORGANIZATION, ORGANIZATION_CLASS_NAME },
    { TOKEN_ORGANIZATIONUNIT, ORGANIZATIONUNIT_CLASS_NAME },
    { TOKEN_COUNTRY,      COUNTRY_CLASS_NAME },
    { TOKEN_ROOTDSE,     ROOTDSE_CLASS_NAME}
};


DWORD gdwKeywordListSize = sizeof(KeywordList)/sizeof(KWDLIST);

HRESULT
InitObjectInfo(
    LPWSTR pszADsPathName,
    POBJECTINFO pObjectInfo
    )
{
    DWORD dwLen = 0;
    HRESULT hr = S_OK;

    ADsAssert(pObjectInfo);
    ADsAssert(pszADsPathName);

    memset(pObjectInfo, 0x0, sizeof(OBJECTINFO));

    dwLen = wcslen(pszADsPathName) * sizeof(WCHAR) * 3;
    if( dwLen ) {
        pObjectInfo->szStrBuf = (LPWSTR) AllocADsMem(dwLen);
        pObjectInfo->szDisplayStrBuf = (LPWSTR) AllocADsMem(dwLen);

        if (!pObjectInfo->szStrBuf || !pObjectInfo->szDisplayStrBuf) {
            RRETURN(E_OUTOFMEMORY);
        }

        pObjectInfo->szStrBufPtr = pObjectInfo->szStrBuf;
        pObjectInfo->szDisplayStrBufPtr = pObjectInfo->szDisplayStrBuf;
    }

    RRETURN(hr);
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    if (pObjectInfo->szStrBuf) {
        FreeADsStr( pObjectInfo->szStrBuf );
    }
    if (pObjectInfo->szDisplayStrBuf) {
        FreeADsStr( pObjectInfo->szDisplayStrBuf );
    }
}


HRESULT
ADsObject(
    LPWSTR pszADsPathName,
    POBJECTINFO pObjectInfo
    )
{
    HRESULT hr = S_OK;

    CLexer Lexer;
    hr = Lexer.InitializePath(pszADsPathName);
    BAIL_ON_FAILURE(hr);

    hr = InitObjectInfo(pszADsPathName, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->ObjectType = TOKEN_LDAPOBJECT;

    hr = ADsObjectParse(&Lexer, pObjectInfo);

error:

    RRETURN(hr);
}


HRESULT
GetNextToken(
    CLexer *pTokenizer,
    POBJECTINFO pObjectInfo,
    LPWSTR *ppszToken,
    LPWSTR *ppszDisplayToken,
    DWORD *pdwToken
    )
{

    HRESULT hr = S_OK;

    ADsAssert(ppszToken);
    *ppszToken = NULL;

    if (ppszDisplayToken) {
        *ppszDisplayToken = NULL;
    }

    hr = pTokenizer->GetNextToken(
             pObjectInfo->szStrBufPtr,
             pObjectInfo->szDisplayStrBufPtr,
             pdwToken
             );
    BAIL_ON_FAILURE(hr);

    *ppszToken = pObjectInfo->szStrBufPtr;

    if (ppszDisplayToken) {
        *ppszDisplayToken = pObjectInfo->szDisplayStrBufPtr;
    }

    if(*pdwToken != TOKEN_END)
    {
        pObjectInfo->szStrBufPtr += wcslen(pObjectInfo->szStrBufPtr) + 1;

        pObjectInfo->szDisplayStrBufPtr += wcslen(pObjectInfo->szDisplayStrBufPtr) + 1;    
    }

error:

    RRETURN (hr);


}


HRESULT
GetNextToken(
    CLexer *pTokenizer,
    POBJECTINFO pObjectInfo,
    LPWSTR *ppszToken,
    DWORD *pdwToken
    )
{
    return (GetNextToken(
                pTokenizer,
                pObjectInfo,
                ppszToken,
                NULL,
                pdwToken
                ));

}
//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <LDAPObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsObjectParse(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch ( dwToken ) {
        case TOKEN_END:
            RRETURN(S_OK);

        default:
            hr = pTokenizer->PushBackToken();
            BAIL_IF_ERROR(hr);

            hr = LDAPObject(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            break;
    }

cleanup:

    RRETURN(hr);

}



//+---------------------------------------------------------------------------
//  Function:   LDAPObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <LDAPObject> -> "\\""identifier""\" <LDAPObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
LDAPObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    LPWSTR szDisplayToken;
    DWORD dwToken, dwPort;
    HRESULT hr;
    WCHAR c = L'\0';

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    if (!_wcsicmp(szToken, L"schema")) {

        hr = pTokenizer->PushBackToken();  // push back the identifier
        BAIL_IF_ERROR(hr);

        pObjectInfo->dwServerPresent = FALSE;

        hr = PathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);

    } else if (!_wcsicmp(szToken, L"rootdse")) {

       hr = pTokenizer->PushBackToken(); // push back the identifier
       BAIL_IF_ERROR(hr);

       pObjectInfo->dwServerPresent = FALSE;

       hr = PathName(pTokenizer, pObjectInfo);
       BAIL_IF_ERROR(hr);

       hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
       BAIL_IF_ERROR(hr);

    } else if (((c = (CHAR)pTokenizer->NextChar()) == TEXT('=')) || (c == TEXT(','))  || (c == TEXT(';')))
    {
        pTokenizer->PushbackChar();  // push back =

        hr = pTokenizer->PushBackToken();  // push back the identifier
        BAIL_IF_ERROR(hr);

        pObjectInfo->dwServerPresent = FALSE;


        hr = PathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);
    }
    else
    {
        pTokenizer->PushbackChar();

        hr = AddTreeName(pObjectInfo, szToken, szDisplayToken);
        BAIL_IF_ERROR(hr);

        pObjectInfo->dwServerPresent = TRUE;

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        //
        // Check if we have an explicit port number
        //

        if ( dwToken == TOKEN_COLON) {

            //
            // Get the port number and set it in the ObjectInfo structure
            //

            hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
            BAIL_IF_ERROR(hr);

            if (dwToken == TOKEN_END) {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

            dwPort = _wtoi(szToken);
            if (dwPort == 0) {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

            AddPortNumber(pObjectInfo, dwPort);

            hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
            BAIL_IF_ERROR(hr);

        }

        //
        // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
        //

        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }

        if (dwToken == TOKEN_FSLASH) {

            hr = PathName(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);

            hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
            BAIL_IF_ERROR(hr);

        } else if ( dwToken == TOKEN_COMMA || dwToken == TOKEN_SEMICOLON ) {
            // do nothing here
        } else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }
    }

    switch (dwToken) {
    case TOKEN_END:
        RRETURN(S_OK);

    default:
        RRETURN(E_ADS_BAD_PATHNAME);

    }
cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    DWORD dwToken;
    HRESULT hr;
    DWORD dwPort;

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);
        hr = AddNamespaceName(pObjectInfo, szToken);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }
    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);
        hr = AddNamespaceName(pObjectInfo, szToken);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Add the default port number depending on the namespace.
    // If an explicit port number is specified, that will override
    //

    if ( _wcsicmp( pObjectInfo->NamespaceName, szGCNamespaceName) == 0 ) {
        dwPort = (DWORD) USE_DEFAULT_GC_PORT;
    }
    else {
        dwPort = (DWORD) USE_DEFAULT_LDAP_PORT;
    }

    AddPortNumber(pObjectInfo, dwPort);

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component
HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    DWORD dwToken;
    HRESULT hr;

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    LPWSTR szToken = NULL;
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (!pObjectInfo->dwPathType) {

        if (dwToken == TOKEN_FSLASH) {

            pObjectInfo->dwPathType = PATHTYPE_WINDOWS;
            RRETURN (PathName(pTokenizer, pObjectInfo));
        }else if (dwToken == TOKEN_COMMA || dwToken == TOKEN_SEMICOLON){

            pObjectInfo->dwPathType = PATHTYPE_X500;
            RRETURN (PathName(pTokenizer, pObjectInfo));
        }else{
            hr = pTokenizer->PushBackToken();
            RRETURN (S_OK);
        }
    }else if (pObjectInfo->dwPathType == PATHTYPE_WINDOWS){

        if (dwToken == TOKEN_FSLASH) {
                RRETURN (PathName(pTokenizer, pObjectInfo));
        }else{
            hr = pTokenizer->PushBackToken();
            RRETURN (S_OK);
        }
    }else if (pObjectInfo->dwPathType == PATHTYPE_X500){

        if (dwToken == TOKEN_COMMA || dwToken == TOKEN_SEMICOLON) {
                RRETURN (PathName(pTokenizer, pObjectInfo));
        }else{
            hr = pTokenizer->PushBackToken();
            RRETURN (S_OK);
        }
    }else {

        //
        // We should never hit this point
        //

        hr = E_FAIL;
    }

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szValue = NULL;
    LPWSTR szDisplayValue = NULL;
    LPWSTR szEqual = NULL;
    LPWSTR szComponent = NULL;
    LPWSTR szDisplayComponent = NULL;
    DWORD dwToken;
    HRESULT hr = S_OK;

    hr = GetNextToken(pTokenizer, pObjectInfo, &szComponent, &szDisplayComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        BAIL_IF_ERROR( hr = E_ADS_BAD_PATHNAME);
    }

    hr = GetNextToken(pTokenizer, pObjectInfo, &szEqual, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_EQUAL) {

        hr = GetNextToken(pTokenizer, pObjectInfo, &szValue, &szDisplayValue, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            BAIL_IF_ERROR(hr = E_ADS_BAD_PATHNAME);
        }

        hr = AddComponent(pObjectInfo, szComponent, szValue, szDisplayComponent, szDisplayValue);
        BAIL_IF_ERROR(hr);

    }else {

        hr = AddComponent(pObjectInfo, szComponent, NULL, szDisplayComponent, NULL);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->PushBackToken();
        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    DWORD dwToken;
    HRESULT hr;

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            BAIL_IF_ERROR(hr);
        }
        pObjectInfo->ObjectClass = szToken;
    }

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
__declspec(dllexport)
CLexer::CLexer():
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE),
                _bFSlashDisabled(FALSE),
                _bExclaimDisabled(FALSE) 
{}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
__declspec(dllexport)
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPTSTR szToken, LPTSTR szDisplayToken, LPDWORD pdwToken)
{
    TCHAR c, cnext;
    DWORD state = 0;
    LPTSTR pch = szToken;
    LPTSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    if (!szToken) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();

        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            switch (c) {

            case TEXT('"') :
                //
                // Quoting;
                //

                fQuotingOn = TRUE;

                state = 1;
                break;

            case TEXT('\\') :
                //
                // Escaping; Ignore the '\' in the token and check to make
                // sure that the next character exists
                //
                cnext = NextChar();
                if (cnext == TEXT('/')) {
                    pch--;
                }
                PushbackChar();

                fEscapeOn = TRUE;

                state = 1;
                break;

            case TEXT('/') :
                if (!_bFSlashDisabled) {
                    *pdwToken = TOKEN_FSLASH;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }
                else {
                    state = 1;
                }
                break;
            case TEXT(',') :
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(';') :
                *pdwToken = TOKEN_SEMICOLON;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('=') :
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(':') :
                if (!_bAtDisabled && !_bExclaimDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
                break;

            case TEXT('\0') :
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('@') :

                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
                break;

            case TEXT('!') :

                if (!_bAtDisabled && !_bExclaimDisabled) {
                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
                break;

            case TEXT(' ') :
                pch--;
                _dwLastTokenLength--;
                break;

            default:
                state = 1;
                break;

            }
            break;

        case 1:

            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_ADS_BAD_PATHNAME);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                } 
                else if (c == TEXT('\\')) {
                    //
                    // This is a special case, where a \ is 
                    // being passed in to escape something inside
                    // quotes.
                    //
                    fEscapeOn = TRUE;
                    _dwLastTokenLength++;

                    *pch++ = c;

                    cnext = NextChar();
                    if (cnext == '/') {
                        pch--;
                    }
                    PushbackChar();
                    state = 1;
                    break;
                }
                *pch++ = c;
                _dwLastTokenLength++;
                break;
            }
            //
            // Ok to put a switch here as all have breaks above.
            //
            switch (c) {
            case TEXT('\\') :

                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                *pch++ = c;

                cnext = NextChar();
                if (cnext == '/') {
                    pch--;
                }
                PushbackChar();

                break;

            case TEXT('"') :
                fQuotingOn = TRUE;
                *pch++ = c;
                _dwLastTokenLength++;
                break;

            case TEXT('\0'):
            case TEXT(',') :
            case TEXT('=') :
            case TEXT(';') :
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);
                break;

            case TEXT('/') :
                if (!_bFSlashDisabled) {
                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }
                else {
                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                }
                break;
            case TEXT('!') :
            case TEXT(':') :
                if (!_bAtDisabled && !_bExclaimDisabled) {

                    PushbackChar();
                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);

                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }
            case TEXT('@') :          
                if (!_bAtDisabled) {

                    PushbackChar();
                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);

                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }

            default :
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            break;
        default:
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}


__declspec(dllexport)
HRESULT
CLexer::GetNextToken(LPTSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
TCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == TEXT('\0')) {
        _dwEndofString = TRUE;
        return(TEXT('\0'));
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPTSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < gdwKeywordListSize; i++) {
        if (!_tcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}

__declspec(dllexport)
HRESULT
CLexer::InitializePath(LPTSTR szBuffer)
{
    HRESULT hr = S_OK;
    
    _Buffer = AllocADsStr(szBuffer);
    if(!_Buffer && szBuffer)
    {
        hr = E_OUTOFMEMORY;
    }
    _ptr = _Buffer;

    return hr;
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo,
             LPTSTR szComponent,
             LPTSTR szValue,
             LPTSTR szDisplayComponent,
             LPTSTR szDisplayValue
             )
{
    if (!szComponent || !*szComponent || !szDisplayComponent || !*szDisplayComponent) {
        RRETURN(E_FAIL);
    }

    if ( pObjectInfo->NumComponents < MAXCOMPONENTS ) {

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                    szComponent;

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                    szValue;

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szComponent =
                    szDisplayComponent;

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szValue =
                    szDisplayValue;

        pObjectInfo->NumComponents++;

        RRETURN(S_OK);

    } else {

        RRETURN(E_ADS_BAD_PATHNAME);
    }

}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPTSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }


    if (_tcscmp(szToken, szLDAPNamespaceName) == 0 ||
        _tcscmp(szToken, szGCNamespaceName) == 0) {

        //
        // szProviderName is the provider name for both LDAP and GC namespaces
        //

        pObjectInfo->ProviderName = szProviderName;
    }
    else {

        //
        // Not one of the namespaces we handle, just copy
        //

        pObjectInfo->ProviderName = szToken;
    }

    RRETURN(S_OK);
}

HRESULT
AddNamespaceName(POBJECTINFO pObjectInfo, LPTSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->NamespaceName = szToken;

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPTSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken || !szDisplayToken || !*szDisplayToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = szToken;
    pObjectInfo->DisplayTreeName = szDisplayToken;

    RRETURN(S_OK);
}


HRESULT
AddPortNumber(POBJECTINFO pObjectInfo, DWORD dwPort)
{
    pObjectInfo->PortNumber = dwPort;

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}

void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}

void
CLexer::SetFSlashDisabler(
    BOOL bFlag
    )
{
    _bFSlashDisabled = bFlag;
}

BOOL
CLexer::GetFSlashDisabler()
{
    return(_bFSlashDisabled);
}

void
CLexer::SetExclaimnationDisabler(
    BOOL bFlag
    )
{
    _bExclaimDisabled = bFlag;
}

BOOL
CLexer::GetExclaimnationDisabler()
{
    return(_bExclaimDisabled);
}

HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;

    BOOL        fQuoteMode = FALSE; // TRUE means we're processing between
                                    // quotation marks
    BOOL        fEscaped = FALSE;   // TRUE means next one char to be 
                                    // processed should be treated as literal

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;

    //
    // Parsing Algorithm:
    //
    // If this char follows an unescaped backslash:
    //      Treat as literal, treat next char regularly (set fEscaped = FALSE)
    // Else, if we're between quotation marks:
    //      If we see a quotation mark, leave quote mode
    //      Else, treat as literal
    // Else, if we're not between quote marks, and we see a quote mark:
    //      Enter quote mode
    // Else, if we see a backslash (and we're not already in escape or quote
    // mode):
    //      Treat next char as literal (set fEscaped = TRUE)
    // Else, if we see a forward-slash (and we're not in escape or quote mode):
    //      We need to escape it by prefixing with a backslash
    // Else:
    //      Do nothing, just a plain old character
    // Go on to next character, and repeat
    //
    // Backslashes inside quotation marks are always treated as literals,
    // since that is the definition of being inside quotation marks
    //
    while (*pch) {
        if (fEscaped) {
            fEscaped = FALSE;
        }
        else if (fQuoteMode) {
            if (*pch == L'"') {
                fQuoteMode = FALSE;
            }
        }
        else if (*pch == L'"') {
            fQuoteMode = TRUE;
        }
        else if (*pch == L'\\') {
            fEscaped = TRUE;
        }
        else if (*pch == L'/') {
            //
            // include space for the escape char
            // we'll need to add
            //
            len++;
        }

        len++;

        pch++;
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName;
    pszDisplayCh = pszDisplay;

    fEscaped = FALSE;
    fQuoteMode = FALSE;

    while (*pch) {
        if (fEscaped) {
            fEscaped = FALSE;
        }
        else if (fQuoteMode) {
            if (*pch == L'"') {
                fQuoteMode = FALSE;
            }
        }
        else if (*pch == L'"') {
            fQuoteMode = TRUE;
        }
        else if (*pch == L'\\') {
            fEscaped = TRUE;
        }
        else if (*pch == L'/') {
            //
            // unescaped forward slash needs to get escaped
            //
            *pszDisplayCh++ = L'\\';
        }

        *pszDisplayCh++ = *pch;

        pch++;
    }
    
    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}

//
// Convert an ADs path to LDAP path
//

HRESULT
GetLDAPTypeName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{
    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = NULL;
    LPWSTR pszDisplayCh = NULL;
    LPWSTR pszDisplay = NULL;    
    

    if (!ppszDisplayName ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (E_ADS_BAD_PATHNAME);
    }

    pch = szName;

    //
    // Parsing algorithm
    // if this character is an escaped back slash
    //    if next character is a forward slash (we know this is a kind of ADsPath)
    //        we will remove the back slash
    // accepts the current character
    // goes on to process the next character
    //

    while (*pch) {
    	if(*pch == L'\\') {

    		pch++;
    		//
    		// If next character is /, we need to remove the escape character
    		//
    		if(*pch != L'/') {
    			len++;
    		}
    		    		
    	}

    	if(*pch) {
    		len++;
            pch++;		
    	}
    	
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName;
    pszDisplayCh = pszDisplay;

    

    while (*pch) {
    	if(*pch == L'\\') {
    		//
    		// If next character is /, we need to remove the escape character
    		//
    		pch++;
    		
    		if(*pch != L'/') {
    			*pszDisplayCh++ = L'\\';
    		}
    		   		
    	}    	

        if(*pch) {
        	*pszDisplayCh++ = *pch;
            pch++;		
        }
    	
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;    

error:    	

    RRETURN(hr);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\sconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  sconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

#define NULL_TERMINATED 0

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;        

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength,
                                  pUnicode,
                                  StringLength + 1);

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}

int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        if(!pTempBuf)
        {
            return rc;
        }
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength - 1,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        pAnsi[StringLength - 1] = 0;
    }

    if(pTempBuf)
    {
        LocalFree( pTempBuf );
    }

    return rc;
}

LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}

void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}


DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //

    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


HRESULT
UnicodeToUTF8String(
    LPCWSTR pUnicode,
    LPSTR *ppUTF8
    )
{
    HRESULT hr = S_OK;

    int UnicodeLength = 0;

    LPSTR pUTF8Temp = NULL;
    int UTF8TempLength = 0;
    
    int UTF8Length = 0;

    if (!pUnicode || !ppUTF8)
        BAIL_ON_FAILURE(hr = E_INVALIDARG)

    UnicodeLength = wcslen(pUnicode);
    UTF8TempLength = LdapUnicodeToUTF8(
                            pUnicode,
                            UnicodeLength,
                            NULL,
                            0
                            );
       
    if(!UTF8TempLength)
    {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }
    
    pUTF8Temp = (char*) AllocADsMem(UTF8TempLength + 1);
    if (!pUTF8Temp)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    UTF8Length = LdapUnicodeToUTF8(pUnicode,
                                   UnicodeLength,
                                   pUTF8Temp,
                                   UTF8TempLength + 1);
    if (UTF8Length == 0)
        BAIL_ON_FAILURE(hr = E_FAIL);

    *(pUTF8Temp+UTF8TempLength) = '\0';
   
    *ppUTF8 = pUTF8Temp;
    
    return(hr);

error:
    if (pUTF8Temp)
        FreeADsMem(pUTF8Temp);

    return (hr);
}


HRESULT
UTF8ToUnicodeString(
    LPCSTR   pUTF8,
    LPWSTR *ppUnicode
    )
{
    HRESULT hr = S_OK;

    int UTF8Length = 0;

    LPWSTR pUnicodeTemp = NULL;
    int UnicodeTempLength = 0;

    int UnicodeLength = 0;

    if (!pUTF8 || !ppUnicode)
        BAIL_ON_FAILURE(hr = E_INVALIDARG)

    UTF8Length = strlen(pUTF8);
    UnicodeTempLength = LdapUTF8ToUnicode(pUTF8,
                                      UTF8Length,
                                      NULL,
                                      0);
    if(UnicodeTempLength == 0)
    {
        BAIL_ON_FAILURE(E_FAIL);
    }
    
    pUnicodeTemp = (PWCHAR) AllocADsMem(UnicodeTempLength + 1);
    if (!pUnicodeTemp)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    UnicodeLength = LdapUTF8ToUnicode(pUTF8,
                                      UTF8Length,
                                      pUnicodeTemp,
                                      UnicodeTempLength + 1);
    if (UnicodeLength == 0)
        BAIL_ON_FAILURE(hr = E_FAIL);


    *(pUnicodeTemp + UnicodeTempLength) = '\0';

    *ppUnicode = pUnicodeTemp;    

    return(hr);

error:
    if (pUnicodeTemp)
        FreeADsMem(pUnicodeTemp);

    return (hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\schmgmt.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  schmgmt.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop


HRESULT
ADsEnumAttributes(
    LPWSTR pszLdapServer,
    LPWSTR pszLdapDn,
    CCredentials Credentials,
    DWORD dwPort,
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    HRESULT hr = S_OK;

    LDAP_SCHEMA_HANDLE hSchema = NULL;
    DWORD cAttributes, cClasses;
    PROPERTYINFO *pPropertyInfo;

    DWORD dwMemSize = 0, dwStrBufSize = 0;

    DWORD dwLdapSyntax;

    LPBYTE pBuffer = NULL;
    LPWSTR pszNameEntry = NULL;
    PADS_ATTR_DEF pAttrDefEntry = NULL;

    ULONG i;

    if ( !ppAttrDefinition || !pdwNumAttributes ||
        (((LONG)dwNumAttributes) < 0 && ((LONG)dwNumAttributes) != -1) ) {
        RRETURN (E_INVALIDARG);
    }

    *ppAttrDefinition = NULL;
    *pdwNumAttributes = NULL;

    hr = SchemaOpen(
             pszLdapServer,
             &hSchema,
             Credentials,
             dwPort
             );
    BAIL_ON_FAILURE(hr);

    if (dwNumAttributes != (DWORD)-1) {
        //
        // List of attributes specified;
        //

        cAttributes = 0;

        for (i=0; i < dwNumAttributes; i++) {

            hr = SchemaGetPropertyInfo(
                     hSchema,
                     ppszAttrNames[i],
                     &pPropertyInfo);

            BAIL_ON_FAILURE(hr);

            if (pPropertyInfo != NULL) {
                cAttributes++;
                dwStrBufSize += (wcslen(ppszAttrNames[i]) + 1) * sizeof (WCHAR);
            }

        }

        dwMemSize = sizeof(ADS_ATTR_DEF) * cAttributes + dwStrBufSize;

        pBuffer = (LPBYTE) AllocADsMem(dwMemSize);

        if (!pBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pAttrDefEntry = (PADS_ATTR_DEF) pBuffer;
        pszNameEntry = (LPWSTR) (pBuffer + cAttributes * sizeof(ADS_ATTR_DEF));


        for (i=0; i < dwNumAttributes; i++) {

            hr = SchemaGetPropertyInfo(
                     hSchema,
                     ppszAttrNames[i],
                     &pPropertyInfo);

            BAIL_ON_FAILURE(hr);

            if (pPropertyInfo == NULL)
                continue;

            dwLdapSyntax = LdapGetSyntaxIdFromName(
                                           pPropertyInfo->pszSyntax);

            pAttrDefEntry->dwADsType = MapLDAPTypeToADSType(dwLdapSyntax);

            pAttrDefEntry->dwMinRange = pPropertyInfo->lMinRange;

            pAttrDefEntry->dwMaxRange = pPropertyInfo->lMaxRange;

            pAttrDefEntry->fMultiValued = !(pPropertyInfo->fSingleValued);

            wcscpy(pszNameEntry, ppszAttrNames[i]);
            pAttrDefEntry->pszAttrName = pszNameEntry;

            pszNameEntry += wcslen(ppszAttrNames[i]) + 1;
            pAttrDefEntry ++;
        }
    }
    else {
        //
        // Get all the attribute definitions
        //
        hr = SchemaGetObjectCount(
                 hSchema,
                 &cClasses,
                 &cAttributes);

        BAIL_ON_FAILURE(hr);

        dwMemSize = sizeof(ADS_ATTR_DEF) * cAttributes;

        //
        // Calculate the size of the buffer
        //

        for (i=0; i < cAttributes; i++) {

            hr = SchemaGetPropertyInfoByIndex(
                     hSchema,
                     i,
                     &pPropertyInfo);
            BAIL_ON_FAILURE(hr);

            dwMemSize += (wcslen(pPropertyInfo->pszPropertyName) + 1) * sizeof (WCHAR);

        }

        pBuffer = (LPBYTE) AllocADsMem(dwMemSize);

        if (!pBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pAttrDefEntry = (PADS_ATTR_DEF) pBuffer;
        pszNameEntry = (LPWSTR) (pBuffer + cAttributes * sizeof(ADS_ATTR_DEF));

        for (i=0; i < cAttributes; i++) {

            hr = SchemaGetPropertyInfoByIndex(
                     hSchema,
                     i,
                     &pPropertyInfo);
            BAIL_ON_FAILURE(hr);

            dwLdapSyntax = LdapGetSyntaxIdFromName(
                                           pPropertyInfo->pszSyntax);

            pAttrDefEntry->dwADsType = MapLDAPTypeToADSType(dwLdapSyntax);

            pAttrDefEntry->dwMinRange = pPropertyInfo->lMinRange;

            pAttrDefEntry->dwMaxRange = pPropertyInfo->lMaxRange;

            pAttrDefEntry->fMultiValued = !(pPropertyInfo->fSingleValued);

            wcscpy(pszNameEntry, pPropertyInfo->pszPropertyName);
            pAttrDefEntry->pszAttrName = pszNameEntry;

            pszNameEntry += wcslen(pPropertyInfo->pszPropertyName) + 1;
            pAttrDefEntry ++;
        }

    }

    *ppAttrDefinition = (PADS_ATTR_DEF) pBuffer;
    *pdwNumAttributes = cAttributes;


error:

    if ( hSchema )
        SchemaClose( &hSchema );

    if(FAILED(hr) && pBuffer)
    {
        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}


HRESULT
ADsCreateAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
ADsWriteAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
ADsDeleteAttributeDefinition(
    LPWSTR pszAttributeName
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
ADsEnumClasses(
    LPWSTR * ppszAttrNames,
    DWORD dwNumClasses,
    PADS_CLASS_DEF * ppAttrDefinition,
    DWORD * pdwNumClasses
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
ADsCreateClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
ADsWriteClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF  pClassDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
ADsDeleteClassDefinition(
    LPWSTR pszClassName
    )
{
    RRETURN (E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\schutil.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      util.cxx
//
//  Contents:  Some misc helper functions
//
//  History:
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

BOOL
IsContainer(
    LPTSTR pszClassName,
    LDAP_SCHEMA_HANDLE hSchema
);

/******************************************************************/
/*  Class SCHEMAINFO
/******************************************************************/
SCHEMAINFO::SCHEMAINFO()
    : _cRef( 0 ),
      _fObsolete( FALSE ),
      fDefaultSchema( FALSE ),
      fAppearsV3(TRUE),
      pszServerName( NULL ),
      pszSubSchemaSubEntry( NULL ),
      pszTime( NULL ),
      Next( NULL ),
      aClasses( NULL ),
      nNumOfClasses( 0 ),
      aClassesSearchTable( NULL ),
      aProperties( NULL ),
      nNumOfProperties( 0 ),
      aPropertiesSearchTable( NULL ),
      pszUserName( NULL )
{
}

SCHEMAINFO::~SCHEMAINFO()
{
    if ( pszServerName )
        FreeADsStr( pszServerName );

    if ( pszUserName )
        FreeADsStr( pszUserName );

    if ( pszSubSchemaSubEntry )
        FreeADsStr( pszSubSchemaSubEntry );

    if ( pszTime )
        FreeADsStr( pszTime );

    if ( !fDefaultSchema )
    {
        if ( aClasses )
            FreeClassInfoArray( aClasses, nNumOfClasses );

        if ( aClassesSearchTable )
            FreeADsMem( aClassesSearchTable );

        if ( aProperties )
            FreePropertyInfoArray( aProperties, nNumOfProperties );

        if ( aPropertiesSearchTable )
            FreeADsMem( aPropertiesSearchTable );
    }
}

DWORD SCHEMAINFO::AddRef()
{
    return ++_cRef;
}

DWORD SCHEMAINFO::Release()
{
    if ( _cRef > 0 )
        return --_cRef;

    return 0;
}

//
// Helper routine that looks up the syntax tables (oid and name oid)
// and returns the correct syntax corresponding to the string name.
//
DWORD
LdapGetSyntaxIdOfAttribute(
    LPWSTR pszStringSyntax
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = -1;

    dwSyntaxId = FindEntryInSearchTable(
                     pszStringSyntax,
                     g_aSyntaxSearchTable,
                     g_nSyntaxSearchTableSize
                     );

    if (dwSyntaxId == -1) {
        //
        // We also need to search in the OID based syntax table.
        //
        dwSyntaxId = FindEntryInSearchTable(
                         pszStringSyntax,
                         g_aOidSyntaxSearchTable,
                         g_nOidSyntaxSearchTableSize
                         );
    }

    return dwSyntaxId;
}


 HRESULT
LdapGetSyntaxOfAttributeOnServerHelper(
    LPTSTR  pszServerPath,
    LPTSTR  pszAttrName,
    DWORD   *pdwSyntaxId,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;
    DWORD dwEntry;
    LPWSTR pszTemp = NULL;

    *pdwSyntaxId = LDAPTYPE_UNKNOWN;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );

    BAIL_IF_ERROR(hr);

    // Support for range attributes; for eg., objectClass=Range=0-1 We should
    // ignore everything after ';' inclusive.
    //

    if ((pszTemp = wcschr(pszAttrName, L';')) != NULL ) {
        *pszTemp = L'\0';
    }

    dwEntry = FindEntryInSearchTable(
                  pszAttrName,
                  pSchemaInfo->aPropertiesSearchTable,
                  pSchemaInfo->nNumOfProperties * 2 );

    //
    // Put back the ; if we had replaced it.
    //

    if (pszTemp)
        *pszTemp = L';';

    if ( dwEntry != -1 )
    {
        //
        // This helper routine will lookup both the oid table and the
        // name based syntax table and return -1 if unsuccesful.
        //
        *pdwSyntaxId = LdapGetSyntaxIdOfAttribute(
                           pSchemaInfo->aProperties[dwEntry].pszSyntax
                           );

        if ( *pdwSyntaxId == -1 ) {
            *pdwSyntaxId = LDAPTYPE_UNKNOWN;
        }
    }
    else
    {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_IF_ERROR(hr);
    }

cleanup:

    if ( pSchemaInfo )
        pSchemaInfo->Release();

    RRETURN(hr);
}

//
// This routine calls the helper and if the flag FromServer is TRUE,
// then if we cannot find the syntax on the server then we will
// mark as obsolete and retry. This will fix some not so obvious
// cases of problems with the schema across mutliple DC's. The
// underlying assumption is that if the server sent the info, then
// it should have the schema information to match.
//
HRESULT
LdapGetSyntaxOfAttributeOnServer(
    LPTSTR  pszServerPath,
    LPTSTR  pszAttrName,
    DWORD   *pdwSyntaxId,
    CCredentials& Credentials,
    DWORD dwPort,
    BOOL fFromServer // defaulted to FALSE
    )
{
    HRESULT hr = S_OK;

    hr = LdapGetSyntaxOfAttributeOnServerHelper(
             pszServerPath,
             pszAttrName,
             pdwSyntaxId,
             Credentials,
             dwPort
             );

    //
    // Reset and retry only if fFromServer is true, and
    // the failure was E_ADS_PROPERTY_NOT_FOUND. If this is
    // a v2 server then there will be no significant perf hit
    // as we do not refresh the default schema.
    //

    if (FAILED(hr)
        && (hr == E_ADS_PROPERTY_NOT_FOUND)
        && fFromServer) {
        //
        // Mark schema as old.
        //
        hr = LdapRemoveSchemaInfoOnServer(
                 pszServerPath,
                 Credentials,
                 dwPort,
                 TRUE // force update.
                 );

        BAIL_ON_FAILURE(hr);

        hr = LdapGetSyntaxOfAttributeOnServerHelper(
                 pszServerPath,
                 pszAttrName,
                 pdwSyntaxId,
                 Credentials,
                 dwPort
                 );

        BAIL_ON_FAILURE(hr);

    }
    else {
        //
        // This is the normal exit path.
        //
        RRETURN(hr);
    }

error :

    //
    // If we get here we need to return prop not found
    // other code may depend on that. Note that we will come
    // here only if we the first try failed and something went
    // wrong while trying to force a reload of the schema.
    //
    if (FAILED(hr)) {
        RRETURN(hr = E_ADS_PROPERTY_NOT_FOUND);
    }
    else  {
        RRETURN(hr);
    }

}

HRESULT
LdapIsClassNameValidOnServer(
    LPTSTR  pszServerPath,
    LPTSTR  pszClassName,
    BOOL    *pfValid,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    *pfValid = FALSE;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );

    BAIL_IF_ERROR(hr);

    if ( FindEntryInSearchTable(
             pszClassName,
             pSchemaInfo->aClassesSearchTable,
             pSchemaInfo->nNumOfClasses * 2 ) != -1 )
    {
        *pfValid = TRUE;
    }

cleanup:

    if ( pSchemaInfo )
        pSchemaInfo->Release();

    RRETURN(hr);
}

HRESULT
LdapGetSchemaObjectCount(
    LPTSTR  pszServerPath,
    DWORD   *pnNumOfClasses,
    DWORD   *pnNumOfProperties,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );

    BAIL_IF_ERROR(hr);

    *pnNumOfClasses = pSchemaInfo->nNumOfClasses;
    *pnNumOfProperties = pSchemaInfo->nNumOfProperties;

cleanup:

    if ( pSchemaInfo )
        pSchemaInfo->Release();

    RRETURN(hr);
}

HRESULT
LdapGetSubSchemaSubEntryPath(
    LPTSTR  pszServerPath,
    LPTSTR  *ppszSubSchemaSubEntryPath,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    *ppszSubSchemaSubEntryPath = NULL;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );
    BAIL_IF_ERROR(hr);

    if ( pSchemaInfo->pszSubSchemaSubEntry )
    {
        *ppszSubSchemaSubEntryPath =
            AllocADsStr( pSchemaInfo->pszSubSchemaSubEntry );

        if ( *ppszSubSchemaSubEntryPath == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

cleanup:

    if ( pSchemaInfo )
        pSchemaInfo->Release();

    RRETURN(hr);
}

HRESULT
LdapMakeSchemaCacheObsolete(
    LPTSTR  pszServerPath,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    RRETURN( LdapRemoveSchemaInfoOnServer(
                 pszServerPath,
                 Credentials,
                 dwPort
                  )
             );
}


HRESULT
SchemaOpen(
    IN  LPTSTR  pszServerPath,
    OUT LDAP_SCHEMA_HANDLE *phSchema,
    IN CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    *phSchema = NULL;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );

    if ( FAILED(hr))
        RRETURN(hr);

    *phSchema = (HANDLE) pSchemaInfo;

    RRETURN(S_OK);
}

HRESULT
SchemaClose(
    IN OUT LDAP_SCHEMA_HANDLE  *phSchema
)
{
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) *phSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    if ( pSchemaInfo->Release() == 0 )
        *phSchema = NULL;

    RRETURN(S_OK);
}

HRESULT
SchemaAddRef(
    IN LDAP_SCHEMA_HANDLE  hSchema
)
{
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    pSchemaInfo->AddRef();

    RRETURN(S_OK);
}

HRESULT
SchemaGetObjectCount(
    LDAP_SCHEMA_HANDLE hSchema,
    DWORD   *pnNumOfClasses,
    DWORD   *pnNumOfProperties
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pnNumOfClasses = pSchemaInfo->nNumOfClasses;
    *pnNumOfProperties = pSchemaInfo->nNumOfProperties;

    RRETURN(hr);
}

HRESULT
SchemaGetClassInfoByIndex(
    LDAP_SCHEMA_HANDLE hSchema,
    DWORD     dwIndex,
    CLASSINFO **ppClassInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    *ppClassInfo = &(pSchemaInfo->aClasses[dwIndex]);

    RRETURN(hr);
}

HRESULT
SchemaGetPropertyInfoByIndex(
    LDAP_SCHEMA_HANDLE hSchema,
    DWORD     dwIndex,
    PROPERTYINFO **ppPropertyInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    *ppPropertyInfo = &(pSchemaInfo->aProperties[dwIndex]);

    RRETURN(hr);
}

HRESULT
SchemaGetClassInfo(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR  pszClassName,
    CLASSINFO **ppClassInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;
    DWORD dwIndex = (DWORD) -1;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    dwIndex = FindEntryInSearchTable(
                  pszClassName,
                  pSchemaInfo->aClassesSearchTable,
                  pSchemaInfo->nNumOfClasses * 2 );

    if ( dwIndex == -1 )
    {
        *ppClassInfo = NULL;
    }
    else
    {
        *ppClassInfo = &(pSchemaInfo->aClasses[dwIndex]);
    }

    RRETURN(hr);
}

HRESULT
SchemaGetPropertyInfo(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR  pszPropertyName,
    PROPERTYINFO **ppPropertyInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;
    DWORD dwIndex = (DWORD) -1;
    LPWSTR pszTemp = NULL;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    // Support for range attributes; for eg., objectClass=Range=0-1 We should
    // ignore everything after ';' inclusive.
    //

    if ((pszTemp = wcschr(pszPropertyName, L';')) != NULL ) {
        *pszTemp = L'\0';
    }

    dwIndex = FindEntryInSearchTable(
                  pszPropertyName,
                  pSchemaInfo->aPropertiesSearchTable,
                  pSchemaInfo->nNumOfProperties * 2 );

    //
    // Put back the ; if we had replaced it.
    //

    if (pszTemp)
        *pszTemp = L';';

    if ( dwIndex == -1 )
    {
        *ppPropertyInfo = NULL;
    }
    else
    {
        *ppPropertyInfo = &(pSchemaInfo->aProperties[dwIndex]);
    }

    RRETURN(hr);
}

HRESULT
SchemaGetSyntaxOfAttribute(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR  pszAttrName,
    DWORD   *pdwSyntaxId
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;
    LPWSTR pszTemp = NULL;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pdwSyntaxId = LDAPTYPE_UNKNOWN;

    // Support for range attributes; for eg., objectClass=Range=0-1 We should
    // ignore everything after ';' inclusive.
    //

    if ((pszTemp = wcschr(pszAttrName, L';')) != NULL ) {
        *pszTemp = L'\0';
    }

    DWORD dwEntry = FindEntryInSearchTable(
                        pszAttrName,
                        pSchemaInfo->aPropertiesSearchTable,
                        pSchemaInfo->nNumOfProperties * 2 );

    //
    // Put back the ; if we had replaced it.
    //

    if (pszTemp)
        *pszTemp = L';';

    if ( dwEntry != -1 )
    {
        *pdwSyntaxId = FindEntryInSearchTable(
                           pSchemaInfo->aProperties[dwEntry].pszSyntax,
                           g_aSyntaxSearchTable,
                           g_nSyntaxSearchTableSize );


        if ( *pdwSyntaxId == -1 ) {

            //
            // We also need to search in the OID based syntax table.
            //
            *pdwSyntaxId = FindEntryInSearchTable(
                               pSchemaInfo->aProperties[dwEntry].pszSyntax,
                               g_aOidSyntaxSearchTable,
                               g_nOidSyntaxSearchTableSize
                               );

            if ( *pdwSyntaxId == -1 ) {
                *pdwSyntaxId = LDAPTYPE_UNKNOWN;
            }
        }

    }
    else
    {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);
}

HRESULT
SchemaIsClassAContainer(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR pszClassName,
    BOOL *pfContainer
)
{
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    if (  ( _tcsicmp( pszClassName, TEXT("Container")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("organizationalUnit")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("organization")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("country")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("locality")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("device")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("DMD")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("mSFTDSA")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("Domain")) == 0 )
       )
    {
        *pfContainer = TRUE;
        RRETURN(S_OK);
    }

    *pfContainer = IsContainer( pszClassName, hSchema );
    RRETURN(S_OK);
}

HRESULT
SchemaGetStringsFromStringTable(
    LDAP_SCHEMA_HANDLE hSchema,
    int *propList,
    DWORD nCount,
    LPWSTR **paStrings
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;
    long i = 0;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    if ( (propList != NULL) && (*propList != -1) )
    {

        *paStrings = (LPWSTR *) AllocADsMem( (nCount+1)*sizeof(LPWSTR));
        if ( *paStrings == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        i = 0;
        while ( propList[i] != -1 )
        {
            (*paStrings)[i] = AllocADsStr(
                     pSchemaInfo->aProperties[pSchemaInfo->aPropertiesSearchTable[propList[i]].nIndex].pszPropertyName  );

            if ( (*paStrings)[i] == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            i++;
        }

        (*paStrings)[i] = NULL;
    }
    else
    {
        *paStrings = NULL;
    }

    return S_OK;

error:

    if ( *paStrings )
    {
        i = 0;
        while ( (*paStrings)[i] )
        {
            FreeADsStr( (*paStrings)[i] );
            i++;
        }
        FreeADsMem( *paStrings );
    }

    RRETURN(hr);

}

BOOL
IsContainer(
    LPTSTR pszClassName,
    LDAP_SCHEMA_HANDLE hSchema
)
{
    int i = 0;
    CLASSINFO *pClassInfo;
    LPTSTR pszName;
    DWORD index;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if (  ( _tcsicmp( pszClassName, TEXT("Container")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("organizationalUnit")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("organization")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("country")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("locality")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("device")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("DMD")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("mSFTDSA")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("Domain")) == 0 )
       )
    {
        return TRUE;
    }

    index = (DWORD) FindEntryInSearchTable(
                        pszClassName,
                        pSchemaInfo->aClassesSearchTable,
                        2 * pSchemaInfo->nNumOfClasses );

    if ( i == ((DWORD) -1) )
        return FALSE;

    pClassInfo = &(pSchemaInfo->aClasses[index]);

    if ( pClassInfo->pOIDsSuperiorClasses )
    {
        for ( i = 0;
              (pszName = pClassInfo->pOIDsSuperiorClasses[i]);
              i++  )
        {
            if ( IsContainer( pszName, hSchema ))
                return TRUE;
        }
    }

    if ( pClassInfo->pOIDsAuxClasses )
    {
        for ( i = 0;
              (pszName = pClassInfo->pOIDsAuxClasses[i]);
              i++  )
        {
            if ( IsContainer( pszName, hSchema ))
                return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\secutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       secutil.cxx
//
//  Contents:   Helper routines for conversion - LDAP specific
//
//  Functions:
//
//  History:    09-27-98 by splitting ldap\var2sec.cxx
//              and distributing between ldapc and router - AjayR
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

//
// Definition need as this is not a part of the headers
//
extern "C" {
HRESULT
ADsEncodeBinaryData (
   PBYTE   pbSrcData,
   DWORD   dwSrcLen,
   LPWSTR  * ppszDestData
   );
}

HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    WCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;
    HRESULT hr = S_OK;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;


    if (!IsValidSid( pSid )) {
        *String= L'\0';
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        RRETURN(hr);
    }

    wsprintf(Buffer, L"S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    wcscpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        wsprintf(Buffer, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        wcscat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        wsprintf(Buffer, L"%lu", Tmp);
        wcscat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        wsprintf(Buffer, L"-%lu", *(GetSidSubAuthority(pSid, i)));
        wcscat(String, Buffer);
    }

    RRETURN(S_OK);

}


HRESULT
ConvertU2TrusteeToSid(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    LPWSTR pszTrustee,
    LPBYTE Sid,
    PDWORD pdwSidSize
    )
{
    PADSLDP pLdapHandle = NULL;
    HRESULT hr = S_OK;
    LPWSTR *SidAttribute = NULL;
    DWORD nCount = 0;
    DWORD dwStatus = 0;
    struct berval **ppBerValue = NULL;
    LPWSTR Attributes[2];
    LDAPMessage *res = NULL;
    LDAPMessage *entry = NULL;
    DWORD dwNumberOfEntries = 0;
    DWORD dwSidLength = 0;
    LPBYTE lpByte = NULL;
    WCHAR szSid[MAX_PATH];

    Attributes[0] = L"Sid";
    Attributes[1] = NULL;

    ConvertSidToString( Sid, szSid);

    dwStatus = LdapOpenObject(
                pszServerName,
                pszTrustee,
                &pLdapHandle,
                Credentials,
                FALSE
                );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = LdapSearchS(
                    pLdapHandle,
                    pszTrustee,
                    LDAP_SCOPE_BASE,
                    L"(objectClass=*)",
                    Attributes,
                    0,
                    &res
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwNumberOfEntries = LdapCountEntries( pLdapHandle, res );

    if ( dwNumberOfEntries == 0 )
        RRETURN(S_OK);

    dwStatus = LdapFirstEntry( pLdapHandle, res, &entry );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = LdapGetValuesLen(
                    pLdapHandle,
                    entry,
                    L"Sid",
                    &ppBerValue,
                    (int *)&nCount
                    );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwSidLength = ((struct berval **)ppBerValue)[0]->bv_len;
    lpByte = (LPBYTE)((struct berval **) ppBerValue)[0]->bv_val;


    memcpy( Sid, lpByte, dwSidLength);
    *pdwSidSize = dwSidLength;

error:

    if (res) {
        LdapMsgFree( res );
    }

    RRETURN(hr);
}


HRESULT
ConvertSidToU2Trustee(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PSID pSid,
    LPWSTR szTrustee
    )
{
    HRESULT hr = S_OK;
    PUCHAR pSidAuthorityCount = NULL;
    LPWSTR pszQueryString = NULL;
    DWORD dwSidLength = 0;
    LDAPMessage *res = NULL;
    LPWSTR pszDN = NULL;
    LDAPMessage *entry = NULL;
    DWORD dwStatus = 0;

    DWORD dwNumberOfEntries  = 0;
    WCHAR szSearchExp[MAX_PATH];

    PADSLDP pLdapHandle = NULL;

    LPWSTR Attributes[] = {L"Sid", NULL};
    WCHAR szSid[MAX_PATH];


    ConvertSidToString( pSid, szSid);

    pSidAuthorityCount = GetSidSubAuthorityCount(pSid);

    if (!pSidAuthorityCount) {
        RRETURN(E_FAIL);
    }

    dwSidLength = GetSidLengthRequired(*pSidAuthorityCount);

    hr = ADsEncodeBinaryData (
            (LPBYTE)pSid,
            dwSidLength,
            &pszQueryString
            );
    BAIL_ON_FAILURE(hr);


    dwStatus = LdapOpenObject(
                pszServerName,
                NULL,
                &pLdapHandle,
                Credentials,
                FALSE
                );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(szSearchExp,L"(Sid=");
    wcscat(szSearchExp, pszQueryString);
    wcscat(szSearchExp, L")");

    dwStatus = LdapSearchS(
                    pLdapHandle,
                    NULL,
                    LDAP_SCOPE_SUBTREE,
                    szSearchExp,
                    Attributes,
                    0,
                    &res
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwNumberOfEntries = LdapCountEntries( pLdapHandle, res );

    if ( dwNumberOfEntries == 0 ){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = LdapFirstEntry( pLdapHandle, res, &entry );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = LdapGetDn( pLdapHandle, entry, &pszDN);
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(szTrustee, pszDN);

error:

    if (pszQueryString) {
        FreeADsStr(pszQueryString);
    }

    if (pszDN) {
        LdapMemFree(pszDN);
    }

    if (res) {
        LdapMsgFree( res );
    }

    if (pLdapHandle) {
        LdapCloseObject( pLdapHandle);
    }

    RRETURN(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\symhelp.c ===
#if !defined(WIN95) && defined(_X86_)
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    symhelp.c

Abstract:



Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

--*/


#define _SYMHELP_SOURCE_

#include "dswarn.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <symhelp.h>
#include <stdio.h>
#include <stdlib.h>

//
// Primitives to access symbolic debug information in an image file
//

typedef struct _RTL_SYMBOL_INFORMATION {
    ULONG Type;
    ULONG SectionNumber;
    ULONG Value;
    STRING Name;
} RTL_SYMBOL_INFORMATION, *PRTL_SYMBOL_INFORMATION;

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    );

typedef struct _PROCESS_DEBUG_INFORMATION {
    LIST_ENTRY List;
    HANDLE UniqueProcess;
    DWORD ImageBase;
    DWORD EndOfImage;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    UCHAR ImageFilePath[ MAX_PATH ];
} PROCESS_DEBUG_INFORMATION, *PPROCESS_DEBUG_INFORMATION;


PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilterRoutine;

RTL_CRITICAL_SECTION LoadedImageDebugInfoListCritSect;
LIST_ENTRY LoadedImageDebugInfoListHead;
LIST_ENTRY LoadedProcessDebugInfoListHead;

LPSTR SymbolSearchPath;

// This variable tracks how many times InitializeImageDebugInformation has been
//  called. Certain operations are performed only on the first call (as
//  NumInitCalls transitions from -1 to 0).
LONG NumInitCalls = -1;

LPSTR
GetEnvVariable(
    IN LPSTR VariableName
    )
{
    NTSTATUS Status;
    STRING Name, Value;
    UNICODE_STRING UnicodeName, UnicodeValue;

    RtlInitString( &Name, VariableName );
    RtlInitUnicodeString( &UnicodeValue, NULL );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (Status != STATUS_BUFFER_TOO_SMALL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    UnicodeValue.MaximumLength = UnicodeValue.Length + sizeof( UNICODE_NULL );
    UnicodeValue.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, UnicodeValue.MaximumLength );
    if (UnicodeValue.Buffer == NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlUnicodeStringToAnsiString( &Value, &UnicodeValue, TRUE );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Value.Buffer[ Value.Length ] = '\0';
    return Value.Buffer;
}

LPSTR
SetSymbolSearchPath( )
{
    ULONG Size, i, Attributes, NumberOfSymbolPaths;
    LPSTR s, SymbolPaths[ 4 ];

    if (SymbolSearchPath != NULL) {
        return SymbolSearchPath;
        }

    Size = 0;
    NumberOfSymbolPaths = 0;
    if (s = GetEnvVariable( "_NT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "_NT_ALT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "SystemRoot" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    SymbolPaths[ NumberOfSymbolPaths++ ] = ".";

    Size = 1;
    for (i=0; i<NumberOfSymbolPaths; i++) {
        Attributes = GetFileAttributesA( SymbolPaths[ i ] );
        if ( Attributes != 0xffffffff && (Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
            Size += 1 + strlen( SymbolPaths[ i ] );
            }
        else {
            SymbolPaths[ i ] = NULL;
            }
        }

    SymbolSearchPath = RtlAllocateHeap( RtlProcessHeap(), 0, Size );
    if (SymbolSearchPath == NULL) {
        return NULL;
        }
    *SymbolSearchPath = '\0';
    for (i=0; i<NumberOfSymbolPaths; i++) {
        if (s = SymbolPaths[ i ]) {
            if (*SymbolSearchPath != '\0') {
                strcat( SymbolSearchPath, ";" );
                }
            strcat( SymbolSearchPath, s );
            }
        }

    return SymbolSearchPath;
}

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    )
{
    PPEB Peb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    PLIST_ENTRY LdrHead, LdrNext;
    PPEB_LDR_DATA Ldr;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPSTR ImageFilePath;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    RTL_PROCESS_MODULES ModuleInfoBuffer;
    PRTL_PROCESS_MODULES ModuleInfo;
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo1;
    SIZE_T RequiredLength;
    ULONG ModuleNumber;

    // Is this the first call?
    if ( InterlockedIncrement ( &NumInitCalls ) == 0 )
    {
        // Yes
        SetSymbolSearchPath();
        InitializeListHead( &LoadedImageDebugInfoListHead );
        InitializeListHead( &LoadedProcessDebugInfoListHead );
        RtlInitializeCriticalSection( &LoadedImageDebugInfoListCritSect );
    }

    // The filter routine can be superceded at any time.
    LoadSymbolsFilterRoutine = LoadSymbolsFilter;

    if (GetKernelSymbols) {
        ModuleInfo = &ModuleInfoBuffer;
        RequiredLength = sizeof( *ModuleInfo );
        Status = NtQuerySystemInformation( SystemModuleInformation,
                                           ModuleInfo,
                                           (ULONG)RequiredLength,
                                           (PULONG)&RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            ModuleInfo = NULL;
            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &ModuleInfo,
                                              0,
                                              &RequiredLength,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );
            if (NT_SUCCESS( Status )) {
                Status = NtQuerySystemInformation( SystemModuleInformation,
                                                   ModuleInfo,
                                                   (ULONG)RequiredLength,
                                                   (PULONG)&RequiredLength
                                                 );
                if (NT_SUCCESS( Status )) {
                    ModuleInfo1 = &ModuleInfo->Modules[ 0 ];
                    for (ModuleNumber=0; ModuleNumber<ModuleInfo->NumberOfModules; ModuleNumber++) {
                        if ((DWORD)(ModuleInfo1->ImageBase) & 0x80000000) {
                            if (ImageFilePath = strchr( ModuleInfo1->FullPathName, ':')) {
                                ImageFilePath -= 1;
                                }
                            else {
                                ImageFilePath = ModuleInfo1->FullPathName +
                                                strlen( ModuleInfo1->FullPathName );
                                while (ImageFilePath > ModuleInfo1->FullPathName) {
                                    if (ImageFilePath[ -1 ] == '\\') {
                                        break;
                                        }
                                    else {
                                        ImageFilePath -= 1;
                                        }
                                    }
                                }

                            AddImageDebugInformation( NULL,
                                                      ImageFilePath,
                                                      (DWORD)ModuleInfo1->ImageBase,
                                                      ModuleInfo1->ImageSize
                                                    );
                            }

                        ModuleInfo1++;
                        }
                    }

                NtFreeVirtualMemory( NtCurrentProcess(),
                                     &ModuleInfo,
                                     &RequiredLength,
                                     MEM_RELEASE
                                   );
                }
            }
        }

    if (TargetProcess == NULL) {

        // Load module information for this process.

        TargetProcess = GetCurrentProcess();
        }

    Status = NtQueryInformationProcess( TargetProcess,
                                        ProcessBasicInformation,
                                        &ProcessInformation,
                                        sizeof( ProcessInformation ),
                                        NULL
                                      );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Peb = ProcessInformation.PebBaseAddress;

    if (NewProcess) {
        return TRUE;
        }

    //
    // Ldr = Peb->Ldr
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &Peb->Ldr,
                                  &Ldr,
                                  sizeof( Ldr ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &LdrHead->Flink,
                                  &LdrNext,
                                  sizeof( LdrNext ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    while (LdrNext != LdrHead) {
        LdrEntry = CONTAINING_RECORD( LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntry,
                                      &LdrEntryData,
                                      sizeof( LdrEntryData ),
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }

        UnicodeString.Length = LdrEntryData.FullDllName.Length;
        UnicodeString.MaximumLength = LdrEntryData.FullDllName.MaximumLength;
        UnicodeString.Buffer = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                UnicodeString.MaximumLength
                                              );
        if (!UnicodeString.Buffer) {
            return FALSE;
            }
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntryData.FullDllName.Buffer,
                                      UnicodeString.Buffer,
                                      UnicodeString.MaximumLength,
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
            return FALSE;
            }

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &UnicodeString,
                                      TRUE
                                    );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
        if (ImageFilePath = strchr( AnsiString.Buffer, ':')) {
            ImageFilePath -= 1;
            }
        else {
            ImageFilePath = AnsiString.Buffer;
            }

        AddImageDebugInformation( (HANDLE)ProcessInformation.UniqueProcessId,
                                  ImageFilePath,
                                  (DWORD)LdrEntryData.DllBase,
                                  LdrEntryData.SizeOfImage
                                );

        RtlFreeAnsiString( &AnsiString );

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }

    return TRUE;
}


BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo = NULL;
    PPROCESS_DEBUG_INFORMATION ProcessInfo = NULL;
    HANDLE FileHandle;
    UCHAR PathBuffer[ MAX_PATH ];

    FileHandle = FindExecutableImage( ImageFilePath, SymbolSearchPath, PathBuffer );
    if (FileHandle == NULL) {
        if (LoadSymbolsFilterRoutine != NULL) {
            (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                         ImageFilePath,
                                         ImageBase,
                                         ImageSize,
                                         LoadSymbolsPathNotFound
                                       );
            }

        return FALSE;
        }
    CloseHandle( FileHandle );
    if (LoadSymbolsFilterRoutine != NULL) {
        (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                     PathBuffer,
                                     ImageBase,
                                     ImageSize,
                                     LoadSymbolsDeferredLoad
                                   );
        }

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Head = &LoadedImageDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        DebugInfo = CONTAINING_RECORD( Next, IMAGE_DEBUG_INFORMATION, List );
        if (DebugInfo->ImageBase == ImageBase &&
            !_stricmp( PathBuffer, DebugInfo->ImageFilePath )
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        DebugInfo = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            !_stricmp( PathBuffer, ProcessInfo->ImageFilePath )
           ) {
            return TRUE;
            }

        Next = Next->Flink;
        }

    ProcessInfo = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( *ProcessInfo ) );
    if (ProcessInfo == NULL) {
        return FALSE;
        }
    ProcessInfo->ImageBase = ImageBase;
    ProcessInfo->EndOfImage = ImageBase + ImageSize;
    ProcessInfo->UniqueProcess = UniqueProcess;
    ProcessInfo->DebugInfo = DebugInfo;
    strcpy( ProcessInfo->ImageFilePath, PathBuffer );
    InsertTailList( &LoadedProcessDebugInfoListHead, &ProcessInfo->List );

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return TRUE;
}


BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    )
{
    PLIST_ENTRY Head, Next;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            (!ARGUMENT_PRESENT( ImageFilePath ) ||
             !_stricmp( ImageFilePath, ProcessInfo->ImageFilePath )
            )
           ) {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnload
                                           );
                }

            Next = Next->Blink;
            RemoveEntryList( &ProcessInfo->List );
            RtlFreeHeap( RtlProcessHeap(), 0, ProcessInfo );
            if (ARGUMENT_PRESENT( ImageFilePath )) {
                break;
                }
            }

        Next = Next->Flink;
        }

    return TRUE;
}

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    if (Address & 0x80000000) {
        UniqueProcess = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            Address >= ProcessInfo->ImageBase &&
            Address < ProcessInfo->EndOfImage
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
        return NULL;
        }

    DebugInfo = ProcessInfo->DebugInfo;
    if (DebugInfo == NULL) {
        DebugInfo = MapDebugInformation( NULL, ProcessInfo->ImageFilePath, SymbolSearchPath, ProcessInfo->ImageBase );
        if (DebugInfo != NULL) {
            DebugInfo->ImageBase = ProcessInfo->ImageBase;
            ProcessInfo->DebugInfo = DebugInfo;
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsLoad
                                           );
                }

            InsertTailList( &LoadedImageDebugInfoListHead, &DebugInfo->List );
            }
        else {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnableToLoad
                                           );
                }
            }
        }

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return DebugInfo;
}


ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    )
{
    NTSTATUS Status;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    RTL_SYMBOL_INFORMATION SymbolInformation;
    ULONG i, ModuleNameLength, Result, Offset;
    LPSTR s;

    DebugInfo = FindImageDebugInformation( UniqueProcess,
                                           Address
                                         );
    if (DebugInfo != NULL) {
        if (s = strchr( DebugInfo->ImageFileName, '.' )) {
            ModuleNameLength = (ULONG)(s - DebugInfo->ImageFileName);
            }
        else {
            ModuleNameLength = strlen( DebugInfo->ImageFileName );
            }

        //  [mikese] RtlLookupSymbolByAddress will fault if there is
        //  no COFF symbol information.
        if ( DebugInfo->CoffSymbols != NULL ) {
            Status = RtlLookupSymbolByAddress( (PVOID)DebugInfo->ImageBase,
                                       DebugInfo->CoffSymbols,
                                       (PVOID)Address,
                                       0x4000,
                                       &SymbolInformation,
                                       NULL
                                     );

            }
        else {
            Status = STATUS_UNSUCCESSFUL;
             }
        }
    else {
        ModuleNameLength = 0;
        Status = STATUS_UNSUCCESSFUL;
        }

    if (NT_SUCCESS( Status )) {
        s = SymbolInformation.Name.Buffer;
        i = 1;
        while (SymbolInformation.Name.Length > i &&
               isdigit( s[ SymbolInformation.Name.Length - i ] )
              ) {
            i += 1;
            }

        if (s[ SymbolInformation.Name.Length - i ] == '@') {
            SymbolInformation.Name.Length = (USHORT)(SymbolInformation.Name.Length - i);
            }

        s = Name;
        Result = _snprintf( s, MaxNameLength,
                            "%.*s!%Z",
                            ModuleNameLength,
                            DebugInfo->ImageFileName,
                            &SymbolInformation.Name
                          );
        Offset = (ULONG)(Address - DebugInfo->ImageBase) - SymbolInformation.Value;
        if (Offset != 0) {
            Result += _snprintf( s + Result, MaxNameLength - Result, "+0x%x", Offset );
            }
        }
    else {
        if (ModuleNameLength != 0) {
            Result = _snprintf( Name, MaxNameLength,
                                "%.*s!0x%08x",
                                ModuleNameLength,
                                DebugInfo->ImageFileName,
                                Address
                              );
            }
        else {
            Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }

    return Result;
}

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength )
{
    PRTL_DEBUG_INFORMATION p;
    NTSTATUS Status;
    DWORD ProcessId;
    ULONG Result = 0;
    ULONG Attempts = 0;

    // We need to call Initialize once to ensure that GetSymbolicNameForAddress
    //  does not fault.
    if ( NumInitCalls == -1 )
    {
        InitializeImageDebugInformation( LoadSymbolsFilterRoutine,
                                         NULL, FALSE, FALSE );
    }

    ProcessId = GetCurrentProcessId();

    while ( Result == 0 )
    {
        Result = GetSymbolicNameForAddress ( (HANDLE)ProcessId, Address,
                                             Name, MaxNameLength );
        if ( Result == 0 )
        {
            if ( ++Attempts < 2 )
            {
                // Try reintialising, to load any modules we missed on a previous
                //  occasion (or if we haven't initialised yet).
                // I don't need a load-symbols-filter, so just use whatever is
                //  already there, if any
                InitializeImageDebugInformation( LoadSymbolsFilterRoutine,
                                                 NULL, FALSE, FALSE );
            }
            else
            {
                // Apparently we are unable to do the right thing, so just return
                //  the address as hex.
                Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }
    }

    return Result;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    );

PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    );

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    )
/*++

Routine Description:

    Given a code address, this routine returns the nearest symbol
    name and the offset from the symbol to that name.  If the
    nearest symbol is not within ClosenessLimit of the location,
    STATUS_ENTRYPOINT_NOT_FOUND is returned.

Arguments:

    ImageBase - Supplies the base address of the image containing
                Address

    MappedBase - Optional parameter, that if specified means the image
                 was mapped as a data file and the MappedBase gives the
                 location it was mapped.  If this parameter does not
                 point to an image file base, then it is assumed that
                 this is a pointer to the coff debug info.

    ClosenessLimit - Specifies the maximum distance that Address can be
                     from the value of a symbol to be considered
                     "found".  Symbol's whose value is further away then
                     this are not "found".

    SymbolInformation - Points to a structure that is filled in by
                        this routine if a symbol table entry is found.

    NextSymbolInformation - Optional parameter, that if specified, is
                            filled in with information about these
                            symbol whose value is the next address above
                            Address


Return Value:

    Status of operation.

--*/

{
    NTSTATUS Status;
    ULONG AddressOffset, i;
    PIMAGE_SYMBOL PreviousSymbolEntry = NULL;
    PIMAGE_SYMBOL SymbolEntry;
    IMAGE_SYMBOL Symbol;
    PUCHAR StringTable;
    BOOLEAN SymbolFound;
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;

    DebugInfo = RtlpGetCoffDebugInfo( ImageBase, MappedBase );
    if (DebugInfo == NULL) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // Crack the symbol table.
    //

    SymbolEntry = (PIMAGE_SYMBOL)
        ((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);

    StringTable = (PUCHAR)
        ((ULONG)SymbolEntry + DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);


    //
    // Find the "header" symbol (skipping all the section names)
    //

    for (i = 0; i < DebugInfo->NumberOfSymbols; i++) {
        if (!strcmp( &SymbolEntry->N.ShortName[ 0 ], "header" )) {
            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                        IMAGE_SIZEOF_SYMBOL);
        }

    //
    // If no "header" symbol found, just start at the first symbol.
    //

    if (i >= DebugInfo->NumberOfSymbols) {
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
        i = 0;
        }

    //
    // Loop through all symbols in the symbol table.  For each symbol,
    // if it is within the code section, subtract off the bias and
    // see if there are any hits within the profile buffer for
    // that symbol.
    //

    AddressOffset = (ULONG)Address - (ULONG)ImageBase;
    SymbolFound = FALSE;
    for (; i < DebugInfo->NumberOfSymbols; i++) {

        //
        // Skip over any Auxilliary entries.
        //
        try {
            while (SymbolEntry->NumberOfAuxSymbols) {
                i = i + 1 + SymbolEntry->NumberOfAuxSymbols;
                SymbolEntry = (PIMAGE_SYMBOL)
                    ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL +
                     SymbolEntry->NumberOfAuxSymbols * IMAGE_SIZEOF_SYMBOL
                    );

                }

            RtlMoveMemory( &Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL );
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
            }

        //
        // If this symbol value is less than the value we are looking for.
        //

        if (Symbol.Value <= AddressOffset) {
            //
            // Then remember this symbol entry.
            //

            PreviousSymbolEntry = SymbolEntry;
            SymbolFound = TRUE;
            }
        else {
            //
            // All done looking if value of symbol is greater than
            // what we are looking for, as symbols are in address order
            //

            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)
            ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL);

        }

    if (!SymbolFound || (AddressOffset - PreviousSymbolEntry->Value) > ClosenessLimit) {
        return STATUS_ENTRYPOINT_NOT_FOUND;
        }

    Status = RtlpCaptureSymbolInformation( PreviousSymbolEntry, StringTable, SymbolInformation );
    if (NT_SUCCESS( Status ) && ARGUMENT_PRESENT( NextSymbolInformation )) {
        Status = RtlpCaptureSymbolInformation( SymbolEntry, StringTable, NextSymbolInformation );
        }

    return Status;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    )
{
    USHORT MaximumLength;
    PCHAR s;

    SymbolInformation->SectionNumber = SymbolEntry->SectionNumber;
    SymbolInformation->Type = SymbolEntry->Type;
    SymbolInformation->Value = SymbolEntry->Value;

    if (SymbolEntry->N.Name.Short) {
        MaximumLength = 8;
        s = &SymbolEntry->N.ShortName[ 0 ];
        }

    else {
        MaximumLength = 64;
        s = &StringTable[ SymbolEntry->N.Name.Long ];
        }

#if i386
    if (*s == '_') {
        s++;
        MaximumLength--;
        }
#endif

    SymbolInformation->Name.Buffer = s;
    SymbolInformation->Name.Length = 0;
    while (*s && MaximumLength--) {
        SymbolInformation->Name.Length++;
        s++;
        }

    SymbolInformation->Name.MaximumLength = SymbolInformation->Name.Length;
    return( STATUS_SUCCESS );
}


PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    )
{
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    ULONG DebugSize;
    ULONG NumberOfDebugDirectories;

    DosHeader = (PIMAGE_DOS_HEADER)MappedBase;
    if ( !DosHeader || DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {
        //
        // Locate debug section.
        //

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)(MappedBase == NULL ? ImageBase : MappedBase),
                                          (BOOLEAN)(MappedBase == NULL ? TRUE : FALSE),
                                          IMAGE_DIRECTORY_ENTRY_DEBUG,
                                          &DebugSize
                                        );

        if (!DebugDirectory ||
            (DebugSize < sizeof(IMAGE_DEBUG_DIRECTORY)) ||
            ((DebugSize % sizeof(IMAGE_DEBUG_DIRECTORY)) != 0)) {
            return NULL;
        }
        //
        // point debug directory at coff debug directory
        //
        NumberOfDebugDirectories = DebugSize / sizeof(*DebugDirectory);

        while ( NumberOfDebugDirectories-- ) {
            if ( DebugDirectory->Type == IMAGE_DEBUG_TYPE_COFF ) {
                break;
            }
            DebugDirectory++;
        }

        if (DebugDirectory->Type != IMAGE_DEBUG_TYPE_COFF ) {
            return NULL;
        }

        if (MappedBase == NULL) {
            if (DebugDirectory->AddressOfRawData == 0) {
                return(NULL);
            }
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) ImageBase + DebugDirectory->AddressOfRawData);
        } else {
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) MappedBase + DebugDirectory->PointerToRawData);
        }
    } else {
        DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)MappedBase;
    }
    return DebugInfo;
}
#else
//4602 nonstandard extension used : translation unit is empty
#pragma warning (disable:4206)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldapc\srchutil.cxx ===
//---------------------------------------------------------------------------;
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssrch.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

const int MAX_BYTES = 1048576;
const int NO_LDAP_RESULT_HANDLES = 32;

static BOOL
IsValidPrefValue(
    ADS_SEARCHPREF_INFO SearchPref
    );

static
HRESULT
LdapValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    VOID        **lpValue,
    ADS_SEARCH_COLUMN * pColumn
    );

HRESULT
UnicodeToUTF8String(
    LPCWSTR pUnicode,
    LPSTR *ppUTF8
    );

HRESULT
UTF8ToUnicodeString(
    LPCSTR   pUTF8,
    LPWSTR *ppUnicode
    );

//
// Sets the appropriate search preferences.
//


HRESULT
ADsSetSearchPreference(
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs,
    OUT LDAP_SEARCH_PREF * pLdapPref,
    IN LPWSTR pszLDAPServer,
    IN LPWSTR pszLDAPDn,
    IN CCredentials& Credentials,
    IN DWORD dwPort
    )
{

    HRESULT hr = S_OK;
    BOOL fWarning = FALSE;
    DWORD i, j;
    BOOL fPagedSearch = FALSE, fSorting = TRUE, fVLV = FALSE, fAttribScoped = FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;

    PADS_SORTKEY pSortKeyArray = NULL;
    DWORD dwSortKeyArrayLen = 0, nKeys = 0;

    BOOL fSetCaching = FALSE; // TRUE if user explicitly set a caching preference
    BOOL fSetScope   = FALSE; // TRUE if user explicitly set a scope preference

    PADS_VLV pVLV  = NULL;
    DWORD dwVLVLen = 0;
    LPSTR pUTF8Target = NULL;
    DWORD dwUTF8TargetLen = 0;

    LPWSTR pAttribScoped  = NULL;

    DWORD dwSecurityMask;
    DWORD dwDirsyncFlag;
    DWORD dwExtendedDNOption;

    int iDirsyncFlagIndex = -1;
    

    if (!pSearchPrefs && dwNumPrefs > 0 || !pLdapPref) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    for (i=0; i<dwNumPrefs; i++) {

        pSearchPrefs[i].dwStatus = ADS_STATUS_S_OK;

        if (!IsValidPrefValue(pSearchPrefs[i]) ) {
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
            fWarning = TRUE;
            continue;
        }

        switch(pSearchPrefs[i].dwSearchPref) {
        case ADS_SEARCHPREF_ASYNCHRONOUS:
            pLdapPref->_fAsynchronous = pSearchPrefs[i].vValue.Boolean;
            break;
        case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
            pLdapPref->_fAttrsOnly = pSearchPrefs[i].vValue.Boolean;
            break;
        case ADS_SEARCHPREF_SIZE_LIMIT:
            pLdapPref->_dwSizeLimit = pSearchPrefs[i].vValue.Integer;
            break;
        case ADS_SEARCHPREF_TIME_LIMIT:
            pLdapPref->_dwTimeLimit = pSearchPrefs[i].vValue.Integer;
            break;
        case ADS_SEARCHPREF_TIMEOUT:
            pLdapPref->_timeout.tv_sec = pSearchPrefs[i].vValue.Integer;
            break;
        case ADS_SEARCHPREF_PAGESIZE:

            if (pLdapPref->_fDirSync) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            ReadPagingSupportedAttr(
                         pszLDAPServer,
                         &fPagedSearch,
                         Credentials,
                         dwPort
                         ) ;

            if (fPagedSearch) {
                pLdapPref->_dwPageSize = pSearchPrefs[i].vValue.Integer;
            }
            else {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
            }
            break;
        case ADS_SEARCHPREF_PAGED_TIME_LIMIT:

            ReadPagingSupportedAttr(
                         pszLDAPServer,
                         &fPagedSearch,
                         Credentials,
                         dwPort
                         ) ;

            if (fPagedSearch) {
                pLdapPref->_dwPagedTimeLimit = pSearchPrefs[i].vValue.Integer;
            }
            else {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
            }
            break;
        case ADS_SEARCHPREF_DEREF_ALIASES:
            pLdapPref->_dwDerefAliases = pSearchPrefs[i].vValue.Integer;
            break;
        case ADS_SEARCHPREF_SEARCH_SCOPE:

            // if doing a attribute-scoped query and user tries to set scope
            // to anything other than ADS_SCOPE_BASE, reject
            if (pLdapPref->_pAttribScoped && (pSearchPrefs[i].vValue.Integer != ADS_SCOPE_BASE)) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }
        
            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_SCOPE_SUBTREE:
                pLdapPref->_dwSearchScope = LDAP_SCOPE_SUBTREE;
                break;
            case ADS_SCOPE_ONELEVEL:
                pLdapPref->_dwSearchScope = LDAP_SCOPE_ONELEVEL;
                break;
            case ADS_SCOPE_BASE:
                pLdapPref->_dwSearchScope = LDAP_SCOPE_BASE;
                break;
            }

            fSetScope = TRUE;   // set so if user later tries to do
                                // attrib-scoped query, and user set scope
                                // to other than ADS_SCOPE_BASE, can detect & reject
            
            break;
        case ADS_SEARCHPREF_CHASE_REFERRALS:
            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_CHASE_REFERRALS_NEVER:
                pLdapPref->_dwChaseReferrals = (DWORD) (DWORD_PTR)LDAP_OPT_OFF;
                break;
            case ADS_CHASE_REFERRALS_SUBORDINATE:
                pLdapPref->_dwChaseReferrals = LDAP_CHASE_SUBORDINATE_REFERRALS;
                break;
            case ADS_CHASE_REFERRALS_EXTERNAL:
                pLdapPref->_dwChaseReferrals = LDAP_CHASE_EXTERNAL_REFERRALS;
                break;
            case ADS_CHASE_REFERRALS_ALWAYS:
                pLdapPref->_dwChaseReferrals = (DWORD) (DWORD_PTR) LDAP_OPT_ON;
                break;
            }
            break;
        case ADS_SEARCHPREF_SORT_ON:

            ReadSortingSupportedAttr(
                         pszLDAPServer,
                         &fSorting,
                         Credentials,
                         dwPort
                         ) ;

            if (!fSorting) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
                continue;
            }
            //
            // The value is actually a pointer to the LDAP Sort Key whose
            // structure is as defined in the sort control RFC extension.
            //

            pSortKeyArray = (PADS_SORTKEY) pSearchPrefs[i].vValue.ProviderSpecific.lpValue;
            dwSortKeyArrayLen = pSearchPrefs[i].vValue.ProviderSpecific.dwLength;

            if (!pSortKeyArray || !dwSortKeyArrayLen ) {
                continue;
            }

            if (dwSortKeyArrayLen % sizeof(ADS_SORTKEY) != 0 ) {
                //
                // The data given does not seem to contain a proper SortKey
                // structure
                //
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            nKeys = dwSortKeyArrayLen / sizeof(ADS_SORTKEY);

            if (pLdapPref->_pSortKeys) {
                //
                // Free the previous one
                //
                FreeSortKeys(pLdapPref->_pSortKeys, pLdapPref->_nSortKeys);

            }

            pLdapPref->_pSortKeys = (PLDAPSortKey) AllocADsMem(
                                                sizeof(LDAPSortKey) * nKeys);
            if (!pLdapPref->_pSortKeys) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            for (j=0; j<nKeys; j++) {

                pLdapPref->_pSortKeys[j].sk_attrtype =
                                    AllocADsStr(pSortKeyArray[j].pszAttrType);
                if(!pLdapPref->_pSortKeys[j].sk_attrtype && pSortKeyArray[j].pszAttrType)
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                pLdapPref->_pSortKeys[j].sk_matchruleoid =
                                    pSortKeyArray[j].pszReserved;
                pLdapPref->_pSortKeys[j].sk_reverseorder =
                                    pSortKeyArray[j].fReverseorder;
            }

            pLdapPref->_nSortKeys = nKeys;

            break;
        case ADS_SEARCHPREF_CACHE_RESULTS:
            // if doing a VLV search and user tries to turn on caching, reject
            if (pLdapPref->_pVLVInfo && pSearchPrefs[i].vValue.Boolean) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }
        
            pLdapPref->_fCacheResults = pSearchPrefs[i].vValue.Boolean;
            fSetCaching = TRUE; // set so if we later determine user wants to
                                // do a VLV search, we can reject if user tried
                                // to explicitly turn on caching
            break;

        //
        // Like paged, setting this preference will mean that we use it
        // by default, it is not used.
        //
        case ADS_SEARCHPREF_DIRSYNC:

            if (pLdapPref->_dwPageSize) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            pLdapPref->_fDirSync = TRUE;

            //
            // Check if previous value is set and free if necessary.
            //
            if (pLdapPref->_pProvSpecific) {
                if (pLdapPref->_pProvSpecific->lpValue) {
                    FreeADsMem(pLdapPref->_pProvSpecific->lpValue);
                    pLdapPref->_pProvSpecific->lpValue = NULL;
                }
                FreeADsMem(pLdapPref->_pProvSpecific);
                pLdapPref->_pProvSpecific = NULL;
            }

            //
            // Copy over the info here.
            //
            pLdapPref->_pProvSpecific =
                (PADS_PROV_SPECIFIC) AllocADsMem(sizeof(ADS_PROV_SPECIFIC));

            if (!pLdapPref->_pProvSpecific) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            pLdapPref->_pProvSpecific->dwLength =
                pSearchPrefs[i].vValue.ProviderSpecific.dwLength;

            //
            // If the octet string is anything other than NULL,
            // we need to copy it over. If it is NULL, then this is
            // the first time the control is being used.
            //
            if (pLdapPref->_pProvSpecific->dwLength > 0) {

                pLdapPref->_pProvSpecific->lpValue =
                    (PBYTE)AllocADsMem(pLdapPref->_pProvSpecific->dwLength);

                if (!pLdapPref->_pProvSpecific->lpValue) {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }

                memcpy(
                    pLdapPref->_pProvSpecific->lpValue,
                    pSearchPrefs[i].vValue.ProviderSpecific.lpValue,
                    pLdapPref->_pProvSpecific->dwLength
                    );
            }
            break;

        case ADS_SEARCHPREF_TOMBSTONE :
            pLdapPref->_fTombStone = pSearchPrefs[i].vValue.Boolean;
            break;

        case ADS_SEARCHPREF_VLV:

            // If user tried to explicitly turn on caching, reject
            // Later on, we'll turn off caching
            if ( fSetCaching && pLdapPref->_fCacheResults) {
                 BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            // test for server support of VLV
            ReadVLVSupportedAttr(
                         pszLDAPServer,
                         &fVLV,
                         Credentials,
                         dwPort
                         ) ;

            if (!fVLV) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
                continue;
            }


            // basic sanity checks of user-supplied data
            pVLV = (PADS_VLV) pSearchPrefs[i].vValue.ProviderSpecific.lpValue;
            dwVLVLen = pSearchPrefs[i].vValue.ProviderSpecific.dwLength;

            if (!pVLV || !dwVLVLen ) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            if (dwVLVLen != sizeof(ADS_VLV)) {
                //
                // The data given does not seem to contain a proper VLV
                // structure
                //
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            // free the previous LDAPVLVInfo, if one exists (generally, it shouldn't)
            if (pLdapPref->_pVLVInfo)
                FreeLDAPVLVInfo(pLdapPref->_pVLVInfo);

            // Copy the user's VLV search preferences into a LDAPVLVInfo
            // Note that we copy the dwOffset and dwContentCount even if the user
            // wants to do a greaterThanOrEqual-type VLV search.  This is because
            // we'll ignore those members if ldvlv_attrvalue != NULL.
            pLdapPref->_pVLVInfo = (PLDAPVLVInfo) AllocADsMem(sizeof(LDAPVLVInfo));
            if (!pLdapPref->_pVLVInfo)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pLdapPref->_pVLVInfo->ldvlv_version      = LDAP_VLVINFO_VERSION;    // 1
            pLdapPref->_pVLVInfo->ldvlv_before_count = pVLV->dwBeforeCount;
            pLdapPref->_pVLVInfo->ldvlv_after_count  = pVLV->dwAfterCount;
            pLdapPref->_pVLVInfo->ldvlv_offset       = pVLV->dwOffset;
            pLdapPref->_pVLVInfo->ldvlv_count        = pVLV->dwContentCount;
            pLdapPref->_pVLVInfo->ldvlv_attrvalue    = NULL;
            pLdapPref->_pVLVInfo->ldvlv_context      = NULL;
            pLdapPref->_pVLVInfo->ldvlv_extradata    = NULL;

            // copy the greaterThanOrEqual attribute, if provided by the user
            if (pVLV->pszTarget) {

                pLdapPref->_pVLVInfo->ldvlv_attrvalue = (PBERVAL) AllocADsMem(sizeof(BERVAL));
                if (!pLdapPref->_pVLVInfo->ldvlv_attrvalue)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                // convert Unicode to UDF-8
                // important: do NOT include the NULL terminator in the LDAPVLVInfo.ldvlv_attrvalue
                
                hr = UnicodeToUTF8String(pVLV->pszTarget, &pUTF8Target);
                BAIL_ON_FAILURE(hr);

                // we want the number of bytes, not the number of MBCS characters
                dwUTF8TargetLen = strlen(pUTF8Target);

                pLdapPref->_pVLVInfo->ldvlv_attrvalue->bv_len = dwUTF8TargetLen;
                pLdapPref->_pVLVInfo->ldvlv_attrvalue->bv_val = (PCHAR) AllocADsMem(dwUTF8TargetLen);
                if (!pLdapPref->_pVLVInfo->ldvlv_attrvalue->bv_val)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                memcpy(pLdapPref->_pVLVInfo->ldvlv_attrvalue->bv_val,
                       pUTF8Target,
                       dwUTF8TargetLen);
            }

            // copy the context ID, if provided by the user
            if (pVLV->lpContextID && pVLV->dwContextIDLength) {

                pLdapPref->_pVLVInfo->ldvlv_context = (PBERVAL) AllocADsMem(sizeof(BERVAL));
                if (pLdapPref->_pVLVInfo->ldvlv_context == NULL)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                
                pLdapPref->_pVLVInfo->ldvlv_context->bv_val = (PCHAR) AllocADsMem(pVLV->dwContextIDLength);
                if (pLdapPref->_pVLVInfo->ldvlv_context->bv_val == NULL)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                pLdapPref->_pVLVInfo->ldvlv_context->bv_len = pVLV->dwContextIDLength;
                memcpy(pLdapPref->_pVLVInfo->ldvlv_context->bv_val,
                       pVLV->lpContextID,
                       pVLV->dwContextIDLength);
            }

            // disable caching, since it's not supported in conjunction with VLV
            pLdapPref->_fCacheResults = FALSE;
            break;

        case ADS_SEARCHPREF_ATTRIBUTE_QUERY:

            // If user tried to explicitly set scope to other than "base", reject
            // Later on, we'll set it to base.
            if ( fSetScope && pLdapPref->_dwSearchScope != LDAP_SCOPE_BASE) {
                 BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            // test for server support of attribute-scoped query
            ReadAttribScopedSupportedAttr(
                         pszLDAPServer,
                         &fAttribScoped,
                         Credentials,
                         dwPort
                         ) ;

            if (!fAttribScoped) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
                continue;
            }
            
            // basic sanity checks of user-supplied data
            pAttribScoped = pSearchPrefs[i].vValue.CaseIgnoreString;

            if (!pAttribScoped) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            // free the previous ADS_ATTRIBUTE_QUERY, if one exists (generally, it shouldn't)
            if (pLdapPref->_pAttribScoped) {
                FreeADsStr(pLdapPref->_pAttribScoped);
                pLdapPref->_pAttribScoped = NULL;
            }

            // copy the ADS_ATTRIBUTE_QUERY
            pLdapPref->_pAttribScoped = AllocADsStr(pAttribScoped);
            if (!(pLdapPref->_pAttribScoped)) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            // set search scope to base (only scope supported by attrib-scoped query)
            pLdapPref->_dwSearchScope = LDAP_SCOPE_BASE;
            break;

        case ADS_SEARCHPREF_SECURITY_MASK:

            //
            // test for server support of security descriptor control
            //
            ReadSecurityDescriptorControlType(
                         pszLDAPServer,
                         &dwSecDescType,
                         Credentials,
                         dwPort
                         );

            if (dwSecDescType != ADSI_LDAPC_SECDESC_NT) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
                continue;
            }

            //
            // sanity check of user supplied data
            //
            dwSecurityMask = pSearchPrefs[i].vValue.Integer;

            if (dwSecurityMask > (OWNER_SECURITY_INFORMATION |
                                  GROUP_SECURITY_INFORMATION |
                                  SACL_SECURITY_INFORMATION  |
                                  DACL_SECURITY_INFORMATION)) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;                                  
            }

            //
            // enable the option
            //
            pLdapPref->_fSecurityDescriptorControl = TRUE;
            pLdapPref->_SecurityDescriptorMask = static_cast<SECURITY_INFORMATION>(dwSecurityMask);
            
            break;

        case ADS_SEARCHPREF_DIRSYNC_FLAG:
            // sanity check of user supplied data
            //
            dwDirsyncFlag = pSearchPrefs[i].vValue.Integer; 

            if(dwDirsyncFlag & (~(LDAP_DIRSYNC_OBJECT_SECURITY |
                                  LDAP_DIRSYNC_ANCESTORS_FIRST_ORDER |
                                  LDAP_DIRSYNC_PUBLIC_DATA_ONLY |
                                  LDAP_DIRSYNC_INCREMENTAL_VALUES))) 
            {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
                               
            }

            // set the flag value
            pLdapPref->_dwDirSyncFlag = dwDirsyncFlag;
                              
            iDirsyncFlagIndex = i;
            break;

        case ADS_SEARCHPREF_EXTENDED_DN:
            // sanity check of user supplied data
            //
            dwExtendedDNOption = pSearchPrefs[i].vValue.Integer;

            if(dwExtendedDNOption != 0 && dwExtendedDNOption != 1)
            {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            // set the option
            pLdapPref->_fExtendedDNControl = TRUE;
            pLdapPref->_dwExtendedDnOption = dwExtendedDNOption;
            break;
            

        default:
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;            
            fWarning = TRUE;
            continue;
        }
    }

    // if dirsyncflag is specified, but using dirsync control is not, then we should indicate error
    if(!pLdapPref->_fDirSync && iDirsyncFlagIndex != -1)
    {
        pSearchPrefs[iDirsyncFlagIndex].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;        
        fWarning = TRUE;
    }


error:

    if (pUTF8Target)
        FreeADsMem(pUTF8Target);

    //
    // Need to return the hr if it was something like out of mem.
    // Most often though it will be either S_OK or s-error ocurred.
    //
    if (FAILED(hr)) {
        //
        // Free sort keys and dirsync data if applicable
        //
        if (pLdapPref->_pSortKeys) {
            FreeSortKeys(pLdapPref->_pSortKeys, pLdapPref->_nSortKeys);
            pLdapPref->_pSortKeys = NULL;
            pLdapPref->_nSortKeys = 0;
        }

        if (pLdapPref->_pProvSpecific) {
            if (pLdapPref->_pProvSpecific->lpValue) {
                FreeADsMem(pLdapPref->_pProvSpecific->lpValue);
            }
            FreeADsMem(pLdapPref->_pProvSpecific);
            pLdapPref->_pProvSpecific = NULL;
        }

        //
        // Free VLV information if applicable
        //
        if (pLdapPref->_pVLVInfo) {
            FreeLDAPVLVInfo(pLdapPref->_pVLVInfo);
            pLdapPref->_pVLVInfo = NULL;
        }

        //
        // Free attrib-scoped query if applicable
        //
        if (pLdapPref->_pAttribScoped) {
            FreeADsStr(pLdapPref->_pAttribScoped);
            pLdapPref->_pAttribScoped = NULL;
        }
        RRETURN(hr);
    }

    RRETURN (fWarning ? S_ADS_ERRORSOCCURRED : S_OK);
}


HRESULT
ADsExecuteSearch(
    IN LDAP_SEARCH_PREF LdapPref,
    IN LPWSTR pszADsPath,
    IN LPWSTR pszLdapServer,
    IN LPWSTR pszLdapDn,
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{
    PLDAP_SEARCHINFO phSearchInfo = NULL;
    LPWSTR szCurrAttr = NULL;
    DWORD dwAttrNamesLen = 0;
    HRESULT hr = S_OK;
    ULONG i, j;
    LPWSTR pszAttrNameBuffer = NULL, *ppszAttrs = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    //
    // Initilize so that we wont end up freeing bad data.
    //
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (!phSearchHandle ) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    //
    // Allocate search handle
    //
    phSearchInfo = (PLDAP_SEARCHINFO) AllocADsMem(sizeof(LDAP_SEARCHINFO));
    if(!phSearchInfo)
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);


    memset(phSearchInfo, 0, sizeof(LDAP_SEARCHINFO));

    phSearchInfo->_pszADsPathContext = AllocADsStr(pszADsPath);
    if(!(phSearchInfo->_pszADsPathContext))
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);

    if (pszSearchFilter) {
        phSearchInfo->_pszSearchFilter = AllocADsStr(pszSearchFilter);
    }
    else {
        phSearchInfo->_pszSearchFilter = AllocADsStr(L"(objectClass=*)");
    }
    if(!(phSearchInfo->_pszSearchFilter))
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);

    if (pszLdapServer) {
        phSearchInfo->_pszLdapServer = AllocADsStr(pszLdapServer);
        if (!phSearchInfo->_pszLdapServer) {
           BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    if (pszLdapDn) {
        phSearchInfo->_pszBindContextDn = AllocADsStr(pszLdapDn);
        if(!(phSearchInfo->_pszBindContextDn)){

            BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);
        }
    }

    phSearchInfo->_fADsPathPresent = FALSE;
    phSearchInfo->_fADsPathReturned = FALSE;
    phSearchInfo->_fADsPathOnly = FALSE;

    phSearchInfo->_fDNPresent = FALSE;
    phSearchInfo->_fDNReturned = FALSE;

    if (dwNumberAttributes == -1) {
        //
        // Specifies returning all attributes
        //

        phSearchInfo->_ppszAttrs = NULL;
        phSearchInfo->_pszAttrNameBuffer = NULL;
        phSearchInfo->_fADsPathPresent = TRUE;
        if(LdapPref._fDirSync)
        {
            phSearchInfo->_fDNPresent = TRUE;
        }
    }
    else {
        ppszAttrs = (LPWSTR *) AllocADsMem(
                                  sizeof(LPWSTR) *
                                  (dwNumberAttributes + 1)
                                  );
        if (!ppszAttrs)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        for (i = 0; i < dwNumberAttributes; i++)
            dwAttrNamesLen+= (wcslen(pAttributeNames[i]) + 1) * sizeof(WCHAR);

        pszAttrNameBuffer = (LPWSTR) AllocADsMem(
                                         dwAttrNamesLen
                                         );
        if (!pszAttrNameBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        szCurrAttr = pszAttrNameBuffer;
        for (i = 0, j = 0; i < dwNumberAttributes; i++) {

            wcscpy(szCurrAttr, pAttributeNames[i]);
            ppszAttrs[j] = szCurrAttr;
            szCurrAttr += wcslen(ppszAttrs[j]) + 1;

            if(_wcsicmp(ppszAttrs[j], L"ADsPath") == 0) {
                //
                // This attribute need not be sent
                //

                phSearchInfo->_fADsPathPresent = TRUE;
            }
            else if(LdapPref._fDirSync && _wcsicmp(ppszAttrs[j], L"distinguishedName") == 0) {
                //
                // This attribute need not be sent
                //

                phSearchInfo->_fDNPresent = TRUE;
            }                
            else {

                j++;
            }

        }

        // If the query requests only ADsPath, then set ppszAttrs[0] to some
        // attribute. Setting it to NULL results in all attributes being
        // returned, which is a huge performance hit. Instead, request only
        // the objectclass (guaranteed to be present on all LDAP servers).
        if (0 == j)
        {
            FreeADsMem(pszAttrNameBuffer);
            pszAttrNameBuffer = (LPWSTR) AllocADsStr(L"objectClass");
            if(pszAttrNameBuffer == NULL) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            FreeADsMem(ppszAttrs);
            ppszAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * 2);
            if(ppszAttrs == NULL) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
                                  
            ppszAttrs[0] = pszAttrNameBuffer;
            ppszAttrs[1] = NULL;

            phSearchInfo->_fADsPathOnly = TRUE;
        }
        else
            ppszAttrs[j] = NULL;

        phSearchInfo->_ppszAttrs = ppszAttrs;
        phSearchInfo->_pszAttrNameBuffer = pszAttrNameBuffer;
    }


    hr = ADsObject(pszADsPath, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    phSearchInfo->_dwPort = pObjectInfo->PortNumber;

    phSearchInfo->_pConnection = NULL;
    phSearchInfo->_hPagedSearch = NULL;
    phSearchInfo->_pSearchResults = NULL;
    phSearchInfo->_cSearchResults = 0;
    phSearchInfo->_dwCurrResult = 0;
    phSearchInfo->_dwMaxResultGot = 0;
    phSearchInfo->_currMsgId = (DWORD) -1;
    phSearchInfo->_pCurrentRow = NULL;
    phSearchInfo->_pFirstAttr = NULL;
    phSearchInfo->_fLastResult = FALSE;
    phSearchInfo->_fLastPage = FALSE;
    phSearchInfo->_fBefFirstRow = TRUE;
    phSearchInfo->_hrLastSearch = S_OK;
    phSearchInfo->_fNonFatalErrors = FALSE;
    phSearchInfo->_fAbandon = FALSE;
    phSearchInfo->_dwVLVOffset = 0;
    phSearchInfo->_dwVLVCount  = 0;
    phSearchInfo->_pVLVContextID = NULL;
    phSearchInfo->_pBerValAttribScoped = NULL;
    phSearchInfo->_pBerValExtendedDN = NULL;

    //
    // Copy the search preference structure and also make a copy of the memory
    // that the internal pointers point to. This can probably be done better by
    // an assignment operator.
    //
    phSearchInfo->_SearchPref = LdapPref;
    phSearchInfo->_SearchPref._pVLVInfo = NULL;
    phSearchInfo->_SearchPref._pAttribScoped = NULL;

    // sorting
    if (LdapPref._pSortKeys) {

        phSearchInfo->_SearchPref._pSortKeys = (PLDAPSortKey) AllocADsMem(
                                            sizeof(LDAPSortKey) * LdapPref._nSortKeys);
        if (!phSearchInfo->_SearchPref._pSortKeys) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(
            phSearchInfo->_SearchPref._pSortKeys,
            LdapPref._pSortKeys,
            sizeof(LDAPSortKey) * LdapPref._nSortKeys
            );

        //
        // We need to copy over all the attibutes.
        //
        for (i=0; i < LdapPref._nSortKeys; i++) {
            phSearchInfo->_SearchPref._pSortKeys[i].sk_attrtype =
                AllocADsStr( LdapPref._pSortKeys[i].sk_attrtype);

            if (!phSearchInfo->_SearchPref._pSortKeys[i].sk_attrtype) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

    }

    // VLV
    if (LdapPref._pVLVInfo) {
        hr = CopyLDAPVLVInfo(LdapPref._pVLVInfo, &(phSearchInfo->_SearchPref._pVLVInfo));
        BAIL_ON_FAILURE(hr);
    }

    // Attribute-scoped query
    if (LdapPref._pAttribScoped) {
        phSearchInfo->_SearchPref._pAttribScoped = AllocADsStr(LdapPref._pAttribScoped);
        if (!(phSearchInfo->_SearchPref._pAttribScoped)) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    *phSearchHandle = phSearchInfo;

    FreeObjectInfo(pObjectInfo);

    RRETURN(S_OK);

error:

    FreeObjectInfo(pObjectInfo);

    if(phSearchInfo) {

       if (phSearchInfo->_pszLdapServer) {
          FreeADsStr(phSearchInfo->_pszLdapServer);
       }

        if(phSearchInfo->_pszBindContextDn)
            FreeADsStr(phSearchInfo->_pszBindContextDn);

        if(phSearchInfo->_pszADsPathContext)
            FreeADsStr(phSearchInfo->_pszADsPathContext);

        if(phSearchInfo->_pszSearchFilter)
            FreeADsStr(phSearchInfo->_pszSearchFilter);

        if(phSearchInfo->_ppszAttrs)
            FreeADsMem(phSearchInfo->_ppszAttrs);
        else if(ppszAttrs)
            FreeADsMem(ppszAttrs);

        if(phSearchInfo->_pszAttrNameBuffer)
            FreeADsMem(phSearchInfo->_pszAttrNameBuffer);
        else if(pszAttrNameBuffer)
            FreeADsMem(pszAttrNameBuffer);

        if (phSearchInfo->_SearchPref._pVLVInfo) {
            FreeLDAPVLVInfo(phSearchInfo->_SearchPref._pVLVInfo);
        }

        if (phSearchInfo->_SearchPref._pAttribScoped) {
            FreeADsStr(phSearchInfo->_SearchPref._pAttribScoped);
        }

        FreeADsMem(phSearchInfo);
    }

    RRETURN (hr);
}


HRESULT
ADsAbandonSearch(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    DWORD dwStatus = 0;
    HRESULT hr = S_OK;
    int ldaperr = 0;

    // If there is an outstanding message id, call LdapAbandon
    //
    if (phSearchInfo->_currMsgId != (DWORD) -1) {

        dwStatus = LdapAbandon(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_currMsgId
                       );
    }
    //
    // Make sure that we don't do extra searches anymore. We only give back
    // whatever rows we have already received from the server
    //

    if(dwStatus != 0)
    {
        // the abandon call fails
        phSearchInfo->_fAbandon = FALSE;
        ldaperr = LdapGetLastError();        
        CheckAndSetExtendedError( phSearchInfo->_pConnection->LdapHandle, &hr, ldaperr);
    }
    else
    {
        phSearchInfo->_fAbandon = TRUE;
    }

    RRETURN(hr);

}
HRESULT
ADsCloseSearchHandle (
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{

    HRESULT hr = S_OK;
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    DWORD i=0;

    if (!phSearchInfo)
        RRETURN (E_ADS_BAD_PARAMETER);

    if (phSearchInfo->_pszLdapServer)
       FreeADsStr(phSearchInfo->_pszLdapServer);

    if(phSearchInfo->_pszBindContextDn)
        FreeADsStr(phSearchInfo->_pszBindContextDn);

    if(phSearchInfo->_pszADsPathContext)
        FreeADsStr(phSearchInfo->_pszADsPathContext);

    if(phSearchInfo->_pszSearchFilter)
        FreeADsStr(phSearchInfo->_pszSearchFilter);

    if(phSearchInfo->_ppszAttrs)
        FreeADsMem(phSearchInfo->_ppszAttrs);

    if(phSearchInfo->_pszAttrNameBuffer)
        FreeADsMem(phSearchInfo->_pszAttrNameBuffer);


    if (phSearchInfo->_pSearchResults) {
        for (DWORD i=0; i <= phSearchInfo->_dwMaxResultGot; i++) {
            LdapMsgFree(
                phSearchInfo->_pSearchResults[i]
                );
        }
        FreeADsMem(phSearchInfo->_pSearchResults);
    }

    if (phSearchInfo->_hPagedSearch) {
        LdapSearchAbandonPage( phSearchInfo->_pConnection,
                               phSearchInfo->_hPagedSearch
                               );
    }

    //
    // Free ServerControls
    //
    if (phSearchInfo->_ServerControls) {

        //
        // This code assumes there are only VLV, sort, dirsync,
        // security descriptor, extended dn & attribute-scoped query controls.
        // If more controls are added, modify the code accordingly.
        // Nothing needs to be freed for the dirsync control for now.
        // Freeing the searchpref will take care of the controls data.
        //
        for (i=0; phSearchInfo->_ServerControls[i]; i++) {

            BOOL fSortControl = FALSE;
            BOOL fVLVControl = FALSE;
            BOOL fSecDescControl = FALSE;            

            if (phSearchInfo->_ServerControls[i]->ldctl_oid) {
                // Compare with sort control
                if (wcscmp(
                        phSearchInfo->_ServerControls[i]->ldctl_oid,
                        LDAP_SERVER_SORT_OID_W
                        ) == 0 ) {
                    fSortControl = TRUE;
                } else {
                    fSortControl = FALSE;
                }

                // Compare with VLV control
                if (wcscmp(
                        phSearchInfo->_ServerControls[i]->ldctl_oid,
                        LDAP_CONTROL_VLVREQUEST_W
                        ) == 0 ) {
                    fVLVControl = TRUE;
                } else {
                    fVLVControl = FALSE;
                }

                // Compare with security descriptor control
                if (wcscmp(
                        phSearchInfo->_ServerControls[i]->ldctl_oid,
                        LDAP_SERVER_SD_FLAGS_OID_W
                        ) == 0 ) {
                    fSecDescControl = TRUE;
                } else {
                    fSecDescControl = FALSE;
                }
                                
            }

            //
            // Free the sort control if this is it.
            //
            if (fSortControl) {

                if (phSearchInfo->_ServerControls[i]->ldctl_oid != NULL) {
                    ldap_memfree( phSearchInfo->_ServerControls[i]->ldctl_oid );
                }

                if (phSearchInfo->_ServerControls[i]->ldctl_value.bv_val != NULL) {
                    ldap_memfreeA( phSearchInfo->_ServerControls[i]->ldctl_value.bv_val );
                }

            }

            //
            // Free the security descriptor control if this is it
            //
            if (fSecDescControl) {
            
                if (phSearchInfo->_ServerControls[i]->ldctl_value.bv_val != NULL) {
                    FreeADsMem( phSearchInfo->_ServerControls[i]->ldctl_value.bv_val );
                }
            }
                        
            //
            // Need to free the control if sort or not.
            // Exception: VLV control is freed with LdapControlFree,
            // not with FreeADsMem
            //
            if (fVLVControl) {
                LdapControlFree( phSearchInfo->_ServerControls[i] );
            }
            else {
                FreeADsMem( phSearchInfo->_ServerControls[i] );
            }
        }

        FreeADsMem( phSearchInfo->_ServerControls );

    }

    //
    // Free SearchPref data
    //
    FreeSortKeys(
        phSearchInfo->_SearchPref._pSortKeys,
        phSearchInfo->_SearchPref._nSortKeys
        );

    FreeLDAPVLVInfo(phSearchInfo->_SearchPref._pVLVInfo);

    if (phSearchInfo->_SearchPref._pAttribScoped)
        FreeADsStr(phSearchInfo->_SearchPref._pAttribScoped);

    //
    // Free Dirsync control infromation.
    //
    if (phSearchInfo->_SearchPref._fDirSync) {
        if (phSearchInfo->_SearchPref._pProvSpecific) {
            //
            // Free the data if applicable.
            //
            if (phSearchInfo->_SearchPref._pProvSpecific->lpValue) {
                FreeADsMem(phSearchInfo->_SearchPref._pProvSpecific->lpValue);
            }
            //
            // Free the struct itself
            //
            FreeADsMem(phSearchInfo->_SearchPref._pProvSpecific);
            phSearchInfo->_SearchPref._pProvSpecific = NULL;
        }
    }


    if (phSearchInfo->_pVLVContextID) {
        if (phSearchInfo->_pVLVContextID->bv_val) {
            FreeADsMem(phSearchInfo->_pVLVContextID->bv_val);
        }
        
        FreeADsMem(phSearchInfo->_pVLVContextID);
    }
    if (phSearchInfo->_pBerVal) {
        ber_bvfree(phSearchInfo->_pBerVal);
    }

    if (phSearchInfo->_pBerValAttribScoped) {
        ber_bvfree(phSearchInfo->_pBerValAttribScoped);
    }

    if(phSearchInfo->_pBerValExtendedDN)
    {
        ber_bvfree(phSearchInfo->_pBerValExtendedDN);
    }
    
    if(phSearchInfo->_pConnection)
        LdapCloseObject(
            phSearchInfo->_pConnection
            );

    FreeADsMem(phSearchInfo);


    RRETURN (hr);
}


HRESULT
ADsGetFirstRow(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN CCredentials& Credentials
    )
{

    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR, dwStatus2 = NO_ERROR;
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    LDAP *ld = NULL;
    BOOL fNewOptionSet = FALSE;

    DWORD oldOption = 0;
    DWORD newOption = 0;

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    // reset the value
    phSearchInfo->_fADsPathReturned = FALSE;
    phSearchInfo->_fDNReturned = FALSE;

    if(!phSearchInfo->_pConnection) {

        hr = LdapOpenObject(
                       phSearchInfo->_pszLdapServer,
                       phSearchInfo->_pszBindContextDn,
                       &phSearchInfo->_pConnection,
                       Credentials,
                       phSearchInfo->_dwPort
                       );
        BAIL_ON_FAILURE(hr);

        //
        // Set the preferences like deref aliases, time limit and size limit
        //
        if (ld = phSearchInfo->_pConnection->LdapHandle) {
            ld->ld_deref = phSearchInfo->_SearchPref._dwDerefAliases;
            ld->ld_sizelimit = phSearchInfo->_SearchPref._dwSizeLimit;
            ld->ld_timelimit = phSearchInfo->_SearchPref._dwTimeLimit;
        }

        hr = AddSearchControls(phSearchInfo, Credentials);
        BAIL_ON_FAILURE(hr);

    }

    ld = phSearchInfo->_pConnection->LdapHandle;
    dwStatus = ldap_get_option(
                   ld,
                   LDAP_OPT_REFERRALS,
                   &(oldOption)
                   );

    newOption = phSearchInfo->_SearchPref._dwChaseReferrals;

    dwStatus2 = ldap_set_option(
                    ld,
                    LDAP_OPT_REFERRALS,
                    &(newOption)
                    );

    if (dwStatus == NO_ERROR && dwStatus2 == NO_ERROR)
        fNewOptionSet = TRUE;

    if(!phSearchInfo->_pSearchResults) {
        //
        // Get the results. This function uses various members of pSearchInfo
        // and returns the result in phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
        // which can be used to call LdapFirstEntry and LdapNextEntry
        //
        hr = ADsGetResults(
                 phSearchInfo
                 );

        //
        // Update the VLV server response if applicable
        //
        if (phSearchInfo->_SearchPref._pVLVInfo
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrVLV = S_OK;

            hrVLV = StoreVLVInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );

            //
            // we only care if storing the cookie failed
            // if the search otherwise succeeded
            //
            if (FAILED(hrVLV) && SUCCEEDED(hr)) {
                hr = hrVLV;
            }
        }

        //
        // Update the Attribute-Scoped Query info if applicable
        //
        if (phSearchInfo->_SearchPref._pAttribScoped
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrASQ = S_OK;

            hrASQ = StoreAttribScopedInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );
                        
            //
            // we only care if storing the info failed
            // if the search otherwise succeeded
            //
            if (FAILED(hrASQ) && SUCCEEDED(hr)) {
                hr = hrASQ;
            }
            
        }
        
        //
        // Update the dirsync control cookie if applicable.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {
            //
            // Store the cookie info in searchprefs.
            //
            StoreDirSyncCookie(
                phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                phSearchInfo
                );

            while (hr == S_ADS_NOMORE_ROWS) {
                //
                // Try and get more results - this will handle the
                // case of the DirSync cookie indicating more rows
                // correctly.
                //
                hr = ADsGetMoreResultsDirSync(
                         phSearchInfo,
                         Credentials
                         );

                BAIL_ON_FAILURE(hr);

            }
        }

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS) {
            goto error;
        }

    }

    //
    // Need to set the cur result to 0 as it maybe a case
    // where we are now going back to the top of a multiple
    // page search. This will make no difference if the cache
    // is turned off.
    //
    phSearchInfo->_dwCurrResult = 0;

    hr = LdapFirstEntry(
                   phSearchInfo->_pConnection,
                   phSearchInfo->_pSearchResults[0],
                   &phSearchInfo->_pCurrentRow
                   );

    BAIL_ON_FAILURE(hr);

    if(phSearchInfo->_pCurrentRow) {
        phSearchInfo->_pFirstAttr = NULL;
        phSearchInfo->_fBefFirstRow = FALSE;
        hr = S_OK;
    }
    else {
        hr = S_ADS_NOMORE_ROWS;
        //
        // Might be DirSync case where we need to try fetch
        // more results.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_fMoreDirSync ) {
            //
            // Try and get more results - this will handle the
            // case of the DirSync cookie indicating more rows
            // correctly.
            //
            hr = ADsGetMoreResultsDirSync(
                     phSearchInfo,
                     Credentials
                     );

            BAIL_ON_FAILURE(hr);
        }
    }

error:

    if (ld && fNewOptionSet) {
        ldap_set_option(
            ld,
            LDAP_OPT_REFERRALS,
            &(oldOption)
        );
    }

    //
    // When there is no more rows to be returned, return whatever error
    // that was returned from the last search
    //
    if (hr == S_ADS_NOMORE_ROWS) {
        if (phSearchInfo->_hrLastSearch != S_OK) {
            RRETURN(phSearchInfo->_hrLastSearch);
        }
        else if (phSearchInfo->_fNonFatalErrors) {
            RRETURN(S_ADS_ERRORSOCCURRED);
        }
        else {
            RRETURN(hr);
        }
    }
    else {
        RRETURN(hr);
    }
}

HRESULT
ADsGetNextRow(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR, dwStatus2 = NO_ERROR;
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    LDAP *ld = NULL;
    BOOL fNewOptionSet = FALSE;


    DWORD oldOption = 0;
    DWORD newOption = 0;    

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    // reset the value
    phSearchInfo->_fADsPathReturned = FALSE;
    phSearchInfo->_fDNReturned = FALSE;

    if(!phSearchInfo->_pConnection) {

        hr = LdapOpenObject(
                       phSearchInfo->_pszLdapServer,
                       phSearchInfo->_pszBindContextDn,
                       &phSearchInfo->_pConnection,
                       Credentials,
                       phSearchInfo->_dwPort
                       );
        BAIL_ON_FAILURE(hr);

        //
        // Set the preferences like deref aliases, time limit and size limit
        //
        if (ld = phSearchInfo->_pConnection->LdapHandle) {
            ld->ld_deref = phSearchInfo->_SearchPref._dwDerefAliases;
            ld->ld_sizelimit = phSearchInfo->_SearchPref._dwSizeLimit;
            ld->ld_timelimit = phSearchInfo->_SearchPref._dwTimeLimit;
        }

        hr = AddSearchControls(phSearchInfo, Credentials);
        BAIL_ON_FAILURE(hr);

    }

    ld = phSearchInfo->_pConnection->LdapHandle;
    dwStatus = ldap_get_option(
                  ld,
                  LDAP_OPT_REFERRALS,
                  &(oldOption)
                  );

    newOption = phSearchInfo->_SearchPref._dwChaseReferrals;

    dwStatus2 = ldap_set_option(
                   ld,
                   LDAP_OPT_REFERRALS,
                   &(newOption)
                   );

    if (dwStatus == NO_ERROR && dwStatus2 == NO_ERROR)
        fNewOptionSet = TRUE;

    if(!phSearchInfo->_pSearchResults) {
        //
        // Get the results. This function uses various members of pSearchInfo
        // and returns the result in phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
        // which can be used to call LdapFirstEntry and LdapNextEntry
        //
        hr = ADsGetResults(
                 phSearchInfo
                 );

        //
        // Update the dirsync control cookie if applicable.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {
            //
            // Store the cookie info in searchprefs.
            //
            StoreDirSyncCookie(
                phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                phSearchInfo
                );
        }


        //
        // Update the VLV server response if applicable
        //
        if (phSearchInfo->_SearchPref._pVLVInfo
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrVLV = S_OK;

            hrVLV = StoreVLVInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );

            //
            // we only care if storing the cookie failed if the search
            // otherwise succeeded
            //
            if (FAILED(hrVLV) && SUCCEEDED(hr)) {
                hr = hrVLV;
            }
        }

        //
        // Update the Attribute-Scoped Query info if applicable
        //
        if (phSearchInfo->_SearchPref._pAttribScoped
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrASQ = S_OK;

            hrASQ = StoreAttribScopedInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );
                        
            //
            // we only care if storing the info failed
            // if the search otherwise succeeded
            //
            if (FAILED(hrASQ) && SUCCEEDED(hr)) {
                hr = hrASQ;
            }
            
        }

        if (hr == S_ADS_NOMORE_ROWS) {
            //
            // Try and get more results - this will handle the
            // case of the DirSync cookie indicating more rows
            // correctly.
            //
            hr = ADsGetMoreResultsDirSync(
                     phSearchInfo,
                     Credentials
                     );

            BAIL_ON_FAILURE(hr);

        }

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS) {
            goto error;
        }

    }

    //
    // If the current row has not been obtained, get it now. Need to
    // distinguish between the case where we are after the end of the result
    // from the case where we are before the beginning of the result. In
    // both cases _pCurrentRow is NULL, but _fBefFirstRow is TRUE only in
    // the latter case.
    //
    if(!phSearchInfo->_pCurrentRow) {
        if(phSearchInfo->_fBefFirstRow)
        {
            //
            // Call the ldap specific function to get the first row.
            //
            hr = LdapFirstEntry(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                       &phSearchInfo->_pCurrentRow
                       );
        }
    }
    else {
        //
        // Call the ldap specific function to get the next row
        //
        hr = LdapNextEntry(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pCurrentRow,
                       &phSearchInfo->_pCurrentRow
                       );
    }

    if (!phSearchInfo->_pCurrentRow
        && (phSearchInfo->_dwCurrResult < phSearchInfo->_dwMaxResultGot)) {
        //
        // In this case we need to proceed to the next result in memory
        //
        hr = S_OK;
        while (!phSearchInfo->_pCurrentRow
               && phSearchInfo->_dwCurrResult < phSearchInfo->_dwMaxResultGot
               && SUCCEEDED(hr)) {

            //
            // With Dirsync we may have results that do not have
            // any entries in them, but the next one may.
            //

            phSearchInfo->_dwCurrResult++;

            hr = LdapFirstEntry(
                     phSearchInfo->_pConnection,
                     phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                     &phSearchInfo->_pCurrentRow
                     );

        }

    }
    else if (!phSearchInfo->_pCurrentRow
             && (!phSearchInfo->_fLastResult
                 || !phSearchInfo->_fLastPage
                 || phSearchInfo->_fMoreDirSync )
             ) {

        //
        // Now if both lastResult and page are true, we need to call
        // ADsGetMoreResultsDirSync. This is the unusual case.
        //
        if (phSearchInfo->_fLastResult && phSearchInfo->_fLastPage) {
            hr = ADsGetMoreResultsDirSync(
                     phSearchInfo,
                     Credentials
                     );
        }
        else {
            //
            // This means that there are more results to be obtained
            // although the current result has reached its end.
            // Call the function to get more results in
            // phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
            // It will increment _dwCurrResult and reallocate if needed.
            //
            hr = ADsGetMoreResults(
                     phSearchInfo
                     );
        }

        //
        // In async searches, we will know if we have to call
        // ADsGetMoreResultsAsync only now. So recheck.
        //
        if (hr == S_ADS_NOMORE_ROWS
            && phSearchInfo->_SearchPref._fAsynchronous
            ) {
            if (phSearchInfo->_fLastResult && phSearchInfo->_fLastPage) {
                hr = ADsGetMoreResultsDirSync(
                         phSearchInfo,
                         Credentials
                         );
            }
        }

        //
        // Update the dirsync control cookie if applicable.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {
            //
            // Store the cookie info in searchprefs.
            //
            StoreDirSyncCookie(
                phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                phSearchInfo
                );
        }

        //
        // Update the Attribute-Scoped Query info if applicable
        //
        if (phSearchInfo->_SearchPref._pAttribScoped
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrASQ = S_OK;

            hrASQ = StoreAttribScopedInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );
                        
            //
            // we only care if storing the info failed
            // if the search otherwise succeeded
            //
            if (FAILED(hrASQ) && SUCCEEDED(hr)) {
                hr = hrASQ;
            }
            
        }

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS) {
            goto error;
        }

        hr = LdapFirstEntry(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                       &phSearchInfo->_pCurrentRow
                       );
        if (!phSearchInfo->_pCurrentRow) {
            //
            // This means that we can possibly have more results
            // but this time we did not get any - not yet a NULL
            // cookie on a paged search that is.
            //
            ADsSetLastError(
                ERROR_MORE_DATA,
                L"Calling GetNextRow can potentially return more results.",
                L"LDAP Provider"
                );
        }
    }

    BAIL_ON_FAILURE(hr);

    if(phSearchInfo->_pCurrentRow) {
        phSearchInfo->_pFirstAttr = NULL;
        phSearchInfo->_fBefFirstRow = FALSE;
        hr = S_OK;
    }
    else {
        hr = S_ADS_NOMORE_ROWS;
        //
        // Might be DirSync case where we need to try fetch
        // more results.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_fMoreDirSync ) {
            //
            // Try and get more results - this will handle the
            // case of the DirSync cookie indicating more rows
            // correctly.
            //
            hr = ADsGetMoreResultsDirSync(
                     phSearchInfo,
                     Credentials
                     );
            BAIL_ON_FAILURE(hr);

        }
    }
error:

    if (ld && fNewOptionSet) {
        ldap_set_option(
            ld,
            LDAP_OPT_REFERRALS,
            &(oldOption)
        );
    }

    //
    // When there is no more rows to be returned, return whatever error
    // that was returned from the last search
    //
    if (hr == S_ADS_NOMORE_ROWS) {
        if (phSearchInfo->_hrLastSearch != S_OK) {
            RRETURN(phSearchInfo->_hrLastSearch);
        }
        else if (phSearchInfo->_fNonFatalErrors) {
            RRETURN(S_ADS_ERRORSOCCURRED);
        }
        else {
            RRETURN(hr);
        }
    }
    else {
        RRETURN(hr);
    }

}

//
// Function to get the results by performing the appropriate search depending
// on the preferences; Paged Results, Sorting, Synchronous, Asynchrnous or
// Timed Synchronous
//

HRESULT
ADsGetResults(
    IN PLDAP_SEARCHINFO phSearchInfo
    )
{

    HRESULT hr = S_OK;
    DWORD dwError;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    ULONG totalCount;
    int resType;

    ADsAssert(phSearchInfo);

    //
    // If abandon has been called, we don't get more results.
    //
    if (phSearchInfo->_fAbandon) {
        RRETURN(S_ADS_NOMORE_ROWS);
    }

    if(!phSearchInfo->_pSearchResults) {
        //
        // Allocate an array of handles to Search Results
        //
        phSearchInfo->_pSearchResults = (LDAPMessage **) AllocADsMem(
                                             sizeof(LDAPMessage *) *
                                             NO_LDAP_RESULT_HANDLES);
        if(!phSearchInfo->_pSearchResults) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        phSearchInfo->_dwCurrResult = 0;
        phSearchInfo->_cSearchResults = NO_LDAP_RESULT_HANDLES;
        //
        // Should also set the cur max to 0;
        //
        phSearchInfo->_dwMaxResultGot = 0;
    }

    // Initialize Result to NULL
    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult] = NULL;

    //
    // Call the ldap specific search function
    //
    if (phSearchInfo->_SearchPref._dwPageSize != 0) {
        //
        // Paged results
        //
        if(!phSearchInfo->_hPagedSearch ) {

            hr = LdapSearchInitPage(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_pszBindContextDn,
                           phSearchInfo->_SearchPref._dwSearchScope,
                           phSearchInfo->_pszSearchFilter,
                           phSearchInfo->_ppszAttrs,
                           phSearchInfo->_SearchPref._fAttrsOnly,
                           phSearchInfo->_ServerControls,
                           phSearchInfo->_ClientControls,
                           phSearchInfo->_SearchPref._dwPagedTimeLimit,
                           phSearchInfo->_SearchPref._dwSizeLimit,
                           NULL,
                           &phSearchInfo->_hPagedSearch
                           );

            BAIL_ON_FAILURE(hr);

        }

        if ( phSearchInfo->_SearchPref._fAsynchronous ) {

            hr = LdapGetNextPage(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           phSearchInfo->_SearchPref._dwPageSize,
                           (ULONG *)&phSearchInfo->_currMsgId
                           );

            if (FAILED(hr)) {
                if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                    phSearchInfo->_fLastPage = TRUE;
                    RRETURN(S_ADS_NOMORE_ROWS);
                } else {
                    BAIL_ON_FAILURE(hr);
                }
            }

            //
            // Wait for one page worth of results to get back.
            //

            hr = LdapResult(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_currMsgId,
                           LDAP_MSG_ALL,
                           phSearchInfo->_SearchPref._timeout.tv_sec ?
                           &phSearchInfo->_SearchPref._timeout : NULL,
                           &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                           &resType
                           );

            if (FAILED(hr)) {
                if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
                    phSearchInfo->_fLastResult = TRUE;
                    RRETURN(S_ADS_NOMORE_ROWS);
                }
                else {
                     BAIL_ON_FAILURE(hr);                    
                }
            }

            hr = LdapGetPagedCount(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           &totalCount,
                           phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                           );
            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                     hr = S_OK;
            }
            
            //
            // if hr failed, we will do the corresponding according to whether there is any result returned in our mechanism later
            //
                
        }
        else {

            hr = LdapGetNextPageS(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           phSearchInfo->_SearchPref._timeout.tv_sec ?
                             &phSearchInfo->_SearchPref._timeout : NULL,
                           phSearchInfo->_SearchPref._dwPageSize,
                           &totalCount,
                           &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                           );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                     phSearchInfo->_fLastPage = TRUE;
                     RRETURN(S_ADS_NOMORE_ROWS);
                 }

            //
            // if hr failed, we will do the corresponding according to whether there is any result returned in our mechanism later
            //
                 
            phSearchInfo->_fLastResult = TRUE;
        }

    }
    else if (phSearchInfo->_SearchPref._fAsynchronous) {
        hr = LdapSearchExt(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pszBindContextDn,
                       phSearchInfo->_SearchPref._dwSearchScope,
                       phSearchInfo->_pszSearchFilter,
                       phSearchInfo->_ppszAttrs,
                       phSearchInfo->_SearchPref._fAttrsOnly,
                       phSearchInfo->_ServerControls,
                       phSearchInfo->_ClientControls,
                       phSearchInfo->_SearchPref._dwPagedTimeLimit,
                       phSearchInfo->_SearchPref._dwSizeLimit,
                       &phSearchInfo->_currMsgId
                       );

        BAIL_ON_FAILURE(hr);

        //
        // Wait for atleast one result
        //
        hr = LdapResult(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_currMsgId,
                       LDAP_MSG_RECEIVED,
                       phSearchInfo->_SearchPref._timeout.tv_sec ?
                         &phSearchInfo->_SearchPref._timeout : NULL,
                       &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                       &resType
                       );
        if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
            phSearchInfo->_fLastResult = TRUE;
            RRETURN(S_ADS_NOMORE_ROWS);
        }

        //
        // if hr failed, we will do the corresponding according to whether there is any result returned in our mechanism later
        //
        
        phSearchInfo->_fLastPage = TRUE;
    }
    else if (phSearchInfo->_SearchPref._timeout.tv_sec != 0) {
        hr = LdapSearchExtS(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pszBindContextDn,
                       phSearchInfo->_SearchPref._dwSearchScope,
                       phSearchInfo->_pszSearchFilter,
                       phSearchInfo->_ppszAttrs,
                       phSearchInfo->_SearchPref._fAttrsOnly,
                       phSearchInfo->_ServerControls,
                       phSearchInfo->_ClientControls,
                       &phSearchInfo->_SearchPref._timeout,
                       phSearchInfo->_SearchPref._dwSizeLimit,
                       &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                       );
        phSearchInfo->_fLastResult = TRUE;
        phSearchInfo->_fLastPage = TRUE;
    }
    else {
        hr = LdapSearchExtS(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pszBindContextDn,
                       phSearchInfo->_SearchPref._dwSearchScope,
                       phSearchInfo->_pszSearchFilter,
                       phSearchInfo->_ppszAttrs,
                       phSearchInfo->_SearchPref._fAttrsOnly,
                       phSearchInfo->_ServerControls,
                       phSearchInfo->_ClientControls,
                       NULL,
                       phSearchInfo->_SearchPref._dwSizeLimit,
                       &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                       );
        phSearchInfo->_fLastResult = TRUE;
        phSearchInfo->_fLastPage = TRUE;
    }

    //
    // Only if there are zero rows returned, return the error,
    // otherwise, store the error and return when GetNextRow is
    // called for the last time
    //
    if (FAILED(hr) &&
        (LdapCountEntries( phSearchInfo->_pConnection,
            phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) == 0)) {
        BAIL_ON_FAILURE(hr);
    }
    else {

         phSearchInfo->_hrLastSearch = hr;
         hr = S_OK;
    }

    phSearchInfo->_pCurrentRow = NULL;

error:

    RRETURN(hr);
}

//
// For Asynchronous or paged searches, more results need to be obtained, once
// the current result set is exhausted. This function gets the next result set
// if one is available. In the case of paged results, this might translate to
// getting the next page.
//

HRESULT
ADsGetMoreResults(
    IN PLDAP_SEARCHINFO phSearchInfo
    )
{

    HRESULT hr = S_OK;
    DWORD dwError;
    LPWSTR pszLDAPPath;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    ULONG totalCount;
    int resType;
    LDAPMessage **pTemp = NULL;


    ADsAssert(phSearchInfo);

    //
    // If abandon has been called, we don't get more results.
    //
    if (phSearchInfo->_fAbandon) {
        RRETURN(S_ADS_NOMORE_ROWS);
    }

    if (phSearchInfo->_fLastResult && phSearchInfo->_fLastPage)
        RRETURN (S_ADS_NOMORE_ROWS);

    if (phSearchInfo->_fLastResult == FALSE) {

        //
        // if we need to cache the results, then we save the result in the
        // phSearchInfo->_pSearchResults array. If we don't need to cache it,
        // release the result and save it in the same place.

        if ( phSearchInfo->_SearchPref._fCacheResults ) {

            ADsAssert(phSearchInfo->_dwCurrResult
                      == phSearchInfo->_dwMaxResultGot);

            phSearchInfo->_dwCurrResult++;
            phSearchInfo->_dwMaxResultGot++;
            if (phSearchInfo->_dwCurrResult >= phSearchInfo->_cSearchResults) {
                //
                // Need to allocate more memory for handles
                //
                pTemp = (LDAPMessage **) ReallocADsMem(
                                                     (void *) phSearchInfo->_pSearchResults,
                                                     sizeof(LDAPMessage *) *
                                                     phSearchInfo->_cSearchResults,
                                                     sizeof(LDAPMessage *) *
                                                     (phSearchInfo->_cSearchResults +
                                                     NO_LDAP_RESULT_HANDLES));
                if(!pTemp) {
                    hr = E_OUTOFMEMORY;
                    phSearchInfo->_dwCurrResult--;
                    phSearchInfo->_dwMaxResultGot--;
                    goto error;
                }
                phSearchInfo->_pSearchResults = pTemp;
                pTemp = NULL;
                phSearchInfo->_cSearchResults += NO_LDAP_RESULT_HANDLES;

            }

        }
        else {
            //
            // Release and use the same space to store the next result.
            //
            LdapMsgFree(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
        }

        // Initialize Result to NULL
        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult] = NULL;

        hr = LdapResult(
                 phSearchInfo->_pConnection,
                 phSearchInfo->_currMsgId,
                 LDAP_MSG_RECEIVED,
                 phSearchInfo->_SearchPref._timeout.tv_sec ?
                   &phSearchInfo->_SearchPref._timeout : NULL,
                 &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                 &resType
                 );

        if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
            phSearchInfo->_fLastResult = TRUE;
        }
        else {
            phSearchInfo->_hrLastSearch = hr;
            hr = S_OK;
            RRETURN(hr);
        }

    }

    //
    // The last result has been reached. Check if we need to look for further
    // pages
    //

    if ( phSearchInfo->_fLastPage == FALSE) {

        //
        // if we need to cache the results, then we save the result in the
        // phSearchInfo->_pSearchResults array. If we don't need to cache it,
        // release the result and save it in the same place.

        if ( phSearchInfo->_SearchPref._fCacheResults ) {

            ADsAssert(phSearchInfo->_dwCurrResult
                        == phSearchInfo->_dwMaxResultGot);

            phSearchInfo->_dwCurrResult++;
            phSearchInfo->_dwMaxResultGot++;
            if (phSearchInfo->_dwCurrResult >= phSearchInfo->_cSearchResults) {
                //
                // Need to allocate more memory for handles
                //
                pTemp = (LDAPMessage **) ReallocADsMem(
                                                     (void *) phSearchInfo->_pSearchResults,
                                                     sizeof(LDAPMessage *) *
                                                     phSearchInfo->_cSearchResults,
                                                     sizeof(LDAPMessage *) *
                                                     (phSearchInfo->_cSearchResults +
                                                     NO_LDAP_RESULT_HANDLES));
                if(!pTemp) {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                phSearchInfo->_pSearchResults = pTemp;
                pTemp = NULL;
                phSearchInfo->_cSearchResults += NO_LDAP_RESULT_HANDLES;

            }
        }
        else {
            //
            // Release and use the same space to store the next result.
            //
            LdapMsgFree(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
        }

        // Initialize Result to NULL
        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult] = NULL;

        if ( phSearchInfo->_SearchPref._fAsynchronous ) {

            hr = LdapGetNextPage(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           phSearchInfo->_SearchPref._dwPageSize,
                           (ULONG *) &phSearchInfo->_currMsgId
                           );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                phSearchInfo->_fLastPage = TRUE;

                if (phSearchInfo->_SearchPref._fCacheResults) {
                    phSearchInfo->_dwCurrResult--;
                    phSearchInfo->_dwMaxResultGot--;
                }

                RRETURN(S_ADS_NOMORE_ROWS);
            }
            BAIL_ON_FAILURE(hr);

            //
            // Wait for one page worth of results to get back.
            //
            hr = LdapResult(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_currMsgId,
                           LDAP_MSG_ALL,
                           phSearchInfo->_SearchPref._timeout.tv_sec ?
                             &phSearchInfo->_SearchPref._timeout : NULL,
                           &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                           &resType
                           );

            phSearchInfo->_fLastResult = FALSE;

            if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
                phSearchInfo->_fLastResult = TRUE;
                RRETURN(S_ADS_NOMORE_ROWS);
            }
            BAIL_ON_FAILURE(hr);

            hr = LdapGetPagedCount(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           &totalCount,
                           phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                           );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                hr = S_OK;
            }
            BAIL_ON_FAILURE(hr);

        }
        else {

            hr = LdapGetNextPageS(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           phSearchInfo->_SearchPref._timeout.tv_sec ?
                             &phSearchInfo->_SearchPref._timeout : NULL,
                           phSearchInfo->_SearchPref._dwPageSize,
                           &totalCount,
                           &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                           );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                //
                // Since we hit the last page we need to get the
                // count of the max and currResults down by one.
                //
                if (phSearchInfo->_SearchPref._fCacheResults) {
                    phSearchInfo->_dwCurrResult--;
                    phSearchInfo->_dwMaxResultGot--;
                }
                phSearchInfo->_fLastPage = TRUE;
                RRETURN(S_ADS_NOMORE_ROWS);
            }
            BAIL_ON_FAILURE(hr);

        }
        RRETURN(S_OK);
    }

    //
    // If we came here, we have reached the end
    //

    hr = S_ADS_NOMORE_ROWS;

error:

    RRETURN(hr);
}

HRESULT
ADsGetPreviousRow(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN CCredentials& Credentials
    )
{
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    LDAPMessage *pTmpRow, *pTargetRow, *pPrevRow = NULL;
    DWORD dwOrigCurrResult;
    HRESULT hr;

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if(!phSearchInfo->_pConnection) {
    // cannot ask for previous row if connection not established
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if(!phSearchInfo->_pSearchResults) {
    // cannot ask for previous row if no results have been obtained
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    // save value in case we need to restore later
    dwOrigCurrResult = phSearchInfo->_dwCurrResult;

    if(NULL == phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult])
    // we are at the end of the entire search result list
    {
        ADsAssert(!phSearchInfo->_pCurrentRow);

        if(phSearchInfo->_dwCurrResult > 0)
        // we need to get the last entry of the previous result
            phSearchInfo->_dwCurrResult--;
        else
        {
            phSearchInfo->_fBefFirstRow = TRUE;
            RRETURN(S_ADS_NOMORE_ROWS);
        }
    }

    ADsAssert(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    hr = LdapFirstEntry(phSearchInfo->_pConnection,
                    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                    &pTmpRow);
    BAIL_ON_FAILURE(hr);

    // row whose predecessor we are looking for (this may be NULL)
    pTargetRow = phSearchInfo->_pCurrentRow;

    if(pTmpRow == pTargetRow)
    // we are at the first row of the current result
    {
        if(phSearchInfo->_dwCurrResult > 0)
        {
            // we need to get the last entry of the previous result
            phSearchInfo->_dwCurrResult--;
            pTargetRow = NULL;

            hr = LdapFirstEntry(phSearchInfo->_pConnection,
                    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                    &pTmpRow);
            BAIL_ON_FAILURE(hr);
        }
        else
        {
            phSearchInfo->_pCurrentRow = NULL;
            phSearchInfo->_fBefFirstRow = TRUE;
            RRETURN(S_ADS_NOMORE_ROWS);
        }
    }

    while(pTmpRow != pTargetRow)
    {
        pPrevRow = pTmpRow;
        hr = LdapNextEntry(phSearchInfo->_pConnection,
                    pTmpRow,
                    &pTmpRow);
        BAIL_ON_FAILURE(hr);
    }

    ADsAssert(pPrevRow);

    phSearchInfo->_pCurrentRow = pPrevRow;
    phSearchInfo->_pFirstAttr = NULL;

    RRETURN(S_OK);

error:

    phSearchInfo->_dwCurrResult = dwOrigCurrResult;
    RRETURN(hr);
}


HRESULT
ADsGetColumn(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    IN CCredentials& Credentials,
    DWORD dwPort,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    VOID **ppValue = NULL;
    struct berval **ppBerValue = NULL;
    WCHAR **ppStrValue = NULL;
    int cValueCount;
    HRESULT hr = S_OK;
    DWORD dwStatus;
    LPWSTR pszDn = NULL;
    LPWSTR pszADsPathName = NULL;
    DWORD dwSyntaxId;
    DWORD dwError;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    PADS_VLV pVLV = NULL;
    LPWSTR pszTempDN = NULL;

    if( !pColumn ||
        !phSearchInfo ||
        !phSearchInfo->_pSearchResults )
        RRETURN (E_ADS_BAD_PARAMETER);

    pColumn->pszAttrName = NULL;
    pColumn->dwADsType = ADSTYPE_INVALID;
    pColumn->pADsValues = NULL;
    pColumn->dwNumValues = 0;
    pColumn->hReserved = NULL;

    if(!phSearchInfo->_pConnection)
        RRETURN (E_ADS_BAD_PARAMETER);


    if (!phSearchInfo->_pCurrentRow
        && _wcsicmp(pszColumnName, ADS_DIRSYNC_COOKIE)
        && _wcsicmp(pszColumnName, ADS_VLV_RESPONSE)) {
        //
        // Current row is not valid and you are not asking for the
        // dirsync cookie - so we will fail.
        //
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    pColumn->pszAttrName = AllocADsStr(pszColumnName);
    if (!pColumn->pszAttrName)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    if(!_wcsicmp (pszColumnName, L"ADsPath")) {
        //
        // Get the DN of the entry.
        //
        hr = LdapGetDn(
                     phSearchInfo->_pConnection,
                     phSearchInfo->_pCurrentRow,
                     &pszDn
                     );
        BAIL_ON_FAILURE(hr);
        

        // if extended_dn control is used, we need to get the normal dn format out for ADsPath
        if(phSearchInfo->_SearchPref._fExtendedDNControl)
        {
            hr = HelpGetNormalDN(pszDn, &pszTempDN);
            BAIL_ON_FAILURE(hr);
        }
        else
        {
            pszTempDN = pszDn;
        }

        //
        // Build the ADsPath
        //

        hr = BuildADsPathFromLDAPPath(
                 phSearchInfo->_pszADsPathContext,
                 pszTempDN,
                 &pszADsPathName
                 );

        BAIL_ON_FAILURE(hr);

        LdapMemFree(pszDn);
        pszDn = NULL;


        pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));
        if (!pColumn->pADsValues)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pColumn->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
        pColumn->dwNumValues = 1;
        pColumn->pADsValues[0].dwType = ADSTYPE_CASE_IGNORE_STRING;

        pColumn->pADsValues[0].CaseIgnoreString = AllocADsStr(pszADsPathName);
        if (!pColumn->pADsValues[0].CaseIgnoreString)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        FreeADsMem(pszADsPathName);

        RRETURN(S_OK);
    }
    else if (phSearchInfo->_SearchPref._fDirSync) {
        //
        // See if we need to return the DistinguishedName
        //
        if(phSearchInfo->_fDNPresent && !_wcsicmp(pszColumnName, L"distinguishedName"))
        {
            //
            // Get the DN of the entry.
            //
            hr = LdapGetDn(
                     phSearchInfo->_pConnection,
                     phSearchInfo->_pCurrentRow,
                     &pszDn
                     );
            BAIL_ON_FAILURE(hr);

            pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));
            if (!pColumn->pADsValues)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->dwADsType = ADSTYPE_DN_STRING;
            pColumn->dwNumValues = 1;
            pColumn->pADsValues[0].dwType = ADSTYPE_DN_STRING;

            pColumn->pADsValues[0].CaseIgnoreString = AllocADsStr(pszDn);
            if (!pColumn->pADsValues[0].CaseIgnoreString)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            LdapMemFree(pszDn);

            RRETURN(S_OK);
            
        }

        
        //
        // See if we need to return the dirsync control info.
        //
        if (!_wcsicmp (pszColumnName, ADS_DIRSYNC_COOKIE)) {

            pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));

            if (!pColumn->pADsValues)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->dwADsType = ADSTYPE_PROV_SPECIFIC;
            pColumn->dwNumValues = 1;
            pColumn->pADsValues[0].dwType = ADSTYPE_PROV_SPECIFIC;

            //
            // Copy the control over if appropriate if not we will
            // return NULL or empty data for the result.
            //
            if (phSearchInfo->_SearchPref._pProvSpecific->lpValue) {

                pColumn->pADsValues[0].ProviderSpecific.dwLength =
                    phSearchInfo->_SearchPref._pProvSpecific->dwLength;


                pColumn->pADsValues[0].ProviderSpecific.lpValue = (LPBYTE)
                    AllocADsMem(
                        pColumn->pADsValues[0].ProviderSpecific.dwLength
                        );
                if (!pColumn->pADsValues[0].ProviderSpecific.lpValue) {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }


                memcpy(
                    pColumn->pADsValues[0].ProviderSpecific.lpValue,
                    phSearchInfo->_SearchPref._pProvSpecific->lpValue,
                    phSearchInfo->_SearchPref._pProvSpecific->dwLength
                    );

            }
            RRETURN(S_OK);
        } // if DirSyncControlStruct is being asked for.
    } // if dirsync set.
    else if (phSearchInfo->_SearchPref._pVLVInfo) {
        //
        // See if we need to return the VLV control info.
        //
        if (!_wcsicmp (pszColumnName, ADS_VLV_RESPONSE)) {

            pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));

            if (!pColumn->pADsValues)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->dwADsType = ADSTYPE_PROV_SPECIFIC;
            pColumn->dwNumValues = 1;
            pColumn->pADsValues[0].dwType = ADSTYPE_PROV_SPECIFIC;

            pColumn->pADsValues[0].ProviderSpecific.dwLength = sizeof(ADS_VLV);
            pColumn->pADsValues[0].ProviderSpecific.lpValue = (LPBYTE) AllocADsMem(sizeof(ADS_VLV));
            if (!pColumn->pADsValues[0].ProviderSpecific.lpValue)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            // copy the VLV data into the ADS_VLV
            pVLV = (PADS_VLV) pColumn->pADsValues[0].ProviderSpecific.lpValue;

            pVLV->dwBeforeCount  = 0;
            pVLV->dwAfterCount   = 0;
            pVLV->dwOffset       = phSearchInfo->_dwVLVOffset;
            pVLV->dwContentCount = phSearchInfo->_dwVLVCount;
            pVLV->pszTarget     = NULL;

            // copy the VLV context ID, if available
            pVLV->lpContextID = NULL;
            pVLV->dwContextIDLength = 0;

            if (phSearchInfo->_pVLVContextID && phSearchInfo->_pVLVContextID->bv_len) {
                pVLV->lpContextID = (LPBYTE) AllocADsMem(phSearchInfo->_pVLVContextID->bv_len);
                if (!pVLV->lpContextID)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                pVLV->dwContextIDLength = phSearchInfo->_pVLVContextID->bv_len;
                memcpy(pVLV->lpContextID,
                       phSearchInfo->_pVLVContextID->bv_val,
                       phSearchInfo->_pVLVContextID->bv_len);
            }

            RRETURN(S_OK);
        } // if VLV response is being asked for
    } // if VLV set


    if (phSearchInfo->_fADsPathOnly) {
        //
        // Only ADsPath attribute requested in the search,
        // so don't return any other column values.
        //
        RRETURN (E_ADS_COLUMN_NOT_SET);
    }

    if (phSearchInfo->_SearchPref._fAttrsOnly) {
        //
        // Only Names got. So, don't return any values
        //
        RRETURN (S_OK);
    }


    //
    // Call the helper function to get the LDAP specific type
    //
    hr = LdapGetSyntaxOfAttributeOnServer(
             phSearchInfo->_pszLdapServer,
             pszColumnName,
             &dwSyntaxId,
             Credentials,
             dwPort
             );

    if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
        //
        // This means that the server didn't give back the schema and we don't
        // have it in the default schema. Return an octet blob.
        //
        dwSyntaxId = LDAPTYPE_OCTETSTRING;
        hr = S_OK;
    }

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        //
        // Not on the server, we will return as provider specific.
        // LDAPTYPE_UNKNOWN will be mapped to ADSTYPE_PROVIDER_SPECIFIC
        // when we build the ADsColumn.
        //
        dwSyntaxId = LDAPTYPE_UNKNOWN;
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Now get the data
    //
    switch ( dwSyntaxId )
    {
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_SECURITY_DESCRIPTOR:
        case LDAPTYPE_UNKNOWN:
            hr = LdapGetValuesLen(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_pCurrentRow,
                           pszColumnName,
                           &ppBerValue,
                           &cValueCount
                           );

            ppValue = (VOID **) ppBerValue;
            break;

        default:
            hr = LdapGetValues(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_pCurrentRow,
                           pszColumnName,
                           &ppStrValue,
                           &cValueCount
                           );
            ppValue = (VOID **) ppStrValue;
            break;
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)) {
        hr=E_ADS_COLUMN_NOT_SET;
    }
    BAIL_ON_FAILURE(hr);

    hr = LdapValueToADsColumn(
             pszColumnName,
             dwSyntaxId,
             cValueCount,
             ppValue,
             pColumn
             );
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:

    ADsFreeColumn(pColumn);

    if (pszADsPathName)
        FreeADsMem(pszADsPathName);

    if(pszDn)
    {
        LdapMemFree(pszDn);
    }

    RRETURN (hr);

}



HRESULT
ADsGetNextColumnName(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{

    HRESULT hr = S_OK;
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    DWORD dwStatus, dwError;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];

    if( !phSearchInfo ||
        !phSearchInfo->_pSearchResults ||
        !ppszColumnName)
        RRETURN (E_ADS_BAD_PARAMETER);

    *ppszColumnName = NULL;

    if (!phSearchInfo->_fADsPathOnly) {

        if (!phSearchInfo->_pFirstAttr)
            hr = LdapFirstAttribute(
                            phSearchInfo->_pConnection,
                            phSearchInfo->_pCurrentRow,
                            &phSearchInfo->_pFirstAttr,
                            ppszColumnName
                            );
        else
            hr = LdapNextAttribute(
                            phSearchInfo->_pConnection,
                            phSearchInfo->_pCurrentRow,
                            phSearchInfo->_pFirstAttr,
                            ppszColumnName
                            );

        BAIL_ON_FAILURE(hr);
    }

    if (*ppszColumnName) {

        // Nothing to do in this case.
    }
    else if ( phSearchInfo->_fDNPresent || phSearchInfo->_fADsPathPresent) {

        if(phSearchInfo->_fDNPresent)
        {
            if(!phSearchInfo->_fDNReturned)
            {
                *ppszColumnName = AllocADsStr(L"distinguishedName");
                if(!*ppszColumnName)
                {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
                phSearchInfo->_fDNReturned = TRUE;

                // got the column name, just return
                hr = S_OK;
                return hr;
            }
            else
            {
                // just set hr equal to no more column here
                hr = S_ADS_NOMORE_COLUMNS;
            }
            
        }

        //
        // If ADsPath was specified return it as the last column
        //

        if(phSearchInfo->_fADsPathPresent)
        {

            if (!phSearchInfo->_fADsPathReturned) {

                *ppszColumnName = AllocADsStr(L"ADsPath");
                if(!*ppszColumnName)
                {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
                phSearchInfo->_fADsPathReturned = TRUE;
                hr = S_OK;
            }
            else {
                               
                hr = S_ADS_NOMORE_COLUMNS;
            }
        }
    }
    else {

        hr = S_ADS_NOMORE_COLUMNS;
    }

error:

    RRETURN (hr);
}



HRESULT
ADsFreeColumn(
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    if(!pColumn)
        RRETURN (E_ADS_BAD_PARAMETER);

    switch(pColumn->dwADsType) {
    case ADSTYPE_OCTET_STRING:
    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
    case ADSTYPE_PROV_SPECIFIC:
        //
        // Call the LDAP free value routine if not DirSyncControl
        // or VLV
        //
        if (pColumn->pszAttrName
            && !_wcsicmp(ADS_VLV_RESPONSE, pColumn->pszAttrName)) {
            //
            // VLV, so free the ADS_VLV and its members
            //
            if (pColumn->pADsValues && pColumn->pADsValues[0].ProviderSpecific.lpValue) {

                if (((PADS_VLV)(pColumn->pADsValues[0].ProviderSpecific.lpValue))->lpContextID) {
                    FreeADsMem(((PADS_VLV)(pColumn->pADsValues[0].ProviderSpecific.lpValue))->lpContextID);
                }

                FreeADsMem(pColumn->pADsValues[0].ProviderSpecific.lpValue);
            }
            
        }
        else if (pColumn->pszAttrName
            && _wcsicmp(ADS_DIRSYNC_COOKIE, pColumn->pszAttrName)
            ) {

            LdapValueFreeLen((struct berval **)pColumn->hReserved);
            pColumn->hReserved = NULL;
        } else {
            //
            // DirSyncControlStruct - so we free the ADsValue.
            //
            if (pColumn->pADsValues[0].ProviderSpecific.lpValue) {
                FreeADsMem(pColumn->pADsValues[0].ProviderSpecific.lpValue);
            }
        }

        break;

    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_DN_STRING:
    case ADSTYPE_CASE_EXACT_STRING:
        if(!pColumn->hReserved) {
            //
            // The column just contains a DN.
            //
            FreeADsMem(pColumn->pADsValues[0].CaseIgnoreString);
        }
        else {
            LdapValueFree( (WCHAR **)pColumn->hReserved);
            pColumn->hReserved = NULL;
        }
        break;

    case ADSTYPE_INTEGER:
    case ADSTYPE_LARGE_INTEGER:
    case ADSTYPE_BOOLEAN:
    case ADSTYPE_UTC_TIME:
        // Nothing to free
        break;

    case ADSTYPE_DN_WITH_BINARY:
    case ADSTYPE_DN_WITH_STRING:

        AdsTypeFreeAdsObjects(
            pColumn->pADsValues,
            pColumn->dwNumValues
            );

        //
        // Do not want to free this twice
        //
        pColumn->pADsValues = NULL;
        break;

    case ADSTYPE_INVALID:
    	//
    	// This comes from the result of search by setting _SearchPref._fAttrsOnly
    	// nothing need to be done
    	//
    	break;

    default:
        // unknown type;
        hr = E_ADS_BAD_PARAMETER;
    }

    if (pColumn->pszAttrName)
        FreeADsStr(pColumn->pszAttrName);

    if (pColumn->pADsValues) {
        FreeADsMem(pColumn->pADsValues);
        pColumn->pADsValues = NULL;
    }

    RRETURN(hr);
}

BOOL
IsValidPrefValue(
    ADS_SEARCHPREF_INFO SearchPref
    )
{

    switch(SearchPref.dwSearchPref) {

    case ADS_SEARCHPREF_ASYNCHRONOUS:
    case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
    case ADS_SEARCHPREF_CACHE_RESULTS:
    case ADS_SEARCHPREF_TOMBSTONE:
        if (SearchPref.vValue.dwType != ADSTYPE_BOOLEAN)
            return FALSE;
        break;

    case ADS_SEARCHPREF_DEREF_ALIASES:
    case ADS_SEARCHPREF_SIZE_LIMIT:
    case ADS_SEARCHPREF_TIME_LIMIT:
    case ADS_SEARCHPREF_SEARCH_SCOPE:
    case ADS_SEARCHPREF_TIMEOUT:
    case ADS_SEARCHPREF_PAGESIZE:
    case ADS_SEARCHPREF_PAGED_TIME_LIMIT:
    case ADS_SEARCHPREF_CHASE_REFERRALS:
        if (SearchPref.vValue.dwType != ADSTYPE_INTEGER)
            return FALSE;
        break;

    case ADS_SEARCHPREF_SORT_ON:
        if (SearchPref.vValue.dwType != ADSTYPE_PROV_SPECIFIC)
            return FALSE;
        break;

    case ADS_SEARCHPREF_DIRSYNC:
        if (SearchPref.vValue.dwType != ADSTYPE_PROV_SPECIFIC)
            return FALSE;
        break;

    case ADS_SEARCHPREF_VLV:
        if (SearchPref.vValue.dwType != ADSTYPE_PROV_SPECIFIC)
            return FALSE;
        break;

    case ADS_SEARCHPREF_ATTRIBUTE_QUERY:
        if (SearchPref.vValue.dwType != ADSTYPE_CASE_IGNORE_STRING)
            return FALSE;
        break;

    case ADS_SEARCHPREF_SECURITY_MASK:
        if (SearchPref.vValue.dwType != ADSTYPE_INTEGER)
            return FALSE;
        break;
        
    case ADS_SEARCHPREF_DIRSYNC_FLAG:
        if(SearchPref.vValue.dwType != ADSTYPE_INTEGER)
            return FALSE;
        break;

    case ADS_SEARCHPREF_EXTENDED_DN:
        if(SearchPref.vValue.dwType != ADSTYPE_INTEGER)
            return FALSE;
        break;
        

    default:
        return FALSE;
    }

    return TRUE;
}


HRESULT
LdapValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    VOID        **ppValue,
    ADS_SEARCH_COLUMN * pColumn
    )
{
    HRESULT hr = S_OK;
    DWORD i, j;

    if(!pszColumnName || !pColumn)
        RRETURN(E_ADS_BAD_PARAMETER);

    pColumn->hReserved = (HANDLE) ppValue;
    pColumn->dwNumValues = dwValues;

    if (dwValues < 1) {
        //
        // Need to set the ADsValue struct to NULL as it does
        // not make sense to return any ADsValues
        //
        pColumn->pADsValues = NULL;

    } else {

        pColumn->pADsValues = (PADSVALUE) AllocADsMem(
                                          sizeof(ADSVALUE) * dwValues
                                          );
        if (!pColumn->pADsValues)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pColumn->dwADsType = MapLDAPTypeToADSType(dwSyntaxId);

    switch (dwSyntaxId) {
    case LDAPTYPE_BITSTRING:
    case LDAPTYPE_PRINTABLESTRING:
    case LDAPTYPE_DIRECTORYSTRING:
    case LDAPTYPE_COUNTRYSTRING:
    case LDAPTYPE_DN:
    case LDAPTYPE_NUMERICSTRING:
    case LDAPTYPE_IA5STRING:
    case LDAPTYPE_CASEIGNORESTRING:
    case LDAPTYPE_OID:
    case LDAPTYPE_TELEPHONENUMBER:
    case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
    case LDAPTYPE_OBJECTCLASSDESCRIPTION:
    case LDAPTYPE_DELIVERYMETHOD:
    case LDAPTYPE_ENHANCEDGUIDE:
    case LDAPTYPE_FACSIMILETELEPHONENUMBER:
    case LDAPTYPE_GUIDE:
    case LDAPTYPE_NAMEANDOPTIONALUID:
    case LDAPTYPE_POSTALADDRESS:
    case LDAPTYPE_PRESENTATIONADDRESS:
    case LDAPTYPE_TELEXNUMBER:
    case LDAPTYPE_DSAQUALITYSYNTAX:
    case LDAPTYPE_DATAQUALITYSYNTAX:
    case LDAPTYPE_MAILPREFERENCE:
    case LDAPTYPE_OTHERMAILBOX:
    case LDAPTYPE_ACCESSPOINTDN:
    case LDAPTYPE_ORNAME:
    case LDAPTYPE_ORADDRESS:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].CaseIgnoreString = (LPWSTR) ppValue[i];
        }
        break;

    case LDAPTYPE_CASEEXACTSTRING:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].CaseExactString = (LPWSTR) ppValue[i];
        }
        break;

    case LDAPTYPE_UTCTIME:
        for (i=0; i < dwValues; i++) {
            SYSTEMTIME st;
            hr = UTCTimeStringToUTCTime((LPWSTR)ppValue[i],
                                        &st);
            BAIL_ON_FAILURE(hr);
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].UTCTime = st;
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;

    case LDAPTYPE_GENERALIZEDTIME:
        for (i=0; i < dwValues; i++) {
            SYSTEMTIME st;
            hr = GenTimeStringToUTCTime((LPWSTR)ppValue[i],
                                         &st);
            BAIL_ON_FAILURE(hr);
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].UTCTime = st;
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;

    case LDAPTYPE_CERTIFICATE:
    case LDAPTYPE_CERTIFICATELIST:
    case LDAPTYPE_CERTIFICATEPAIR:
    case LDAPTYPE_PASSWORD:
    case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
    case LDAPTYPE_AUDIO:
    case LDAPTYPE_JPEG:
    case LDAPTYPE_FAX:
    case LDAPTYPE_OCTETSTRING:
    case LDAPTYPE_SECURITY_DESCRIPTOR:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].OctetString.dwLength = ((struct berval **)ppValue)[i]->bv_len;
            pColumn->pADsValues[i].OctetString.lpValue = (LPBYTE)
                                        ((struct berval **) ppValue)[i]->bv_val;
        }
        break;

    case LDAPTYPE_BOOLEAN:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            if ( _wcsicmp( (WCHAR *) ppValue[i], L"TRUE") == 0 ) {
                pColumn->pADsValues[i].Boolean = TRUE;
            }
            else if ( _wcsicmp( (WCHAR *) ppValue[i], L"FALSE") == 0 ) {
                pColumn->pADsValues[i].Boolean = FALSE;
            }
            else {
                BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
            }
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;

    case LDAPTYPE_INTEGER:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].Integer = _wtol((WCHAR *) ppValue[i]);
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;

    case LDAPTYPE_INTEGER8:

        for (i=0; i < dwValues; i++) {

            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            swscanf ((WCHAR *) ppValue[i], L"%I64d", &pColumn->pADsValues[i].LargeInteger);

        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;


    case LDAPTYPE_DNWITHBINARY:

        for (i=0; i < dwValues; i++) {
            hr = LdapDNWithBinToAdsTypeHelper(
                     (LPWSTR) ppValue[i],
                     &pColumn->pADsValues[i]
                     );
            BAIL_ON_FAILURE(hr);
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;


    case LDAPTYPE_DNWITHSTRING:

        for (i=0; i < dwValues; i++) {
            hr = LdapDNWithStrToAdsTypeHelper(
                     (LPWSTR) ppValue[i],
                     &pColumn->pADsValues[i]
                     );
            BAIL_ON_FAILURE(hr);
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;


    default:
        pColumn->dwADsType = ADSTYPE_PROV_SPECIFIC;
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = ADSTYPE_PROV_SPECIFIC;
            pColumn->pADsValues[i].ProviderSpecific.dwLength =
                 ((struct berval **)ppValue)[i]->bv_len;
            pColumn->pADsValues[i].ProviderSpecific.lpValue =
                (LPBYTE) ((struct berval **) ppValue)[i]->bv_val;
        }
        break;
    }
    RRETURN(hr);


error:

    if (pColumn->pADsValues) {
        FreeADsMem(pColumn->pADsValues);
        pColumn->pADsValues = NULL;
        pColumn->dwNumValues = 0;
    }

    RRETURN(hr);
}

//
// To add the server controls. The controls will be set internally in the
// handle. Right now, we support sort, dirsync and domain scope controls.
//
HRESULT
AddSearchControls(
   PLDAP_SEARCHINFO phSearchInfo,
   CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    PLDAPSortKey *ppSortKeys = NULL;
    PLDAPControl pSortControl = NULL, *ppServerControls = NULL;
    PLDAPControl pDirSyncControl = NULL;
    PLDAPControl pDomCtrl = NULL;
    PLDAPControl pTombStoneCtrl = NULL;
    PLDAPControl pVLVControl = NULL;
    PLDAPControl pAttribScopedCtrl = NULL;
    PLDAPControl pSecurityDescCtrl = NULL;
    PLDAPControl pExtendedCtrl = NULL;
    PBERVAL pBerVal = NULL;
    DWORD nKeys=0, i=0;
    DWORD dwControls = 0;
    DWORD dwCurControl = 0;
    BOOL fDomainScopeControl = FALSE;
    BOOL fTombStone = FALSE;
    BYTE * pbSecDescValue = NULL;    

    if (phSearchInfo->_SearchPref._pSortKeys) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._fDirSync) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._fTombStone) {
        dwControls++;
        fTombStone = TRUE;
    }

    if (phSearchInfo->_SearchPref._pVLVInfo) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._pAttribScoped) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._fSecurityDescriptorControl) {
        dwControls++;
    }

    if(phSearchInfo->_SearchPref._fExtendedDNControl)
    {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._dwChaseReferrals == LDAP_CHASE_EXTERNAL_REFERRALS
        || phSearchInfo->_SearchPref._dwChaseReferrals == (DWORD)(DWORD_PTR)LDAP_OPT_OFF) {
        //
        // Try and see if we can add the additional ADControl.
        //
        hr = ReadDomScopeSupportedAttr(
                 phSearchInfo->_pszLdapServer,
                 &fDomainScopeControl,
                 Credentials,
                 phSearchInfo->_dwPort
                 );

        if (FAILED(hr)) {
            hr = S_OK;
            fDomainScopeControl = FALSE;
        }
        else if (fDomainScopeControl == TRUE) {
            dwControls++;
        }
    }

    if (!dwControls) {
        RRETURN(S_OK);
    }
    ADsAssert(phSearchInfo);

    if (phSearchInfo->_ServerControls) {
        while (phSearchInfo->_ServerControls[i]) {

            //
            // Free the pre-existing controls in preparation for adding in a new
            // batch.
            //
            // The algorithm is:
            //   If this is the VLV control, free it with LdapControlFree
            //   All other controls are freed with FreeADsMem
            //     The sort & security descriptor controls also have additional
            //     memory associated with them that must be freed here.
            //     (some other controls, like ASQ, extended dn or DirSync, also have additonal
            //      memory that must be freed, but this memory is tracked via
            //      _ldap_searchinfo and the freeing is done when we actually
            //      process adding the new control below)
            //

            //
            // If this is the VLV control, need to free it
            // using LdapControlFree
            //
            if ((phSearchInfo->_ServerControls[i]->ldctl_oid)
                && (wcscmp(
                       phSearchInfo->_ServerControls[i]->ldctl_oid,
                       LDAP_CONTROL_VLVREQUEST_W
                       ) == 0)) {
                       
                    LdapControlFree(phSearchInfo->_ServerControls[i]);
            }
            else {
                //
                // If this is the sort or security descriptor control, we
                // need to free some additional stuff.
                //            
                if ((phSearchInfo->_ServerControls[i]->ldctl_oid)
                && (wcscmp(
                       phSearchInfo->_ServerControls[i]->ldctl_oid,
                       LDAP_SERVER_SORT_OID_W
                       ) == 0)
                ) {
                    //
                    // This is a sort control
                    //
                    if (phSearchInfo->_ServerControls[i]->ldctl_oid) {
                        ldap_memfree(phSearchInfo->_ServerControls[i]->ldctl_oid);
                    }

                    if (phSearchInfo->_ServerControls[i]->ldctl_value.bv_val) {
                        ldap_memfreeA(
                            phSearchInfo->_ServerControls[i]->ldctl_value.bv_val
                            );
                    }
                }
                else if ((phSearchInfo->_ServerControls[i]->ldctl_oid)
                          && (wcscmp(phSearchInfo->_ServerControls[i]->ldctl_oid,
                                     LDAP_SERVER_SD_FLAGS_OID_W) == 0)) {

                    //
                    // This is a security descriptor control
                    //
                    if (phSearchInfo->_ServerControls[i]->ldctl_value.bv_val) {
                        FreeADsMem(phSearchInfo->_ServerControls[i]->ldctl_value.bv_val);
                    }

                }                
                
                // free the control (for any control except VLV, which
                // we already freed above)
                FreeADsMem(phSearchInfo->_ServerControls[i]);
            }
            
            i++;
        }
        FreeADsMem(phSearchInfo->_ServerControls);
        phSearchInfo->_ServerControls = NULL;        
    }

    nKeys = phSearchInfo->_SearchPref._nSortKeys;
    //
    // One more than our dwControls is the number we need.
    //
    ppServerControls = (PLDAPControl *)
        AllocADsMem( sizeof(PLDAPControl) * (dwControls+1) );
    if (!ppServerControls) {
        RRETURN(E_OUTOFMEMORY);
    }


    //
    // Process the VLV control
    //
    if (phSearchInfo->_SearchPref._pVLVInfo) {

        hr = LdapCreateVLVControl(phSearchInfo->_pConnection,
                                  phSearchInfo->_SearchPref._pVLVInfo,
                                  TRUE,
                                  &pVLVControl
            