 == sizeof(hdr));

    // validate header
    if (hdr.m_identifier != x_DBSignature ||
        hdr.m_version != x_DBVersion)
        {
        ft.LogError(VSS_ERROR_BAD_SNAPSHOT_DATABASE, VSSDBG_COORD);
        ft.Throw
            (
            VSSDBG_COORD,
            E_UNEXPECTED,
            L"Contents of the hardware snapshot set database are invalid"
            );
        }

    // obtain number of snapshots from the header
    DWORD cSnapshots = hdr.m_NumberOfSnapshotSets;
    while(cSnapshots-- != 0)
        {
        VSS_SNAPSHOT_SET_HDR sethdr;

        // read snapshot set header
        if (!ReadFile(h, &sethdr, sizeof(sethdr), &cbRead, NULL))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"ReadFile");
            }

        BS_ASSERT(cbRead == sizeof(sethdr));

        // allocated variables that need to be freed on failure
        VSS_SNAPSHOT_SET_LIST *pList = NULL;

        // allocate string for XML description
        LPWSTR wsz = new WCHAR[sethdr.m_cwcXML];

        if (wsz == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cant allocate XML string");

        try
            {
            // allocate snapshot set list element
            pList = new VSS_SNAPSHOT_SET_LIST;
            if (pList == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cant allocate snapshot set description");

            // read in XML description
            if (!ReadFile(h, wsz, sethdr.m_cwcXML*sizeof(WCHAR), &cbRead, NULL))
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"ReadFile");
                }

            BS_ASSERT(cbRead == sethdr.m_cwcXML * sizeof(WCHAR));

            // load XML description
            ft.hr = LoadVssSnapshotSetDescription(wsz, &pList->m_pDescription);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"LoadVssSnapshotSetDescription");

            // get snapshot set id
            ft.hr = pList->m_pDescription->GetSnapshotSetId(&pList->m_SnapshotSetId);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotSetId");

            // add snapshot set to list
            pList->m_next = m_pList;
            m_pList = pList;

            // delete XML string
            delete wsz;
            }
        catch(...)
            {
            // delete allocated data
            delete wsz;
            delete pList;

            // rethrow exception
            throw;
            }
        }
    }

// persist list of snapshot sets to
// System Volume Information\HardwareSnapshotDatabase{ProviderId}
// stored on the drive containing the system directory.

void CVssHardwareProviderWrapper::SaveData()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::SaveData");

    // get exclusive access to list
    CVssSafeAutomaticLock lock(m_csList);

    // open handle to alternate database file
    CVssAutoWin32Handle h = OpenAlternateDatabase();

    VSS_HARDWARE_SNAPSHOTS_HDR hdr;
    DWORD cbWritten;

    // setup header
    hdr.m_identifier = x_DBSignature;
    hdr.m_version = x_DBVersion;
    hdr.m_NumberOfSnapshotSets = 0;
    VSS_SNAPSHOT_SET_LIST *pList = m_pList;

    // count number of snapshot sets and put this in the header
    while(pList)
        {
        IVssSnapshotSetDescription *pSnapshotSet = pList->m_pDescription;
        LONG lContext;
        ft.hr = pSnapshotSet->GetContext(&lContext);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");
        if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) != 0)
            hdr.m_NumberOfSnapshotSets += 1;

        pList = pList->m_next;
        }

    // write the header
    if (!WriteFile(h, &hdr, sizeof(hdr), &cbWritten, NULL) ||
        cbWritten != sizeof(hdr))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"WriteFile");
        }


    pList = m_pList;
    // write the individual snapshot sets
    while(pList != NULL)
        {
        LONG lContext;
        ft.hr = pList->m_pDescription->GetContext(&lContext);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

        // don't write information about snapshot set if it is an
        // auto-release snapshot.  All such snapshots should be automatically
        // deleted when the service terminates.
        if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) == 0)
            {
            pList = pList->m_next;
            continue;
            }

        // get XML string
        CComBSTR bstrXML;
        ft.hr = pList->m_pDescription->SaveAsXML(&bstrXML);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::SaveAsXML");

        VSS_SNAPSHOT_SET_HDR sethdr;

        // fill in header with size of string and snapshot set id
        sethdr.m_cwcXML = (UINT) wcslen(bstrXML) + 1;
        sethdr.m_idSnapshotSet = pList->m_SnapshotSetId;

        // write snapshot set header
        if (!WriteFile(h, &sethdr, sizeof(sethdr), &cbWritten, NULL) ||
            cbWritten != sizeof(sethdr))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"WriteFile");
            }

        // write XML snapshot set description
        if (!WriteFile(h, bstrXML, sethdr.m_cwcXML * sizeof(WCHAR), &cbWritten, NULL) ||
            cbWritten != sethdr.m_cwcXML * sizeof(WCHAR))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"WriteFile");
            }

        // move to next snapshot set
        pList = pList->m_next;
        }

    // close handle to file
    h.Close();

    // build name of file
    WCHAR wcsPath[MAX_PATH+64];
    WCHAR wcsAlternatePath[MAX_PATH+64];
    
    GetDatabasePath(false, STRING_CCH_PARAM(wcsPath));
    GetDatabasePath(true, STRING_CCH_PARAM(wcsAlternatePath));
    
    // Try opening the file.  
    // If the file doesn't exist bu the alternate file exists, 
    //  then move hte alternate file into the original one.
    // If both files don't exist, then try creating the original file.
    if (DoesPathExists(wcsPath))
        DeleteDatabase(wcsPath);

    // Copy the alternate database over the original one
    MoveDatabase(wcsAlternatePath, wcsPath);

    }


// load snapshot set database if necessary
// note that if operation fails, then this function will just return.
// data will be logged appropriately but essentially, the saved configuration
// will be lost.
void CVssHardwareProviderWrapper::CheckLoaded()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CheckLoaded");

    if (!m_bLoaded)
        {
        BS_ASSERT(m_pList == NULL);
        try
            {
            LoadData();
            }
        catch(...)
            {
            }

        m_bLoaded = true;
        }
    }



// try saving snapshot set database
// if operation fails, then just return logging an appropriate error.
// save flag will not be cleared in this case
void CVssHardwareProviderWrapper::TrySaveData()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::TrySaveData");

    if (m_bChanged)
        {
        try
            {
            SaveData();
            m_bChanged = false;
            }
        VSS_STANDARD_CATCH(ft)

        if (ft.HrFailed())
            ft.LogError(VSS_ERROR_CANNOT_SAVE_SNAPSHOT_DATABASE, VSSDBG_COORD << ft.hr);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\lovelace.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Lovelace.cxx

Abstract:

    Definition of CVssQueuedVolume	


    Adi Oltean  [aoltean]  10/20/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     10/20/1999  Created

--*/

#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORLOVLC"
//
////////////////////////////////////////////////////////////////////////


const x_MaxDisplayName = 80;


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolume - constructors, destructors and initialization methods


CVssQueuedVolume::CVssQueuedVolume():
	m_hBeginFlushAndHoldEvent(NULL),
	m_hBeginReleaseWritesEvent(NULL),
	m_hFinishCurrentEvent(NULL),
	m_InstanceID(GUID_NULL),
	m_ulNumberOfVolumesToFlush(0),
	m_usSecondsToHoldFileSystemsTimeout(x_nFileSystemsLovelaceTimeout),
	m_usSecondsToHoldIrpsTimeout(x_nHoldingIRPsLovelaceTimeout),
	m_pwszVolumeName(NULL),
	m_pwszVolumeDisplayName(NULL),
	m_bOpenVolumeHandleSucceeded(false),
	m_bFlushSucceeded(false),
	m_bReleaseSucceeded(false),
    m_hrOpenVolumeHandle(S_OK),
    m_hrFlush(S_OK),
	m_hrRelease(S_OK),
	m_hrOnRun(S_OK)
{
}

	
CVssQueuedVolume::~CVssQueuedVolume()
{
	// Wait for the worker thread to finish, if running.
	// WARNING: FinalReleaseWorkerThreadObject uses virtual methods!
	// Virtual methods in classes derived from CVssQueuedVolume are now inaccessible!
	FinalReleaseWorkerThreadObject();

	// Release the attached strings.
	::VssFreeString(m_pwszVolumeName);
	::VssFreeString(m_pwszVolumeDisplayName);

	// Close the Wait handle passed by Volume Set object.
	if (m_hFinishCurrentEvent)
    	::CloseHandle(m_hFinishCurrentEvent);
}


HRESULT CVssQueuedVolume::Initialize(
	IN	LPWSTR pwszVolumeName,
	IN	LPWSTR pwszVolumeDisplayName
	)
/*++

Routine description:

    Initialize a Queued volume object.

Return codes:

    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssQueuedVolume::Initialize");

	try
	{
		// Copy with the trailing "\\". 
		::VssSafeDuplicateStr(ft, m_pwszVolumeName, pwszVolumeName);

		// Copy the volume displayed name 
		::VssSafeDuplicateStr(ft, m_pwszVolumeDisplayName, pwszVolumeDisplayName);

		// Create the m_hFinishCurrentEvent event as an autoreset event.
		m_hFinishCurrentEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );
		if (m_hFinishCurrentEvent == NULL)
			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");

        // Compute a display name
        WCHAR wszDisplayName[x_MaxDisplayName];
        ft.hr = StringCchPrintfW( STRING_CCH_PARAM(wszDisplayName), L"Lovelace(%s)", m_pwszVolumeDisplayName);
        
        // Replace the backslash with dash (otherwise we cannot create the registry key)
        for (LPWSTR pwszIndex = wszDisplayName; *pwszIndex; pwszIndex++)
            if (*pwszIndex == L'\\')
                *pwszIndex = L'_';
        
        m_diagnose.Initialize(wszDisplayName);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolume - thread-related methods



void CVssQueuedVolume::SetParameters(
	IN	HANDLE hBeginFlushAndHoldEvent,
	IN	HANDLE hBeginReleaseWritesEvent,
	IN	VSS_ID	InstanceID,
	IN	ULONG	ulNumberOfVolumesToFlush
	)
{
	m_hBeginFlushAndHoldEvent = hBeginFlushAndHoldEvent;
	m_hBeginReleaseWritesEvent = hBeginReleaseWritesEvent;
	m_InstanceID = InstanceID;
	m_ulNumberOfVolumesToFlush = ulNumberOfVolumesToFlush;
}


bool CVssQueuedVolume::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnInit" );

    // Raise thread priority to HIGHEST (bug# 685929)
    // (since the process has NORMAL_PRIORITY_CLASS, the combined priority for this thread will be 9)
    BOOL bResult = ::SetThreadPriority(GetThreadHandle(), THREAD_PRIORITY_HIGHEST);
    if (!bResult)
    {
        ft.LogGenericWarning(VSSDBG_COORD, 
            L"::SetThreadPriority(%p, THREAD_PRIORITY_HIGHEST) [0x%08lx]", 
            GetThreadHandle(), GetLastError());
        return false;
    }

	return (m_hBeginFlushAndHoldEvent != NULL)
		&& (m_hBeginReleaseWritesEvent != NULL)
		&& (m_hFinishCurrentEvent != NULL)
		&& (m_InstanceID != GUID_NULL)
		&& (m_ulNumberOfVolumesToFlush != 0)
		&& (m_usSecondsToHoldFileSystemsTimeout != 0)
		&& (m_usSecondsToHoldIrpsTimeout != 0);
}


void CVssQueuedVolume::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnRun" );

	try
	{
		// Open Handles
		OnOpenVolumeHandle();

		// Signal the thread set that the volume handle is opened...
		if (!::SetEvent(m_hFinishCurrentEvent))
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"SetEvent(%p)", m_hFinishCurrentEvent );

		// Wait for Beginning the Flush & Hold event
		DWORD dwResult = ::WaitForSingleObject( m_hBeginFlushAndHoldEvent, x_nOpeningVolumeHandleVssTimeout * 1000 );
		if ((dwResult == WAIT_FAILED) || (dwResult == WAIT_TIMEOUT))
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"WaitForSingleObject(%p,%d) == [0x%08lx]", 
		        m_hFinishCurrentEvent, x_nOpeningVolumeHandleVssTimeout * 1000, GetLastError() );

		// Hold writes
		OnHoldWrites();

		// Signal the thread set that the writes are now hold...
		if (!::SetEvent(m_hFinishCurrentEvent))
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"SetEvent(%p)", m_hFinishCurrentEvent );

		// Wait for the "Release Writes" event
		// TBD: is the timeout value correct ?!
		dwResult = ::WaitForSingleObject( m_hBeginReleaseWritesEvent, x_nHoldingIRPsVssTimeout * 1000 );
		if ((dwResult == WAIT_FAILED) || (dwResult == WAIT_TIMEOUT))
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"WaitForSingleObject(%p,%d) == [0x%08lx]", 
		        m_hFinishCurrentEvent, x_nHoldingIRPsVssTimeout * 1000, GetLastError() );

		// Release writes.
		OnReleaseWrites();
	}
	VSS_STANDARD_CATCH(ft);

    if (ft.HrFailed())
    {
		// Signal the thread set that the volume handle is opened...
		// Just to make sure that the main background thread doesn't wait on failures
		BS_ASSERT(m_hFinishCurrentEvent != NULL);
		::SetEvent(m_hFinishCurrentEvent);
    }

	m_hrOnRun = ft.hr;
}


void CVssQueuedVolume::OnFinish()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnFinish" );

    m_hBeginFlushAndHoldEvent = NULL; // released by the ThreadSet
	m_hBeginReleaseWritesEvent = NULL;	// released by the ThreadSet
	m_InstanceID = GUID_NULL;
	m_ulNumberOfVolumesToFlush = 0;
	m_usSecondsToHoldFileSystemsTimeout = 0;
	m_usSecondsToHoldIrpsTimeout = 0;

	// Mark thread state as finished
	MarkAsFinished();
};


void CVssQueuedVolume::OnTerminate()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnTerminate" );
}


void CVssQueuedVolume::OnOpenVolumeHandle()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnOpenVolumeHandle" );

    m_diagnose.RecordGenericEvent(VSS_IN_OPEN_VOLUME_HANDLE, CVssDiag::VSS_DIAG_ENTER_OPERATION, 0, ft.hr, m_InstanceID);

	try
	{
		BS_ASSERT(m_bOpenVolumeHandleSucceeded == false);
		m_bOpenVolumeHandleSucceeded = false;
		
		// Open the IOCTL channel
		// Eliminate the trailing backslash
		// Throw on error 
		BS_ASSERT(::wcslen(m_pwszVolumeName) == x_nLengthOfVolMgmtVolumeName);
		m_objIChannel.Open(ft, m_pwszVolumeName, true, true);

        BS_ASSERT(ft.hr == S_OK);
		m_bOpenVolumeHandleSucceeded = true;
	}
	VSS_STANDARD_CATCH(ft)

    m_diagnose.RecordGenericEvent(VSS_IN_OPEN_VOLUME_HANDLE, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 0, ft.hr, m_InstanceID);

	m_hrOpenVolumeHandle = ft.hr;
};



void CVssQueuedVolume::OnHoldWrites()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnHoldWrites" );

    m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_FLUSH_AND_HOLD, CVssDiag::VSS_DIAG_ENTER_OPERATION, 0, ft.hr, m_InstanceID);
    
	try
	{
		BS_ASSERT(m_bFlushSucceeded == false);
		m_bFlushSucceeded = false;
		
        if (IsOpenVolumeHandleSucceeded())
        {
            // pack the IOCTL [in] arguments
    		m_objIChannel.Pack(ft, m_InstanceID);
    		m_objIChannel.Pack(ft, m_ulNumberOfVolumesToFlush);
    		m_objIChannel.Pack(ft, m_usSecondsToHoldFileSystemsTimeout);
    		m_objIChannel.Pack(ft, m_usSecondsToHoldIrpsTimeout);

    		// send the IOCTL. Log if an error 
    		m_objIChannel.Call(ft, IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES, true, VSS_ICHANNEL_LOG_LOVELACE_HOLD);

            BS_ASSERT(ft.hr == S_OK);
    		m_bFlushSucceeded = true;
        }
	}
	VSS_STANDARD_CATCH(ft)

    m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_FLUSH_AND_HOLD, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 0, ft.hr, m_InstanceID);

	m_hrFlush = ft.hr;
};



void CVssQueuedVolume::OnReleaseWrites()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnReleaseWrites" );

    m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_RELEASE, CVssDiag::VSS_DIAG_ENTER_OPERATION, 0, ft.hr, m_InstanceID);
    
	try
	{
		BS_ASSERT(m_bReleaseSucceeded == false);
		m_bReleaseSucceeded = false;

		// If the Flush IOCTL was succeeded 
        if (IsFlushSucceeded()) {
            BS_ASSERT(IsOpenVolumeHandleSucceeded());
            
    		// then send the Release IOCTL.
    		m_objIChannel.Call(ft, IOCTL_VOLSNAP_RELEASE_WRITES, true, VSS_ICHANNEL_LOG_LOVELACE_RELEASE);

            BS_ASSERT(ft.hr == S_OK);
    		m_bReleaseSucceeded = true;
        }
	}
	VSS_STANDARD_CATCH(ft)

    m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_RELEASE, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 0, ft.hr, m_InstanceID);
    
	m_hrRelease = ft.hr;
};






/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolumesList


CVssQueuedVolumesList::CVssQueuedVolumesList():
	m_eState(VSS_TS_INITIALIZING),
	m_hBeginFlushAndHoldEvent(NULL),
	m_hBeginReleaseWritesEvent(NULL)
{
    m_diagnose.Initialize(L"Lovelace");
}
	

CVssQueuedVolumesList::~CVssQueuedVolumesList()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::~CVssQueuedVolumesList" );

	try
	{
		// Remove all volumes from the map
		Reset();

		// Release the internal synchronization objects
		if (m_hBeginFlushAndHoldEvent)
			::CloseHandle(m_hBeginFlushAndHoldEvent);
		if (m_hBeginReleaseWritesEvent)
			::CloseHandle(m_hBeginReleaseWritesEvent);
	}
	VSS_STANDARD_CATCH(ft)
};


HRESULT CVssQueuedVolumesList::AddVolume(
	WCHAR* pwszVolumeName,
	WCHAR* pwszVolumeDisplayName
	)
/*++

Routine description:

    Adds a volume to the volume list.

Error codes returned:

    E_UNEXPECTED
        - The thread state is incorrect. No logging is done - programming error.
    VSS_E_OBJECT_ALREADY_EXISTS
        - The volume was already added to the snapshot set.
    VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
        - The maximum number of volumes was reached.
    E_OUTOFMEMORY

    [Initialize() failures]
        E_OUTOFMEMORY
        
--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::AddVolume" );

	try
	{
		// Assert parameters
		BS_ASSERT(pwszVolumeName && pwszVolumeName[0]);
		BS_ASSERT(pwszVolumeDisplayName && pwszVolumeDisplayName[0]);

		// Make sure the volume list object is initialized
		if (m_eState != VSS_TS_INITIALIZING) {
		    BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);
		}

		// Find if the volume was already added
		if (m_VolumesMap.Lookup(pwszVolumeName))
			ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_ALREADY_EXISTS, L"Volume already added");

		// Check if the maximum number of objects was reached
		if (m_VolumesMap.GetSize() >= MAXIMUM_WAIT_OBJECTS)
            ft.Throw( VSSDBG_COORD, VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED,
                      L"The maximum number (%d) of Lovelace threads was reached.",
                      m_VolumesMap.GetSize());

		// Create the queued volume object
		CVssQueuedVolume* pQueuedVol = new CVssQueuedVolume();
		if (pQueuedVol == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Initialize the pQueuedVol object. This method may throw
		ft.hr = pQueuedVol->Initialize(pwszVolumeName, pwszVolumeDisplayName);
		if (ft.HrFailed()) {
			delete pQueuedVol;
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
            		  L"Cannot initialize volume object 0x%08lx", ft.hr);
		}

		// Add the volume object to the map
		// Beware that the volume name is already allocated.
		BS_ASSERT(pQueuedVol->GetVolumeName() != NULL);
		if (!m_VolumesMap.Add(pQueuedVol->GetVolumeName(), pQueuedVol))	{
			delete pQueuedVol;
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
};


HRESULT CVssQueuedVolumesList::RemoveVolume(
	WCHAR* pwszVolumeName
	)
/*++

Routine description:

    Removes a volume to the volume list.

Error codes returned:

    E_UNEXPECTED
        - The thread state is incorrect. No logging is done - programming error.
    VSS_E_OBJECT_NOT_FOUND
        - The volume was not added to the snapshot set.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::RemoveVolume" );

	try
	{
		// Assert parameters
		BS_ASSERT(pwszVolumeName && pwszVolumeName[0]);

		// Make sure the volume list object is initialized
		if (m_eState != VSS_TS_INITIALIZING)
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);

		// Find if the volume was already added
		CVssQueuedVolume* pQueuedVol = m_VolumesMap.Lookup(pwszVolumeName);
		if (pQueuedVol == NULL)
			ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Volume does not exist");

		// Remove the corresponding entry
		BOOL bRemoved = m_VolumesMap.Remove(pwszVolumeName);
		if (!bRemoved) {
			BS_ASSERT(bRemoved);
			ft.Trace( VSSDBG_COORD, L"Error removing the volume entry");
		}

		// Delete the volume object.
		delete pQueuedVol;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
};


void CVssQueuedVolumesList::Reset()
/*++

Routine description:

    Waits for all background threads. Reset the snapshot set.

Thrown errors:

    None.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::Reset" );

    // If the flush faield this must be treated already in the "flush" error case
    if (  (m_eState == VSS_TS_HOLDING)
        ||(m_eState == VSS_TS_FAILED_IN_FLUSH) )
    {
        BS_ASSERT(m_VolumesMap.GetSize() > 0);

	    // Wait for all threads to finish. 
	    // This will signal the m_hBeginReleaseWritesEvent event.
	    // WARNING: Ignore return codes from this call. Trace already done.
	    WaitForFinish();
    }

	// Remove all queued volumes
	for(int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++) {
		CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
		BS_ASSERT(pVol);
		delete pVol;
	}

	// Remove all map entries
	m_VolumesMap.RemoveAll();

    ft.Trace(VSSDBG_COORD, L"Current state %d. Reset to initializing", m_eState);
    m_eState = VSS_TS_INITIALIZING;
}
	

HRESULT CVssQueuedVolumesList::FlushAndHoldAllWrites(
	IN	VSS_ID	SnapshotSetID
	)
/*++

Routine description:

    Creates the background threads.
    Flush and Hold all writes on the background threads.
    Wait until all IOCTLS are performed.

Return codes:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Invalid thread state. Dev error - no entry is put in the event log.
        - Empty volume array. Dev error - no entry is put in the event log.
        - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
    VSS_ERROR_FLUSH_WRITES_TIMEOUT
        - An error occured while flushing the writes from a background thread. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::FlushAndHoldAllWrites" );

	HANDLE* pHandleArray = NULL;

	try
	{
		// Check to see if the state is correct
        if (m_eState != VSS_TS_INITIALIZING) {
            BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);
        }

		// Check we have added some volumes first
		if (m_VolumesMap.GetSize() <= 0) {
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Improper array size.");
		}

		// Create the Begin FlushAndHold Writes event, as a manual reset non-signaled event
		if (m_hBeginFlushAndHoldEvent == NULL) {
    		m_hBeginFlushAndHoldEvent = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    		if (m_hBeginFlushAndHoldEvent == NULL)
    			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
    			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");
		} else
		    ::ResetEvent( m_hBeginFlushAndHoldEvent );

		// Create the Begin Release Writes event, as a manual reset non-signaled event
		if (m_hBeginReleaseWritesEvent == NULL) {
    		m_hBeginReleaseWritesEvent = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    		if (m_hBeginReleaseWritesEvent == NULL)
    			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
    			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");
		} else
		    ::ResetEvent( m_hBeginReleaseWritesEvent );

		// Create the array of handles local to each thread
		pHandleArray = new HANDLE[m_VolumesMap.GetSize()];
		if (pHandleArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Prepares all jobs
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

			// Get the wait handle
			pHandleArray[nIndex] = pVol->GetFinishCurrentEvent();

			// Immediately transfer parameters to the current job
			// Ownership of the wait handle is passed to the Volume Object.
			pVol->SetParameters(
			    m_hBeginFlushAndHoldEvent,
				m_hBeginReleaseWritesEvent,
				SnapshotSetID,
				m_VolumesMap.GetSize()
				);

			// Prepare the job
			ft.hr = pVol->PrepareJob();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job %d [0x%08lx]. ", nIndex, ft.hr);
		}

        // Record that we are about to start opening the volume handles        
        m_diagnose.RecordGenericEvent(VSS_IN_OPEN_VOLUME_HANDLE, CVssDiag::VSS_DIAG_ENTER_OPERATION, 0, 
            ft.hr, SnapshotSetID);

		// Flush and hold writes. All threads will wait for the event to be signaled.
		// This thread will wait until all IOCTLS were sent.

		// Start (i.e. Resume) all threads
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ ) {
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

			// This can happen only because some thread objects were in invalid state...
			ft.hr = pVol->StartJob();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job %d [0x%08lx]. ", nIndex, ft.hr);
		}
        
		// Wait for all threads to open the volumes.
		DWORD dwReturn = ::WaitForMultipleObjects( m_VolumesMap.GetSize(),
				pHandleArray, TRUE, x_nFlushVssTimeout * 1000);
        ft.InterpretWaitForMultipleObjects(dwReturn);

        // Record that finished the attempt to open the volume handles        
        m_diagnose.RecordGenericEvent(VSS_IN_OPEN_VOLUME_HANDLE, CVssDiag::VSS_DIAG_LEAVE_OPERATION, dwReturn, 
            ft.hr, SnapshotSetID);

		if ((dwReturn == WAIT_FAILED) || (dwReturn == WAIT_TIMEOUT))
			ft.TranslateGenericError( VSSDBG_COORD, 
			    ft.hr, L"WaitForMultipleObjects(%d,%p,1,%d) == 0x%08lx", 
			    m_VolumesMap.GetSize(),pHandleArray, x_nFlushVssTimeout * 1000, dwReturn);

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);
            BS_ASSERT(pVol->GetFlushError() == S_OK);
            BS_ASSERT(pVol->GetReleaseError() == S_OK);

            // Check if open handles succeeded.
			if (!pVol->IsOpenVolumeHandleSucceeded()) {
                if (pVol->GetOpenVolumeHandleError() == E_OUTOFMEMORY)
                    ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx,0x%08lx]",
                        pVol->GetOpenVolumeHandleError(), 
                        pVol->GetFlushError(), 
                        pVol->GetReleaseError(), 
                        pVol->GetOnRunError());
			    
			    ft.LogError(VSS_ERROR_FLUSH_WRITES_TIMEOUT, 
			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
			            << pVol->GetOpenVolumeHandleError() 
			            << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
				ft.Throw( VSSDBG_COORD, VSS_E_FLUSH_WRITES_TIMEOUT,
						  L"Lovelace failed to hold writes at volume %d - '%s'",
						  nIndex, pVol->GetVolumeDisplayName() );
			}
		}

        // Record that we are about to start sending the Flush&Hold IOCTL
        m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_FLUSH_AND_HOLD, CVssDiag::VSS_DIAG_ENTER_OPERATION, 0, 
            ft.hr, SnapshotSetID);

		// Release all blocked threads by signaling the m_hBeginFlushAndHoldEvent event.
		BS_ASSERT(m_hBeginFlushAndHoldEvent != NULL);
		if (!::SetEvent(m_hBeginFlushAndHoldEvent))
			ft.TranslateGenericError( VSSDBG_COORD, 
			    HRESULT_FROM_WIN32(GetLastError()), 
			    L"SetEvent(%p)", m_hBeginReleaseWritesEvent);

		// Wait for all threads to send the FlushAndHold IOCTLS.
		dwReturn = ::WaitForMultipleObjects( m_VolumesMap.GetSize(),
				pHandleArray, TRUE, x_nFlushVssTimeout * 1000);
        ft.InterpretWaitForMultipleObjects(dwReturn);

        // Record that finished the attempt to send the Flush&Hold IOCTL
        m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_FLUSH_AND_HOLD, CVssDiag::VSS_DIAG_LEAVE_OPERATION, dwReturn, 
            ft.hr, SnapshotSetID);
        
		if ((dwReturn == WAIT_FAILED) || (dwReturn == WAIT_TIMEOUT))
			ft.TranslateGenericError( VSSDBG_COORD, 
			    ft.hr, L"WaitForMultipleObjects(%d,%p,1,%d) == 0x%08lx", 
			    m_VolumesMap.GetSize(),pHandleArray, x_nFlushVssTimeout * 1000, dwReturn);

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);
            BS_ASSERT(pVol->IsOpenVolumeHandleSucceeded());
            BS_ASSERT(pVol->GetReleaseError() == S_OK);

            // Check if Flush succeeded.
			if (!pVol->IsFlushSucceeded()) {
                if ((pVol->GetOpenVolumeHandleError() == E_OUTOFMEMORY) ||
                    (pVol->GetFlushError() == E_OUTOFMEMORY) ||
                    (pVol->GetOnRunError() == E_OUTOFMEMORY))
                    ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx,0x%08lx]",
                        pVol->GetOpenVolumeHandleError(), 
                        pVol->GetFlushError(), 
                        pVol->GetReleaseError(), 
                        pVol->GetOnRunError());

			    ft.LogError(VSS_ERROR_FLUSH_WRITES_TIMEOUT, 
			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
			            << pVol->GetOpenVolumeHandleError() 
			            << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
				ft.Throw( VSSDBG_COORD, VSS_E_FLUSH_WRITES_TIMEOUT,
						  L"Lovelace failed to hold writes at volume %d - '%s'",
						  nIndex, pVol->GetVolumeDisplayName() );
			}
		}

		m_eState = VSS_TS_HOLDING;
	}
	VSS_STANDARD_CATCH(ft)

	// Deallocate the handle array
	delete[] pHandleArray;

	// Check for errors
    if (ft.HrFailed())
		m_eState = VSS_TS_FAILED_IN_FLUSH;

    return ft.hr;
};


HRESULT CVssQueuedVolumesList::ReleaseAllWrites()
/*++

Routine description:

    Signals all the background threads to release the writes.
    Wait until all IOCTLS are performed.

Return codes:

    [WaitForFinish() failures]
        E_UNEXPECTED
            - The list of volumes is empty. Dev error - nothing is logged on.
            - SetEvent failed. An entry is put in the error log.
            - WaitForMultipleObjects failed. An entry is put in the error log.
        E_OUTOFMEMORY
            - Cannot create the array of handles.
            - One of the background threads failed with E_OUTOFMEMORY
        VSS_E_HOLD_WRITES_TIMEOUT
            - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::ReleaseAllWrites" );

    try
    {
        // If the flush faield this must be treated already in the "flush" error case
	    if (  (m_eState == VSS_TS_HOLDING)
	        ||(m_eState == VSS_TS_FAILED_IN_FLUSH) )
        {
            BS_ASSERT(m_VolumesMap.GetSize() > 0);
    	    // Wait for all threads to finish.
    	    // This will signal the m_hBeginReleaseWritesEvent event.
    	    ft.hr = WaitForFinish();
    	    if (ft.HrFailed())
    		    ft.Throw( VSSDBG_COORD, ft.hr, L"Error waiting threads for finishing");
	    }
    }
    VSS_STANDARD_CATCH(ft)

	// Check for errors
    if (ft.HrFailed())
		m_eState = VSS_TS_FAILED_IN_RELEASE;

    return ft.hr;
};


HRESULT CVssQueuedVolumesList::WaitForFinish()
/*++

Routine description:

    Wait until all Lovelace threads are finished.

Thrown errors:

    E_UNEXPECTED
        - The list of volumes is empty. Dev error - nothing is logged on.
        - SetEvent failed. An entry is put in the error log.
        - WaitForMultipleObjects failed. An entry is put in the error log.
    E_OUTOFMEMORY
        - Cannot create the array of handles.
        - One of the background threads failed with E_OUTOFMEMORY
    VSS_E_HOLD_WRITES_TIMEOUT
        - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::WaitForFinish" );

	// Table of handles used for synchronization
	HANDLE* pHandleArray = NULL;

	try
	{
        // Record that we are about to start sending the Release IOCTL
        m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_RELEASE, CVssDiag::VSS_DIAG_ENTER_OPERATION, 0, ft.hr);

		// Release all blocked threads by signaling the m_hBeginFlushAndHoldEvent (if 
		// not already signaled) and the m_hBeginReleaseWritesEvent event.
		if(m_hBeginFlushAndHoldEvent != NULL) {
			if (!::SetEvent(m_hBeginFlushAndHoldEvent))
				ft.TranslateGenericError( VSSDBG_COORD, 
				    HRESULT_FROM_WIN32(GetLastError()), 
				    L"SetEvent(%p)", m_hBeginFlushAndHoldEvent);
		}

		if(m_hBeginReleaseWritesEvent != NULL) {
			if (!::SetEvent(m_hBeginReleaseWritesEvent))
				ft.TranslateGenericError( VSSDBG_COORD, 
				    HRESULT_FROM_WIN32(GetLastError()), 
				    L"SetEvent(%p)", m_hBeginReleaseWritesEvent);
		}

		// Get the size of the array.
		if (m_VolumesMap.GetSize() <= 0) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Zero array size.");
		}

		// Create the array of handles local to each thread
		pHandleArray = new HANDLE[m_VolumesMap.GetSize()];
		if (pHandleArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Search to find any running threads
		int nThreadHandlesCount = 0;
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);
			
			// Get the thread handle, if it is still running
			// Note: the "prepared" threads will not be in "running" state at this point
			// The only procedure that can fire them up (i.e. StartJob) cannot
			// be called anymore at this point.
			if (pVol->IsStarted()) {
			    HANDLE hThread = pVol->GetThreadHandle();
    			BS_ASSERT(hThread != NULL);
    			pHandleArray[nThreadHandlesCount++] = hThread; // will be closed on job array destruction.
			}
		}

        // If we have threads that we can wait on...
        if (nThreadHandlesCount != 0) {
    		// Wait for all threads to send the Release IOCTLS.
    		DWORD dwReturn = ::WaitForMultipleObjects( nThreadHandlesCount,
    				pHandleArray, TRUE, x_nReleaseVssTimeout * 1000);
            ft.InterpretWaitForMultipleObjects(dwReturn);
            
            // Record that we finished the attempt to send the Release IOCTL
            m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_RELEASE, CVssDiag::VSS_DIAG_LEAVE_OPERATION, dwReturn, 
                ft.hr);
            
            if ((WAIT_FAILED == dwReturn) || (WAIT_TIMEOUT == dwReturn))
				ft.TranslateGenericError( VSSDBG_COORD, ft.hr,
				    L"WaitForMultipleObjects(%d,%p,1,%d) == 0x%08lx", 
				    nThreadHandlesCount,pHandleArray, x_nReleaseVssTimeout * 1000, dwReturn);
        }
        else
            m_diagnose.RecordGenericEvent(VSS_IN_IOCTL_RELEASE, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 0, 
                ft.hr);
            

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

            // Check if Release writers succeeded. 
            if (pVol->IsFlushSucceeded()) {
                BS_ASSERT(pVol->GetFlushError() == S_OK);

                // Check if Release writes succeeded
    			if (!pVol->IsReleaseSucceeded()) {
                    if ((pVol->GetOpenVolumeHandleError() == E_OUTOFMEMORY) ||
                        (pVol->GetFlushError() == E_OUTOFMEMORY) ||
                        (pVol->GetReleaseError() == E_OUTOFMEMORY) ||
                        (pVol->GetOnRunError() == E_OUTOFMEMORY))
                        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx,0x%08lx]",
                            pVol->GetOpenVolumeHandleError(), pVol->GetFlushError(), pVol->GetReleaseError(), pVol->GetOnRunError());
    			    
    			    ft.LogError(VSS_ERROR_HOLD_WRITES_TIMEOUT, 
    			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
    			            << pVol->GetOpenVolumeHandleError() << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
    				ft.Throw( VSSDBG_COORD, VSS_E_HOLD_WRITES_TIMEOUT,
    						  L"Lovelace failed to hold writes at volume %d - '%s'",
    						  nIndex, pVol->GetVolumeDisplayName() );
    			}
            }
		}

		m_eState = VSS_TS_RELEASED;
	}
	VSS_STANDARD_CATCH(ft)

	// Deallocate the handle array
	delete[] pHandleArray;

	return ft.hr;
};


CComBSTR CVssQueuedVolumesList::GetVolumesList() throw(HRESULT)
/*++

Routine description:

    Gets the list of volumes as a BSTR.

Throws:

    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::GetVolumesList" );
	CComBSTR bstrVolumeNamesList;

    BS_ASSERT(m_VolumesMap.GetSize() > 0);

	// Concatenate the list of volume display names
	for (int nIndexTmp = 0; nIndexTmp < m_VolumesMap.GetSize(); nIndexTmp++ ) {
		// Obtain the queued volume object in discussion
		CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndexTmp);
		BS_ASSERT(pVol);

		// Check to see if this is the first item
		if (nIndexTmp == 0) {
			// Put the first volume name
			bstrVolumeNamesList = pVol->GetVolumeName();
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
		} else {
			// Append the semicolon
			bstrVolumeNamesList += x_wszVolumeNamesSeparator;
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
			// Append the next volume name
			bstrVolumeNamesList += pVol->GetVolumeName();
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
		}
	}

	// Return the built list
	return bstrVolumeNamesList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\hardwrp.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module hardwrp.cxx | Implementation of the CVssHWProviderWrapper methods
    @end

Author:

    Brian Berkowitz  [brianb]  04/16/2001

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      04/16/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "setupapi.h"
#include "rpc.h"
#include "cfgmgr32.h"
#include "devguid.h"
#include "resource.h"
#include "vssmsg.h"
#include "vs_inc.hxx"
#include <svc.hxx>


// Generated file from Coord.IDL
#include "vss.h"
#include "vscoordint.h"
#include "vsevent.h"
#include "vdslun.h"
#include "vsprov.h"
#include "vswriter.h"
#include "vsbackup.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "vs_idl.hxx"
#include "hardwrp.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORHWPWC"
//
////////////////////////////////////////////////////////////////////////

// static data members
// first wrapper in list
CVssHardwareProviderWrapper *CVssHardwareProviderWrapper::s_pHardwareWrapperFirst = NULL;

// critical section for wrapper list
CVssSafeCriticalSection CVssHardwareProviderWrapper::s_csHWWrapperList;


// constructor
CVssHardwareProviderWrapper::CVssHardwareProviderWrapper() :
    m_SnapshotSetId(GUID_NULL),
    m_bForceFailure(FALSE),
    m_pList(NULL),
    m_wszOriginalVolumeName(NULL),
    m_rgLunInfoProvider(NULL),
    m_rgwszDevicesProvider(NULL),
    m_cLunInfoProvider(0),
    m_pExtents(NULL),
    m_ProviderId(GUID_NULL),
    m_lRef(0),
    m_eState(VSS_SS_UNKNOWN),
    m_bOnGlobalList(false),
    m_rgdwHiddenDrives(NULL),
    m_cdwHiddenDrives(0),
    m_bLoaded(false),
    m_bChanged(false),
    m_pHardwareWrapperNext(NULL),
    m_hevtOverlapped(NULL)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CVssHardwareProviderWrapper");
    }

// destructor
CVssHardwareProviderWrapper::~CVssHardwareProviderWrapper()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::~CVssHardwareProviderWrapper");

    // delete any cached information about volumes
    DeleteCachedInfo();

    // delete overlapped handle
    if (m_hevtOverlapped != NULL)
        CloseHandle(m_hevtOverlapped);

    // try saving the snapshot set list if it hasn't been successfully
    // saved yet
    TrySaveData();

    // close any volume handles kept open for snapshots in progress
    CloseVolumeHandles();

    // free up all created snapshot sets
    while(m_pList)
        {
        VSS_SNAPSHOT_SET_LIST *pList = m_pList;
        m_pList = m_pList->m_next;
        delete pList;
        }

    // delete hidden drives bitmap
    delete m_rgdwHiddenDrives;

    if (m_bOnGlobalList)
        {
        // remove wrapper from global wrapper list

        // first acquire critical section
        CVssSafeAutomaticLock lock(s_csHWWrapperList);
        CVssHardwareProviderWrapper *pWrapperCur = s_pHardwareWrapperFirst;
        if (pWrapperCur == this)
            // wrapper is first one on the list
            s_pHardwareWrapperFirst = m_pHardwareWrapperNext;
        else
            {
            // wrapper is not the first one on the list.  Search For it
            while(TRUE)
                {
                // save current as previous
                CVssHardwareProviderWrapper *pWrapperPrev = pWrapperCur;

                // get next wrapper
                pWrapperCur = pWrapperCur->m_pHardwareWrapperNext;

                // shouldn't be null since the wrapper is on the list
                BS_ASSERT(pWrapperCur != NULL);
                if (pWrapperCur == this)
                    {
                    pWrapperPrev->m_pHardwareWrapperNext = pWrapperCur->m_pHardwareWrapperNext;
                    break;
                    }
                }
            }
        }
    }

// append a wrapper to the global list
void CVssHardwareProviderWrapper::AppendToGlobalList()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::AppendToGlobalList");

    BS_ASSERT(s_csHWWrapperList.IsInitialized());

    // get lock for global list
    CVssSafeAutomaticLock lock(s_csHWWrapperList);

    // make current object first on global list
    m_pHardwareWrapperNext = s_pHardwareWrapperFirst;
    s_pHardwareWrapperFirst = this;
    m_bOnGlobalList = true;
    }

// eliminate all wrappers in order to terminate the service
void CVssHardwareProviderWrapper::Terminate()
    {
    // get lock
    CVssSafeAutomaticLock lock(s_csHWWrapperList);

    // delete all wrappers on the list
    while(s_pHardwareWrapperFirst)
        delete s_pHardwareWrapperFirst;
    }

// initialize the hardware wrapper
void CVssHardwareProviderWrapper::Initialize()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::Initialize");
    if (!m_csList.IsInitialized() || !m_csLunInfo.IsInitialized())
        {
        try
            {
            if (!m_csList.IsInitialized())
                m_csList.Init();

            if (!m_csLunInfo.IsInitialized())
                m_csLunInfo.Init();

            if (!m_csDynDisk.IsInitialized())
                m_csDynDisk.Init();
            }
        catch(...)
            {
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot initialize critical section");
            }
        }
    }




// create a wrapper of the hardware provider supporting the
// IVssSnapshotProvider interface
// Throws:
//      E_OUTOFMEMORY
//      VSS_E_UNEXPECTED_PROVIDER_ERROR,
//      VSS_ERROR_CREATING_PROVIDER_CLASS

IVssSnapshotProvider* CVssHardwareProviderWrapper::CreateInstance
    (
    IN VSS_ID ProviderId,
    IN CLSID ClassId
    ) throw(HRESULT)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CreateInstance");

    // initialize critical section for list if necessary
    if (!s_csHWWrapperList.IsInitialized())
        s_csHWWrapperList.Init();

    CComPtr<CVssHardwareProviderWrapper> pWrapper;

    bool bCreated = false;

    // if wrapper is created, this is the autoptr used to destroy it if we
    // prematurely exit the routine.

        {
        CVssSafeAutomaticLock lock(s_csHWWrapperList);

        // look for wrapper in list of wrappers already created
        CVssHardwareProviderWrapper *pWrapperSearch = s_pHardwareWrapperFirst;

        while(pWrapperSearch != NULL)
            {
            if (pWrapperSearch->m_ProviderId == ProviderId)
                break;

            pWrapperSearch = pWrapperSearch->m_pHardwareWrapperNext;
            }

        if (pWrapperSearch != NULL)
            // reference count incremented
            pWrapper = pWrapperSearch;
        else
            {
            // Ref count becomes 1
            // create new wrapper
            pWrapper = new CVssHardwareProviderWrapper();
            if (pWrapper == NULL)
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

            pWrapper->m_ProviderId = ProviderId;
            pWrapper->Initialize();
            bCreated = true;
            }
        }

    // Create the IVssSoftwareSnapshotProvider interface

    if (pWrapper->m_pHWItf == NULL)
        {
        // necessary create hardware provider
        ft.CoCreateInstanceWithLog(
                VSSDBG_COORD,
                ClassId,
                L"HWPRV",
                CLSCTX_LOCAL_SERVER,
                IID_IVssHardwareSnapshotProvider,
                (IUnknown**)&(pWrapper->m_pHWItf));
        if ( ft.HrFailed() )
            {
            ft.LogError(VSS_ERROR_CREATING_PROVIDER_CLASS, VSSDBG_COORD << ClassId << ft.hr );
            ft.Throw( VSSDBG_COORD, VSS_E_UNEXPECTED_PROVIDER_ERROR, L"CoCreateInstance failed with hr = 0x%08lx", ft.hr);
            }

        BS_ASSERT(pWrapper->m_pHWItf);


        // Query the creation itf.
        ft.hr = pWrapper->m_pHWItf->SafeQI( IVssProviderCreateSnapshotSet, &(pWrapper->m_pCreationItf));
        if (ft.HrFailed())
            ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderCreateSnapshotSet");

        BS_ASSERT(pWrapper->m_pCreationItf);

        // Query the notification itf.
        ft.hr = pWrapper->m_pHWItf->SafeQI( IVssProviderNotifications, &(pWrapper->m_pNotificationItf));
        if (ft.HrSucceeded())
            {
            BS_ASSERT(pWrapper->m_pNotificationItf);
            }
        else if (ft.hr != E_NOINTERFACE)
            {
            BS_ASSERT(false);
            ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderNotifications");
            }
        }

    if (bCreated)
        // append wrapper to the global list
        pWrapper->AppendToGlobalList();

    // create provider instance
    IVssSnapshotProvider *pProvider = CVssHardwareProviderInstance::CreateInstance(pWrapper);
    return pProvider;
    }


/////////////////////////////////////////////////////////////////////////////
// Internal methods
// this method should never be called
STDMETHODIMP CVssHardwareProviderWrapper::QueryInternalInterface
    (
    IN  REFIID iid,
    OUT void** pp
    )
    {
    UNREFERENCED_PARAMETER(iid);

    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::QueryInternalInterface");

    BS_ASSERT(pp);
    *pp = NULL;

    BS_ASSERT(FALSE);
    return E_NOINTERFACE;
    }

/////////////////////////////////////////////////////////////////////////////
// IUnknown

// supports coercing the wrapper to IUnknown
STDMETHODIMP CVssHardwareProviderWrapper::QueryInterface(REFIID iid, void** pp)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::QueryInterface");

    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
    return S_OK;
    }

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssHardwareProviderWrapper::AddRef()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::AddRef");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper AddRef(%p) %lu --> %lu", this, m_lRef, m_lRef+1);

    return ::InterlockedIncrement(&m_lRef);
    }

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssHardwareProviderWrapper::Release()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::Release");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper Release(%p) %lu --> %lu", this, m_lRef, m_lRef-1);

    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!

    return l;
    }

// wrapper for provider BeginPrepareSnapshot call.  Uses
// lun information cached during AreLunsSupported call.
// this routine will return the following errors:
//
//      E_OUTOFMEMORY: if an out of resource condition occurs
//
//      E_INVALIDARG: one of the arguments to the provider is invalid.
//
//      VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER: if the specific luns are
//          not capable of being snapshotted.
//
//      VSS_E_PROVIDER_VETO: for all other errors
//
STDMETHODIMP CVssHardwareProviderWrapper::BeginPrepareSnapshot
    (
    IN LONG lContext,
    IN VSS_ID SnapshotSetId,
    IN VSS_ID SnapshotId,
    IN VSS_PWSZ wszVolumeName
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BeginPrepareSnapshot");

    CVssSafeAutomaticLock lock(m_csLunInfo);

    BS_ASSERT(wszVolumeName != NULL);

    // temporary computer name string
    LPWSTR wszComputerName = NULL;
    bool bBeginPrepareSucceeded = false;
    try
        {
        if (m_bForceFailure)
            ft.Throw(VSSDBG_COORD, VSS_E_PROVIDER_VETO, L"forcing failure due to previous BeginPrepare failure");

        // call IsVolumeSupported in case there was an intervening
        // call to IsVolumeSupported outside of snapshot creation
        if (wcscmp(wszVolumeName, m_wszOriginalVolumeName) != 0)
            {
            BOOL bIsSupported;
            ft.hr = IsVolumeSupported(lContext, wszVolumeName, &bIsSupported);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IsVolumeSupported");

            if (!bIsSupported)
                // this is really unexpected since the provider said it
                // supported the volume previously.  May want to log something
                ft.Throw(VSSDBG_COORD, VSS_E_PROVIDER_VETO, L"volume is not supported");
                }


        // make sure persistent snapshot set data is loaded.  We wan't to
        // make sure that we don't add anything to the snapshot set list
        // without first loading it from the database.
        CheckLoaded();

        BS_ASSERT(m_SnapshotSetId == GUID_NULL ||
                  m_SnapshotSetId == SnapshotSetId);

        // save snapshot set id
        m_SnapshotSetId = SnapshotSetId;

        // save away state
        m_eState = VSS_SS_PROCESSING_PREPARE;

        // call provider BeginPrepareSnapshot with cached lun information
        ft.hr = m_pHWItf->BeginPrepareSnapshot
                    (
                    SnapshotSetId,
                    SnapshotId,
                    lContext,
                    (LONG) m_cLunInfoProvider,
                    m_rgwszDevicesProvider,
                    m_rgLunInfoProvider
                    );

        // Check if there was a problem with the arguments
        if (ft.hr == E_INVALIDARG)
            ft.Throw
                (
                VSSDBG_COORD,
                E_INVALIDARG,
                L"Invalid arguments to BeginPrepareSnapshot for provider " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(m_ProviderId)
                );

        // check for luns not supported by provider
        if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER)
            {
            BS_ASSERT( m_ProviderId != GUID_NULL );
            ft.Throw
                (VSSDBG_COORD,
                VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER,
                L"Volume %s not supported by provider " WSTR_GUID_FMT,
                wszVolumeName,
                GUID_PRINTF_ARG(m_ProviderId)
                );
            }

        // check for provider imposed limit on number of snapshots
        if (ft.hr == VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED)
            ft.Throw
                (
                VSSDBG_COORD,
                VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED,
                L"Volume %s has too many snapshots" WSTR_GUID_FMT,
                wszVolumeName,
                GUID_PRINTF_ARG(m_ProviderId)
                );

        // translate and log all other provider errors
        if (ft.HrFailed())
            ft.TranslateProviderError
                (
                VSSDBG_COORD,
                m_ProviderId,
                L"BeginPrepareSnapshot(" WSTR_GUID_FMT L",%s)",
                GUID_PRINTF_ARG(m_ProviderId),
                wszVolumeName
                );

        // indicate that begin prepare succeeded
        bBeginPrepareSucceeded = false;

        // allocate snapshot set description object if there is not yet one
        // allocated for this snapshot set.
        if (m_pSnapshotSetDescription == NULL)
            {
            ft.hr = CreateVssSnapshotSetDescription
                        (
                        m_SnapshotSetId,
                        lContext,
                        &m_pSnapshotSetDescription
                        );

            ft.CheckForErrorInternal(VSSDBG_COORD, L"CreateVssSnapshotSetDescription");
            }

        BS_ASSERT(m_pSnapshotSetDescription);

        // create snapshot description object for this volume
        ft.hr = m_pSnapshotSetDescription->AddSnapshotDescription(SnapshotId, m_ProviderId);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::AddSnapshotDescription");


        // obtain snapshot description just created
        CComPtr<IVssSnapshotDescription> pSnapshotDescription;
        ft.hr = m_pSnapshotSetDescription->FindSnapshotDescription(SnapshotId, &pSnapshotDescription);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnaphotSetDescription::FindSnapshotDescription");

        BS_ASSERT(pSnapshotDescription);

        wszComputerName = GetLocalComputerName();
        // set originating machine and computer name
        ft.hr = pSnapshotDescription->SetOrigin(wszComputerName, wszVolumeName);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetOrigin");

        // set whether original volume is dynamic
        ft.hr = pSnapshotDescription->SetIsDynamicVolume(m_bVolumeIsDynamicProvider);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetIsDynamicVolume");

        // set service machine
        ft.hr = pSnapshotDescription->SetServiceMachine(wszComputerName);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetServiceMachine");

        // set attributes.  Will be the same as the context with the additional
        // indication that the snapshot is surfaced by a hardware provider
        ft.hr = pSnapshotDescription->SetAttributes(lContext | VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetAttributes");

        // add a mapping for each lun
        for(UINT iLun = 0; iLun < m_cLunInfoProvider; iLun++)
            {
            ft.hr = pSnapshotDescription->AddLunMapping();
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::AddLunMapping");
            }

        // number of extents
        UINT cExtents = m_pExtents->NumberOfDiskExtents;

        // first extent and disk
        DISK_EXTENT *pExtent = m_pExtents->Extents;

        // just past last extent
        DISK_EXTENT *pExtentMax = pExtent + cExtents;

        for(UINT iLun = 0; iLun < m_cLunInfoProvider; iLun++)
            {
            CComPtr<IVssLunMapping> pLunMapping;

            ULONG PrevDiskNo = pExtent->DiskNumber;

            ft.hr = pSnapshotDescription->GetLunMapping(iLun, &pLunMapping);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetLunMapping");

            ft.hr = pLunMapping->SetSourceDevice(m_rgwszDevicesProvider[iLun]);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunMapping::SetSourceDevice");

            // add extents for the current disk
            for (; pExtent < pExtentMax && pExtent->DiskNumber == PrevDiskNo; pExtent++)
                {
                ft.hr = pLunMapping->AddDiskExtent
                            (
                            pExtent->StartingOffset.QuadPart,
                            pExtent->ExtentLength.QuadPart
                            );

                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunMapping::AddDiskExtent");
                }
            }

        // save all lun information
        SaveLunInformation
            (
            pSnapshotDescription,
            false,
            m_rgLunInfoProvider,
            m_cLunInfoProvider
            );

        // we are now in the process of preparing the snapshot
        m_eState = VSS_SS_PREPARING;
        }
    VSS_STANDARD_CATCH(ft)

    DeleteCachedInfo();

    // delete temporary computer name
    delete wszComputerName;

    // map error so that no extra event logging is done
    if (ft.HrFailed())
        {
        // if provider BeginPrepare succeeded but we failed after
        // that then we must force failure of all subsequent BeginPrepare
        // and also of DoSnapshotSet in order to cause AbortSnapshots to
        // get called.  The key thing is that we have caused a mirror to
        // get created but we have no way of using it or freeing it up other
        // than causing the snapshot set creation to be aborted.  Note
        // that this should be a pretty rare case since the only failures
        // that can occur after BeginPrepareSnapshot succeeds are out of
        // memory cases and typically at that point, everything will start
        // to fail anyway
        if (bBeginPrepareSucceeded)
            m_bForceFailure = TRUE;

        BS_ASSERT(ft.hr == E_OUTOFMEMORY ||
                  ft.hr == E_UNEXPECTED ||
                  ft.hr == E_INVALIDARG ||
                  ft.hr == VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER ||
                  ft.hr == VSS_E_PROVIDER_VETO ||
                  ft.hr == VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED);

        if (ft.hr != E_OUTOFMEMORY &&
            ft.hr != E_INVALIDARG &&
            ft.hr != VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER &&
            ft.hr != VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED)
            ft.hr = VSS_E_PROVIDER_VETO;
        }

    return ft.hr;
    }

// routine called after snapshot is created.  This call GetTargetLuns to
// get the target luns and then persists all the snapshot information into
// the backup components document by using the IVssCoordinatorCallback::CoordSetContent
// method
STDMETHODIMP CVssHardwareProviderWrapper::PostSnapshot
    (
    LONG lContext,
    IN IDispatch *pCallback,
    IN bool *pbCancelled
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::PostSnapshot");

    // array of destination luns
    VDS_LUN_INFORMATION *rgDestLuns = NULL;

    // array of source luns
    VDS_LUN_INFORMATION *rgSourceLuns = NULL;

    // mapping structure used to map snapshot volumes to original volumes
    LUN_MAPPING_STRUCTURE *pMapping = NULL;

    // array of source device names
    PVSS_PWSZ rgwszSourceDevices = NULL;

    UINT cSourceLuns = 0;

    // has GetTargetLuns succeeded?
    BOOL bGetTargetLunsSucceeded = FALSE;
    try
        {
        BS_ASSERT(m_pHWItf);
        BS_ASSERT(m_pSnapshotSetDescription);
        UINT cSnapshots;

        // get count of snapshots in the snapshot set
        ft.hr = m_pSnapshotSetDescription->GetSnapshotCount(&cSnapshots);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

        // loop through the snapshots
        for(UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++)
            {
            CComPtr<IVssSnapshotDescription> pSnapshot;

            // get snapshot description
            ft.hr = m_pSnapshotSetDescription->GetSnapshotDescription(iSnapshot, &pSnapshot);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotDescription");

            // get source lun information for the snapshot
            GetLunInformation
                (
                pSnapshot,
                false,
                &rgwszSourceDevices,
                &rgSourceLuns,
                &cSourceLuns
                );


            rgDestLuns = (VDS_LUN_INFORMATION *) CoTaskMemAlloc(cSourceLuns * sizeof(VDS_LUN_INFORMATION));
            if (rgDestLuns == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"can't allocate destination luns");

            // clear destination luns in case of failure before they
            // are filled in
            memset(rgDestLuns, 0, cSourceLuns * sizeof(VDS_LUN_INFORMATION));

            // call provider to get the corresponding target luns
            ft.hr = m_pHWItf->GetTargetLuns
                (
                cSourceLuns,
                rgwszSourceDevices,
                rgSourceLuns,
                rgDestLuns
                );

            // remap and throw any failures
            if (ft.HrFailed())
                ft.TranslateProviderError
                    (
                    VSSDBG_COORD,
                    m_ProviderId,
                    L"IVssHardwareSnapshotProvider::GetTargetLuns"
                    );

            // indicate that GetTargetLuns succeeded
            bGetTargetLunsSucceeded = TRUE;

            // save destination lun information into the snapshot set description
            SaveLunInformation(pSnapshot, true, rgDestLuns, cSourceLuns);

            // free up surce and destination luns
            FreeLunInfo(rgDestLuns, NULL, cSourceLuns);
            FreeLunInfo(rgSourceLuns, rgwszSourceDevices, cSourceLuns);

            // clear variables so that they are not freed in the
            // case of an exception
            rgSourceLuns = NULL;
            rgwszSourceDevices = NULL;
            rgDestLuns = NULL;
            cSourceLuns = 0;

            // set timestamp for the snapshot
            CVsFileTime timeNow;
            pSnapshot->SetTimestamp(timeNow);
            }


        if ((lContext & VSS_VOLSNAP_ATTR_TRANSPORTABLE) != 0)
            {
            CComBSTR bstrXML;

            BS_ASSERT(pCallback);

            // save snapshot set description as XML string
            ft.hr = m_pSnapshotSetDescription->SaveAsXML(&bstrXML);
            ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::SaveAsXML");

            // get IVssWriterCallback interface from IDispatch passed to us
            // from the requestor process.
            CComPtr<IVssCoordinatorCallback> pCoordCallback;
            ft.hr = pCallback->SafeQI(IVssCoordinatorCallback, &pCoordCallback);
            if (ft.HrFailed())
                {
                // log any failure
                ft.LogError(VSS_ERROR_QI_IVSSWRITERCALLBACK, VSSDBG_COORD << ft.hr);
                ft.Throw
                    (
                    VSSDBG_COORD,
                    E_UNEXPECTED,
                    L"Error querying for IVssWriterCallback interface.  hr = 0x%08lx",
                    ft.hr
                    );
                }

            // special GUID indicating that this is the snapshot service
            // making the callback.
            CComBSTR bstrSnapshotService = idVolumeSnapshotService;
            if (!bstrSnapshotService)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Can't allocate string");

            // add the snapshot set description to the backup components document
            ft.hr = pCoordCallback->CoordSetContent(bstrSnapshotService, 0, NULL, bstrXML);
            ft.CheckForError(VSSDBG_COORD, L"IVssCoordCallback::SetContent");
            }
        else
            {
            // build mapping structure used to match up arriving luns
            // and snapshot volumes.
            BuildLunMappingStructure(m_pSnapshotSetDescription, &pMapping);
            LocateAndExposeVolumes(pMapping, false, pbCancelled);
            WriteDeviceNames
                (
                m_pSnapshotSetDescription,
                pMapping,
                (lContext & VSS_VOLSNAP_ATTR_PERSISTENT) != 0,
                false
                );

            // construct a new snapshot set list element.  We hold onto the snapshot
            // set description in order to answer queries about the snapshot set
            // and also to persist information on service shutdown
            VSS_SNAPSHOT_SET_LIST *pNewElt = new VSS_SNAPSHOT_SET_LIST;
            if (pNewElt == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Couldn't allocate snapshot set list element");

                {
                // append new element to list
                // list is protected by critical section
                CVssSafeAutomaticLock lock(m_csList);

                pNewElt->m_next = m_pList;
                pNewElt->m_pDescription = m_pSnapshotSetDescription;
                m_pSnapshotSetDescription = NULL;
                pNewElt->m_SnapshotSetId = m_SnapshotSetId;
                m_pList = pNewElt;
                if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) != 0)
                    m_bChanged = true;
                }

            TrySaveData();
            }
        }
    VSS_STANDARD_CATCH(ft)

    // free up lun mapping structure if allocated
    DeleteLunMappingStructure(pMapping);

    if (ft.HrFailed())
        {
        if (bGetTargetLunsSucceeded)
            {
            // we have gotten the target luns from the provider but for
            // some reason the snapshot set could not be created.  Free
            // up all destination luns.  Note that we can't pass a device
            // name in this case since the lun may not yet be associated
            // with this machine.  It is up to the provider to have put
            // enough information in the lun info in order to uniquely
            // identify it in this case.
            for(UINT iLun = 0; iLun < cSourceLuns; iLun++)
                m_pHWItf->OnLunEmpty(NULL, &rgDestLuns[iLun]);
            }
        else
            {
            try
                {
                AbortSnapshots(m_SnapshotSetId);
                }
            catch(...)
                {
                }
            }

        // free any source luns we have
        FreeLunInfo(rgSourceLuns, rgwszSourceDevices, cSourceLuns);

        // free any destination luns we have
        FreeLunInfo(rgDestLuns, NULL, cSourceLuns);

        // translate all errors except for out of resources to
        // provider veto in order to prevent extra event logging.
        if (ft.HrFailed() && ft.hr != E_OUTOFMEMORY)
            ft.hr = VSS_E_PROVIDER_VETO;
        }


    // the current snapshot creation process is complete.
    // clear any information about it
    ResetSnapshotSetState();
    return ft.hr;
    }

// build VSS_SNAPSHOT_PROP structure from a snapshot set description and
// snapshot description.
void CVssHardwareProviderWrapper::BuildSnapshotProperties
    (
    IN IVssSnapshotSetDescription *pSnapshotSet,
    IN IVssSnapshotDescription *pSnapshot,
    OUT VSS_SNAPSHOT_PROP *pProp
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BuildSnapshotProperties");

    LONG cSnapshots;
    VSS_ID SnapshotSetId;
    VSS_ID SnapshotId;
    CComBSTR bstrOriginalVolume;
    CComBSTR bstrOriginatingMachine;
    CComBSTR bstrServiceMachine;
    CComBSTR bstrDeviceName;
    CComBSTR bstrExposedName;
    CComBSTR bstrExposedPath;
    LONG lAttributes;
    VSS_TIMESTAMP timestamp;

    // get snapshot set id
    ft.hr = pSnapshotSet->GetSnapshotSetId(&SnapshotSetId);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotSetId");

    // get snapshot context
    ft.hr = pSnapshot->GetAttributes(&lAttributes);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

    // get count of snapshots
    ft.hr = pSnapshotSet->GetOriginalSnapshotCount(&cSnapshots);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

    // get snapshot id
    ft.hr = pSnapshot->GetSnapshotId(&SnapshotId);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetSnapshotId");

    // get snapshot timestamp
    ft.hr = pSnapshot->GetTimestamp(&timestamp);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetTimestamp");

    // get originating machine and original volume name
    ft.hr = pSnapshot->GetOrigin(&bstrOriginatingMachine, &bstrOriginalVolume);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetOrigin");

    // get service machine
    ft.hr = pSnapshot->GetServiceMachine(&bstrServiceMachine);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetServiceMachine");

    // get device name
    ft.hr = pSnapshot->GetDeviceName(&bstrDeviceName);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetDeviceName");

    // get exposed name and path
    ft.hr = pSnapshot->GetExposure(&bstrExposedName, &bstrExposedPath);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetExposure");

    // task allocated strings
    VSS_PWSZ wszDeviceName = NULL;
    VSS_PWSZ wszOriginatingMachine = NULL;
    VSS_PWSZ wszOriginalVolume = NULL;
    VSS_PWSZ wszServiceMachine = NULL;
    VSS_PWSZ wszExposedPath = NULL;
    VSS_PWSZ wszExposedName = NULL;
    try
        {
        VssSafeDuplicateStr(ft, wszDeviceName, bstrDeviceName);
        VssSafeDuplicateStr(ft, wszOriginalVolume, bstrOriginalVolume);
        VssSafeDuplicateStr(ft, wszOriginatingMachine, bstrOriginatingMachine);
        VssSafeDuplicateStr(ft, wszServiceMachine, bstrServiceMachine);
        VssSafeDuplicateStr(ft, wszExposedName, bstrExposedName);
        VssSafeDuplicateStr(ft, wszExposedPath, bstrExposedPath);
        }
    catch(...)
        {
        // free any strings allocated and rethrow exception
        CoTaskMemFree(wszDeviceName);
        CoTaskMemFree(wszOriginatingMachine);
        CoTaskMemFree(wszOriginalVolume);
        CoTaskMemFree(wszServiceMachine);
        CoTaskMemFree(wszExposedName);
        CoTaskMemFree(wszExposedPath);
        throw;
        }


    // copy values into property structure now that no more exceptions
    // can be thrown.
    pProp->m_SnapshotId = SnapshotId;
    pProp->m_SnapshotSetId = SnapshotSetId;
    pProp->m_ProviderId = m_ProviderId;
    pProp->m_lSnapshotsCount = cSnapshots;
    pProp->m_lSnapshotAttributes = lAttributes;
    pProp->m_eStatus = VSS_SS_CREATED;
    pProp->m_pwszSnapshotDeviceObject = wszDeviceName;
    pProp->m_pwszOriginalVolumeName = wszOriginalVolume;
    pProp->m_pwszOriginatingMachine = wszOriginatingMachine;
    pProp->m_pwszServiceMachine = wszServiceMachine;
    pProp->m_pwszExposedName = wszExposedName;
    pProp->m_pwszExposedPath = wszExposedPath;
    pProp->m_tsCreationTimestamp = timestamp;
    }



// determine if a particular snapshot belongs to a snapshot set and if
// so return its properties
bool CVssHardwareProviderWrapper::FindSnapshotProperties
    (
    IN IVssSnapshotSetDescription *pSnapshotSet,
    IN VSS_ID SnapshotId,
    OUT VSS_SNAPSHOT_PROP *pProp
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::FindSnapshotProperties");

    CComPtr<IVssSnapshotDescription> pSnapshot;
    ft.hr = pSnapshotSet->FindSnapshotDescription(SnapshotId, &pSnapshot);
    if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
        return false;

    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::FindSnapshotDescription");

    BuildSnapshotProperties(pSnapshotSet, pSnapshot, pProp);
    return true;
    }

// dummy routine for GetSnapshotProperties that should never
// be called
STDMETHODIMP CVssHardwareProviderWrapper::GetSnapshotProperties
    (
    IN      VSS_ID          SnapshotId,
    OUT     VSS_SNAPSHOT_PROP   *pProp
    )
    {
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(pProp);

    BS_ASSERT(FALSE && "should never get here");
    return E_UNEXPECTED;
    }



// obtain the properties of a specific snapshot
STDMETHODIMP CVssHardwareProviderWrapper::GetSnapshotPropertiesInternal
    (
    IN      LONG            lContext,
    IN      VSS_ID          SnapshotId,
    OUT     VSS_SNAPSHOT_PROP   *pProp
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::GetSnapshotProperties");

    try
        {
        if (pProp == NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"NULL output parameter");

        // clear properties in case of error.
        memset(pProp, 0, sizeof(VSS_SNAPSHOT_PROP));

        CheckLoaded();

        CVssSafeAutomaticLock lock(m_csList);

        // loop through existing snapshot sets
        VSS_SNAPSHOT_SET_LIST *pList = m_pList;
        for (; pList != NULL ; pList = pList->m_next)
            {
            if (!CheckContext(lContext, pList->m_pDescription))
                continue;

            // determine if snapshot belongs to the snapshot set
            if (FindSnapshotProperties
                    (
                    pList->m_pDescription,
                    SnapshotId,
                    pProp
                    ))
                break;
            }

        // if not in any snapshot set, then it doesn't exist
        if (pList == NULL)
            ft.hr = VSS_E_OBJECT_NOT_FOUND;
        }
    VSS_STANDARD_CATCH(ft);

    // remap errors to prevent extra event logging
    if (ft.HrFailed() &&
        ft.hr != E_INVALIDARG &&
        ft.hr != E_OUTOFMEMORY &&
        ft.hr != VSS_E_OBJECT_NOT_FOUND)
        ft.hr = VSS_E_PROVIDER_VETO;

    return ft.hr;
    }

// implement query method.  Only supports querying for all snapshots matching
// a specific context or in any context.
STDMETHODIMP CVssHardwareProviderWrapper::Query
    (
    IN      LONG            lContext,
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::Query");

    try
        {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        ft.Trace( VSSDBG_COORD, L"Parameters: QueriedObjectId = " WSTR_GUID_FMT
                  L"eQueriedObjectType = %d. eReturnedObjectsType = %d, ppEnum = %p",
                  GUID_PRINTF_ARG( QueriedObjectId ),
                  eQueriedObjectType,
                  eReturnedObjectsType,
                  ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");

        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");

        if (eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");

        BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
        // The only purpose of this is to use a smart ptr to destroy correctly the array on error.
        // Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        CheckLoaded();

        // Get the list of snapshots in the give array
        EnumerateSnapshots(lContext, pArray);

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_COORD,
                E_OUTOFMEMORY,
                L"Cannot create enumerator instance. [0x%08lx]",
                ft.hr
                );

        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
        // Now pEnumObject's reference count becomes 1 (because of the smart pointer).
        // So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
        // The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
        ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed())
            {
            BS_ASSERT(false); // dev error
            ft.Throw
                (
                VSSDBG_COORD,
                E_UNEXPECTED,
                L"Cannot initialize enumerator instance. [0x%08lx]",
                ft.hr
                );
            }

        // Initialize the enumerator object.
        // The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if (ft.HrFailed())
            {
            BS_ASSERT(false); // dev error
            ft.Throw
                (
                VSSDBG_COORD,
                E_UNEXPECTED,
                L"Error querying the IVssEnumObject interface. hr = 0x%08lx",
                ft.hr
                );
            }

        BS_ASSERT(*ppEnum);

        BS_ASSERT( !ft.HrFailed() );
        ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
        }
    VSS_STANDARD_CATCH(ft)

    // remap errors to prevent extra event logging
    if (ft.HrFailed() && ft.hr != E_OUTOFMEMORY)
        ft.hr = VSS_E_PROVIDER_VETO;

    return ft.hr;
    }

// determine if a snapshot exists on a volume.  It is assumed that the
// upper level software has converted the volume name to \\?\Volume{GUID}
// prior to making this call.
STDMETHODIMP CVssHardwareProviderWrapper::IsVolumeSnapshotted
    (
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSnapshotsPresent,
    OUT     LONG *          plSnapshotCompatibility
    )
    {
    LPWSTR wszComputerName = NULL;

    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::IsVolumeSnapshotted");
    try
        {
        // clear arguments
        VssZeroOut(pbSnapshotsPresent);
        VssZeroOut(plSnapshotCompatibility);

        // validate arguments
        if (plSnapshotCompatibility == NULL ||
            pbSnapshotsPresent == NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"NULL output parameter.");

        if (pwszVolumeName == NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"NULL required input parameter");


        // get local computer name
        wszComputerName = GetLocalComputerName();
        *pbSnapshotsPresent = false;
        *plSnapshotCompatibility = 0;
        VSS_SNAPSHOT_SET_LIST *pList = m_pList;

        // loop through the snapshot sets.
        for(; pList != NULL; pList = pList->m_next)
            {
            IVssSnapshotSetDescription *pSnapshotSet = pList->m_pDescription;
            UINT cSnapshots;

            // get count of snapshots in the snapshot set
            ft.hr = pSnapshotSet->GetSnapshotCount(&cSnapshots);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSet::GetSnapshotCount");

            // loop through the snapshots
            for(UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++)
                {
                // get snapshot description
                CComPtr<IVssSnapshotDescription> pSnapshot;
                ft.hr = pSnapshotSet->GetSnapshotDescription(iSnapshot, &pSnapshot);
                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotDescription");

                // get originating machine and volume.  Note volume name should
                // be of format \\?\Volume{GUID} since GetVolumeNameForVolumeMountPoint
                // is called by coordinator on any volume names
                CComBSTR bstrOriginalVolume;
                CComBSTR bstrOriginatingMachine;
                ft.hr = pSnapshot->GetOrigin(&bstrOriginatingMachine, &bstrOriginalVolume);
                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetOrigin");

                // compare originating machine and volume.  If match, then
                // there is a snapshot on the volume.
                if (wcscmp(bstrOriginatingMachine, wszComputerName) == 0 &&
                    wcscmp(bstrOriginalVolume, pwszVolumeName) == 0)
                    {
                    *pbSnapshotsPresent = TRUE;
                    break;
                    }
                }
            }

        }
    VSS_STANDARD_CATCH(ft)

    delete wszComputerName;

    // remap errors to prevent extra event logging
    if (ft.HrFailed() &&
        ft.hr != E_OUTOFMEMORY &&
        ft.hr != VSS_E_OBJECT_NOT_FOUND)
        ft.hr = VSS_E_PROVIDER_VETO;

    return ft.hr;
    }




// call provider with EndPrepareSnapshots.  Upon successful completion of
// this call all snapshots in the set are prepared
STDMETHODIMP CVssHardwareProviderWrapper::EndPrepareSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::EndPrepareSnapshots");

    BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
    BS_ASSERT(m_eState == VSS_SS_PREPARING);
    BS_ASSERT(m_pCreationItf);
    try
        {
        if (m_bForceFailure)
            ft.Throw(VSSDBG_COORD, VSS_E_PROVIDER_VETO, L"Force failure due to BeginPrepare failure");

        ft.hr = m_pCreationItf->EndPrepareSnapshots(SnapshotSetId);
        if (ft.HrFailed())
            return ft.hr;

        HideVolumes();
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        {
        // remap errors to prevent extra logging
        if (ft.hr != E_OUTOFMEMORY)
            ft.hr = VSS_E_PROVIDER_VETO;
        }
    else
        m_eState = VSS_SS_PREPARED;

    return ft.hr;
    }



// call provider with PreCommitSnapshots
STDMETHODIMP CVssHardwareProviderWrapper::PreCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::PreCommitSnapshots");

    BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
    BS_ASSERT(m_pCreationItf);

    try
        {
        BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
        BS_ASSERT(m_eState == VSS_SS_PREPARED);
        BS_ASSERT(m_pHWItf);

        m_eState = VSS_SS_PROCESSING_PRECOMMIT;
        // return all errors directly to caller
        ft.hr = m_pCreationItf->PreCommitSnapshots(SnapshotSetId);
        }
    VSS_STANDARD_CATCH(ft)

    if (!ft.HrFailed())
        m_eState = VSS_SS_PRECOMMITTED;

    return ft.hr;
    }

// call provider with CommitSnapshots
STDMETHODIMP CVssHardwareProviderWrapper::CommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CommitSnapshots");

    BS_ASSERT(m_eState == VSS_SS_PRECOMMITTED);
    BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
    BS_ASSERT(m_pCreationItf);

    m_eState = VSS_SS_PROCESSING_COMMIT;

    // return all errors directly to the caller
    ft.hr = m_pCreationItf->CommitSnapshots(SnapshotSetId);
    if (!ft.HrFailed())
        m_eState = VSS_SS_COMMITTED;

    return ft.hr;
    }


// call provider with PostCommitSnapshots
STDMETHODIMP CVssHardwareProviderWrapper::PostCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::PostCommitSnapshots");

    try
        {
        BS_ASSERT(m_eState == VSS_SS_COMMITTED);
        BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
        BS_ASSERT(m_pCreationItf);

        m_eState = VSS_SS_PROCESSING_POSTCOMMIT;

        CloseVolumeHandles();
        ft.hr = m_pSnapshotSetDescription->SetOriginalSnapshotCount(lSnapshotsCount);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::SetOriginalSnapshotCount");
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        return VSS_E_PROVIDER_VETO;



    // return errors directly to caller
    return m_pCreationItf->PostCommitSnapshots(SnapshotSetId, lSnapshotsCount);
    }


STDMETHODIMP CVssHardwareProviderWrapper::PreFinalCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
   {
   UNREFERENCED_PARAMETER(SnapshotSetId);

   CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::PreFinalCommitSnapshots");

   ft.hr = E_NOTIMPL;
   return ft.hr;
   }

STDMETHODIMP CVssHardwareProviderWrapper::PostFinalCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
   {
   UNREFERENCED_PARAMETER(SnapshotSetId);

   CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::PostFinalCommitSnapshots");

   ft.hr = E_NOTIMPL;
   return ft.hr;
   }

// abort snapshot creation that is in progress
STDMETHODIMP CVssHardwareProviderWrapper::AbortSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::AbortSnapshots");
    bool fNeedRescan = false;

    if (m_SnapshotSetId == GUID_NULL)
        {
        // not currently in the process of creating a snapshot.  This must
        // be an already created snapshot that we are in the process of
        // deleting
        try
            {
            DYNDISKARRAY rgDynDisksRemoved;
            InternalDeleteSnapshot(VSS_CTX_ALL, SnapshotSetId, rgDynDisksRemoved, &fNeedRescan);
            if (rgDynDisksRemoved.GetSize() > 0)
                TryRemoveDynamicDisks(rgDynDisksRemoved);
            }
        VSS_STANDARD_CATCH(ft)

        if (fNeedRescan) 
            {
            try 
                {
                //
                // If any LUNs were freed as a result of this snapshot delete, do a 
                // rescan to ensure that the rest of the OS knows about it
                //
                DoRescan();
                }
            VSS_STANDARD_CATCH(ft)
            }

        
        return ft.hr == VSS_E_OBJECT_NOT_FOUND ? S_OK : ft.hr;
        }

    BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
    BS_ASSERT(m_pCreationItf);

    m_eState = VSS_SS_ABORTED;
    CloseVolumeHandles();

    // delete any cached info from IsVolumeSupported call.
    DeleteCachedInfo();

    // return errors directly to caller
    ft.hr = m_pCreationItf->AbortSnapshots(SnapshotSetId);

    ResetSnapshotSetState();
    return ft.hr;
    }


////////////////////////////////////////////////////////////////////////
// IVssProviderNotifications

STDMETHODIMP CVssHardwareProviderWrapper::OnLoad
    (
    IN  IUnknown* pCallback
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::OnLoad");

    return m_pNotificationItf? m_pNotificationItf->OnLoad(pCallback): S_OK;
    }

// call provider with unload method
STDMETHODIMP CVssHardwareProviderWrapper::OnUnload
    (
    IN      BOOL    bForceUnload
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::OnUnload");

    if (m_pNotificationItf)
        ft.hr = m_pNotificationItf->OnUnload(bForceUnload);

    return ft.hr;
    }


// delete information cached in AreLunsSupported
void CVssHardwareProviderWrapper::DeleteCachedInfo()
    {
    // free cached lun information for this volume
    FreeLunInfo(m_rgLunInfoProvider, m_rgwszDevicesProvider, m_cLunInfoProvider);
    m_cLunInfoProvider = 0;
    m_rgLunInfoProvider = NULL;
    m_rgwszDevicesProvider = NULL;

    // delete cached extents for this volume
    delete m_pExtents;
    m_pExtents = NULL;

    // delete cached original volume name
    delete m_wszOriginalVolumeName;
    m_wszOriginalVolumeName = NULL;
    }

// Enumerate the snapshots into the given array
void CVssHardwareProviderWrapper::EnumerateSnapshots
    (
    IN  LONG lContext,
    IN OUT  VSS_OBJECT_PROP_Array* pArray
    ) throw(HRESULT)
    {
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssHardwareProviderWrapper::EnumerateSnapshots");

    BS_ASSERT(pArray);

    for(VSS_SNAPSHOT_SET_LIST *pList = m_pList; pList; pList = pList->m_next)
        {
        IVssSnapshotSetDescription* pSnapshotSetDescription = pList->m_pDescription;
        BS_ASSERT(pSnapshotSetDescription);

        if (!CheckContext(lContext, pSnapshotSetDescription))
            continue;

        // Get the number of snapshots for this set
        UINT uSnapshotsCount = 0;
        ft.hr = pSnapshotSetDescription->GetSnapshotCount(&uSnapshotsCount);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

        // For each snapshot - try to add it to the array (if it is in the right context)
        for( UINT uSnapshotIndex = 0; uSnapshotIndex < uSnapshotsCount; uSnapshotIndex++)
            {
            // Get the snapshot description
            CComPtr<IVssSnapshotDescription> pSnapshotDescription = NULL;
            ft.hr = pSnapshotSetDescription->GetSnapshotDescription(uSnapshotIndex, &pSnapshotDescription);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");
            BS_ASSERT(pSnapshotDescription);

            // Create a new snapshot structure
            VSS_OBJECT_PROP_Ptr ptrSnapProp;
            ptrSnapProp.InitializeAsEmpty(ft);

            // Get the structure from the union
            VSS_OBJECT_PROP* pObj = ptrSnapProp.GetStruct();
            BS_ASSERT(pObj);
            VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

            // Make it a snapshot structure
            pObj->Type = VSS_OBJECT_SNAPSHOT;

            // Fill in the snapshot structure
            BuildSnapshotProperties
                (
                pSnapshotSetDescription,
                pSnapshotDescription,
                pSnap
                );

            // Add the snapshot to the array
            if (!pArray->Add(ptrSnapProp))
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

            ptrSnapProp.Reset();
            }
        }
    }



// set metadata indicating that a snapshot is exposed.  In addition, if the
// snapshot is exposed locally, then we need to unhide the volume so that
// the exposure is persistent.
STDMETHODIMP CVssHardwareProviderWrapper::SetExposureProperties
    (
    IN VSS_ID SnapshotId,
    IN LONG lAttributesExposure,
    IN LPCWSTR wszExposed,
    IN LPCWSTR wszExposedPath
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::ExposeSnapshotVolume");

    try
        {
        CheckLoaded();
        VSS_SNAPSHOT_SET_LIST *pList = m_pList;
        CComPtr<IVssSnapshotDescription> pSnapshot;

        while(pList)
            {
            ft.hr = pList->m_pDescription->FindSnapshotDescription(SnapshotId, &pSnapshot);
            if (ft.hr == S_OK)
                break;

            if (ft.hr != VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD, ft.hr, L"rethrow error");

            pList = pList->m_next;
            }

        if (!pList)
            ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Snapshot set not found");

        LONG lContext;
        ft.hr = pList->m_pDescription->GetContext(&lContext);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

        LONG lAttributes;

        ft.hr = pSnapshot->GetAttributes(&lAttributes);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetAttributes");

        lAttributes |= lAttributesExposure;

        // indicate name used to expose the snapshot
        ft.hr = pSnapshot->SetExposure(wszExposed, wszExposedPath);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetExposure");

        // change attributes to indicate that snapshot is exposed locally
        ft.hr = pSnapshot->SetAttributes(lAttributes);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetAttributes");

        // data needs to be saved unless snapshot is auto-release
        if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) != 0)
            {
            m_bChanged = true;
            TrySaveData();
            }
        }
    VSS_STANDARD_CATCH(ft)

    // remap errors to prevent redundant event logging
    if (ft.HrFailed() && ft.hr != VSS_E_OBJECT_NOT_FOUND && ft.hr != E_OUTOFMEMORY)
        ft.hr = VSS_E_PROVIDER_VETO;

    return ft.hr;
    }


STDMETHODIMP CVssHardwareProviderWrapper::SetSnapshotProperty(
    IN   VSS_ID             SnapshotId,
    IN   VSS_SNAPSHOT_PROPERTY_ID   eSnapshotPropertyId,
    IN   VARIANT            vProperty
    )
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::SetSnapshotProperty");

    try
        {

        //
        // Argument checking
        //
        if ( SnapshotId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotId == GUID_NULL");

        // Right now, only the Service Machine can be changed.
        if (eSnapshotPropertyId != VSS_SPROPID_SERVICE_MACHINE)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid property %d", eSnapshotPropertyId);

        CComVariant value = vProperty;
        if (value.vt != VT_BSTR)
            {
            BS_ASSERT(false); // The coordinator must give us the right data
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid variant %ul for property %d",
                value.vt, eSnapshotPropertyId);
            }

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: SnapshotId: " WSTR_GUID_FMT
            L", eSnapshotPropertyId = %d, vProperty = %s" ,
            GUID_PRINTF_ARG(SnapshotId), eSnapshotPropertyId, value.bstrVal );

        // We should not allow empty strings
        if (value.bstrVal == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL service machine name", value.bstrVal);

        // get lock
        CVssSafeAutomaticLock lock(s_csHWWrapperList);


        // Find the snapshot with the given ID
        CheckLoaded();
        VSS_SNAPSHOT_SET_LIST *pList = m_pList;
        CComPtr<IVssSnapshotDescription> pSnapshot;

        while(pList)
            {
            ft.hr = pList->m_pDescription->FindSnapshotDescription(SnapshotId, &pSnapshot);
            if (ft.hr == S_OK)
                break;

            if (ft.hr != VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD, ft.hr, L"rethrow error");

            pList = pList->m_next;
            }

        if (!pList)
            ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Snapshot set not found");

        LONG lContext;
        ft.hr = pList->m_pDescription->GetContext(&lContext);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

        // Set the member in the structure
        BS_ASSERT(eSnapshotPropertyId == VSS_SPROPID_SERVICE_MACHINE)

        // indicate service machine
        ft.hr = pSnapshot->SetServiceMachine(value.bstrVal);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetServiceMachine");

        // data needs to be saved unless snapshot is auto-release
        if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) != 0)
            {
            m_bChanged = true;
            TrySaveData();
            }
    }
    VSS_STANDARD_CATCH(ft)

    // remap errors to prevent redundant event logging
    switch(ft.hr)
    {
    case S_OK:
    case VSS_E_OBJECT_NOT_FOUND:
    case E_OUTOFMEMORY:
    case E_INVALIDARG:
        break;
    default:
        ft.hr = VSS_E_PROVIDER_VETO;
    }

    return ft.hr;
}

// revert to snapshot not implemented for hardware providers
STDMETHODIMP CVssHardwareProviderWrapper::RevertToSnapshot(
   IN       VSS_ID              SnapshotId
 ) 
    {
    UNREFERENCED_PARAMETER(SnapshotId);
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::RevertToSnapshot");
    
    ft.hr = VSS_E_PROVIDER_VETO;
    return ft.hr;
    }

// revert to snapshot not implemented for hardware providers
STDMETHODIMP CVssHardwareProviderWrapper::QueryRevertStatus(
   IN      VSS_PWSZ                         pwszVolume,
   OUT    IVssAsync**                  ppAsync
 )
    {
    UNREFERENCED_PARAMETER(pwszVolume);
    UNREFERENCED_PARAMETER(ppAsync);
	
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::QueryRevertStatus");

    ft.hr = VSS_E_PROVIDER_VETO;
    return ft.hr;
    }


// determine if all the luns composing a volume are supported by this
// provider.
//
// IMPORTANT NOTE: This routine will save information about the luns
// containing the volume in the object.  This information is used
// in the BeginPrepareSnapshot call.  It is assumed that this routine is
// called before the BeginPrepareSnapshot call and that the
// BeginPrepareSnapshot call is called before subsequent calls to
// IsVolumeSupported.  If not, then the cached information will be lost!!!
// Therefore there is a call at the beginning of BeginPrepareSnapshots to
// call IsVolumeSupported.  This will do nothing if the cached info is for
// the same volume that BeginPrepareSnapshots is called on.
STDMETHODIMP CVssHardwareProviderWrapper::IsVolumeSupported
    (
    IN LONG lContext,
    IN VSS_PWSZ wszVolumeName,
    OUT BOOL *pbIsSupported
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::IsVolumeSupported");


    CVssSafeAutomaticLock lock(m_csLunInfo);

    BS_ASSERT(wszVolumeName != NULL);
    BS_ASSERT(pbIsSupported != NULL);


    // validate that bus types match
    BS_ASSERT(BusTypeUnknown == VDSBusTypeUnknown);
    BS_ASSERT(BusTypeScsi == VDSBusTypeScsi);
    BS_ASSERT(BusTypeAtapi == VDSBusTypeAtapi);
    BS_ASSERT(BusTypeAta == VDSBusTypeAta);
    BS_ASSERT(BusType1394 == VDSBusType1394);
    BS_ASSERT(BusTypeSsa == VDSBusTypeSsa);
    BS_ASSERT(BusTypeFibre == VDSBusTypeFibre);
    BS_ASSERT(BusTypeUsb == VDSBusTypeUsb);
    BS_ASSERT(BusTypeRAID == VDSBusTypeRAID);

    // buffer for VOLUME_DISK_EXTENTS structure
    BYTE *bufExtents = NULL;

    // allocated lun information
    VDS_LUN_INFORMATION *rgLunInfo = NULL;

    // device names
    VSS_PWSZ *rgwszDevices = NULL;

    // number of luns found
    UINT cLuns = 0;

    *pbIsSupported = true;

    // volume name copy, updated to remove final slash
    LPWSTR wszVolumeNameCopy = NULL;
    try
        {
        // if called multiple times with same volume, don't do anything
        if (m_wszOriginalVolumeName)
            {
            if (wcscmp(m_wszOriginalVolumeName, wszVolumeName) == 0)
                {
                *pbIsSupported = true;
                throw S_OK;
                }
            else
                // delete any leftover information from a previous call
                DeleteCachedInfo();
            }

        // create a copy of the volume name in order to delete
        // trailing backslash if necessary
        wszVolumeNameCopy = new WCHAR[wcslen(wszVolumeName) + 1];

        if (wszVolumeNameCopy == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");

        wcscpy(wszVolumeNameCopy, wszVolumeName);
        if (wszVolumeNameCopy[wcslen(wszVolumeName) - 1] == L'\\')
            wszVolumeNameCopy[wcslen(wszVolumeName) - 1] = L'\0';

        bool bVolumeIsDynamic;

        if (!BuildLunInfoFromVolume
                (
                wszVolumeNameCopy,
                bufExtents,
                cLuns,
                rgwszDevices,
                rgLunInfo,
                bVolumeIsDynamic
                ))
            *pbIsSupported = false;
        else
            {

            //
            // If this involves dynamic disks and is not transportable, ensure
            // that auto-import is supported.
            //
            if ((bVolumeIsDynamic) && 
                ((lContext & VSS_VOLSNAP_ATTR_TRANSPORTABLE) == 0)) 
                {
                    CVssSafeAutomaticLock lock(m_csDynDisk);
                    SetupDynDiskInterface();
                    BS_ASSERT(m_pDynDisk);

                    //
                    // Check specifically for S_OK;
                    //
                    if (S_OK != m_pDynDisk->AutoImportSupported()) {
                        *pbIsSupported = false;
                    }
                }

            if (*pbIsSupported) 
                {
                
                // call AreLunsSupported with the lun information and the context
                // for the snapshot
                ft.hr = m_pHWItf->AreLunsSupported
                            (
                            (LONG) cLuns,
                            lContext,
                            rgwszDevices,
                            rgLunInfo,
                            pbIsSupported
                            );

                // remap any provider failures
                if (ft.HrFailed())
                    ft.TranslateProviderError
                        (
                        VSSDBG_COORD,
                        m_ProviderId,
                        L"IVssSnapshotSnapshotProvider::AreLunsSupported failed with error 0x%08lx",
                        ft.hr
                        );


                if(*pbIsSupported)
                    {
                    BS_ASSERT(m_wszOriginalVolumeName == NULL);

                    // provider is chose.  Save way original volume name
                    m_wszOriginalVolumeName = new WCHAR[wcslen(wszVolumeName) + 1];
                    if (m_wszOriginalVolumeName == NULL)
                        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate volume name");

                    wcscpy(m_wszOriginalVolumeName, wszVolumeName);

                    // save away lun information
                    m_rgLunInfoProvider = rgLunInfo;
                    m_cLunInfoProvider = cLuns;
                    m_rgwszDevicesProvider = rgwszDevices;
                    m_bVolumeIsDynamicProvider = bVolumeIsDynamic;


                    // don't free up the lun information
                    rgLunInfo = NULL;
                    rgwszDevices = NULL;
                    cLuns = 0;

                    // save disk extent information
                    m_pExtents = (VOLUME_DISK_EXTENTS *) bufExtents;

                    // don't free up the extents buffer
                    bufExtents = NULL;
                    }
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    // free up lun info if not NULL
    FreeLunInfo(rgLunInfo, rgwszDevices, cLuns);

    // delete temporary string buffer
    delete wszVolumeNameCopy;

    // free up buffers used for ioctls
    delete bufExtents;

    if (ft.HrFailed()) 
        {
        *pbIsSupported = FALSE;
        }


    // remap errors to prevent extra event logging
    if (ft.HrFailed() &&
        ft.hr != VSS_E_OBJECT_NOT_FOUND &&
        ft.hr != E_OUTOFMEMORY)
        ft.hr = VSS_E_PROVIDER_VETO;


    return ft.hr;
    }

// check whether context matches context for snapshot set
bool CVssHardwareProviderWrapper::CheckContext
    (
    LONG lContext,
    IVssSnapshotSetDescription *pSnapshotSet
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CheckContext");

    if (lContext == VSS_CTX_ALL)
        return true;

    // Make sure we are in the correct context
    LONG lSnapshotSetContext = 0;
    ft.hr = pSnapshotSet->GetContext(&lSnapshotSetContext);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

    lSnapshotSetContext &= VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE|VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE|VSS_VOLSNAP_ATTR_NO_WRITERS|VSS_VOLSNAP_ATTR_PERSISTENT;
    LONG lContextT = lContext & (VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE|VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE|VSS_VOLSNAP_ATTR_NO_WRITERS|VSS_VOLSNAP_ATTR_PERSISTENT);
    return lContextT == lSnapshotSetContext;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\hwinst.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module hwinst.cxx | Implementation of the utility CVssHWProviderInstance methods
    @end

Author:

    Brian Berkowitz  [brianb]  06/01/2001

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      06/01/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "setupapi.h"
#include "rpc.h"
#include "cfgmgr32.h"
#include "devguid.h"
#include "resource.h"
#include "vssmsg.h"
#include "vs_inc.hxx"
#include <svc.hxx>


// Generated file from Coord.IDL
#include "vss.h"
#include "vscoordint.h"
#include "vsevent.h"
#include "vdslun.h"
#include "vsprov.h"
#include "vswriter.h"
#include "vsbackup.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "vs_idl.hxx"
#include "hardwrp.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORHWINC"
//
////////////////////////////////////////////////////////////////////////
// constructor for hardware wrapper instance
CVssHardwareProviderInstance::CVssHardwareProviderInstance
    (
    CVssHardwareProviderWrapper *pWrapper
    ) :
    m_lContext(0),
    m_lRef(0),
    m_pWrapper(pWrapper)
    {
    }

CVssHardwareProviderInstance::~CVssHardwareProviderInstance()
    {
    if (m_rgSnapshotSetIds.GetSize() > 0)
        m_pWrapper->DeleteAutoReleaseSnapshots
                        (
                        m_rgSnapshotSetIds.GetData(),
                        m_rgSnapshotSetIds.GetSize()
                        );
    }



// create a wrapper of the hardware provider supporting the
// IVssSnapshotProvider interface
// Throws:
//      E_OUTOFMEMORY

IVssSnapshotProvider* CVssHardwareProviderInstance::CreateInstance
    (
    IN CVssHardwareProviderWrapper *pWrapper
    ) throw(HRESULT)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderInstance::CreateInstance");

    CVssHardwareProviderInstance *pProvider = new CVssHardwareProviderInstance(pWrapper);
    if (pProvider == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot create hardware provider instance");

    pProvider->AddRef();
    return pProvider;
    }


/////////////////////////////////////////////////////////////////////////////
// Internal methods

// this method should never be called
STDMETHODIMP CVssHardwareProviderInstance::QueryInternalInterface
    (
    IN  REFIID iid,
    OUT void** pp
    )
    {
    UNREFERENCED_PARAMETER(iid);

    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::QueryInternalInterface");

    BS_ASSERT(pp);
    *pp = NULL;

    BS_ASSERT(FALSE);
    return E_NOINTERFACE;
    }

/////////////////////////////////////////////////////////////////////////////
// IUnknown

// supports coercing the Instance to IUnknown
STDMETHODIMP CVssHardwareProviderInstance::QueryInterface(REFIID iid, void** pp)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderInstance::QueryInterface");

    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
    return S_OK;
    }

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssHardwareProviderInstance::AddRef()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderInstance::AddRef");

    return ::InterlockedIncrement(&m_lRef);
    }

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssHardwareProviderInstance::Release()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderInstance::Release");

    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!

    return l;
    }

// IVssProvider::SetContext
// note that this routine will initialize the wrapper's critical section
// if it wasn't already done.
STDMETHODIMP CVssHardwareProviderInstance::SetContext
    (
    IN LONG lContext
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderInstance::SetContext");

    // make sure that context is assigned only once
    BS_ASSERT(m_lContext == VSS_CTX_BACKUP);

    m_lContext = lContext;
    return ft.hr;
    }

// wrapper for BeginPrepareSnapshot.  cache snapshot set ids for auto-release
// snapshots created through this interface pointer.  These will be deleted
// when the interface reference count falls to 0.
STDMETHODIMP CVssHardwareProviderInstance::BeginPrepareSnapshot
    (
    IN VSS_ID SnapshotSetId,
    IN VSS_ID SnapshotId,
    IN VSS_PWSZ pwszVolumeName,
    IN LONG         lNewContext
    )
    {
    UNREFERENCED_PARAMETER(lNewContext);
    
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareInstance::BeginPrepareSnapshot");

    try
        {
        if ((m_lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) == 0)
            AddSnapshotSet(SnapshotSetId);

        ft.hr = m_pWrapper->BeginPrepareSnapshot
                            (
                            m_lContext,
                            SnapshotSetId,
                            SnapshotId,
                            pwszVolumeName
                            );
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

void CVssHardwareProviderInstance::AddSnapshotSet(VSS_ID SnapshotSetId)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderInstance::AddSnapshotSet");

    if (m_rgSnapshotSetIds.GetSize() == 0 ||
        m_rgSnapshotSetIds[m_rgSnapshotSetIds.GetSize() -1] != SnapshotSetId)
        m_rgSnapshotSetIds.Add(SnapshotSetId);
    }


// wrapper for BeginPrepareSnapshot.  cache snapshot set ids for auto-release
// snapshots created through this interface pointer.  These will be deleted
// when the interface reference count falls to 0.
STDMETHODIMP CVssHardwareProviderInstance::ImportSnapshotSet
    (
    LPCWSTR wszXMLSnapshotSet,
    bool *pbCancelled
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareInstance::ImportSnapshotSet");

    try
        {
        CComPtr<IVssSnapshotSetDescription> pSnapshotSet;

        ft.hr = LoadVssSnapshotSetDescription(wszXMLSnapshotSet, &pSnapshotSet);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"LoadVssSnapshotSetDescription");

        // determine context
        LONG lContext;
        ft.hr = pSnapshotSet->GetContext(&lContext);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

        VSS_ID SnapshotSetId;
        ft.hr = pSnapshotSet->GetSnapshotSetId(&SnapshotSetId);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotSetId");

        if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) == 0)
            AddSnapshotSet(SnapshotSetId);

        ft.hr = m_pWrapper->ImportSnapshotSetInternal(pSnapshotSet, pbCancelled);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\query.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Query.cxx | Implementation of Query methods in coordinator interfaces
    @end

Author:

    Adi Oltean  [aoltean]  09/03/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/03/1999  Created
    aoltean     09/09/1999  Adding Query from coord.cxx
                            dss -> vss
    aoltean     09/20/1999  Simplify memory management
    aoltean     09/21/1999  Converting to the new enumerator
    aoltean     09/22/1999  Making the first branch of Query working
    aoltean     09/27/1999  Provider-generic code

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "vs_sec.hxx"
#include "shim.hxx"
#include "coord.hxx"
#include "lmshare.h"
#include "lmaccess.h"
#include "lmerr.h"
#include "lmapibuf.h"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORQRYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  QueryXXXX methods


STDMETHODIMP CVssCoordinator::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )

/*++

Routine Description:

    Implements the IVssCoordinator::Query method

Arguments:

    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum

Return values:

    E_ACCESSDENIED
        - The user is not a backup operator or an administrator
    E_OUTOFMEMORY
    E_INVALIDARG
        - Invalid arguments
    VSS_E_OBJECT_NOT_FOUND
        - Queried object not found.
    E_UNEXPECTED
        - CVssEnumFromArray::Init failures
        - QueryInterface(IID_IVssEnumObject,...) failures

    [CVssProviderManager::TransferEnumeratorContentsToArray() failures]
        E_OUTOFMEMORY

        [InitializeAsEmpty failed]
            E_OUTOFMEMORY

        [IVssEnumObject::Next() failed]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - unexpected provider error when calling Next. An error log entry is added describing the error.
            VSS_E_PROVIDER_VETO
                - provider error when calling Next

    [IVssSnapshotProvider::Query failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

    [QuerySupportedProvidersIntoArray() failures]
        E_OUTOFMEMORY

        VSS_E_UNEXPECTED_PROVIDER_ERROR
            Unexpected provider error on calling IsVolumeSupported

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterface failures]
            [lockObj failures]
                E_OUTOFMEMORY

            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
             L"QueriedObjectId = " WSTR_GUID_FMT
             L", eQueriedObjectType = %d"
             L", eReturnedObjectsType = %d"
             L", ppEnum = %p",
             GUID_PRINTF_ARG( QueriedObjectId ),
             eQueriedObjectType,
             eReturnedObjectsType,
             ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");
        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");
        if ((eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            && (eReturnedObjectsType != VSS_OBJECT_PROVIDER))
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");
        BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Freeze context
        FreezeContext();

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
        // The only purpose of this is to use a smart ptr to destroy correctly the array on error.
        // Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Fill now the collection
        switch( eReturnedObjectsType )
        {
        case VSS_OBJECT_SNAPSHOT:
            {
                // Get the array of interfaces
                CVssSnapshotProviderItfMap* pItfMap;
                CVssProviderManager::GetProviderItfArray( GetContextInternal(), &pItfMap );
                BS_ASSERT(pItfMap);

                // Initialize an observer.
                // This will keep track of all Snapshot set IDs that are created
                // while the queries are in process
                CVssSnasphotSetIdObserver rec;

                // Start recording. This may throw.
                // (stop recording occurs anyway at object destruction if a throw happens after this call)
                rec.StartRecording();

                // For each provider get all objects tht corresponds to the filter
                for (int nIndex = 0; nIndex < pItfMap->GetSize(); nIndex++ )
                {
                    CComPtr<IVssSnapshotProvider> pProviderItf = pItfMap->GetValueAt(nIndex);
                    if (pProviderItf == NULL)
                        continue;

                    // Query the provider
                    CComPtr<IVssEnumObject> pEnumTmp;
                    ft.hr = pProviderItf->Query(
                        GUID_NULL,
                        VSS_OBJECT_NONE,
                        VSS_OBJECT_SNAPSHOT,
                        &pEnumTmp
                        );
                    if (ft.HrFailed())
                        ft.TranslateProviderError( VSSDBG_COORD, pItfMap->GetKeyAt(nIndex),
                            L"Error calling Query(). [0x%08lx]", ft.hr);

                    // Add enumerator contents to array
                    CVssProviderManager::TransferEnumeratorContentsToArray(
                        pItfMap->GetKeyAt(nIndex), pEnumTmp, pArray );
                }

                // Stop recording.
                rec.StopRecording();

                // Remove from the array all snapshots that were created during Query.
                for(int nIndex = 0; nIndex < pArray->GetSize();) {
                    VSS_OBJECT_PROP_Ptr& ptr = (*pArray)[nIndex];
                    VSS_OBJECT_PROP* pStruct = ptr.GetStruct();
                    BS_ASSERT(pStruct);
                    BS_ASSERT(pStruct->Type == VSS_OBJECT_SNAPSHOT);
                    VSS_SNAPSHOT_PROP* pSnap = &(pStruct->Obj.Snap);

                    // If the snapshot belongs to a partially created snapshot set, remove it.
                    if (rec.IsRecorded(pSnap->m_SnapshotSetId)) {
                        pArray->RemoveAt(nIndex);
                        // Do not increment - the same index will refer to the next element, if any.
                    } else
                        {
                        // This element is OK. Proceed with the next one.
                        nIndex++;
                    }
                }
            }
            break;

        case VSS_OBJECT_PROVIDER:
            // Insert property structures into array.
            CVssProviderManager::QuerySupportedProvidersIntoArray(
                GetContextInternal(), true, NULL, pArray );
            break;

        default:
            BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        }

        // Create the enumerator object.
        ft.hr = VssBuildEnumInterface<CVssEnumFromArray>( VSSDBG_COORD, pArray, ppEnum );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssAdmin::QueryProviders(
    OUT   IVssEnumObject**ppEnum
    )

/*++

Routine Description:

    Implements the IVssAdmin::QueryProviders method

Arguments:

    OUT     IVssEnumObject**ppEnum

Return values:

    E_OUTOFMEMORY
    E_INVALIDARG
        - Invalid arguments
    E_ACCESSDENIED
        - The user is not a backup operator or an administrator
    E_UNEXPECTED
        - CVssEnumFromArray::Init failures
        - QueryInterface(IID_IVssEnumObject,...) failures

    [QuerySupportedProvidersIntoArray() failures]
        E_OUTOFMEMORY

        VSS_E_UNEXPECTED_PROVIDER_ERROR
            Unexpected provider error on calling IsVolumeSupported

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterface failures]
            [lockObj failures]
                E_OUTOFMEMORY

            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::QueryProviders" );
    VSS_OBJECT_PROP_Ptr ptrProviderProperties;

    try
    {
        // Initialize [out] arguments
        VssZeroOut( ppEnum );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
             L"ppEnum = %p",
             ppEnum
             );

        // Argument validation
        BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
        // The only purpose of this is to use a smart ptr to destroy correctly the array on error.
        // Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Insert property structures into array. All providers support by default the backup context.
        CVssProviderManager::QuerySupportedProvidersIntoArray(
            VSS_CTX_BACKUP, true, NULL, pArray );

        // Create the enumerator object.
        ft.hr = VssBuildEnumInterface<CVssEnumFromArray>( VSSDBG_COORD, pArray, ppEnum );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssSnasphotSetIdObserver


//  Global variables
//

// Global list of observers
CVssDLList<CVssSnasphotSetIdObserver*>   CVssSnasphotSetIdObserver::m_list;

// Global lock fot the observer operations
CVssSafeCriticalSection  CVssSnasphotSetIdObserver::m_cs;


// Implementation
//

// Constructs an observer object
CVssSnasphotSetIdObserver::CVssSnasphotSetIdObserver():
    m_bRecordingInProgress(false),
    m_Cookie(VSS_NULL_COOKIE)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::CVssSnasphotSetIdObserver" );
}


// Destructs the observer object
// This does NOT throw!
CVssSnasphotSetIdObserver::~CVssSnasphotSetIdObserver()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::~CVssSnasphotSetIdObserver" );

    // Check if the critical section is initialized
    if (!m_cs.IsInitialized())
        return;

    // Global lock. This does NOT throw!
    CVssSafeAutomaticLock lock(m_cs);

    // Check for validity
    if (!IsValid())
        return;

    // Remove ourselves to the global list of observers
    // This also does not throw.
    CVssSnasphotSetIdObserver* pThis = NULL;
    m_list.ExtractByCookie(m_Cookie, pThis);
    BS_ASSERT(this == pThis);
}


// Check if the observer is valid
bool CVssSnasphotSetIdObserver::IsValid()
{
    return (m_Cookie != VSS_NULL_COOKIE);
}


// Puts the observer in the listeners list in order to detect partial results in Query
// This may safely throw!
void CVssSnasphotSetIdObserver::StartRecording() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::StartRecording" );

    // Initialize critical section if needed.
    m_cs.Init();
    if (!m_cs.IsInitialized())
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Unable to initialize the global critical section");

    // Global lock - does not throw
    CVssSafeAutomaticLock lock(m_cs);

    // Starts the recording
    BS_ASSERT(m_bRecordingInProgress == false);
    m_bRecordingInProgress = true;

    // Try to add the current snapshot set ID, if any
    // This may throw.
    CVssGlobalSnapshotSetId::InitializeObserver(this);

    // Add ourselves to the global list of observers.
    // This can throw E_OUTOFMEMORY
    if (m_Cookie != VSS_NULL_COOKIE) {
        BS_ASSERT(false);
        return;
    }
    m_Cookie = m_list.Add(ft, this);
}


// Stop recording SSIDs
void CVssSnasphotSetIdObserver::StopRecording()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::StopRecording" );

    // Programming error: you must successfully call StartRecording first!
    if (!IsValid()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"StartRecording was not called successfully");
    }

    // Acquire the critical section. Doesn't throw.
    BS_ASSERT(m_cs.IsInitialized());
    CVssSafeAutomaticLock lock(m_cs);

    // Stops the recording
    BS_ASSERT(m_bRecordingInProgress == true);
    m_bRecordingInProgress = false;
}


// Check if a SSID was in progress
bool CVssSnasphotSetIdObserver::IsRecorded(
    IN  VSS_ID SnapshotSetID
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::IsRecorded" );

    // Programming error: you must successfully call StartRecording first!
    if (!IsValid()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"StartRecording was not called successfully");
    }

    // Acquire the critical section
    BS_ASSERT(m_cs.IsInitialized());
    CVssSafeAutomaticLock lock(m_cs);

    // Check to see if the snapshot set is recorded
    return (m_mapSnapshotSets.FindKey(SnapshotSetID) != -1);
}


// Records this Snapshot Set ID in ALL observers
void CVssSnasphotSetIdObserver::BroadcastSSID(
    IN VSS_ID SnapshotSetId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::BroadcastSSID" );

    // Validate arguments
    BS_ASSERT(SnapshotSetId != GUID_NULL);

    // Do not attempt to broadcast SSIDs if there are no observers
    if (!m_cs.IsInitialized())
        return;

    // Acquire the critical section
    CVssSafeAutomaticLock lock(m_cs);

    // Record the SSID for all listeners
    //

    // Get an iterator for the global list of observers
    CVssDLListIterator<CVssSnasphotSetIdObserver*> iterator(m_list);

    // Send the SSID to all observers. If we fail in the middle,
    // then we are still in a consistent state. In order to simplify
    // the code we will not add any supplementary checks,
    // since the caller (StartSnapshotSet) will fail anyway,
    // so we will have an additional harmless filtering for an invalid SSID.

    // This might throw!
    CVssSnasphotSetIdObserver* pObj = NULL;
    while (iterator.GetNext(pObj))
        pObj->RecordSSID(SnapshotSetId);
}


// Records this Snapshot Set ID in this observer instance
// Remark: The lock is already acquired
void CVssSnasphotSetIdObserver::RecordSSID(
    IN VSS_ID SnapshotSetId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::RecordSSID" );

    // Check to see if recording is in progress.
    if (!m_bRecordingInProgress)
        return;

    // Add the SSID to the internal map
    if (!m_mapSnapshotSets.Add(SnapshotSetId, 0))
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\mgmt.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Mgmt.cxx | Implementation of CVssSnapshotMgmt
    @end

Author:

    Adi Oltean  [aoltean]  03/05/2001

Revision History:

    Name        Date        Comments
    aoltean     03/05/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_sec.hxx"
#include "provmgr.hxx"

#include "mgmt.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORMGMTC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssSnapshotMgmt


STDMETHODIMP CVssSnapshotMgmt::GetProviderMgmtInterface(							
	IN  	VSS_ID 	    ProviderId,     //  It might be a software or a system provider.
	IN  	REFIID 	    InterfaceId,    //  Might be IID_IVssDifferentialSoftwareSnapshotMgmt
	OUT     IUnknown**  ppItf           
	)
/*++

Routine description:

    Returns an interface to further configure a snapshot provider

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_PROVIDER_NOT_REGISTERED 
        - provider not found
    E_NOINTERFACE
        - the provider does not support the interface with the given ID.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - unexpected error when calling QueryInteface
    E_NOTIMPL
        - The SKU is not Windows Server 2003 or later.
    
    [CVssProviderManager::GetProviderInterface() failures]
        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.
            
            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::GetProviderMgmtInterface" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppItf );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  InterfaceId = " WSTR_GUID_FMT L"\n"
             L"  ppItf = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             GUID_PRINTF_ARG( InterfaceId ),
             ppItf);

        // Argument validation
		BS_ASSERT(ppItf);
        if (ppItf == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppItf");

        // Right now we support only IVssDifferentialSoftwareSnapshotMgmt. In future version we might support more interfaces.
        // WARNING: with the current implementation the client may still use QueryInterface to reach other provider's custom interfaces.
        // We cannot prevent that unless we decide to create a wrapper object around the returned provider interface, in order to 
        // intercept QueryInterface calls also.
        if ( InterfaceId != IID_IVssDifferentialSoftwareSnapshotMgmt )
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid Interface ID");

        if (CVssSKU::IsClient())
            ft.Throw( VSSDBG_COORD, E_NOTIMPL, L"Method not exposed in client SKU");

		// Get the provider interface
        CComPtr<IVssSnapshotProvider> ptrProviderInterface;
        BOOL bResult = CVssProviderManager::GetProviderInterface( ProviderId, VSS_CTX_ALL, ptrProviderInterface );
        if (!bResult)
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, L"We could not found a provider with the given ID");
    	BS_ASSERT(ptrProviderInterface);

    	// Query the IID_IVssDifferentialSoftwareSnapshotMgmt interface.
    	// Last call, so we can directly fill out the OUT parameter
    	CComPtr<IVssSnapshotMgmt> ptrProviderSnapshotMgmt;
    	ft.hr = ptrProviderInterface->QueryInternalInterface(IID_IVssSnapshotMgmt, 
    	            reinterpret_cast<void**>(&ptrProviderSnapshotMgmt));
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QueryInternalInterface(IID_IVssSnapshotMgmt, ...)");

        // Get the provider interface
    	ft.hr = ptrProviderSnapshotMgmt->GetProviderMgmtInterface( ProviderId, InterfaceId, ppItf);
    }
    VSS_STANDARD_CATCH(ft)

	// The ft.hr may be an VSS_E_OBJECT_NOT_FOUND or not.
    return ft.hr;
}



STDMETHODIMP CVssSnapshotMgmt::QueryVolumesSupportedForSnapshots(
	IN  	VSS_ID 	    ProviderId,     
    IN      LONG        lContext,
	OUT 	IVssEnumMgmtObject **ppEnum
	)
/*++

Routine description:

    Query volumes (on the local machine) that support snapshots.

Parameters:

    ProviderID - the provider on which we should return the supported volumes for snapshot. 
    ppEnum - the returned list of volumes.

Remarks:

    The result of the query is independent by context.

Error codes:

    S_FALSE
        - If returning an empty array
    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.

    VSS_E_PROVIDER_NOT_REGISTERED
        The Provider ID does not correspond to a registered provider.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported
    E_UNEXPECTED
        Error while getting the list of volumes. (for example dismounting a volume in the middle of an enumeration)
        A error log entry contains more information.

    [CVssProviderManager::GetProviderInterface() failures]
        [lockObj failures]
            E_OUTOFMEMORY
        
        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.
            
            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [provider's QueryVolumesSupportedForSnapshots()]
        S_FALSE
            - If returning an empty array
        E_ACCESSDENIED
            - The user is not an administrator
        E_INVALIDARG
            - Invalid argument
        E_OUTOFMEMORY
            - lock failures.
        E_UNEXPECTED
            Error while getting the list of volumes. (for example dismounting a volume in the middle of an enumeration)
            A error log entry contains more information.

        [CVssSoftwareProvider::IsVolumeSupported() failures]
            S_OK
                The function completed with success
            E_ACCESSDENIED
                The user is not an administrator.
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources           
            E_UNEXPECTED
                Unexpected programming error. Logging not done and not needed.
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.

            [CVssSoftwareProvider::GetVolumeInformation]
                E_OUTOFMEMORY
                VSS_E_PROVIDER_VETO
                    An error occured while opening the IOCTL channel. The error is logged.
                E_UNEXPECTED
                    Unexpected programming error. Nothing is logged.
                VSS_E_OBJECT_NOT_FOUND
                    The device does not exist or it is not ready.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::QueryVolumesSupportedForSnapshots" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             ppEnum);

        // Argument validation
        if (ProviderId == GUID_NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ProviderID");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Try to find the provider interface
		CComPtr<IVssSnapshotProvider> ptrProviderItf;
        if (!(CVssProviderManager::GetProviderInterface(ProviderId, lContext, ptrProviderItf)))
			ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
			    L"Provider not found");

    	// Query the IID_IVssSnapshotMgmt interface.
    	// Last call, so we can directly fill out the OUT parameter
    	CComPtr<IVssSnapshotMgmt> ptrProviderSnapshotMgmt;
    	ft.hr = ptrProviderItf->QueryInternalInterface(IID_IVssSnapshotMgmt, 
    	            reinterpret_cast<void**>(&ptrProviderSnapshotMgmt));
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QueryInternalInterface(IID_IVssSnapshotMgmt, ...)");

        // Get the provider interface
    	ft.hr = ptrProviderSnapshotMgmt->QueryVolumesSupportedForSnapshots( ProviderId, lContext, ppEnum);
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QueryVolumesSupportedForSnapshots(ProviderId,%ld,...)", lContext);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



/*++

Routine description:

    Query snapshots on the given volume.

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
--*/
STDMETHODIMP CVssSnapshotMgmt::QuerySnapshotsByVolume(
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_ID 	    ProviderId,     
	OUT 	IVssEnumObject **ppEnum
	)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::QuerySnapshotsByVolume" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             pwszVolumeName,
             GUID_PRINTF_ARG( ProviderId ),
             ppEnum);

        // Argument validation
		BS_ASSERT(pwszVolumeName);
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");
        if (ProviderId == GUID_NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ProviderID");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Calculate the unique volume name, just to make sure that we have the right path
    	WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
        GetVolumeNameWithCheck(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
            pwszVolumeName,
   			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal));

        // Try to find the provider interface
		CComPtr<IVssSnapshotProvider> ptrProviderItf;
        if (!(CVssProviderManager::GetProviderInterface(ProviderId, VSS_CTX_ALL, ptrProviderItf)))
			ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
			    L"Provider not found");

    	// Query the IID_IVssSnapshotMgmt interface.
    	// Last call, so we can directly fill out the OUT parameter
    	CComPtr<IVssSnapshotMgmt> ptrProviderSnapshotMgmt;
    	ft.hr = ptrProviderItf->QueryInternalInterface(IID_IVssSnapshotMgmt, 
    	            reinterpret_cast<void**>(&ptrProviderSnapshotMgmt));
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QueryInternalInterface(IID_IVssSnapshotMgmt, ...)");

        // Get the provider interface
    	ft.hr = ptrProviderSnapshotMgmt->QuerySnapshotsByVolume( wszVolumeNameInternal, ProviderId, ppEnum);
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QuerySnapshotsByVolume(%s,...)", wszVolumeNameInternal);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\reg_util.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module reg_util.cxx | Implementation of the Registry-related functions
    @end

Author:

    Adi Oltean  [aoltean]  09/27/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/27/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "reg_util.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORREGUC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssCoordinator private methods


void RecursiveDeleteKey(
    IN  CVssFunctionTracer& ft,
    IN  HKEY hParentKey,
    IN  LPCWSTR wszName
    )

/*++

Routine Description:

    Deletes recursively a registry key.

Arguments:

    IN  CVssFunctionTracer& ft,     // function tracer of the caller
    IN  HKEY hParentKey,            // handle to an ancestor key (like HKEY_LOCAL_MACHINE)
    IN  LPCWSTR wszName             // The key path from ancestor

--*/

{
    BS_ASSERT(hParentKey);
    BS_ASSERT(wszName && wszName[0] != L'\0');

    // Recursively delete the key
    DWORD dwRes = ::SHDeleteKey(
        hParentKey,                  //  IN HKEY hKey,
        wszName                     //  IN LPCTSTR  pszSubKey
        );
    if ( dwRes == ERROR_FILE_NOT_FOUND )
        ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
                    L"Key with path %p\\%s not found", hParentKey, wszName);
    if ( dwRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(dwRes), L"SHDeleteKey(%p,%s)", 
                    hParentKey, wszName);
}



void QueryStringValue(
    IN  CVssFunctionTracer& ft,
    IN  HKEY    hKey,
    IN  LPCWSTR wszKeyName,
    IN  LPCWSTR wszValueName,
    IN  DWORD   dwValueSize,
    OUT LPCWSTR wszValue
    )

/*++

Routine Description:

    Get the content of a (named) value of a registry key.
    Intended to be called from CVssCoordinator methods.
    Throw some HRESULTS on error

Arguments:

    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey,              // handle to the registry key
    IN  LPCWSTR wszKeyName,     // the name of the key (used only in tracing)
    IN  LPCWSTR wszValueName,   // the name of the value. Empty string for default key value.
    IN  DWORD   dwValueSize,    // the size of the value buffer, in WCHARs
    OUT LPCWSTR wszValue        // The content of that value.
                                // The buffer must be already allocated and must have at
                                // least dwValueSize WCHARs

Remarks:

    The code throws an error if value name length is greater than dwValueSize-1

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry errors. An error log entry is added describing the error.

--*/

{
    WCHAR       wszFunctionName[] = L"QueryStringValue";

	ft.hr = S_OK;

    BS_ASSERT( hKey );
    BS_ASSERT( wszKeyName != NULL && wszKeyName[0] != L'\0' );
    BS_ASSERT( wszValueName != NULL ); // wszValueName can be L""
    BS_ASSERT( dwValueSize != 0 );
    BS_ASSERT( wszValue );

    ::ZeroMemory( (void*)wszValue, dwValueSize * sizeof(WCHAR) );

    // Get the string content of the named key value
    DWORD   dwType;
    // Make room for the NULL character set above (bug 548694)
    DWORD   dwDataSize = (dwValueSize - 1) * sizeof(WCHAR);
    LPBYTE  pbData = (LPBYTE)wszValue;
    LONG lRes = ::RegQueryValueExW (
        hKey,           //  IN HKEY hKey,
        wszValueName,   //  IN LPCWSTR lpValueName,
        NULL,           //  IN LPDWORD lpReserved,
        &dwType,        //  OUT LPDWORD lpType,
        pbData,         //  IN OUT LPBYTE lpData,
        &dwDataSize     //  IN OUT LPDWORD lpcbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
            L"RegQueryValueExW(%s,%s,...)", wszKeyName, wszValueName );

    // Unexpected key type
    if ( dwType != REG_SZ ) { 
        ft.LogError(VSS_ERROR_WRONG_REGISTRY_TYPE_VALUE, 
            VSSDBG_COORD << (INT)dwType << (INT)REG_SZ << wszValueName << wszKeyName );
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                  L"%s: The value %s in the key with name %s has not a REG_SZ type. dwType == 0x%08lx",
                  wszFunctionName, wszValueName, wszKeyName, dwType );
    }
}


void QueryDWORDValue(
    IN  CVssFunctionTracer& ft,
    IN  HKEY    hKey,
    IN  LPCWSTR wszKeyName,
    IN  LPCWSTR wszValueName,
    OUT PDWORD pdwValue
    )

/*++

Routine Description:

    Get the content of a (named) value of a registry key.
    Intended to be called from CVssCoordinator methods.
    Throw some HRESULTS on error

Arguments:

    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey,              // handle to the registry key
    IN  LPCWSTR wszKeyName,     // the name of the key (used only in tracing)
    IN  LPCWSTR wszValueName,   // the name of the value. Empty string for default key value.
    OUT PDWORD pdwValue         // The content of that DWORD value.

Remarks:

    The code throws an error if value name length is greater than dwValueSize-1

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry errors. An error log entry is added describing the error.

--*/

{
    WCHAR       wszFunctionName[] = L"QueryDWORDValue";

	ft.hr = S_OK;

    BS_ASSERT( hKey );
    BS_ASSERT( wszKeyName != NULL && wszKeyName[0] != L'\0' );
    BS_ASSERT( wszValueName != NULL ); // wszValueName can be L""
    BS_ASSERT( pdwValue );

    (*pdwValue)=0;

    // Get the string content of the named key value
    DWORD   dwType = REG_NONE;  // Prefix bug 192471, still doesn't handle throw inside called functions well.
    DWORD   dwDataSize = sizeof(DWORD);
    LPBYTE  pbData = (LPBYTE)pdwValue;
    LONG lRes = ::RegQueryValueExW (
        hKey,           //  IN HKEY hKey,
        wszValueName,   //  IN LPCWSTR lpValueName,
        NULL,           //  IN LPDWORD lpReserved,
        &dwType,        //  OUT LPDWORD lpType,
        pbData,         //  IN OUT LPBYTE lpData,
        &dwDataSize     //  IN OUT LPDWORD lpcbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
            L"RegQueryValueExW(%s,%s,...)", wszKeyName, wszValueName );

    // Unexpected key type
    if ( dwType != REG_DWORD ) { 
        ft.LogError(VSS_ERROR_WRONG_REGISTRY_TYPE_VALUE, 
            VSSDBG_COORD << (INT)dwType << (INT)REG_DWORD << wszValueName << wszKeyName );
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                  L"%s: The value %s in the key with name %s has not a REG_DWORD type. dwType == 0x%08lx",
                  wszFunctionName, wszValueName, wszKeyName, dwType );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\provmgr.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module ProvMgr.cxx | Implementation of the CVssProviderManager methods
    @end

Author:

    Adi Oltean  [aoltean]  09/27/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/27/1999  Created
    aoltean     09/09/1999  Adding AddVolumeTointernalList from coord.cxx
    aoltean     09/09/1999  dss -> vss
    aoltean     09/15/1999  Returning only volume names to the writers.
    aoltean     09/21/1999  Rewriting GetProviderProperties in accordance with the new enumerator.
    aoltean     09/22/1999  Add TransferEnumeratorContentsToArray

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "cfgmgr32.h"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"
#include "reg_util.hxx"
#include "provmgr.hxx"
#include "softwrp.hxx"
#include "hardwrp.hxx"
#include "vs_reg.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORPRVMC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssProviderManager static members

VSS_OBJECT_PROP_Array* CVssProviderManager::m_pProvidersArray = NULL;
CVssProviderManager* CVssProviderManager::m_pStatefulObjList = NULL;
CVssCriticalSection CVssProviderManager::m_GlobalCS;
CVssCtxSnapshotProviderItfMap CVssProviderManager::m_mapProviderMapGlobalCache;
CVssProviderNotificationsItfMap  CVssProviderManager::m_mapProviderItfOnLoadCache;


/////////////////////////////////////////////////////////////////////////////
//  Query methods



void CVssProviderManager::TransferEnumeratorContentsToArray(
    IN  VSS_ID ProviderId,
    IN  IVssEnumObject* pEnum,
    IN  VSS_OBJECT_PROP_Array* pArray
    )

/*++

Routine Description:

    Append to the array the objects returned by this enumerator

Arguments:

    IN  IVssEnumObject* pEnum,          - The enumerator interface used for query
    IN  VSS_OBJECT_PROP_Array* pArray   - The array that will contain the results
    IN  VSS_ID  ProviderID              - The provider ID (for logging in case of errors)

Throw values:

    E_OUTOFMEMORY

    [InitializeAsEmpty failed]
        E_OUTOFMEMORY

    [IVssEnumObject::Next() failed]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - unexpected provider error when calling Next. An error log entry is added describing the error.
        VSS_E_PROVIDER_VETO
            - provider error when calling Next

Warning:

    The array remains filled partially on error! It is the responsibility of caller to take care.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::TransferEnumeratorContentsToArray");

    BS_ASSERT(pEnum);
    BS_ASSERT(pArray);

    ULONG ulFetched;
    VSS_OBJECT_PROP_Ptr ptrObjectProp;
    while (true)
    {
        // Allocate the new structure object, but with zero contents.
        // The internal pointer must not be NULL.
        // WARNING: This might throw E_OUTOFMEMORY
        ptrObjectProp.InitializeAsEmpty(ft);

        // Get the Next object in the newly allocated structure object.
        // This will fill up hte object's type and fields in the union
        // The pointer fields will refer some CoTaskMemAlloc buffers
        // that must be deallocated by us, after the structure is useless.
        VSS_OBJECT_PROP* pProp = ptrObjectProp.GetStruct();
        BS_ASSERT(pProp);
        ft.hr = pEnum->Next(1, pProp, &ulFetched);
        if (ft.hr == S_FALSE) // end of enumeration
        {
            BS_ASSERT(ulFetched == 0);
            break; // This will destroy the last allocated structure in the VSS_OBJECT_PROP_Ptr destructor
        }
        if (ft.HrFailed())
            ft.TranslateProviderError( VSSDBG_COORD, ProviderId, L"IVssEnumObject::Next" );

        // Add the element to the array.
        // If fails then VSS_OBJECT_PROP_Ptr::m_pStruct will be correctly deallocated
        // by the VSS_OBJECT_PROP_Ptr destructor
        if (!pArray->Add(ptrObjectProp))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot add element to the array");

        // Reset the current pointer to NULL
        ptrObjectProp.Reset(); // The internal pointer was detached into pArray.
    }
}


void CVssProviderManager::QuerySupportedProvidersIntoArray(
    IN      LONG lContext,
    IN      bool bQueryAllProviders,
    IN      VSS_PWSZ pwszVolumeName,
    IN      VSS_OBJECT_PROP_Array* pArray
    )

/*++

Routine Description:

    Fill the array with all providers

Arguments:

    IN      LONG lContext,
    BOOL    bQueryAllProviders         // If false then query only the providers who supports the volume name below.
    VSS_PWSZ    pwszVolumeName      // The volume name that must be checked.
    VSS_OBJECT_PROP_Array* pArray   // where to put the result.

Throws:

    E_OUTOFMEMORY

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [GetProviderInterface failures]
        [lockObj failures]
            E_OUTOFMEMORY

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [InitializeAsProvider() failures]
        E_OUTOFMEMORY

    [IVssSnapshotProvider::IsVolumeSupported() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::QuerySupportedProvidersIntoArray");
    VSS_OBJECT_PROP_Ptr ptrProviderProperties;

    BS_ASSERT(bQueryAllProviders || pwszVolumeName );
    BS_ASSERT(!bQueryAllProviders || !pwszVolumeName );
    BS_ASSERT(pArray);
    BS_ASSERT(IsContextValid(lContext));

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw E_OUTOFMEMORY
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    // Load m_pProvidersArray, if needed.
    LoadInternalProvidersArray();
    BS_ASSERT(m_pProvidersArray);

    // Add elements to the collection
    for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
        // Get the structure object from the array
        VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

        // Get the provider structure
        BS_ASSERT(ptrProperties.GetStruct());
        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

        // Check if we aplying a filter
        if (!bQueryAllProviders)
        {
            // Create the IVssSnapshotProvider interface, if needed
            CComPtr<IVssSnapshotProvider> ptrProvider;
            if (!GetProviderInterface( ProviderProp.m_ProviderId,
                    lContext,
                    ptrProvider,
                    ProviderProp.m_ClassId,
                    ProviderProp.m_eProviderType ))
                continue;

            // Check if the volume is supported by this provider
            BOOL bIsSupported = FALSE;
            BS_ASSERT(ptrProvider);
            ft.hr = ptrProvider->IsVolumeSupported( pwszVolumeName, &bIsSupported );
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD,
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", pwszVolumeName);
            if (ft.HrFailed())
                ft.TranslateProviderError( VSSDBG_COORD, ProviderProp.m_ProviderId,
                    L"IVssSnapshotProvider::IsVolumeSupported() failed with 0x%08lx", ft.hr );

            // If the provider does not support this volume then continue the enumeration.
            if (!bIsSupported)
                continue;
        }

        // Build the structure
        // This might throw E_OUTOFMEMORY
        ptrProviderProperties.InitializeAsProvider( ft,
            ProviderProp.m_ProviderId,
            ProviderProp.m_pwszProviderName,
            ProviderProp.m_eProviderType,
            ProviderProp.m_pwszProviderVersion,
            ProviderProp.m_ProviderVersionId,
            ProviderProp.m_ClassId);

        // Insert provider into the array.
        // If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
        if (!pArray->Add(ptrProviderProperties))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot add element to the array");

        // Reset the current pointer to NULL since the internal pointer was detached into pArray.
        ptrProviderProperties.Reset();
    }
}


void CVssProviderManager::GetProviderItfArrayInternal(
    IN      LONG lContext,
    OUT     CVssSnapshotProviderItfMap** ppMap
    )
/*++

Routine Description:

    Returns the unfilled provider map associated with that context.

Arguments:

    IN      LONG lContext,
    OUT     CVssSnapshotProviderItfMap* pMap

Throws:

    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderItfArrayInternal");

    BS_ASSERT(IsContextValid(lContext));
    BS_ASSERT(ppMap);

    (*ppMap) = NULL;

    // If the provider map is not found, create one
    CVssSnapshotProviderItfMap* pMapTmp = m_mapProviderMapGlobalCache.Lookup(lContext);
    if (pMapTmp == NULL)
    {
        // Allocate a new map
        pMapTmp = new CVssSnapshotProviderItfMap;
        if (pMapTmp == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

        if (!m_mapProviderMapGlobalCache.Add(lContext, pMapTmp))
        {
            delete pMapTmp;
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
        }
    }

    (*ppMap) = pMapTmp;
}


void CVssProviderManager::UnloadGlobalProviderItfCache()
/*++

Routine Description:

    Removes all caches corresponding to global provider interfaces.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::UnloadGlobalProviderItfCache");

    for (int nIndex = 0; nIndex < m_mapProviderMapGlobalCache.GetSize(); nIndex++ )
    {
        CVssSnapshotProviderItfMap* pMapTmp = m_mapProviderMapGlobalCache.GetValueAt(nIndex);
        delete pMapTmp;
    }

    m_mapProviderMapGlobalCache.RemoveAll();
}


BOOL CVssProviderManager::GetProviderInterfaceInternal(
    IN CVssSnapshotProviderItfMap& providerItfMap,
    IN VSS_ID ProviderId,
    IN LONG lContext,
    IN CLSID ClassId,
    IN VSS_PROVIDER_TYPE eProviderType,
    OUT CComPtr<IVssSnapshotProvider> &ptrProviderInterface
    )

/*++

Routine Description:

    Create the interface corresponding to this provider ClassId.
    Calls also OnLoad/SetContext on that provider if the interface is obtained for the first time.

    Places the interface in various caches for better usage.

Arguments:

    IN CVssSnapshotProviderItfMap& providerItfMap,
    IN VSS_ID ProviderId,
    IN LONG lContext,
    IN CLSID ClassId,
    OUT CComPtr<IVssSnapshotProvider> &ptrProviderInterface

Returns:
    TRUE - The interface pointer, if we found a provider that accepted the context.
    FALSE - Oterwise. In the OUT parameter we have NULL if the provider does not accept the context.

Throws:

    E_OUTOFMEMORY

    [CoCreateInstance() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - The provider interface couldn't be created. An error log entry is added describing the error.

    [QueryInterface failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. An error log entry is added describing the error.

    [OnLoad() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

    [SetContext() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterfaceInternal");

    // Reset the interface pointer
    ptrProviderInterface = NULL;

    // Use only Babbage provider for Timewarp Multilayer snapshots
    if ((lContext == VSS_CTX_CLIENT_ACCESSIBLE) && (ProviderId != VSS_SWPRV_ProviderId))
        return FALSE;

    //
    // Try to get the cached provider interface.
    // If we found the interface in the map, return it.
    // (it may be NULL, hovewer, if the provider doesn't support the context),
    //

    CComPtr<IVssSnapshotProvider> ptrInternalProviderItf;
    int nItfIndex = providerItfMap.FindKey(ProviderId);
    if (nItfIndex != -1)
    {
        ptrInternalProviderItf = providerItfMap.Lookup(ProviderId);

        // If the provider was found, but does not support that context, return NULL
        if (ptrInternalProviderItf == NULL)
            return FALSE;

        ptrProviderInterface = ptrInternalProviderItf;
        return TRUE;
    }

    //
    // Create the IVssSnapshotProvider interface and set it to the correct context.
    //

    // Get the class ID, if not already provided.
    if (ClassId == GUID_NULL)
    {
        BS_ASSERT(eProviderType == VSS_PROV_UNKNOWN);
        bool bFound = false;

        // Load m_pProvidersArray, if needed.
        LoadInternalProvidersArray();
        BS_ASSERT(m_pProvidersArray);

        for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
        {
            // Get the structure object from the array
            VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

            // Get the provider structure
            BS_ASSERT(ptrProperties.GetStruct());
            BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
            VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

            // Check if provider was found.
            if (ProviderProp.m_ProviderId != ProviderId)
                continue;

            bFound = true;
            ClassId = ProviderProp.m_ClassId;
            eProviderType = ProviderProp.m_eProviderType;

            // Exit from the loop
            break;
        }

        // Check if we found a provider
        if (!bFound)
            return FALSE;
    }

    // Create the IVssSnapshotProvider instance
    switch(eProviderType)
    {
    case VSS_PROV_SYSTEM:
    case VSS_PROV_SOFTWARE:
        ptrInternalProviderItf.Attach(CVssSoftwareProviderWrapper::CreateInstance(ProviderId, ClassId));
        break;
    case VSS_PROV_HARDWARE:
        ptrInternalProviderItf.Attach(CVssHardwareProviderWrapper::CreateInstance(ProviderId, ClassId));
        break;
    default:
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Unexpected provider type %d", eProviderType);
    }
    BS_ASSERT(ptrInternalProviderItf);

    // Check if we called OnLoad on that provider and if not, load the provider.
    int nOnLoadIndex = m_mapProviderItfOnLoadCache.FindKey(ProviderId);
    if ( nOnLoadIndex == -1 )
    {
        // Call the OnLoad routine
        ft.hr = ptrInternalProviderItf->OnLoad(NULL);
        if (ft.HrFailed())
            ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"IVssProviderNotifications::OnLoad");

        // If everything is OK then add the interface to the array.
        if (!m_mapProviderItfOnLoadCache.Add(ProviderId, ptrInternalProviderItf))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
    }

    //
    //  Check if the provider supports the given context. By default the context is Backup.
    //

    if (lContext == VSS_CTX_BACKUP)
    {
        // The backup context must be supported by all providers. We do not even call SetContext.
        // Add the provider to the proper cache.
        if (!providerItfMap.Add(ProviderId, ptrInternalProviderItf))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
    }
    else
    {
        BS_ASSERT(ptrInternalProviderItf);
        ft.hr = ptrInternalProviderItf->SetContext(lContext);

        // If the context is not supported, then return nothing.
        // Do not ask twice the same provider for this context.
        if (ft.hr == VSS_E_UNSUPPORTED_CONTEXT)
        {
            if (!providerItfMap.Add(ProviderId, NULL))
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
            return FALSE;
        }

        // Check for other failures
        if (ft.HrFailed())
            ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"IVssSnapshotProvider::SetContext");

        // The context is supported. Add the provider to the proper cache.
        if (!providerItfMap.Add(ProviderId, ptrInternalProviderItf))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
    }

    // Return the interface that we found
    ptrProviderInterface = ptrInternalProviderItf;

    return TRUE;
}


BOOL CVssProviderManager::GetProviderInterface(
    IN      VSS_ID ProviderId,
    IN      LONG lContext,
    OUT     CComPtr<IVssSnapshotProvider> & ptrProviderInterface,
    IN      GUID ClassId, /* = GUID_NULL   */
    IN      VSS_PROVIDER_TYPE eProviderType /* = VSS_PROV_UNKNOWN */
    )

/*++

Routine Description:

    Get the interface corresponding to this provider Id.

Arguments:

    IN      VSS_ID ProviderId,
    IN      LONG lContext,
    OUT     CComPtr<IVssSnapshotProvider> & ptrProviderInterface,
    IN      GUID ClassId = GUID_NULL    // Hint - for optimizing interface creation

Return value:
    TRUE, if provider was found, and it supports that context
    FALSE otherwise.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [GetProviderInterfaceInternal() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.

        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. An error log entry is added describing the error.

        [OnLoad() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

        [SetContext() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterface");

    BS_ASSERT(IsContextValid(lContext));
    BS_ASSERT(ptrProviderInterface == NULL);

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    CVssSnapshotProviderItfMap* pMap = NULL;
    GetProviderItfArrayInternal(lContext, &pMap);
    BS_ASSERT(pMap);

    return GetProviderInterfaceInternal( (*pMap), ProviderId, lContext, ClassId, eProviderType, ptrProviderInterface);
}


BOOL CVssProviderManager::GetProviderInterfaceForSnapshotCreation(
    IN      VSS_ID ProviderId,
    OUT CComPtr<IVssSnapshotProvider> &ptrProviderInterface
    )
/*++

Method:

    CVssProviderManager::GetProviderInterfaceForSnapshotCreation

Description:

    To be called only in AddToSnapshotSet

    This method caches a list of provider interfaces per coordinator instance, named the local cache.
    The list is an associative array ProviderID - interface designed to be used only during the
    snapshot creation protocol.

    This method does not rely on the global Provider interface cached into
    the global Providers array. (i.e. on the "global cache").
    This is because we need to handle "auto-delete" snapshots
    and we link the lifetime of all auto-delete snapshots with the lifetime of the
    originating provider interface. Therefore there might be several provider interfaces with different
    lifetimes.

    Each coordinator object will keep on its own lifetime a list of provider interfaces
    that corresponds to each "used" provider ID. If the coordinator object goes away then
    all used provider interfaces will be released, therefore giving a chance to the provider to
    delete the "auto-delete" snapshots.

Algorithm:

    If a cached interface exists in the current coordinator object then it will be returned. Otherwise
    a new instance will be created, inserted into the local cache and returned.

Info:

    The ref count for the returned interface is at least 2 (one reference in the local cache and another
    which is returned.

Throws:

    VSS_E_PROVIDER_NOT_REGISTERED

    [lockObj failures]
        E_OUTOFMEMORY

    [GetProviderInterfaceInternal() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.

        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. An error log entry is added describing the error.

        [OnLoad() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

        [SetContext() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterfaceForSnapshotCreation");

    BS_ASSERT(IsContextValid(m_lContext));
    BS_ASSERT(ptrProviderInterface == NULL);

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    return GetProviderInterfaceInternal( m_mapProviderItfLocalCache,
        ProviderId, m_lContext, GUID_NULL, VSS_PROV_UNKNOWN, ptrProviderInterface);
}


void CVssProviderManager::GetProviderItfArray(
    IN      LONG lContext,
    OUT     CVssSnapshotProviderItfMap** ppMap
    )

/*++

Routine Description:

    Get the array of all provider interfaces

Arguments:

    IN      LONG lContext,
    OUT     CVssSnapshotProviderItfMap** ppMap

Throws:

    E_OUTOFMEMORY

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [GetProviderInterfaceInternal() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.

        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. An error log entry is added describing the error.

        [OnLoad() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

        [SetContext() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderItfArray");

    BS_ASSERT(ppMap);
    (*ppMap) = NULL;

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    // Load m_pProvidersArray, if needed.
    LoadInternalProvidersArray();
    BS_ASSERT(m_pProvidersArray);

    //
    //  Try to load all provider interfaces for the given map
    //  If we will not succeed, the method will throw.
    //

    // Enumerate through all registered providers
    for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
        // Get the structure object from the array
        VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

        // Get the provider structure
        BS_ASSERT(ptrProperties.GetStruct());
        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

        // Load the interface. Ignore the error code.
        CComPtr<IVssSnapshotProvider> ptrProviderInterface;
        GetProviderInterface( ProviderProp.m_ProviderId,
            lContext,
            ptrProviderInterface,
            ProviderProp.m_ClassId,
            ProviderProp.m_eProviderType );
    }

    // Get the map for the given context.
    // If we reach this point, all provider interfaces were loaded for this context.
    CVssSnapshotProviderItfMap* pMap = NULL;
    GetProviderItfArrayInternal(lContext, &pMap);
    BS_ASSERT(pMap);

    (*ppMap) = pMap;
}


/////////////////////////////////////////////////////////////////////////////
//  Provider array management


void CVssProviderManager::LoadInternalProvidersArray()

/*++

Routine Description:

    Fill the array with all providers, if not initialized

Arguments:


Warnings:

    Each time when you access m_pProvidersArray you should call first this method.

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - error while reading from registry. An error log entry is added describing the error.

    [GetProviderProperties() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::LoadInternalProvidersArray");

    VSS_OBJECT_PROP_Ptr ptrProviderProperties;
    WCHAR       wszKeyName[x_nMaxKeynameLen];
    HKEY        hKeyProviders = NULL;
    FILETIME    time;
    LONG        lRes;

    try
    {
        // The lock should be active now.
        BS_ASSERT(m_GlobalCS.IsLocked());

        // If needed, reconstruct the array from registry.
        if (m_pProvidersArray == NULL)
        {
            // Create the collection object. Initial reference count is 0.
            m_pProvidersArray = new VSS_OBJECT_PROP_Array;
            if (m_pProvidersArray == NULL)
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

            // Open the "Providers" key.
            ft.hr = StringCchPrintfW( STRING_CCH_PARAM(wszKeyName), 
                        L"%s\\%s", x_wszVSSKey, x_wszVSSKeyProviders);
            if (ft.HrFailed())
                ft.TranslateGenericError( VSSDBG_COORD, ft.hr, L"StringCchPrintfW()");
            lRes = ::RegOpenKeyExW(
                HKEY_LOCAL_MACHINE, //  IN HKEY hKey,
                wszKeyName,         //  IN LPCWSTR lpSubKey,
                0,                  //  IN DWORD ulOptions,
                KEY_READ,           //  IN REGSAM samDesired,
                &hKeyProviders      //  OUT PHKEY phkResult
                );
            if (lRes != ERROR_SUCCESS)
                ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                    L"RegOpenKeyExW(HKLM,%s\\%s,0,KEY_ALL_ACCESS,&ptr)", x_wszVSSKey, x_wszVSSKeyProviders );
            BS_ASSERT(hKeyProviders);

            // Add elements to the collection
            bool bLastProviderInEnumeration = false;
            for (DWORD dwIndex = 0; !bLastProviderInEnumeration; dwIndex++)
            {
                // Fill wszKeyName with the name of the subkey
                DWORD dwSize = x_nMaxKeynameLen;
                lRes = ::RegEnumKeyExW(
                    hKeyProviders,      // IN HKEY hKey,
                    dwIndex,            // IN DWORD dwIndex,
                    wszKeyName,         // OUT LPWSTR lpName,
                    &dwSize,            // IN OUT LPDWORD lpcbName,
                    NULL,               // IN LPDWORD lpReserved,
                    NULL,               // IN OUT LPWSTR lpClass,
                    NULL,               // IN OUT LPDWORD lpcbClass,
                    &time);             // OUT PFILETIME lpftLastWriteTime
                switch(lRes)
                {
                case ERROR_SUCCESS:
                    BS_ASSERT(dwSize != 0);

                    // Get the provider properties structure
                    ft.hr = CVssProviderManager::GetProviderProperties(
                                hKeyProviders,
                                wszKeyName,
                                ptrProviderProperties
                                );
                    if (ft.HrFailed())
                    {
                        // Do not throw in case that the registry contain keys with bad format.
                        ft.Trace( VSSDBG_COORD,
                                  L"Error on getting Provider properties for %s. [0x%08lx]",
                                  wszKeyName, ft.hr );
                        ft.hr = S_OK;
                        BS_ASSERT(ptrProviderProperties.GetStruct() == NULL);
                        break;  // Continue the iteration
                    }
                    BS_ASSERT(ptrProviderProperties.GetStruct());
                    BS_ASSERT(ptrProviderProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);

                    // Insert it into the array.
                    // If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
                    if (!m_pProvidersArray->Add(ptrProviderProperties))
                        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                                  L"Cannot add element to the array");

                    // Reset the current pointer to NULL since
                    // the internal pointer was detached into pArray.
                    ptrProviderProperties.Reset();

                    break; // Go to Next key, if not find yet.

                case ERROR_NO_MORE_ITEMS:
                    bLastProviderInEnumeration = true;
                    break; // End of iteration

                default:
                    // RegEnumKeyExW failure
                    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                        L"RegEnumKeyExW(HKLM\\%s\\%s,%s,%d,...)",
                        x_wszVSSKey, x_wszVSSKeyProviders, wszKeyName, dwIndex );
                }
            }
        }
        BS_ASSERT(m_pProvidersArray);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    lRes = hKeyProviders? ::RegCloseKey(hKeyProviders): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace( VSSDBG_COORD, L"Error closing the hKeyProviders key. [0x%08lx]", GetLastError());

    // If an error occured then throw it outside
    if (ft.HrFailed()) {
        // Unload the array of providers
        UnloadInternalProvidersArray();
        // Throw the corresponding error
        ft.Throw( VSSDBG_COORD, ft.hr, L"Cannot load the internal providers array [0x%08lx]", ft.hr);
    }
}


void CVssProviderManager::UnloadInternalProvidersArray()

/*++

Routine Description:

    Destroy the static array, if exist.
    Call OnUnload for all providers.
    Deallocate all cached provider interface references.

Arguments:

    None.

Caller:

    You should call this method at program termination.

Throws:

    None.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::UnloadInternalProvidersArray");

    try
    {
        // Lock the global critical section for the duration of this block
        // WARNING: This call may throw exceptions!
        CVssAutomaticLock2 lockObj(m_GlobalCS);

        // Unload all loaded providers
        for (int nIndex = 0; nIndex < m_mapProviderItfOnLoadCache.GetSize(); nIndex++)
        {
            // Get the structure object from the array
            CComPtr<IVssSnapshotProvider> ptrNotif =
                m_mapProviderItfOnLoadCache.GetValueAt(nIndex);

            if (ptrNotif)
            {
                ft.hr = ptrNotif->OnUnload(TRUE);
                if (ft.HrFailed())
                {
                    ft.Trace( VSSDBG_COORD,
                              L"Cannot unload load the internal provider");
                    ft.hr = S_OK;
                }
            }
        }

        // Unload all unused COM server DLLs in this service
        ::CoFreeUnusedLibraries();

        // Release all interfaces
        m_mapProviderItfOnLoadCache.RemoveAll();

        // Delete the provider array.
        if (m_pProvidersArray != NULL)
        {
            // Delete silently the array and all its elements.
            // This will release the provider interfaces too.
            delete m_pProvidersArray;
            m_pProvidersArray = NULL;
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft.hr);
}


void CVssProviderManager::AddProviderIntoArray(
    IN      VSS_ID ProviderId,
    IN      VSS_PWSZ pwszProviderName,
    IN      VSS_PROVIDER_TYPE eProviderType,
    IN      VSS_PWSZ pwszProviderVersion,
    IN      VSS_ID ProviderVersionId,
    IN      CLSID ClassId
    )

/*++

Routine Description:

    Add that provider to the array. This has nothing to do with the registry.
    The caller is supposed to add the provider to the registry also.

    Called only by the RegisterProvider method.

Arguments:

    VSS_ID ProviderId,              // Id of the provider
    VSS_PWSZ pwszProviderName,
    VSS_PROVIDER_TYPE eProviderType,
    VSS_PWSZ pwszProviderVersion,
    VSS_ID ProviderVersionId,
    CLSID ClassId

Throws:

    E_OUTOFMEMORY

    [lockObj failures] or
    [InitializeAsProvider() failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::AddProviderIntoArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    if (m_pProvidersArray)
    {
        VSS_OBJECT_PROP_Ptr ptrProviderProperties;
        ptrProviderProperties.InitializeAsProvider( ft,
            ProviderId,
            pwszProviderName,
            eProviderType,
            pwszProviderVersion,
            ProviderVersionId,
            ClassId );

        // Insert it into the array.
        // If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
        if (!m_pProvidersArray->Add(ptrProviderProperties))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot add element to the array");

        // Reset the current pointer to NULL since
        // the internal pointer was detached into pArray.
        ptrProviderProperties.Reset();
    }
}


bool CVssProviderManager::RemoveProviderFromArray(
    IN      VSS_ID ProviderId
    )

/*++

Routine Description:

    Eliminates the corresponding array element.
    WARNING: Also load, unload and unregister the provider with the given Id.

    Called only by the UnregisterProvider method

Arguments:

    VSS_ID ProviderId           // The provider Id

Return value:

    true - if the provider was sucessfully removed
    false - if there is no provider registered under that ID.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::RemoveProviderFromArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    // Load m_pProvidersArray, if needed.
    LoadInternalProvidersArray();
    BS_ASSERT(m_pProvidersArray);

    // Find that provider
    bool bFound = false;
    int nIndex = -1;
    for (nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
        // Get the structure object from the array
        VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

        // Get the provider structure
        BS_ASSERT(ptrProperties.GetStruct());
        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

        // Check if provider was found.
        if (ProviderProp.m_ProviderId != ProviderId)
            continue;

        // Exit from the loop
        bFound = true;
        break;
    }

    if (bFound)
    {
        // Delete the element from the array.
        m_pProvidersArray->RemoveAt(nIndex);

        // Remove the entries from the caches.
        for (int lContextIdx = 0; lContextIdx < m_mapProviderMapGlobalCache.GetSize(); lContextIdx++)
        {
            // Get the provider cache for this type of context
            CVssSnapshotProviderItfMap* pMap = m_mapProviderMapGlobalCache.GetValueAt(lContextIdx);

            // Remove the associated provider interface.
            if (pMap)
                pMap->Remove(ProviderId);
        }

        // Unload the provider, if loaded
        CComPtr<IVssSnapshotProvider> ptrNotif = m_mapProviderItfOnLoadCache.Lookup(ProviderId);
        if (ptrNotif)
        {
            ft.hr = ptrNotif->OnUnload(TRUE);
            if (ft.HrFailed())
                ft.Trace( VSSDBG_COORD, L"Cannot unload the internal provider with Provider Id"
                    WSTR_GUID_FMT, GUID_PRINTF_ARG(ProviderId));
        }
        m_mapProviderItfOnLoadCache.Remove(ProviderId);

        // Unload all unused COM server DLLs in this service
        ::CoFreeUnusedLibraries();
    }

    return bFound;
}


/////////////////////////////////////////////////////////////////////////////
// CVssProviderManager private methods



HRESULT CVssProviderManager::GetProviderProperties(
    IN  HKEY hKeyProviders,
    IN  LPCWSTR wszProviderKeyName,
    OUT VSS_OBJECT_PROP_Ptr& ptrProviderProperties
    )

/*++

Routine Description:

    Get provider properties from registry.

Arguments:

    IN  HKEY hKeyProviders,                         // The providers Key
    IN  LPCWSTR wszProviderKeyName,                 // The provider Key name (actually a guid)
    OUT VSS_OBJECT_PROP_Ptr& ptrProviderProperties  // will return an allocated structure containing provider properties

Return values:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry failures. An error log entry is added describing the error.

    [QueryStringValue failures] or
    [QueryDWORDValue] failures
        E_OUTOFMEMORY
        E_UNEXPECTED
            - on registry failures. An error log entry is added describing the error.

Throws:

    None.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderProperties");

    HKEY hKeyProvider = NULL;
    HKEY hKeyCLSID = NULL;
    LONG lRes;

    BS_ASSERT( hKeyProviders );
    BS_ASSERT( wszProviderKeyName != NULL && wszProviderKeyName[0] != L'\0' );
    BS_ASSERT( ptrProviderProperties.GetStruct() == NULL );

    try
    {
        // Convert wszProviderKeyName into ProviderId.
        VSS_ID ProviderId;
        ft.hr = ::CLSIDFromString( W2OLE(const_cast<LPWSTR>(wszProviderKeyName)), &ProviderId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CLSIDFromString(%s)", wszProviderKeyName);

        // Open the provider key
        lRes = ::RegOpenKeyExW(
            hKeyProviders,      //  IN HKEY hKey,
            wszProviderKeyName, //  IN LPCWSTR lpSubKey,
            0,                  //  IN DWORD ulOptions,
            KEY_READ,           //  IN REGSAM samDesired,
            &hKeyProvider       //  OUT PHKEY phkResult
            );
        if (lRes != ERROR_SUCCESS)
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"RegOpenKeyExW(hKeyProviders,%s,KEY_READ,...)", wszProviderKeyName);
        BS_ASSERT(hKeyProvider);

        // Get the provider name
        WCHAR wszProviderName[x_nMaxValueLen];
        QueryStringValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            x_wszVSSProviderValueName,
            x_nMaxValueLen,
            wszProviderName
            );
        BS_ASSERT(wszProviderName[0] != L'\0');

        // Get the provider type
        DWORD dwProviderType = 0;
        QueryDWORDValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            x_wszVSSProviderValueType,
            &dwProviderType
            );

        VSS_PROVIDER_TYPE eProviderType = VSS_PROV_UNKNOWN;
        switch(dwProviderType) {
        case VSS_PROV_SYSTEM:
        case VSS_PROV_SOFTWARE:
        case VSS_PROV_HARDWARE:
            eProviderType = (VSS_PROVIDER_TYPE) dwProviderType;
            break;
        default:
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"QueryDWORDValue(hProvider,%s,%s,%d)",
                wszProviderKeyName,
                x_wszVSSProviderValueType,
                dwProviderType);
        }

        // Get the provider version string
        WCHAR wszProviderVersion[x_nMaxValueLen];
        QueryStringValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            x_wszVSSProviderValueVersion,
            x_nMaxValueLen,
            wszProviderVersion
            );

        // Get the provider version Id
        WCHAR wszProviderVersionId[x_nMaxValueLen];
        QueryStringValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            x_wszVSSProviderValueVersionId,
            x_nMaxValueLen,
            wszProviderVersionId
            );
        BS_ASSERT(wszProviderVersionId[0] != L'\0');

        // Convert wszValueBuffer into ProviderVersionId .
        VSS_ID ProviderVersionId;
        ft.hr = ::CLSIDFromString(W2OLE(wszProviderVersionId), &ProviderVersionId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr,
                L"CLSIDFromString(%s)", wszProviderVersionId);

        // Open the CLSID key of that provider
        lRes = ::RegOpenKeyExW(
            hKeyProvider,           //  IN HKEY hKey,
            x_wszVSSKeyProviderCLSID, //  IN LPCWSTR lpSubKey,
            0,                      //  IN DWORD ulOptions,
            KEY_READ,               //  IN REGSAM samDesired,
            &hKeyCLSID              //  OUT PHKEY phkResult
            );
        if (lRes != ERROR_SUCCESS)
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"CLSIDFromString(%s)", wszProviderVersionId);
        BS_ASSERT(hKeyCLSID);

        // Get the content of the default value
        WCHAR wszClsid[x_nMaxValueLen];
        QueryStringValue( ft,
            hKeyCLSID,
            x_wszVSSKeyProviderCLSID,
            x_wszVSSCLSIDValueName,
            x_nMaxValueLen,
            wszClsid
            );
        BS_ASSERT(wszClsid[0] != L'\0');

        // Get the clsid. Remark: if W2OLE fails a SE is thrown
        CLSID ClassId;
        ft.hr = ::CLSIDFromString(W2OLE(wszClsid), &ClassId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr,
                L"CLSIDFromString(%s)", wszClsid);

        // Initialize the Properties pointer. If an error occurs an exception is thrown.
        ptrProviderProperties.InitializeAsProvider(ft,
            ProviderId,
            wszProviderName,
            eProviderType,
            wszProviderVersion,
            ProviderVersionId,
            ClassId);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    lRes = hKeyProvider? ::RegCloseKey(hKeyProvider): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace(VSSDBG_COORD, L"Error closing the hKeyProvider key. [0x%08lx]", GetLastError());

    lRes = hKeyCLSID? ::RegCloseKey(hKeyCLSID): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace(VSSDBG_COORD, L"Error closing the hKeyCLSID key. [0x%08lx]", GetLastError());

    // If something went wrong, the out must be NULL.
    if (ft.HrFailed()) {
        BS_ASSERT( ptrProviderProperties.GetStruct() == NULL );
    }

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  Local state management


void CVssProviderManager::Activate() throw(HRESULT)

/*++

Routine Description:

    Mark the current object as stateful.

    The concrete case the current object is a coordinator interface. This interface have no state
    in the moment when StartSnapshotSet is called. After that the state will contain the
    snapshot set Id, the list of involved snapshots (providers), etc.

    When DoSnapshotSet is called then the state is lost and the object must be taken out from the
    global list of stategful objects.

    This whole thing is done to allow AbortAllSnapshotsInProgress to take action on all objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::Activate");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    if (!m_bHasState)
    {
        m_pNext = m_pPrev = NULL; // for safety

        if (m_pStatefulObjList != NULL)
        {
            BS_ASSERT(m_pStatefulObjList->m_pPrev == NULL);
            m_pStatefulObjList->m_pPrev = this;
        }
        m_pNext = m_pStatefulObjList;
        m_pStatefulObjList = this;
        m_bHasState = true;
    }
}


void CVssProviderManager::Deactivate() throw(HRESULT)

/*++

Routine Description:

    Mark the current object as stateless.

    The concrete case the current object is a coordinator interface. This interface have no state
    in the moment when StartSnapshotSet is called. After that the state will contain the
    snapshot set Id, the list of involved snapshots (providers), etc.

    When DoSnapshotSet is called then the state is lost and the object must be taken out from the
    global list of stategful objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::Deactivate");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    if (m_bHasState)
    {
        if (m_pPrev != NULL) // we are in the middle
            m_pPrev->m_pNext = m_pNext;
        else // we are the first
        {
            BS_ASSERT(m_pStatefulObjList == this);
            m_pStatefulObjList = m_pNext;
        }

        if (m_pNext != NULL)
            m_pNext->m_pPrev = m_pPrev;

        m_pNext = m_pPrev = NULL;
        m_bHasState = false;

        // Warning: this call may throw errors!
        OnDeactivate();
    }
}


void CVssProviderManager::DeactivateAll()

/*++

Routine Description:

    Deactivate all activated objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [OnDeactivate failures]
        TBD

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::DeactivateAll");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    while (m_pStatefulObjList)
    {
        CVssProviderManager* pFirstObj = m_pStatefulObjList;

        BS_ASSERT(pFirstObj->m_bHasState);
        pFirstObj->m_bHasState = false;

        BS_ASSERT(pFirstObj->m_pPrev == NULL);
        m_pStatefulObjList = pFirstObj->m_pNext;

        if (pFirstObj->m_pNext != NULL)
        {
            BS_ASSERT(pFirstObj->m_pNext->m_pPrev == pFirstObj);
            pFirstObj->m_pNext->m_pPrev = NULL;

            pFirstObj->m_pNext = NULL;
        }

        pFirstObj->OnDeactivate();
    }
}


bool CVssProviderManager::AreThereStatefulObjects()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::AreThereStatefulObjects");

    return (m_pStatefulObjList != NULL);
};


/////////////////////////////////////////////////////////////////////////////
//  Context-related routines


LONG CVssProviderManager::GetContextInternal()

/*++

Method:

    CVssProviderManager::GetContextInternal

Description:

    Returns the existing context

--*/

{
    BS_ASSERT(m_bContextIsSet);
    BS_ASSERT(IsContextValid(m_lContext));

    return m_lContext;
}


bool CVssProviderManager::IsContextValid(
    IN  LONG lContext
    )

/*++

Method:

    CVssProviderManager::IsContextValid

Description:

    Returns the existing context

--*/

{
    if (lContext == VSS_CTX_ALL)
        return true;

    lContext &= ~(VSS_VOLSNAP_ATTR_TRANSPORTABLE 
        | VSS_VOLSNAP_ATTR_DIFFERENTIAL 
        | VSS_VOLSNAP_ATTR_PLEX);
    
    return (lContext == VSS_CTX_BACKUP) ||
           (lContext == VSS_CTX_CLIENT_ACCESSIBLE) ||
           (lContext == VSS_CTX_APP_ROLLBACK) ||
           (lContext == VSS_CTX_NAS_ROLLBACK) ||
           (lContext == VSS_CTX_FILE_SHARE_BACKUP);
}


void CVssProviderManager::SetContextInternal(
    IN      LONG lContext
    )

/*++

Method:

    CVssProviderManager::SetContext

Description:

    Called only once to set the context for the snapshot creation process

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::SetContextInternal");

    // Don't set the context twice...
    if (m_bContextIsSet)
    {
        BS_ASSERT(m_lContext == lContext);
        return;
    }

    BS_ASSERT(m_lContext == VSS_CTX_BACKUP);
    BS_ASSERT(IsContextValid(lContext));

    if (m_lContext == VSS_CTX_BACKUP)
        m_lContext = lContext;

    m_bContextIsSet = true;
}




/////////////////////////////////////////////////////////////////////////////
//  Constructors and destructors


CVssProviderManager::~CVssProviderManager()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::~CVssProviderManager");

    BS_ASSERT((m_pNext == NULL) && (m_pPrev == NULL) && !m_bHasState );

    // The local cache interfaces must be automatically released
    // Here the auto-delete snapshots are deleted.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\setup.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    setup.cxx

Abstract:

    Implements the Volume Snapshot Service.

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     06/30/1999  Created.
    aoltean     07/23/1999  Making registration code more error-prone.
                            Changing the service name.
    aoltean     08/11/1999  Initializing m_bBreakFlagInternal
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding some headers
	aoltean		10/05/1999	Moved from svc.cxx
	aoltean		03/10/2000	Simplifying Setup

--*/

////////////////////////////////////////////////////////////////////////
//  Includes

#include "StdAfx.hxx"
#include <comadmin.h>
#include "resource.h"

// General utilities
#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "memory"
#include "vs_reg.hxx"
#include "vs_sec.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSETUC"
//
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//  constants


// Registry keys/values
WCHAR x_wszVssAppLaunchPermissionKeyNameFMT[]  = L"APPID\\{56BE716B-2F76-4dfa-8702-67AE10044F0B}";



///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//


HRESULT CVsServiceModule::RegisterServer(
    BOOL bRegTypeLib
    )

/*++

Routine Description:

    Register the new COM server.

Arguments:

    bRegTypeLib,

Remarks:

    Called by CVsServiceModule::_WinMain()

Return Value:

    S_OK
    E_UNEXPECTED  if an error has occured. See trace file for details

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::RegisterServer" );

    try
    {
        //
        // Initialize the COM library
        //

        ft.hr = CoInitialize(NULL);
        if ( ft.HrFailed() )
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"CoInitialize failed 0x%08lx", ft.hr );

        // Add registry entries for CLSID and APPID by running proper scripts
        ft.hr = UpdateRegistryFromResource(IDR_VSSVC, TRUE);
        if ( ft.HrFailed() )
			ft.Trace( VSSDBG_COORD, L"UpdateRegistryFromResource failed 0x%08lx", ft.hr );

        //
        //  Add the VSS event log source
        //  (it cannot be added with the RGS script)
        //  We assume that the key already exist (it should be created by the RGS above)
        //
        CVssRegistryKey keyEventLogSource(KEY_SET_VALUE | KEY_WRITE);
        if (!keyEventLogSource.Open(HKEY_LOCAL_MACHINE, g_wszVssEventLogSourceKey))
            keyEventLogSource.Create(HKEY_LOCAL_MACHINE, g_wszVssEventLogSourceKey);

        // Add the new registry values
        keyEventLogSource.SetValue(g_wszVssEventTypesSupportedValName, g_dwVssEventTypesSupported);
        keyEventLogSource.SetValue(g_wszVssEventMessageFileValName, g_wszVssBinaryPath, REG_EXPAND_SZ);

        // Register the type library and add object map registry entries
        ft.hr = CComModule::RegisterServer(bRegTypeLib);
        if ( ft.HrFailed() )
			ft.Trace( VSSDBG_COORD, L"UpdateRegistryFromResource failed 0x%08lx", ft.hr );

        // Create a new LaunchPermissions SD for VSS that includes backup operators
        CreateLaunchPermissions();

        //
        // Uninitialize the COM library
        //
        CoUninitialize();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


// Create a new LaunchPermissions SD for VSS that includes backup operators
void CVsServiceModule::CreateLaunchPermissions()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::CreateLaunchPermissions" );

    //  Open the default LaunchPermissions key as READ_ONLY
    CVssRegistryKey defaultKey(KEY_READ);
    defaultKey.Open(HKEY_LOCAL_MACHINE, x_wszDefaultLaunchPermissionKeyName);

    //  Read the default LaunchPermissions value (self-relative SD)
    LPBYTE pbData = NULL;
    DWORD dwSize = 0;
    defaultKey.GetBinaryValue(x_wszDefaultLaunchPermissionValueName, pbData, dwSize);
    BS_ASSERT(dwSize >= SECURITY_DESCRIPTOR_MIN_LENGTH);
    std::auto_ptr<BYTE>  pbInitialSD(pbData);
    PSECURITY_DESCRIPTOR pInitialSD = (PSECURITY_DESCRIPTOR)pbInitialSD.get();

    // Make sure the security descriptor is valid
    if (!::IsValidSecurityDescriptor( pInitialSD ))
		ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
		    L"IsValidSecurityDescriptor(%p)", pInitialSD);

    // Create an Absolute SD
    CSecurityDescriptor sdAbsolute;
    ft.hr = sdAbsolute.Attach(pInitialSD);
    if (ft.HrFailed())
        ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CSecurityDescriptor::Attach(%p)", pInitialSD);

    // Initialize group and owner from the those in the DefaultLaunchPermission value
    // Note: CSecurityDescriptor::Attach tries to do that but it has a BUG - it calls
    //  GetSecurityDescriptorOwner of the internal member - m_pSD - rather than of the 
    //  input SD - pSelfRelativeSD - as it should...
    PSID pOwner = NULL;
    PSID pGroup = NULL;
    BOOL bDefOwner;
    BOOL bDefGroup;
    if (GetSecurityDescriptorOwner(pInitialSD, &pOwner, &bDefOwner)) {
        ft.hr = sdAbsolute.SetOwner(pOwner, bDefOwner);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, 
                L"CSecurityDescriptor::SetOwner()");
    } else {
		ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
		    L"GetSecurityDescriptorOwner(%p)", pInitialSD);
    }

    if (GetSecurityDescriptorGroup(pInitialSD, &pGroup, &bDefGroup)) {
        ft.hr = sdAbsolute.SetGroup(pGroup, bDefGroup);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, 
                L"CSecurityDescriptor::SetGroup()");
    } else {
		ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
		    L"GetSecurityDescriptorGroup(%p)", pInitialSD);
    }

    // Create the backup operators SID
    CAutoSid asidBackupOperators;
    asidBackupOperators.CreateBasicSid(WinBuiltinBackupOperatorsSid);

    // lookup name of backup operators group
    WCHAR wszBackupOperators[MAX_PATH];
    DWORD dwNameSize = MAX_PATH;
    WCHAR wszDomainName[MAX_PATH];
    DWORD dwDomainNameSize = MAX_PATH;
    SID_NAME_USE snu;
    if (!::LookupAccountSid
            (
            NULL,
            asidBackupOperators.Get(),
            wszBackupOperators, &dwNameSize,
            wszDomainName, &dwDomainNameSize,
            &snu
            ))
    {
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
            L"LookupAccountSid(NULL, %p, %p, [%d], %p, [%d], [%d]) == 0x%08lx",
            asidBackupOperators.Get(), 
            wszBackupOperators, dwNameSize,
            wszDomainName, dwDomainNameSize,
            snu, GetLastError()
            );
    }

    // Add backup operators as allowed to launch the COM server 
    ft.hr = sdAbsolute.Allow(wszBackupOperators, COM_RIGHTS_EXECUTE);
    if (ft.HrFailed())
        ft.TranslateGenericError(VSSDBG_COORD, ft.hr, 
            L"CSecurityDescriptor::Allow(%s, COM_RIGHTS_EXECUTE)", wszBackupOperators);
    BS_ASSERT(::IsValidSecurityDescriptor(sdAbsolute));

    // Get the size of the new Self-relative SD
    DWORD dwNewSelfRelativeSdSize = GetSecurityDescriptorLength(sdAbsolute);
    BS_ASSERT(dwNewSelfRelativeSdSize >= SECURITY_DESCRIPTOR_MIN_LENGTH);

    // Get the new self-relative SD
    std::auto_ptr<BYTE>  pbFinalSD(new BYTE[dwNewSelfRelativeSdSize]);
    if (pbFinalSD.get() == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error [%ld]", dwNewSelfRelativeSdSize);

    // Fill the self-relative SD contents
    if (!::MakeSelfRelativeSD( sdAbsolute, (PSECURITY_DESCRIPTOR) pbFinalSD.get(), &dwNewSelfRelativeSdSize))
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
            L"MakeSelfRelativeSD(%p, %p, [%lu])", 
            (PSECURITY_DESCRIPTOR)sdAbsolute, pbFinalSD, dwNewSelfRelativeSdSize);
    
    //  Open the VSS LaunchPermissions key
    CVssRegistryKey vssLaunchPermKey;
    vssLaunchPermKey.Open(HKEY_CLASSES_ROOT, x_wszVssAppLaunchPermissionKeyNameFMT);

    // Save the new security descriptor
    vssLaunchPermKey.SetBinaryValue(x_wszAppLaunchPermissionValueName, pbFinalSD.get(), dwNewSelfRelativeSdSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\snap_set.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Coord.cxx | Implementation of CVssSnapshotSetObject
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     07/23/1999  Adding List, moving Admin functions in the Admin.cxx
    aoltean     08/11/1999  Adding support for Software and test provider
    aoltean     08/18/1999  Adding events. Making itf pointers CComPtr.
                            Renaming XXXSnapshots -> XXXSnapshot
    aoltean     08/18/1999  Renaming back XXXSnapshot -> XXXSnapshots
                            More stabe state management
                            Resource deallocations is fair
                            More comments
                            Using CComPtr
    aoltean     09/09/1999  Moving constants in coord.hxx
                            Add Security checks
                            Add argument validation.
                            Move Query into query.cpp
                            Move AddvolumesToInternalList into private.cxx
                            dss -> vss
    aoltean     09/21/1999  Adding a new header for the "ptr" class.
    aoltean     09/27/1999  Provider-generic code.
    aoltean     10/04/1999  Treatment of writer error codes.
    aoltean     10/12/1999  Adding HoldWrites, ReleaseWrites
    aoltean     10/13/1999  Moving from coord.cxx into snap_set.cxx
    brianb      04/20/2000  Added SQL wrapper stuff
    brianb      04/21/2000  Disable SQL writer until new ODBC driver is available

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"

#include "provmgr.hxx"
#include "snap_set.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_filter.hxx"
#include "callback.hxx"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSNPSC"
//
////////////////////////////////////////////////////////////////////////


// global semaphore used to serialize creation of snapshot sets
const LPCWSTR x_pwszVssvcPublisher = L"VssvcPublisher";

// global semaphore used to serialize creation of snapshot sets
LONG g_hSemSnapshotSets = 0;

// global semaphore used to serialize SimulateSnapshotFreeze after cancellation
LONG g_hSemSnapshotSetCancelled = 0;



/////////////////////////////////////////////////////////////////////////////
//  CVssSnapshotSetObject


HRESULT CVssSnapshotSetObject::StartSnapshotSet(
    OUT     VSS_ID*     pSnapshotSetId
    )
/*++

Routine description:

    Starts a new calling sequence for snapshot creation.
    Called by CVssCoordinator::StartSnapshotSet.

Arguments:

    OUT     VSS_ID*     pSnapshotSetId

Return values:

    E_OUTOFMEMORY
    VSS_E_SNAPSHOT_SET_IN_PROGRESS
        - StartSnapshotSet is called while another snapshot set in in the
          process of being created
    E_UNEXPECTED
        - if CoCreateGuid fails

    [Deactivate() failures] or
    [Activate() failures]
        [lockObj failures]
            E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::StartSnapshotSet" );

    try
    {
        BS_ASSERT(pSnapshotSetId);
        BS_ASSERT(IsContextValid(GetContextInternal()));

        // Mark current set as not cancelled. This must be done before aquiring the SemSnapshotSets
        // flag in order to prevent race-condition with SimulateSnapshotFreeze
        // Note that if the previous set was started, then cancelled, this will clear up the 
        // cancellation flag, even if the cancelled set is still in progress
        InterlockedCompareExchange(&g_hSemSnapshotSetCancelled, 0, 1);

        // Prevent simultaneous creation of multiple snapshot sets on the same machine.
        if (InterlockedCompareExchange(&g_hSemSnapshotSets, 1, 0) != 0)
            ft.Throw
                (
                VSSDBG_COORD,
                VSS_E_SNAPSHOT_SET_IN_PROGRESS,
                L"Snapshot set creation is already in progress."
                );

        BS_ASSERT(!m_bHasAcquiredSem);
        m_bHasAcquiredSem = true;

        // Verifying state...
        if (m_lCoordState != VSSC_Initialized) {
            // Mark the ending of the snapshot set creation!
            // Warning: may throw E_OUTOFMEMORY
            Deactivate();
        }

        // We should be in the correct state.
        BS_ASSERT(m_lCoordState == VSSC_Initialized);
        BS_ASSERT(m_lSnapshotsCount == 0);

        // Allocate a new Snapshot Set ID
        CVssGlobalSnapshotSetId::NewID();

        // Mark the beginning of the snapshot set creation
        // WARNING: This call may throw an E_OUTOFMEMORY exception!
        Activate();

        // Initialize the state of the snapshot set object.
        // Do not initialize any state that is related to the background state.
        ft.Trace( VSSDBG_COORD, L"Initialize the state of the snapshot set object" );
        (*pSnapshotSetId) = CVssGlobalSnapshotSetId::GetID();
        m_lCoordState = VSSC_SnapshotSetStarted;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed() && m_bHasAcquiredSem)
        {
        // Reset the allocated Snapshot Set ID
        CVssGlobalSnapshotSetId::ResetID();

        InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
        m_bHasAcquiredSem = false;
        }
    else if (ft.HrSucceeded())
    	{
    	try
    	  {
    	  if (m_bShutdownNeeded)
           DoBackupShutdown();

           // store the information needed to perform a shutdown event
           m_bShutdownNeeded = false;
           m_lastSnapshotSet = CVssGlobalSnapshotSetId::GetID();
    	  }
    	  VSS_STANDARD_CATCH(ft)

    	  if (ft.HrFailed())
    	  	ft.Trace(VSSDBG_COORD, L"failed to call BackupShutdown");
    	}
    
    return ft.hr;
}


HRESULT CVssSnapshotSetObject::AddToSnapshotSet(
    IN      VSS_PWSZ    pwszVolumeName,
    IN      VSS_ID      ProviderId,
    OUT     VSS_ID      *pSnapshotId
    )
/*++

Routine description:

    Adds a volume to the snapshot set

Arguments:

    pwszVolumeName, - volume name (to be parsed by GetVolumeNameForVolumeMountPointW)
    ProviderId      - ID of the provider or GUID_NULL for automatic choosing of the provider
    ppSnapshot      - If non-NULL then will hold a pointer for the returned IVssSnapshot

Return values:

    E_OUTOFMEMORY
    VSS_E_BAD_STATE
        - wrong calling sequence.
    E_INVALIDARG
        - Invalid arguments (for example the volume name is invalid).
    VSS_E_VOLUME_NOT_SUPPORTED
        - The volume is not supported by any registered providers

    [GetSupportedProviderId() failures]
        E_OUTOFMEMORY
        E_INVALIDARG
            - if the volume is not in the correct format.
        VSS_E_VOLUME_NOT_SUPPORTED
            - If the given volume is not supported by any provider

        [QuerySupportedProvidersIntoArray() failures]
            E_OUTOFMEMORY

            VSS_E_UNEXPECTED_PROVIDER_ERROR
                Unexpected provider error on calling IsVolumeSupported

            [lockObj failures]
                E_OUTOFMEMORY

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [GetProviderInterface failures]
                [lockObj failures]
                    E_OUTOFMEMORY

                [GetProviderInterfaceInternal() failures]
                    E_OUTOFMEMORY

                    [CoCreateInstance() failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - The provider interface couldn't be created. An error log entry is added describing the error.

                    [QueryInterface failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - Unexpected provider error. An error log entry is added describing the error.

                    [OnLoad() failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - Unexpected provider error. The error code is logged into the event log.
                        VSS_E_PROVIDER_VETO
                            - Expected provider error. The provider already did the logging.

                    [SetContext() failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - Unexpected provider error. The error code is logged into the event log.

            [InitializeAsProvider() failures]
                E_OUTOFMEMORY

            [IVssSnapshotProvider::IsVolumeSupported() failures]
                E_INVALIDARG
                    NULL pointers passed as parameters or a volume name in an invalid format.
                E_OUTOFMEMORY
                    Out of memory or other system resources
                VSS_E_PROVIDER_VETO
                    An error occured while opening the IOCTL channel. The error is logged.
                VSS_E_OBJECT_NOT_FOUND
                    If the volume name does not correspond to an existing mount point

    [GetProviderInterfaceForSnapshotCreation() failures]
        VSS_E_PROVIDER_NOT_REGISTERED

        [lockObj failures]
            E_OUTOFMEMORY

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [CVssQueuedVolumesList::AddVolume() failures]
        E_UNEXPECTED
            - The thread state is incorrect. No logging is done - programming error.
        VSS_E_OBJECT_ALREADY_EXISTS
            - The volume was already added to the snapshot set.
        VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
            - The maximum number of volumes was reached.
        E_OUTOFMEMORY

        [Initialize() failures]
            E_OUTOFMEMORY

    [BeginPrepareSnapshot() failures]
        E_INVALIDARG
        VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
        VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AddToSnapshotSet" );
    WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
    VSS_ID InternalProviderId = ProviderId;

    bool bVolumeInserted = false;
    bool bProviderItfInserted = false;

    try
    {
        BS_ASSERT(::wcslen(pwszVolumeName) > 0);
        BS_ASSERT(IsContextValid(GetContextInternal()));
        BS_ASSERT(pSnapshotId);

        // Verifying state
        if (m_lCoordState != VSSC_SnapshotSetStarted)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                      L"Snapshot Set in incorrect state %ld", m_lCoordState);

        // Getting the volume name
        GetVolumeNameWithCheck(VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED,
            pwszVolumeName,
            wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal));

        // If the caller did not specified a provider
        if (InternalProviderId == GUID_NULL) {
            // Choose a provider that works.
            // This call may throw!
            GetSupportedProviderId( wszVolumeNameInternal, &InternalProviderId );
            ft.Trace( VSSDBG_COORD, L"Provider found: " WSTR_GUID_FMT, GUID_PRINTF_ARG(InternalProviderId) );

            BS_ASSERT(InternalProviderId != GUID_NULL);
        }

        // Get the provider interface
        CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.Lookup( InternalProviderId );
        if (pProviderItf == NULL) {
            // The ref count will be 2 since the method keeps another
            // copy in its internal local cache.
            // We ignore the return value since we know for sure that the provider must return that interface
            GetProviderInterfaceForSnapshotCreation( InternalProviderId, pProviderItf );
            if (pProviderItf == NULL)
            {
                // IsVolumeSupported was already called in coord.cxx!AddToSnapshotSet.
                // It is impossible to succeed there and fail here.
                BS_ASSERT(false);
                // The volume is not supported. Defensive code.
                ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED,
                    L"Volume %s not supported by provider " WSTR_GUID_FMT L"in the context %ld",
                    pwszVolumeName,
                    GUID_PRINTF_ARG(InternalProviderId),
                    GetContextInternal()
                    );
            }

            // Add the interface to the array. In this moment the reference count will become 3.
            // We cannot use the local cache for keeping these interfaces because we need to
            // differentiate between provider interfaces involved in the current snapshot set
            // and provider interfaces involved in auto-delete snapshots.
            if ( !m_mapProviderItfInSnapSet.Add( InternalProviderId, pProviderItf ) )
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

            // Mark the provider interface as inserted
            bProviderItfInserted = true;
        }

        // Add volume to the thread set.
        // TBD: In the future snapshots will be allowed without involving Lovelace.
        ft.hr = m_VolumesList.AddVolume(wszVolumeNameInternal, pwszVolumeName);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
                      L"Error adding volume %s to the thread set. 0x%08lx",
                      wszVolumeNameInternal, ft.hr);

        // Mark the volume as inserted
        bVolumeInserted = true;

        // Create the snapshot Id
        VSS_ID SnapshotId;
        ft.hr = ::CoCreateGuid(&SnapshotId);
        if (ft.HrFailed())
            ft.TranslateGenericError( VSSDBG_COORD, ft.hr, L"CoCreateGuid()");

        // Prepare the snapshot
        ft.hr = pProviderItf->BeginPrepareSnapshot(
                    CVssGlobalSnapshotSetId::GetID(),
                    SnapshotId,
                    wszVolumeNameInternal,
                    GetContextInternal()     // ??? Pass in entire context, or just some of it ???
                    );
        // Check if the volume is a non-supported one.
        if ( ft.hr == E_INVALIDARG ) {
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                L"Invalid arguments to BeginPrepareSnapshot for provider " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.hr == VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER ) {
            BS_ASSERT( ProviderId != GUID_NULL );
            ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER,
                L"Volume %s not supported by provider " WSTR_GUID_FMT,
                wszVolumeNameInternal, GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.hr == VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED ) {
            ft.Throw( VSSDBG_COORD, VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED,
                L"Volume %s has too many snapshots" WSTR_GUID_FMT,
                wszVolumeNameInternal, GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.HrFailed() )
            ft.TranslateProviderError(VSSDBG_COORD, InternalProviderId,
                L"BeginPrepareSnapshot("WSTR_GUID_FMT L","WSTR_GUID_FMT L",%s)",
                GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()),
                GUID_PRINTF_ARG(SnapshotId),
                wszVolumeNameInternal);

        // Increment the number of snapshots on this set
        m_lSnapshotsCount++;

        // Set the Snapshot ID
        (*pSnapshotId) = SnapshotId;

        // The pProviderItf reference count will be again 2
        // (the itfs in local cache and in the snapshot set cache) since the smart pointer is gone
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed()) {
        // We do not need to abort the snapshot on error since BeginPrepareSnapshot is the last call.

        // Remove the volume from the list, if added
        if (bVolumeInserted) {
            HRESULT hr2 = m_VolumesList.RemoveVolume( wszVolumeNameInternal );
            if (FAILED(hr2)) {
                BS_ASSERT(false);
                ft.Trace( VSSDBG_COORD, L"Warning: Error deleting the volume 0x%08lx", hr2);
            }
        }

        // Remove the new interface, if added
        if (bProviderItfInserted) {
            if (!m_mapProviderItfInSnapSet.Remove( InternalProviderId ))
                ft.Trace( VSSDBG_COORD, L"Warning: Error deleting the added interface");
        }
    }

    return ft.hr;
}


HRESULT CVssSnapshotSetObject::DoSnapshotSet()
/*++

Routine description:

    Performs DoSnapshotSet in a synchronous manner.

Error codes:

    E_OUTOFMEMORY
        - lock statement.
    VSS_E_BAD_STATE
        - Wrong calling sequence.

    [EndPrepareAllSnapshots() failures] or
    [PreCommitAllSnapshots() failures] or
    [CommitAllSnapshots() failures] or
    [PostCommitAllSnapshots() failures]

        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Invalid number of prepared snapshots

        [EndPrepareSnapshots() failures] or
        [PreCommitSnapshots() failures] or
        [CommitSnapshots() failures] or
        [PostCommitSnapshots() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
            VSS_E_OBJECT_NOT_FOUND
                - If the volume name does not correspond to an existing mount point then abort
                snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)
            VSS_E_INSUFFICIENT_STORAGE
                Not enough disk storage to create a snapshot (for ex. diff area)
                (remark: when a snapshot is not created since there is not enough disk space
                this error is not guaranteed to be returned. VSS_E_PROVIDER_VETO or VSS_E_OBJECT_NOT_FOUND
                may also be returned in that case.)

    [PrepareAndFreezeWriters() failures] or
    [ThawWriters() failures]
        E_OUTOFMEMORY

        [CoCreateInstance(CLSID_VssEvent) failures] or
        [PrepareForSnapshot() failures] or
        [Freeze() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_WRITER_ERROR
                - Unexpected writer error. The error code is logged into the event log.

    [LovelaceFlushAndHold() failures]
        [FlushAndHoldAllWrites() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - Invalid thread state. Dev error - no entry is put in the event log.
                - Empty volume array. Dev error - no entry is put in the event log.
                - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
            VSS_ERROR_FLUSH_WRITES_TIMEOUT
                - An error occured while flushing the writes from a background thread. An event log entry is added.

    [LovelaceRelease() failures]
        [ReleaseAllWrites() failures]
            [WaitForFinish() failures]
                E_UNEXPECTED
                    - The list of volumes is empty. Dev error - nothing is logged on.
                    - SetEvent failed. An entry is put in the error log.
                    - WaitForMultipleObjects failed. An entry is put in the error log.
                E_OUTOFMEMORY
                    - Cannot create the array of handles.
                    - One of the background threads failed with E_OUTOFMEMORY
                VSS_E_HOLD_WRITES_TIMEOUT
                    - Lovelace couldn't keep more the writes. An event log entry is added.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::DoSnapshotSet" );

    try
    {   
        BS_ASSERT(IsContextValid(GetContextInternal()));

       // we're now in a backup sequence, so shutdown events are needed
        m_bShutdownNeeded = true;

        // Change state from VSSC_SnapshotSetStarted to VSSC_SnapshotCreation
        // BUG 381357: we do not allow multiple calls to DoSnapshotSet in the context of the same Snapshot Set
        LONG lNewCoordState = ::InterlockedCompareExchange( &m_lCoordState, VSSC_SnapshotCreation, VSSC_SnapshotSetStarted);
        if (lNewCoordState != VSSC_SnapshotSetStarted)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Snapshot Set in incorrect state %ld", m_lCoordState);

        // The snapshot set must not be empty
        if (m_lSnapshotsCount == 0)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Snapshot Set is empty");

        //
        // Create the snapshot set
        //

        // End the prepare phase for all snapshots. Cancel detection inside
        EndPrepareAllSnapshots();

        // Send PrepareForSnapshot and Freeze to writers.
        // This function may throw HRESULTs
        // Cancel detection inside.
        if (AreWritersAllowed())
            PrepareAndFreezeWriters();

        // Pre-commit all snapshots. Cancel detection inside
        PreCommitAllSnapshots();

        // Flush and Hold writes on involved volumes
        LovelaceFlushAndHold();

        // Commit all snapshots. Cancel detection inside
        CommitAllSnapshots();

        // Release writes on involved volumes
        LovelaceRelease();

        // On each involved provider, call PostCommitSnapshots for all committed snapshots.
        PostCommitAllSnapshots();

        // Send the Thaw event to all writers.
        ThawWriters();

        //
        // Snapshot set created.
        //
        
        // Remove any snapshotset related  state
        Deactivate();

        // Hide errors in eventuality of writer vetos
        ft.hr = S_OK;
    }
    VSS_STANDARD_CATCH(ft)

    m_pWriterCallback = NULL;

    CVssFunctionTracer ft2( VSSDBG_COORD, L"CVssSnapshotSetObject::DoSnapshotSet_failure_block" );

    try
    {
        // Cleanup on error...
        if (ft.hr != S_OK) // HrFailed not used since VSS_S_ASYNC_CANCELLED may be thrown...
        {
            ft.Trace( VSSDBG_COORD, L"Abort detected while commiting the snapshot set 0x%08lx", ft.hr );
            // These functions should not throw

            // Deal correctly with committed snapshots
            AbortAllSnapshots();

            // Release writes on involved volumes using Lovelace.
            // Tracing the return value already done.
            m_VolumesList.ReleaseAllWrites();

            // Send Abort to all writers,regardless of what events they were already received.
            if (AreWritersAllowed())
                AbortWriters();

            // WARNING: This call may throw
            Deactivate();
        }
    }
    VSS_STANDARD_CATCH(ft2);

    if (ft2.HrFailed())
        ft2.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft2.hr);

    BS_ASSERT((ft.hr == VSS_E_BAD_STATE) || m_bHasAcquiredSem);
    InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
    m_bHasAcquiredSem = false;

    return ft.hr;
}


void CVssSnapshotSetObject::PrepareAndFreezeWriters() throw (HRESULT)
/*++

Routine description:

    Send the PrepareForSnapshot and Freeze events to all writers.

Error codes:

    E_OUTOFMEMORY
    VSS_S_ASYNC_CANCELLED
        - if IVssAsync::Cancel was called

    [CoCreateInstance(CLSID_VssEvent) failures] or
    [PrepareForSnapshot() failures] or
    [Freeze() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PrepareAndFreezeWriters" );

    // Allocate the string for snapshot set ID
     CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();
    if (!bstrSnapshotSetID)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

    // Create the instance of the event class
    if (m_pWriters == NULL)
    {
        CVssFunctionTracer ft( VSSDBG_COORD, L"PrepareAndFreezeWriters_create_writers_instance" );
        ft.CoCreateInstanceWithLog(
                VSSDBG_COORD,
                CLSID_VssEvent,
                L"VssEvent",
                CLSCTX_ALL,
                IID_IVssWriter,
                (IUnknown**)&(m_pWriters));
        ft.TranslateWriterReturnCode( VSSDBG_COORD, L"CoCreateInstance(CLSID_VssEvent)");
        BS_ASSERT(m_pWriters);
        SetupPublisherFilter
            (
            m_pWriters,
            NULL,
            NULL,
            m_rgWriterInstances,
            m_cWriterInstances,
            false,
            false
            );
    }

    // Test if an Cancel occured
    TestIfCancelNeeded(ft);

    // Get the list of volumes to be snapshotted
    CComBSTR bstrVolumeNamesList = m_VolumesList.GetVolumesList();
    if (bstrVolumeNamesList.Length() == 0)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Null volume list");

    // We will ignore the case when if some subscribers returned and
    // error code while treating the event. This is because
    // transient subscriptions are not garbage collected in the event system.
    // In other words, if a subscriber process died without having a change to remove its
    // transient subscriptions the sending event will return one of these
    // EVENT_XXXX_SUBSCRIBERS_FAILED - which is wrong. Therefore this mechanism is not so
    // reliable therefore we will not use it.

    // Record entering...
    m_diagnose.RecordWriterEvent( VSS_IN_PREPARESNAPSHOT, CVssDiag::VSS_DIAG_ENTER_OPERATION, 
        0, ft.hr, CVssGlobalSnapshotSetId::GetID());

    // Send "PrepareForSnapshot" event to all subscribers
    ft.hr = m_pWriters->PrepareForSnapshot(
                bstrSnapshotSetID,
                bstrVolumeNamesList
                );

    // Record leaving...
    m_diagnose.RecordWriterEvent( VSS_IN_PREPARESNAPSHOT, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 
        0, ft.hr, CVssGlobalSnapshotSetId::GetID());
    
    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"PrepareForSnapshot(%s,%s)", bstrSnapshotSetID, bstrVolumeNamesList);

    // Test if an Cancel occured
    TestIfCancelNeeded(ft);

    // Freeze the front-end apps
    FreezePhase(bstrSnapshotSetID, VSS_APP_FRONT_END);

    // Freeze the back-end apps
    FreezePhase(bstrSnapshotSetID, VSS_APP_BACK_END);

    // Freeze the system writers
    FreezePhase(bstrSnapshotSetID, VSS_APP_SYSTEM);
}


void CVssSnapshotSetObject::FreezePhase(
        IN  CComBSTR& bstrSnapshotSetID,
        IN  VSS_APPLICATION_LEVEL eAppLevel
        ) throw (HRESULT)
/*++

Routine description:

    Send the Freeze events to all writers.

Error codes:

    E_OUTOFMEMORY
    VSS_S_ASYNC_CANCELLED
        - if IVssAsync::Cancel was called

    [Freeze() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::FreezePhase" );

    // Send "Freeze" event to all level 0 subscribers
    BS_ASSERT(m_pWriters != NULL);

    // Record entering...
    m_diagnose.RecordWriterEvent( VSS_IN_FREEZE, CVssDiag::VSS_DIAG_ENTER_OPERATION, 
        0, ft.hr, CVssGlobalSnapshotSetId::GetID());

    ft.hr = m_pWriters->Freeze(bstrSnapshotSetID, eAppLevel);

    // Record leaving...
    m_diagnose.RecordWriterEvent( VSS_IN_FREEZE, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 
        0, ft.hr, CVssGlobalSnapshotSetId::GetID());

    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Freeze(%s,%d)", bstrSnapshotSetID, (INT)eAppLevel);

    // Test if an Cancel occured
    TestIfCancelNeeded(ft);
}


void CVssSnapshotSetObject::ThawWriters() throw (HRESULT)
/*++

Routine description:

    Send the Thaw events to all writers.

Error codes:

    E_OUTOFMEMORY

    [Thaw() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
    {
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::ThawWriters" );

    // Allocate the string for snapshot set ID
    CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();

    if (!bstrSnapshotSetID)
        // We cannot send anymore the Thaw event since we have a memory allocation error
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");


    if (AreWritersAllowed())
        {
        // Send "Thaw" event to all subscribers
        BS_ASSERT(m_pWriters != NULL);
        
        // Record entering...
        m_diagnose.RecordWriterEvent( VSS_IN_THAW, CVssDiag::VSS_DIAG_ENTER_OPERATION, 
            0, ft.hr, CVssGlobalSnapshotSetId::GetID());

        ft.hr = m_pWriters->Thaw(bstrSnapshotSetID);

        // Record leaving...
        m_diagnose.RecordWriterEvent( VSS_IN_THAW, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 
            0, ft.hr, CVssGlobalSnapshotSetId::GetID());

        ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Thaw(%s)", bstrSnapshotSetID);
        }

        // Send the PostSnapshot event to providers and eventually writers (bug #549779)

        // call PostSnapshot method on the provider generic interface
        for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
            {
            CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
            ft.hr = pProviderItf->PostSnapshot(m_pWriterCallback, &m_bCancel);
            if (ft.HrFailed())
                ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
                    L"PostCommitSnapshots("WSTR_GUID_FMT L", %ld)",
                    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()), m_lSnapshotsCount);
            }

        // Send PostSnapshot to writers only if writer callback was specified (BUG# 549779)
        if (m_pWriterCallback && AreWritersAllowed())
            {
            CComPtr<IDispatch> pCallback;
            CVssCoordinatorCallback::Initialize(m_pWriterCallback, &pCallback);

            // Record entering...
            m_diagnose.RecordWriterEvent( VSS_IN_POSTSNAPSHOT, CVssDiag::VSS_DIAG_ENTER_OPERATION, 
                0, ft.hr, CVssGlobalSnapshotSetId::GetID());

            // BUGBUG: temporarily pass in NULL for PostSnapshot
            ft.hr = m_pWriters->PostSnapshot(bstrSnapshotSetID, pCallback, NULL);

            // Record leaving...
            m_diagnose.RecordWriterEvent( VSS_IN_POSTSNAPSHOT, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 
                0, ft.hr, CVssGlobalSnapshotSetId::GetID());

            ft.TranslateWriterReturnCode( VSSDBG_COORD, L"PostSnapshot(%s)", bstrSnapshotSetID);
            }
}





void CVssSnapshotSetObject::AbortWriters()
/*++

Routine description:

    Send the Abort events to all writers.

Error codes:

    [Abort() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AbortWriters" );

    if (m_pWriters != NULL) {

        // Allocate the string for snapshot set ID
        CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();

        if (!bstrSnapshotSetID) {
            // We cannot send anymore the Abort event since we have a memory allocation error
            ft.Trace( VSSDBG_COORD, L"Memory allocation error");
        } else {

            // Record entering...
            m_diagnose.RecordWriterEvent( VSS_IN_ABORT, CVssDiag::VSS_DIAG_ENTER_OPERATION, 
                0, ft.hr, CVssGlobalSnapshotSetId::GetID());

            // Send "Abort" event to all subscribers
            ft.hr = m_pWriters->Abort(bstrSnapshotSetID);

            // Record leaving...
            m_diagnose.RecordWriterEvent( VSS_IN_ABORT, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 
                0, ft.hr, CVssGlobalSnapshotSetId::GetID());

            ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Abort(%s)", bstrSnapshotSetID);
        }
    }
}


void CVssSnapshotSetObject::SetWriterInstances
    (
    LONG cWriterInstances,
    VSS_ID *rgWriterInstances
    )
/*++

Routine description:

    Set the set of writers that participate in the snapshot

Throws:

    E_OUTOFMEMORY
--*/

    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSnapshotSetObject::SetWriterInstances");

    
        if (cWriterInstances > 0)
        {
            BS_ASSERT(rgWriterInstances);
            
            VSS_ID * rgNewWriterInstances = new VSS_ID[cWriterInstances];
            if (rgNewWriterInstances == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate array of writer instances");

            memcpy(rgNewWriterInstances, rgWriterInstances, cWriterInstances * sizeof(VSS_ID));
            
            delete[] m_rgWriterInstances;
            m_rgWriterInstances = rgNewWriterInstances;

            m_cWriterInstances = cWriterInstances;
        }
        else
        {
            m_cWriterInstances = 0;
            
            delete[] m_rgWriterInstances;
            m_rgWriterInstances = NULL;
        }
    
    }


void CVssSnapshotSetObject::LovelaceFlushAndHold()
/*++

Routine description:

    Invokes the Lovelace's Flush& Hold on all volumes in the snapshot set.

Throws:

    [FlushAndHoldAllWrites() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - Invalid thread state. Dev error - no entry is put in the event log.
            - Empty volume array. Dev error - no entry is put in the event log.
            - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
        VSS_ERROR_FLUSH_WRITES_TIMEOUT
            - An error occured while flushing the writes from a background thread. An event log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::LovelaceFlushAndHold" );

    // Flush And Hold writes on involved volumes using Lovelace.
    ft.hr = m_VolumesList.FlushAndHoldAllWrites(CVssGlobalSnapshotSetId::GetID());
    if (ft.HrFailed())
        ft.Throw(VSSDBG_COORD, ft.hr, L"Flush and Hold failure");
}


void CVssSnapshotSetObject::LovelaceRelease()
/*++

Routine description:

    Invokes the Lovelace's Release on all volumes in the snapshot set,

Throws:

    [ReleaseAllWrites() failures]
        [WaitForFinish() failures]
            E_UNEXPECTED
                - The list of volumes is empty. Dev error - nothing is logged on.
                - SetEvent failed. An entry is put in the error log.
                - WaitForMultipleObjects failed. An entry is put in the error log.
            E_OUTOFMEMORY
                - Cannot create the array of handles.
                - One of the background threads failed with E_OUTOFMEMORY
            VSS_E_HOLD_WRITES_TIMEOUT
                - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::LovelaceRelease" );

    // Release writes on involved volumes using Lovelace.
    ft.hr = m_VolumesList.ReleaseAllWrites();
    if (ft.HrFailed())
        ft.Throw(VSSDBG_COORD, ft.hr, L"Release failure");
}


void CVssSnapshotSetObject::EndPrepareAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call EndPrepareSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [EndPrepareSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)
        VSS_E_INSUFFICIENT_STORAGE
            Not enough disk storage to create a snapshot (for ex. diff area)
            (remark: when a snapshot is not created since there is not enough disk space
            this error is not guaranteed to be returned. VSS_E_PROVIDER_VETO or VSS_E_OBJECT_NOT_FOUND
            may also be returned in that case.)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::EndPrepareAllSnapshots" );

    // On each involved provider, call PreCommitSnapshots for all prepared snapshots.
    for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
    {

        // End the background prepare phase
        CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->EndPrepareSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_INSUFFICIENT_STORAGE )
            ft.Throw(VSSDBG_COORD, VSS_E_INSUFFICIENT_STORAGE,
                L"insufficient diff area storage detected while calling EndPrepareAllSnapshots. Provider ID = " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
            ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
                L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
        else if ( ft.HrFailed() )
            ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
                L"EndPrepareSnapshots("WSTR_GUID_FMT L")",
                GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

        // Test if an Cancel occured
        TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::PreCommitAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call PreCommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [PreCommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PreCommitAllSnapshots" );

    // On each involved provider, call PreCommitSnapshots for all prepared snapshots.
    for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
    {
        // Pre-commit
        CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PreCommitSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
            ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
                L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
        else if ( ft.HrFailed() )
            ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
                L"PreCommitSnapshots("WSTR_GUID_FMT L")",
                GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

        // Test if an Cancel occured
        TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::CommitAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call CommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [CommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CommitAllSnapshots" );

    // On each involved provider, call CommitSnapshots for all prepared snapshots.
    for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
    {
        // Commit
        CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->CommitSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
            ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
                L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
        else if ( ft.HrFailed() )
            ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
                L"CommitSnapshots("WSTR_GUID_FMT L")",
                GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

        // Test if an Cancel occured
        TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::PostCommitAllSnapshots() throw (HRESULT)
/*++

Routine description:

    Call PostCommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [PostCommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PostCommitAllSnapshots" );

    // On each involved provider, call PostCommitSnapshots for all committed snapshots.
    for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
    {
        CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PostCommitSnapshots( CVssGlobalSnapshotSetId::GetID(), m_lSnapshotsCount );
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
            ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
                L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
        else if ( ft.HrFailed() )
            ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
                L"PostCommitSnapshots("WSTR_GUID_FMT L", %ld)",
                GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()), m_lSnapshotsCount);

        // Test if an Cancel occured
        TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::AbortAllSnapshots()
/*++

Routine description:

    Call AbortSnapshots for each provider involved in the snapshot set.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AbortAllSnapshots" );

    try
    {
        for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
        {
            CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);

            ft.hr = pProviderItf->AbortSnapshots(CVssGlobalSnapshotSetId::GetID());
            if (ft.HrFailed())
                ft.Trace( VSSDBG_COORD, L"AbortSnapshots failed at one writer. hr = 0x%08lx", ft.hr);
        }
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssSnapshotSetObject::TestIfCancelNeeded(
    IN  CVssFunctionTracer& ft
    ) throw(HRESULT)
{
    if (m_bCancel)
        ft.Throw( VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");
}


void CVssSnapshotSetObject::OnDeactivate() throw(HRESULT)

/*++

Routine Description:

    Called by CVssProviderManager::Deactivate in order to remove the state of the object.

Warning:

    - The local cache interfaces are not released since are needed in the auto-delete case
    - The Reset function may throw...

Thrown errors:

    E_OUTOFMEMORY.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::OnDeactivate" );

    // Remove state from the coordinator interface
    // This will release the interfaces also but not completely
    // since a copy is stored in the local cache.
    m_mapProviderItfInSnapSet.RemoveAll();

    // Remove all volumes from the snapshot set.
    m_VolumesList.Reset();

    m_lSnapshotsCount = 0;

    CVssGlobalSnapshotSetId::ResetID();

    m_lCoordState = VSSC_Initialized;
}


void CVssSnapshotSetObject::GetSupportedProviderId(
    IN  LPWSTR wszVolumeName,
    OUT VSS_ID* pProviderId
    ) throw(HRESULT)

/*++

Routine Description:

    Called by CVssSnapshotSetObject::AddToSnapshotSet in order to establish the provider
    that will be used for snapshotting this volume

Algorithm:

    for $ProvType in the following order (Hardware, Software, System)
        for $Provider in all providers of type $ProvType
            if ($Provider supports Volume) then
                return the ID of $Provider
    return VSS_E_VOLUME_NOT_SUPPORTED

Remarks:

    We impose no rule for choosing between providers of the same type. The mechanishm of
    choosing is intentionally arbitrarily.

Arguments:
    wszVolumeName - expected to be in the \\\\\?\\Volume{00000000-0000-0000-0000-000000000000}\\ format.

Return values:

    None.

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
        - if the volume is not in the correct format.
    VSS_E_VOLUME_NOT_SUPPORTED
        - If the given volume is not supported by any provider

    [QuerySupportedProvidersIntoArray() failures]
        E_OUTOFMEMORY

        VSS_E_UNEXPECTED_PROVIDER_ERROR
            Unexpected provider error on calling IsVolumeSupported

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterface failures]
            [lockObj failures]
                E_OUTOFMEMORY

            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::GetSupportedProviderId" );

    VSS_ID VolumeId;

    // Assert parameters
    BS_ASSERT(pProviderId);
    BS_ASSERT(*pProviderId == GUID_NULL);
    BS_ASSERT(wszVolumeName);

    // Get the volume GUID
    if (!::GetVolumeGuid(wszVolumeName, VolumeId)) {
        // We assert since the check was already done
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Cannot convert volume name %s to a GUID", wszVolumeName);
    }

    //
    // Get all providers that supports this volume into an array
    //

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pFilteredProvidersArray = new VSS_OBJECT_PROP_Array;
    if (pFilteredProvidersArray == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
    // The only purpose of this is to use a smart ptr to destroy correctly the array on error.
    // Now pFilteredProvidersArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pFilteredProvidersArray);
    BS_ASSERT(pArrayItf);

    // Insert property structures into the array.
    // Only providers that supports tha volume will be chosen.
    CVssProviderManager::QuerySupportedProvidersIntoArray(
        GetContextInternal(), false, wszVolumeName, pFilteredProvidersArray );

    //
    //  Search a provider that supports that volume (i.e. from the above list),
    //  in the correct priority order.
    //

    // For each provider type, in the correct priority order
    bool bFound = false;
    for(int nPriority = 0; !bFound && arrProviderTypesOrder[nPriority] ; nPriority++) {

        // Get the current provider type
        VSS_PROVIDER_TYPE nCurrentType = arrProviderTypesOrder[nPriority];

        // For all providers of that type search one that supports the volume
        for(int nIndex = 0; !bFound && (nIndex < pFilteredProvidersArray->GetSize()); nIndex++) {

            // Get the structure object from the array
            VSS_OBJECT_PROP_Ptr& ptrProperties = (*pFilteredProvidersArray)[nIndex];

            // Get the provider structure
            BS_ASSERT(ptrProperties.GetStruct());
            BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
            VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

            // Skip providers with the wrong type
            if (ProviderProp.m_eProviderType != nCurrentType)
                continue;

            // We found a good provider
            (*pProviderId) = ProviderProp.m_ProviderId;
            bFound = true;
        }
    }

    if (!bFound) {
        BS_ASSERT(false); // The "Volume not supported should be detected already by the IsVolumeSupported() call in coord.cxx
        ft.Throw(VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED, L"Volume %s not supported by any provider", wszVolumeName);
    }
}


/////////////////////////////////////////////////////////////////////////////
// Life-management related methods


STDMETHODIMP CVssSnapshotSetObject::QueryInterface(
    IN  REFIID iid,
    OUT void** pp
    )
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
    return S_OK;
}


ULONG CVssSnapshotSetObject::AddRef()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AddRef");

    return ::InterlockedIncrement(&m_lRef);
}


ULONG CVssSnapshotSetObject::Release()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::Release");

    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
}


CVssSnapshotSetObject* CVssSnapshotSetObject::CreateInstance() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CreateInstance");

    CVssSnapshotSetObject* pObj = new CVssSnapshotSetObject;
    if (pObj == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

    if (FAILED(pObj->FinalConstructInternal()))
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Error initializing the object");

    return pObj;
}


HRESULT CVssSnapshotSetObject::FinalConstructInternal()
{
    // Initialize the diag object. This doesn't throw.
    m_diagnose.Initialize(x_pwszVssvcPublisher);
    
    return S_OK;
}


CVssSnapshotSetObject::CVssSnapshotSetObject():
    m_bCancel(false),
    m_lSnapshotsCount(0),
    m_lCoordState(VSSC_Initialized),
    m_bHasAcquiredSem(false),
    m_lRef(0),
    m_rgWriterInstances(NULL),
    m_cWriterInstances(0),
    m_bShutdownNeeded(false),
    m_lastSnapshotSet(GUID_NULL)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CVssSnapshotSetObject");
}


CVssSnapshotSetObject::~CVssSnapshotSetObject()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSnapshotSetObject::~CVssSnapshotSetObject");

    try
    	{
        if (m_bShutdownNeeded)
        	DoBackupShutdown();
    	}
    VSS_STANDARD_CATCH(ft)
    if (ft.HrFailed())
    	ft.Trace(VSSDBG_COORD, L"Failed to perfrom backup shutdown");
    
    try
    {        
        // Release aborts all prepared snapshots
        Deactivate();
  
        delete [] m_rgWriterInstances;

        // If writers interface is present, we must also have an filter interface attached
        // BUG 496343 "An interceptor still has a reference on shutdown. Someone leaked an interface pointer." after system state backup	Under Investigation	Server RC1	 
        if (m_pWriters)
            ClearPublisherFilter(m_pWriters);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft.hr);

    if (m_bHasAcquiredSem)
        InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);

}


/////////////////////////////////////////////////////////////////////////////
//  CVssGlobalSnapshotSetId


//  Static data members
//

// Global snapshot set Id
VSS_ID CVssGlobalSnapshotSetId::m_SnapshotSetID = GUID_NULL;

// Global lock
CVssCriticalSection  CVssGlobalSnapshotSetId::m_cs;


//  Implementation
//

// Get the current Snasphot set ID
VSS_ID CVssGlobalSnapshotSetId::GetID() throw(HRESULT)
{
    // (Simplify tracing: do not declare a function tracer)

    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    return m_SnapshotSetID;
}


// Allocate a new Snapshot Set ID
VSS_ID CVssGlobalSnapshotSetId::NewID() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::NewID" );

    try
    {
        // Acquire the critical section. This may throw.
        CVssAutomaticLock2 lock(m_cs);

        // Create the new Snapshot Set ID
        BS_ASSERT(m_SnapshotSetID == GUID_NULL);
        ft.hr = ::CoCreateGuid( &m_SnapshotSetID );
        if ( ft.HrFailed() )
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CoCreateGuid" );

        // Broadcast the new snapshot set ID. This may throw.
        CVssSnasphotSetIdObserver::BroadcastSSID(m_SnapshotSetID);
    }
    VSS_STANDARD_CATCH(ft)

    // Re-throw error, if needed
    if (ft.HrFailed()) {
        m_SnapshotSetID = GUID_NULL;
        ft.Throw( VSSDBG_COORD, ft.hr, L"Re-throw error 0x%08lx", ft.hr);
    }

    // Return the created SSID
    return m_SnapshotSetID;
}


// Clear the current snapshot Set ID
void CVssGlobalSnapshotSetId::ResetID() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::ResetID" );

    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    // Set the new Snapshot Set ID
    m_SnapshotSetID = GUID_NULL;
}


// Record the current SSID in the given observer
void CVssGlobalSnapshotSetId::InitializeObserver(
    IN CVssSnasphotSetIdObserver* pObserver
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::InitializeObserver" );

    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    // Record the current Snapshot Set ID. This may throw.
    if (m_SnapshotSetID != GUID_NULL)
        pObserver->RecordSSID(m_SnapshotSetID);
}


// do the work to import a snapshot set
// returns:
//
//      NOERROR: if all snapshots are successfully imported
//
//      VSS_S_SOME_SNAPSHOTS_NOT_IMPORTED: if some but not all snapshots are imported
//
//      VSS_E_NO_SNAPSHOTS_IMPORTED: if no snapshots were successfully imported
//
HRESULT CVssSnapshotSetObject::DoImportSnapshots(IN BSTR bstrXML)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSnapshotSetObject::DoImportSnapshots");

    bool bSomeSucceeded = false;
    bool bAllSucceeded = true;

    CComPtr<IVssSnapshotSetDescription> pSnapshotSet;

    // load snapshot set description
    ft.hr = LoadVssSnapshotSetDescription(bstrXML, &pSnapshotSet);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"LoadVssSnapshotSetDescription");

    // determine number of snapshots
    UINT cSnapshots;
    ft.hr = pSnapshotSet->GetSnapshotCount(&cSnapshots);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

    // Get the array of interfaces
    CVssSnapshotProviderItfMap* pItfMap;
    CVssProviderManager::GetProviderItfArray( VSS_CTX_ALL, &pItfMap );

    // loop through the providers
    for (int nIndex = 0; nIndex < pItfMap->GetSize(); nIndex++ )
        {
        CComPtr<IVssSnapshotProvider> pProviderItf;

        // get provider id.
        VSS_ID providerId = pItfMap->GetKeyAt(nIndex);

        // verify that the provider is used by some snapshot being
        // imported
        bool bFound = false;
        for(UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++)
            {
            if (m_bCancel)
                ft.Throw(VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");

            CComPtr<IVssSnapshotDescription> pSnapshot;

            // get snapshot description
            ft.hr = pSnapshotSet->GetSnapshotDescription(iSnapshot, &pSnapshot);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotDescription");

            // get provider id
            VSS_ID providerIdSnapshot;
            ft.hr = pSnapshot->GetProviderId(&providerIdSnapshot);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshtoDescription::GetProviderId");

            if (providerId == providerIdSnapshot)
                {
                bFound = true;
                break;
                }
            }

        // ignore this provider
        if (!bFound)
            continue;

        if (!GetProviderInterfaceForSnapshotCreation(providerId, pProviderItf))
            {
            bAllSucceeded = false;
            continue;
            }

        // call provider to import snapshots it handles
        ft.hr = pProviderItf->ImportSnapshotSet(bstrXML, &m_bCancel);
        if (ft.HrFailed())
            bAllSucceeded = false;
        else
            {
            if (ft.hr == VSS_S_SOME_SNAPSHOTS_NOT_IMPORTED)
                bAllSucceeded = false;

            bSomeSucceeded = true;
            }
        }

    if (!bSomeSucceeded)
        return VSS_E_NO_SNAPSHOTS_IMPORTED;
    else if (!bAllSucceeded)
        return VSS_S_SOME_SNAPSHOTS_NOT_IMPORTED;
    else
        return NOERROR;
    }

void CVssSnapshotSetObject::DoBackupShutdown()
  {
  CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::DoBackupShutdown" );
  
  if (!AreWritersAllowed())
    return;

  // Create the instance of the event class
  if (m_pWriters == NULL)
    {
    ft.CoCreateInstanceWithLog(
              VSSDBG_COORD,
              CLSID_VssEvent,
              L"VssEvent",
              CLSCTX_ALL,
              IID_IVssWriter,
              (IUnknown**)&(m_pWriters));
    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"CoCreateInstance(CLSID_VssEvent)");
    BS_ASSERT(m_pWriters);
    SetupPublisherFilter
          (
          m_pWriters,
          NULL,
          0,
          m_rgWriterInstances,
          m_cWriterInstances,
          false,
          false
          );
    }

  // Record entering...
  m_diagnose.RecordWriterEvent( VSS_IN_BACKUPSHUTDOWN, CVssDiag::VSS_DIAG_ENTER_OPERATION, 
        0, ft.hr, m_lastSnapshotSet);

  // Send "BackupShutdown" event to all subscribers
  ft.hr = m_pWriters->BackupShutdown(CComBSTR(m_lastSnapshotSet));
  // Record leaving...
  m_diagnose.RecordWriterEvent(VSS_IN_BACKUPSHUTDOWN, CVssDiag::VSS_DIAG_LEAVE_OPERATION, 
        0, ft.hr, m_lastSnapshotSet);
  ft.TranslateWriterReturnCode( VSSDBG_COORD, L"BackupShutdown");

  m_bShutdownNeeded = false;
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\rescan.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module rescan.cxx | Implementation of the CVssHWProviderWrapper methods to do a scsi rescan
    @end

Author:

    Brian Berkowitz  [brianb]  05/22/01

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      05/21/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "setupapi.h"
#include "rpc.h"
#include "cfgmgr32.h"
#include "devguid.h"
#include "resource.h"
#include "vssmsg.h"
#include "vs_inc.hxx"
#include <svc.hxx>


// Generated file from Coord.IDL
#include "vss.h"
#include "vscoordint.h"
#include "vsevent.h"
#include "vdslun.h"
#include "vsprov.h"
#include "vswriter.h"
#include "vsbackup.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "vs_idl.hxx"
#include "hardwrp.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORRESCC"
//

////////////////////////////////////////////////////////////////////////
// We will enumerate those device ids that belong to GUID_DEVCLASS_SCSIADAPTER
//  According to Lonny, all others are not needed at all.
//  This will of cource speed up enumeration
//  An excerpt of his mail is shown below
//  Other classes of interest include:
//   PCMCIA,
//  There should be no need to manually force a re-enumeration of PCMCIA
//  devices, since PCMCIA automatically detects/reports cards the moment they
//  arrive.
//
//   HDC,
//  The only way IDE devices can come or go (apart from PCMCIA IDE devices
//  covered under the discussion above) is via ACPI.  In that case, too,
//  hot-plug notification is given, thus there's no need to go and manually
//  re-enumerate.
//
//   MULTI_FUNCTION_ADAPTER,
//  There are two types of multifunction devices--those whose children are
//  enumerated via a bus-standard multi-function mechanism, and those whose
//  children a enumerated based on registry information.  In the former case, it
//  is theoretically possible that you'd need to do a manual re-enumeration in
//  order to cause the bus to find any new multi-function children.  In reality,
//  however, there are no such situations today.  In the latter case, there's no
//  point at all, since it's the registry spooge that determines what children
//  get exposed, not the bus driver.
//
//  Bottom line--I don't think that manual enumeration is necessary for any
//  (setup) class today except ScsiAdapter.  Ideally, the list of devices
//  requiring re-enumeration would be based on interface class instead.  Thus,
//  each device (regardless of setup class) that requires manual re-enumeration
//  in order to detect newly-arrived disks would expose an interface.  This
//  interface wouldn't need to actually be opened, it'd just be a mechanism to
//  enumerate such devices.  Given that ScsiAdapter is the only class today that
//  needs this functionality, and given the fact that all new hot-plug busses
//  actually report the device as soon as it arrives, we probably don't need to
//  go to this extra trouble.
//
void CVssHardwareProviderWrapper::DoRescanForDeviceChanges()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::DoRescanForDeviceChanges");

    //  the following algorithm will be used
    //  a) Get all the deviceIds
    //  b) For each deviceId, get the class guid
    //  c) If the class GUID matches any of the following:
    //      GUID_DEVCLASS_SCSIADAPTER
    //    then get the devinst of the devidId and enumerate the devinst


    CONFIGRET result;
    GUID guid;
    ULONG length;
    LPWSTR deviceList = NULL;
    PWSTR ptr = NULL;
    DEVINST devinst;

    result = CM_Get_Device_ID_List_Size_Ex
                (
                &length,
                NULL, // No enumerator
                CM_GETIDLIST_FILTER_NONE,
                NULL
                );

    if (result != CR_SUCCESS)
        {
        ft.Trace(VSSDBG_COORD, L"unable to do rescan, cannot get buffer size");
        return;
        }

    // allocate device list
    deviceList = new WCHAR[length];
    if (!deviceList)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string");

    try
        {
        result = CM_Get_Device_ID_List_Ex
                    (
                    NULL,
                    deviceList,
                    length,
                    CM_GETIDLIST_FILTER_NONE,
                    NULL
                    );

        if (result != CR_SUCCESS)
            {
            // delete device list and return
            delete deviceList;
            ft.Trace(VSSDBG_COORD, L"Cannot get device list");
            return;
            }

        ptr = deviceList;

        while (ptr && *ptr)
            {
            LPWSTR TempString;

            devinst = DeviceIdToDeviceInstance(ptr);
            if (GetDevicePropertyString(devinst, SPDRP_CLASSGUID, &TempString))
                {
                if (CLSIDFromString(TempString, &guid) == NOERROR)
                    {
                    if (guid == GUID_DEVCLASS_SCSIADAPTER)
                        // cause rescan on a scsi adapter
                        ReenumerateDevices(devinst);
                    }

                delete TempString;
                }

            ptr = ptr + (wcslen(ptr) + 1);
            }

        delete deviceList;
        }
    catch(...)
        {
        delete deviceList;
        throw;
        }
    }


// Given the device Id this routine will enumerate all the devices under
// it. Example, given a scsi adapter ID it will find new disks.
// This function uses the user mode PNP manager.
// Returns TRUE on success.
BOOL CVssHardwareProviderWrapper::ReenumerateDevices
    (
    IN DEVINST deviceInstance
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareTestProvider::ReenumerateDevices");
    CONFIGRET result;
    BOOL bResult = TRUE;

    result = CM_Reenumerate_DevNode_Ex(deviceInstance, CM_REENUMERATE_SYNCHRONOUS, NULL);

    bResult = (result == CR_SUCCESS ? TRUE : FALSE);
    if (!bResult)
        ft.Trace(VSSDBG_COORD, L"CM_Reenumerate_DevNode returned an error");

    return bResult;
    }



// Given a deviceId return the device instance (handle)
// returns 0 on a failure
DEVINST CVssHardwareProviderWrapper::DeviceIdToDeviceInstance(LPWSTR deviceId)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareTestProvider::DeviceIdToDeviceInstance");

    CONFIGRET result;
    DEVINST devinst = 0;

    BS_ASSERT(deviceId != NULL);
    result = CM_Locate_DevNode(&devinst, deviceId,CM_LOCATE_DEVNODE_NORMAL | CM_LOCATE_DEVNODE_PHANTOM);
    if (result == CR_SUCCESS)
        return devinst;

    return 0;
    }



// Given the devinst, query the PNP subsystem for a property.
// This function can only be used if the property value is a string.
// propCodes supported are: SPDRP_DEVICEDESC, SPDRP_CLASSGUID,
// SPDRP_FRIENDLYNAME.
BOOL CVssHardwareProviderWrapper::GetDevicePropertyString
    (
    IN DEVINST devinst,
    IN ULONG propCode,
    OUT LPWSTR *data
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::GetDevicePropertyString");

    BOOL bResult = FALSE;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfo;
    ULONG reqSize = 0;
    LPWSTR deviceIdString = NULL;

    BS_ASSERT(data);

    // null out output parameter
    *data = NULL;
    if (!devinst)
        return bResult;

    // compute maximum size of output string
    switch(propCode)
        {
        case (SPDRP_DEVICEDESC):
            reqSize = LINE_LEN + 1;
            break;

        case (SPDRP_CLASSGUID):
            reqSize = MAX_GUID_STRING_LEN + 1;
            break;

        case (SPDRP_FRIENDLYNAME):
            reqSize = MAX_PATH + 1;
            break;

        default:
            return bResult;
        }

    // get device id string
    if (!DeviceInstanceToDeviceId(devinst, &deviceIdString))
        return bResult;

    // allocate string
    *data = new WCHAR[reqSize];
    if ((*data) == NULL)
        {
        delete deviceIdString;
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");
        }

    // clear string
    memset (*data, 0, reqSize * sizeof(WCHAR));

    DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (DeviceInfoSet == INVALID_HANDLE_VALUE)
        ft.Trace (VSSDBG_COORD, L"SetupDiCreateDeviceInfoList failed: %lx", GetLastError());
    else
        {
        DeviceInfo.cbSize = sizeof(SP_DEVINFO_DATA);
        if (SetupDiOpenDeviceInfo
                (
                DeviceInfoSet,
                deviceIdString,
                NULL,
                0,
                &DeviceInfo
                ))
            {
            if (SetupDiGetDeviceRegistryProperty
                    (
                    DeviceInfoSet,
                    &DeviceInfo,
                    propCode,
                    NULL,
                    (PBYTE)*data,
                    reqSize*sizeof(WCHAR),
                    NULL
                    ))
                bResult = TRUE;
            else
                ft.Trace (VSSDBG_COORD, L"SetupDiGetDeviceRegistryProperty failed: %lx", GetLastError());
            }
        else
            ft.Trace (VSSDBG_COORD, L"SetupDiOpenDeviceInfo failed: %lx", GetLastError());

        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        }

    if (!bResult)
        {
        delete *data;
        *data = NULL;
        }

    delete deviceIdString;
    return bResult;
    }



// given a device instance handle set the deviceId
// return TRUE on success FALSE otherwise
BOOL CVssHardwareProviderWrapper::DeviceInstanceToDeviceId
    (
    IN DEVINST devinst,
    OUT LPWSTR *deviceId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::DeviceInstanceToDeviceId");

    CONFIGRET result;
    BOOL bResult = FALSE;
    DWORD size;

    // null out output parameter
    *deviceId = NULL;
    result = CM_Get_Device_ID_Size_Ex(&size, devinst, 0, NULL);

    if (result != CR_SUCCESS)
        return FALSE;

    // allocate space for string
    *deviceId = new WCHAR[size + 1];

    // check for allocation failure
    if (!(*deviceId))
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");

    // clear string
    memset(*deviceId, 0, (size + 1) * sizeof(WCHAR));
    result = CM_Get_Device_ID
                    (
                    devinst,
                    *deviceId,
                    size + 1,
                    0
                    );

    if (result == CR_SUCCESS)
        bResult = TRUE;
    else
        {
        // delete string on failure
        delete *deviceId;
        *deviceId = NULL;
        }

    return bResult;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\shim.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Shim.cxx | Implementation of CVssShimObject
    @end

Author:

    Adi Oltean  [aoltean]  07/20/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/20/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "worker.hxx"

#include "shim.hxx"

#include "vswriter.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSHIMC"
//
////////////////////////////////////////////////////////////////////////

// Global semaphore used to serialize creation of snapshot sets, CVssShimObject also uses
// this semaphore to serialize both StartSnapshotSet and SimulateSnapshotFreeze.  Defined
// in snap_set.cxx.
extern LONG g_hSemSnapshotSets;

// Global semaphore used to serialize SimulateSnapshotFreeze after cancellation.
// Defined in snap_set.cxx.
extern LONG g_hSemSnapshotSetCancelled;


/////////////////////////////////////////////////////////////////////////////
//  CVssShimObject


HRESULT CVssShimObject::SimulateSnapshotFreeze(
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray
	)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::SimulateSnapshotFreeze" );

    try
    {
		BS_ASSERT(!m_bHasAcquiredSem);

        // Trace the input parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: SnapshotSetID = " WSTR_GUID_FMT L" "
            L" OptionFlags = %lu, VolumeCount = %d", 
            GUID_PRINTF_ARG(guidSnapshotSetId), ulOptionFlags, ulVolumeCount );
        for ( ULONG ulIndex = 0; ulIndex < ulVolumeCount ; ulIndex++ )
            ft.Trace( VSSDBG_COORD, L"   Volume[%02d]= %s", 
                ulIndex, ppwszVolumeNamesArray[ulIndex] );

        // Prevent simultaneous creation of multiple snapshot sets and SimulateSnapshotFreeze
        // on the same machine (but allow Simulate after cancellation)
		if (InterlockedCompareExchange(&g_hSemSnapshotSets, 1, 0) != 0)
        {
            if(InterlockedCompareExchange(&g_hSemSnapshotSetCancelled, 0, 1) != 1)
            {
			    ft.Throw
				    (
				    VSSDBG_COORD,
				    VSS_E_SNAPSHOT_SET_IN_PROGRESS,
				    L"Snapshot set creation is already in progress."
				    );
            }
        }
        m_bHasAcquiredSem = true;

        //
        // Finally call into the VssApi.DLL's SimulateSnaphotFreezeInternal!
        //
        PFunc_SimulateSnapshotFreezeInternal pFuncFreeze;
        _Module.GetSimulateFunctions( &pFuncFreeze, NULL );
        if ( pFuncFreeze != NULL )
        {
            m_guidSimulateSnapshotSetId = guidSnapshotSetId;        
            ft.hr = pFuncFreeze( guidSnapshotSetId, ulOptionFlags,	ulVolumeCount,	ppwszVolumeNamesArray, &m_bCancel );
            if ( ft.HrFailed() )
            {
                ft.Trace( VSSDBG_COORD, L"ERROR: SimulateSnapshotFreezeInternal returned hr: 0x%08lx", ft.hr );
            }
        }
        else
        {
            ft.Trace( VSSDBG_COORD, L"ERROR: pFuncFreeze is NULL, no registered simulate snapshot function!!" );
        }
        
        if ( ft.HrSucceeded() )
        {
            TestIfCancelNeeded(ft);        
        }
    }
    VSS_STANDARD_CATCH(ft);

	// Cleanup on error...
	if (ft.hr != S_OK) // HrFailed not used since VSS_S_ASYNC_CANCELLED may be thrown...
	{
		ft.Trace( VSSDBG_COORD, L"Abort detected 0x%08lx", ft.hr );
        // These functions should not throw

        // If it was a cancel then abort the snapshot set in progress.
        if (ft.hr == VSS_S_ASYNC_CANCELLED) {
            // TBD: User cancelled.            
        }

        // Thaw any shim writers that got frozen before the error occurred or the
        // async operation was cancelled.  Note that SimulateSnapshotThaw will
        // release the semaphore.
        if ( m_bHasAcquiredSem )
            SimulateSnapshotThaw( guidSnapshotSetId );
	}

    // We may return here VSS_S_ASYNC_CANCELLED
    return ft.hr;
}


HRESULT CVssShimObject::SimulateSnapshotThaw(
    IN      VSS_ID          guidSnapshotSetId
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::SimulateSnapshotThaw" );

    //
    // Finally call into the VssApi.DLL's SimulateSnaphotThawInternal!
    //
    PFunc_SimulateSnapshotThawInternal pFuncThaw;
    _Module.GetSimulateFunctions( NULL, &pFuncThaw );
    if ( pFuncThaw != NULL )
    {
        pFuncThaw( guidSnapshotSetId );
    }
    else
    {
        ft.Trace( VSSDBG_COORD, L"ERROR: pFuncThaw is NULL, no registered simulate snapshot function!!" );
    }

    //
    //  Thaw can be called out of order since the requestor might be making sure that
    //  all writers thaw properly.
    //
    if ( m_bHasAcquiredSem )
    {
    	if ( InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1) == 1 )
            m_bHasAcquiredSem = false;
    }

    m_guidSimulateSnapshotSetId = GUID_NULL;
    
    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Life-management related methods


void CVssShimObject::TestIfCancelNeeded(
	IN	CVssFunctionTracer& ft
    ) throw(HRESULT)
{
	if (m_bCancel)
        ft.Throw( VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");
}


STDMETHODIMP CVssShimObject::QueryInterface(
	IN	REFIID iid,
	OUT	void** pp
	)
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
}


ULONG CVssShimObject::AddRef()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::AddRef");
	
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CVssShimObject::Release()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::Release");
	
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
}


CVssShimObject* CVssShimObject::CreateInstance() throw(HRESULT)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::CreateInstance");
	
	CVssShimObject* pObj = new CVssShimObject;
	if (pObj == NULL)
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	if (FAILED(pObj->FinalConstructInternal()))
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Error initializing the object");

	return pObj;
}


HRESULT CVssShimObject::FinalConstructInternal()
{
	return S_OK;
}


CVssShimObject::CVssShimObject():
	m_bCancel(false),
	m_lRef(0),
	m_guidSimulateSnapshotSetId( GUID_NULL ),
	m_bHasAcquiredSem( false )
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::CVssShimObject");
}


CVssShimObject::~CVssShimObject()
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssShimObject::~CVssShimObject");

	//
	// If we acquired the semaphore then make
	// sure to call SimulateSnapshotThaw.  This happens if the requestor doesn't
	// call it before exiting.
	//
	if ( m_bHasAcquiredSem )
	{
        ft.Trace( VSSDBG_COORD, L"Calling SimulateSnapshotThaw since requestor did not do so" );
        SimulateSnapshotThaw( m_guidSimulateSnapshotSetId );

        //  Make sure we always clear the semaphore.  SimulateSnapshotThaw should always 
        if ( m_bHasAcquiredSem )
        {
        	InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
        	m_bHasAcquiredSem = false;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    StdAfx.cxx

Abstract:

    Source file that includes just the standard includes.  stdafx.pch will be
    the pre-compiled header and stdafx.obj will contain the pre-compiled type
    information.

Author:

    Adi Oltean   [aoltean]      07/02/1999

Revision History:

--*/

#include "StdAfx.hxx"

// Needed here to match COM server definitions with the <atlimpl.cpp> stuff
#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\jetwriter\stdafx.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>
#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)

#include "vs_assert.hxx"

#include <oleauto.h>
#include <comadmin.h>

#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\vssqlwrt.cpp ===
/*++
Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsSqlWr.cpp | Implementation of Sql Writer wrapper class used by the coordinator
    @end

Author:

    Brian Berkowitz  [brianb]  04/18/2000

TBD:
    
    Add comments.

Revision History:

    
    Name        Date        Comments
    brianb     04/18/2000   Created
    brianb     04/20/2000   integrated with coordinator
    brianb     05/10/2000   make sure registration thread does CoUninitialize

--*/
#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "vs_idl.hxx"


#include <vswriter.h>
#include <sqlsnap.h>
#include <sqlwriter.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSQLWC"
//
////////////////////////////////////////////////////////////////////////


CVssSqlWriterWrapper::CVssSqlWriterWrapper() :
    m_pSqlWriter(NULL)
    {
    }

DWORD CVssSqlWriterWrapper::InitializeThreadFunc(VOID *pv)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSqlWriterWrapper::InitializeThreadFunc");

    CVssSqlWriterWrapper *pWrapper = (CVssSqlWriterWrapper *) pv;

    BOOL fCoinitializeSucceeded = false;

    try
        {
        // intialize MTA thread
        ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_GEN,
                E_UNEXPECTED,
                L"CoInitializeEx failed 0x%08lx", ft.hr
                );

        fCoinitializeSucceeded = true;

        ft.hr = pWrapper->m_pSqlWriter->Initialize();
        }
    VSS_STANDARD_CATCH(ft)

    if (fCoinitializeSucceeded)
        CoUninitialize();

    pWrapper->m_hrInitialize = ft.hr;
    return 0;
    }



HRESULT CVssSqlWriterWrapper::CreateSqlWriter()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSqlWriterWrapper::CreateSqlWriter");

    if (m_pSqlWriter)
        return S_OK;

    try
        {
        m_pSqlWriter = new CSqlWriter;
        if (m_pSqlWriter == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Allocation of CSqlWriter object failed.");

        DWORD tid;

        HANDLE hThread = CreateThread
                            (
                            NULL,
                            256* 1024,
                            CVssSqlWriterWrapper::InitializeThreadFunc,
                            this,
                            0,
                            &tid
                            );

        if (hThread == NULL)
            ft.Throw
                (
                VSSDBG_GEN,
                E_UNEXPECTED,
                L"CreateThread failed with error %d",
                GetLastError()
                );

        // wait for thread to complete
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
        ft.hr = m_hrInitialize;
        }
    VSS_STANDARD_CATCH(ft)
    if (ft.HrFailed() && m_pSqlWriter)
        {
        delete m_pSqlWriter;
        m_pSqlWriter = NULL;
        }

    return ft.hr;
    }

void CVssSqlWriterWrapper::DestroySqlWriter()
    {
    if (m_pSqlWriter)
        {
        m_pSqlWriter->Uninitialize();
        delete m_pSqlWriter;
        m_pSqlWriter = NULL;
        }
    }


CVssSqlWriterWrapper::~CVssSqlWriterWrapper()
    {
    DestroySqlWriter();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\prop\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\softwrp.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module softwrp.cxx | Implementation of CVssSoftwareProviderWrapper
    @end

Author:

    Adi Oltean  [aoltean]  03/11/2001

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     03/11/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "softwrp.hxx"
#include "vssmsg.h"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSOFTC"
//
////////////////////////////////////////////////////////////////////////


IVssSnapshotProvider* CVssSoftwareProviderWrapper::CreateInstance(
    IN VSS_ID ProviderId,
    IN CLSID ClassId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::CreateInstance");

    // Ref count becomes 1
    CComPtr<CVssSoftwareProviderWrapper> pWrapper = new CVssSoftwareProviderWrapper();
    if (pWrapper == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

    // Create the IVssSoftwareSnapshotProvider interface
    ft.CoCreateInstanceWithLog(
            VSSDBG_COORD,
            ClassId,
            L"SW_PROV",
            CLSCTX_LOCAL_SERVER,
            IID_IVssSoftwareSnapshotProvider,
            (IUnknown**)&(pWrapper->m_pSoftwareItf));
    if ( ft.HrFailed() ) {
        ft.LogError(VSS_ERROR_CREATING_PROVIDER_CLASS, VSSDBG_COORD << ClassId << ft.hr );
        ft.Throw( VSSDBG_COORD, VSS_E_UNEXPECTED_PROVIDER_ERROR, L"CoCreateInstance failed with hr = 0x%08lx", ft.hr);
    }
    BS_ASSERT(pWrapper->m_pSoftwareItf);

    // Query the creation itf.
    ft.hr = pWrapper->m_pSoftwareItf->SafeQI( IVssProviderCreateSnapshotSet, &(pWrapper->m_pCreationItf) );
    if (ft.HrFailed()) {
        ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderCreateSnapshotSet");
    }
    BS_ASSERT(pWrapper->m_pCreationItf);

    // Query the notification itf.
    // Execute the OnLoad, if needed
    ft.hr = pWrapper->m_pSoftwareItf->SafeQI( IVssProviderNotifications, &(pWrapper->m_pNotificationItf) );
    if (ft.HrSucceeded()) {
        BS_ASSERT(pWrapper->m_pNotificationItf);
    } else if (ft.hr != E_NOINTERFACE) {
        BS_ASSERT(false);
        ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderNotifications");
    }

    // return the created interface
    // Ref count is still 1
    return pWrapper.Detach();
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods

STDMETHODIMP CVssSoftwareProviderWrapper::QueryInternalInterface(
    IN  REFIID iid,
    OUT void** pp
    )
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::QueryInternalInterface");

    BS_ASSERT(pp);
    if (iid != IID_IVssSnapshotMgmt) {
        BS_ASSERT(false);
        return E_UNEXPECTED;
    }

    // Get the management interface
    CComPtr<IVssSnapshotMgmt> ptrUnk;
    BS_ASSERT(m_pSoftwareItf);
    ft.hr = m_pSoftwareItf->SafeQI(IVssSnapshotMgmt, &ptrUnk);
    if (ft.HrFailed())
    {
        BS_ASSERT(false);
        ft.Trace( VSSDBG_COORD, L"Error while obtaining the IVssSnapshotMgmt interface 0x%08lx", ft.hr);
        return E_UNEXPECTED;
    }

    (*pp) = ptrUnk.Detach();
    return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP CVssSoftwareProviderWrapper::QueryInterface(REFIID iid, void** pp)
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::QueryInterface");

    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
    return S_OK;
};

STDMETHODIMP_(ULONG) CVssSoftwareProviderWrapper::AddRef()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::AddRef");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper AddRef(%p) %lu --> %lu", this, m_lRef, m_lRef+1);

    return ::InterlockedIncrement(&m_lRef);
};

STDMETHODIMP_(ULONG) CVssSoftwareProviderWrapper::Release()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::Release");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper Release(%p) %lu --> %lu", this, m_lRef, m_lRef-1);

    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
};


/////////////////////////////////////////////////////////////////////////////
//  IVssSoftwareSnapshotProvider


STDMETHODIMP CVssSoftwareProviderWrapper::SetContext(
    IN      LONG     lContext
    )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->SetContext(lContext);
}


STDMETHODIMP CVssSoftwareProviderWrapper::GetSnapshotProperties(
    IN      VSS_ID          SnapshotId,
    OUT     VSS_SNAPSHOT_PROP   *pProp
    )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->GetSnapshotProperties(
                SnapshotId,
                pProp
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->Query(
                QueriedObjectId,
                eQueriedObjectType,
                eReturnedObjectsType,
                ppEnum
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
    IN      VSS_OBJECT_TYPE eSourceObjectType,
    IN      BOOL            bForceDelete,
    OUT     LONG*           plDeletedSnapshots,
    OUT     VSS_ID*         pNondeletedSnapshotID
    )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->DeleteSnapshots(
                SourceObjectId,
                eSourceObjectType,
                bForceDelete,
                plDeletedSnapshots,
                pNondeletedSnapshotID
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::BeginPrepareSnapshot(
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_ID          SnapshotId,
    IN      VSS_PWSZ     pwszVolumeName,
    IN      LONG             lNewContext  
    
    )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->BeginPrepareSnapshot(
                SnapshotSetId,
                SnapshotId, 
                pwszVolumeName,
                lNewContext
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::IsVolumeSupported(
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSupportedByThisProvider
    )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->IsVolumeSupported(
                pwszVolumeName,
                pbSupportedByThisProvider
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::IsVolumeSnapshotted(
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSnapshotsPresent,
    OUT     LONG *          plSnapshotCompatibility
    )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->IsVolumeSnapshotted(
                pwszVolumeName,
                pbSnapshotsPresent,
                plSnapshotCompatibility
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::SetSnapshotProperty(
    IN   VSS_ID             SnapshotId,
    IN   VSS_SNAPSHOT_PROPERTY_ID   eSnapshotPropertyId,
    IN   VARIANT            vProperty
    )
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->SetSnapshotProperty(SnapshotId, eSnapshotPropertyId, vProperty);
}


STDMETHODIMP CVssSoftwareProviderWrapper::RevertToSnapshot(
   IN       VSS_ID              SnapshotId
 )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->RevertToSnapshot(SnapshotId);
}

STDMETHODIMP CVssSoftwareProviderWrapper::QueryRevertStatus(
   IN      VSS_PWSZ                         pwszVolume,
   OUT    IVssAsync**                  ppAsync
 )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->QueryRevertStatus(pwszVolume, ppAsync);
}


/////////////////////////////////////////////////////////////////////////////
// IVssProviderCreateSnapshotSet


STDMETHODIMP CVssSoftwareProviderWrapper::EndPrepareSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->EndPrepareSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PreCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PreCommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::CommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->CommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PostCommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PostCommitSnapshots(SnapshotSetId, lSnapshotsCount);
}

STDMETHODIMP CVssSoftwareProviderWrapper::PreFinalCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PreFinalCommitSnapshots(SnapshotSetId);
}

STDMETHODIMP CVssSoftwareProviderWrapper::PostFinalCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PostFinalCommitSnapshots(SnapshotSetId);
}

STDMETHODIMP CVssSoftwareProviderWrapper::PostSnapshot(
    IN      IDispatch       *pCallback,
    IN      bool            *pbCancelled
    )
    {
    UNREFERENCED_PARAMETER(pCallback);
    UNREFERENCED_PARAMETER(pbCancelled);

    return S_OK;
    }


STDMETHODIMP CVssSoftwareProviderWrapper::AbortSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->AbortSnapshots(SnapshotSetId);
}

// miscellaneous methods
STDMETHODIMP CVssSoftwareProviderWrapper::BreakSnapshotSet
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::BreakSnapshotSet");
    try
        {
        CComPtr<IVssEnumObject> pEnum;
        ft.hr = m_pSoftwareItf->Query
                    (
                    GUID_NULL,
                    VSS_OBJECT_NONE,
                    VSS_OBJECT_SNAPSHOT,
                    &pEnum
                    );

        if (!ft.HrFailed())
            {
            VSS_OBJECT_PROP_Ptr ptrObjectProp;
            while(TRUE)
                {
                ULONG ulFetched;
                ptrObjectProp.InitializeAsEmpty(ft);
                VSS_OBJECT_PROP *pProp = ptrObjectProp.GetStruct();
                BS_ASSERT(pProp);
                ft.hr = pEnum->Next(1, pProp, &ulFetched);
                if (ft.hr == S_OK)
                    {
                    if (pProp->Obj.Snap.m_SnapshotSetId == SnapshotSetId)
                        ft.Throw(VSSDBG_COORD, VSS_E_PROVIDER_VETO, L"Cannot call BreakSnapshotSet on a software provider");
                    }
                else
                    break;

                ptrObjectProp.Reset();
                }

            ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"");
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CVssSoftwareProviderWrapper::SetExposureProperties
    (
    IN      VSS_ID          SnapshotId,
    IN      LONG            lAttributesExposure,
    IN      LPCWSTR         wszExposedName,
    IN      LPCWSTR         wszExposedPath
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::ExposeSnapshotVolume");
    
    try
    {
    	// fix the wszExposedPath parameter
    	wszExposedPath = (wszExposedPath != NULL) ? wszExposedPath	 :
    												L"";
    												
        // Assuming the arguments are good.
        BS_ASSERT(wszExposedName);
        BS_ASSERT(wszExposedPath);
        BS_ASSERT(lAttributesExposure 
            & (VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY | VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY));

        // Get the attributes. Verify also that the snapshot exists.
        VSS_OBJECT_PROP_Ptr ptrProp;
        ptrProp.InitializeAsEmpty(ft);
        VSS_OBJECT_PROP *pProp = ptrProp.GetStruct();
        VSS_SNAPSHOT_PROP & snap = pProp->Obj.Snap;

        ft.hr = m_pSoftwareItf->GetSnapshotProperties(SnapshotId, &snap);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr, 
                L"GetSnapshotProperties: Error catched 0x%08lx", ft.hr );

        // Set the exposed name
        CComVariant value = wszExposedName;
        if (value.vt == VT_ERROR)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
        ft.hr = m_pSoftwareItf->SetSnapshotProperty(SnapshotId, 
                    VSS_SPROPID_EXPOSED_NAME, value);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr, 
                L"SetSnapshotProperty(exposed name): Error catched 0x%08lx", ft.hr );

        // Set the exposed path
        value = wszExposedPath;
        if (value.vt == VT_ERROR)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
        ft.hr = m_pSoftwareItf->SetSnapshotProperty(SnapshotId, 
                    VSS_SPROPID_EXPOSED_PATH, value);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr, 
                L"SetSnapshotProperty(exposed path): Error catched 0x%08lx", ft.hr );

        // Set the attributes
        value = (long)(snap.m_lSnapshotAttributes | lAttributesExposure);
        if (value.vt == VT_ERROR)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
        ft.hr = m_pSoftwareItf->SetSnapshotProperty(SnapshotId, 
                    VSS_SPROPID_SNAPSHOT_ATTRIBUTES, value);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr, 
                L"SetSnapshotProperty(attributes): Error catched 0x%08lx", ft.hr );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CVssSoftwareProviderWrapper::ImportSnapshotSet(
    IN      LPCWSTR         wszXMLSnapshotSet,
    IN      bool            *pbCancelled
    )
    {
    UNREFERENCED_PARAMETER(wszXMLSnapshotSet);
    UNREFERENCED_PARAMETER(pbCancelled);

    return VSS_E_PROVIDER_VETO;
    }


////////////////////////////////////////////////////////////////////////
// IVssProviderNotifications

STDMETHODIMP CVssSoftwareProviderWrapper::OnLoad(
    IN  IUnknown* pCallback
    )
{
    return m_pNotificationItf? m_pNotificationItf->OnLoad(pCallback): S_OK;
}


STDMETHODIMP CVssSoftwareProviderWrapper::OnUnload(
    IN      BOOL    bForceUnload
    )
{
    return m_pNotificationItf? m_pNotificationItf->OnUnload(bForceUnload): S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\vsstswrt.cpp ===
/*++
Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Vsstswrt.cpp | Implementation of STSWriter wrapper class used by the coordinator
    @end

Author:

    Brian Berkowitz  [brianb]  04/18/2000

TBD:

    Add comments.

Revision History:


    Name        Date        Comments
    brianb     04/18/2000   Created
    brianb     04/20/2000   integrated with coordinator
    brianb     05/10/2000   make sure registration thread does CoUninitialize

--*/
#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "vs_idl.hxx"


#include <vswriter.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdmsg.h"
#include "stswriter.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSTSWC"
//
////////////////////////////////////////////////////////////////////////


CVssStsWriterWrapper::CVssStsWriterWrapper() :
    m_pStsWriter(NULL)
    {
    }

DWORD CVssStsWriterWrapper::InitializeThreadFunc(VOID *pv)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssStsWriterWrapper::InitializeThreadFunc");

    CVssStsWriterWrapper *pWrapper = (CVssStsWriterWrapper *) pv;

    BOOL fCoinitializeSucceeded = false;

    try
        {
        // intialize MTA thread
        ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_GEN,
                E_UNEXPECTED,
                L"CoInitializeEx failed 0x%08lx", ft.hr
                );

        fCoinitializeSucceeded = true;

        ft.hr = pWrapper->m_pStsWriter->Initialize();
        }
    VSS_STANDARD_CATCH(ft)

    if (fCoinitializeSucceeded)
        CoUninitialize();

    pWrapper->m_hrInitialize = ft.hr;
    return 0;
    }



HRESULT CVssStsWriterWrapper::CreateStsWriter()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssStsWriterWrapper::CreateStsWriter");

    if (m_pStsWriter)
        return S_OK;

    try
        {
        m_pStsWriter = new CSTSWriter;
        if (m_pStsWriter == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Allocation of CSTSWriter object failed.");

        DWORD tid;

        HANDLE hThread = CreateThread
                            (
                            NULL,
                            256* 1024,
                            CVssStsWriterWrapper::InitializeThreadFunc,
                            this,
                            0,
                            &tid
                            );

        if (hThread == NULL)
            ft.Throw
                (
                VSSDBG_GEN,
                E_UNEXPECTED,
                L"CreateThread failed with error %d",
                GetLastError()
                );

        // wait for thread to complete
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
        ft.hr = m_hrInitialize;
        }
    VSS_STANDARD_CATCH(ft)
    if (ft.HrFailed() && m_pStsWriter)
        {
        delete m_pStsWriter;
        m_pStsWriter = NULL;
        }

    return ft.hr;
    }

void CVssStsWriterWrapper::DestroyStsWriter()
    {
    if (m_pStsWriter)
        {
        m_pStsWriter->Uninitialize();
        delete m_pStsWriter;
        m_pStsWriter = NULL;
        }
    }


CVssStsWriterWrapper::~CVssStsWriterWrapper()
    {
    DestroyStsWriter();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\coord\src\svc.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    svc.cxx

Abstract:

    Implements the Volume Snapshot Service.

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     06/30/1999  Created.
    aoltean     07/23/1999  Making registration code more error-prone.
                            Changing the service name.
    aoltean     08/11/1999  Initializing m_bBreakFlagInternal
    aoltean     09/09/1999  dss -> vss
    aoltean     09/21/1999  Adding a new header for the "ptr" class.
    aoltean     09/27/1999  Adding some headers
    aoltean     03/10/2000  Simplifying Setup
    brianb      04/19/2000  Add Sql Writer
    brianb      05/03/2000  Start sql writer before registering COM stuff
    brianb      05/05/2000  fix sql writer startup

--*/


////////////////////////////////////////////////////////////////////////
//  Includes

#include "StdAfx.hxx"
#include <comadmin.h>
#include "resource.h"
#include "vssmsg.h"
#include "dbt.h"

// General utilities
#include "vs_inc.hxx"
#include "vs_idl.hxx"
#include "vs_sec.hxx"
#include "vs_reg.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "shim.hxx"
#include "coord.hxx"
#include "mgmt.hxx"
#include "bsstring.hxx"
#include "comadmin.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "sqlsnap.h"
#include "sqlwriter.h"

#include "iadmw.h"
#include "iiscnfg.h"
#include "mdmsg.h"

// BUG 628924  VSS: Need to remove SharePoint writer.
// #include "stswriter.h"
#include "regwriter.hxx"
#include "evtlogwriter.hxx"
#include "comregdbwriter.hxx"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSVCC"
//
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//  Constants

// 15 minutes of idle activity until shutdown.
// The time is expressed number of 100 nanosecond intervals.
const LONGLONG  x_llVSSVCIdleTimeout = (LONGLONG)(-3) * 60 * 1000 * 1000 * 10;

// Immediate shutdown.
const LONGLONG  x_llVSSVCShutdownTimeout = (LONGLONG)(-1);


////////////////////////////////////////////////////////////////////////
//  ATL Stuff


CVsServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VSSCoordinator, CVssCoordinator)
    OBJECT_ENTRY(CLSID_VssSnapshotMgmt, CVssSnapshotMgmt)
END_OBJECT_MAP()

// sql server (MSDE) Writer wrapper.  Included in coordinator because
// it needs admin privileges
CVssSqlWriterWrapper g_SqlWrapper;

// BUG 628924  VSS: Need to remove SharePoint writer.
// CVssStsWriterWrapper g_StsWrapper;


//
//  Store away the thread id of the thread executing the ServiceMain() method.
//  Used to syncronize the ending of the main thread.
//
static DWORD g_dwServiceMainThreadId = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  CVsServiceModule implementation


CVsServiceModule::CVsServiceModule()

/*++

Routine Description:

    Default constructor. Initialize ALL members with predefined values.

--*/

{
    ::VssZeroOut(&m_status);
    m_hInstance = NULL;
    m_hServiceStatus = NULL;
    m_hDiskNotify = NULL;
    m_dwThreadID = 0;
    m_bShutdownInProgress = false;
    m_hSubscriptionsInitializeEvent = NULL;
    m_bCOMStarted = false;
    m_pvFuncSimulateSnapshotFreezeInternal = NULL;
    m_pvFuncSimulateSnapshotThawInternal = NULL;

    // Initialize the members of the SERVICE_STATUS that don't change
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwControlsAccepted =
        SERVICE_ACCEPT_STOP |
        SERVICE_ACCEPT_SHUTDOWN;
}


///////////////////////////////////////////////////////////////////////////////////////
// Service control routines (i.e. ServiceMain-related methods)
//


void CVsServiceModule::StartDispatcher()

/*++

Routine Description:

    Called in the main execution path.
    Will register the _ServiceMain function.

Called by:

    CVsServiceModule::_WinMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher");

    try
    {
        SERVICE_TABLE_ENTRYW st[] =
        {
            { const_cast<LPWSTR>(x_wszServiceName), _ServiceMain },
            { NULL, NULL }
        };

        // Register the dispatcher main function into the Service Control Manager
        // This call blocks until ServiceMain tells SCM the service status is stopped
        if ( !::StartServiceCtrlDispatcherW(st) ) {
            ft.LogError(VSS_ERROR_STARTING_SERVICE_CTRL_DISPATCHER, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
                      L"StartServiceCtrlDispatcherW failed. 0x%08lx", GetLastError() );
        }

        //  If the ServiceMain thread is still running, wait for it to finish.
        if ( g_dwServiceMainThreadId != 0 )
        {
            HANDLE hServiceMainThread;

            hServiceMainThread = ::OpenThread( SYNCHRONIZE, FALSE, g_dwServiceMainThreadId );
            if ( hServiceMainThread != NULL )
            {
                ft.Trace( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher: Waiting for ServiceMain thread to finish..." );
                //  Wait up to 10 seconds
                if ( ::WaitForSingleObject( hServiceMainThread, 10000 ) == WAIT_TIMEOUT )
                {
                    ft.Trace( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher: Wait timed out, ending anyway" );
                }
                ::CloseHandle( hServiceMainThread );
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

    m_status.dwWin32ExitCode = ft.hr;
}


void WINAPI CVsServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}


void CVsServiceModule::ServiceMain(
    IN  DWORD   /* dwArgc */,
    IN  LPTSTR* /* lpszArgv */
    )

/*++

Routine Description:

    The main service control dispatcher.

Called by:

    Called by the NT Service framework following
    the StartServiceCtrlDispatcherW which was called in CVsServiceModule::StartDispatcher

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::ServiceMain");

    try
    {
        // Store away this thread id for use by the main thread.
        g_dwServiceMainThreadId = ::GetCurrentThreadId();

        // Needed for SERVICE_CONTROL_INTERROGATE that may come between the next two calls
        m_status.dwCurrentState = SERVICE_START_PENDING;

        // Register the control request handler
        m_hServiceStatus = ::RegisterServiceCtrlHandlerEx(x_wszServiceName, _Handler, NULL);
        if ( m_hServiceStatus == NULL ) {
            ft.LogError(VSS_ERROR_STARTING_SERVICE_REG_CTRL_HANDLER, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"RegisterServiceCtrlHandlerEx failed. 0x%08lx", GetLastError() );
        }

        // Now we will really inform the SCM that the service is pending its start.
        SetServiceStatus(SERVICE_START_PENDING);

        // Internal initialization
        OnInitializing();

        // The service is started now.
        SetServiceStatus(SERVICE_RUNNING);

        // Wait for shutdown attempt
        OnRunning();

        // Shutdown was started either by receiving the SERVICE_CONTROL_STOP
        // or SERVICE_CONTROL_SHUTDOWN events either because the COM objects number is zero.
        SetServiceStatus(SERVICE_STOP_PENDING);

        // Perform the un-initialization tasks
        OnStopping();

        // The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed()) {

        // Present the error codes to the caller.
        m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        m_status.dwServiceSpecificExitCode = ft.hr;

        // Perform the un-initialization tasks
        OnStopping();

        // The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED, false);
    }
}


DWORD WINAPI CVsServiceModule::_Handler
    (
    DWORD dwOpcode,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpEventContext
    )
    {
    return _Module.Handler(dwOpcode, dwEventType, lpEventData, lpEventContext);
    }


DWORD CVsServiceModule::Handler
    (
    DWORD dwOpcode,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpEventContext
    )

/*++

Routine Description:

    Used by Service Control Manager to inform this service about the service-related events

Called by:

    Service Control Manager.

--*/

    {
    UNREFERENCED_PARAMETER(lpEventContext);
    UNREFERENCED_PARAMETER(lpEventData);
    UNREFERENCED_PARAMETER(dwEventType);
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Handler");
    DWORD dwResult = ERROR_CALL_NOT_IMPLEMENTED;

    try
        {
        // re-initialize "volatile" members
        m_status.dwCheckPoint = 0;
        m_status.dwWaitHint = 0;
        m_status.dwWin32ExitCode = 0;
        m_status.dwServiceSpecificExitCode = 0;

        switch (dwOpcode)
            {
            case SERVICE_CONTROL_INTERROGATE:
                dwResult = NOERROR;
                // Present the previous state.
                SetServiceStatus(m_status.dwCurrentState);
                break;

            case SERVICE_CONTROL_STOP:
            case SERVICE_CONTROL_SHUTDOWN:
                dwResult = NOERROR;
                SetServiceStatus(SERVICE_STOP_PENDING);
                OnSignalShutdown();
                // The SERVICE_STOPPED status must be communicated
                // in Service's main function.
                break;
            }
        }
    VSS_STANDARD_CATCH(ft)

    return dwResult;
    }


void CVsServiceModule::SetServiceStatus(
        IN  DWORD dwState,
        IN  bool bThrowOnError /* = true */
        )

/*++

Routine Description:

    Informs the Service Control Manager about the new status.

Called by:

    CVsServiceModule methods

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::SetServiceStatus");

    try
    {
        ft.Trace( VSSDBG_COORD, L"Attempt to change the service status to %lu", dwState);

        BS_ASSERT(m_hServiceStatus != NULL);

        // Inform SCM about the new status
        m_status.dwCurrentState = dwState;
        if ( !::SetServiceStatus(m_hServiceStatus, &m_status) ) {
            ft.LogError(VSS_ERROR_SET_SERVICE_STATUS, VSSDBG_COORD << (INT)dwState << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
                        L"Error on calling SetServiceStatus. 0x%08lx", GetLastError() );
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.ThrowIf( bThrowOnError, VSSDBG_COORD, ft.hr,
                    L"Error on calling SetServiceStatus. 0x%08lx", ft.hr );
}


void CVsServiceModule::WaitForSubscribingCompletion() throw(HRESULT)

/*++

Routine Description:

    Wait until all subscriptions are performed

Called by:

    CVsServiceModule::ServiceMain

Throws:

    E_UNEXPECTED
        - WaitForSingleObject failures

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::WaitForSubscribingCompletion" );

    // Wait for shutdown
    DWORD dwRet = WaitForSingleObject(
        m_hSubscriptionsInitializeEvent,    // IN HANDLE hHandle,
        INFINITE                            // IN DWORD dwMilliseconds
        );
    if( dwRet != WAIT_OBJECT_0 )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
            L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hSubscriptionsInitializeEvent);
}


/*++

Routine Description:

    Gets the simulate snapshot function pointers.

Called by:

    CVsServiceModule::ServiceMain

Throws:

    E_UNEXPECTED
        - WaitForSingleObject failures

--*/
void CVsServiceModule::GetSimulateFunctions(
        OUT PFunc_SimulateSnapshotFreezeInternal *ppvSimulateFreeze,
        OUT PFunc_SimulateSnapshotThawInternal *ppvSimulateThaw )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::GetSimulateFunctions" );
    //
    //  Must wait for the shim to finish subscribing before accessing the
    //  internal freeze and thaw functions; otherwise the two m_pvFuncXXXX
    //  vars will be NULL.
    //
    WaitForSubscribingCompletion();
    if ( ppvSimulateFreeze != NULL )
        *ppvSimulateFreeze = m_pvFuncSimulateSnapshotFreezeInternal;
    if ( ppvSimulateThaw != NULL )
        *ppvSimulateThaw = m_pvFuncSimulateSnapshotThawInternal;
};



///////////////////////////////////////////////////////////////////////////////////////
// Service initialization, running and finalization routines
//


void CVsServiceModule::OnInitializing()

/*++

Routine Description:

    Initialize the service.

    If the m_status.dwWin32ExitCode is S_OK then initialization succeeded.
    Otherwise ServiceMain must silently shutdown the service.

Called by:

    CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnInitializing" );

    m_dwThreadID = GetCurrentThreadId();

    // First thing: turn on backup privilege
    ft.hr = TurnOnSecurityPrivilegeBackup();
    if (ft.HrFailed())
        ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"TurnOnSecurityPrivilegeBackup");

    // Initialize the COM library
    ft.hr = CoInitializeEx(
            NULL,
            COINIT_MULTITHREADED
            );
    if (ft.HrFailed()) {
        ft.LogError(VSS_ERROR_STARTING_SERVICE_CO_INIT_FAILURE, VSSDBG_COORD << ft.hr );
        ft.Throw( VSSDBG_COORD, ft.hr, L" Error: CoInitialize(NULL) returned 0x%08lx", ft.hr );
    }

    BS_ASSERT( ft.hr == S_OK );

    m_bCOMStarted = true;

    //
    // Initialize the security descriptor from registry
    // Contents: Admin, BO, System always enabled.
    // The rest of users are read from the SYSTEM\\CurrentControlSet\\Services\\VSS\\VssAccessControl key
    // The format of this registry key is a set of values of the form:
    //      REG_DWORD Name "domain1\user1", 1
    //      REG_DWORD Name "domain2\user2", 1
    //      REG_DWORD Name "domain3\user3", 0
    // where 1 means "Allow" and 0 means "Deny"
    //
    CVssSidCollection sidCollection;
    sidCollection.Initialize();

    // Get the SD. The pointer cannot be NULL
    PSECURITY_DESCRIPTOR pSD = sidCollection.GetSecurityDescriptor();
    BS_ASSERT(pSD);

    // Initialize COM security
    ft.hr = CoInitializeSecurity(
           pSD,                                 //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,       //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_DISABLE_AAA | EOAC_SECURE_REFS | EOAC_NO_CUSTOM_MARSHAL,
                                                //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );
    if (ft.HrFailed()) {
        ft.LogError(VSS_ERROR_STARTING_SERVICE_CO_INITSEC_FAILURE, VSSDBG_COORD << ft.hr );
        ft.Throw( VSSDBG_COORD, ft.hr,
                  L" Error: CoInitializeSecurity() returned 0x%08lx", ft.hr );
    }

    //  Turns off SEH exception handing for COM servers (BUG# 530092)
    ft.ComDisableSEH(VSSDBG_COORD);

    // Create the event needed to synchronize
    BS_ASSERT(m_hShutdownTimer == NULL);
    m_hShutdownTimer.Attach( CreateWaitableTimer(
        NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
        TRUE,       //  IN BOOL bManualReset,
        NULL        //  IN LPCTSTR lpName
        ) );
    if ( !m_hShutdownTimer.IsValid() ) {
        if (GetLastError() != ERROR_OUTOFMEMORY)
            ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
        ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
                  L"Error creating the shutdown timer 0x%08lx", GetLastError() );
    }

    // Create the event needed to synchronize
    BS_ASSERT(m_hSubscriptionsInitializeEvent == NULL);
    m_hSubscriptionsInitializeEvent = CreateEvent(
        NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
        TRUE,       //  IN BOOL bManualReset,
        FALSE,      //  IN BOOL bInitialState,
        NULL        //  IN LPCTSTR lpName
        );
    if ( m_hSubscriptionsInitializeEvent == NULL ) {
        if (GetLastError() != ERROR_OUTOFMEMORY)
            ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
        ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
                  L"Error creating the subscriptions sync event 0x%08lx", GetLastError() );
    }

    //  Register the COM class objects
    ft.hr = RegisterClassObjects( CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE );
    if (ft.HrFailed()) {
        if (GetLastError() != ERROR_OUTOFMEMORY)
            ft.LogError(VSS_ERROR_STARTING_SERVICE_CLASS_REG, VSSDBG_COORD << ft.hr);
        ft.Throw( VSSDBG_COORD, ft.hr, L" Error: RegisterClassObjects() returned 0x%08lx", ft.hr );
    }

    // The service is started now to prevent the service startup from
    // timing out.  The COM registration is done after we fully complete
    // initialization
    SetServiceStatus(SERVICE_RUNNING);

    // startup sql writer if not already started.
    g_SqlWrapper.CreateSqlWriter();

//  BUG 628924  VSS: Need to remove SharePoint writer.
//  g_StsWrapper.CreateStsWriter();

    // startup the Registry writer if not already started.
    CRegistryWriter::CreateWriter();

    // startup the Event Log writer if not already started.
    CEventLogWriter::CreateWriter();

    // startup the Com+ RegDB writer if not already started.
    CComRegDBWriter::CreateWriter();

    // register the shim snapshot writers
    RegisterSnapshotSubscriptions( &m_pvFuncSimulateSnapshotFreezeInternal, &m_pvFuncSimulateSnapshotThawInternal );

    // Mark that all the subscriptiuons are initialized
    if (!::SetEvent( m_hSubscriptionsInitializeEvent )) {
        ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
        ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
                L"Error on setting the sub sync event 0x%08lx", GetLastError());
    }

}



void CVsServiceModule::OnRunning()

/*++

Routine Description:

    Keeps the service alive until the job is done.

Called by:

    CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnRunning" );

    // Wait for shutdown
    DWORD dwRet = WaitForSingleObject(
        m_hShutdownTimer,                   // IN HANDLE hHandle,
        INFINITE                            // IN DWORD dwMilliseconds
        );
    if( dwRet != WAIT_OBJECT_0 )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
            L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hShutdownTimer);

    // Trace the fact that the service will be shutdown
    ft.Trace( VSSDBG_COORD, L"VSSVC: %s event received",
        m_bShutdownInProgress? L"Shutdown": L"Idle timeout");
}


void CVsServiceModule::OnStopping()

/*++

Routine Description:

    Performs the uninitialization tasks.

Called by:

    CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnStopping" );

    try
    {
        g_SqlWrapper.DestroySqlWriter();

//      BUG 628924  VSS: Need to remove SharePoint writer.
//      g_StsWrapper.DestroyStsWriter();

        CRegistryWriter::DestroyWriter();

        CEventLogWriter::DestroyWriter();

        CComRegDBWriter::DestroyWriter();

        //  Unregister the COM classes
        ft.hr = RevokeClassObjects();
        if (ft.HrFailed())
            ft.Trace( VSSDBG_COORD, L" Error: RevokeClassObjects returned hr = 0x%08lx", ft.hr );

        // Remove the providers array
        CVssProviderManager::UnloadInternalProvidersArray();

        // Remove the global cached interfaces
        CVssProviderManager::UnloadGlobalProviderItfCache();

        try
        {
                // Remove state from all stateful objects
                CVssProviderManager::DeactivateAll();
        }
        VSS_STANDARD_CATCH(ft)

        UnregisterSnapshotSubscriptions();
        m_pvFuncSimulateSnapshotFreezeInternal = NULL;
        m_pvFuncSimulateSnapshotThawInternal = NULL;

        // Uninitialize the COM library
        if ( m_bCOMStarted )
            CoUninitialize();

        if ( !::CloseHandle( m_hSubscriptionsInitializeEvent ) )
            ft.Trace( VSSDBG_COORD, L"Error closing the sub sync event 0x%08lx", GetLastError() );
    }
    VSS_STANDARD_CATCH(ft)
}


void CVsServiceModule::OnSignalShutdown()

/*++

Routine Description:

    Called when the current service should not be stopping its activity.
    Too bad about COM calls in progress - the running clients will get an error.

Called by:

    CVsServiceModule::Handler

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnSignalShutdown" );

    try
    {
        // Trace the fact that the service will be shutdown
        ft.Trace( VSSDBG_COORD, L"VSSVC: Trying to shutdown the service");
        
        if (m_hShutdownTimer.IsValid())
        {
            LARGE_INTEGER liDueTime;
            liDueTime.QuadPart = x_llVSSVCShutdownTimeout;

            m_bShutdownInProgress = true;
            
            // Set the timer to become signaled immediately.
            if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
                ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
                    L"Error on setting the shutdown event 0x%08lx", GetLastError());
            BS_ASSERT(GetLastError() == 0);
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed()) {
        m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        m_status.dwServiceSpecificExitCode = ft.hr;
    }
}


///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//


LONG CVsServiceModule::Lock()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Lock" );

    // If we are not shutting down then we are cancelling the "idle timeout" timer.
    if (!m_bShutdownInProgress) {

        // Trace the fact that the idle period is done.
        ft.Trace( VSSDBG_COORD, L"VSSVC: Idle period is finished");

        // Cancel the timer
        if (!::CancelWaitableTimer(m_hShutdownTimer))
            ft.Trace(VSSDBG_COORD, L"Error cancelling the waitable timer 0x%08lx",
                GetLastError());
    }

    return CComModule::Lock();
}


LONG CVsServiceModule::Unlock()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Unlock" );

    // Check if we entered in the idle period.
    LONG lRefCount = CComModule::Unlock();
    if ( lRefCount == 0) {
        LARGE_INTEGER liDueTime;
        liDueTime.QuadPart = x_llVSSVCIdleTimeout;

        // Trace the fact that the idle period begins
        ft.Trace( VSSDBG_COORD, L"VSSVC: Idle period begins");

        // Set the timer to become signaled after the proper idle time.
        // We cannot fail at this point (BUG 265455)
        if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
            ft.LogGenericWarning( VSSDBG_COORD, L"SetWaitableTimer(...) [0x%08lx]", GetLastError());
        BS_ASSERT(GetLastError() == 0);

        return 0;
    }
    return lRefCount;
}



///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//



LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (*p1 != NULL)
    {
        LPCTSTR p = p2;
        while (*p != NULL)
        {
            if (*p1 == *p++)
                return p1+1;
        }
        p1++;
    }
    return NULL;
}


extern "C" int WINAPI _tWinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE, /* hPrevInstance */
    IN LPTSTR lpCmdLine,
    IN int /* nShowCmd */
    )
{
    return _Module._WinMain( hInstance, lpCmdLine );
}


int WINAPI CVsServiceModule::_WinMain(
    IN HINSTANCE hInstance,
    IN LPTSTR /* lpCmdLine */
    )

/*++

Routine Description:

    Called in the main execution path.
    Used to:
        - start the service, if no parameters on the command line.
        - register the service, if the "/Register" or "-Register" command line parameter is present

Called by:

    _WinMain()

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::_WinMain");

    try
    {
        // Get the command line
        LPTSTR lpCmdLine = GetCommandLine();
        ft.Trace( VSSDBG_COORD, L"Trace: VSS command-line: '%s'", T2W(lpCmdLine) );

        // Set the reporting mode for ATLASSERT and BS_ASSERT macros.
//        VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

        // Initialize the internal variables
        Init(ObjectMap, hInstance);
        m_hInstance = hInstance;

        // Parse the command line
        TCHAR szTokens[] = _T("-/");
        LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);

        bool bRegisterTentative = false;
        while (lpszToken != NULL)
        {
            ft.Trace( VSSDBG_COORD, L"Current token = \'%s\'", lpszToken );

            // Register as Server
            if (lstrcmpi(lpszToken, _T("Register"))==0)
            {
                bRegisterTentative = true;
                ft.hr = RegisterServer(TRUE);
                break;
            }

            lpszToken = FindOneOf(lpszToken, szTokens);
        }

        // Start the dispatcher function
        if (!bRegisterTentative)
            StartDispatcher();
    }
    VSS_STANDARD_CATCH(ft)

    // When we get here, the service has been stopped
    return m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sec\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\jetwriter\ijetwriter.cpp ===
/*
**++
**
**  Copyright (c) 2000-2001  Microsoft Corporation
**
**  Module Name:
**
**  wrtrrsm.cpp
**
**
**  Abstract:
**
**  Writer shim module for RSM
**
**
**  Author:
**
**  Brian Berkowitz [brianb]
**
**
**  Revision History:
**
**  X-11    MCJ     Michael C. Johnson      19-Sep-2000
**      215218: Wildcard name of log files returned by OnIdentify()
**      215390: Incorporate multiple '.' fix in MatchFileName from NtBackup
**
**  X-10    MCJ     Michael C. Johnson      19-Sep-2000
**      176860: Add the missing calling convention specifiers
**
**  X-9 MCJ     Michael C. Johnson      21-Aug-2000
**      Added copyright and edit history
**      161899: Don't add a component for a database file in the
**              exclude list.
**      165873: Remove trailing '\' from metadata file paths
**      165913: Deallocate memory on class destruction
**
**
**--
*/

#include <stdafx.h>

#include <esent.h>

#include <vss.h>
#include <vswriter.h>

#include <jetwriter.h>


#include "vs_inc.hxx"
#include "ijetwriter.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "JTWIJTWC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  local functions


#define UMAX(_a, _b)            ((_a) > (_b)      ? (_a)    : (_b))
#define EXECUTEIF(_bSuccess, _fn)   ((_bSuccess)      ? (_fn)   : (_bSuccess))
#define GET_STATUS_FROM_BOOL(_bSucceed) ((_bSucceed)      ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))


typedef struct _ExpandedPathInfo
    {
    LIST_ENTRY  leQueueHead;
    PWCHAR  pwszOriginalFilePath;
    PWCHAR  pwszOriginalFileName;
    PWCHAR  pwszExpandedFilePath;
    PWCHAR  pwszExpandedFileName;
    bool    bRecurseIntoSubdirectories;
    } EXPANDEDPATHINFO, *PEXPANDEDPATHINFO, **PPEXPANDEDPATHINFO;



static void RemoveAnyTrailingSeparator (PCHAR szPath)
    {
    ULONG   ulPathLength = strlen (szPath);

    if ('\\' == szPath [ulPathLength - 1])
    {
    szPath [ulPathLength - 1] = '\0';
    }
    }


static void RemoveAnyTrailingSeparator (PWCHAR wszPath)
    {
    ULONG   ulPathLength = wcslen (wszPath);

    if (L'\\' == wszPath [ulPathLength - 1])
    {
    wszPath [ulPathLength - 1] = UNICODE_NULL;
    }
    }


static bool ConvertName (PCHAR  szSourceName,
             ULONG  ulTargetBufferLengthInChars,
             PWCHAR wszTargetBuffer)
    {
    bool bSucceeded = true;


    wszTargetBuffer [0] = L'\0';


    /*
    ** Only need to do the conversion for non-zero length
    ** strings. Returning a zero length string for a zero length
    ** argument is an ok thing to do.
    */
    if ('\0' != szSourceName [0])
    {
    bSucceeded = (0 != MultiByteToWideChar (CP_OEMCP,
                        0,
                        szSourceName,
                        -1,
                        wszTargetBuffer,
                        ulTargetBufferLengthInChars));
    }


    return (bSucceeded);
    } /* ConvertName () */


static bool ConvertNameAndSeparateFilePaths (PCHAR  pszSourcePath,
                         ULONG  ulTargetBufferLength,
                         PWCHAR pwszTargetPath,
                         PWCHAR&    pwszTargetFileSpec)
    {
    bool    bSucceeded;
    PWCHAR  pwchLastSlash;


    bSucceeded = ConvertName (pszSourcePath, ulTargetBufferLength, pwszTargetPath);

    if (bSucceeded)
    {
    /*
    ** Scan backwards from the end of the target path, zap the
    ** end-most '\' and point the file spec at the character
    ** following where the '\' used to be.
    */
    pwchLastSlash = wcsrchr (pwszTargetPath, L'\\');

    bSucceeded = (NULL != pwchLastSlash);
    }


    if (bSucceeded)
    {
    pwszTargetFileSpec = pwchLastSlash + 1;

    *pwchLastSlash = UNICODE_NULL;
    }


    return (bSucceeded);
    } /* ConvertNameAndSeparateFilePaths () */


static void  ConvertPathToLogicalPath(PWCHAR wszSource, ULONG lMaxSize, PWCHAR wszDest)
{
    const WCHAR Slash = L'\\';
    const WCHAR Score = L'_';

    // copy the string
    memset(wszDest, 0, lMaxSize * sizeof(WCHAR));
    wcsncpy(wszDest, wszSource, lMaxSize - 1);

    // replace all slashes with underscores
    WCHAR* nextSlash = wcschr(wszDest, Slash);
    while (nextSlash != NULL)
    {
        *nextSlash = Score;
        nextSlash = wcschr(nextSlash + 1, Slash);
    }

    return;
}

/*
** This routine breaks out the next path and filespec from a list of
** filespecs. The expected format of the input string is
**
**  path\[filespec] [/s]
**
**
** The list can contain an arbitrary number of filespecs each
** separated by a semi-colon.
*/
static bool DetermineNextPathWorker (LPCWSTR  pwszFileList,
                     LPCWSTR& pwszReturnedCursor,
                     ULONG&   ulReturnedDirectoryStart,
                     ULONG&   ulReturnedDirectoryLength,
                     ULONG&   ulReturnedFilenameStart,
                     ULONG&   ulReturnedFilenameLength,
                     bool&    bReturnedRecurseIntoSubdirectories,
                     bool&    bReturnedFoundSpec)
    {
    bool    bSucceeded                    = true;
    bool    bFoundSpec                    = false;
    ULONG   ulPathNameLength;
    ULONG   ulFileNameLength;
    ULONG   ulIndex;
    ULONG   ulIndexSubDirectory           = 0;
    ULONG   ulIndexLastDirectorySeparator = 0;
    ULONG   ulIndexFirstCharInSpec        = 0;
    ULONG   ulIndexLastCharInSpec         = 0;
    const ULONG ulLengthFileList              = wcslen (pwszFileList);


    /*
    ** The format of the string we are expecting is "filename.ext /s
    ** ;nextname", ie a list of semi-colon separated names with an
    ** optional trailing '/s'. There can be an arbitrary number of
    ** spaces before the '/' and before the ';': these will be
    ** stripped out and discarded. So we start by scanning for the
    ** first '/' or ';' characters.
    **
    ** Look for a ';' first to determine the end point.
    */
    if ((NULL         == pwszFileList) ||
    (UNICODE_NULL == pwszFileList [0]))
    {
    bFoundSpec = false;
    }

    else if (( L';'  == pwszFileList [0]) ||
         ( L'/'  == pwszFileList [0]) ||
         ((L'\\' == pwszFileList [0]) && (UNICODE_NULL == pwszFileList [1])))
    {
    bSucceeded = false;
    bFoundSpec = false;
    }

    else
    {
    bFoundSpec = true;
    }


    if (bSucceeded && bFoundSpec)
    {
    while (L' ' == pwszFileList [ulIndexFirstCharInSpec])
        {
        ulIndexFirstCharInSpec++;
        }


    for (ulIndex = ulIndexFirstCharInSpec; ulIndex < ulLengthFileList; ulIndex++)
        {
        if ((UNICODE_NULL == pwszFileList [ulIndex]) ||
        (L';'         == pwszFileList [ulIndex]))
        {
        /*
        ** We found the end of this specification
        */
        break;
        }

        else if (L'\\' == pwszFileList [ulIndex])
        {
        /*
        ** Found a backslash? Record it's location. We'll want
        ** this later when determining what the file name is
        ** and so on.
        */
        ulIndexLastDirectorySeparator = ulIndex;
        }

        else if ((L'/' ==           pwszFileList [ulIndex]) &&
             (L's' == towlower (pwszFileList [ulIndex + 1])))
        {
        ulIndexSubDirectory = ulIndex;
        }
        }



    ulIndexLastCharInSpec = (0 == ulIndexSubDirectory) ? ulIndex - 1 : ulIndexSubDirectory - 1;

    while (L' ' == pwszFileList [ulIndexLastCharInSpec])
        {
        ulIndexLastCharInSpec--;
        }


    _ASSERTE (ulIndex                       >  ulIndexSubDirectory);
    _ASSERTE (ulIndexSubDirectory == 0 ||
              ulIndexSubDirectory           >  ulIndexLastCharInSpec);
    _ASSERTE (ulIndexLastCharInSpec         >= ulIndexLastDirectorySeparator);
    _ASSERTE (ulIndexLastDirectorySeparator >  ulIndexFirstCharInSpec);


    /*
    ** We may have an illegal spec here with a missing '\'. Come
    ** on folks, there ought to be at least one. one measly '\' is
    ** all I'm after.
    */
    bSucceeded = (0 < ulIndexLastDirectorySeparator);
    }




    if (bSucceeded)
    {
    if (bFoundSpec)
        {
        ulPathNameLength = ulIndexLastDirectorySeparator - ulIndexFirstCharInSpec;
        ulFileNameLength = ulIndexLastCharInSpec         - ulIndexLastDirectorySeparator;


        pwszReturnedCursor                 = (UNICODE_NULL == pwszFileList [ulIndex])
                                    ? &pwszFileList [ulIndex]
                                    : &pwszFileList [ulIndex + 1];

        ulReturnedDirectoryStart           = ulIndexFirstCharInSpec;
        ulReturnedDirectoryLength          = ulPathNameLength;
        ulReturnedFilenameStart            = ulIndexLastDirectorySeparator + 1;
        ulReturnedFilenameLength           = ulFileNameLength;

        bReturnedRecurseIntoSubdirectories = (0 != ulIndexSubDirectory);
        bReturnedFoundSpec                 = true;
        }

    else
        {
        pwszReturnedCursor                 = pwszFileList;

        ulReturnedDirectoryStart           = 0;
        ulReturnedDirectoryLength          = 0;
        ulReturnedFilenameStart            = 0;
        ulReturnedFilenameLength           = 0;

        bReturnedRecurseIntoSubdirectories = false;
        bReturnedFoundSpec                 = false;
        }
    }



    return (bSucceeded);
    } /* DetermineNextPathWorker () */



static bool DetermineNextPathLengths (LPCWSTR pwszFileList,
                      ULONG&  ulReturnedLengthDirectory,
                      ULONG&  ulReturnedLengthFilename,
                      bool&   bReturnedRecurseIntoSubdirectories,
                      bool&   bReturnedFoundSpec)
    {
    bool    bSucceeded;
    LPCWSTR pwszUpdatedCursor;
    ULONG   ulIndexDirectoryStart;
    ULONG   ulIndexFilenameStart;


    bSucceeded = DetermineNextPathWorker (pwszFileList,
                      pwszUpdatedCursor,
                      ulIndexDirectoryStart,
                      ulReturnedLengthDirectory,
                      ulIndexFilenameStart,
                      ulReturnedLengthFilename,
                      bReturnedRecurseIntoSubdirectories,
                      bReturnedFoundSpec);

    return (bSucceeded);
    } /* DetermineNextPathLengths () */


static bool DetermineNextPath (LPCWSTR  pwszFileList,
                   LPCWSTR& pwszReturnedCursor,
                   ULONG    ulLengthBufferDirectory,
                   PWCHAR   pwszBufferDirectory,
                   ULONG    ulLengthBufferFilename,
                   PWCHAR   pwszBufferFilename,
                   bool&    bReturnedRecurseIntoSubdirectories,
                   bool&    bReturnedFoundSpec)
    {
    bool    bSucceeded                    = true;
    bool    bRecurseIntoSubdirectories;
    bool    bFoundSpec;
    bool    bWildcardFilename;
    LPCWSTR pwszUpdatedCursor;
    ULONG   ulLengthDirectory;
    ULONG   ulLengthFilename;
    ULONG   ulIndexDirectoryStart;
    ULONG   ulIndexFilenameStart;


    bSucceeded = DetermineNextPathWorker (pwszFileList,
                      pwszUpdatedCursor,
                      ulIndexDirectoryStart,
                      ulLengthDirectory,
                      ulIndexFilenameStart,
                      ulLengthFilename,
                      bRecurseIntoSubdirectories,
                      bFoundSpec);

    if (bSucceeded && bFoundSpec)
    {
    if ((ulLengthBufferDirectory < ((sizeof (WCHAR) * ulLengthDirectory) + sizeof (UNICODE_NULL))) ||
        (ulLengthBufferFilename  < ((sizeof (WCHAR) * ulLengthFilename)  + sizeof (UNICODE_NULL))))
        {
        /*
        ** Oops, buffer overflow would occur if we were to proceed
        ** with the copy.
        */
        bSucceeded = false;
        }
    }


    if (bSucceeded)
    {
    bReturnedRecurseIntoSubdirectories = bRecurseIntoSubdirectories;
    bReturnedFoundSpec                 = bFoundSpec;
    pwszReturnedCursor                 = pwszUpdatedCursor;


    if (bFoundSpec)
        {
        /*
        ** Everything up to, but excluding the last directory
        ** separator is the path. Everything after the last directory
        ** separator up to and including the last char is the
        ** filespec. If the filespec is zero length, then add the '*'
        ** wildcard.
        */
        bWildcardFilename = (0 == ulLengthFilename);

        ulLengthFilename += bWildcardFilename ? 1 : 0;


        memcpy (pwszBufferDirectory,
            &pwszFileList [ulIndexDirectoryStart],
            sizeof (WCHAR) * ulLengthDirectory);

        memcpy (pwszBufferFilename,
            (bWildcardFilename) ? L"*" : &pwszFileList [ulIndexFilenameStart],
            sizeof (WCHAR) * ulLengthFilename);

        pwszBufferDirectory [ulLengthDirectory] = UNICODE_NULL;
        pwszBufferFilename  [ulLengthFilename]  = UNICODE_NULL;
        }
    }


    return (bSucceeded);
    } /* DetermineNextPath () */



static bool ValidateIncludeExcludeList (LPCWSTR pwszFileList)
    {
    LPCWSTR pwszCursor  = pwszFileList;
    bool    bSucceeded  = true;
    bool    bFoundFiles = true;
    bool    bRecurseIntoSubdirectories;
    ULONG   ulIndexDirectoryStart;
    ULONG   ulIndexFilenameStart;
    ULONG   ulLengthDirectory;
    ULONG   ulLengthFilename;

    while (bSucceeded && bFoundFiles)
    {
    bSucceeded = EXECUTEIF (bSucceeded, (DetermineNextPathWorker (pwszCursor,
                                      pwszCursor,
                                      ulIndexDirectoryStart,
                                      ulLengthDirectory,
                                      ulIndexFilenameStart,
                                      ulLengthFilename,
                                      bRecurseIntoSubdirectories,
                                      bFoundFiles)));
    }


    return (bSucceeded);
    } /* ValidateIncludeExcludeList () */


/*
** Based on MatchFname() from \nt\base\fs\utils\ntback50\be\bsdmatch.cpp
*/
static bool MatchFilename (LPCWSTR pwszPattern,    /* I - file name (with wildcards)     */
               LPCWSTR pwszFilename)   /* I - file name (without wildcards ) */
    {
    ULONG   ulIndexPattern;                 /* index for pwszPattern */
    ULONG   ulIndexFilename;                /* index for pwszFilename */
    ULONG   ulLengthPattern;
    const ULONG ulLengthFilename        = wcslen (pwszFilename);
    bool    bSucceeded              = true;
    PWCHAR  pwszNameBufferAllocated = NULL;         /* allocated temp name buffer  */
    PWCHAR  pwszNameBufferTemp;             /* pointer to one of the above */
    PWCHAR  pwchTemp;
    WCHAR   pwszNameBufferStatic [256];         /* static temp name buffer     */
    WCHAR   wchSavedChar ;


    ulIndexFilename = 0;

    if (wcscmp (pwszPattern, L"*") && wcscmp (pwszPattern, L"*.*"))
    {
    bool bTryWithDot = false;

    do
        {
        if (bTryWithDot)
        {
        /*
        ** Size of name_buff minus a null, minus a dot for the
        ** "bTryWithDot" code below. If the name is longer than the
        ** static buffer, allocate one from the heap.
        */
        if (((ulLengthFilename + 2) * sizeof (WCHAR)) > sizeof (pwszNameBufferStatic))
            {
            pwszNameBufferAllocated = new WCHAR [ulLengthFilename + 2];
            pwszNameBufferTemp = pwszNameBufferAllocated;
            }
        else
            {
            pwszNameBufferTemp = pwszNameBufferStatic;
            }

        if (pwszNameBufferTemp != NULL)
            {
            wcscpy (pwszNameBufferTemp, pwszFilename);
            wcscat (pwszNameBufferTemp, L".");
            pwszFilename = pwszNameBufferTemp;
            ulIndexFilename = 0;
            bSucceeded = true;
            }

        bTryWithDot = false;
        }

        else if (wcschr (pwszFilename, L'.') == NULL)
        {
        bTryWithDot = true;
        }


        for (ulIndexPattern = 0; (pwszPattern [ulIndexPattern] != 0) && (bSucceeded) ; ulIndexPattern++)
        {
        switch (pwszPattern [ulIndexPattern])
            {
            case L'*':
            while (pwszPattern [ulIndexPattern + 1] != UNICODE_NULL)
                {
                if (pwszPattern [ulIndexPattern + 1] == L'?')
                {
                if (pwszFilename [++ulIndexFilename] == UNICODE_NULL)
                    {
                    break ;
                    }
                }

                else if (pwszPattern [ulIndexPattern + 1] != L'*')
                {
                break ;
                }

                ulIndexPattern++ ;
                }

            pwchTemp = wcspbrk (&pwszPattern [ulIndexPattern + 1], L"*?");

            if (pwchTemp != NULL)
                {
                wchSavedChar = *pwchTemp;
                *pwchTemp = UNICODE_NULL;

                ulLengthPattern = wcslen (&pwszPattern [ulIndexPattern + 1]);

                while (pwszFilename [ulIndexFilename] &&
                   _wcsnicmp (&pwszFilename [ulIndexFilename],
                          &pwszPattern [ulIndexPattern + 1],
                          ulLengthPattern))
                {
                ulIndexFilename++;
                }

                ulIndexPattern += ulLengthPattern;

                *pwchTemp = wchSavedChar;

                if (pwszFilename [ulIndexFilename] == UNICODE_NULL)
                {
                bSucceeded = false;
                }
                else
                {
                ulIndexFilename++;
                }
                }
            else
                {
                if (pwszPattern [ulIndexPattern + 1] == UNICODE_NULL)
                {
                ulIndexFilename = wcslen (pwszFilename);
                break;
                }
                else
                {
                pwchTemp = wcschr (&pwszFilename [ulIndexFilename],
                           pwszPattern [ulIndexPattern + 1]);

                if (pwchTemp != NULL)
                    {
                    ulIndexFilename += (ULONG)(pwchTemp - &pwszFilename [ulIndexFilename]);
                    }
                else
                    {
                    bSucceeded = false;
                    }
                }
                }
            break;


            case L'?' :
            if (pwszFilename [ulIndexFilename] != UNICODE_NULL)
                {
                ulIndexFilename++;
                }
            break;


            default:
            if (pwszFilename [ulIndexFilename] == UNICODE_NULL)
                {
                bSucceeded = false;
                }

            else if (towupper (pwszFilename [ulIndexFilename]) != towupper (pwszPattern [ulIndexPattern]))
                {
                ULONG   ulIndexPreviousStar = ulIndexPattern;


                /*
                ** Set the index back to the last '*'
                */
                bSucceeded = false;

                do
                {
                if (pwszPattern [ulIndexPreviousStar] == L'*')
                    {
                    ulIndexPattern = ulIndexPreviousStar;
                    ulIndexFilename++;
                    bSucceeded = true;
                    break;
                    }
                } while (ulIndexPreviousStar-- > 0);
                }
            else
                {
                ulIndexFilename++;
                }

            }
        }


        if (pwszFilename [ulIndexFilename] != UNICODE_NULL)
        {
        bSucceeded = false;
        }

        } while ((!bSucceeded) && (bTryWithDot));
    }


    delete [] pwszNameBufferAllocated;


    return (bSucceeded);
    } /* MatchFilename () */


/////////////////////////////////////////////////////////////////////////////
//  class CVssIJetWriter
//
// logical path   == dbpathname (with slashes turned to underscores)
// component name == dbfilename (minus the extension?)
// caption        == display name
//
//
// add db and slv files as database files
// add the per-instance log file to each database even though is is the same each time.



STDMETHODCALLTYPE CVssIJetWriter::~CVssIJetWriter()
    {
    PostProcessIncludeExcludeLists (true );
    PostProcessIncludeExcludeLists (false);

    delete m_wszWriterName;
    delete m_wszFilesToInclude;
    delete m_wszFilesToExclude;
    }



BOOL CVssIJetWriter::CheckExcludedFileListForMatch (LPCWSTR pwszDatabaseFilePath,
                            LPCWSTR pwszDatabaseFileSpec)
    {
    BOOL        bMatchFound = false;
    PLIST_ENTRY     pleElement  = m_leFilesToExcludeEntries.Flink;
    UNICODE_STRING  ucsExcludedFilePath;
    UNICODE_STRING  ucsDatabaseFilePath;
    PEXPANDEDPATHINFO   pepnPathInfomation;


    RtlInitUnicodeString (&ucsDatabaseFilePath, pwszDatabaseFilePath);


    while ((&m_leFilesToExcludeEntries != pleElement) && !bMatchFound)
    {
    pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));

    RtlInitUnicodeString (&ucsExcludedFilePath,
                  pepnPathInfomation->pwszExpandedFilePath);


    if (pepnPathInfomation->bRecurseIntoSubdirectories)
        {
        bMatchFound = RtlPrefixUnicodeString (&ucsExcludedFilePath,
                          &ucsDatabaseFilePath,
                          true);
        }
    else
        {
        bMatchFound = RtlEqualUnicodeString (&ucsExcludedFilePath, &ucsDatabaseFilePath, true) &&
              MatchFilename (pepnPathInfomation->pwszExpandedFileName, pwszDatabaseFileSpec);
        }



    pleElement = pleElement->Flink;
    }




    return (bMatchFound);
    } /* CVssIJetWriter::CheckExcludedFileListForMatch () */




bool CVssIJetWriter::ProcessJetInstance (JET_INSTANCE_INFO *pInstanceInfo)
    {
    JET_ERR jetStatus;
    HRESULT hrStatus;
    DWORD   dwStatus;
    bool    bSucceeded;
    bool    bRestoreMetadata        = false;
    bool    bNotifyOnBackupComplete = false;
    bool    bSelectable             = false;
    bool    bIncludeComponent;
    CHAR    szPathShortName        [MAX_PATH];
    CHAR    szPathFullName         [MAX_PATH];
    WCHAR   wszInstanceName        [MAX_PATH];
    WCHAR   wszDatabaseName        [MAX_PATH];
    WCHAR   wszDatabaseLogicalPath [MAX_PATH];
    WCHAR   wszDatabaseDisplayName [MAX_PATH];
    WCHAR   wszDatabaseFilePath    [MAX_PATH];
    WCHAR   wszDatabaseSLVFilePath [MAX_PATH];
    WCHAR   wszLogFilePath         [MAX_PATH];
    WCHAR   wszLogFileName         [MAX_PATH];
    WCHAR   wszCheckpointFilePath  [MAX_PATH];
    WCHAR   wszCheckpointFileName  [MAX_PATH];

    PWCHAR  pwszDatabaseFileName    = L"";
    PWCHAR  pwszDatabaseSLVFileName = L"";




    /*
    ** A valid instance will have an instance Id, but if it's not
    ** actually being used for anything it may well not have a name,
    ** any log or database files.
    **
    ** See if we can get hold of the name of the log file for this
    ** instance.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
                               JET_sesidNil,
                               JET_paramLogFilePath,
                               NULL,
                               szPathShortName,
                               sizeof (szPathShortName)));

    if (bSucceeded)
    {
    dwStatus = GetFullPathNameA (szPathShortName,
                     sizeof (szPathFullName),
                     szPathFullName,
                     NULL);

    bSucceeded = (dwStatus > 0);
    }


    if (bSucceeded)
    {
    RemoveAnyTrailingSeparator (szPathFullName);

    bSucceeded = ConvertName (szPathFullName,
                  MAX_PATH,
                  wszLogFilePath);
    }


    BsDebugTrace (0,
          DEBUG_TRACE_VSS_WRITER,
          (L"CVssIJetWriter::ProcessJetInstance - "
           L"%s calling JetGetSystemParameter() with instance Log file path '%S' (shortname) or '%s' full name",
           bSucceeded ? L"Succeeded" : L"FAILED",
           szPathShortName,
           wszLogFilePath));





    /*
    ** Ok, now get the SystemPath which we will need to construct the
    ** path for the checkpoint file.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
                               JET_sesidNil,
                               JET_paramSystemPath,
                               NULL,
                               szPathShortName,
                               sizeof (szPathShortName)));

    if (bSucceeded)
    {
    dwStatus = GetFullPathNameA (szPathShortName,
                     sizeof (szPathFullName),
                     szPathFullName,
                     NULL);

    bSucceeded = (dwStatus > 0);
    }


    if (bSucceeded)
    {
    RemoveAnyTrailingSeparator (szPathFullName);

    bSucceeded = ConvertName (szPathFullName,
                  MAX_PATH,
                  wszCheckpointFilePath);
    }


    BsDebugTrace (0,
          DEBUG_TRACE_VSS_WRITER,
          (L"CVssIJetWriter::ProcessJetInstance - "
           L"%s calling JetGetSystemParameter() with checkpoint file path '%S' (shortname) or '%s' full name",
           bSucceeded ? L"Succeeded" : L"FAILED",
           szPathShortName,
           wszCheckpointFilePath));



    /*
    ** Ok, now get the base name which we will need to construct the
    ** file spec for the log and checkpoint files. Note that we expect
    ** this to be just 3 chars long.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
                               JET_sesidNil,
                               JET_paramBaseName,
                               NULL,
                               szPathShortName,
                               sizeof (szPathShortName)));

    if (bSucceeded)
    {
    /*
    ** Convert to wide char ensuring that we leave a little room
    ** for the "*.log"/".chk" strings to be appended to form the
    ** log file spec and the checkpoint file specs respectively.
    */
    bSucceeded = ConvertName (szPathShortName,
                  MAX_PATH - sizeof ("*.log"),
                  wszCheckpointFileName);
    }


    if (bSucceeded)
    {
    wcscpy (wszLogFileName, wszCheckpointFileName);


    wcscat (wszCheckpointFileName, L".chk" );
    wcscat (wszLogFileName,        L"*.log");
    }


    BsDebugTrace (0,
          DEBUG_TRACE_VSS_WRITER,
          (L"CVssIJetWriter::ProcessJetInstance - "
           L"%s calling JetGetSystemParameter() for base name '%S' to form LogFileName '%s' and CheckpointFileName '%s'",
           bSucceeded ? L"Succeeded" : L"FAILED",
           szPathShortName,
           wszLogFileName,
           wszCheckpointFileName));




    if (bSucceeded && (pInstanceInfo->cDatabases > 0))
    {
    /*
    ** Ok, we think we have an instance that is actually being
    ** used for something. so go ahead and construct a 'component'
    ** for it.
    */
    if ((NULL == pInstanceInfo->szInstanceName) ||
        ('\0' == pInstanceInfo->szInstanceName [0]))
        {
        /*
        ** We seem to have a NULL pointer or a zero length
        ** string. Just set to a zero length unicode string.
        */
        wszInstanceName [0] = UNICODE_NULL;
        }

    else
        {
        bSucceeded = ConvertName (pInstanceInfo->szInstanceName,
                      MAX_PATH,
                      wszInstanceName);
        }



    for (ULONG ulDatabase = 0; bSucceeded && (ulDatabase < pInstanceInfo->cDatabases); ulDatabase++)
        {
        bSucceeded = ConvertNameAndSeparateFilePaths (pInstanceInfo->szDatabaseFileName [ulDatabase],
                              MAX_PATH,
                              wszDatabaseFilePath,
                              pwszDatabaseFileName);


        /*
        ** Convert the database display name to unicode but allow
        ** for a possible NULL pointer or a non-zero length file
        ** spec.
        */
        if (bSucceeded)
        {
        if ((NULL == pInstanceInfo->szDatabaseDisplayName [ulDatabase]) ||
            ('\0' == pInstanceInfo->szDatabaseDisplayName [ulDatabase][0]))
            {
            wszDatabaseDisplayName [0] = UNICODE_NULL;
            }
        else
            {
            bSucceeded = ConvertName (pInstanceInfo->szDatabaseDisplayName [ulDatabase],
                          MAX_PATH,
                          wszDatabaseDisplayName);
            }
        }


        /*
        ** Convert the SLV filename to unicode but allow for a
        ** possible NULL pointer or a non-zero length file spec.
        */
        if (bSucceeded)
        {
        if ((NULL == pInstanceInfo->szDatabaseSLVFileName [ulDatabase]) ||
            ('\0' == pInstanceInfo->szDatabaseSLVFileName [ulDatabase][0]))
            {
            wszDatabaseSLVFilePath [0] = UNICODE_NULL;
            pwszDatabaseSLVFileName    = wszDatabaseSLVFilePath;
            }
        else
            {
            bSucceeded = ConvertNameAndSeparateFilePaths (pInstanceInfo->szDatabaseSLVFileName [ulDatabase],
                                  MAX_PATH,
                                  wszDatabaseSLVFilePath,
                                  pwszDatabaseSLVFileName);
            }
        }




        /*
        ** We've now done all the name conversions to unicode so
        ** add a component and the log and database files where
        ** they're available.
        */
        if (bSucceeded)
        {
        bIncludeComponent = !CheckExcludedFileListForMatch (wszDatabaseFilePath,
                                    pwszDatabaseFileName);
        }


        if (bSucceeded && bIncludeComponent)
        {
        PWCHAR  pwchLastDot          = wcsrchr (pwszDatabaseFileName, L'.');
        ULONG   ulDatabaseNameLength = (ULONG) (pwchLastDot - pwszDatabaseFileName);

        wcsncpy (wszDatabaseName, pwszDatabaseFileName, ulDatabaseNameLength);
        wszDatabaseName [ulDatabaseNameLength] = '\0';

        ConvertPathToLogicalPath(wszDatabaseFilePath, MAX_PATH, wszDatabaseLogicalPath);

        hrStatus = m_pIMetadata->AddComponent (VSS_CT_DATABASE,
                               wszDatabaseLogicalPath,
                               wszDatabaseName,
                               wszDatabaseDisplayName,
                               NULL,
                               0,
                               bRestoreMetadata,
                               bNotifyOnBackupComplete,
                               bSelectable);

        bSucceeded = SUCCEEDED (hrStatus);

        BsDebugTrace (0,
                  DEBUG_TRACE_VSS_WRITER,
                  (L"CVssIJetWriter::ProcessJetInstance - "
                   L"%s adding component '%s\\%s' for jet instance '%s' database '%s' with display name '%s'",
                   bSucceeded ? L"Succeeded" : L"FAILED",
                   wszDatabaseLogicalPath,
                   wszDatabaseName,
                   wszInstanceName,
                   wszDatabaseName,
                   wszDatabaseDisplayName));
        }



        if (bSucceeded && bIncludeComponent)
        {
        hrStatus = m_pIMetadata->AddDatabaseFiles (wszDatabaseLogicalPath,
                               wszDatabaseName,
                               wszDatabaseFilePath,
                               pwszDatabaseFileName);

        bSucceeded = SUCCEEDED (hrStatus);

        BsDebugTrace (0,
                  DEBUG_TRACE_VSS_WRITER,
                  (L"CVssIJetWriter::ProcessJetInstance - "
                   L"%s adding database files for instance '%s', database '%s', database file '%s\\%s'",
                   bSucceeded ? L"Succeeded" : L"FAILED",
                   wszInstanceName,
                   wszDatabaseName,
                   wszDatabaseFilePath,
                   pwszDatabaseFileName));
        }



        /*
        ** May not have an SLV file so only add it if we have a
        ** non-zero length file spec
        */
        if (bSucceeded && bIncludeComponent && (UNICODE_NULL != pwszDatabaseSLVFileName [0]))
        {
        hrStatus = m_pIMetadata->AddDatabaseFiles (wszDatabaseLogicalPath,
                               wszDatabaseName,
                               wszDatabaseSLVFilePath,
                               pwszDatabaseSLVFileName);

        bSucceeded = SUCCEEDED (hrStatus);

        BsDebugTrace (0,
                  DEBUG_TRACE_VSS_WRITER,
                  (L"CVssIJetWriter::ProcessJetInstance - "
                   L"%s adding SLV file for instance '%s', database '%s', SLV file '%s\\%s'",
                   bSucceeded ? L"Succeeded" : L"FAILED",
                   wszInstanceName,
                   wszDatabaseName,
                   wszDatabaseSLVFilePath,
                   pwszDatabaseSLVFileName));
        }


        /*
        ** May not have an instance log file so only add it if we
        ** have a non-zero length file path
        */
        if (bSucceeded && bIncludeComponent && (UNICODE_NULL != wszLogFilePath [0]))
        {
        hrStatus = m_pIMetadata->AddDatabaseLogFiles (wszDatabaseLogicalPath,
                                  wszDatabaseName,
                                  wszLogFilePath,
                                  wszLogFileName);

        bSucceeded = SUCCEEDED (hrStatus);

        BsDebugTrace (0,
                  DEBUG_TRACE_VSS_WRITER,
                  (L"CVssIJetWriter::ProcessJetInstance - "
                   L"%s adding log file for instance '%s', database '%s', log file '%s\\%s'",
                   bSucceeded ? L"Succeeded" : L"FAILED",
                   wszInstanceName,
                   wszDatabaseName,
                   wszLogFilePath,
                   wszLogFileName));
        }


        /*
        ** May not have a checkpoint file so only add it if we
        ** have a non-zero length file path
        */
        if (bSucceeded && bIncludeComponent && (UNICODE_NULL != wszCheckpointFilePath [0]))
        {
        hrStatus = m_pIMetadata->AddDatabaseLogFiles (wszDatabaseLogicalPath,
                                  wszDatabaseName,
                                  wszCheckpointFilePath,
                                  wszCheckpointFileName);

        bSucceeded = SUCCEEDED (hrStatus);

        BsDebugTrace (0,
                  DEBUG_TRACE_VSS_WRITER,
                  (L"CVssIJetWriter::ProcessJetInstance - "
                   L"%s adding checkpoint file for instance '%s', database '%s', checkpoint file '%s\\%s'",
                   bSucceeded ? L"Succeeded" : L"FAILED",
                   wszInstanceName,
                   wszDatabaseName,
                   wszCheckpointFilePath,
                   wszCheckpointFileName));
        }
        }
    }


    return (bSucceeded);
    } /* CVssIJetWriter::ProcessJetInstance () */



bool CVssIJetWriter::PreProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    /*
    ** Parse the m_wszFilesToInclude and m_wszFilesToExclude adding
    ** and enty to the appropriate list as necessary. This will
    ** minimize the number of passes over the un-processed lists.
    */
    ULONG       ulPathLength;
    ULONG       ulNameLength;
    bool        bRecurseIntoSubdirectories;
    bool        bSucceeded         = true;
    bool        bFoundFiles        = true;
    PEXPANDEDPATHINFO   pepnPathInfomation = NULL;
    PWCHAR      pwszCursor         = bProcessingIncludeList
                        ? m_wszFilesToInclude
                        : m_wszFilesToExclude;



    while (bSucceeded && bFoundFiles)
    {
    bSucceeded = DetermineNextPathLengths (pwszCursor,
                           ulPathLength,
                           ulNameLength,
                           bRecurseIntoSubdirectories,
                           bFoundFiles);


    if (bSucceeded && bFoundFiles)
        {
        pepnPathInfomation = new EXPANDEDPATHINFO;

        bSucceeded = (NULL != pepnPathInfomation);
        }
    else
        {
        /*
        ** We either failed and/or found no files. In either case
        ** there is no point in continuing.
        */
        break;
        }



    if (bSucceeded)
        {
        InitializeListHead (&pepnPathInfomation->leQueueHead);


        if (0 == ulNameLength)
        {
        /*
        ** If the filename component is zero length, then it
        ** will be turned into a "*" so add a character to the
        ** buffer to make room.
        */
        ulNameLength++;
        }

        /*
        ** Allow extra space for terminating UNICODE_NULL
        */
        ulPathLength++;
        ulNameLength++;


        pepnPathInfomation->pwszExpandedFilePath = NULL;
        pepnPathInfomation->pwszExpandedFileName = NULL;
        pepnPathInfomation->pwszOriginalFilePath = new WCHAR [ulPathLength];
        pepnPathInfomation->pwszOriginalFileName = new WCHAR [ulNameLength];

        bSucceeded = ((NULL != pepnPathInfomation->pwszOriginalFilePath) &&
              (NULL != pepnPathInfomation->pwszOriginalFileName));
        }


    if (bSucceeded)
        {
        bSucceeded = DetermineNextPath (pwszCursor,
                        pwszCursor,
                        ulPathLength * sizeof (WCHAR),
                        pepnPathInfomation->pwszOriginalFilePath,
                        ulNameLength * sizeof (WCHAR),
                        pepnPathInfomation->pwszOriginalFileName,
                        pepnPathInfomation->bRecurseIntoSubdirectories,
                        bFoundFiles);

        BS_ASSERT (bFoundFiles && L"Second attempt to locate files failed unexpectedly");
        }


    if (bSucceeded)
        {
        ulPathLength = ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFilePath, NULL, 0);
        ulNameLength = ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFileName, NULL, 0);

        bSucceeded = (0 < ulPathLength) && (0 < ulNameLength);
        }


    if (bSucceeded)
        {
        pepnPathInfomation->pwszExpandedFilePath = new WCHAR [ulPathLength];
        pepnPathInfomation->pwszExpandedFileName = new WCHAR [ulNameLength];

        bSucceeded = ((NULL != pepnPathInfomation->pwszExpandedFilePath) &&
              (NULL != pepnPathInfomation->pwszExpandedFileName));
        }


    if (bSucceeded)
        {
        ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFilePath,
                       pepnPathInfomation->pwszExpandedFilePath,
                       ulPathLength);


        ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFileName,
                       pepnPathInfomation->pwszExpandedFileName,
                       ulNameLength);
        }


    if (bSucceeded)
        {
        InsertTailList (bProcessingIncludeList ? &m_leFilesToIncludeEntries : &m_leFilesToExcludeEntries,
                &pepnPathInfomation->leQueueHead);

        pepnPathInfomation = NULL;
        }



    if (NULL != pepnPathInfomation)
        {
        delete [] pepnPathInfomation->pwszOriginalFilePath;
        delete [] pepnPathInfomation->pwszOriginalFileName;
        delete [] pepnPathInfomation->pwszExpandedFilePath;
        delete [] pepnPathInfomation->pwszExpandedFileName;
        delete pepnPathInfomation;

        pepnPathInfomation = NULL;
        }
    }


    return (bSucceeded);
    } /* CVssIJetWriter::PreProcessIncludeExcludeLists () */



bool CVssIJetWriter::ProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    /*
    ** parse the m_wszFilesToInclude and m_wszFilesToExclude
    ** calling the m_pIMetadata->IncludeFiles() and/or
    ** m_pIMetadata->ExcludeFiles() routines as necessary
    */
    HRESULT     hrStatus;
    bool        bSucceeded   = true;
    const PLIST_ENTRY   pleQueueHead = bProcessingIncludeList ? &m_leFilesToIncludeEntries : &m_leFilesToExcludeEntries;
    PLIST_ENTRY     pleElement   = pleQueueHead->Flink;
    PEXPANDEDPATHINFO   pepnPathInfomation;



    while (bSucceeded && (pleQueueHead != pleElement))
    {
    pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));


    if (bProcessingIncludeList)
        {
        hrStatus = m_pIMetadata->AddIncludeFiles (pepnPathInfomation->pwszOriginalFilePath,
                              pepnPathInfomation->pwszOriginalFileName,
                              pepnPathInfomation->bRecurseIntoSubdirectories,
                              NULL);
        }
    else
        {
        hrStatus = m_pIMetadata->AddExcludeFiles (pepnPathInfomation->pwszOriginalFilePath,
                              pepnPathInfomation->pwszOriginalFileName,
                              pepnPathInfomation->bRecurseIntoSubdirectories);
        }


    bSucceeded = SUCCEEDED (hrStatus);

    pleElement = pleElement->Flink;
    }


    return (bSucceeded);
    } /* CVssIJetWriter::ProcessIncludeExcludeLists () */



void CVssIJetWriter::PostProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    PEXPANDEDPATHINFO   pepnPathInfomation;
    PLIST_ENTRY     pleElement;
    const PLIST_ENTRY   pleQueueHead = bProcessingIncludeList
                        ? &m_leFilesToIncludeEntries
                        : &m_leFilesToExcludeEntries;


    while (!IsListEmpty (pleQueueHead))
    {
    pleElement = RemoveHeadList (pleQueueHead);

    BS_ASSERT (NULL != pleElement);


    pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));

    delete [] pepnPathInfomation->pwszOriginalFilePath;
    delete [] pepnPathInfomation->pwszOriginalFileName;
    delete [] pepnPathInfomation->pwszExpandedFilePath;
    delete [] pepnPathInfomation->pwszExpandedFileName;
    delete pepnPathInfomation;
    }
    } /* CVssIJetWriter::PostProcessIncludeExcludeLists () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnIdentify (IN IVssCreateWriterMetadata *pMetadata)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnIdentify");

    JET_ERR      jetStatus;
    HRESULT      hrStatus;
    bool         bSucceeded = true;
    ULONG        ulInstanceInfoCount = 0;
    JET_INSTANCE_INFO   *pInstanceInfo;


    m_pIMetadata = pMetadata;

    /**
    ** Set up a restore method
    */
    hrStatus = m_pIMetadata->SetRestoreMethod (
                        VSS_RME_RESTORE_AT_REBOOT,      // restore at reboot
                        NULL,
                        NULL,
                        VSS_WRE_NEVER,                  // writer not invoked during restore
                        true);                          // reboot is required
    bSucceeded = SUCCEEDED (hrStatus);
 
    /*
    ** Set up list of include and exclude files. ready for use in
    ** filtering Jet databases and adding include/exclude files lists.
    */
    bSucceeded = EXECUTEIF (bSucceeded, (PreProcessIncludeExcludeLists (true )));
    bSucceeded = EXECUTEIF (bSucceeded, (PreProcessIncludeExcludeLists (false)));

    bSucceeded = EXECUTEIF (bSucceeded, (JET_errSuccess <= JetGetInstanceInfo (&ulInstanceInfoCount,
                                           &pInstanceInfo)));

    for (ULONG ulInstanceIndex = 0; ulInstanceIndex < ulInstanceInfoCount; ulInstanceIndex++)
    {
    bSucceeded = EXECUTEIF (bSucceeded, (ProcessJetInstance (pInstanceInfo + ulInstanceIndex)));
    }


    bSucceeded = EXECUTEIF (bSucceeded, (ProcessIncludeExcludeLists (true )));
    bSucceeded = EXECUTEIF (bSucceeded, (ProcessIncludeExcludeLists (false)));
    bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnIdentify (pMetadata)));



    PostProcessIncludeExcludeLists (true );
    PostProcessIncludeExcludeLists (false);


    m_pIMetadata = NULL;

    return (bSucceeded);
    } /* CVssIJetWriter::OnIdentify () */


bool STDMETHODCALLTYPE CVssIJetWriter::OnPrepareBackup (IN IVssWriterComponents *pIVssWriterComponents)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPrepareBackup");

    bool    bSucceeded;


    bSucceeded = m_pwrapper->OnPrepareBackupBegin (pIVssWriterComponents);

    bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnPrepareBackupEnd (pIVssWriterComponents, bSucceeded)));

    if (!bSucceeded)
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);

    return (bSucceeded);
    } /* CVssIJetWriter::OnPrepareBackup () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnBackupComplete (IN IVssWriterComponents *pIVssWriterComponents)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnBackupComplete");

    bool    bSucceeded;


    bSucceeded = m_pwrapper->OnBackupCompleteBegin (pIVssWriterComponents);

    bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnBackupCompleteEnd (pIVssWriterComponents, bSucceeded)));

    if (!bSucceeded)
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);

    return (bSucceeded);
    } /* CVssIJetWriter::OnBackupComplete () */




// log jet error and translate jet error into an appropriate writer error
JET_ERR CVssIJetWriter::TranslateJetError(JET_ERR err, CVssFunctionTracer &ft, CVssDebugInfo &dbgInfo)
    {
    ft.LogGenericWarning(dbgInfo, L"ESENT ERROR " WSTR_GUID_FMT L" %s: %ld",
                GUID_PRINTF_ARG(m_idWriter), m_wszWriterName, (LONG)err);
    if (err >= JET_errSuccess)
        return err;

    switch (err)
        {
        case JET_errOSSnapshotInvalidSequence:
        default:
            SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            break;

        case JET_errOutOfThreads:
        case JET_errTooManyIO:
        case errPMOutOfPageSpace:
        case errSPOutOfAvailExtCacheSpace:
        case errSPOutOfOwnExtCacheSpace:
        case JET_errSPAvailExtCacheOutOfMemory:
        case JET_errOutOfMemory:
        case JET_errOutOfDatabaseSpace:
        case JET_errOutOfCursors:
        case JET_errOutOfBuffers:
        case JET_errOutOfFileHandles:
        case JET_errVersionStoreOutOfMemory:
        case JET_errCurrencyStackOutOfMemory:
        case JET_errTooManyMempoolEntries:
        case JET_errOutOfSessions:
            SetWriterFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            break;

        case JET_errOSSnapshotTimeOut:
            SetWriterFailure(VSS_E_WRITERERROR_TIMEOUT);
            break;

        case JET_errOSSnapshotNotAllowed:
            SetWriterFailure(VSS_E_WRITERERROR_RETRYABLE);
            break;
        }

    return err;
    }

bool STDMETHODCALLTYPE CVssIJetWriter::OnPrepareSnapshot()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPrepareSnapshot");

    if (!m_pwrapper->OnPrepareSnapshotBegin())
        {
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        return false;
        }

    // go to Jet level directly
    JET_ERR err = JetOSSnapshotPrepare( &m_idJet , 0 );
    bool fSuccess = JET_errSuccess <= err;
    if (!fSuccess)
        TranslateJetError(err, ft, VSSDBG_GEN);

    if (!m_pwrapper->OnPrepareSnapshotEnd(fSuccess))
        {
        if (fSuccess)
            SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);

        return false;
        }

    return fSuccess;
    } /* CVssIJetWriter::OnPrepareSnapshot () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnFreeze()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnFreeze");

    unsigned long           cInstanceInfo   = 0;
    JET_INSTANCE_INFO *     aInstanceInfo   = NULL;
    bool                    fDependence     = true;

    if (!m_pwrapper->OnFreezeBegin())
        {
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        return false;
        }


    // we need to freeze at Jet level, then check from this DLL the dependencies
    // (as here we hagve the snapshot object implementation and COM registration)

    bool fSuccess = true;

    JET_ERR err = JetOSSnapshotFreeze( m_idJet , &cInstanceInfo, &aInstanceInfo, 0 );
    if ( JET_errSuccess > err)
        {
        fSuccess = false;
        TranslateJetError(err, ft, VSSDBG_GEN);
        }
    else
        {
        // return false if some instances are only partialy affected
        fDependence = FCheckVolumeDependencies(cInstanceInfo, aInstanceInfo);
        (void)JetFreeBuffer( (char *)aInstanceInfo );

        if ( !fDependence )
            {
            SetWriterFailure(VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT);
            // on error, stop the snapshot, return false
            JetOSSnapshotThaw( m_idJet , 0 );
            }
        }

    if (!m_pwrapper->OnFreezeEnd(fSuccess && fDependence))
        {
        if (fDependence && fSuccess)
            SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);

        return false;
        }

    return fSuccess && fDependence;
    } /* CVssIJetWriter::OnFreeze () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnThaw()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnThaw");

    bool fSuccess1 = m_pwrapper->OnThawBegin();
    // go to Jet level directly. It will eventualy return timeout errors
    JET_ERR err = JetOSSnapshotThaw( m_idJet , 0 );
    bool fSuccess2 = JET_errSuccess <= err;
    if (!fSuccess2)
        TranslateJetError(err, ft, VSSDBG_GEN);

    if (fSuccess1)
        {
        if (!m_pwrapper->OnThawEnd(fSuccess2))
            {
            if (fSuccess2)
                SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            return false;
            }
        }

    return fSuccess1 && fSuccess2;
    } /* CVssIJetWriter::OnThaw () */

bool STDMETHODCALLTYPE CVssIJetWriter::OnPostSnapshot
    (
    IN IVssWriterComponents *pIVssWriterComponents
    )
    {
    if (!m_pwrapper->OnPostSnapshot(pIVssWriterComponents))
        {
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        return false;
        }

    return true;
    }



bool STDMETHODCALLTYPE CVssIJetWriter::OnAbort()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnAbort");

    m_pwrapper->OnAbortBegin();
    JET_ERR err = JetOSSnapshotAbort( m_idJet , 0 );
    if (err < JET_errSuccess)
        TranslateJetError(err, ft, VSSDBG_GEN);

    m_pwrapper->OnAbortEnd();
    return true;
    } /* CVssIJetWriter::OnAbort () */

bool STDMETHODCALLTYPE CVssIJetWriter::OnPreRestore
    (
    IN IVssWriterComponents *pIVssWriterComponents
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPostRestore");

    if (!m_pwrapper->OnPreRestoreBegin(pIVssWriterComponents))
        {
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        return false;
        }

    if (!m_pwrapper->OnPreRestoreEnd(pIVssWriterComponents, true))
        {
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        return false;
        }

    return true;
    } /* CVssIJetWriter::OnPreRestore () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnPostRestore
    (
    IN IVssWriterComponents *pIVssWriterComponents
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPostRestore");

    if (!m_pwrapper->OnPostRestoreBegin(pIVssWriterComponents))
        {
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        return false;
        }

    if (!m_pwrapper->OnPostRestoreEnd(pIVssWriterComponents, true))
        {
        SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        return false;
        }

    return true;
    } /* CVssIJetWriter::OnPostRestore () */



bool CVssIJetWriter::FCheckPathVolumeDependencies(const char * szPath) const
    {
    // use static variable in order to avoid alloc/free
    WCHAR wszPath[MAX_PATH];

    if (MultiByteToWideChar(CP_OEMCP, 0, szPath, -1, wszPath, MAX_PATH ) == 0 )
        {
        BS_ASSERT( ERROR_INSUFFICIENT_BUFFER != GetLastError() );
        return false;
        }

    // use standart Writer call to check the affected path
    return IsPathAffected(wszPath);
    } /* CVssIJetWriter::FCheckPathVolumeDependencies () */



// all or nothing check: all path in instance are affected or none !
//
bool CVssIJetWriter::FCheckInstanceVolumeDependencies (const JET_INSTANCE_INFO * pInstanceInfo) const
    {
    BS_ASSERT(pInstanceInfo);

    JET_ERR     err             = JET_errSuccess;
    bool        fAffected;
    bool        fAffected1;
    char        szPath[ MAX_PATH ];


    // check first system and log path
    err = JetGetSystemParameter( pInstanceInfo->hInstanceId, JET_sesidNil, JET_paramLogFilePath, NULL, szPath, sizeof( szPath ) );
    if ( JET_errSuccess > err )
        return false;

    fAffected = FCheckPathVolumeDependencies( szPath );

    err = JetGetSystemParameter
        (
        pInstanceInfo->hInstanceId,
        JET_sesidNil,
        JET_paramSystemPath,
        NULL,
        szPath,
        sizeof(szPath)
        );

    if (JET_errSuccess > err)
        return false;


    fAffected1 = FCheckPathVolumeDependencies(szPath);
    if ((fAffected && !fAffected1) || (!fAffected && fAffected1))
        return false;

    for (ULONG_PTR iDatabase = 0;
        iDatabase < pInstanceInfo->cDatabases;
        iDatabase++)
        {
        char * szFile = pInstanceInfo->szDatabaseFileName[iDatabase];

        BS_ASSERT(szFile); // we always have a db file name
        fAffected1 = FCheckPathVolumeDependencies(szFile);
        if ((fAffected && !fAffected1) || (!fAffected && fAffected1))
            return false;

        szFile = pInstanceInfo->szDatabaseSLVFileName[iDatabase];

        // if no SLV file, go to next database
        if (!szFile)
            continue;

        fAffected1 = FCheckPathVolumeDependencies(szFile);
        if ((fAffected && !fAffected1) || (!fAffected && fAffected1))
            return false;
        }

    // all set !
    return true;
    } /* CVssIJetWriter::FCheckInstanceVolumeDependencies () */


bool CVssIJetWriter::FCheckVolumeDependencies
    (
    unsigned long cInstanceInfo,
    JET_INSTANCE_INFO * aInstanceInfo
    ) const
    {
    bool fResult = true;

    // check each instance
    while (cInstanceInfo && fResult)
        {
        cInstanceInfo--;
        fResult = FCheckInstanceVolumeDependencies (aInstanceInfo + cInstanceInfo);
        }

    return fResult;
    } /* CVssIJetWriter::FCheckVolumeDependencies () */



// internal method to assign basic members
HRESULT CVssIJetWriter::InternalInitialize (IN VSS_ID  idWriter,
                        IN LPCWSTR wszWriterName,
                        IN bool    bSystemService,
                        IN bool    bBootableSystemState,
                        IN LPCWSTR wszFilesToInclude,
                        IN LPCWSTR wszFilesToExclude)
    {
    HRESULT hrStatus = NOERROR;


    hrStatus = CVssWriter::Initialize (idWriter,
                wszWriterName,
                bBootableSystemState
                    ? VSS_UT_BOOTABLESYSTEMSTATE
                    : (bSystemService
                        ? VSS_UT_SYSTEMSERVICE
                        : VSS_UT_USERDATA),
                VSS_ST_TRANSACTEDDB,
                VSS_APP_BACK_END);

    // hrStatus may be S_FALSE
    if (hrStatus != S_OK)
    	return hrStatus;
    
    m_idWriter             = idWriter;
    m_bSystemService       = bSystemService;
    m_bBootableSystemState = bBootableSystemState;
    m_wszWriterName        = _wcsdup(wszWriterName);
    m_wszFilesToInclude    = _wcsdup(wszFilesToInclude);
    m_wszFilesToExclude    = _wcsdup(wszFilesToExclude);

    if ((NULL == m_wszWriterName)     ||
    (NULL == m_wszFilesToInclude) ||
    (NULL == m_wszFilesToExclude))
    {
    delete m_wszWriterName;
    delete m_wszFilesToInclude;
    delete m_wszFilesToExclude;

    m_wszWriterName     = NULL;
    m_wszFilesToInclude = NULL;
    m_wszFilesToExclude = NULL;

    hrStatus = E_OUTOFMEMORY;
    }


    return (hrStatus);
    } /* CVssIJetWriter::InternalInitialize () */



// do initialization
HRESULT STDMETHODCALLTYPE CVssIJetWriter::Initialize (IN VSS_ID idWriter,           // id of writer
                              IN LPCWSTR wszWriterName,     // writer name
                              IN bool bSystemService,       // is this a system service
                              IN bool bBootableSystemState, // is this writer part of bootable system state
                              IN LPCWSTR wszFilesToInclude, // additional files to include
                              IN LPCWSTR wszFilesToExclude, // additional files to exclude
                              IN CVssJetWriter *pWriter,        // writer wrapper class
                              OUT void **ppInstance)        // output instance
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::Initialize");

    try
    {
    // check parameters
    if (ppInstance == NULL)
        {
        ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"NULL output parameter.");
        }

    // change null pointer to null strings for files to include
    // and files to exclude
    if (wszFilesToInclude == NULL)
        wszFilesToInclude = L"";

    if (wszFilesToExclude == NULL)
        wszFilesToExclude = L"";


    if (!ValidateIncludeExcludeList (wszFilesToInclude))
        {
        ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"Bad FilesToInclude list.");
        }

    if (!ValidateIncludeExcludeList (wszFilesToExclude))
        {
        ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"Bad FilesToExclude list.");
        }



    // null output parameter
    *ppInstance = NULL;

    // create instance
    PVSSIJETWRITER pInstance = new CVssIJetWriter;

    // create instance
    ft.ThrowIf (NULL == pInstance,
            VSSDBG_GEN,
            E_OUTOFMEMORY,
            L"FAILED creating CVssIJetWriter object due to allocation failure.");



    // call internal initialization
    ft.hr = pInstance->InternalInitialize (idWriter,
                           wszWriterName,
                           bSystemService,
                           bBootableSystemState,
                           wszFilesToInclude,
                           wszFilesToExclude);

    ft.ThrowIf (ft.HrFailed(),
            VSSDBG_GEN,
            ft.hr,
            L"FAILED during internal initialisation of CVssIJetWriter object");



    // Subscribe the object.
    ft.hr = pInstance->Subscribe();

    ft.ThrowIf (ft.HrFailed(),
            VSSDBG_GEN,
            ft.hr,
            L"FAILED during internal initialisation of CVssIJetWriter object");



    ((CVssIJetWriter *) pInstance)->m_pwrapper = pWriter;
    *ppInstance = (void *) pInstance;
    } VSS_STANDARD_CATCH(ft)


    return (ft.hr);
    } /* CVssIJetWriter::Initialize () */



void STDMETHODCALLTYPE CVssIJetWriter::Uninitialize(IN PVSSIJETWRITER pInstance)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::Uninitialize");

    try
        {
        CVssIJetWriter *pWriter = (CVssIJetWriter *) pInstance;
        // Unsubscribe the object.

        BS_ASSERT(pWriter);

        pWriter->Unsubscribe();
        delete pWriter;
        }
    VSS_STANDARD_CATCH(ft)
    } /* CVssIJetWriter::Uninitialize () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\filter\filter.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Abstract:

    @doc
    @module filter.cxx | publisher filter for IVssWriter event
    @end

Author:

    Brian Berkowitz  [brianb]  11/09/2000

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      10/09/2000  Created.

--*/

#include <stdafx.hxx>

#include <sddl.h>

#include "vs_inc.hxx"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_idl.hxx"
#include "vssmsg.h"



// filter class
class CVssWriterPublisherFilter : public IMultiInterfacePublisherFilter
    {
public:
    // constructor
    CVssWriterPublisherFilter(IMultiInterfaceEventControl *pControl);

    // destructor
    ~CVssWriterPublisherFilter();

    STDMETHOD(Initialize)(IMultiInterfaceEventControl *pEc);
    STDMETHOD(PrepareToFire)(REFIID iid, BSTR bstrMethod, IFiringControl *pFiringControl);

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvUnknown);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    static void CreatePublisherFilter
        (
        IN IMultiInterfaceEventControl *pControl,
        IN const VSS_ID *rgWriterClassId,
        IN UINT cWriterClassId,
        IN const VSS_ID *rgInstanceIdInclude,
        IN UINT  cInstanceIdInclude,
        IN bool bMetadataFire,
        IN bool bIncludeWriterClasses,
        OUT IMultiInterfacePublisherFilter **ppFilter
        );

private:
    // setup well known sids
    void SetupGenericSids();

    // setup id arrays
    void SetupIdArrays
        (
        IN const VSS_ID *rgWriterClassId,
        IN UINT cWriterClassId,
        IN const VSS_ID *rgInstanceIdInclude,
        IN UINT cInstanceIdInclude,
        IN bool bMetadataFire,
        IN bool bIncludeWriterClasses
        );

    // test whether a subscription should be included
    bool TestSubscriptionMembership(IEventSubscription *pSubscription);

    // cached pointer to event control
    CComPtr<IMultiInterfaceEventControl> m_pControl;

    // reference count
    LONG m_cRef;

    // array of writer class ids
    VSS_ID *m_rgWriterClassId;

    // size of array
    UINT m_cWriterClassId;

    // array of instance ids to include
    VSS_ID *m_rgInstanceIdInclude;

    // count of instance ids to include
    UINT m_cInstanceIdInclude;

    // fire all writers
    bool m_bMetadataFire;

    // exclude or include writer classes
    bool m_bIncludeWriterClasses;

    // The list of SIDs read from registry
    CVssSidCollection   m_SidCollection;

    // have well known sids beeen compouted
    bool m_bSidCollectionInitialized;
    };


// constructor
CVssWriterPublisherFilter::CVssWriterPublisherFilter(IMultiInterfaceEventControl *pControl) :
    m_cRef(0),
    m_pControl(pControl),
    m_bSidCollectionInitialized(false),
    m_rgWriterClassId(NULL),
    m_rgInstanceIdInclude(NULL),
    m_cWriterClassId(0),
    m_cInstanceIdInclude(0),
    m_bMetadataFire(false),
    m_bIncludeWriterClasses(false)
    {
    }

CVssWriterPublisherFilter::~CVssWriterPublisherFilter()
    {
    // delete array of class ids
    delete m_rgWriterClassId;

    // delete array of instance ids
    delete m_rgInstanceIdInclude;
    }

// create a publisher filter and return an interface pointer to it
void CVssWriterPublisherFilter::CreatePublisherFilter
    (
    IN IMultiInterfaceEventControl *pControl,
    IN const VSS_ID *rgWriterClassId,
    IN UINT cWriterClassId,
    IN const VSS_ID *rgInstanceIdInclude,
    IN UINT cInstanceIdInclude,
    IN bool bMetadataFire,
    IN bool bIncludeWriterClasses,
    OUT IMultiInterfacePublisherFilter **ppFilter
    )
    {
    CVssWriterPublisherFilter *pFilter = new CVssWriterPublisherFilter(pControl);
    if (pFilter == NULL)
        throw E_OUTOFMEMORY;

    // setup filtering arrays based on writer class and instance ids
    pFilter->SetupIdArrays
        (
        rgWriterClassId,
        cWriterClassId,
        rgInstanceIdInclude,
        cInstanceIdInclude,
        bMetadataFire,
        bIncludeWriterClasses
        );

    // get publisher filter interface
    pFilter->QueryInterface(IID_IMultiInterfacePublisherFilter, (void **) ppFilter);
    }

// query interface method
STDMETHODIMP CVssWriterPublisherFilter::QueryInterface(REFIID riid, void **ppvUnk)
    {
    if (riid == IID_IUnknown)
        *ppvUnk = (IUnknown *) this;
    else if (riid == IID_IMultiInterfacePublisherFilter)
        *ppvUnk = (IMultiInterfacePublisherFilter *) (IUnknown *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) (*ppvUnk))->AddRef();
    return S_OK;
    }

// add ref method
STDMETHODIMP_(ULONG) CVssWriterPublisherFilter::AddRef()
    {
    LONG cRef = InterlockedIncrement(&m_cRef);

    return (ULONG) cRef;
    }

// release method
STDMETHODIMP_(ULONG) CVssWriterPublisherFilter::Release()
    {
    LONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
        {
        delete this;

        return 0;
        }
    else
        return (ULONG) cRef;
    }



// initialize method (does nothing.  All the work is done in PrepareToFire)
STDMETHODIMP CVssWriterPublisherFilter::Initialize
    (
    IMultiInterfaceEventControl *pec
    )
    {
    UNREFERENCED_PARAMETER(pec);

    return S_OK;
    }

void CVssWriterPublisherFilter::SetupIdArrays
    (
    IN const VSS_ID *rgWriterClassId,
    UINT cWriterClassId,
    IN const VSS_ID *rgInstanceIdInclude,
    UINT cInstanceIdInclude,
    bool bMetadataFire,
    bool bIncludeWriterClasses
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::SetupIdArrays");

    m_bMetadataFire = bMetadataFire;
    m_bIncludeWriterClasses = bIncludeWriterClasses;

    if (cWriterClassId)
        {
        // copy writer class id array
        m_rgWriterClassId = new VSS_ID[cWriterClassId];

        // check for allocation failure
        if (m_rgWriterClassId == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate writer class id array");

        memcpy(m_rgWriterClassId, rgWriterClassId, cWriterClassId * sizeof(VSS_ID));
        m_cWriterClassId = cWriterClassId;
        }

    if (cInstanceIdInclude)
        {
        // copy writer instance id array
        m_rgInstanceIdInclude = new VSS_ID[cInstanceIdInclude];

        // check for allocation failure
        if (m_rgInstanceIdInclude == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate instance id include array");

        memcpy(m_rgInstanceIdInclude, rgInstanceIdInclude, cInstanceIdInclude*sizeof(VSS_ID));
        m_cInstanceIdInclude = cInstanceIdInclude;
        }
    }



// setup well known sids so that they only are computed once
void CVssWriterPublisherFilter::SetupGenericSids()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssPublisherFilter::SetupGenericSids");

    if (m_bSidCollectionInitialized)
        return;

    // Read sids from registry
    m_SidCollection.Initialize();

    // indicate that sids were successfully created
    m_bSidCollectionInitialized = true;
    }


// key method that determines which subscriptions shoud receive the event
STDMETHODIMP CVssWriterPublisherFilter::PrepareToFire
    (
    REFIID iid,
    BSTR bstrMethod,
    IFiringControl *pFiringControl
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::PrepareToFire");

    BS_ASSERT(iid == IID_IVssWriter);
    // validate iid we are being called on
    if (iid != IID_IVssWriter)
        return E_INVALIDARG;

    try
        {
        // setup sids if not done so already
        SetupGenericSids();

        CComPtr<IEventObjectCollection> pCollection;
        int location;

        // get subscriptions
        ft.hr = m_pControl->GetSubscriptions
                    (
                    IID_IVssWriter,
                    bstrMethod,
                    NULL,
                    &location,
                    &pCollection
                    );

        ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::GetSubscriptions");

        // create enumerator
        CComPtr<IEnumEventObject> pEnum;
        ft.hr = pCollection->get_NewEnum(&pEnum);
        ft.CheckForError(VSSDBG_GEN, L"IEventObjectCollection::get_NewEnum");

        while(TRUE)
            {
            CComPtr<IEventSubscription> pSubscription;
            DWORD cElt;

            // get next subscription
            ft.hr = pEnum->Next(1, (IUnknown **) &pSubscription, &cElt);
            ft.CheckForError(VSSDBG_GEN, L"IEnumEventObject::Next");
            if (ft.hr == S_FALSE)
                break;

            // get owner of subscription
            CComBSTR bstrSID;
            ft.hr = pSubscription->get_OwnerSID(&bstrSID);
            ft.CheckForError(VSSDBG_GEN, L"IEventSubscription::get_OwnerSID");

            // convert string representation to sid
            CAutoSid asid;
            asid.CreateFromString(bstrSID);
            SID *psid = asid.Get();

            // determine if subscription should be fired
            bool bFire = m_SidCollection.IsSidAllowedToFire(psid);
            if (!bFire)
                ft.Trace(VSSDBG_GEN, L"Subscriber with SID (%s) is not allowed to fire", (LPWSTR)bstrSID);

            // finally make sure that we should fire the subscription
            // based on our writer class and instance lists
            if (bFire)
                {
                    if (TestSubscriptionMembership(pSubscription))
                        {
                        ft.Trace(VSSDBG_GEN, L"Firing subscriber SID (%s) for method (%s)", 
                            (LPWSTR)bstrSID, (LPWSTR)bstrMethod);
                        ft.hr = pFiringControl->FireSubscription(pSubscription);
                        ft.CheckForError(VSSDBG_GEN, L"FireSubscription");
                        }
                    else
                        ft.Trace(VSSDBG_GEN, L"Subscriber with SID (%s) for method (%s) was not fired.", 
                            (LPWSTR)bstrSID, (LPWSTR)bstrMethod);
                }
            }

        ft.hr = S_OK;
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// test whether a subscription should be fired based on its writer id and
// subscription id.  If the appropriate properties do not exist or are not
// well formed, then we don't fire the subscription.

bool CVssWriterPublisherFilter::TestSubscriptionMembership
    (
    IEventSubscription *pSubscription
    )
    {
    if (m_cWriterClassId)
        {
        VARIANT varWriterId;
        HRESULT hr;

        // initialize variant
        VariantInit(&varWriterId);

        // get writer class id property
        hr = pSubscription->GetSubscriberProperty(L"WriterId", &varWriterId);

        // validate that the property id was found and that its type is correct
        if (hr != S_OK || varWriterId.vt != VT_BSTR)
            {
            VariantClear(&varWriterId);
            return false;
            }

        VSS_ID WriterId;

        // try converting the string to a GUID.
        hr = CLSIDFromString(varWriterId.bstrVal, (LPCLSID) &WriterId);
        if (FAILED(hr))
            {
            VariantClear(&varWriterId);
            return false;
            }

        // test to see if writer class is in array
        for (UINT iWriterId = 0; iWriterId < m_cWriterClassId; iWriterId++)
            {
            if (m_rgWriterClassId[iWriterId] == WriterId)
                {
                // if the writer class id is in the list then we fire the
                // subscription if we enabled specific writer classes and
                // we are firing to gather metadata.  We don't fire the
                // subscription if we disable specific writerc classes

                VariantClear(&varWriterId);

                if (!m_bIncludeWriterClasses)
                    return false;
                else
                    return m_bMetadataFire;
                }
            }

        VariantClear(&varWriterId);
        }

    // if we are firing to gather metadata then we fire the subscription if
    // we were not enabling specific writer classes.  If we were, then the
    // class must be in the writer class array to be fired
    if (m_bMetadataFire)
        return !m_bIncludeWriterClasses;


    // the subscription is now only fired if the specific instance id is
    // in the instance id array.
    if (m_cInstanceIdInclude)
        {
        VARIANT varInstanceId;
        HRESULT hr;

        VariantInit(&varInstanceId);

        // get writer instance id property
        hr = pSubscription->GetSubscriberProperty(L"WriterInstanceId", &varInstanceId);

        // validate that the property was found and that its type is correct
        if (hr != S_OK || varInstanceId.vt != VT_BSTR)
            {
            VariantClear(&varInstanceId);
            return false;
            }

        VSS_ID InstanceId;

        // try converting the string to a GUID.
        hr = CLSIDFromString(varInstanceId.bstrVal, (LPCLSID) &InstanceId);
        if (FAILED(hr))
            {
            VariantClear(&varInstanceId);
            return false;
            }

        // test to see if writer is included
        for (UINT iInstanceId = 0; iInstanceId < m_cInstanceIdInclude; iInstanceId++)
            {
            if (m_rgInstanceIdInclude[iInstanceId] == InstanceId)
                {
                VariantClear(&varInstanceId);
                return true;
                }
            }

        VariantClear(&varInstanceId);
        }

    // don't fire the subscription.  It wasn't in the list of writer instances
    // to fire.
    return false;
    }


// setup a filter on an event object
void SetupPublisherFilter
    (
    IN IVssWriter *pWriter,                 // subscriber
    IN const VSS_ID *rgWriterClassId,       // array of writer class ids
    IN UINT cWriterClassId,                 // size of writer class id array
    IN const VSS_ID *rgInstanceIdInclude,   // array of writer instance ids to include
    IN UINT cInstanceIdInclude,             // size of array of writer instances
    IN bool bMetadataFire,                  // whether we are gathering metadata
    IN bool bIncludeWriterClasses           // whether class id array should be used to
                                            // enable or disable specific writer classes
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"SetupPublisherFilter");

    CComPtr<IMultiInterfaceEventControl> pControl;

    // get event control interface
    ft.hr = pWriter->QueryInterface(IID_IMultiInterfaceEventControl, (void **) &pControl);
    if (ft.HrFailed())
        {
        ft.LogError(VSS_ERROR_QI_IMULTIINTERFACEEVENTCONTROL_FAILED, VSSDBG_GEN << ft.hr);
        ft.Throw
            (
            VSSDBG_GEN,
            E_UNEXPECTED,
            L"Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx",
            ft.hr
            );
        }

    // create filter
    CComPtr<IMultiInterfacePublisherFilter> pFilter;
    CVssWriterPublisherFilter::CreatePublisherFilter
        (
        pControl,
        rgWriterClassId,
        cWriterClassId,
        rgInstanceIdInclude,
        cInstanceIdInclude,
        bMetadataFire,
        bIncludeWriterClasses,
        &pFilter
        );

    // set filter for event
    ft.hr = pControl->SetMultiInterfacePublisherFilter(pFilter);
    ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter");

    // indicate that subscriptions should be fired in parallel
    ft.hr = pControl->put_FireInParallel(TRUE);
    ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::put_FireInParallel");
    }

// clear the publisher filter from an event
void ClearPublisherFilter(IVssWriter *pWriter)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"ClearPublisherFilter");

    try
        {
        CComPtr<IMultiInterfaceEventControl> pControl;

        // get event control interface
        ft.hr = pWriter->QueryInterface(IID_IMultiInterfaceEventControl, (void **) &pControl);
        if (ft.HrFailed())
            {
            ft.LogError(VSS_ERROR_QI_IMULTIINTERFACEEVENTCONTROL_FAILED, VSSDBG_GEN << ft.hr);
            ft.Throw
                (
                VSSDBG_GEN,
                E_UNEXPECTED,
                L"Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx",
                ft.hr
                );
                }

        // set filter for event
        ft.hr = pControl->SetMultiInterfacePublisherFilter(NULL);
        ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter");
        }
    VSS_STANDARD_CATCH(ft)

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\prop\pointer.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Pointer.cxx | Implementation of VSS_OBJECT_PROP_Ptr class
    @end

Author:

    Adi Oltean  [aoltean]  09/21/1999

Revision History:

    Name        Date        Comments

    aoltean     09/21/1999	VSS_OBJECT_PROP_Ptr as a pointer to the properties structure.
							This pointer will serve as element in CSimpleArray constructs.
	aoltean		09/22/1999	Adding InitializeAsEmpty and Print
	aoltean		09/24/1999	Moving into modules/prop
	aoltean		03/27/2000	Adding Writers
	aoltean		03/01/2001	Adding mgmt objects

--*/


/////////////////////////////////////////////////////////////////////////////
//  Needed includes


#include "stdafx.hxx"

#include "vs_idl.hxx"
#include "vs_inc.hxx"

#include "copy.hxx"	
#include "pointer.hxx"	

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "PRPPNTRC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  VSS_OBJECT_PROP_Ptr class


void VSS_OBJECT_PROP_Ptr::InitializeAsSnapshot(
    IN  CVssFunctionTracer& ft,
	IN  VSS_ID SnapshotId,
	IN  VSS_ID SnapshotSetId,
	IN  LONG lSnapshotsCount,
	IN  VSS_PWSZ pwszSnapshotDeviceObject,
	IN  VSS_PWSZ pwszOriginalVolumeName,
	IN  VSS_PWSZ pwszOriginatingMachine,
	IN  VSS_PWSZ pwszServiceMachine,
	IN  VSS_PWSZ pwszExposedName,
	IN  VSS_PWSZ pwszExposedPath,
	IN  VSS_ID ProviderId,
	IN  LONG lSnapshotAttributes,
	IN  VSS_TIMESTAMP tsCreationTimestamp,
	IN  VSS_SNAPSHOT_STATE eStatus
    ) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to keep a VSS_OBJECT_SNAPSHOT structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeAsSnapshot";
	VSS_OBJECT_PROP* pProp = NULL;

    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_OBJECT_SNAPSHOT;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_SNAPSHOT_PROP& SnapshotProp = pProp->Obj.Snap;

		// Setting the internal members
		SnapshotProp.m_SnapshotId			= SnapshotId;
		SnapshotProp.m_SnapshotSetId		= SnapshotSetId;
		SnapshotProp.m_lSnapshotsCount      = lSnapshotsCount;
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszSnapshotDeviceObject, pwszSnapshotDeviceObject);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszOriginalVolumeName, pwszOriginalVolumeName);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszOriginatingMachine, pwszOriginatingMachine);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszServiceMachine, pwszServiceMachine);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszExposedName, pwszExposedName);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszExposedPath, pwszExposedPath);
		SnapshotProp.m_ProviderId			= ProviderId;
		SnapshotProp.m_lSnapshotAttributes	= lSnapshotAttributes;
		SnapshotProp.m_tsCreationTimestamp = tsCreationTimestamp;
		SnapshotProp.m_eStatus				= eStatus;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::InitializeAsProvider(
    IN  CVssFunctionTracer& ft,
    IN	VSS_ID ProviderId,
    IN	VSS_PWSZ pwszProviderName,
    IN  VSS_PROVIDER_TYPE eProviderType,
    IN	VSS_PWSZ pwszProviderVersion,
    IN	VSS_ID ProviderVersionId,
	IN	CLSID ClassId
    ) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to keep a VSS_OBJECT_PROVIDER structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeAsProvider";
	VSS_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert parameters
		BS_ASSERT(pwszProviderName == NULL || pwszProviderName[0] != L'\0');
		BS_ASSERT(eProviderType == VSS_PROV_SYSTEM ||
            eProviderType == VSS_PROV_SOFTWARE ||
            eProviderType == VSS_PROV_HARDWARE
            );

		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_OBJECT_PROVIDER;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_PROVIDER_PROP& ProviderProp = pProp->Obj.Prov;

		// Setting the internal members
		ProviderProp.m_ProviderId		 = ProviderId;
        ::VssSafeDuplicateStr(ft, ProviderProp.m_pwszProviderName, pwszProviderName);
		ProviderProp.m_eProviderType	 = eProviderType;
        ::VssSafeDuplicateStr(ft, ProviderProp.m_pwszProviderVersion, pwszProviderVersion);
		ProviderProp.m_ProviderVersionId = ProviderVersionId;
		ProviderProp.m_ClassId			 = ClassId;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::InitializeAsEmpty(
    IN  CVssFunctionTracer& ft
	)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to appear as an empty structure (to be filled later).

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeEmpty";
	VSS_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		BS_ASSERT(pProp == NULL);
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::Print(
    IN  CVssFunctionTracer& ft,
	IN  LPWSTR wszOutputBuffer,
	IN  LONG lBufferSize
	)
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::Print";

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		if (m_pStruct == NULL)
			::StringCchPrintfW(wszOutputBuffer, lBufferSize, L"NULL object\n\n");

        // Effective copy
        switch(m_pStruct->Type)
        {
        case VSS_OBJECT_SNAPSHOT:

			::StringCchPrintfW(wszOutputBuffer, lBufferSize,
				L"Id = " WSTR_GUID_FMT L", "
				L"SnapshotSetId = " WSTR_GUID_FMT L"\n"
				L"SnapCount = %ld "
				L"DevObj = %s\n"
				L"OriginalVolumeName = %s\n"
				L"OriginatingMachine = %s\n"
				L"ServiceMachine = %s\n"
				L"Exposed name = %s\n"
				L"Exposed path = %s\n"
				L"ProviderId = " WSTR_GUID_FMT L"\n"
				L"Attributes = 0x%08lx\n"
				L"Timestamp = " WSTR_LONGLONG_FMT L"\n"
				L"Status = %d\n ",
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_SnapshotId ),
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_SnapshotSetId ),
				m_pStruct->Obj.Snap.m_lSnapshotsCount,
				m_pStruct->Obj.Snap.m_pwszSnapshotDeviceObject,
				m_pStruct->Obj.Snap.m_pwszOriginalVolumeName,
				m_pStruct->Obj.Snap.m_pwszOriginatingMachine,
				m_pStruct->Obj.Snap.m_pwszServiceMachine,
				m_pStruct->Obj.Snap.m_pwszExposedName,
				m_pStruct->Obj.Snap.m_pwszExposedPath,
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_ProviderId ),
				m_pStruct->Obj.Snap.m_lSnapshotAttributes,
				LONGLONG_PRINTF_ARG( m_pStruct->Obj.Snap.m_tsCreationTimestamp ),
				m_pStruct->Obj.Snap.m_eStatus);
            break;

        case VSS_OBJECT_PROVIDER:
            ::StringCchPrintfW(wszOutputBuffer, lBufferSize,
				L"m_ProviderId = " WSTR_GUID_FMT L"\n"
				L"m_pwszProviderName = %s\n"
				L"m_ProviderType = %d\n"
				L"m_pwszProviderVersion = %s\n"
				L"m_ProviderVersionId = " WSTR_GUID_FMT L"\n"
				L"m_ClassID: " WSTR_GUID_FMT L"\n\n",
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ProviderId ),
                m_pStruct->Obj.Prov.m_pwszProviderName? m_pStruct->Obj.Prov.m_pwszProviderName: L"NULL",
                m_pStruct->Obj.Prov.m_eProviderType,
                m_pStruct->Obj.Prov.m_pwszProviderVersion? m_pStruct->Obj.Prov.m_pwszProviderVersion: L"NULL",
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ProviderVersionId ),
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ClassId )
                );
            break;

        default:
			ft.ErrBox( VSSDBG_GEN, E_UNEXPECTED,
					   L"%s: Wrong object type %d", wszFunctionName, m_pStruct->Type );
            break;
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
		BS_ASSERT(m_pStruct == NULL);
		ft.Throw( VSSDBG_GEN, E_UNEXPECTED,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}



/////////////////////////////////////////////////////////////////////////////
//  VSS_MGMT_OBJECT_PROP_Ptr class


void VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsVolume(
		IN  CVssFunctionTracer& ft,
 		IN  VSS_PWSZ pwszVolumeName,
 		IN  VSS_PWSZ pwszVolumeDisplayName
		) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_MGMT_OBJECT_PROP_Ptr in order to keep a VSS_MGMT_OBJECT_SNAPSHOT structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsVolume";
	VSS_MGMT_OBJECT_PROP* pProp = NULL;

    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_MGMT_OBJECT_UNION structure
        pProp = static_cast<VSS_MGMT_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_MGMT_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_MGMT_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_MGMT_OBJECT_VOLUME;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_VOLUME_PROP& VolumeProp = pProp->Obj.Vol;

		// Setting the internal members
        ::VssSafeDuplicateStr(ft, VolumeProp.m_pwszVolumeName, pwszVolumeName);
        ::VssSafeDuplicateStr(ft, VolumeProp.m_pwszVolumeDisplayName, pwszVolumeDisplayName);

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_MGMT_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsDiffVolume(
		IN  CVssFunctionTracer& ft,
 		IN  VSS_PWSZ pwszVolumeName,
 		IN  VSS_PWSZ pwszVolumeDisplayName,
		IN  LONGLONG llVolumeFreeSpace,
		IN  LONGLONG llVolumeTotalSpace
		) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_MGMT_OBJECT_PROP_Ptr in order to keep a VSS_MGMT_OBJECT_PROVIDER structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsDiffVolume";
	VSS_MGMT_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert parameters
		BS_ASSERT(llVolumeFreeSpace >= 0);
		BS_ASSERT(llVolumeTotalSpace >= 0);

		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_MGMT_OBJECT_UNION structure
        pProp = static_cast<VSS_MGMT_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_MGMT_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_MGMT_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_MGMT_OBJECT_DIFF_VOLUME;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_DIFF_VOLUME_PROP& DiffVolumeProp = pProp->Obj.DiffVol;

		// Setting the internal members
        ::VssSafeDuplicateStr(ft, DiffVolumeProp.m_pwszVolumeName, pwszVolumeName);
        ::VssSafeDuplicateStr(ft, DiffVolumeProp.m_pwszVolumeDisplayName, pwszVolumeDisplayName);
        DiffVolumeProp.m_llVolumeFreeSpace = llVolumeFreeSpace;
        DiffVolumeProp.m_llVolumeTotalSpace = llVolumeTotalSpace;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_MGMT_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsDiffArea(
		IN  CVssFunctionTracer& ft,
 		IN  VSS_PWSZ pwszVolumeName,
 		IN  VSS_PWSZ pwszDiffAreaVolumeName,
		IN  LONGLONG llUsedDiffSpace,
		IN  LONGLONG llAllocatedDiffSpace,
		IN  LONGLONG llMaximumDiffSpace
		) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_MGMT_OBJECT_PROP_Ptr in order to keep a VSS_MGMT_OBJECT_PROVIDER structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsProvider";
	VSS_MGMT_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert parameters
		BS_ASSERT(llUsedDiffSpace >= 0);
		BS_ASSERT(llAllocatedDiffSpace >= 0);
		BS_ASSERT((llMaximumDiffSpace >= 0) || (llMaximumDiffSpace == -1));

		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_MGMT_OBJECT_UNION structure
        pProp = static_cast<VSS_MGMT_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_MGMT_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_MGMT_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_MGMT_OBJECT_DIFF_AREA;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_DIFF_AREA_PROP& DiffAreaProp = pProp->Obj.DiffArea;

		// Setting the internal members
        ::VssSafeDuplicateStr(ft, DiffAreaProp.m_pwszVolumeName, pwszVolumeName);
        ::VssSafeDuplicateStr(ft, DiffAreaProp.m_pwszDiffAreaVolumeName, pwszDiffAreaVolumeName);
        DiffAreaProp.m_llMaximumDiffSpace = llMaximumDiffSpace;
        DiffAreaProp.m_llAllocatedDiffSpace = llAllocatedDiffSpace;
        DiffAreaProp.m_llUsedDiffSpace = llUsedDiffSpace;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_MGMT_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsEmpty(
    IN  CVssFunctionTracer& ft
	)
/*++

Routine description:

    Initialize a VSS_MGMT_OBJECT_PROP_Ptr in order to appear as an empty structure (to be filled later).

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::InitializeEmpty";
	VSS_MGMT_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_MGMT_OBJECT_UNION structure
        pProp = static_cast<VSS_MGMT_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_MGMT_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_MGMT_OBJECT_PROP_Copy::init(pProp);

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		BS_ASSERT(pProp == NULL);
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_MGMT_OBJECT_PROP_Ptr::Print(
    IN  CVssFunctionTracer& ft,
	IN  LPWSTR wszOutputBuffer,
	IN  LONG lBufferSize
	)
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::Print";

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		if (m_pStruct == NULL)
			::StringCchPrintfW(wszOutputBuffer, lBufferSize, L"NULL object\n\n");

        switch(m_pStruct->Type)
        {
        case VSS_MGMT_OBJECT_VOLUME:

			::StringCchPrintfW(wszOutputBuffer, lBufferSize,
				L"VolumeName = %s\n"
				L"VolumeDisplayName = %s\n"
				L"lCurrentSnapshotCount = %ld \n",
				m_pStruct->Obj.Vol.m_pwszVolumeName,
				m_pStruct->Obj.Vol.m_pwszVolumeDisplayName);
            break;

        case VSS_MGMT_OBJECT_DIFF_VOLUME:
			::StringCchPrintfW(wszOutputBuffer, lBufferSize,
				L"VolumeName = %s\n"
				L"VolumeDisplayName = %s\n"
				L"llFreeSpace = " WSTR_LONGLONG_FMT L"\n"
				L"llTotalSpace = " WSTR_LONGLONG_FMT L"\n",
				m_pStruct->Obj.DiffVol.m_pwszVolumeName,
				m_pStruct->Obj.DiffVol.m_pwszVolumeDisplayName,
				m_pStruct->Obj.DiffVol.m_llVolumeFreeSpace,
				m_pStruct->Obj.DiffVol.m_llVolumeTotalSpace);
            break;

        case VSS_MGMT_OBJECT_DIFF_AREA:
			::StringCchPrintfW(wszOutputBuffer, lBufferSize,
				L"VolumeName = %s\n"
				L"VolumeDiffAreaName = %s\n"
				L"MaxSpace = " WSTR_LONGLONG_FMT L"\n"
				L"AllocatedSpace = " WSTR_LONGLONG_FMT L"\n"
				L"UsedSpace = " WSTR_LONGLONG_FMT L"\n",
				m_pStruct->Obj.DiffArea.m_pwszVolumeName,
				m_pStruct->Obj.DiffArea.m_pwszDiffAreaVolumeName,
				m_pStruct->Obj.DiffArea.m_llMaximumDiffSpace,
				m_pStruct->Obj.DiffArea.m_llAllocatedDiffSpace,
				m_pStruct->Obj.DiffArea.m_llUsedDiffSpace);
            break;


        default:
			ft.ErrBox( VSSDBG_GEN, E_UNEXPECTED,
					   L"%s: Wrong object type %d", wszFunctionName, m_pStruct->Type );
            break;
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
		BS_ASSERT(m_pStruct == NULL);
		ft.Throw( VSSDBG_GEN, E_UNEXPECTED,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\registry\registry.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc  
    @module registry.cxx | Implementation of CVssRegistryKey
    @end

Author:

    Adi Oltean  [aoltean]  03/14/2001

Revision History:

    Name        Date        Comments
    aoltean     03/14/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes
#include "stdafx.hxx"

#include "memory"
#include <safeboot.h>

#include "vs_inc.hxx"
#include "vs_reg.hxx"

#include "vs_reg.hxx"

#include "vss.h"
#include "vswriter.h"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "REGREGSC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CVssRegistryKey  implementation


// Creates the registry key. 
// Throws an error if the key already exists
void CVssRegistryKey::Create( 
    IN  HKEY        hAncestorKey,
    IN  LPCWSTR     pwszPathFormat,
    IN  ...
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::Create" );

    BS_ASSERT(hAncestorKey);
    BS_ASSERT(pwszPathFormat);
    
    // Build the path to the key
    WCHAR wszKeyPath[x_nVssMaxRegBuffer];
    va_list marker;
    va_start( marker, pwszPathFormat );
    ft.hr = StringCchVPrintfW( STRING_CCH_PARAM(wszKeyPath), pwszPathFormat, marker );
    va_end( marker );
    if (ft.HrFailed())
        ft.TranslateGenericError(VSSDBG_GEN, ft.hr, L"StringCchVPrintfW()");

    // Create the key
    BS_ASSERT( (m_samDesired & KEY_WRITE) == KEY_WRITE);
    DWORD dwDisposition = 0;
    HKEY hRegKey = NULL;
    LONG lRes = ::RegCreateKeyExW(
        hAncestorKey,               //  IN HKEY hKey,
        wszKeyPath,                 //  IN LPCWSTR lpSubKey,
        0,                          //  IN DWORD Reserved,
        REG_NONE,                   //  IN LPWSTR lpClass,
        m_dwKeyCreateOptions,       //  IN DWORD dwOptions,
        m_samDesired,               //  IN REGSAM samDesired,
        NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        &hRegKey,                   //  OUT PHKEY phkResult,
        &dwDisposition              //  OUT LPDWORD lpdwDisposition
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegCreateKeyExW(%ld,%s,...)", 
            hAncestorKey, wszKeyPath);

    // Check whether we created or opened the key
    switch ( dwDisposition )
    {
    case REG_CREATED_NEW_KEY: 
        if (!m_awszKeyPath.CopyFrom(wszKeyPath)) {
            ::RegCloseKey( hRegKey );
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");
        }
        Close();
        m_hRegKey = hRegKey;
        break;
    case REG_OPENED_EXISTING_KEY:
        ::RegCloseKey( hRegKey );
        ft.Throw( VSSDBG_GEN, VSS_E_OBJECT_ALREADY_EXISTS, L"Key %s already exists", wszKeyPath);
    default:
        BS_ASSERT( false );
        if (hRegKey && (hRegKey != INVALID_HANDLE_VALUE))
            ::RegCloseKey( hRegKey );
        ft.TranslateGenericError(VSSDBG_GEN, E_UNEXPECTED, L"RegCreateKeyExW(%ld,%s,...,[%lu])", 
            hAncestorKey, wszKeyPath, dwDisposition);
    }
}


// Opens a registry key. 
bool CVssRegistryKey::Open( 
    IN  HKEY        hAncestorKey,
    IN  LPCWSTR     pwszPathFormat,
    IN  ...
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::Open" );
    
    BS_ASSERT(hAncestorKey);
    BS_ASSERT(pwszPathFormat);
    
    // Build the path to the key
    WCHAR wszKeyPath[x_nVssMaxRegBuffer];
    va_list marker;
    va_start( marker, pwszPathFormat );
    ft.hr = StringCchVPrintfW( STRING_CCH_PARAM(wszKeyPath), pwszPathFormat, marker );
    va_end( marker );
    if (ft.HrFailed())
        ft.TranslateGenericError(VSSDBG_GEN, ft.hr, L"StringCchVPrintfW()");

    // Open the key
    HKEY hRegKey = NULL;
    LONG lRes = ::RegOpenKeyExW(
        hAncestorKey,               //  IN HKEY hKey,
        wszKeyPath,                 //  IN LPCWSTR lpSubKey,
        0,                          //  IN DWORD dwOptions,
        m_samDesired,               //  IN REGSAM samDesired,
        &hRegKey                    //  OUT PHKEY phkResult
        );
    if ( lRes == ERROR_FILE_NOT_FOUND )
        return false;
    
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegOpenKeyExW(%ld,%s,...)", 
            hAncestorKey, wszKeyPath);

    if (!m_awszKeyPath.CopyFrom(wszKeyPath)) {
        ::RegCloseKey( hRegKey );
        ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");
    }
    
    Close();
    m_hRegKey = hRegKey;

    return true;
}


// Recursively deletes a subkey. 
// Throws an error if the subkey does not exist
void CVssRegistryKey::DeleteSubkey( 
    IN  LPCWSTR     pwszPathFormat,
    IN  ...
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::DeleteSubkey" );
    
    BS_ASSERT(pwszPathFormat);
    
    // Build the path to the key
    WCHAR wszKeyPath[x_nVssMaxRegBuffer];
    va_list marker;
    va_start( marker, pwszPathFormat );
    ft.hr = StringCchVPrintfW( STRING_CCH_PARAM(wszKeyPath), pwszPathFormat, marker );
    va_end( marker );
    if (ft.HrFailed())
        ft.TranslateGenericError(VSSDBG_GEN, ft.hr, L"StringCchVPrintfW()");

    // Recursively delete the key
    DWORD dwRes = ::SHDeleteKey(
        m_hRegKey,                  //  IN HKEY hKey,
        wszKeyPath                  //  IN LPCTSTR  pszSubKey
        );
    if ( dwRes == ERROR_FILE_NOT_FOUND )
        ft.Throw( VSSDBG_GEN, VSS_E_OBJECT_NOT_FOUND, L"Key with path %s\\%s not found", 
            m_awszKeyPath.GetRef(), wszKeyPath);
    if ( dwRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(dwRes), L"SHDeleteKey(%ld[%s],%s)", 
            m_hRegKey, m_awszKeyPath.GetRef(), wszKeyPath);
}


// Deletes a value. 
// Throws an error if the value does not exist
void CVssRegistryKey::DeleteValue( 
    IN  LPCWSTR     pwszValueName
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::DeleteValue" );
    
    BS_ASSERT(pwszValueName);
    
    // Recursively delete the key
    LONG lRes = ::RegDeleteValue(
        m_hRegKey,                  //  IN HKEY hKey,
        pwszValueName               //  IN LPCTSTR  pwszValueName
        );
    if ( lRes == ERROR_FILE_NOT_FOUND )
        ft.Throw( VSSDBG_GEN, VSS_E_OBJECT_NOT_FOUND, L"Value %s\\%s not found", 
            m_awszKeyPath.GetRef(), pwszValueName);
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegDeleteValue(%ld[%s],%s)", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName);
}


// Adds a LONGLONG value to the registry key
void CVssRegistryKey::SetValue( 
    IN  LPCWSTR     pwszValueName,
    IN  LONGLONG    llValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::SetValue_LONGLONG" );

    // Convert the value to a string
    WCHAR wszValue[x_nVssMaxRegNumBuffer];
    ft.hr = StringCchPrintfW( STRING_CCH_PARAM(wszValue), 
                L"%I64d", llValue );
    if (ft.HrFailed())
        ft.TranslateGenericError( VSSDBG_GEN, ft.hr, L"StringCchPrintfW()");

    // Set the value as string
    SetValue(pwszValueName, wszValue);
}


// Adds a REG_SZ value to the registry key
void CVssRegistryKey::SetValue( 
    IN  LPCWSTR     pwszValueName,
    IN  LPCWSTR     pwszValue,
    IN  REGSAM      eSzType /* = REG_SZ */
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::SetValue_PWSZ" );

    // Assert paramters
    BS_ASSERT(pwszValueName);
    BS_ASSERT(pwszValue);

    BS_ASSERT(m_hRegKey);

    BS_ASSERT((eSzType == REG_SZ) || (eSzType == REG_EXPAND_SZ));
    
    // Set the value
    DWORD dwLength = ::lstrlenW( pwszValue );
    LONG lRes = ::RegSetValueExW(
        m_hRegKey,                          // IN HKEY hKey,
        pwszValueName,                      // IN LPCWSTR lpValueName,
        0,                                  // IN DWORD Reserved,
        eSzType,                            // IN DWORD dwType,
        (CONST BYTE*)pwszValue,             // IN CONST BYTE* lpData,
        (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), 
            L"RegSetValueExW(0x%08lx,%s,0,REG_SZ,%s.%d)", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValue, (dwLength + 1) * sizeof(WCHAR));
}


// Adds a REG_DWORD value to the registry key
void CVssRegistryKey::SetValue( 
    IN  LPCWSTR     pwszValueName,
    IN  DWORD       dwValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::SetValue_DWORD" );

    // Assert paramters
    BS_ASSERT(pwszValueName);

    BS_ASSERT(m_hRegKey);

    // Set the value
    LONG lRes = ::RegSetValueExW(
        m_hRegKey,                          // IN HKEY hKey,
        pwszValueName,                      // IN LPCWSTR lpValueName,
        0,                                  // IN DWORD Reserved,
        REG_DWORD,                          // IN DWORD dwType,
        (CONST BYTE*)&dwValue,              // IN CONST BYTE* lpData,
        sizeof(DWORD)                       // IN DWORD cbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), 
            L"RegSetValueExW(0x%08lx,%s,0,REG_DWORD,%ld)", 
            m_hRegKey, m_awszKeyPath.GetRef(), dwValue);
}


// Adds a REG_MULTI_SZ value to the registry key
// WARNING: do not call this routine for a REG_SZ value!
// (Intentionally this is a different function so that it won't 
// be confused with CVssRegistryKey::SetValue)
void CVssRegistryKey::SetMultiszValue( 
    IN  LPCWSTR     pwszValueName,
    IN  LPCWSTR     pwszValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::SetMultiszValue" );

    // Assert paramters
    BS_ASSERT(pwszValueName);
    BS_ASSERT(pwszValue);

    BS_ASSERT(m_hRegKey);
    
    // Get the length of the multi-sz string, including the zero character for each string
    DWORD dwLength = 0;
    LPCWSTR pwszCurrent = pwszValue;
    do
    {
        // Add the zero character
        LONG dwCurrentLength = ::lstrlenW(pwszCurrent) + 1;
        dwLength += dwCurrentLength;
        pwszCurrent += dwCurrentLength;
    }
    while(pwszCurrent[0]);

    // Add the final zero character
    dwLength += 1;

    // Set the value
    LONG lRes = ::RegSetValueExW(
        m_hRegKey,                          // IN HKEY hKey,
        pwszValueName,                      // IN LPCWSTR lpValueName,
        0,                                  // IN DWORD Reserved,
        REG_MULTI_SZ,                             // IN DWORD dwType,
        (CONST BYTE*)pwszValue,             // IN CONST BYTE* lpData,
        (dwLength) * sizeof(WCHAR)      // IN DWORD cbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), 
            L"RegSetValueExW(0x%08lx,%s,0,REG_SZ,%s.%d)", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValue, (dwLength) * sizeof(WCHAR));
}


// Adds a binary value to the registry key
void CVssRegistryKey::SetBinaryValue( 
    IN  LPCWSTR     pwszValueName,
    IN  BYTE *      pbData,
    IN  DWORD       dwSize
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::SetBinaryValue" );

    // Assert paramters
    BS_ASSERT(pwszValueName);
    BS_ASSERT(pbData);
    BS_ASSERT(dwSize);

    BS_ASSERT(m_hRegKey);
    
    // Set the value
    LONG lRes = ::RegSetValueExW(
        m_hRegKey,                          // IN HKEY hKey,
        pwszValueName,                      // IN LPCWSTR lpValueName,
        0,                                  // IN DWORD Reserved,
        REG_BINARY,                         // IN DWORD dwType,
        pbData,                             // IN CONST BYTE* lpData,
        dwSize                              // IN DWORD cbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), 
            L"RegSetValueExW(0x%08lx,%s,0,REG_BINARY,%p.%lu)", 
            m_hRegKey, m_awszKeyPath.GetRef(), pbData, dwSize);
}


// Reads a VSS_PWSZ value from the registry key
bool CVssRegistryKey::GetValue( 
    IN  LPCWSTR     pwszValueName,
    OUT VSS_PWSZ &  pwszValue,
    IN  bool        bThrowIfNotFound /* = true */
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::GetValue_PWSZ" );

    // Assert parameters
    BS_ASSERT(pwszValueName);
    BS_ASSERT(pwszValue == NULL);

    // Reset the OUT parameter
    pwszValue = NULL;

    // Get the value length (we suppose that doesn't change)
    DWORD dwType = 0;
    DWORD dwSizeInBytes = 0;
    LONG lResult = ::RegQueryValueExW( 
        m_hRegKey,
        pwszValueName,
        NULL,
        &dwType,
        NULL,
        &dwSizeInBytes);
    if (lResult == ERROR_FILE_NOT_FOUND) 
    {
        if (bThrowIfNotFound) 
        {
            ft.LogGenericWarning(VSSDBG_GEN, 
                L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu]) => ERROR_FILE_NOT_FOUND", 
                m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType, dwSizeInBytes);
            ft.Throw( VSSDBG_GEN, VSS_E_OBJECT_NOT_FOUND, L"Registry key not found");
        }
        else
            return ft.Exit(false);
    }
    if ((lResult != ERROR_SUCCESS) && (lResult != ERROR_MORE_DATA))
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lResult), 
            L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType, dwSizeInBytes);

    // Check the type and the size
    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected type %lu for a string value 0x%08lx(%s),%s",
            dwType, m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName );
    BS_ASSERT(dwSizeInBytes);
    
    // Allocate the buffer
    CVssAutoPWSZ awszValue;
    DWORD dwSizeOfString = dwSizeInBytes/sizeof(WCHAR);
    awszValue.Allocate(dwSizeOfString);

    // Get the string contents
    DWORD dwType2 = 0;
    DWORD dwSizeInBytes2 = dwSizeOfString * (sizeof(WCHAR));
    BS_ASSERT( dwSizeInBytes2 == dwSizeInBytes);
    lResult = ::RegQueryValueExW( 
        m_hRegKey,
        pwszValueName,
        NULL,
        &dwType2,
        (LPBYTE)awszValue.GetRef(),
        &dwSizeInBytes2);
    if (lResult != ERROR_SUCCESS)
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lResult), 
            L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType2, dwSizeInBytes2);
    BS_ASSERT(dwType2 == REG_SZ || dwType2 == REG_EXPAND_SZ);
    BS_ASSERT(dwSizeInBytes2 == dwSizeInBytes);
    (awszValue.GetRef())[dwSizeOfString] = L'\0';

    // Set the OUT parameter
    pwszValue = awszValue.Detach();

    return ft.Exit(true);
}


// Reads a LONGLONG value from the registry key
bool CVssRegistryKey::GetValue( 
    IN  LPCWSTR     pwszValueName,
    OUT LONGLONG &  llValue,
    IN  bool        bThrowIfNotFound /* = true */
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::GetValue_LONGLONG" );

    // Assert parameters
    BS_ASSERT(pwszValueName);

    CVssAutoPWSZ awszValue;
    bool bResult = GetValue(pwszValueName, awszValue.GetRef(), bThrowIfNotFound);
    if (!bResult) 
    {
        BS_ASSERT(!bThrowIfNotFound);
        return ft.Exit(false);
    }
        
    BS_ASSERT(awszValue.GetRef());
    BS_ASSERT(awszValue.GetRef()[0]);

    // Read the LONGLONG string
    llValue = ::_wtoi64(awszValue);

    return ft.Exit(true);
}


// Reads a DWORD value from the registry key
bool CVssRegistryKey::GetValue( 
    IN  LPCWSTR     pwszValueName,
    OUT DWORD  &    dwValue,
    IN  bool        bThrowIfNotFound /* = true */
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::GetValue_DWORD" );

    // Assert parameters
    BS_ASSERT(pwszValueName);

    // Reset the OUT parameter
    dwValue = 0;

    // Get the value length (we suppose that doesn't change)
    DWORD dwType = 0;
    DWORD dwSizeInBytes = 0;
    LONG lResult = ::RegQueryValueExW( 
        m_hRegKey,
        pwszValueName,
        NULL,
        &dwType,
        NULL,
        &dwSizeInBytes);
    if (lResult == ERROR_FILE_NOT_FOUND) 
    {
        if (bThrowIfNotFound)
        {
            ft.LogGenericWarning(VSSDBG_GEN, 
                L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu]) => ERROR_FILE_NOT_FOUND", 
                m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType, dwSizeInBytes);
            ft.Throw( VSSDBG_GEN, VSS_E_OBJECT_NOT_FOUND, L"Registry key not found");
        }
        else
            return ft.Exit(false);
    }
    if ((lResult != ERROR_SUCCESS) && (lResult != ERROR_MORE_DATA))
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lResult), 
            L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType, dwSizeInBytes);

    // Check the type and the size
    if (dwType != REG_DWORD)
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected type %lu for a DWORD value 0x%08lx(%s),%s",
            dwType, m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName );
    BS_ASSERT(dwSizeInBytes == sizeof(DWORD));
    
    // Get the string contents
    DWORD dwType2 = 0;
    DWORD dwSizeInBytes2 = dwSizeInBytes;
    DWORD dwReadValue = 0;
    lResult = ::RegQueryValueExW( 
        m_hRegKey,
        pwszValueName,
        NULL,
        &dwType2,
        (LPBYTE)&dwReadValue,
        &dwSizeInBytes2);
    if (lResult != ERROR_SUCCESS)
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lResult), 
            L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType2, dwSizeInBytes2);
    BS_ASSERT(dwType2 == REG_DWORD);
    BS_ASSERT(dwSizeInBytes2 == dwSizeInBytes);

    dwValue = dwReadValue;

    return ft.Exit(true);
}


// Reads a REG_BINARY value from the registry key
bool CVssRegistryKey::GetBinaryValue( 
    IN  LPCWSTR     pwszValueName,
    OUT BYTE*  &    pbData,
    OUT DWORD  &    dwSize,
    IN  bool        bThrowIfNotFound /* = true */
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::GetBinaryValue" );

    // Assert parameters
    BS_ASSERT(pwszValueName);
    BS_ASSERT(pbData == NULL);
    BS_ASSERT(dwSize == NULL);

    // Reset the OUT parameters
    pbData = NULL;
    dwSize = 0;

    // Get the value length (we suppose that doesn't change)
    DWORD dwType = 0;
    DWORD dwSizeInBytes = 0;
    LONG lResult = ::RegQueryValueExW( 
        m_hRegKey,
        pwszValueName,
        NULL,
        &dwType,
        NULL,
        &dwSizeInBytes);
    if (lResult == ERROR_FILE_NOT_FOUND) 
    {
        if (bThrowIfNotFound)
        {
            ft.LogGenericWarning(VSSDBG_GEN, 
                L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu]) => ERROR_FILE_NOT_FOUND", 
                m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType, dwSizeInBytes);
            ft.Throw( VSSDBG_GEN, VSS_E_OBJECT_NOT_FOUND, L"Registry key not found");
        }
        else
            return ft.Exit(false);
    }
    if ((lResult != ERROR_SUCCESS) && (lResult != ERROR_MORE_DATA))
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lResult), 
            L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType, dwSizeInBytes);  

    // Check the type and the size
    if (dwType != REG_BINARY)
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected type %lu for a binary value 0x%08lx(%s),%s",
            dwType, m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName );
    BS_ASSERT(dwSizeInBytes);

    // Allocate the buffer
    BS_ASSERT(dwSizeInBytes != 0);
    std::auto_ptr<BYTE>  pBuffer(new BYTE[dwSizeInBytes]);
    if (pBuffer.get() == NULL)
        ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

    // Get the binary value contents
    DWORD dwType2 = 0;
    DWORD dwSizeInBytes2 = dwSizeInBytes;
    lResult = ::RegQueryValueExW( 
        m_hRegKey,
        pwszValueName,
        NULL,
        &dwType2,
        pBuffer.get(),
        &dwSizeInBytes2);
    if (lResult != ERROR_SUCCESS)
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lResult), 
            L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType2, dwSizeInBytes2);
    BS_ASSERT(dwType2 == REG_BINARY);
    BS_ASSERT(dwSizeInBytes2 == dwSizeInBytes);

    // Set the OUT parameters
    pbData = pBuffer.release();
    dwSize = dwSizeInBytes;
    
    return ft.Exit(true);
}


// Closes the registry key
void CVssRegistryKey::Close()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::Close" );
    
    if (m_hRegKey) {
        // Close the opened key
        LONG lRes = ::RegCloseKey( m_hRegKey );
        if (lRes != ERROR_SUCCESS) {
            BS_ASSERT(false);
            ft.Trace( VSSDBG_GEN, L"%s: Error on closing key with name %s. lRes == 0x%08lx", (VSS_PWSZ)m_awszKeyPath, lRes );
        }
        m_hRegKey = NULL;
    }
    m_awszKeyPath.Clear();
}


// Standard constructor
CVssRegistryKey::CVssRegistryKey(
        IN  REGSAM samDesired, /* = KEY_ALL_ACCESS */
        IN  DWORD dwKeyCreateOptions /* = REG_OPTION_NON_VOLATILE */
        )
{
    m_hRegKey = NULL;
    m_dwKeyCreateOptions = dwKeyCreateOptions;
    m_samDesired = samDesired;
}


// Standard destructor
CVssRegistryKey::~CVssRegistryKey()
{
    Close();
}


/////////////////////////////////////////////////////////////////////////////
// CVssRegistryKeyIterator implementation



// Standard constructor
CVssRegistryKeyIterator::CVssRegistryKeyIterator()
{
    // Initialize data members
    Detach();
}


// Returns the name of the current key.
// The returned key is always non-NULL (or the function will throw E_UNEXPECTED).
VSS_PWSZ CVssRegistryKeyIterator::GetCurrentKeyName() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKeyIterator::GetCurrentKeyName" );

    if (!m_bAttached || !m_awszSubKeyName.GetRef()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: noninitialized iterator");
    }

    // Fill wszSubKeyName with the name of the subkey
    FILETIME time;
    DWORD dwSize = m_dwMaxSubKeyLen;
    LONG lRes = ::RegEnumKeyExW(
        m_hParentKey,               // IN HKEY hKey,
        m_dwCurrentKeyIndex,        // IN DWORD dwIndex,
        m_awszSubKeyName,           // OUT LPWSTR lpName,
        &dwSize,                    // IN OUT LPDWORD lpcbName,
        NULL,                       // IN LPDWORD lpReserved,
        NULL,                       // IN OUT LPWSTR lpClass,
        NULL,                       // IN OUT LPDWORD lpcbClass,
        &time);                     // OUT PFILETIME lpftLastWriteTime
    switch(lRes)
    {
    case ERROR_SUCCESS:
        BS_ASSERT(dwSize != 0);
        break; // Go to Next key
    default:
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegEnumKeyExW(%p,%lu,%p,%lu ...)", 
             m_hParentKey, m_dwCurrentKeyIndex, m_awszSubKeyName.GetRef(), dwSize);
    case ERROR_NO_MORE_ITEMS:
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: dwIndex out of scope %lu %lu", m_dwCurrentKeyIndex, m_dwKeyCount);
    }
    
    return m_awszSubKeyName.GetRef();
}


// Standard constructor
void CVssRegistryKeyIterator::Attach(
        IN  CVssRegistryKey & key
        ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKeyIterator::Attach" );

    // Reset all members
    Detach();
    m_hParentKey = key.GetHandle();
    BS_ASSERT(m_hParentKey);

    // Get the number of subkeys and the max subkey length
    DWORD dwKeyCount = 0;
    DWORD dwMaxSubKeyLen = 0;
    LONG lRes = ::RegQueryInfoKeyW(
                    m_hParentKey,       // handle to key
                    NULL,               // class buffer
                    NULL,               // size of class buffer
                    NULL,               // reserved
                    &dwKeyCount,        // number of subkeys
                    &dwMaxSubKeyLen,    // longest subkey name
                    NULL,               // longest class string
                    NULL,               // number of value entries
                    NULL,               // longest value name
                    NULL,               // longest value data
                    NULL,               // descriptor length
                    NULL);              // last write time
    if (lRes != ERROR_SUCCESS)
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegQueryInfoKeyW(%p, ...)", m_hParentKey);

    // Allocate the key name with a sufficient length.
    // We assume that the key length cannot change during the ennumeration).
    if (dwMaxSubKeyLen)
        m_awszSubKeyName.Allocate(dwMaxSubKeyLen);

    // Setting the number of subkeys
    m_dwKeyCount = dwKeyCount;
    m_dwMaxSubKeyLen = dwMaxSubKeyLen + 1;

    // Attachment completed
    m_bAttached = true;
}


void CVssRegistryKeyIterator::Detach()
{
    // Initialize data members
    m_hParentKey = NULL;
    m_dwKeyCount = 0;
    m_dwCurrentKeyIndex = 0;
    m_dwMaxSubKeyLen = 0;
    m_awszSubKeyName.Clear();
    m_bAttached = false;
}


// Tells if the current key is still valid 
bool CVssRegistryKeyIterator::IsEOF()
{
    return (m_dwCurrentKeyIndex >= m_dwKeyCount);
}


// Return the number of subkeys at the moment of attaching
DWORD CVssRegistryKeyIterator::GetSubkeysCount()
{
    return (m_dwKeyCount);
}


// Set the next key as being the current one in the enumeration
void CVssRegistryKeyIterator::MoveNext()
{
    if (!IsEOF()) 
        m_dwCurrentKeyIndex++;
    else
        BS_ASSERT(false);
}



/////////////////////////////////////////////////////////////////////////////
// CVssRegistryValueIterator  implementation



// Standard constructor
CVssRegistryValueIterator::CVssRegistryValueIterator()
{
    // Initialize data members
    Detach();
}


// Returns the name of the current value.
// The returned value is always non-NULL (or the function will throw E_UNEXPECTED).
VSS_PWSZ CVssRegistryValueIterator::GetCurrentValueName() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryValueIterator::GetCurrentValueName" );

    ReadCurrentValueDetails();
    BS_ASSERT(m_bSeekDone);
    return m_awszValueName.GetRef();
}


// Returns the type of the current value.
DWORD CVssRegistryValueIterator::GetCurrentValueType() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryValueIterator::GetCurrentValueType" );

    ReadCurrentValueDetails();
    BS_ASSERT(m_bSeekDone);
    return m_dwCurrentValueType;
}


// Reads a VSS_PWSZ value from the registry key
void CVssRegistryValueIterator::GetCurrentValueContent( 
    OUT VSS_PWSZ  & pwszValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryValueIterator::GetCurrentValueContent" );

    ReadCurrentValueDetails();
    BS_ASSERT(m_bSeekDone);

    if (m_dwCurrentValueType != REG_SZ) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: attempting to read a value of the wrong type");
    }

    // Allocate the output buffer
    DWORD cchStringSize = m_cbValueDataSize / sizeof(WCHAR);
    CVssAutoPWSZ awszBuffer;
    awszBuffer.Allocate(cchStringSize + 1);

    // Fill awszBuffer with the string contents
    DWORD cchNameSize = m_cchMaxValueNameLen;
    DWORD dwCurrentValueType = 0;
    DWORD cbValueSize = m_cbValueDataSize;
    LONG lRes = ::RegEnumValue(
        m_hKey,                     // IN HKEY hKey,
        m_dwCurrentValueIndex,      // IN DWORD dwIndex,
        m_awszValueName,            // OUT LPWSTR lpName,
        &cchNameSize,               // IN OUT LPDWORD lpcbName,
        NULL,                       // IN LPDWORD lpReserved,
        &dwCurrentValueType,        // IN OUT LPDWORD lpType,
        (LPBYTE)awszBuffer.GetRef(),// IN OUT LPBYTE lpData,
        &cbValueSize);              // IN OUT LPDWORD lpcbData
    switch(lRes)
    {
    case ERROR_SUCCESS:
        BS_ASSERT(cchNameSize != 0);
        BS_ASSERT(cbValueSize != 0);
        if (dwCurrentValueType != m_dwCurrentValueType)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, 
                L"Unexpected error: current value type changed in the meantime %lu %lu", 
                dwCurrentValueType, m_dwCurrentValueType);
        break; 
    case ERROR_NO_MORE_ITEMS:
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: dwIndex out of scope %lu %lu", m_dwCurrentValueIndex, m_dwValuesCount);
    default:
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegEnumValue(%p,%lu,%p,%lu ...)", 
             m_hKey, m_dwCurrentValueIndex, m_awszValueName.GetRef(), cchNameSize);
    }

    awszBuffer.GetRef()[cchStringSize] = L'\0';
    pwszValue = awszBuffer.Detach();
}


// Reads a DWORD value from the registry key
void CVssRegistryValueIterator::GetCurrentValueContent( 
    OUT DWORD  & dwValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryValueIterator::GetCurrentValueContent" );

    ReadCurrentValueDetails();
    BS_ASSERT(m_bSeekDone);

    if (m_dwCurrentValueType != REG_DWORD)
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, 
            L"Unexpected error: attempting to read a value of the wrong type");

    // Allocate the output buffer
    if (m_cbValueDataSize != sizeof(DWORD))
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, 
            L"Unexpected error: unexpected DWORD size [%ld, %ld]", m_cbValueDataSize, sizeof(DWORD));

    
    // Fill dwInternalValue with the DWORD value
    DWORD dwInternalValue = 0;
    DWORD cchNameSize = m_cchMaxValueNameLen;
    DWORD dwCurrentValueType = 0;
    DWORD cbValueSize = m_cbValueDataSize;
    LONG lRes = ::RegEnumValue(
        m_hKey,                     // IN HKEY hKey,
        m_dwCurrentValueIndex,      // IN DWORD dwIndex,
        m_awszValueName,            // OUT LPWSTR lpName,
        &cchNameSize,               // IN OUT LPDWORD lpcbName,
        NULL,                       // IN LPDWORD lpReserved,
        &dwCurrentValueType,        // IN OUT LPDWORD lpType,
        (LPBYTE)&dwInternalValue,   // IN OUT LPBYTE lpData,
        &cbValueSize);              // IN OUT LPDWORD lpcbData
    switch(lRes)
    {
    case ERROR_SUCCESS:
        BS_ASSERT(cchNameSize != 0);
        BS_ASSERT(cbValueSize != 0);
        if (dwCurrentValueType != m_dwCurrentValueType)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, 
                L"Unexpected error: current value type changed in the meantime %lu %lu", 
                dwCurrentValueType, m_dwCurrentValueType);
        break; 
    case ERROR_NO_MORE_ITEMS:
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: dwIndex out of scope %lu %lu", m_dwCurrentValueIndex, m_dwValuesCount);
    default:
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegEnumValue(%p,%lu,%p,%lu ...)", 
             m_hKey, m_dwCurrentValueIndex, m_awszValueName.GetRef(), cchNameSize);
    }

    dwValue = dwInternalValue;
}


// Reads a REG_BINARY value from the registry key
void CVssRegistryValueIterator::GetCurrentValueContent( 
    OUT PBYTE  & pbValue,   // Must be deleted with "delete[]"
    OUT DWORD  & cbSize
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryValueIterator::GetCurrentValueContent" );

    ReadCurrentValueDetails();
    BS_ASSERT(m_bSeekDone);

    if (m_dwCurrentValueType != REG_BINARY) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: attempting to read a value of the wrong type");
    }

    // Allocate the output buffer
    DWORD cbValueSize = m_cbValueDataSize;
    CVssAutoCppPtr<PBYTE> awszBuffer;
    awszBuffer.AllocateBytes(cbValueSize);

    // Fill awszBuffer with the string contents
    DWORD cchNameSize = m_cchMaxValueNameLen;
    DWORD dwCurrentValueType = 0;
    LONG lRes = ::RegEnumValue(
        m_hKey,                     // IN HKEY hKey,
        m_dwCurrentValueIndex,      // IN DWORD dwIndex,
        m_awszValueName,            // OUT LPWSTR lpName,
        &cchNameSize,               // IN OUT LPDWORD lpcbName,
        NULL,                       // IN LPDWORD lpReserved,
        &dwCurrentValueType,        // IN OUT LPDWORD lpType,
        (LPBYTE)awszBuffer.Get(),   // IN OUT LPBYTE lpData,
        &cbValueSize);              // IN OUT LPDWORD lpcbData
    switch(lRes)
    {
    case ERROR_SUCCESS:
        BS_ASSERT(cchNameSize != 0);
        BS_ASSERT(cbValueSize != 0);
        if (dwCurrentValueType != m_dwCurrentValueType)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, 
                L"Unexpected error: current value type changed in the meantime %lu %lu", 
                dwCurrentValueType, m_dwCurrentValueType);
        break; 
    case ERROR_NO_MORE_ITEMS:
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: dwIndex out of scope %lu %lu", m_dwCurrentValueIndex, m_dwValuesCount);
    default:
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegEnumValue(%p,%lu,%p,%lu ...)", 
             m_hKey, m_dwCurrentValueIndex, m_awszValueName.GetRef(), cchNameSize);
    }

    pbValue = awszBuffer.Detach();
    cbSize = cbValueSize;
}


// Returns the name and the type of the current value.
void CVssRegistryValueIterator::ReadCurrentValueDetails() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryValueIterator::ReadCurrentValueDetails" );

    if (!m_bAttached || !m_awszValueName.GetRef()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: noninitialized iterator");
    }

    // Do not load twice the same value
    if (m_bSeekDone)
        return;

    // Fill wszSubKeyName with the name of the subkey
    DWORD cchNameSize = m_cchMaxValueNameLen;
    LONG lRes = ::RegEnumValue(
        m_hKey,                     // IN HKEY hKey,
        m_dwCurrentValueIndex,      // IN DWORD dwIndex,
        m_awszValueName,            // OUT LPWSTR lpName,
        &cchNameSize,               // IN OUT LPDWORD lpcbName,
        NULL,                       // IN LPDWORD lpReserved,
        &m_dwCurrentValueType,      // IN OUT LPDWORD lpType,
        NULL,                       // IN OUT LPBYTE lpData,
        &m_cbValueDataSize);        // IN OUT LPDWORD lpcbData
    switch(lRes)
    {
    case ERROR_SUCCESS:
        BS_ASSERT(cchNameSize != 0);
        BS_ASSERT(m_cbValueDataSize != 0);
        break; // Go to Next key
    default:
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegEnumValue(%p,%lu,%p,%lu ...)", 
             m_hKey, m_dwCurrentValueIndex, m_awszValueName.GetRef(), cchNameSize);
    case ERROR_NO_MORE_ITEMS:
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: dwIndex out of scope %lu %lu", m_dwCurrentValueIndex, m_dwValuesCount);
    }

    m_bSeekDone = true;
}


// Attaches the iterator to a registry key
void CVssRegistryValueIterator::Attach(
        IN  CVssRegistryKey & key
        ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryValueIterator::Attach" );

    // Reset all members
    Detach();
    m_hKey = key.GetHandle();
    BS_ASSERT(m_hKey);

    // Get the number of values and the max value name length
    DWORD dwValuesCount = 0;
    DWORD dwMaxValueNameLen = 0;
    LONG lRes = ::RegQueryInfoKeyW(
                    m_hKey,             // handle to key
                    NULL,               // class buffer
                    NULL,               // size of class buffer
                    NULL,               // reserved
                    NULL,               // number of subkeys
                    NULL,               // longest subkey name
                    NULL,               // longest class string
                    &dwValuesCount,     // number of value entries
                    &dwMaxValueNameLen, // longest value name
                    NULL,               // longest value data
                    NULL,               // descriptor length
                    NULL);              // last write time
    if (lRes != ERROR_SUCCESS)
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegQueryInfoKeyW(%p, ...)", m_hKey);

    // Allocate the key name with a sufficient length.
    // We assume that the key length cannot change during the ennumeration).
    if (dwMaxValueNameLen)
        m_awszValueName.Allocate(dwMaxValueNameLen);

    // Setting the number of subkeys
    m_dwValuesCount = dwValuesCount;
    m_cchMaxValueNameLen = dwMaxValueNameLen + 1;

    // Attachment completed
    m_bAttached = true;
}


void CVssRegistryValueIterator::Detach()
{
    // Initialize data members
    m_hKey = NULL;
    m_dwValuesCount = 0;
    m_dwCurrentValueIndex = 0;
    m_cchMaxValueNameLen = 0;
    m_awszValueName.Clear();
    m_dwCurrentValueType = 0;
    m_cbValueDataSize = 0;
    m_bSeekDone = false;
    m_bAttached = false;
}


// Tells if the current key is still valid 
bool CVssRegistryValueIterator::IsEOF()
{
    return (m_dwCurrentValueIndex >= m_dwValuesCount);
}


// Return the number of subkeys at the moment of attaching
DWORD CVssRegistryValueIterator::GetValuesCount()
{
    return (m_dwValuesCount);
}


// Set the next key as being the current one in the enumeration
void CVssRegistryValueIterator::MoveNext()
{
    if (!IsEOF()) 
    {
        m_bSeekDone = false;
        m_dwCurrentValueType = 0;
        m_cbValueDataSize = 0;
        m_dwCurrentValueIndex++;
    }
    else
        BS_ASSERT(false);
}


/////////////////////////////////////////////////////////////////////////////
// CVssDiag implementation


void CVssDiag::Initialize(
    IN  LPCWSTR     pwszStaticContext
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssDiag::Initialize" );

    try
    {
        ft.Trace( VSSDBG_GEN, L"Parameters %s", pwszStaticContext);

        if ((pwszStaticContext == NULL) || (pwszStaticContext[0] == L'\0')) {
            BS_ASSERT(false);   // Programming error
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L" NULL or empty parameter");
        }

        // If not initialized, return
        if (m_bInitialized)
            return;

        // If not enabled, return
        if(!m_key.Open(HKEY_LOCAL_MACHINE, x_wszVssDiagPath)) {
            ft.Trace(VSSDBG_GEN, L"Diagnose not enabled (%s)", pwszStaticContext);
            return;
        }

        // Try to read the "Enabled" flag. If not present, return.
        CVssAutoPWSZ awszValue;
        if (m_key.GetValue(L"", awszValue.GetRef(), false))
        {
            if (!awszValue.GetRef()) {
                BS_ASSERT(false);
                return;
            }
            
            if (wcscmp(awszValue, x_wszVssDiagEnabledValue) != 0)
                return;
                
            // Open the key, if exists. If not, create it.
            if (!m_key.Open(HKEY_LOCAL_MACHINE, L"%s\\%s", x_wszVssDiagPath, pwszStaticContext))
                m_key.Create(HKEY_LOCAL_MACHINE, L"%s\\%s", x_wszVssDiagPath, pwszStaticContext);
            
            ft.Trace(VSSDBG_GEN, L"Diagnose enabled for (%s)", pwszStaticContext);
            
            // Zero out the queued diag data
            ::VssZeroOut(m_QueuedDiagData);
            
            // Mark the object as "initialized"
            m_bInitialized = true;
        }
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssDiag::RecordWriterEvent(
    IN  VSS_OPERATION   eOperation,
    IN  DWORD           dwEventContext,
    IN  DWORD           dwCurrentState,
    IN  HRESULT         hrLastError,
    IN  GUID            guidSnapshotSetID /* = GUID_NULL */
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssDiag::RecordWriterEvent" );

    RecordGenericEvent(
        eOperation,
        dwEventContext,
        dwCurrentState,
        hrLastError,
        guidSnapshotSetID
        );
}


void CVssDiag::RecordGenericEvent(
    IN  DWORD       dwEventID,
    IN  DWORD       dwEventContext,
    IN  DWORD       dwCurrentState,
    IN  HRESULT     hrLastError,
    IN  GUID        guidSnapshotSetID /* = GUID_NULL */
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssDiag::RecordGenericEvent" );

    try
    {
        ft.Trace( VSSDBG_GEN, L"Parameters %ld, %ld, %ld, 0x%08lx, " WSTR_GUID_FMT, 
            dwEventID, dwEventContext, dwCurrentState, hrLastError, 
            GUID_PRINTF_ARG(guidSnapshotSetID));

        // If not initialized, return
        if (!m_bInitialized)
            return;

        if (dwEventContext & CVssDiag::VSS_DIAG_IGNORE_LEAVE)
            return;

        // Get new event parameters
        bool bInOperation = !!(dwEventContext & VSS_DIAG_ENTER_OPERATION);
        LPCWSTR pwszEventName = GetStringFromOperation(bInOperation, dwEventID);

        // Some events do not require logging
        if (NULL == pwszEventName)
            return;
            
        ft.Trace(VSSDBG_GEN, L"Event name: %s", pwszEventName);

        // Fill out event data
        CVssDiagData    data;

        data.m_dwSize = sizeof(data);  // For future compatibility
        data.m_dwReserved = 0;
        
        CVsFileTime filetime;
        data.m_llTimestamp = filetime;
        
        data.m_dwProcessID = GetCurrentProcessId();
        data.m_dwThreadID = GetCurrentThreadId();
        
        data.m_dwEventID = dwEventID;
        data.m_dwEventContext = dwEventContext;
        
        data.m_dwCurrentState = dwCurrentState;
        data.m_hrLastErrorCode = hrLastError;
        
        data.m_guidSnapshotSetID = guidSnapshotSetID;
        
        data.m_pReserved1 = NULL;
        data.m_pReserved2 = NULL;

        // If we are in queued mode, then add the element to the queue
        if (IsQueuedMode(dwEventID, dwEventContext))
        {
            if (m_dwQueuedElements < x_nMaxQueuedDiagData)
            {
                m_QueuedDiagData[m_dwQueuedElements].m_pwszEventName = pwszEventName;
                m_QueuedDiagData[m_dwQueuedElements].m_diag = data;
                m_dwQueuedElements++;
            }
        }
        else
        {
            // Flush the queue
            FlushQueue();

            // Write the current data as a binary block
            m_key.SetBinaryValue(pwszEventName, (BYTE *) &data, sizeof(data));
        }
    }
    VSS_STANDARD_CATCH(ft)
}


// Flush the queued elements in registry
void CVssDiag::FlushQueue()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssDiag::FlushQueue" );

    try
    {
        DWORD dwQueuedElements = m_dwQueuedElements;
        m_dwQueuedElements = 0;
        for ( DWORD dwIndex = 0; dwIndex < dwQueuedElements; dwIndex++)
        {
            // Write the data as a binary block
            LPCWSTR pwszEventName = m_QueuedDiagData[dwIndex].m_pwszEventName;
            CVssDiagData* pDiagData = &(m_QueuedDiagData[dwIndex].m_diag);
            m_key.SetBinaryValue(pwszEventName, (BYTE *) pDiagData, sizeof(CVssDiagData));
        }
    }
    VSS_STANDARD_CATCH(ft)
}


// Size of the L"VSS_IN_" string, without the zero character
const x_VssPrefixSize = SIZEOF_ARRAY(L"VSS_IN_") - 1;

// Define for simplifying hte case statement below
#define VSS_OPERATION_CASE_STMT(operation)                                          \
	case operation:                                                                 \
	    if (bInOperation)                                                           \
    	    return x_VssPrefixSize + VSS_WSTRINGIZE(operation) L" (Enter)" ;        \
    	else                                                                        \
    	    return x_VssPrefixSize + VSS_WSTRINGIZE(operation) L" (Leave)" ;


// Define for simplifying hte case statement below
#define VSS_WRITERSTATE_CASE_STMT(state)                                            \
    case state:                                                                     \
        if (bInOperation)                                                           \
            return VSS_WSTRINGIZE(state) L" (SetCurrentState)" ;                    \
        else                                                                        \
            return NULL;


// Define for simplifying hte case statement below
#define VSS_HRESULT_CASE_STMT(hresult)                                              \
    case hresult:                                                                   \
        if (bInOperation)                                                           \
            return VSS_WSTRINGIZE(hresult) L" (SetCurrentFailure)" ;                \
        else                                                                        \
            return NULL;


// Convert a writer status into a string
LPCWSTR CVssDiag::GetStringFromOperation(
            IN	bool bInOperation,
            IN  DWORD dwOperation
            )
{
    switch (dwOperation)
	{
        // Writer operations
        VSS_OPERATION_CASE_STMT(VSS_IN_IDENTIFY)
        VSS_OPERATION_CASE_STMT(VSS_IN_PREPAREBACKUP)
        VSS_OPERATION_CASE_STMT(VSS_IN_PREPARESNAPSHOT)
        VSS_OPERATION_CASE_STMT(VSS_IN_FREEZE)
        VSS_OPERATION_CASE_STMT(VSS_IN_THAW)
        VSS_OPERATION_CASE_STMT(VSS_IN_POSTSNAPSHOT)
        VSS_OPERATION_CASE_STMT(VSS_IN_BACKUPCOMPLETE)
        VSS_OPERATION_CASE_STMT(VSS_IN_PRERESTORE)
        VSS_OPERATION_CASE_STMT(VSS_IN_POSTRESTORE)
        VSS_OPERATION_CASE_STMT(VSS_IN_GETSTATE)
        VSS_OPERATION_CASE_STMT(VSS_IN_ABORT)
        VSS_OPERATION_CASE_STMT(VSS_IN_BACKUPSHUTDOWN)
        VSS_OPERATION_CASE_STMT(VSS_IN_BKGND_FREEZE_THREAD)
        
        // Other Event IDs
        VSS_OPERATION_CASE_STMT(VSS_IN_OPEN_VOLUME_HANDLE)
        VSS_OPERATION_CASE_STMT(VSS_IN_IOCTL_FLUSH_AND_HOLD)
        VSS_OPERATION_CASE_STMT(VSS_IN_IOCTL_RELEASE)
        
        // Writer State changes. 
        // These values are coming from SetCurrentState
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_UNKNOWN)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_STABLE)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_WAITING_FOR_FREEZE)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_WAITING_FOR_THAW)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_WAITING_FOR_POST_SNAPSHOT)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_IDENTIFY)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_PREPARE_BACKUP)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_PREPARE_SNAPSHOT)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_FREEZE)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_THAW)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_POST_SNAPSHOT)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_BACKUP_COMPLETE)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_PRE_RESTORE)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_POST_RESTORE)
        VSS_WRITERSTATE_CASE_STMT(VSS_WS_FAILED_AT_BACKUPSHUTDOWN)
        
        // Writer error codes
        // These values are coming from SetCurrentFailure
        VSS_HRESULT_CASE_STMT(VSS_S_OK)
        VSS_HRESULT_CASE_STMT(VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT)
        VSS_HRESULT_CASE_STMT(VSS_E_WRITERERROR_OUTOFRESOURCES)
        VSS_HRESULT_CASE_STMT(VSS_E_WRITERERROR_TIMEOUT)
        VSS_HRESULT_CASE_STMT(VSS_E_WRITERERROR_RETRYABLE)
        VSS_HRESULT_CASE_STMT(VSS_E_WRITERERROR_NONRETRYABLE)
        VSS_HRESULT_CASE_STMT(VSS_E_WRITERERROR_RECOVERY_FAILED)
        VSS_HRESULT_CASE_STMT(VSS_E_WRITER_NOT_RESPONDING)
	default:
	    {
            static WCHAR wszBuffer[80];
            ::StringCchPrintfW(STRING_CCH_PARAM(wszBuffer), 
                L"UNKNOWN_EVENT[0x%08lx] %s", 
                dwOperation, bInOperation? L"(Enter)": L"(Leave)");
            return wszBuffer;
        }
	}
}


// Returns true if the diagnose must operate in queued mode 
// (i.e. without writing to registry)
bool CVssDiag::IsQueuedMode(
    IN  DWORD       dwEventID,
    IN  DWORD       dwEventContext
    )
{
    switch (dwEventID)
    {
    case VSS_IN_IOCTL_FLUSH_AND_HOLD:
        // Always in Queued mode (since we don't know the order for parallel F&H ioctls)
        return true;               
        
    case VSS_IN_IOCTL_RELEASE:
        // If we are in ENTER then we are still in queued mode
        return !!(dwEventContext & VSS_DIAG_ENTER_OPERATION);               

    default:
        return false;
    }

}


bool CVssMachineInformation::IsDuringSetup()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssMachineInformation::IsDuringSetup" );

    CRegKey cRegKeySetup;
    DWORD dwRes = cRegKeySetup.Open(HKEY_LOCAL_MACHINE, x_SetupKey, KEY_READ);
    if (dwRes == ERROR_SUCCESS)
    {
        DWORD dwValue;
        dwRes = cRegKeySetup.QueryValue(dwValue, x_SystemSetupInProgress);
        if (dwRes == ERROR_SUCCESS && dwValue > 0)
            return true;
        dwRes = cRegKeySetup.QueryValue(dwValue, x_UpgradeInProgress);
        if (dwRes == ERROR_SUCCESS && dwValue > 0)
            return true;
    }
    return false;
}


bool CVssMachineInformation::IsDuringSafeMode()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssMachineInformation::IsDuringSafeMode" );

    CRegKey cRegKeySetup;
    DWORD dwRes = cRegKeySetup.Open(HKEY_LOCAL_MACHINE, x_SafebootKey, KEY_READ);
    if (dwRes == ERROR_SUCCESS)
    {
        DWORD dwValue;
        dwRes = cRegKeySetup.QueryValue(dwValue, x_SafebootOptionValue);
        if (dwRes == ERROR_SUCCESS)
        {
            ft.Trace(VSSDBG_GEN, L"SafeBoot option 0x%08lx", dwValue);
            switch(dwValue)
            {
                case SAFEBOOT_MINIMAL:
                case SAFEBOOT_NETWORK:
                    return true;
                case SAFEBOOT_DSREPAIR:
                    // Writers are allowed in DS Repair
                    // (That's the only way for the AD Writer to do its job on restore).
                    return false;
                default:
                    ft.Trace(VSSDBG_GEN, L"Unrecognized safe mode option %ud", dwValue);
                    return true;
            }
        }
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\alloc.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Alloc.cxx | Automatic allocation of diff areas
    @end

Author:

    Adi Oltean  [aoltean]   06/01/2000

Comments:

    This module contains routines for diff area allocation at the time
    of snapshot creation.

    There is maximum one diff area association per snapshotted volume.

Algorithm:

    b) If the snapshotted volume already have a snapshot (i.e. an "in use" diff area)
    we don't establish a different diff area association.
    This is because it is not possible today to change the diff area
    associations for volumes that already have snapshots.

    c) If there is no diff area "in use" we look into the registry for a diff area
    association for hte snapshotted volume. If there is one, we use it. Note that we
    ignore /owerwrite the VOLSNAP diff area settings (i.e. those retrieved by the
    QUERY_DIFF_AREAS ioctl).

    d) If there are no diff areas in use or in registry for the snapshotted volume then
    we apply the default allocation algorithm. The algorithm differs for timewarp
    versus backup.

    e)  ( If the diff area association specified in registry is invalid (non-NTFS
    or read-only or non-fixed) then stop creation process with VSS_E_INSUFFICIENT_STORAGE. )

    f)  Otherwise, (i.e. no "in use" or "in registry" diff area) then use one of
    the the default diff area allocation algorithms, depending on the context:

    f.1) The algorithm for default diff area allocation for Backup

    Initial suppositions:
    - Supposing that we are taking snapshots of N volumes.
    - From this volumes, suppose that LS volumes don't have yet a diff area
    association in use. A volume has an "in use" diff area if and only if it
    has Babbage snapshots. Obviously, Count(LS) <= N.

    In short, the backup allocation algorithm will choose diff areas in order to
    maximize the diff area free space for the diff area volumes. The free space
    per diff area must be over 20 Mb. We prefer allocating a diff area on the snapshotted volume.

    A detailed description of the algorithm is given below.

        1)  Select the list LC of volumes that are candidate for a diff area
        (read-write, NTFS, fixed).
        2)  Eliminate the volumes that have free space under the 120 Mb from LC.
        (100Mb are necessary for initial allocation during Flush&Hold + Release,
        20 Mb are the minimum for free space per at least one diff area).
        This is preliminary calculation.
        3)  For each volume V from LC, compute the number of diff areas
        nExistingDiffAreaCount[V] that are currently in use on volume V.
        We ignore the diff areas that are not in use.
        4)  We try to determine a number of new diff area associatons so that
        we maximize the free space per diff area for each diff area volume.
        This is done using the following algorithm
            a.  Initialize nPlannedDiffAreaCount[V] = 0, for each V
            b.  For each (snapshotting) volume VS which does not have a diff area
            association
                i.  We select a diff area candidate that maximizes the free space per
                (existing or planned) diff area. In other words, we select the volume
                VD from LC that maximizes the following formula:
                (Free space on VD) / (nExistingDiffAreaCount[V] + nPlannedDiffAreaCount[V] + 1)
                ii. The free space above must be over 20 Mb, otherwise we will stop the
                allocation with VSS_E_INSUFFICIENT_STORAGE.
                iii.    After selecting the volume VD that satisfies the max criteria above,
                we increment nPlannedDiffAreaCount[VD] and we add VD to the Planned diff
                area list (say LD)
                    Note: we added 1 to the nPlannedDiffAreaCount[V] in the above formula,
                    since we want to estimate what the free space per diff area will
                    be if we plan this new diff area.
                    Note: the formula above does not depend on VS, so LD will not depend
                    on the snapshotted volume.So we will simply iterate the loop above
                    NS times, where NS = count(LS).
        5)  After computing the list of planned diff area volumes we will
        establish the associations between the volumes from LS and the volumes
        from LD. If a volume exists both in LS and LD we will establish the diff
        area association to itself.

    If we cannot find in the system the necessary space for allocating the
    necessary diff areas (for example no NTFS volume on the system) the
    snapshot creation process stops with VSS_E_INSUFFICIENT_STORAGE

    f.2) The algorithm for default diff area allocation for Timewarp

    For each volume (that does not have yet a diff area) we will allocate a
    diff area on the volume itself, where the maximum diff area space will be
    10% from the total volume space. If this value is smaller than 100 Mb we
    will use 100 Mb instead as the max diff area.

    If the snapshotted volume cannot be used as a diff area we return
    VSS_E_INSUFFICIENT_STORAGE.

Revision History:

    Name        Date        Comments

    aoltean     06/01/2000  Created.
    aoltean     07/12/2001  Adding algorithm description.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "memory"
#include <winnt.h>
#include "vssmsg.h"

#include "vs_idl.hxx"
#include "ntddsnap.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_reg.hxx"
#include "ichannel.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"
#include "alloc.hxx"
#include "qsnap.hxx"
#include "provider.hxx"

#include "diffmgmt.hxx"
#include "diffreg.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRALLOC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Constants

// The minimum free space for a diff area
const x_nRemainingFreeSpace = 20 * 1024 * 1024;


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator constructors/destructors


CVssDiffAreaAllocator::CVssDiffAreaAllocator(
    IN  LONG lContext,
    IN  VSS_ID SnapshotSetID
    ):
    m_bChangesCommitted(false),
    m_bNoChangesNeeded(false),
    m_lContext(lContext),
    m_SnapshotSetID(SnapshotSetID)
{
    CVssFunctionTracer( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::CVssDiffAreaAllocator");

    BS_ASSERT(SnapshotSetID != GUID_NULL);
}


CVssDiffAreaAllocator::~CVssDiffAreaAllocator()
{
    CVssFunctionTracer( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::~CVssDiffAreaAllocator");
    int nIndex;

    // The Rollback function should not throw.
    if (!m_bChangesCommitted && !m_bNoChangesNeeded)
        Rollback();

    // Deallocate all the associations
    for (nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
        delete m_mapOriginalVolumes.GetValueAt(nIndex);

    // Deallocate all the volume names
    for (nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
        ::VssFreeString(m_mapOriginalVolumes.GetKeyAt(nIndex));

    // Deallocate all the diff area candidates
    // This will delete the associated volume names also (which are the keys)
    for (nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++)
        delete m_mapDiffAreaCandidates.GetValueAt(nIndex);
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator Public operations

void CVssDiffAreaAllocator::AssignDiffAreas() throw(HRESULT)
/*++

Routine description:

    Assign all the diff areas for the current snapshot set.

Throws:

    VSS_E_PROVIDER_VETO
    E_UNEXPECTED
    VSS_E_INSUFFICIENT_STORAGE
        - insufficient diff area

    [CVssDiffAreaAllocator::Initialize() failures]
        E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::AssignDiffAreas");


    // Fill out various internal structures (like the list of original volumes)
    Initialize();

    // If no volumes to snapshot then we are done.
    if (m_bNoChangesNeeded)
        return;

    // Find the candidates for the diff areas
    FindDiffAreaCandidates();

    // Deal with no candidates scenario...
    // If no candidates then we will stop here and inform the user to add more NTFS disk space.
    if (m_mapDiffAreaCandidates.GetSize() == 0) {
        ft.LogError( VSS_ERROR_NO_DIFF_AREAS_CANDIDATES, VSSDBG_SWPRV);
        ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE, L"Cannot find a diff area candidate");
    }

    // Clear the non-necessary diff areas and compute the number of allocated
    // diff areas that already exist on each candidate
    ComputeExistingDiffAreasCount();

    // planning of new diff areas
    PlanNewDiffAreas();

    // effectively allocate the diff areas for the voluems to be snapshotted
    AssignPlannedDiffAreas();
}


void CVssDiffAreaAllocator::Commit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Commit");

    m_bChangesCommitted = true;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator Private operations


void CVssDiffAreaAllocator::Initialize() throw(HRESULT)
/*++

Routine description:

    Initialize the internal data structures

Throws:

    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Initialize");

    // For all volumes which have snapshots
    // - reassign the next diff area to the existing diff area
    CVssSnapIterator snapIterator;
    while (true)
    {
        CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(m_SnapshotSetID);

        // End of enumeration?
        if (ptrQueuedSnapshot == NULL)
            break;

        // Get the snapshot structure
        PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
        BS_ASSERT(pProp != NULL);

        // Ignore the snapshots that are not in the PREPARING state.
        if (ptrQueuedSnapshot->GetStatus() == VSS_SS_PREPARING) {
            // Make a copy of the volume name
            BS_ASSERT(pProp->m_pwszOriginalVolumeName && pProp->m_pwszOriginalVolumeName[0]);
            CVssAutoPWSZ awszOriginalVolumeName;
            ::VssSafeDuplicateStr( ft, awszOriginalVolumeName.GetRef(), pProp->m_pwszOriginalVolumeName );
            BS_ASSERT(awszOriginalVolumeName.GetRef());

            // Check to see if the volume is snapshotted
            // If is has already snapshots, do not attempt to change its diff area.
            CVssAutoPWSZ awszLastSnapshotName;
            LONG lVolAttr = CVsSoftwareProvider::GetVolumeInformationFlags(awszOriginalVolumeName,
                                VSS_CTX_ALL, &awszLastSnapshotName);
            if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
            {
                ft.LogError(VSS_ERROR_INVALID_SNAPSHOTTED_VOLUME, VSSDBG_SWPRV << awszOriginalVolumeName.GetRef());
                ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, 
                    L"Volume %s appears as invalid or dismounted", awszOriginalVolumeName.GetRef());
            }

            // If the volume is snapshotted then initialize its diff area
            if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED) != 0)
            {
                BS_ASSERT(awszLastSnapshotName.GetRef());

                // Attach to the snapshot.
                CVssDiffArea diffobj;
                CVssAutoPWSZ awszDiffAreaVolumeInUse;

                // Get the diff area for the "in use" volume.
                try
                {
                    diffobj.InitializeForSnapshot(awszLastSnapshotName, true, true);
                    diffobj.GetDiffArea(awszDiffAreaVolumeInUse);
                }
                VSS_STANDARD_CATCH(ft)
                if (ft.HrFailed())
                {
                    // The snapshot may dissapear in the middle. Ignore this error.
                    ft.Trace( VSSDBG_SWPRV, L"The snapshot %s most likely dissapeared without notice. Ignored. [5x%08lx]",
                        awszLastSnapshotName.GetRef(), ft.hr);
                    continue;
                }

#ifdef _DEBUG
                // Verify that the registry information is correct
                LONGLONG llMaxSpaceInRegistry = 0;
                LONG lAssociationFlags = 0;
                CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
                CVssProviderRegInfo regInfo;
                if (regInfo.GetDiffAreaForVolume(awszOriginalVolumeName,
                        awszDiffAreaVolumeInRegistry.GetRef(), llMaxSpaceInRegistry, lAssociationFlags))
                {
                    BS_ASSERT(::wcscmp(awszDiffAreaVolumeInUse, awszDiffAreaVolumeInRegistry) == 0);
                }
#endif // _DEBUG

                // Re-set the diff area for the next snapshot to be the one used last time
                diffobj.InitializeForVolume(awszOriginalVolumeName);
                diffobj.Clear();
                diffobj.AddVolume(awszDiffAreaVolumeInUse.GetRef());
            }
        }
    }

    // Get the list of volumes to be snapshotted
    // We do this in a separate loop since even if the snapshot dissapears we want a diff area to
    // be already assigned to it (in the loop above)
    BS_ASSERT(m_mapOriginalVolumes.GetSize() == 0);
    CVssSnapIterator snapIterator2;
    while (true)
    {
        CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator2.GetNextBySnapshotSet(m_SnapshotSetID);

        // End of enumeration?
        if (ptrQueuedSnapshot == NULL)
            break;

        // Get the snapshot structure
        PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
        BS_ASSERT(pProp != NULL);

        // Ignore the snapshots that are not in the PREPARING state.
        if (ptrQueuedSnapshot->GetStatus() == VSS_SS_PREPARING) {
            // Make a copy of the volume name
            BS_ASSERT(pProp->m_pwszOriginalVolumeName && pProp->m_pwszOriginalVolumeName[0]);
            CVssAutoPWSZ awszOriginalVolumeName;
            ::VssSafeDuplicateStr( ft, awszOriginalVolumeName.GetRef(), pProp->m_pwszOriginalVolumeName );
            BS_ASSERT(awszOriginalVolumeName.GetRef());

            // Check to see if the volume is snapshotted
            // If is has already snapshots, do not attempt to change its diff area.
            LONG lVolAttr = CVsSoftwareProvider::GetVolumeInformationFlags(awszOriginalVolumeName, VSS_CTX_ALL);
            if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
            {
                ft.LogError(VSS_ERROR_INVALID_SNAPSHOTTED_VOLUME, VSSDBG_SWPRV << awszOriginalVolumeName.GetRef());
                ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, 
                    L"Volume %s appears as invalid or dismounted", awszOriginalVolumeName.GetRef());
            }
            
            if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED) != 0)
                continue;

            // Add the corresponding diff area
            std::auto_ptr<CVssDiffAreaAssociation>
                pAssociation(new CVssDiffAreaAssociation(awszOriginalVolumeName));

            if (pAssociation.get() == NULL)
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

            // Add the volume to the ones needed for diff area
            if (!m_mapOriginalVolumes.Add(awszOriginalVolumeName.GetRef(), pAssociation.get()))
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

            // the values are now kept by the array.
            awszOriginalVolumeName.Detach();
            pAssociation.release();
        }
    }

    // If there are no volumes to process then make this explicit
    if (m_mapOriginalVolumes.GetSize() == 0) {
        m_bNoChangesNeeded = true;
        return;
    }
}


void CVssDiffAreaAllocator::FindDiffAreaCandidates() throw(HRESULT)
/*++

Routine description:

    Find the candidates for the diff areas
    Compute various parameters like the number of allocated diff areas on each candidate

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO
        - FindFirstVolume, FindNextVolume errors

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::FindDiffAreaCandidates");

    // Search between all mounted volumes
    WCHAR wszVolumeName[MAX_PATH+1];
    CVssVolumeIterator volumeIterator;
    while(true) {
    
        // Get the volume name
        if (!volumeIterator.SelectNewVolume(ft, wszVolumeName, MAX_PATH))
            break;

        BS_ASSERT( wszVolumeName[0] );

        // Make sure the volume si supported for diff area (fixed, NTFS, read-write)
        LONG lDiffVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszVolumeName, VSS_CTX_ALL, NULL, FALSE);
        if ((lDiffVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
            continue;

        // Get its free space
        ULARGE_INTEGER ulnFreeBytesAvailable;
        ULARGE_INTEGER ulnTotalNumberOfBytes;
        ULARGE_INTEGER ulnTotalNumberOfFreeBytes;
        if (!::GetDiskFreeSpaceEx(wszVolumeName,
                &ulnFreeBytesAvailable,
                &ulnTotalNumberOfBytes,
                &ulnTotalNumberOfFreeBytes
                )){
            ft.Trace( VSSDBG_SWPRV, L"Cannot get the free space for volume (%s) - [0x%08lx]",
                      wszVolumeName, GetLastError());
            BS_ASSERT(false);
            continue;
        }

        // Check to see if the free space is enough for at least one diff area
        if (ulnTotalNumberOfFreeBytes.QuadPart <
                (ULONGLONG)(x_nDefaultInitialSnapshotAllocation)) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a volume (%s) with "
                      L"insufficient free space for one allocation (%I64u)",
                      wszVolumeName, ulnFreeBytesAvailable);
            continue;
        }

        // Add the local volume as a candidate
        CVssAutoPWSZ awszCandidate;
        if (!awszCandidate.CopyFrom(wszVolumeName))
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

        // Create the candidate object that must keep this information.
        CVssDiffAreaCandidate* pObj =
            new CVssDiffAreaCandidate(awszCandidate.GetRef(), ulnTotalNumberOfBytes, ulnFreeBytesAvailable);
        if (pObj == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

        // Add the candidate object into the array
        if (!m_mapDiffAreaCandidates.Add(awszCandidate.GetRef(), pObj)) {
            delete pObj;
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");
        }

        // The string is already detached in a Diff Area Candidate
        awszCandidate.Detach();

        ft.Trace( VSSDBG_SWPRV, L"Candidate added: (\'%s\', %I64u)",
                  awszCandidate, ulnFreeBytesAvailable );
    }
}


void CVssDiffAreaAllocator::ComputeExistingDiffAreasCount() throw(HRESULT)
/*++

Description:

    Compute the nunber of original volumes that keeps diff areas on this volume.
    This does not include volumes on which there are no existing shapshots.

    Stores the results in the properties of the existing candidates objects list.

WARNING:

    This method will clear the diff area settings for volumes who keep no snapshots
    (but for us it doesn't matter)

Throws:

    VSS_E_PROVIDER_VETO
        - failure in FindFirstVolume/FindNextVolume, IVssEnumObject::Next
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::ComputeExistingDiffAreasCount" );

    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() != 0);

    CVssDiffArea diffobj;

    // Search between all mounted volumes
    WCHAR wszQueriedVolumeName[MAX_PATH+1];
    CVssVolumeIterator volumeIterator;
    while(true) {
    
        // Get the volume name
        if (!volumeIterator.SelectNewVolume(ft, wszQueriedVolumeName, MAX_PATH))
            break;

        BS_ASSERT( wszQueriedVolumeName[0] );

        // Make sure the volume is snaphsotted
        LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszQueriedVolumeName, VSS_CTX_ALL, NULL, FALSE);
        if ((lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED) == 0)
            continue;

        // The volume has snapshots.
        // Therefore it is impossible to have it proposed for snapshots in the current set.
        // (since the current set contains takes in consideration only volumes without snapshots)
        if (m_mapOriginalVolumes.Lookup(wszQueriedVolumeName))
        {
            BS_ASSERT(false);
            continue;
        }

        //
        // Enumerate through all snapshots
        //

        // Open a IOCTL channel on that volume
        // Eliminate the last backslash in order to open the volume
        CVssIOCTLChannel volumeIChannel;
        ft.hr = volumeIChannel.Open(ft, wszQueriedVolumeName, true, false, VSS_ICHANNEL_LOG_NONE, 0);
        if (ft.HrFailed())
            continue;

        // Get the list of snapshots
        // If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
        // supported then try with the next volume.
        ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS,
                    false, VSS_ICHANNEL_LOG_NONE);
        if (ft.HrFailed())
            continue;

        // Get the length of snapshot names multistring
        ULONG ulMultiszLen;
        volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
        DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif

        CVssAutoPWSZ awszSnapshotName;
        while(volumeIChannel.UnpackZeroString(ft, awszSnapshotName.GetRef()))
        {
            // Initialize the diff area object
            // This might fail...
            diffobj.InitializeForSnapshot(awszSnapshotName, true, true);

            // Enumerate the diff area volumes for the queried volume.
            // Increment the "diff areas" counter for the corresponding diff area volume
            diffobj.IncrementCountOnPointedDiffAreas( this );
        }

#ifdef _DEBUG
        // Check if all strings were browsed correctly
        DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
        BS_ASSERT( (dwFinalOffset - dwInitialOffset == ulMultiszLen));
#endif
    }

    // Result of computation
    for(int nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++) {
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nIndex);
        ft.Trace( VSSDBG_SWPRV, L"Number of diff areas for volume '%s' = %d",
                  pObj->GetVolumeName(), pObj->GetExistingDiffAreas() );
    }
}


void CVssDiffAreaAllocator::IncrementExistingDiffAreaCountOnVolume(
    IN  LPWSTR pwszDiffAreaVolumeName
    )

/*++

Description:

    Increment the "diff areas" counter for the corresponding diff area volume
    This routine is called for each diff area voplume for the queried volume name.

Arguments:

    pwszDiffAreaVolumeName - The diff area for the queried volume name

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::OnDiffAreaVolume");

    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pwszDiffAreaVolumeName);

    // If this volume is also a diff area candidate then increment the
    // associated counter of existing diff areas
    if (pObj)
        pObj->IncrementExistingDiffAreas();
}


void CVssDiffAreaAllocator::PlanNewDiffAreas() throw(HRESULT)
/*++

Description:

    Planning of new diff areas

Throws:

    VSS_E_INSUFFICIENT_STORAGE
        - insufficient diff area specified

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::PlanNewDiffAreas");

    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() > 0);

    // Repeat the allocation sequence for each volume to be snapshotted.
    INT nNeededBackupDiffAreas = 0;
    for(INT nVolumeIndex = 0; nVolumeIndex < m_mapOriginalVolumes.GetSize(); nVolumeIndex++)
    {
        // This is the volume to be snapshotted
        VSS_PWSZ pwszVolumeName = m_mapOriginalVolumes.GetKeyAt(nVolumeIndex);

        // If there is an assigned diff area in Registry, use that one
        CVssProviderRegInfo& regInfo = CVssDiffMgmt::GetRegInfo();
        CVssAutoPWSZ awszDiffAreaVolumeName;
        LONGLONG llMaxSize = 0;
        LONG lAssociationFlags = 0;
        if (regInfo.GetDiffAreaForVolume(pwszVolumeName, awszDiffAreaVolumeName.GetRef(), llMaxSize, lAssociationFlags))
        {
            // Check to see if the diff area found in registry is a diff area candidate also
            CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(awszDiffAreaVolumeName);
            if (pObj == NULL)
            {
                ft.Trace( VSSDBG_SWPRV, L"Invalid diff area %s specified in registry for volume %s. Using the default one",
                    awszDiffAreaVolumeName.GetRef(), pwszVolumeName);
                // The diff area volume specified in the registry does not hold enough space
                ft.Throw( VSSDBG_SWPRV,
                    VSS_E_INSUFFICIENT_STORAGE, L"The volume %s must be able to support a diff area",
                    pwszVolumeName);
            }
            else
            {
                // Increment the planned diff areas
                pObj->IncrementPlannedDiffAreas();

                // Add the corresponding diff area
                CVssDiffAreaAssociation* pAssociation = m_mapOriginalVolumes.GetValueAt(nVolumeIndex);
                BS_ASSERT(pAssociation);
                pAssociation->SetDiffArea(awszDiffAreaVolumeName, llMaxSize);

                // Continue with the next volume
                continue;
            }
        }

        // Otherwise: No diff area (or invalid diff area) specified in registry.
        // Now we have two cases: timewarp vs. backup.

        // If we are in non-backup case we will choose the same volume as the snapshotted one.
        // We are supposing that the volume is a diff area candidate also
        if (m_lContext == VSS_CTX_CLIENT_ACCESSIBLE)
        {
            // Check to see if the snapshotted volume is a diff area candidate also
            CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pwszVolumeName);
            if (pObj == NULL)
            {
                // This might happen if the volume temporarily dissapeared when m_mapDiffAreaCandidates
                // was filled. In this case this call will throw the correct error code.
                LONG lVolAttr = CVsSoftwareProvider::GetVolumeInformationFlags(pwszVolumeName, VSS_CTX_CLIENT_ACCESSIBLE);

                // If the volume is re-formatted to a different FS (none NTFS) or something like that in the
                // middle of snapshot creation, it may not be supported for Timewarp snapshot anymore (bug 504777).
                if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
                    ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_NOT_SUPPORTED, 
                        L"The timewarp volume %s [attributes = 0x%08lx] must be able to support a snapshot", 
                        pwszVolumeName, lVolAttr);

                // If the volume is re-formatted to a different FS (none NTFS) or something like that in
                // the middle of snapshot creation, it may not be supported for diff area anymore.
                // Also, if the volume is less than 100 MB it is not supported as diff area. For Timewarp
                // snapshots on such volumes, user must make an association to use a different volume as 
                // diff area before creating the Timewarp snapshot (bug 504777).
                if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
                    ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE, 
                        L"The volume %s [attributes = 0x%08lx] must be able to support a diff area", 
                        pwszVolumeName, lVolAttr);

                // The diff area volume specified in the registry does not hold enough space, or
                // an extremely rare case - the volume dissapeared when m_mapDiffAreaCandidates was filled and then reappeared again.
                ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE, 
                    L"The timewarp volume %s [0x%08lx] must be able to serve as a diff area",
                    pwszVolumeName, lVolAttr);
            }

            // Get the default max space
            llMaxSize = (LONGLONG) (pObj->GetVolumeTotalSpace() * x_nTimewarpDefaultMaxSpacePercent / 100);

            // Make sure it is at least the allocated size
            if (llMaxSize < (LONGLONG)x_nDefaultInitialSnapshotAllocation)
                llMaxSize = (LONGLONG)x_nDefaultInitialSnapshotAllocation;

            // Increment the planned diff areas
            pObj->IncrementPlannedDiffAreas();

            // Add the corresponding diff area
            CVssDiffAreaAssociation* pAssociation = m_mapOriginalVolumes.GetValueAt(nVolumeIndex);
            BS_ASSERT(pAssociation);
            pAssociation->SetDiffArea(pwszVolumeName, llMaxSize);

            // Continue with the next volume
            continue;
        }

        // The diff area for this volume must be established using the backup algorithm
        // For this volume, the assigned diff area will be still NULL.
        nNeededBackupDiffAreas++;
    }

    // We have now nNeededBackupDiffAreas volumes without a diff area assigned yet.
    // We need first to compute the sublist of diff area candidates.
    // The list will contain (nNeededBackupDiffAreas) entries
    for(INT nNeededDiffIndex = 0; nNeededDiffIndex < nNeededBackupDiffAreas; nNeededDiffIndex++)
    {
        // Find a diff area candidate that will remain with
        // maximum free space per hosted diff area
        INT nCandidateIndex = -1;
        double lfMaxFreeSpacePerHostedDiffArea = 0;
        for(int nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++)
        {
            CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nIndex);
            BS_ASSERT(pObj);

            // We try to add *another* diff area and we estimate the results.
            INT nEstimatedDiffAreas = 1 + pObj->GetPlannedDiffAreas();

            // What will be the free space if we will allocate another diff area?
            // We will ignore the allocated space for the new diff areas in order to keep
            // the algorithm simple to understand
            double lfRemainingFreeSpaceAfterAllocation = pObj->GetVolumeFreeSpace();

            // What will be the free space per hosted diff area (including estimated ones)?
            double lfFreeSpacePerHostedDiffArea =
                lfRemainingFreeSpaceAfterAllocation / (nEstimatedDiffAreas + pObj->GetExistingDiffAreas());

            // Is the current volume a better candidate?
            if (lfFreeSpacePerHostedDiffArea > lfMaxFreeSpacePerHostedDiffArea) {
                nCandidateIndex = nIndex;
                lfMaxFreeSpacePerHostedDiffArea = lfFreeSpacePerHostedDiffArea;
            }
        }

        BS_ASSERT( nCandidateIndex >= 0 );

        // We found another candidate.
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nCandidateIndex);

        // Check to see if we have enough free space per diff area
        if (lfMaxFreeSpacePerHostedDiffArea < x_nRemainingFreeSpace) {
            // Indicate to the user the requirement that it should provide more space.
            ft.LogError( VSS_ERROR_NO_DIFF_AREAS_CANDIDATES, VSSDBG_SWPRV);
            ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE,
                      L"Not enough free space (%.1f) on any diff area. Best bet: '%s - %.1f'",
                      lfMaxFreeSpacePerHostedDiffArea,
                      pObj->GetVolumeName(),
                      pObj->GetVolumeFreeSpace());
        }

        // Increment the planned diff areas
        pObj->IncrementPlannedDiffAreasForBackup();

        ft.Trace( VSSDBG_SWPRV,
            L"\r\n   New hosting candidate: '%s'. \r\n\tExisting: %d, \r\n\tplanned: %d, \r\n\tFree: (%.1f). \r\n\tRelative (%.1f)\r\n",
            pObj->GetVolumeName(),
            pObj->GetExistingDiffAreas(),
            pObj->GetPlannedDiffAreas(),
            pObj->GetVolumeFreeSpace(),
            lfMaxFreeSpacePerHostedDiffArea
            );
    }

    // For each volume to be snapshotted using hte backup algorithm,
    // check to see if we can put the diff area on the same volume
    // If yes, proceed.
    INT nRemainingDiffCount = nNeededBackupDiffAreas;
    for (int nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
    {
        // Get the diff area association object
        CVssDiffAreaAssociation* pAssoc = m_mapOriginalVolumes.GetValueAt(nIndex);
        BS_ASSERT(pAssoc);

        // If we already assigned a diff area, ignore
        if (pAssoc->IsDiffAreaAssigned())
            continue;

        // The current volume is a diff area candidate also?
        // If not we cannot reassign the diff area to itself
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pAssoc->GetOriginalVolumeName());
        if (pObj == NULL)
            continue;
        BS_ASSERT(::wcscmp(pObj->GetVolumeName(), pAssoc->GetOriginalVolumeName()) == 0);

        // We have remaining planned diff areas on the same volume?
        BS_ASSERT(pObj->GetPlannedDiffAreasForBackup() >= 0);
        if (pObj->GetPlannedDiffAreasForBackup() == 0)
            continue;

        // We reserve the planned diff area for backup.
        BS_ASSERT(pObj);
        pObj->DecrementPlannedDiffAreasForBackup();

        // We mark that volume as auto-assigned
        pAssoc->SetDiffArea(pAssoc->GetOriginalVolumeName(), VSS_ASSOC_NO_MAX_SPACE);

        // We just consumed one diff area candidate
        nRemainingDiffCount--;
    }

    // For each volume to be snapshotted using the backup algorithm,
    // and which is not a diff area candidate, assign another diff area
    int nNextCandidateIndex = 0;
    CVssDiffAreaCandidate* pCandidate = NULL;
    for (int nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
    {
        // Get the diff area association object
        CVssDiffAreaAssociation* pAssoc = m_mapOriginalVolumes.GetValueAt(nIndex);
        BS_ASSERT(pAssoc);

        // If we already assigned a diff area, ignore
        if (pAssoc->IsDiffAreaAssigned())
            continue;

        // Get the associated diff area
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pAssoc->GetOriginalVolumeName());
		if (pObj)
			BS_VERIFY(pObj->GetPlannedDiffAreasForBackup() == 0);

        // If there are no remainig diff areas on the current candidate, go and search another ones
        // Iterate through the next available diff area candidate for backup
        // Otherwise use another diff area for backup snapshot
        if ((pCandidate == NULL) || (pCandidate->GetPlannedDiffAreasForBackup() == 0))
            while(true) {
                // Premature end of cycle
                if (nNextCandidateIndex >= m_mapDiffAreaCandidates.GetSize()){
                    BS_ASSERT(false); // Programming error. Too few diff area candidates for backup.
                    ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Cannot find anymore diff area candidates for volume %s [%d]",
                        pAssoc->GetOriginalVolumeName(), nIndex);
                }
                // Next candidate?
                pCandidate = m_mapDiffAreaCandidates.GetValueAt(nNextCandidateIndex++);
                BS_ASSERT(pCandidate);
                // We found a candidate
                if (pCandidate && (pCandidate->GetPlannedDiffAreasForBackup() > 0))
                    break;
            }

        // We have remaining planned diff areas?
        BS_ASSERT(pCandidate->GetPlannedDiffAreasForBackup() >= 0);

        // We reserve the planned diff area for backup.
        pCandidate->DecrementPlannedDiffAreasForBackup();

        // We allocate the diff area
        pAssoc->SetDiffArea(pCandidate->GetVolumeName(), VSS_ASSOC_NO_MAX_SPACE);

        // We just consumed one diff area candidate
        nRemainingDiffCount--;
    }

    //
    // Safety checks
    //

    BS_ASSERT(nRemainingDiffCount == 0);

    // The rest of candidates should not be usable for backup
    while(true) {
        BS_ASSERT(!pCandidate || (pCandidate->GetPlannedDiffAreasForBackup() == 0));
        if (nNextCandidateIndex >= m_mapDiffAreaCandidates.GetSize())
            break;
        pCandidate = m_mapDiffAreaCandidates.GetValueAt(nNextCandidateIndex++);
    }

    // Check if all planned diff areas for backup were used.
    for(int nDiffIndex = 0; nDiffIndex < m_mapDiffAreaCandidates.GetSize(); nDiffIndex++) {
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nDiffIndex);
        BS_ASSERT(pObj);

        // We have remaining planned diff areas?
        if (pObj->GetPlannedDiffAreasForBackup() != 0) {
            BS_ASSERT(false);
            ft.Trace( VSSDBG_SWPRV,
                      L"FALSE ASSERT: remaining planned diff areas (%d, %d) on '%s'",
                      pObj->GetPlannedDiffAreas(), pObj->GetPlannedDiffAreasForBackup(), pObj->GetVolumeName() );
        }

        // Check if all planned diff areas are correctly assigned.
        int nVolumesServed = 0;
        for(int nVolIndex = 0; nVolIndex < m_mapOriginalVolumes.GetSize(); nVolIndex++) {
            CVssDiffAreaAssociation* pAssoc = m_mapOriginalVolumes.GetValueAt(nVolIndex);
            BS_ASSERT(pAssoc);

            if (::wcscmp(pAssoc->GetDiffAreaVolumeName(), pObj->GetVolumeName()) == 0)
                nVolumesServed++;
        }

        if (nVolumesServed != pObj->GetPlannedDiffAreas()) {
            BS_ASSERT(false);
            ft.Trace( VSSDBG_SWPRV,
                      L"FALSE ASSERT: remaining planned diff areas (%d, %d) on '%s'. Expected: %d",
                      pObj->GetPlannedDiffAreas(), pObj->GetPlannedDiffAreasForBackup(), pObj->GetVolumeName(), nVolumesServed);
        }
    }
}


// effectively allocate the diff areas for the voluems to be snapshotted
void CVssDiffAreaAllocator::AssignPlannedDiffAreas() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::AssignPlannedDiffAreas");

    CVssDiffArea diffobj;

    //
    // For each volume to be snapshotted, associate its diff area
    //

    // For each volume to be snapshotted, check to see if we can put the diff area on the same volume
    for (int nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
    {
        // Get the diff area association object
        CVssDiffAreaAssociation* pAssoc = m_mapOriginalVolumes.GetValueAt(nIndex);
        BS_ASSERT(pAssoc);

        //
        // Assign the founded diff area to the snapshotted volume
        //

        // Initialize the diff area object
        // If an error is encountered then it is already logged.
        diffobj.InitializeForVolume(pAssoc->GetOriginalVolumeName());

        // Add the volume to the diff area
        // If an error is encountered then it is already logged.
        diffobj.Clear();

        // Add the volume to the diff area
        // If an error is encountered then it is already logged.
        diffobj.AddVolume(pAssoc->GetDiffAreaVolumeName());

        // Set the maximum size
        BS_ASSERT( ( pAssoc->GetMaxSize() == VSS_ASSOC_NO_MAX_SPACE) || ( pAssoc->GetMaxSize() > 0) );
        diffobj.ChangeDiffAreaMaximumSize(pAssoc->GetMaxSize());
    }
}


void CVssDiffAreaAllocator::Rollback()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Rollback");

    BS_ASSERT(m_bChangesCommitted == false);
    BS_ASSERT(m_bNoChangesNeeded == false);

    try
    {
        CVssDiffArea diffobj;

        // For each volume to be snapshoted, rollback the diff area assignments
        for (int nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++) {
            VSS_PWSZ wszVolumeName = m_mapOriginalVolumes.GetKeyAt(nIndex);
            BS_ASSERT( wszVolumeName && wszVolumeName[0] );

            // Initialize the diff area object.
            diffobj.InitializeForVolume(wszVolumeName);

            // Clear the diff area on the queried volume.
            diffobj.Clear();
        }
    }
    VSS_STANDARD_CATCH(ft)
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaCandidate methods


CVssDiffAreaCandidate::CVssDiffAreaCandidate(
    IN  VSS_PWSZ wszVolumeName,       // Transfer ownership!
    IN  ULARGE_INTEGER ulTotalSpace,
    IN  ULARGE_INTEGER ulFreeSpace
    ):
    m_wszVolumeName(wszVolumeName),
    m_ulTotalSpace(ulTotalSpace),
    m_ulFreeSpace(ulFreeSpace),
    m_nPlannedDiffAreas(0),
    m_nPlannedDiffAreasForBackup(0),
    m_nExistingDiffAreas(0)
{
}

CVssDiffAreaCandidate::~CVssDiffAreaCandidate()
{
    ::VssFreeString(m_wszVolumeName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\prop\copy.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Copy.cxx | Implementation of VSS_OBJECT_PROP_Copy and VSS_OBJECT_PROP_Ptr classes
    @end

Author:

    Adi Oltean  [aoltean]  09/01/1999

Remarks:

	It cannot be put into a library because of ATL code.

Revision History:

    Name        Date        Comments
    aoltean     09/01/1999  Created
    aoltean     09/09/1999  dss -> vss
	aoltean		09/13/1999	Moved to inc. Renamed to copy.inl
	aoltean		09/20/1999	Adding methods for creating the snapshot, snapshot set,
							provider and volume property structures.
							Also VSS_OBJECT_PROP_Manager renamed to VSS_OBJECT_PROP_Manager.
	aoltean		09/21/1999	Renaming back VSS_OBJECT_PROP_Manager to VSS_OBJECT_PROP_Copy.
							Moving the CreateXXX into VSS_OBJECT_PROP_Ptr::InstantiateAsXXX
	aoltean		09/22/1999	Fixing VSSDBG_GEN.
	aoltean		09/24/1999	Moving into modules/prop
	aoltean		12/16/1999	Adding specialized copyXXX methods
	aoltean     03/05/2001  Adding support for management objects

--*/


/////////////////////////////////////////////////////////////////////////////
//  Needed includes

#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "copy.hxx"	

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "PRPCOPYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  VSS_OBJECT_PROP_Copy class


HRESULT VSS_OBJECT_PROP_Copy::copySnapshot(
			IN	VSS_SNAPSHOT_PROP* pObj1,
			IN	VSS_SNAPSHOT_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::copySnapshot" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
        pObj1->m_SnapshotId = pObj2->m_SnapshotId;
        pObj1->m_SnapshotSetId = pObj2->m_SnapshotSetId;
        pObj1->m_lSnapshotsCount = pObj2->m_lSnapshotsCount;
		::VssSafeDuplicateStr( ft, pObj1->m_pwszSnapshotDeviceObject, pObj2->m_pwszSnapshotDeviceObject );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszOriginalVolumeName, pObj2->m_pwszOriginalVolumeName );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszOriginatingMachine, pObj2->m_pwszOriginatingMachine );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszServiceMachine, pObj2->m_pwszServiceMachine );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszExposedName, pObj2->m_pwszExposedName );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszExposedPath, pObj2->m_pwszExposedPath );
        pObj1->m_ProviderId = pObj2->m_ProviderId;
        pObj1->m_lSnapshotAttributes = pObj2->m_lSnapshotAttributes;
        pObj1->m_tsCreationTimestamp = pObj2->m_tsCreationTimestamp;
        pObj1->m_eStatus = pObj2->m_eStatus;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_OBJECT_PROP_Copy::copyProvider(
		IN	VSS_PROVIDER_PROP* pObj1,
		IN	VSS_PROVIDER_PROP* pObj2
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::copyProvider" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
        pObj1->m_ProviderId = pObj2->m_ProviderId;
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszProviderName, pObj2->m_pwszProviderName );
        pObj1->m_eProviderType = pObj2->m_eProviderType;
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszProviderVersion, pObj2->m_pwszProviderVersion );
        pObj1->m_ProviderVersionId = pObj2->m_ProviderVersionId;
        pObj1->m_ClassId = pObj2->m_ClassId;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_OBJECT_PROP_Copy::copy(
		IN	VSS_OBJECT_PROP* pObj1,
		IN	VSS_OBJECT_PROP* pObj2
		)
{
	HRESULT hr;

    // Testing arguments
    if ((pObj1 == NULL) || (pObj2 == NULL))
        return E_INVALIDARG;

    // Zeroing the contents of the destination structure
    ::VssZeroOut(pObj1);

    // Copy the type
    pObj1->Type = pObj2->Type;

    // Effective copy
    switch(pObj2->Type)
    {
    case VSS_OBJECT_SNAPSHOT:
		hr = copySnapshot( &(pObj1->Obj.Snap), &(pObj2->Obj.Snap) );
        break;

    case VSS_OBJECT_PROVIDER:
		hr = copyProvider( &(pObj1->Obj.Prov), &(pObj2->Obj.Prov) );
        break;

    default:
		BS_ASSERT(false);
		hr = E_UNEXPECTED;
        break;
    }

    return hr;
}


void VSS_OBJECT_PROP_Copy::init(
		IN	VSS_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::init" );

    try
    {
        // Zeroing the contents of the structure
        ::VssZeroOut(pObjectProp);
    }
    VSS_STANDARD_CATCH(ft)
}


void VSS_OBJECT_PROP_Copy::destroy(
		IN	VSS_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::destroy" );

    try
    {
        if (pObjectProp)
        {
            switch(pObjectProp->Type)
            {
            case VSS_OBJECT_SNAPSHOT:
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszOriginalVolumeName);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszSnapshotDeviceObject);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszOriginatingMachine);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszServiceMachine);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszExposedName);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszExposedPath);
                break;

            case VSS_OBJECT_PROVIDER:
                ::VssFreeString(pObjectProp->Obj.Prov.m_pwszProviderName);
                ::VssFreeString(pObjectProp->Obj.Prov.m_pwszProviderVersion);
                break;

            default:
                break;
            }
            pObjectProp->Type = VSS_OBJECT_UNKNOWN;
        }
    }
    VSS_STANDARD_CATCH(ft)
}


/////////////////////////////////////////////////////////////////////////////
//  VSS_MGMT_OBJECT_PROP_Copy class


HRESULT VSS_MGMT_OBJECT_PROP_Copy::copyVolume(
			IN	VSS_VOLUME_PROP* pObj1,
			IN	VSS_VOLUME_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::copyVolume" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeName, pObj2->m_pwszVolumeName);
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeDisplayName, pObj2->m_pwszVolumeDisplayName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_MGMT_OBJECT_PROP_Copy::copyDiffVolume(
			IN	VSS_DIFF_VOLUME_PROP* pObj1,
			IN	VSS_DIFF_VOLUME_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::copyDiffVolume" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeName, pObj2->m_pwszVolumeName);
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeDisplayName, pObj2->m_pwszVolumeDisplayName);
        pObj1->m_llVolumeFreeSpace = pObj2->m_llVolumeFreeSpace;
        pObj1->m_llVolumeTotalSpace = pObj2->m_llVolumeTotalSpace;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_MGMT_OBJECT_PROP_Copy::copyDiffArea(
			IN	VSS_DIFF_AREA_PROP* pObj1,
			IN	VSS_DIFF_AREA_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::copyDiffArea" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeName, pObj2->m_pwszVolumeName);
		::VssSafeDuplicateStr( ft, pObj1->m_pwszDiffAreaVolumeName, pObj2->m_pwszDiffAreaVolumeName);
        pObj1->m_llMaximumDiffSpace = pObj2->m_llMaximumDiffSpace;
        pObj1->m_llAllocatedDiffSpace = pObj2->m_llAllocatedDiffSpace;
        pObj1->m_llUsedDiffSpace = pObj2->m_llUsedDiffSpace;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_MGMT_OBJECT_PROP_Copy::copy(
		IN	VSS_MGMT_OBJECT_PROP* pObj1,
		IN	VSS_MGMT_OBJECT_PROP* pObj2
		)
{
	HRESULT hr;

    // Testing arguments
    if ((pObj1 == NULL) || (pObj2 == NULL))
        return E_INVALIDARG;

    // Zeroing the contents of the destination structure
    ::VssZeroOut(pObj1);

    // Copy the type
    pObj1->Type = pObj2->Type;

    // Effective copy
    switch(pObj2->Type)
    {
    case VSS_MGMT_OBJECT_VOLUME:
		hr = copyVolume( &(pObj1->Obj.Vol), &(pObj2->Obj.Vol) );
        break;

    case VSS_MGMT_OBJECT_DIFF_VOLUME:
		hr = copyDiffVolume( &(pObj1->Obj.DiffVol), &(pObj2->Obj.DiffVol) );
        break;

    case VSS_MGMT_OBJECT_DIFF_AREA:
		hr = copyDiffArea( &(pObj1->Obj.DiffArea), &(pObj2->Obj.DiffArea) );
        break;

    default:
		BS_ASSERT(false);
		hr = E_UNEXPECTED;
        break;
    }

    return hr;
}


void VSS_MGMT_OBJECT_PROP_Copy::init(
		IN	VSS_MGMT_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::init" );

    try
    {
        // Zeroing the contents of the structure
        ::VssZeroOut(pObjectProp);
    }
    VSS_STANDARD_CATCH(ft)
}


void VSS_MGMT_OBJECT_PROP_Copy::destroy(
		IN	VSS_MGMT_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::destroy" );

    try
    {
        if (pObjectProp)
        {
            switch(pObjectProp->Type)
            {
            case VSS_MGMT_OBJECT_VOLUME:
                ::VssFreeString(pObjectProp->Obj.Vol.m_pwszVolumeName);
                ::VssFreeString(pObjectProp->Obj.Vol.m_pwszVolumeDisplayName);
                break;

            case VSS_MGMT_OBJECT_DIFF_VOLUME:
                ::VssFreeString(pObjectProp->Obj.DiffVol.m_pwszVolumeName);
                ::VssFreeString(pObjectProp->Obj.DiffVol.m_pwszVolumeDisplayName);
                break;

            case VSS_MGMT_OBJECT_DIFF_AREA:
                ::VssFreeString(pObjectProp->Obj.DiffArea.m_pwszVolumeName);
                ::VssFreeString(pObjectProp->Obj.DiffArea.m_pwszDiffAreaVolumeName);
                break;

            default:
                break;
            }
            pObjectProp->Type = VSS_MGMT_OBJECT_UNKNOWN;
        }
    }
    VSS_STANDARD_CATCH(ft)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\diffmgmt.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module DiffMgmt.cxx | Implementation of IVssDifferentialSoftwareSnapshotMgmt
    @end

Author:

    Adi Oltean  [aoltean]  03/12/2001

Revision History:

    Name        Date        Comments
    aoltean     03/12/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include <mstask.h>
#include <clusapi.h>
#include <msclus.h>

#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "swprv.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_sec.hxx"
#include "vs_reg.hxx"
#include "vs_clus.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diffreg.hxx"
#include "diffmgmt.hxx"
#include "diff.hxx"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDIFMC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffMgmt


/////////////////////////////////////////////////////////////////////////////
// Static members

CVssProviderRegInfo     CVssDiffMgmt::m_regInfo;


/////////////////////////////////////////////////////////////////////////////
// Methods


STDMETHODIMP CVssDiffMgmt::AddDiffArea(							
	IN  	VSS_PWSZ 	pwszVolumeName,
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,
    IN      LONGLONG    llMaximumDiffSpace
	)												
/*++

Routine description:

    Adds a diff area association for a certain volume.
    If the association is not supported, an error code will be returned.

    Both volumes must be Fixed, NTFS and read-write.

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument or volume not found
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_ALTEADY_EXISTS
        - The association already exists in registry
        - the volume is in use and the association cannot be added.
    VSS_E_VOLUME_NOT_SUPPORTED
        - One of the given volumes is not supported.
    E_UNEXPECTED
        - Unexpected runtime error. An error log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::AddDiffArea" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  pwszDiffAreaVolumeName = %s\n"
             L"  llMaximumDiffSpace = %I64d\n",
             pwszVolumeName,
             pwszDiffAreaVolumeName,
             llMaximumDiffSpace);

        // Argument validation
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszVolumeName");
        if (pwszDiffAreaVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszDiffAreaVolumeName");
        if ( (( llMaximumDiffSpace < 0) && ( llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE))
           || ( llMaximumDiffSpace == VSS_ASSOC_REMOVE) )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid llMaximumDiffSpace");

        if (( llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE) && 
            (llMaximumDiffSpace < (LONGLONG)x_nDefaultInitialSnapshotAllocation))
            ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE, L"Not enough storage for the initial diff area allocation");
            
        // Calculate the internal volume name
    	WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
        GetVolumeNameWithCheck(VSSDBG_SWPRV, E_INVALIDARG,
            pwszVolumeName, 
            wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal));

        // Calculate the internal diff area volume name
    	WCHAR wszDiffAreaVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
        GetVolumeNameWithCheck(VSSDBG_SWPRV, E_INVALIDARG,
            pwszDiffAreaVolumeName,
   			wszDiffAreaVolumeNameInternal, ARRAY_LEN(wszDiffAreaVolumeNameInternal));

        // Checking if the proposed association is valid and the original volume is not in use
        LONG lAssociationFlags = GetAssociationFlags(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal);
        ft.Trace(VSSDBG_SWPRV, L"An association is proposed: %s - %s with flags 0x%08lx",
            pwszVolumeName, wszDiffAreaVolumeNameInternal, lAssociationFlags);
        if (lAssociationFlags & VSS_DAT_INVALID)
    		ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_NOT_SUPPORTED, L"Unsupported volume(s)");
        if (lAssociationFlags & VSS_DAT_ASSOCIATION_IN_USE)
    		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_ALREADY_EXISTS, L"Association already exists");
        if (lAssociationFlags & VSS_DAT_SNAP_VOLUME_IN_USE)
    		ft.Throw( VSSDBG_SWPRV, VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED, L"Original volume has snapshots on it");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Get the previous diff area association, if any.
        // If is invalid, remove it and continue with establishing a new association. If is valid, then stop here.
        CVssAutoPWSZ awszPreviousDiffAreaVolume;
        LONGLONG llPreviousMaxSpace = 0;
        LONG lPreviousAssociationFlags = 0;
        if (m_regInfo.GetDiffAreaForVolume(wszVolumeNameInternal, awszPreviousDiffAreaVolume.GetRef(), 
                llPreviousMaxSpace, lPreviousAssociationFlags))
        {
            // Throw an error
            if (::wcscmp(awszPreviousDiffAreaVolume.GetRef(), wszDiffAreaVolumeNameInternal) == 0)
        		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_ALREADY_EXISTS, L"Association already exists (and is valid)");
            else
        		ft.Throw( VSSDBG_SWPRV, VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED, L"Another association defined");
        }

        // If the previous association still exists but is invalid, delete it.
        if (lPreviousAssociationFlags & VSS_DAT_INVALID)
            m_regInfo.RemoveDiffArea(wszVolumeNameInternal, awszPreviousDiffAreaVolume);

        // There is no diff area. Add the diff area association into the registry
        m_regInfo.AddDiffArea(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal, llMaximumDiffSpace);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


 STDMETHODIMP CVssDiffMgmt::ChangeDiffAreaMaximumSize(							
	IN  	VSS_PWSZ 	pwszVolumeName,
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,
    IN      LONGLONG    llMaximumDiffSpace
	)												
/*++

Routine description:

    Updates the diff area max size for a certain volume.
    This may not have an immediate effect

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument or volume not found
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - The association does not exists
    VSS_E_VOLUME_IN_USE
        - the volume is in use and the association cannot be deleted.
    E_UNEXPECTED
        - Unexpected runtime error. An error log entry is added.
    VSS_E_INSUFFICIENT_STORAGE
        - Insufficient storage for the diff area.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::ChangeDiffAreaMaximumSize" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  pwszDiffAreaVolumeName = %s\n"
             L"  llMaximumDiffSpace = %I64d\n",
             pwszVolumeName,
             pwszDiffAreaVolumeName,
             llMaximumDiffSpace);

        // Argument validation
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszVolumeName");
        if (pwszDiffAreaVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszDiffAreaVolumeName");
        if ( ( llMaximumDiffSpace < 0) && ( llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE) )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid llMaximumDiffSpace");

        if (( llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE) && 
            ( llMaximumDiffSpace != VSS_ASSOC_REMOVE) && 
            (llMaximumDiffSpace < (LONGLONG)x_nDefaultInitialSnapshotAllocation))
            ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE, L"Not enough storage for the initial diff area allocation");
            
        // Calculate the internal volume name
    	WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
        GetVolumeNameWithCheck(VSSDBG_SWPRV, E_INVALIDARG,
            pwszVolumeName,
   			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal));

        // Calculate the internal diff area volume name
    	WCHAR wszDiffAreaVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
        GetVolumeNameWithCheck(VSSDBG_SWPRV, E_INVALIDARG,
            pwszDiffAreaVolumeName,
   			wszDiffAreaVolumeNameInternal, ARRAY_LEN(wszDiffAreaVolumeNameInternal));

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Checking if the association is valid.
        LONG lAssociationFlags = GetAssociationFlags(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal);
        ft.Trace(VSSDBG_SWPRV, L"An association is changing: %s - %s with flags 0x%08lx",
            wszVolumeNameInternal, wszDiffAreaVolumeNameInternal, lAssociationFlags);
        if (lAssociationFlags & VSS_DAT_INVALID)
    		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Unsupported volume(s)");

        // Check if the association is present in registry
        bool bPresentInRegistry = m_regInfo.IsAssociationPresentInRegistry(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal);

        // If the association is in use
        if (lAssociationFlags & VSS_DAT_ASSOCIATION_IN_USE)
        {
            // If we need to remove the association and it is in use, return an error
            // Otherwise, change the max diff space on disk
            if (llMaximumDiffSpace == VSS_ASSOC_REMOVE)
        		ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_IN_USE, L"The association is in use");
            else
            {
                CVssDiffArea diffobj;
                diffobj.InitializeForVolume(wszVolumeNameInternal);
                diffobj.ChangeDiffAreaMaximumSize(llMaximumDiffSpace);
            }
        }
        else
        {
            if (!bPresentInRegistry)
        		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Association not found");
            if (lAssociationFlags & VSS_DAT_SNAP_VOLUME_IN_USE)
        		ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_IN_USE, L"The original volume is in use");
        }

        // If the association is present on the registry
        if (bPresentInRegistry)
        {
            // If llMaximumDiffSpace is zero, then remove the diff area association from registry
            // Else change the diff area size in registry
            if (llMaximumDiffSpace == VSS_ASSOC_REMOVE)
                m_regInfo.RemoveDiffArea(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal);
            else
                m_regInfo.ChangeDiffAreaMaximumSize(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal, llMaximumDiffSpace);
        }

    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


//
//  Queries
//

STDMETHODIMP CVssDiffMgmt::QueryVolumesSupportedForDiffAreas(
	IN  	VSS_PWSZ 	pwszOriginalVolumeName,
	OUT  	IVssEnumMgmtObject **ppEnum
	)												
/*++

Routine description:

    Query volumes that support diff areas (including the disabled ones)

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::QueryVolumesSupportedForDiffAreas" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszOriginalVolumeName = %s\n"
             L"  ppEnum = %p\n",
             pwszOriginalVolumeName,
             ppEnum);

		BS_ASSERT(ppEnum)
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");
		
        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		CVssClusterAPI clus;
		bool bClusterPresent = false;
		CComPtr<ISClusResource> pOriginalVolResource;

        // Calculate the internal volume name, if we passed a non-NULL parameter
    	WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
        wszVolumeNameInternal[0] = L'\0';

        // Deal with cluster presence only if we specify a snapshotted volume
        // If the snapshotted volume is NULL, then return all volumes that can 
        // be diff areas. Note that in reality some volumes may not be used as diff areas
        // for a snaphsotted volume (in the cluster presence)
        if (pwszOriginalVolumeName)
        {
            GetVolumeNameWithCheck(VSSDBG_SWPRV, E_INVALIDARG,
                pwszOriginalVolumeName, 
                wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal));

            bClusterPresent = clus.Initialize();
        }

        if (bClusterPresent) {
            // Get the group for thse original volume. 
            // This group might be NULL for volumes not managed by the cluster
            pOriginalVolResource.Attach(
                clus.GetPhysicalDiskResourceForVolumeName(wszVolumeNameInternal) );
        }

		WCHAR wszVolumeName[MAX_PATH+1];
    	CVssVolumeIterator volumeIterator;
		while(true) {

    		// Get the volume name
    		if (!volumeIterator.SelectNewVolume(ft, wszVolumeName, MAX_PATH))
    		    break;

            //
            //  Verify if the volume is supported for diff area
            //

            // Checking if the volume is Fixed, NTFS and read-write.
            LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszVolumeName, VSS_CTX_CLIENT_ACCESSIBLE, NULL, FALSE );
            if ( (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
                continue;

            //
            //  Check if the volume belongs to the same group as the origina volume (if needed)
            //
            if (bClusterPresent)
            {
                // Calculate the real volume name for the iterated volume (it might have a different GUID)
                WCHAR wszIteratedVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
                GetVolumeNameWithCheck(VSSDBG_SWPRV, E_UNEXPECTED,
                    wszVolumeName, 
                    wszIteratedVolumeNameInternal, ARRAY_LEN(wszIteratedVolumeNameInternal));

                //  Skip the cluster check if the volumes are identical
                if (wcscmp(wszVolumeNameInternal, wszIteratedVolumeNameInternal) != 0)
                {
                    CComPtr<ISClusResource> pResource = clus.GetPhysicalDiskResourceForVolumeName(wszVolumeName);

                    // Volumes are compatible if either:
                    // - they both belong to the same group, or 
                    // - none of them is belonging to a group
                    
                    if ((pOriginalVolResource == NULL) && (pResource != NULL))
                        continue;
                    if ((pOriginalVolResource != NULL) && (pResource == NULL))
                        continue;

                    // If the volumes belong to the same Physical Disk resource then we cannot setup 
                    // a proper order for online/offline (bug# 660296)
                    if ((pOriginalVolResource != NULL) 
                        && (pResource != NULL)
                        && clus.AreResourcesEqual(pOriginalVolResource, pResource))
                        continue;

                    // If volumes belong to different Physical Disk resources, then these resources 
                    // must be in the same group and we should be able to setup a dependency 
                    // (if the dependency doesn't exist already)
                    if ( ((pOriginalVolResource != NULL) && (pResource != NULL))
                        && !clus.IsDependencyAlreadyEstablished(pOriginalVolResource, pResource)
                        && !clus.CanEstablishDependency(pOriginalVolResource, pResource) )
                        continue;
                }
            }

            //
            //  Calculate the volume display name
            //

            WCHAR wszVolumeDisplayName[MAX_PATH];
            VssGetVolumeDisplayName( wszVolumeName, wszVolumeDisplayName, MAX_PATH);

            //
            //  Calculate the free space
            //
            ULARGE_INTEGER ulnFreeBytesAvailable;
            ULARGE_INTEGER ulnTotalNumberOfBytes;
            ULARGE_INTEGER ulnTotalNumberOfFreeBytes;
            if (!::GetDiskFreeSpaceEx(wszVolumeName,
                    &ulnFreeBytesAvailable,
                    &ulnTotalNumberOfBytes,
                    &ulnTotalNumberOfFreeBytes
                    )){
                ft.Trace( VSSDBG_SWPRV, L"Cannot get the free space for volume (%s) - [0x%08lx]",
                          wszVolumeName, GetLastError());
                continue;
            }

            // We should not have any quotas for the Local SYSTEM account
            BS_ASSERT( ulnFreeBytesAvailable.QuadPart == ulnTotalNumberOfFreeBytes.QuadPart );

            // 
            //  Add the supported volume to the list
            //

			// Initialize an empty snapshot properties structure
			VSS_MGMT_OBJECT_PROP_Ptr ptrVolumeProp;
			ptrVolumeProp.InitializeAsDiffVolume( ft,
				wszVolumeName,
				wszVolumeDisplayName,
				ulnFreeBytesAvailable.QuadPart,
				ulnTotalNumberOfBytes.QuadPart
				);

			if (!pArray->Add(ptrVolumeProp))
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"Cannot add element to the array");

			// Reset the current pointer to NULL
			ptrVolumeProp.Reset(); // The internal pointer was detached into pArray.

		}

        // Create the enumerator object. 
		ft.hr = VssBuildEnumInterface<CVssMgmtEnumFromArray>( VSSDBG_SWPRV, pArray, ppEnum );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssDiffMgmt::QueryDiffAreasForVolume(
	IN  	VSS_PWSZ 	pwszVolumeName,
	OUT  	IVssEnumMgmtObject **ppEnum
	)												
/*++

Routine description:

    Query diff areas that host snapshots for the given (snapshotted) volume

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::QueryDiffAreasForVolume" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  ppEnum = %p\n",
             pwszVolumeName? pwszVolumeName: L"NULL",
             ppEnum);

        // Argument validation
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszVolumeName");

        // Calculate the internal volume name
    	WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
        GetVolumeNameWithCheck(VSSDBG_SWPRV, E_INVALIDARG,
            pwszVolumeName,
   			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal));

        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        CVssAutoPWSZ awszLastSnapshotName;
        LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszVolumeNameInternal, 
                                VSS_CTX_ALL, &awszLastSnapshotName);
        if ((lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
    		ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
				  L"Volume not supported for snapshots", pwszVolumeName, GetLastError());

        // If the volume is in use, get the corresponding association
        // Otherwise, If the association is only in registry, get it
        if (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED)
        {
            // Get the diff area for the "in use" volume
            CVssAutoPWSZ awszDiffAreaVolumeInUse;
            CVssDiffArea diffobj;
            BS_ASSERT(awszLastSnapshotName.GetRef());
            diffobj.InitializeForSnapshot(awszLastSnapshotName, true, true);
            diffobj.GetDiffArea(awszDiffAreaVolumeInUse);

            // Get the diff area sizes
            diffobj.InitializeForVolume(wszVolumeNameInternal, true);
            LONGLONG llUsedSpace = 0;
            LONGLONG llAllocatedSpace = 0;
            LONGLONG llMaxSpace = 0;
            diffobj.GetDiffAreaSizes(llUsedSpace, llAllocatedSpace, llMaxSpace);

#ifdef _DEBUG
            // Verify that the registry information is correct
            LONGLONG llMaxSpaceInRegistry = 0;
            LONG lAssociationFlags = 0;
            CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
            if (m_regInfo.GetDiffAreaForVolume(wszVolumeNameInternal, awszDiffAreaVolumeInRegistry.GetRef(), 
                    llMaxSpaceInRegistry, lAssociationFlags))
            {
                BS_ASSERT(::wcscmp(awszDiffAreaVolumeInUse, awszDiffAreaVolumeInRegistry) == 0);
                BS_ASSERT(llMaxSpace == llMaxSpaceInRegistry);
                BS_ASSERT((lAssociationFlags & VSS_DAT_INVALID) == 0);
            }
#endif // _DEBUG

            // Initialize an new structure for the association
      		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
    		ptrDiffAreaProp.InitializeAsDiffArea( ft,
    			wszVolumeNameInternal,
    			awszDiffAreaVolumeInUse,
    			llUsedSpace,
    			llAllocatedSpace,
    			llMaxSpace);

            //  Add the association to the list
    		if (!pArray->Add(ptrDiffAreaProp))
    			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

    		// Reset the current pointer to NULL
    		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.
        }
        else
        {
            LONGLONG llMaxSpaceInRegistry = 0;
            LONG lAssociationFlags = 0;
            CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
            if (m_regInfo.GetDiffAreaForVolume(wszVolumeNameInternal, awszDiffAreaVolumeInRegistry.GetRef(), 
                    llMaxSpaceInRegistry, lAssociationFlags))
            {
                // Initialize a new structure for the association
          		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
        		ptrDiffAreaProp.InitializeAsDiffArea( ft,
        			wszVolumeNameInternal,
        			awszDiffAreaVolumeInRegistry,
        			0,
        			0,
        			llMaxSpaceInRegistry);

                //  Add the association to the list
        		if (!pArray->Add(ptrDiffAreaProp))
        			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

        		// Reset the current pointer to NULL
        		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.
            }
        }

        // Create the enumerator object. 
		ft.hr = VssBuildEnumInterface<CVssMgmtEnumFromArray>( VSSDBG_SWPRV, pArray, ppEnum );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVssDiffMgmt::QueryDiffAreasOnVolume(
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,
	OUT  	IVssEnumMgmtObject **ppEnum
	)												
/*++

Routine description:

    Query diff areas that host snapshots on the given (snapshotted) volume

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::QueryDiffAreasOnVolume" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszDiffAreaVolumeName = %s\n"
             L"  ppEnum = %p\n",
             pwszDiffAreaVolumeName? pwszDiffAreaVolumeName: L"NULL",
             ppEnum);

        // Argument validation
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");
        bool bFilterByDiffAreaVolumeName = (pwszDiffAreaVolumeName != NULL);

        // Calculate the internal diff area volume name
    	WCHAR wszDiffAreaVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
   	    wszDiffAreaVolumeNameInternal[0] = L'\0';
    	if (bFilterByDiffAreaVolumeName)
            GetVolumeNameWithCheck(VSSDBG_SWPRV, E_INVALIDARG,
                pwszDiffAreaVolumeName,
       			wszDiffAreaVolumeNameInternal, ARRAY_LEN(wszDiffAreaVolumeNameInternal));

        // Checking if the volume is Fixed, NTFS and read-write.
        LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszDiffAreaVolumeNameInternal, VSS_CTX_ALL );
        if ( (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
    	    ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Volume not supported for diff area" );

        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Enumerate through all volumes that may be snapshotted
        //

		WCHAR wszVolumeName[MAX_PATH+1];
    	CVssVolumeIterator volumeIterator;
		while(true) {

    		// Get the volume name
    		if (!volumeIterator.SelectNewVolume(ft, wszVolumeName, MAX_PATH))
    		    break;

            //
            //  Verify if the volume is supported for diff area
            //

            // Checking if the volume is Fixed, NTFS and read-write.
            CVssAutoPWSZ awszLastSnapshotName;
            LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszVolumeName, 
                                    VSS_CTX_ALL, &awszLastSnapshotName, FALSE );
            if ( (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
            {
                ft.Trace(VSSDBG_SWPRV, L"Volume %s is not supported for snapshot", wszVolumeName);
                continue;
            }

            // If the volume is in use, get the corresponding association
            // Otherwise, If the association is only in registry, get it
            if (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED)
            {
                // Get the diff area for the "in use" volume
                CVssAutoPWSZ awszDiffAreaVolumeInUse;
                CVssDiffArea diffobj;
                BS_ASSERT(awszLastSnapshotName.GetRef());
                diffobj.InitializeForSnapshot(awszLastSnapshotName, true, true);
                diffobj.GetDiffArea(awszDiffAreaVolumeInUse);

                // If this is not our diff area, then go to the next volume
                if (::wcscmp(wszDiffAreaVolumeNameInternal, awszDiffAreaVolumeInUse))
                {
                    ft.Trace(VSSDBG_SWPRV, L"In Use association %s - %s is ignored",
                        wszDiffAreaVolumeNameInternal, awszDiffAreaVolumeInUse);
                    continue;
                }

                // Get the diff area sizes from disk
                diffobj.InitializeForVolume(wszVolumeName, true);
                LONGLONG llUsedSpace = 0;
                LONGLONG llAllocatedSpace = 0;
                LONGLONG llMaxSpace = 0;
                diffobj.GetDiffAreaSizes(llUsedSpace, llAllocatedSpace, llMaxSpace);

#ifdef _DEBUG
                // Verify that the registry information is correct
                LONGLONG llMaxSpaceInRegistry = 0;
                LONG lAssociationFlags = 0;
                CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
                if (m_regInfo.GetDiffAreaForVolume(wszVolumeName, awszDiffAreaVolumeInRegistry.GetRef(), 
                        llMaxSpaceInRegistry, lAssociationFlags))
                {
                    BS_ASSERT(::wcscmp(awszDiffAreaVolumeInUse, awszDiffAreaVolumeInRegistry) == 0);
                    BS_ASSERT(llMaxSpace == llMaxSpaceInRegistry);
                }
#endif // _DEBUG

                // Initialize an new structure for the association
          		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
        		ptrDiffAreaProp.InitializeAsDiffArea( ft,
        			wszVolumeName,
        			awszDiffAreaVolumeInUse,
        			llUsedSpace,
        			llAllocatedSpace,
        			llMaxSpace);

                //  Add the association to the list
        		if (!pArray->Add(ptrDiffAreaProp))
        			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

        		// Reset the current pointer to NULL
        		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.
            }
            else
            {
                LONGLONG llMaxSpaceInRegistry = 0;
                LONG lAssociationFlags = 0;
                CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
                if (m_regInfo.GetDiffAreaForVolume(wszVolumeName, awszDiffAreaVolumeInRegistry.GetRef(), 
                        llMaxSpaceInRegistry, lAssociationFlags))
                {
                    // If this is not our diff area, then go to the next volume
                    if (::wcscmp(wszDiffAreaVolumeNameInternal, awszDiffAreaVolumeInRegistry)) {
                        ft.Trace(VSSDBG_SWPRV, L"Registered association %s - %s is ignored",
                            wszDiffAreaVolumeNameInternal, awszDiffAreaVolumeInRegistry);
                        continue;
                    }

                    // Initialize a new structure for the association
              		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
            		ptrDiffAreaProp.InitializeAsDiffArea( ft,
            			wszVolumeName,
            			awszDiffAreaVolumeInRegistry,
            			0,
            			0,
            			llMaxSpaceInRegistry);

                    //  Add the association to the list
            		if (!pArray->Add(ptrDiffAreaProp))
            			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

            		// Reset the current pointer to NULL
            		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.
                }
            }
        }

        // Create the enumerator object. 
		ft.hr = VssBuildEnumInterface<CVssMgmtEnumFromArray>( VSSDBG_SWPRV, pArray, ppEnum );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssDiffMgmt::QueryDiffAreasForSnapshot(
    IN      VSS_ID      SnapshotId,     
	OUT  	IVssEnumMgmtObject **ppEnum
	)												
/*++

Routine description:

    Query diff areas that host snapshots for the given (snapshotted) volume

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - lock failures.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::QueryDiffAreasForSnapshot" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  SnapshotId = "WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             GUID_PRINTF_ARG(SnapshotId),
             ppEnum);

        // Argument validation
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		// Try to find a created snapshot with this ID
		CVssAutoPWSZ awszSnapshotDeviceObject;
		bool bFound = CVssQueuedSnapshot::FindPersistedSnapshotByID(
		    SnapshotId, VSS_CTX_ALL, &(awszSnapshotDeviceObject.GetRef()));
		if (!bFound)
            ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
                L"Snapshot not found");

        // Open the snapshot. There is no trailing backslash to eliminate.
        // It will throw on error and log it.
        CVssIOCTLChannel snapIChannel;
		snapIChannel.Open(ft, awszSnapshotDeviceObject, false, true, VSS_ICHANNEL_LOG_PROV);

    	// Get the original volume name
		CVssAutoPWSZ awszOriginalVolumeName;
    	CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl( snapIChannel, &(awszOriginalVolumeName.GetRef()));

        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Get the diff area for the "in use" volume
        CVssAutoPWSZ awszDiffAreaVolumeInUse;
        CVssDiffArea diffobj;
        diffobj.InitializeForSnapshot(awszSnapshotDeviceObject, false, true); // do not prepend GLOBALROOT
        diffobj.GetDiffArea(awszDiffAreaVolumeInUse);

        // Get the diff area sizes
        diffobj.InitializeForVolume(awszOriginalVolumeName, true);
        LONGLONG llUsedSpace = 0;
        LONGLONG llAllocatedSpace = 0;
        LONGLONG llMaxSpace = 0;
        diffobj.GetDiffAreaSizes(llUsedSpace, llAllocatedSpace, llMaxSpace);
        
        // Initialize an new structure for the association
  		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
		ptrDiffAreaProp.InitializeAsDiffArea( ft,
			awszOriginalVolumeName,
			awszDiffAreaVolumeInUse,
			llUsedSpace,
			llAllocatedSpace,
			llMaxSpace);

        //  Add the association to the list
		if (!pArray->Add(ptrDiffAreaProp))
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

		// Reset the current pointer to NULL
		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssMgmtEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssMgmtEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumMgmtObject, ppEnum);
        if ( ft.HrFailed() ) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Life management


HRESULT CVssDiffMgmt::CreateInstance(
    OUT		IUnknown** ppItf,
    IN 		const IID iid /* = IID_IVssDifferentialSoftwareSnapshotMgmt */
    )
/*++

Routine description:

    Creates an instance of the CVssDiffMgmt to be returned as IVssDifferentialSoftwareSnapshotMgmt

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Dev error. No logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::CreateInstance" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr(ppItf);
        BS_ASSERT(ppItf);

        // Allocate the COM object.
        CComObject<CVssDiffMgmt>* pObject;
        ft.hr = CComObject<CVssDiffMgmt>::CreateInstance(&pObject);
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Error creating the CVssDiffMgmt instance. hr = 0x%08lx", ft.hr);
        BS_ASSERT(pObject);

        // Querying the IVssSnapshot interface
        CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
        BS_ASSERT(pUnknown);
        ft.hr = pUnknown->QueryInterface(iid, reinterpret_cast<void**>(ppItf) );
        if ( ft.HrFailed() ) {
            BS_ASSERT(false); // Dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error querying the interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppItf);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods


LONG CVssDiffMgmt::GetAssociationFlags(
		IN  	VSS_PWSZ 	pwszVolumeName,
		IN  	VSS_PWSZ 	pwszDiffAreaVolumeName
        ) throw(HRESULT)
/*++

Routine description:

    Get the association flags for the given volumes.

Throw error codes:

    E_OUTOFMEMORY
        - lock failures.
    E_UNEXPECTED
        - Unexpected runtime error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::GetAssociationFlags" );

    LONG lAssociationFlags = 0;

    // Note: (Bug 500079)
    //  This method is changed to call GetVolumeInformationFlags without throwing.
    //  As a result, GetAssociationFlags will return VSS_DAT_INVALID instead of throwing
    //  an error, which is a better behavior for the callers
    

    // Checking if the volume is good for snapshots and if it has snapshots.
    CVssAutoPWSZ awszLastSnapshotName;
    LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( pwszVolumeName, 
                                VSS_CTX_ALL, &awszLastSnapshotName, FALSE);
    if ((lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
        lAssociationFlags |= VSS_DAT_INVALID;
    else if (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED)
        lAssociationFlags |= VSS_DAT_SNAP_VOLUME_IN_USE;

    // Checking if the diff volume is good for keeping a diff area.
    LONG lDiffVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( pwszDiffAreaVolumeName, 
                                VSS_CTX_ALL, NULL, FALSE);
    if ((lDiffVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
        lAssociationFlags |= VSS_DAT_INVALID;

    //
    // Check if the current association is in use
    //

    if (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED)
    {
        // Get the diff area from the original volume.
        CVssAutoPWSZ awszCurrentDiffArea;
        CVssDiffArea diffobj;
        diffobj.InitializeForSnapshot(awszLastSnapshotName, true, true); 
        diffobj.GetDiffArea(awszCurrentDiffArea);

        // If the used diff area volume is the same as the one passed as parameter
        if (::wcscmp(awszCurrentDiffArea, pwszDiffAreaVolumeName) == 0)
        {
            // An invalid association cannot be in use
            BS_ASSERT((lAssociationFlags & VSS_DAT_INVALID) == 0);
            lAssociationFlags |= VSS_DAT_ASSOCIATION_IN_USE;
        }
    }

    return lAssociationFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\diff.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Diff.cxx | Diff area object implementation
    @end

Author:

    Adi Oltean  [aoltean]   01/24/2000

Revision History:

    Name        Date        Comments

    aoltean     01/24/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"
#include "alloc.hxx"
#include "qsnap.hxx"
#include "diffmgmt.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDIFFC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Operations


CVssDiffArea::CVssDiffArea():
    m_bInitializedForQuery(false)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssDiffArea::CVssDiffArea" );
}


CVssDiffArea::~CVssDiffArea()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssDiffArea::~CVssDiffArea" );
}


void CVssDiffArea::InitializeForVolume(
    IN      LPCWSTR pwszVolumeMountPoint,   // DO NOT transfer ownership
    IN      bool    bInitializeForQuery /* = false */
    ) throw(HRESULT)
/*++

Routine description:

    Initialize the internal structure for a new diff area.

Parameters:

    Volume mount point (with trailing backslash).

Throws:

    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW
        - Error in opening the IOCTL channel
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::InitializeForVolume" );

    // Test the arguments
    if ((pwszVolumeMountPoint == NULL) ||
        (pwszVolumeMountPoint[0] == L'\0')) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"NULL volume mount point");
    }

    // Convert the volume mount point into a volume name
    WCHAR wszVolumeName[MAX_PATH];
    if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
            wszVolumeName, ARRAY_LEN(wszVolumeName)))
        ft.TranslateInternalProviderError( VSSDBG_SWPRV,
            HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
            L"GetVolumeNameForVolumeMountPointW( %s, ...)", pwszVolumeMountPoint);
    BS_ASSERT(::wcslen(wszVolumeName) != 0);

    // Opening the channel
    // (if already opened then it will be closed automatically)
    // Eliminate the last backslash from the volume name.
    // The call will throw on error
    // Warning: Always do the logging
    m_objectIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV,
        bInitializeForQuery? 0: GENERIC_READ | GENERIC_WRITE);
    m_bInitializedForQuery = bInitializeForQuery;
}


void CVssDiffArea::InitializeForSnapshot(
    IN      LPCWSTR pwszSnapshotName,   // DO NOT transfer ownership
    IN      bool    bPrependGlobalRoot, /* = false */
    IN      bool    bInitializeForQuery /* = false */
    ) throw(HRESULT)
/*++

Routine description:

    Initialize the internal structure for a new diff area.

Parameters:

    Snapshot device name (without trailing backslash).

Throws:

    VSS_E_PROVIDER_VETO
        - Error in opening the IOCTL channel
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::InitializeForSnapshot" );

    // Test the arguments
    if ((pwszSnapshotName == NULL) ||
        (pwszSnapshotName[0] == L'\0')) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"NULL pwszSnapshotName");
    }

    WCHAR wszUserModeSnapshotName[MAX_PATH];
    LPCWSTR wszFinalSnapshotName = pwszSnapshotName;

    if (bPrependGlobalRoot)
    {
        // Compose the snapshot name in a user-mode style
        ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
            x_wszGlobalRootPrefix, pwszSnapshotName );
        wszFinalSnapshotName = wszUserModeSnapshotName;
    }

    // Opening the channel
    // (if already opened then it will be closed automatically)
    // No need to  eliminate the last backslash from the name.
    // The call will throw on error
    // Warning: Always do the logging
    m_objectIChannel.Open(ft, wszFinalSnapshotName, false, true, VSS_ICHANNEL_LOG_PROV,
        bInitializeForQuery? 0: GENERIC_READ | GENERIC_WRITE);
    m_bInitializedForQuery = bInitializeForQuery;
}


void CVssDiffArea::AddVolume(
    IN      VSS_PWSZ pwszVolumeMountPoint
    ) throw(HRESULT)
/*++

Routine description:

    Add a volume to the diff area.

Return codes:

    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW, ConvertVolMgmtVolumeNameIntoKernelObject
        - Error in sending the IOCTL
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY
        - Error in packing arguments

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::AddVolume" );

    // Test arguments
    if (pwszVolumeMountPoint == NULL)
        ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");

    // The critical section will be left automatically at the end of scope.
    CVssAutomaticLock2 lock(m_cs);

    BS_ASSERT(m_objectIChannel.IsOpen());
    BS_ASSERT(!m_bInitializedForQuery);

    // Convert the volume mount point into a volume name
    WCHAR wszVolumeName[MAX_PATH];
    if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
            wszVolumeName, ARRAY_LEN(wszVolumeName)))
        ft.TranslateInternalProviderError( VSSDBG_SWPRV,
            HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
            L"GetVolumeNameForVolumeMountPointW( %s, ...)", pwszVolumeMountPoint);
    BS_ASSERT(::wcslen(wszVolumeName) != 0);

    if (!::ConvertVolMgmtVolumeNameIntoKernelObject(wszVolumeName))
        ft.TranslateInternalProviderError( VSSDBG_SWPRV,
            E_UNEXPECTED, VSS_E_PROVIDER_VETO,
            L"ConvertVolMgmtVolumeNameIntoKernelObject( %s, ...)", wszVolumeName);

    // Send the IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA ioctl
    // Logs the error, if any, as a provider error.
    m_objectIChannel.PackSmallString(ft, wszVolumeName);
    m_objectIChannel.Call(ft, IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssDiffArea::Clear() throw(HRESULT)
/*++

Routine description:

    Clears the diff area volume.

Throws:

    E_UNEXPECTED
        - Error in sending the IOCTL (ignored anyway in the client)
    E_OUTOFMEMORY
        - Error in packing arguments

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::Clear" );

    BS_ASSERT(!m_bInitializedForQuery);

    // The critical section will be left automatically at the end of scope.
    CVssAutomaticLock2 lock(m_cs);

    // Try to clear the diff area on the current volume
    // Do not log anything at this point!
    BS_ASSERT(m_objectIChannel.IsOpen());
    m_objectIChannel.Call(ft, IOCTL_VOLSNAP_CLEAR_DIFF_AREA);

    // shouldn't change maximum size since there may already be
    // a diff
    m_objectIChannel.ResetOffsets();
}


void CVssDiffArea::IncrementCountOnPointedDiffAreas(
    IN OUT  CVssDiffAreaAllocator* pObj
    ) throw(HRESULT)

/*++

Routine description:

    Query the diff area volumes for the current volume.
    and call CVssDiffAreaAllocator::IncrementExistingDiffAreaCountOnVolume
    for each volume in the diff area.

Return codes:

    E_OUTOFMEMORY
        - lock failures
    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW, GetVolumeGuid
    E_UNEXPECTED
        - Nothing to log. (wrong volume) The result is anyway ignored by the client.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::IncrementCountOnPointedDiffAreas" );

    CVssAutoPWSZ awszVolumeName;

    // Initialize [out] arguments
    BS_ASSERT( pObj );

    // The critical section will be left automatically at the end of scope.
    CVssAutomaticLock2 lock(m_cs);

    // Get the list of volumes that are part of the diff area
    // Do not perform any logging.
    BS_ASSERT(m_objectIChannel.IsOpen());
    m_objectIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA);

    // Get the length of snapshot names multistring
    ULONG ulMultiszLen;
    m_objectIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
    // Get the offset to do some test comparison
    DWORD dwInitialOffset = m_objectIChannel.GetCurrentOutputOffset();
#endif

    while(m_objectIChannel.UnpackZeroString(ft, awszVolumeName.GetRef()))
    {
        // Compose the volume name in a user-mode style
        WCHAR wszMountPoint[MAX_PATH];
    	ft.hr = StringCchPrintfW(STRING_CCH_PARAM(wszMountPoint), 
    	            L"%s%s\\", x_wszGlobalRootPrefix, awszVolumeName.GetRef());
        if (ft.HrFailed())
    		ft.TranslateGenericError( VSSDBG_SWPRV, ft.hr, L"StringCchPrintfW(,%s,%s)",
    		    x_wszGlobalRootPrefix, awszVolumeName.GetRef());

        // Get the mount point for the volume name
        // If an error occurs then DO the logging.
        WCHAR wszUserModeVolumeName[MAX_PATH];
        if (!::GetVolumeNameForVolumeMountPointW( wszMountPoint,
                wszUserModeVolumeName, MAX_PATH))
            ft.TranslateInternalProviderError( VSSDBG_SWPRV,
                HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
                L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszMountPoint);
        BS_ASSERT(::wcslen(wszUserModeVolumeName) != 0);

        // Invoke the callback
        pObj->IncrementExistingDiffAreaCountOnVolume(wszUserModeVolumeName);
    }

#ifdef _DEBUG
    // Check if all strings were browsed correctly
    DWORD dwFinalOffset = m_objectIChannel.GetCurrentOutputOffset();
    BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
}


void CVssDiffArea::GetDiffArea(
    OUT     CVssAutoPWSZ & awszDiffAreaName
    ) throw(HRESULT)
/*++

Routine description:

    Sends the proper IOCTL in order to get the volume name for the diff area

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Dev error. No logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::GetDiffArea" );

    // Send the QUERY_DIFF_AREA ioctl
    m_objectIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA, true, VSS_ICHANNEL_LOG_PROV);

    // Get the length of snapshot names multistring
    ULONG ulMultiszLen = 0;
    m_objectIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
    // Try to find the snapshot with the corresponding Id
    DWORD dwInitialOffset = m_objectIChannel.GetCurrentOutputOffset();
#endif

    CVssAutoPWSZ awszDiffAreaDevice;
    BS_VERIFY(m_objectIChannel.UnpackZeroString(ft, awszDiffAreaDevice.GetRef()));

    // Compose the volume name in a user-mode style
    WCHAR wszMountPoint[MAX_PATH];
	ft.hr = StringCchPrintfW(STRING_CCH_PARAM(wszMountPoint), 
	            L"%s%s\\", x_wszGlobalRootPrefix, awszDiffAreaDevice.GetRef());
    if (ft.HrFailed())
		ft.TranslateGenericError( VSSDBG_SWPRV, ft.hr, L"StringCchPrintfW(,%s,%s)",
		    x_wszGlobalRootPrefix, awszDiffAreaDevice.GetRef());

    // Get the mount point for the volume name
    // If an error occurs then DO the logging.
    WCHAR wszCurrentDiffVolume[MAX_PATH];
    if (!::GetVolumeNameForVolumeMountPointW( wszMountPoint,
            wszCurrentDiffVolume, MAX_PATH))
        ft.TranslateInternalProviderError( VSSDBG_SWPRV,
            HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
            L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszMountPoint);
    BS_ASSERT(::wcslen(wszMountPoint) != 0);

    // Make sure we don't have any other diff areas
    BS_VERIFY(!m_objectIChannel.UnpackZeroString(ft, awszDiffAreaName.GetRef()));

#ifdef _DEBUG
    // Check if all strings were unmarshalled correctly
    DWORD dwFinalOffset = m_objectIChannel.GetCurrentOutputOffset();
    BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif

    // Copy the diff area to the OUT parameter
    awszDiffAreaName.CopyFrom(wszCurrentDiffVolume);
}


void CVssDiffArea::GetDiffAreaSizes(
    OUT     LONGLONG & llUsedSpace,
    OUT     LONGLONG & llAllocatedSpace,
    OUT     LONGLONG & llMaxSpace
    ) throw(HRESULT)
/*++

Routine description:

    Sends the proper IOCTL in order to get the diff area sizes

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Dev error. No logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::GetDiffAreaSizes" );

    // Send the QUERY_DIFF_AREA ioctl
    m_objectIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES, true, VSS_ICHANNEL_LOG_PROV);
    m_objectIChannel.Unpack(ft, &llUsedSpace);
    m_objectIChannel.Unpack(ft, &llAllocatedSpace);
    m_objectIChannel.Unpack(ft, &llMaxSpace);

    BS_ASSERT(llUsedSpace >= 0);
    BS_ASSERT(llAllocatedSpace >= 0);
    BS_ASSERT(llMaxSpace >= 0);

    // Deal with the "no max size" case
    if (llMaxSpace == VSS_BABBAGE_NO_MAX_SPACE)
        llMaxSpace = VSS_ASSOC_NO_MAX_SPACE;
}


void CVssDiffArea::ChangeDiffAreaMaximumSize(
    IN      LONGLONG    llMaximumDiffSpace
    ) throw(HRESULT)
/*++

Routine description:

    Sends the proper IOCTL in order to change the diff area max size on disk

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Dev error. No logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::ChangeDiffAreaMaximumSize" );

    BS_ASSERT( ( llMaximumDiffSpace == VSS_ASSOC_NO_MAX_SPACE) || ( llMaximumDiffSpace > 0) );
    BS_ASSERT(!m_bInitializedForQuery);

    // The driver will make sure that -1 means no limit
    LONGLONG llInternalMaxDiffSpace = (llMaximumDiffSpace == VSS_ASSOC_NO_MAX_SPACE)?
        VSS_BABBAGE_NO_MAX_SPACE: llMaximumDiffSpace;

    // Set the maximum space
    LONGLONG llUsedSpace = 0;       // Zero. Babbage will ignore it anyway.
    LONGLONG llAllocatedSpace = 0;  // Zero. Babbage will ignore it anyway.
    m_objectIChannel.Pack(ft, llUsedSpace);
    m_objectIChannel.Pack(ft, llAllocatedSpace);
    m_objectIChannel.Pack(ft, llInternalMaxDiffSpace);
    m_objectIChannel.Call(ft, IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE, true, VSS_ICHANNEL_LOG_PROV);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\diffreg.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Diffreg.cxx | Implementation of CVssProviderRegInfo
    @end

Author:

    Adi Oltean  [aoltean]  03/13/2001

Revision History:

    Name        Date        Comments
    aoltean     03/13/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include <mstask.h>
#include <clusapi.h>
#include <msclus.h>

#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "swprv.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_sec.hxx"
#include "vs_reg.hxx"
#include "vs_clus.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diffreg.hxx"
#include "diffmgmt.hxx"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRREGMC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffMgmt - Methods


void CVssProviderRegInfo::AddDiffArea(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,     
    IN      LONGLONG    llMaximumDiffSpace
	) throw(HRESULT)
/*++

Routine description:

    Adds a diff area association for a certain volume.
    If the association is not supported, an error code will be returned.
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_ALREADY_EXISTS
        - If an associaltion already exists
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::AddDiffArea" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    BOOL bRes = GetVolumeGuid( pwszVolumeName, VolumeID );
    BS_ASSERT(bRes);
    bRes = GetVolumeGuid( pwszDiffAreaVolumeName, DiffAreaVolumeID );
    BS_ASSERT(bRes);

    // Make sure this is the only association on the original volume
    CVssRegistryKey reg;
    if (reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT, x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID)))
    {
        CVssRegistryKeyIterator iter;
        iter.Attach(reg);

        // If there is already a diff area in registry, then stop here.
        if (!iter.IsEOF())
            ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_ALREADY_EXISTS, L"There is an association on %s", pwszVolumeName);
    }
    
    // Create the registry key
    reg.Create( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT L"\\" WSTR_GUID_FMT, 
        x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID), GUID_PRINTF_ARG(DiffAreaVolumeID));

    //Add the value denoting the maximum diff area
    reg.SetValue( x_wszVssMaxDiffValName, llMaximumDiffSpace);

    // If we are in a cluster
    CVssClusterAPI cluster;

    if (cluster.Initialize())
    {
        // Try to add the dependency and the checkpoint
        bool bDependencyAdded = false;
        bool bCheckpointAdded = false;
        try
        {
            // then add a dependency between the two volumes 
            bDependencyAdded = cluster.AddDependency(pwszVolumeName, pwszDiffAreaVolumeName);

            // and a checkpoint registry to the original volume
            // NOTE: this shouldn't fail if the checkpoint is already added!
            bCheckpointAdded = cluster.AddRegistryKey(pwszVolumeName, L"%s\\" WSTR_GUID_FMT, 
                x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID));
        }
        VSS_STANDARD_CATCH(ft)

        // Rollback changes on error
        if (ft.HrFailed())
        {
            // Remove the dependency that was just added
            if (bDependencyAdded)
                if (!cluster.RemoveDependency(pwszVolumeName, pwszDiffAreaVolumeName))
                {
                    BS_ASSERT(false);
                    ft.LogGenericWarning( VSSDBG_SWPRV, L"cluster.RemoveDependency(%s, %s)", 
                        pwszVolumeName, pwszDiffAreaVolumeName);
                }

            // Open the Associations registry key. We want to remove the added diff area GUID key (if any).
            if (!reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT, 
                    x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID)))
            {
                BS_ASSERT(false);
                ft.LogGenericWarning( VSSDBG_SWPRV, L"reg.Open( HKEY_LOCAL_MACHINE, %s\\" WSTR_GUID_FMT L")", 
                    x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID));
            }
            else
            {
                // Delete the diff area volume subkey
                reg.DeleteSubkey( WSTR_GUID_FMT, GUID_PRINTF_ARG(DiffAreaVolumeID));
            }

            // There was a failure somewhere
            if (ft.HrSucceeded()) {
                BS_ASSERT(false);
                ft.hr = E_UNEXPECTED;
            }

            // Rethrowing
            ft.ReThrow();
        }
    }
}


void CVssProviderRegInfo::RemoveDiffArea(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName
	) throw(HRESULT)
/*++

Routine description:

    Removes a diff area association for a certain volume.
    If the association does not exists, an error code will be returned.
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - If an associaltion does not exists
    E_UNEXPECTED
        - Unexpected runtime errors.
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::RemoveDiffArea" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    if(!GetVolumeGuid( pwszVolumeName, VolumeID ))
        ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"The volume %s does not represent a volume name", pwszVolumeName );
    if(!GetVolumeGuid( pwszDiffAreaVolumeName, DiffAreaVolumeID ))
        ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"The volume %s does not represent a volume name", pwszDiffAreaVolumeName );

    // Open the registry key for that association, to make sure it's there.
    CVssRegistryKey reg;
    if (!reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT L"\\" WSTR_GUID_FMT, 
            x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID), GUID_PRINTF_ARG(DiffAreaVolumeID)))
        ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"An association between %s and %s does not exist", 
            pwszVolumeName, pwszDiffAreaVolumeName);

    // Open the associations key for that volume
    if (!reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT, 
            x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID)))
    {
        BS_ASSERT(false);
        ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, 
            L"The association key does not exists for volume %s", pwszVolumeName);
    }

    // Recursively deletes the subkey for that volume.
    reg.DeleteSubkey( WSTR_GUID_FMT, GUID_PRINTF_ARG(DiffAreaVolumeID));

    // If we are in a cluster
    CVssClusterAPI cluster;

    if (cluster.Initialize())
    {
        // then remove the dependency between the two volumes 
        cluster.RemoveDependency(pwszVolumeName, pwszDiffAreaVolumeName);

        // BUG: 665051 - do not delete the registry checkpoints... 
        //
        // cluster.RemoveRegistryKey(pwszVolumeName, L"%s\\" WSTR_GUID_FMT, 
        //    x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID));
    }

}


bool CVssProviderRegInfo::IsAssociationPresentInRegistry(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName
	) throw(HRESULT)
/*++

Routine description:

    Removes a diff area association for a certain volume.
    If the association does not exists, an error code will be returned.
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - If an associaltion does not exists
    E_UNEXPECTED
        - Unexpected runtime errors.
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::IsAssociationPresentInRegistry" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    if(!GetVolumeGuid( pwszVolumeName, VolumeID ))
        ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"The volume %s does not represent a volume name", pwszVolumeName );
    if(!GetVolumeGuid( pwszDiffAreaVolumeName, DiffAreaVolumeID ))
        ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"The volume %s does not represent a volume name", pwszDiffAreaVolumeName );

    // Try to open the registry key for that association, to make sure it's there.
    CVssRegistryKey reg;
    return reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT L"\\" WSTR_GUID_FMT, 
            x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID), GUID_PRINTF_ARG(DiffAreaVolumeID));
}


void CVssProviderRegInfo::ChangeDiffAreaMaximumSize(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,     
    IN      LONGLONG    llMaximumDiffSpace
	) throw(HRESULT)
/*++

Routine description:

    Updates the diff area max size for a certain volume.
    This may not have an immediate effect
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - The association does not exists
    E_UNEXPECTED
        - Unexpected runtime error. An error log entry is added.
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::ChangeDiffAreaMaximumSize" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    BOOL bRes = GetVolumeGuid( pwszVolumeName, VolumeID );
    BS_ASSERT(bRes);
    bRes = GetVolumeGuid( pwszDiffAreaVolumeName, DiffAreaVolumeID );
    BS_ASSERT(bRes);

    // Open the registry key
    CVssRegistryKey reg;
    if (!reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT L"\\" WSTR_GUID_FMT, 
            x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID), GUID_PRINTF_ARG(DiffAreaVolumeID)))
        ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"An association between %s and %s does not exist", 
            pwszVolumeName, pwszDiffAreaVolumeName);

    // Update the value denoting the maximum diff area
    reg.SetValue( x_wszVssMaxDiffValName, llMaximumDiffSpace);
}


bool CVssProviderRegInfo::GetDiffAreaForVolume(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN OUT 	VSS_PWSZ &	pwszDiffAreaVolumeName,
	IN OUT 	LONGLONG &	llMaxSize,
	IN OUT  LONG     &  lAssociationFlags
	) throw(HRESULT)
/*++

Routine description:

    Gets the diff area volume name from registry.
    In the next version this will return an array of diff area volumes associated with the given volume.

Returns:
    true
        - There is an association. Returns the diff area volume in the out parameter
    false
        - There is no association
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    E_UNEXPECTED
        - Unexpected runtime error. An error log entry is added.
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::GetDiffAreaForVolume" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName == NULL);
    BS_ASSERT(llMaxSize == 0);
    BS_ASSERT(lAssociationFlags == 0);

    // Extract the GUIDs
    GUID VolumeID;
    BOOL bRes = GetVolumeGuid( pwszVolumeName, VolumeID );
    BS_ASSERT(bRes);

    // Open the registry key
    CVssRegistryKey reg;
    if (!reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT, x_wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID)))
        return false;

    // Enumerate the subkeys (in fact it should be either zero or one - in this version)
    CVssRegistryKeyIterator iter;
    iter.Attach(reg);
    if (iter.IsEOF())
        return false;   // Volume key leftover from a previous deleted association...
    
    // Read the subkey name
    CVssAutoPWSZ awszVolumeName;
    awszVolumeName.Allocate(x_nLengthOfVolMgmtVolumeName);
	ft.hr = StringCchPrintfW(awszVolumeName.GetRef(), x_nLengthOfVolMgmtVolumeName + 1, L"%s%s%s", 
        x_wszVolMgmtVolumeDefinition, iter.GetCurrentKeyName(), x_wszVolMgmtEndOfVolumeName);
    if (ft.HrFailed())
		ft.TranslateGenericError( VSSDBG_SWPRV, ft.hr, L"StringCchPrintfW(,%s,%s,%s)",
		    x_wszVolMgmtVolumeDefinition, iter.GetCurrentKeyName(), x_wszVolMgmtEndOfVolumeName);

    // Open the diff area key
    CVssRegistryKey reg2;
    bRes = reg2.Open( reg.GetHandle(), iter.GetCurrentKeyName());
    BS_ASSERT(bRes);

    // Get the max space
    reg2.GetValue( x_wszVssMaxDiffValName, llMaxSize );
    
    ft.Trace( VSSDBG_GEN, L"Registry diff volume name for %s is %s", 
        pwszVolumeName, awszVolumeName.GetRef());
    
    // Save also the new volume to the output parameter
    pwszDiffAreaVolumeName = awszVolumeName.Detach();
    ft.Trace( VSSDBG_GEN, L"Internal diff volume name for %s is %s", 
        pwszVolumeName, pwszDiffAreaVolumeName);
    
    // Convert the volume name to the "internal" version (bug# 698870)
    
    // Get the real GUID-based volume name
    WCHAR wszVolumeNameInternal[MAX_PATH];
    if (!::GetVolumeNameForVolumeMountPointW( pwszDiffAreaVolumeName, 
                STRING_CCH_PARAM(wszVolumeNameInternal)))
    {
        ft.LogGenericWarning(VSSDBG_GEN, 
            L"GetVolumeNameForVolumeMountPointW( '%s'): 0x%08lx", 
            pwszDiffAreaVolumeName, GetLastError());

        lAssociationFlags |= CVssDiffMgmt::VSS_DAT_INVALID;
        return false;
    }

    // If the volume GUID in the registry is not the volume name GUID, 
    // then treat the association as invalid (BUG 698870)
    if (_wcsicmp(pwszDiffAreaVolumeName, wszVolumeNameInternal) != 0)
    {
        lAssociationFlags |= CVssDiffMgmt::VSS_DAT_INVALID;
        return false;
    }
    
    // Go to next subkey. There should be no subkeys left since in this version we have only one diff area per volume.
    iter.MoveNext();
    BS_ASSERT(iter.IsEOF());

    // Get the association flags
    lAssociationFlags = CVssDiffMgmt::GetAssociationFlags(pwszVolumeName, pwszDiffAreaVolumeName);
    ft.Trace(VSSDBG_SWPRV, L"An association is present: %s - %s (%I64d) with flags 0x%08lx",
        pwszVolumeName, pwszDiffAreaVolumeName, llMaxSize, lAssociationFlags);

    // Return TRUE only if the association is valid
    return ((lAssociationFlags & CVssDiffMgmt::VSS_DAT_INVALID) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sec\security.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module security.cxx | Implementation of IsAdministrator
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     08/26/1999  Adding RegisterProvider
    aoltean     08/26/1999  Adding UnregisterProvider
    aoltean     08/27/1999  Adding IsAdministrator,
                            Adding unique provider name test.
    aoltean     08/30/1999  Calling OnUnregister on un-registering
                            Improving IsProviderNameAlreadyUsed.
    aoltean     09/09/1999  dss -> vss
    aoltean     09/21/1999  Adding a new header for the "ptr" class.
    aoltean     09/27/1999  Adding new headers
    aoltean     10/15/1999  Moving declaration in security.hxx
    aoltean     01/18/2000  Moved into a separate directory
    brianb      04/04/2000  Add IsBackupOperator
    brianb      04/27/2000  Change IsBackupOperator to check SE_BACKUP_NAME privilege
    brianb      05/03/2000  Added GetClientTokenOwner method
    brianb      05/10/2000  fix problem with uninitialized variable
    brianb      05/12/2000  handle in proc case for impersonation failures

--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"

// This must be included before vs_inc.h since contains the NetApiXXX 
#include <lm.h>

#include "vs_inc.hxx"

#include "vs_sec.hxx"
#include "sddl.h"
#include "vs_reg.hxx"

#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SECSECRC"
//
////////////////////////////////////////////////////////////////////////

BOOL GetCurrentAccessToken
    (
    IN  BOOL bPerformImpersonation,
    OUT HANDLE *phToken
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"GetCurrentAccessToken");

    BS_ASSERT(phToken);
    
    if (bPerformImpersonation)
        {
            
        //  Impersonate the client to get its identity access token.
        //  The client should not have RPC_C_IMP_LEVEL_ANONYMOUS otherwise an error will be returned
        ft.hr = ::CoImpersonateClient();
        if (ft.HrFailed())
            {
            
            if (ft.hr != RPC_E_CALL_COMPLETE)
                ft.TranslateGenericError( VSSDBG_GEN, ft.hr, L"CoImpersonateClient");

            // this means that the call came from the same thread
            // Do not perform impersonation.  Just use the process
            // token
            if (!::OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, phToken))
                ft.TranslateWin32Error(VSSDBG_GEN,L"OpenProcessToken");
            
            ft.hr = S_OK;
            return FALSE;
            }

        BOOL bRes = ::OpenThreadToken
                (
                GetCurrentThread(), //  IN HANDLE ThreadHandle,
                TOKEN_QUERY,        //  IN DWORD DesiredAccess,
                TRUE,               //  IN BOOL OpenAsSelf
                phToken             //  OUT PHANDLE TokenHandle
                );
        HRESULT hrErr = HRESULT_FROM_WIN32(GetLastError());

        // Revert the thread's access token - finish the impersonation
        ft.hr = ::CoRevertToSelf();
        if (ft.HrFailed())
            ft.TranslateWin32Error(VSSDBG_GEN,L"CoRevertToSelf");

        if (!bRes)
            ft.TranslateGenericError(VSSDBG_GEN, hrErr, L"OpenThreadToken");
    
        return TRUE;
        }
    else // i.e. if (!bPerformImpersonation)
        {

        // First try to get the thread token. (assuming we are already impersonating) 
        // If we succeed, we will go with this. 
        // If we fail, we ignore the error and proceed with OpenProcessToken (who must succeed).
        if (::OpenThreadToken
                (
                GetCurrentThread(), //  IN HANDLE ThreadHandle,
                TOKEN_QUERY,        //  IN DWORD DesiredAccess,
                TRUE,               //  IN BOOL OpenAsSelf
                phToken             //  OUT PHANDLE TokenHandle
                ))
            return TRUE;

        // We don't have a thread token (so we cannot be under impersonation). 
        // Now try to get the process token
        if (!::OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, phToken))
            ft.TranslateWin32Error(VSSDBG_GEN, L"OpenProcessToken");
        
        return FALSE;
        }
    }




bool IsInGroup(DWORD dwGroup, bool bImpersonate)

/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of an administrator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the specified group is between token groups.

Return Value:

    true, if the caller thread is running under the context of the specified group
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    CVssFunctionTracer ft( VSSDBG_GEN, L"IsInGroup" );

    BOOL bIsInGroup = FALSE;
    PSID psidGroup = NULL;
    BOOL bRes;

    // Reset the error code
    ft.hr = S_OK;

    //  Build the SID for the Administrators group
    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
    bRes = AllocateAndInitializeSid
            (
            &SidAuth,                       //  IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
            2,                              //  IN BYTE nSubAuthorityCount,
            SECURITY_BUILTIN_DOMAIN_RID,    //  IN DWORD nSubAuthority0,
            dwGroup,                        //  IN DWORD nSubAuthority1,
            0,                              //  IN DWORD nSubAuthority2,
            0,                              //  IN DWORD nSubAuthority3,
            0,                              //  IN DWORD nSubAuthority4,
            0,                              //  IN DWORD nSubAuthority5,
            0,                              //  IN DWORD nSubAuthority6,
            0,                              //  IN DWORD nSubAuthority7,
            &psidGroup                      //  OUT PSID *pSid
            );

    if (!bRes)
        ft.TranslateError
            (
            VSSDBG_GEN,
            HRESULT_FROM_WIN32(GetLastError()),
            L"AllocateAndInitializeSid"
            );

    try
        {

        if (!bImpersonate)
            bRes = CheckTokenMembership(NULL, psidGroup, &bIsInGroup);
        else
            {
            CVssAutoWin32Handle  hToken;

            // impersonate client (or get process token)
            if (GetCurrentAccessToken(true, hToken.ResetAndGetAddress()))
                // check token membership
                bRes = CheckTokenMembership(hToken, psidGroup, &bIsInGroup);
            else
                // called from same thread
                bRes = CheckTokenMembership(NULL, psidGroup, &bIsInGroup);
            }

        if (!bRes)
            ft.TranslateError
                (
                VSSDBG_GEN,
                HRESULT_FROM_WIN32(GetLastError()),
                L"CheckTokenMembership"
                );

        }
    VSS_STANDARD_CATCH(ft)

    HRESULT hr = ft.hr;

    // Catch possible AVs
    try
        {
        //  Free the previously allocated SID
        if (psidGroup)
            ::FreeSid( psidGroup );
        }
    VSS_STANDARD_CATCH(ft)

    // Pass down the exception, if any
    if (FAILED(hr))
        throw(hr);

    return bIsInGroup ? true : false;
    }

bool HasPrivilege(LPWSTR wszPriv, bool bImpersonate)

/*++

Routine Description:

    Return TRUE if the current thread/process has a specific privilege

Arguments:


    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the specified group is between token groups.

Return Value:

    true, if the caller thread is running under the context of the specified group
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    CVssFunctionTracer ft( VSSDBG_GEN, L"HasPrivilege" );

    BOOL bHasPrivilege = false;
    CVssAutoWin32Handle  hToken;

    LUID TokenValue;
    if (!LookupPrivilegeValue (NULL, wszPriv, &TokenValue))
        ft.TranslateError
            (
            VSSDBG_GEN,
            HRESULT_FROM_WIN32(GetLastError()),
            L"LookupPrivilegeValue"
            );

    GetCurrentAccessToken(bImpersonate, hToken.ResetAndGetAddress());

    BYTE rgb[sizeof(LUID_AND_ATTRIBUTES) + sizeof(PRIVILEGE_SET)];
    PRIVILEGE_SET *pSet = (PRIVILEGE_SET *) rgb;

    pSet->PrivilegeCount = 1;
    pSet->Control = PRIVILEGE_SET_ALL_NECESSARY;
    pSet->Privilege[0].Luid = TokenValue;
    pSet->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!PrivilegeCheck(hToken, pSet, &bHasPrivilege))
        ft.TranslateError
            (
            VSSDBG_GEN,
            HRESULT_FROM_WIN32(GetLastError()),
            L"PrivilegeCheck"
            );

    return bHasPrivilege ? true : false;
    }


TOKEN_USER * GetClientTokenUser(BOOL bImpersonate)

/*++

Routine Description:

    Return TOKEN_USER of client process

Arguments:

    bImpersonate - TRUE iif an impersonation is required.

Remarks:

    The current impersonation thread is asked for the access token.
    After that we return the client sid of that token

Return Value:

    SID of client thread

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    CVssFunctionTracer ft( VSSDBG_GEN, L"GetClientTokenUser" );

    BOOL bRes;

    CVssAutoWin32Handle  hToken;
    GetCurrentAccessToken(bImpersonate, hToken.ResetAndGetAddress());

    DWORD cbSid;
    bRes = ::GetTokenInformation
            (
            hToken,         //  IN HANDLE TokenHandle,
            TokenUser,      //  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
            NULL,           //  OUT LPVOID TokenInformation,
            0,              //  IN DWORD TokenInformationLength,
            &cbSid          //  OUT PDWORD ReturnLength
            );

    BS_ASSERT( bRes == FALSE );

    DWORD dwError = GetLastError();
    if ( dwError != ERROR_INSUFFICIENT_BUFFER )
        {
        ft.LogError(VSS_ERROR_EXPECTED_INSUFFICENT_BUFFER, VSSDBG_GEN << (HRESULT) dwError);
        ft.Throw
            (
            VSSDBG_GEN,
            E_UNEXPECTED,
            L"ERROR_INSUFFICIENT_BUFFER expected error . [0x%08lx]",
            dwError
            );
        }

    //  Allocate the buffer needed to get the Token Groups information
    CVssAutoCppPtr<TOKEN_USER*> ptrTokenUser;
    ptrTokenUser.AllocateBytes(cbSid);

    //  Get the all Group SIDs in the token
    DWORD cbTokenObtained;
    bRes = ::GetTokenInformation
        (
        hToken,             //  IN HANDLE TokenHandle,
        TokenUser,          //  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
        ptrTokenUser,       //  OUT LPVOID TokenInformation,
        cbSid,              //  IN DWORD TokenInformationLength,
        &cbTokenObtained    //  OUT PDWORD ReturnLength
        );

    if ( !bRes )
        ft.TranslateError
            (
            VSSDBG_GEN,
            HRESULT_FROM_WIN32(GetLastError()),
            L"GetTokenInformation"
            );

    if (cbTokenObtained != cbSid)
        {
        ft.LogError(VSS_ERROR_GET_TOKEN_INFORMATION_BUFFER_SIZE_MISMATCH, VSSDBG_GEN << (INT) cbTokenObtained << (INT) cbSid);
        ft.Throw
            (
            VSSDBG_GEN,
            E_UNEXPECTED,
            L"Unexpected error. Final buffer size = %lu, original size was %lu",
            cbTokenObtained,
            cbSid
            );
        }

    return ptrTokenUser.Detach();
    }


TOKEN_OWNER * GetClientTokenOwner(BOOL bImpersonate)

/*++

Routine Description:

    Return TOKEN_OWNER of client process

Arguments:


    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we return the client sid of that token

Return Value:

    SID of client thread

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    CVssFunctionTracer ft( VSSDBG_GEN, L"GetClientTokenOwner" );

    BOOL bRes;

    CVssAutoWin32Handle  hToken;
    GetCurrentAccessToken(bImpersonate, hToken.ResetAndGetAddress());

    DWORD cbSid;
    bRes = ::GetTokenInformation
            (
            hToken,         //  IN HANDLE TokenHandle,
            TokenOwner,  //  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
            NULL,           //  OUT LPVOID TokenInformation,
            0,              //  IN DWORD TokenInformationLength,
            &cbSid          //  OUT PDWORD ReturnLength
            );

    BS_ASSERT( bRes == FALSE );

    DWORD dwError = GetLastError();
    if ( dwError != ERROR_INSUFFICIENT_BUFFER )
        {
        ft.LogError(VSS_ERROR_EXPECTED_INSUFFICENT_BUFFER, VSSDBG_GEN << (HRESULT) dwError);
        ft.Throw
            (
            VSSDBG_GEN,
            E_UNEXPECTED,
            L"ERROR_INSUFFICIENT_BUFFER expected error . [0x%08lx]",
            dwError
            );
        }

    //  Allocate the buffer needed to get the Token Groups information
    CVssAutoCppPtr<TOKEN_OWNER*> ptrTokenOwner;
    ptrTokenOwner.AllocateBytes(cbSid);

    //  Get the all Group SIDs in the token
    DWORD cbTokenObtained;
    bRes = ::GetTokenInformation
        (
        hToken,             //  IN HANDLE TokenHandle,
        TokenOwner,         //  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
        ptrTokenOwner,      //  OUT LPVOID TokenInformation,
        cbSid,              //  IN DWORD TokenInformationLength,
        &cbTokenObtained    //  OUT PDWORD ReturnLength
        );

    if ( !bRes )
        ft.TranslateError
            (
            VSSDBG_GEN,
            HRESULT_FROM_WIN32(GetLastError()),
            L"GetTokenInformation"
            );

    if (cbTokenObtained != cbSid)
        {
        ft.LogError(VSS_ERROR_GET_TOKEN_INFORMATION_BUFFER_SIZE_MISMATCH, VSSDBG_GEN << (INT) cbTokenObtained << (INT) cbSid);
        ft.Throw
            (
            VSSDBG_GEN,
            E_UNEXPECTED,
            L"Unexpected error. Final buffer size = %lu, original size was %lu",
            cbTokenObtained,
            cbSid
            );
        }

    return ptrTokenOwner.Detach();
    }



bool IsAdministrator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of an administrator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is between token groups.

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    return IsInGroup(DOMAIN_ALIAS_RID_ADMINS, true);
    }

bool IsProcessAdministrator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of an administrator

Arguments:

    none

Remarks:
    The current process is asked for the access token.
    After that we check if the Administrators group is between token groups.

Return Value:

    true, if the process is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    return IsInGroup(DOMAIN_ALIAS_RID_ADMINS, false);
    }



bool IsBackupOperator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of a backup operator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is in the groups token
    or the backup privilege is enabled

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    //  Bug #554480	VSS: Authorize backup operators based on group membership not privilege
    //    return HasPrivilege(SE_BACKUP_NAME, true) || IsAdministrator();
    return HasPrivilege(SE_BACKUP_NAME, true) 
        || IsInGroup(DOMAIN_ALIAS_RID_BACKUP_OPS, true) 
        || IsAdministrator();
    }

bool IsRestoreOperator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of a restore operator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is in the token groups or
    if the restore privilege is enabled.

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    return HasPrivilege(SE_RESTORE_NAME, true) || IsAdministrator();
    }


bool IsProcessBackupOperator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of a backup operator

Arguments:

    none

Remarks:

Return Value:

    true, if the process is running under the context of an administrator or
    has SE_BACKUP_NAME privilege enabled
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    //  Bug #554480	VSS: Authorize backup operators based on group membership not privilege
    //  (We still keep the check for backup privilege, for safety)
    //    return HasPrivilege(SE_BACKUP_NAME, false) || IsProcessAdministrator();
    return HasPrivilege(SE_BACKUP_NAME, false) 
        || IsInGroup(DOMAIN_ALIAS_RID_BACKUP_OPS, false) 
        || IsProcessAdministrator();
    }

bool IsProcessRestoreOperator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of a restore operator

Arguments:

    none

Remarks:

Return Value:

    true, if the process is running under the context of an administrator
    or has the SE_RESTORE_NAME privilege; false otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

    {
    return HasPrivilege(SE_RESTORE_NAME, false) || IsProcessAdministrator();
    }



// turn on a particular security privilege
HRESULT TurnOnSecurityPrivilege(LPCWSTR wszPriv)

/*++

Routine Description:

    sets the specified privilege on the process token

Arguments:

    none

Remarks:

Return Value:
    status code for operation

Thrown exceptions:
    none
--*/

    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"TurnOnSecurityPrivilege");

    CVssAutoWin32Handle  hProcessToken;
    try
        {
        LUID    TokenValue = {0, 0};

        if (!OpenProcessToken (
                GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES,
                hProcessToken.ResetAndGetAddress()
                ))
            ft.TranslateWin32Error(VSSDBG_GEN, L"OpenProcessToken");

        if (!LookupPrivilegeValue (NULL, wszPriv, &TokenValue))
            ft.TranslateWin32Error(VSSDBG_GEN, L"LookupPrivilegeValue(%s)", wszPriv);

        TOKEN_PRIVILEGES    NewTokenPrivileges;

        NewTokenPrivileges.PrivilegeCount           = 1;
        NewTokenPrivileges.Privileges[0].Luid       = TokenValue;
        NewTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        // AdjustTokenPrivileges succeeds even the token isn't set
        SetLastError(ERROR_SUCCESS);

        if (!AdjustTokenPrivileges(
                hProcessToken,
                FALSE,
                &NewTokenPrivileges,
                sizeof (NewTokenPrivileges),
                NULL,
                NULL
                ))
            ft.TranslateWin32Error(VSSDBG_GEN, L"AdjustTokenPrivileges");
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// turn on backup security privilege
HRESULT TurnOnSecurityPrivilegeBackup()
    {
    return TurnOnSecurityPrivilege(SE_BACKUP_NAME);
    }

// turn on restore security privilege
HRESULT TurnOnSecurityPrivilegeRestore()
    {
    return TurnOnSecurityPrivilege(SE_RESTORE_NAME);
    }


// create a basic well known sid such as LOCAL_SERVICE, LOCAL_SYSTEM,
// or NETWORK_SERVICE.
void CAutoSid::CreateBasicSid(WELL_KNOWN_SID_TYPE type)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CAutoSid::CreateBasicSid");

    BS_ASSERT(!Base::IsValid());

    DWORD cbSid = 0;
    CreateWellKnownSid(type, NULL, NULL, &cbSid);
    DWORD dwErr = GetLastError();
    if (dwErr != ERROR_INSUFFICIENT_BUFFER)
        {
        ft.hr = HRESULT_FROM_WIN32(dwErr);
        ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSidType");
        }

    CVssAutoLocalPtr<SID*> pSid;
    pSid.AllocateBytes(cbSid);

    if (!CreateWellKnownSid(type, NULL, pSid, &cbSid))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSidType");
        }

    Base::Attach(pSid.Detach());
    }

// create a sid based on a STRING sid
void CAutoSid::CreateFromString(LPCWSTR wsz)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CAutoSid::CreateFromString");

    BS_ASSERT(!Base::IsValid());
    
    if (!ConvertStringSidToSid (wsz, (PSID*)&Base::GetPtrObject()))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_GEN, L"ConvertStringSidToSid");
        }
    }


//////////////////////////////////////////////////////////////////////////////
// CVssSecurityDescriptor
//

CVssSecurityDescriptor::CVssSecurityDescriptor()
{
        m_pSD = NULL;
        m_pOwner = NULL;
        m_pGroup = NULL;
        m_pDACL = NULL;
        m_pSACL= NULL;
}

CVssSecurityDescriptor::~CVssSecurityDescriptor()
{
        if (m_pSD)
                delete m_pSD;
        if (m_pOwner)
                free(m_pOwner);
        if (m_pGroup)
                free(m_pGroup);
        if (m_pDACL)
                free(m_pDACL);
        if (m_pSACL)
                free(m_pSACL);
}

HRESULT CVssSecurityDescriptor::Initialize()
{
        if (m_pSD)
        {
                delete m_pSD;
                m_pSD = NULL;
        }
        if (m_pOwner)
        {
                free(m_pOwner);
                m_pOwner = NULL;
        }
        if (m_pGroup)
        {
                free(m_pGroup);
                m_pGroup = NULL;
        }
        if (m_pDACL)
        {
                free(m_pDACL);
                m_pDACL = NULL;
        }
        if (m_pSACL)
        {
                free(m_pSACL);
                m_pSACL = NULL;
        }

        ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
        if (m_pSD == NULL)
                return E_OUTOFMEMORY;

        if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pSD;
                m_pSD = NULL;
                ATLASSERT(FALSE);
                return hr;
        }
        return S_OK;
}

HRESULT CVssSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
        PSID pUserSid = NULL;
        PSID pGroupSid = NULL;
        HRESULT hr;

        Initialize();
        hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (SUCCEEDED(hr))
        {
                hr = SetOwner(pUserSid, bDefaulted);
                if (SUCCEEDED(hr))
                        hr = SetGroup(pGroupSid, bDefaulted);
        }
        if (pUserSid != NULL)
                free(pUserSid);
        if (pGroupSid != NULL)
                free(pGroupSid);
        return hr;
}

HRESULT CVssSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
        PSID pUserSid = NULL;
        PSID pGroupSid = NULL;
        HRESULT hr;

        Initialize();
        hr = GetThreadSids(&pUserSid, &pGroupSid);
        if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
                hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (SUCCEEDED(hr))
        {
                hr = SetOwner(pUserSid, bDefaulted);
                if (SUCCEEDED(hr))
                        hr = SetGroup(pGroupSid, bDefaulted);
        }
        if (pUserSid != NULL)
                free(pUserSid);
        if (pGroupSid != NULL)
                free(pGroupSid);
        return hr;
}

HRESULT CVssSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
        ATLASSERT(m_pSD);

        // Mark the SD as having no owner
        if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }

        if (m_pOwner)
        {
                free(m_pOwner);
                m_pOwner = NULL;
        }

        // If they asked for no owner don't do the copy
        if (pOwnerSid == NULL)
                return S_OK;

        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pOwnerSid);

        m_pOwner = (PSID) malloc(dwSize);
        if (m_pOwner == NULL)
                return E_OUTOFMEMORY;
        if (!CopySid(dwSize, m_pOwner, pOwnerSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pOwner);
                m_pOwner = NULL;
                return hr;
        }

        ATLASSERT(IsValidSid(m_pOwner));

        if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pOwner);
                m_pOwner = NULL;
                return hr;
        }

        return S_OK;
}

HRESULT CVssSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
        ATLASSERT(m_pSD);

        // Mark the SD as having no Group
        if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }

        if (m_pGroup)
        {
                free(m_pGroup);
                m_pGroup = NULL;
        }

        // If they asked for no Group don't do the copy
        if (pGroupSid == NULL)
                return S_OK;

        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pGroupSid);

        m_pGroup = (PSID) malloc(dwSize);
        if (m_pGroup == NULL)
                return E_OUTOFMEMORY;
        if (!CopySid(dwSize, m_pGroup, pGroupSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pGroup);
                m_pGroup = NULL;
                return hr;
        }

        ATLASSERT(IsValidSid(m_pGroup));

        if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pGroup);
                m_pGroup = NULL;
                return hr;
        }

        return S_OK;
}

HRESULT CVssSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD dwAceFlags)
{
        HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask, dwAceFlags);
        if (SUCCEEDED(hr))
                SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
        return hr;
}

HRESULT CVssSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD dwAceFlags)
{
        HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask, dwAceFlags);
        if (SUCCEEDED(hr))
                SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
        return hr;
}

HRESULT CVssSecurityDescriptor::Allow(PSID pSid, DWORD dwAccessMask, DWORD dwAceFlags)
{
        HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pSid, dwAccessMask, dwAceFlags);
        if (SUCCEEDED(hr))
                SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
        return hr;
}

HRESULT CVssSecurityDescriptor::Deny(PSID pSid, DWORD dwAccessMask, DWORD dwAceFlags)
{
        HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pSid, dwAccessMask, dwAceFlags);
        if (SUCCEEDED(hr))
                SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
        return hr;
}

HRESULT CVssSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
        HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
        if (SUCCEEDED(hr))
                SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
        return hr;
}

HRESULT CVssSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        if (!bRes)
        {
                // Couldn't open process token
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        CloseHandle(hToken);
        return hr;
}

HRESULT CVssSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
        if (!bRes)
        {
                // Couldn't open thread token
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        CloseHandle(hToken);
        return hr;
}

HRESULT CVssSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
        DWORD dwSize;
        HRESULT hr;
        PTOKEN_USER ptkUser = NULL;
        PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;

        if (ppUserSid)
        {
                // Get length required for TokenUser by specifying buffer length of 0
                GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
                hr = GetLastError();
                if (hr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        ATLASSERT(FALSE);
                        hr = HRESULT_FROM_WIN32(hr);
                        goto failed;
                }

                ptkUser = (TOKEN_USER*) malloc(dwSize);
                if (ptkUser == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkUser->User.Sid);

                PSID pSid;
                pSid = (PSID) malloc(dwSize);
                if (pSid == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                ATLASSERT(IsValidSid(pSid));
                *ppUserSid = pSid;
                free(ptkUser);
                ptkUser = NULL;
        }
        if (ppGroupSid)
        {
                // Get length required for TokenPrimaryGroup by specifying buffer length of 0
                GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
                hr = GetLastError();
                if (hr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        ATLASSERT(FALSE);
                        hr = HRESULT_FROM_WIN32(hr);
                        goto failed;
                }

                ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
                if (ptkGroup == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

                PSID pSid;
                pSid = (PSID) malloc(dwSize);
                if (pSid == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                ATLASSERT(IsValidSid(pSid));

                *ppGroupSid = pSid;
                free(ptkGroup);
                ptkGroup = NULL;
        }

        return S_OK;

failed:
        if (ptkUser)
                free(ptkUser);
        if (ptkGroup)
                free (ptkGroup);
        return hr;
}


HRESULT CVssSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
        HANDLE tkHandle;

        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
        {
                TOKEN_USER *tkUser;
                DWORD tkSize;
                DWORD sidLength;

                // Call to get size information for alloc
                GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
                tkUser = (TOKEN_USER *) malloc(tkSize);
                if (tkUser == NULL)
                        return E_OUTOFMEMORY;

                // Now make the real call
                if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
                {
                        sidLength = GetLengthSid(tkUser->User.Sid);
                        *ppSid = (PSID) malloc(sidLength);
                        if (*ppSid == NULL)
                                return E_OUTOFMEMORY;

                        memcpy(*ppSid, tkUser->User.Sid, sidLength);
                        CloseHandle(tkHandle);

                        free(tkUser);
                        return S_OK;
                }
                else
                {
                        free(tkUser);
                        return HRESULT_FROM_WIN32(GetLastError());
                }
        }
        return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CVssSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
        HRESULT hr;
        LPTSTR pszRefDomain = NULL;
        DWORD dwDomainSize = 0;
        DWORD dwSidSize = 0;
        SID_NAME_USE snu;

        // Call to get size info for alloc
        LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(hr);

        ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
        if (pszRefDomain == NULL)
                return E_OUTOFMEMORY;

        *ppSid = (PSID) malloc(dwSidSize);
        if (*ppSid != NULL)
        {
                if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
                {
                        free(*ppSid);
                        *ppSid = NULL;
                        delete[] pszRefDomain;
                        return HRESULT_FROM_WIN32(GetLastError());
                }
                delete[] pszRefDomain;
                return S_OK;
        }
        delete[] pszRefDomain;
        return E_OUTOFMEMORY;
}


HRESULT CVssSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
        PACL    pDACL = NULL;
        PACL    pSACL = NULL;
        BOOL    bDACLPresent, bSACLPresent;
        BOOL    bDefaulted;
        ACCESS_ALLOWED_ACE* pACE;
        HRESULT hr;
        PSID    pUserSid;
        PSID    pGroupSid;

        hr = Initialize();
        if(FAILED(hr))
                return hr;

        // get the existing DACL.
        if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
                goto failed;

        if (bDACLPresent)
        {
                if (pDACL)
                {
                        // allocate new DACL.
                        m_pDACL = (PACL) malloc(pDACL->AclSize);
                        if (m_pDACL == NULL)
                        {
                                hr = E_OUTOFMEMORY;
                                goto failedMemory;
                        }

                        // initialize the DACL
                        if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        for (int i = 0; i < pDACL->AceCount; i++)
                        {
                                if (!GetAce(pDACL, i, (void **)&pACE))
                                        goto failed;

                                if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
                                        goto failed;
                        }

                        if (!IsValidAcl(m_pDACL))
                                goto failed;
                }

                // set the DACL
                if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
                        goto failed;
        }

        // get the existing SACL.
        if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
                goto failed;

        if (bSACLPresent)
        {
                if (pSACL)
                {
                        // allocate new SACL.
                        m_pSACL = (PACL) malloc(pSACL->AclSize);
                        if (m_pSACL == NULL)
                        {
                                hr = E_OUTOFMEMORY;
                                goto failedMemory;
                        }

                        // initialize the SACL
                        if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        for (int i = 0; i < pSACL->AceCount; i++)
                        {
                                if (!GetAce(pSACL, i, (void **)&pACE))
                                        goto failed;

                                if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
                                        goto failed;
                        }

                        if (!IsValidAcl(m_pSACL))
                                goto failed;
                }

                // set the SACL
                if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
                        goto failed;
        }

        if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
                goto failed;

        if (FAILED(SetOwner(pUserSid, bDefaulted)))
                goto failed;

        if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
                goto failed;

        if (FAILED(SetGroup(pGroupSid, bDefaulted)))
                goto failed;

        if (!IsValidSecurityDescriptor(m_pSD))
                goto failed;

        return hr;

failed:
        hr = HRESULT_FROM_WIN32(hr);

failedMemory:
        if (m_pDACL)
        {
                free(m_pDACL);
                m_pDACL = NULL;
        }
        if (m_pSD)
        {
                free(m_pSD);
                m_pSD = NULL;
        }
        return hr;
}

HRESULT CVssSecurityDescriptor::AttachObject(HANDLE hObject)
{
        HRESULT hr;
        DWORD dwSize = 0;
        PSECURITY_DESCRIPTOR pSD = NULL;

        GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(hr);

        pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);
        if (pSD == NULL)
                return E_OUTOFMEMORY;

        if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                free(pSD);
                return hr;
        }

        hr = Attach(pSD);
        free(pSD);
        return hr;
}


HRESULT CVssSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        LPVOID pAce;
        ACE_HEADER *aceHeader;

        if (pSrc == NULL)
                return S_OK;

        if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
                return HRESULT_FROM_WIN32(GetLastError());

        // Copy all of the ACEs to the new ACL
        for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
        {
                if (!GetAce(pSrc, i, &pAce))
                        return HRESULT_FROM_WIN32(GetLastError());

                aceHeader = (ACE_HEADER *) pAce;

                if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
                        return HRESULT_FROM_WIN32(GetLastError());
        }

        return S_OK;
}

HRESULT CVssSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD dwAceFlags)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        DWORD returnValue;
        PSID principalSID;
        PACL oldACL, newACL = NULL;

        oldACL = *ppAcl;

        returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(returnValue))
                return returnValue;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL)
                GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

        ATLTRY(newACL = (PACL) new BYTE[aclSize]);
        if (newACL == NULL)
                return E_OUTOFMEMORY;

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                free(principalSID);
                delete [] newACL;
                return HRESULT_FROM_WIN32(GetLastError());
        }

        if (!AddAccessDeniedAceEx(newACL, ACL_REVISION2, dwAceFlags, dwAccessMask, principalSID))
        {
                free(principalSID);
                delete [] newACL;
                return HRESULT_FROM_WIN32(GetLastError());
        }

        returnValue = CopyACL(newACL, oldACL);
        if (FAILED(returnValue))
        {
                free(principalSID);
                delete [] newACL;
                return returnValue;
        }

        *ppAcl = newACL;
        newACL = NULL;
        
        if (oldACL != NULL)
                free(oldACL);
        free(principalSID);
        return S_OK;
}


HRESULT CVssSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD dwAceFlags)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        DWORD returnValue;
        PSID principalSID;
        PACL oldACL, newACL = NULL;

        oldACL = *ppAcl;

        returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(returnValue))
                return returnValue;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL)
                GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

        ATLTRY(newACL = (PACL) new BYTE[aclSize]);
        if (newACL == NULL)
                return E_OUTOFMEMORY;

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                free(principalSID);
                delete [] newACL;
                return HRESULT_FROM_WIN32(GetLastError());
        }

        returnValue = CopyACL(newACL, oldACL);
        if (FAILED(returnValue))
        {
                free(principalSID);
                delete [] newACL;                
                return returnValue;
        }

        if (!AddAccessAllowedAceEx(newACL, ACL_REVISION2, dwAceFlags, dwAccessMask, principalSID))
        {
                free(principalSID);
                delete [] newACL;                
                return HRESULT_FROM_WIN32(GetLastError());
        }

        *ppAcl = newACL;
        newACL = NULL;
        
        if (oldACL != NULL)
                free(oldACL);
        free(principalSID);
        return S_OK;
}


HRESULT CVssSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, PSID principalSID, DWORD dwAccessMask, DWORD dwAceFlags)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        DWORD returnValue;
        PACL oldACL, newACL = NULL;

        oldACL = *ppAcl;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL)
                GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

        ATLTRY(newACL = (PACL) new BYTE[aclSize]);
        if (newACL == NULL)
                return E_OUTOFMEMORY;

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                delete [] newACL;
                return HRESULT_FROM_WIN32(GetLastError());
        }

        if (!AddAccessDeniedAceEx(newACL, ACL_REVISION2, dwAceFlags, dwAccessMask, principalSID))
        {
                delete [] newACL;        
                return HRESULT_FROM_WIN32(GetLastError());
        }

        returnValue = CopyACL(newACL, oldACL);
        if (FAILED(returnValue))
        {
                delete [] newACL;        
                return returnValue;
        }

        *ppAcl = newACL;
        newACL = NULL;
        
        if (oldACL != NULL)
                free(oldACL);
        return S_OK;
}


HRESULT CVssSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, PSID principalSID, DWORD dwAccessMask, DWORD dwAceFlags)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        DWORD returnValue;
        PACL oldACL, newACL = NULL;

        oldACL = *ppAcl;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL)
                GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

        ATLTRY(newACL = (PACL) new BYTE[aclSize]);
        if (newACL == NULL)
                return E_OUTOFMEMORY;

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                delete [] newACL;
                return HRESULT_FROM_WIN32(GetLastError());
        }

        returnValue = CopyACL(newACL, oldACL);
        if (FAILED(returnValue))
        {
		  delete [] newACL;
                return returnValue;
        }

        if (!AddAccessAllowedAceEx(newACL, ACL_REVISION2, dwAceFlags, dwAccessMask, principalSID))
        {
                delete [] newACL;
                return HRESULT_FROM_WIN32(GetLastError());
        }

        *ppAcl = newACL;
        newACL = NULL;
        
        if (oldACL != NULL)
                free(oldACL);
        return S_OK;
}


HRESULT CVssSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        ULONG i;
        LPVOID ace;
        ACCESS_ALLOWED_ACE *accessAllowedAce;
        ACCESS_DENIED_ACE *accessDeniedAce;
        SYSTEM_AUDIT_ACE *systemAuditAce;
        PSID principalSID;
        DWORD returnValue;
        ACE_HEADER *aceHeader;

        returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(returnValue))
                return returnValue;

        GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

        for (i = 0; i < aclSizeInfo.AceCount; i++)
        {
                if (!GetAce(pAcl, i, &ace))
                {
                        free(principalSID);
                        return HRESULT_FROM_WIN32(GetLastError());
                }

                aceHeader = (ACE_HEADER *) ace;

                if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
                {
                        accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

                        if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
                        {
                                DeleteAce(pAcl, i);
                                free(principalSID);
                                return S_OK;
                        }
                } else

                if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
                {
                        accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

                        if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
                        {
                                DeleteAce(pAcl, i);
                                free(principalSID);
                                return S_OK;
                        }
                } else

                if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
                {
                        systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

                        if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
                        {
                                DeleteAce(pAcl, i);
                                free(principalSID);
                                return S_OK;
                        }
                }
        }
        free(principalSID);
        return S_OK;
}


HRESULT CVssSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
        HRESULT hr;
        TOKEN_PRIVILEGES tpPrevious;
        TOKEN_PRIVILEGES tp;
        DWORD  cbPrevious = sizeof(TOKEN_PRIVILEGES);
        LUID   luid;
        HANDLE hTokenUsed;

        // if no token specified open process token
        if (hToken == 0)
        {
                if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        return hr;
                }
        }
        else
                hTokenUsed = hToken;

        if (!LookupPrivilegeValue(NULL, privilege, &luid ))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }

        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        tp.Privileges[0].Attributes = 0;

        if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }

        tpPrevious.PrivilegeCount = 1;
        tpPrevious.Privileges[0].Luid = luid;

        if (bEnable)
                tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
        else
                tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

        if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }
        return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////
// Class - CVssSidCollection
//



CVssSidCollection::CVssSidCollection()
{
    m_bInitialized = false;
}


CVssSidCollection::~CVssSidCollection()
{
    for(INT nIndex = 0; nIndex < m_SidArray.GetSize(); nIndex++) {
        LocalFree(m_SidArray.GetKeyAt(nIndex));
        LocalFree((m_SidArray.GetValueAt(nIndex)).GetSid());
        LocalFree((m_SidArray.GetValueAt(nIndex)).GetName());
        LocalFree((m_SidArray.GetValueAt(nIndex)).GetDomain());
    }
}


// Get the total count of stored SIDs
INT CVssSidCollection::GetSidCount()
{
    BS_ASSERT(m_bInitialized);
    return m_SidArray.GetSize();
}


// Get the SID with the given index (starts with 0)
PSID CVssSidCollection::GetSid(INT nIndex) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::GetSid");

    BS_ASSERT(m_bInitialized);
    if ((nIndex < 0) || (nIndex >= GetSidCount()))
        ft.Throw( VSSDBG_GEN, E_UNEXPECTED, L"Index out of range %ld", nIndex);

    return (m_SidArray.GetValueAt(nIndex)).GetSid();
}


// Get the SID use with the given index
SID_NAME_USE CVssSidCollection::GetSidUse(INT nIndex) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::GetSidUse");

    BS_ASSERT(m_bInitialized);
    if ((nIndex < 0) || (nIndex >= GetSidCount()))
        ft.Throw( VSSDBG_GEN, E_UNEXPECTED, L"Index out of range %ld", nIndex);

    return (m_SidArray.GetValueAt(nIndex)).GetUse();
}


// Check if the the SID is allowed
bool CVssSidCollection::IsSidAllowed(INT nIndex) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::IsSidAllowed");

    BS_ASSERT(m_bInitialized);
    if ((nIndex < 0) || (nIndex >= GetSidCount()))
        ft.Throw( VSSDBG_GEN, E_UNEXPECTED, L"Index out of range %ld", nIndex);

    return (m_SidArray.GetValueAt(nIndex)).IsSidAllowed();
}

// Check if the the SID is local
bool CVssSidCollection::IsLocal(INT nIndex) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::IsLocal");

    BS_ASSERT(m_bInitialized);
    if ((nIndex < 0) || (nIndex >= GetSidCount()))
        ft.Throw( VSSDBG_GEN, E_UNEXPECTED, L"Index out of range %ld", nIndex);

    return (m_SidArray.GetValueAt(nIndex)).IsLocal();
}


// Get the SID with the given index (starts with 0)
LPWSTR CVssSidCollection::GetPrincipal(INT nIndex) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::GetPrincipal");
    
    BS_ASSERT(m_bInitialized);
    if ((nIndex < 0) || (nIndex >= GetSidCount()))
        ft.Throw( VSSDBG_GEN, E_UNEXPECTED, L"Index out of range %ld", nIndex);

    return m_SidArray.GetKeyAt(nIndex);
}


LPWSTR CVssSidCollection::GetName(INT nIndex) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::GetName");
    
    BS_ASSERT(m_bInitialized);
    if ((nIndex < 0) || (nIndex >= GetSidCount()))
        ft.Throw( VSSDBG_GEN, E_UNEXPECTED, L"Index out of range %ld", nIndex);

    return (m_SidArray.GetValueAt(nIndex)).GetName();;
}


LPWSTR CVssSidCollection::GetDomain(INT nIndex) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::GetDomain");
    
    BS_ASSERT(m_bInitialized);
    if ((nIndex < 0) || (nIndex >= GetSidCount()))
        ft.Throw( VSSDBG_GEN, E_UNEXPECTED, L"Index out of range %ld", nIndex);

    return (m_SidArray.GetValueAt(nIndex)).GetDomain();;
}


// Add a well-known SID to the internal map
void CVssSidCollection::AddWellKnownSid(
    IN  WELL_KNOWN_SID_TYPE type
    )
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::AddWellKnownSid");

    // Get the SID size
	DWORD cbSid = 0;
	if (CreateWellKnownSid(type, NULL, NULL, &cbSid))
	    ft.TranslateWin32Error(VSSDBG_GEN, L"CreateWellKnownSid(type, NULL, NULL, &dwSid)");
	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	    ft.TranslateWin32Error(VSSDBG_GEN, L"CreateWellKnownSid(type, NULL, NULL, &dwSid)");

    // Allocate the SID
    CVssAutoLocalPtr<PSID> pSID;
    pSID.AllocateBytes(cbSid);

	// Create the SID
	if (!CreateWellKnownSid(type, NULL, pSID, &cbSid))
	    ft.TranslateWin32Error(VSSDBG_GEN, L"CreateWellKnownSid(type, NULL, pSID, [%ld])", cbSid);

    // Get the string representation in the "domain\name" format

    // First get the sizes
    DWORD cchName = 0;
    DWORD cchDomain = 0;
    SID_NAME_USE peUse;
	if (LookupAccountSid(NULL, pSID, NULL, &cchName, NULL, &cchDomain, &peUse))
	    ft.TranslateWin32Error(VSSDBG_GEN, L"LookupAccountSid()");
	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	    ft.TranslateWin32Error(VSSDBG_GEN, L"LookupAccountSid()");

    // Now allocate the buffers
    CVssAutoLocalString pwszName, pwszDomain, pwszComposedName;
    pwszName.AllocateString(cchName);
    pwszDomain.AllocateString(cchDomain);

    // Try again
	if (!LookupAccountSid(NULL, pSID, pwszName, &cchName, pwszDomain, &cchDomain, &peUse))
	    ft.TranslateWin32Error(VSSDBG_GEN, L"LookupAccountSid()");

    // Check to see if the account is local.
    // and also complete the m_pwszBuiltinDomain if the sid is for Adminstrators
    bool bLocalAccount = VerifyIsLocal(pwszDomain, (WinBuiltinAdministratorsSid == type));

    // Compose the big name ("domain\name")
    pwszComposedName.CopyFrom(pwszDomain);
    pwszComposedName.Append(L"\\");
    pwszComposedName.Append(pwszName);

	// Now add it to the array
    if (!m_SidArray.Add(pwszComposedName, 
            CVssSidWrapper(true, pSID, peUse, pwszName, pwszDomain, bLocalAccount))) 
		ft.ThrowOutOfMemory(VSSDBG_GEN);

	// Transfer ownership into the array
	pSID.Detach();
	pwszComposedName.Detach();
	pwszName.Detach();
	pwszDomain.Detach();
}


// Add a user to the internal map based on the user name
// Return "false" if the user name does not correspond to a real user.
bool CVssSidCollection::AddUser(
    IN  LPCWSTR pwszUser,
    IN  bool bAllow
    )
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::AddSidOrUser");

    if ( (pwszUser == NULL) || (pwszUser[0] == L'\0'))
        ft.Throw( VSSDBG_GEN, E_UNEXPECTED, L"Invalid argument '%s'", pwszUser);

    // First, check to see if this is a valid user name
    DWORD cbSid = 0;
    DWORD cchDomain = 0;
    SID_NAME_USE sbUse;
    if (LookupAccountName( NULL, pwszUser, NULL, &cbSid, NULL, &cchDomain, &sbUse))
        ft.TranslateWin32Error(VSSDBG_GEN, L"LookupAccountName( NULL, %s, NULL, p, NULL, p, p)", pwszUser);

    // If the user does not exist, return false
	if (GetLastError() == ERROR_NONE_MAPPED)
	    return false;
	
	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) 
        ft.TranslateWin32Error(VSSDBG_GEN, L"LookupAccountName( NULL, %s, NULL, p, NULL, p, p)", pwszUser);

    // It appears we are on the correct path. 
    // Allocate the SID and the domain
    CVssAutoLocalPtr<PSID> pSID;
    pSID.AllocateBytes(cbSid);
    CVssAutoLocalString pwszDomain;
    pwszDomain.AllocateString(cchDomain);

    // Retrieve the SID
    if (!LookupAccountName( NULL, pwszUser, 
            pSID, &cbSid, pwszDomain, &cchDomain, &sbUse))
        ft.TranslateWin32Error(VSSDBG_GEN, L"LookupAccountName( NULL, %s,...)", pwszUser);

    // Check to see if the account is local.
    bool bLocalAccount = VerifyIsLocal(pwszDomain, false);

    // Now we are sure that the user is real
    CVssAutoLocalString pwszComposedName, pwszUserName;
    pwszUserName.CopyFrom(pwszUser);

    // Compose the big name ("domain\name")
    pwszComposedName.CopyFrom(pwszDomain);
    pwszComposedName.Append(L"\\");
    pwszComposedName.Append(pwszUserName);

	// Now we have both the string and the SID. Add them into the array.
    if (!m_SidArray.Add(pwszComposedName, 
            CVssSidWrapper(bAllow, pSID, sbUse, pwszUserName, pwszDomain, bLocalAccount))) 
		ft.ThrowOutOfMemory(VSSDBG_GEN);

	// Transfer ownership into the array
	pSID.Detach();
	pwszComposedName.Detach();
	pwszUserName.Detach();
	pwszDomain.Detach();

    return true;
}


 // Return "true" if the user name with the given domain is local user/group
bool CVssSidCollection::VerifyIsLocal(
    IN  LPCWSTR pwszDomain,
    IN  bool bIsAdministratorsAccount
    )
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::VerifyIsLocal");

    // If this is the Administrators SID, then complete the m_pwszBuiltinDomain field.
    // Otherwise check to see if the account is local.
    if (bIsAdministratorsAccount) 
    {
        BS_ASSERT(!m_pwszBuiltinDomain.IsValid());
        BS_ASSERT(m_SidArray.GetSize() == 0);
        m_pwszBuiltinDomain.CopyFrom(pwszDomain);
        return true;
    }
    else
    {
        BS_ASSERT(m_pwszBuiltinDomain.IsValid());
        BS_ASSERT(m_SidArray.GetSize() != 0);
        
        // we consider it local if the domain is "BUILTIN" or the computer name
        if(0 == _wcsicmp(pwszDomain, m_pwszBuiltinDomain))
            return true;

        // get the computer name
        WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD dwSize = SIZEOF_ARRAY(wszComputerName);
        if (0 == GetComputerNameW(wszComputerName, &dwSize))
            ft.TranslateWin32Error(VSSDBG_GEN, L"GetComputerNameW");

        // If this is the computer name, return TRUE
        if(0 == _wcsicmp(pwszDomain, wszComputerName))
            return true;
    }

    return false;
}



//
// Initialize the security descriptor from registry
// Contents: Admin, BO, System always enabled.
// The rest of users are read from the SYSTEM\\CurrentControlSet\\Services\\VSS\\VssAccessControl key
// The format of this registry key is a set of values of the form:
//      REG_DWORD Name "domain1\user1", 1
//      REG_DWORD Name "domain2\user2", 1
//      REG_DWORD Name "domain3\user3", 0
// where 1 means "Allow" and 0 means "Deny"
//
void CVssSidCollection::Initialize()
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::Initialize");

    // only initialize once
    if (m_bInitialized)
    	return;

    //
    // Add well-known SIDs
    //

    // This MUST be added first since fills out the m_pwszBuiltinDomain member
    AddWellKnownSid(WinBuiltinAdministratorsSid);

    AddWellKnownSid(WinBuiltinBackupOperatorsSid);

    AddWellKnownSid(WinLocalSystemSid); 
    
    //
    // Add other users from registry
    //

    // Open the registry and enumerate all users specified there
	CVssRegistryKey keyUserList(KEY_READ);
	if (keyUserList.Open(HKEY_LOCAL_MACHINE, x_wszVssAccessControlKey))
	{
    	CVssRegistryValueIterator iterator;
    	iterator.Attach(keyUserList);

    	// for each value take the value name as the user name (in the "domain\user" format)
    	for(;!iterator.IsEOF();iterator.MoveNext())
    	{
    	    // Check to see ifthe value is of the right type
    	    if (iterator.GetCurrentValueType() != REG_DWORD) {
                ft.LogError(VSS_ERROR_WRONG_REG_USER_VALUE_TYPE, 
                    VSSDBG_GEN << iterator.GetCurrentValueName() << x_wszVssAccessControlKey);
                continue;
    	    }

            // Get the allow/deny flag
    	    DWORD dwValue = 0;
            iterator.GetCurrentValueContent(dwValue);

            // Interpret the allow/deny flag
            bool bIsAllowed;
            switch(dwValue) {
            case 0:
                bIsAllowed = false;
                break;
            case 1:
                bIsAllowed = true;
                break;
            default:
                ft.LogError(VSS_ERROR_WRONG_REG_USER_VALUE, 
                    VSSDBG_GEN << iterator.GetCurrentValueName() 
                        << x_wszVssAccessControlKey << (INT)dwValue);
                continue;
            }

    	    // Add the user (if exists)
    	    if (!AddUser(iterator.GetCurrentValueName(), bIsAllowed )) {
                ft.LogError(VSS_ERROR_WRONG_USER_NAME, 
                    VSSDBG_GEN << iterator.GetCurrentValueName() << x_wszVssAccessControlKey);
                continue;
    	    }
    	}
	}

    // Build the security descriptor
    m_SD.Initialize();

    // Add a valid owner (the value does not matter)
    CAutoSid userSid;
    userSid.CreateBasicSid(WinLocalSystemSid);
    ft.hr = m_SD.SetOwner(userSid.Get());
    if (ft.HrFailed())
        ft.TranslateGenericError( VSSDBG_COORD, ft.hr, L"SetOwner");

    // Add a valid group (the value does not matter)
    CAutoSid groupSid;
    groupSid.CreateBasicSid(WinBuiltinAdministratorsSid);
    ft.hr = m_SD.SetGroup(groupSid.Get());
    if (ft.HrFailed())
        ft.TranslateGenericError( VSSDBG_COORD, ft.hr, L"SetGroup");

    // Make sure the SACL is NULL (not supported by COM)
    if (m_SD.m_pSACL) {
        free(m_SD.m_pSACL);
        m_SD.m_pSACL= NULL;
    }

    // Add principals to the DACL
    for (INT nIndex = 0; nIndex < m_SidArray.GetSize(); nIndex++)
    {
        if ((m_SidArray.GetValueAt(nIndex)).IsSidAllowed())
        {
            ft.hr = m_SD.Allow((m_SidArray.GetValueAt(nIndex)).GetSid(), 
                            COM_RIGHTS_EXECUTE);
            if (ft.HrFailed())
                ft.TranslateGenericError( VSSDBG_GEN, ft.hr, 
                    L"m_SD.Allow(%s, COM_RIGHTS_EXECUTE);", 
                        m_SidArray.GetKeyAt(nIndex));
        }
        else
        {
            ft.hr = m_SD.Deny((m_SidArray.GetValueAt(nIndex)).GetSid(), 
                            COM_RIGHTS_EXECUTE);
            if (ft.HrFailed())
                ft.TranslateGenericError( VSSDBG_GEN, ft.hr, 
                    L"m_SD.Deny(%s, COM_RIGHTS_EXECUTE);", 
                        m_SidArray.GetKeyAt(nIndex));
        }
    }

    BS_ASSERT(::IsValidSecurityDescriptor(m_SD));   

    // We mark object as initialized (since we need it in GetXXX routines)
    m_bInitialized = true;

}


// determine if the process is a valid writer
bool CVssSidCollection::IsProcessValidWriter()
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::IsProcessValidWriter");

    CVssAutoCppPtr<TOKEN_USER*> ptrTokenOwner = GetClientTokenUser(FALSE);
    return  IsSidAllowedToFire(ptrTokenOwner.Get()->User.Sid);
}


bool CVssSidCollection::IsSidAllowedToFire(
    IN  PSID psid
    )
{
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::IsSidAllowedToFire");

    BS_ASSERT(psid);

    // First check if the SID is explicitely dissalowed
    if (CheckIfExplicitelySpecified(psid, false))
    {
        if ( g_cDbgTrace.IsTracingEnabled() ) {
            CVssAutoLocalString aszWriterSid;
            if (ConvertSidToStringSid( psid, aszWriterSid.ResetAndGetAddress()))
                ft.Trace( VSSDBG_XML, L"WriterSid: %s was explicitely denied to fire", aszWriterSid.Get() );
        }
    
        return false;
    }

    // Then check if the SID is explicitely allowed
    if (CheckIfExplicitelySpecified(psid, true))
        return true;

    if ( g_cDbgTrace.IsTracingEnabled() ) {
        CVssAutoLocalString aszWriterSid;
        if (ConvertSidToStringSid( psid, aszWriterSid.ResetAndGetAddress()))
            ft.Trace( VSSDBG_XML, L"WriterSid: %s was implicitely denied to fire", aszWriterSid.Get() );
    }

    // Check failed
    return false;
}

//
//  if (bCheckToBeDone == false) check if the SID is explicitely denied to fire
//  if (bCheckToBeDone == true) check if the SID is explicitely allowed to fire
//
//  Return true if the check succeeded or false otherwise
//
bool CVssSidCollection::CheckIfExplicitelySpecified(
    IN  PSID psid,
    IN  bool bCheckToBeDone
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::CheckIfExplicitelySpecified");

    BS_ASSERT(psid);

    // Now look only for the checked SIDs 
    for (INT nIndex = 0; nIndex < GetSidCount(); nIndex++)
    {
        // Ignore opposite checks
        if (bCheckToBeDone != IsSidAllowed(nIndex))
            continue;
        
        switch(GetSidUse(nIndex))
        {
        case SidTypeUser:
        case SidTypeComputer:
            if (EqualSid(psid, GetSid(nIndex)))
                return true;
            break;
        
        case SidTypeAlias:
        case SidTypeWellKnownGroup: 
            if (IsLocal(nIndex)) {
                if (IsSidRelatedWithLocalSid(psid, GetName(nIndex), GetSid(nIndex)))
                    return true;
            }
            else {
                if (EqualSid(psid, GetSid(nIndex)))
                    return true;
            }
            break;

        default:
            // Unknown SID type in the collection. Ignoring.
            ft.Trace(VSSDBG_GEN, 
                L"Unknown SID %s with type %ld in the SID collection. Ignoring. [%d]", 
                GetPrincipal(nIndex), GetSidUse(nIndex), nIndex);
            BS_ASSERT(false);
            break;
        }
    }

    return false;
}


// is a local group mentioned in the SID collection or is even a member of the SID collection
bool CVssSidCollection::IsSidRelatedWithLocalSid(
        IN  PSID pSid,
        IN  LPWSTR pwszWellKnownPrincipal,
        IN  PSID pWellKnownSid
        )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSidCollection::IsSidRelatedWithLocalSid");

    // Assert parameters
    BS_ASSERT(pSid);
    BS_ASSERT(pwszWellKnownPrincipal);
    BS_ASSERT(pWellKnownSid);

    if (EqualSid(pSid, pWellKnownSid) == TRUE)
        return true;

    // get list of local group members
    CVssAutoNetApiPtr apBuffer;
    DWORD_PTR ResumeHandle = NULL;
    DWORD cEntriesRead = 0, cEntriesTotal = 0;
    NET_API_STATUS status = 
        NetLocalGroupGetMembers(
            NULL,
            pwszWellKnownPrincipal,
            0,
            apBuffer.ResetAndGetAddress(),
            MAX_PREFERRED_LENGTH,
            &cEntriesRead,
            &cEntriesTotal,
            &ResumeHandle
            );

    // If this is not a group - then compare SIDs directly 
    // (for example for LocalSystem account)
    if (status == NERR_GroupNotFound)
        return false;

    // We have a different error?
    if (status != NERR_Success) 
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(status), 
                L"NetGroupGetUsers(%s)", pwszWellKnownPrincipal);

    BS_ASSERT(cEntriesRead == cEntriesTotal);

    // loop through member list to see if any sids mach the sid of the owner
    // of the subscription
    LOCALGROUP_MEMBERS_INFO_0 *rgMembers = (LOCALGROUP_MEMBERS_INFO_0 *) apBuffer.Get();
    for(DWORD iEntry = 0; iEntry < cEntriesRead; iEntry++)
        {
        PSID psidMember = rgMembers[iEntry].lgrmi0_sid;
        if (EqualSid(psidMember, pSid))
            return true;
        }

    return false;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\delete.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Delete.cxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   02/01/2000

Revision History:

    Name        Date        Comments

    aoltean     02/01/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>

#include "vs_idl.hxx"


#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"
#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
 

#include "ntddsnap.h"
#include "ntddvol.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDELEC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsSoftwareProvider::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots that match the proper filter criteria.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then S_OK is returned.

Throws:

    E_ACCESSDENIED
        - The user is not an administrator (this should be the SYSTEM account).
    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::DeleteSnapshots" );

    try
    {
    	// Zero out parameters
		::VssZeroOut(plDeletedSnapshots);
		::VssZeroOut(pNondeletedSnapshotID);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				L"  SourceObjectId = " WSTR_GUID_FMT L"\n"
				L"  eSourceObjectType = %d\n"
				L"  bForceDelete = %d"
				L"  plDeletedSnapshots = %p"
				L"  pNondeletedSnapshotID = %p",
				GUID_PRINTF_ARG( SourceObjectId ),
				eSourceObjectType,
				bForceDelete,			
				plDeletedSnapshots,		
				pNondeletedSnapshotID
             	);

		// Check arguments
		BS_ASSERT(plDeletedSnapshots);
		if (plDeletedSnapshots == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"plDeletedSnapshots == NULL");
		BS_ASSERT(pNondeletedSnapshotID);
		if (pNondeletedSnapshotID == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pNondeletedSnapshotID == NULL");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Freeze the context
        //
        FreezeContext();

		// Delete snapshots based on the given filter
        switch(eSourceObjectType) {
		case VSS_OBJECT_SNAPSHOT_SET:
		case VSS_OBJECT_SNAPSHOT:
    		ft.hr = InternalDeleteSnapshots(SourceObjectId,
    					eSourceObjectType,
    					GetContextInternal(),
    					plDeletedSnapshots,
    					pNondeletedSnapshotID);
			break;
			
		default:
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Incompatible type %d", eSourceObjectType);
		}
		
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods


HRESULT CVsSoftwareProvider::InternalDeleteSnapshots(
    IN      VSS_ID			SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN      LONG            lContext,
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots in the snapshot set.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::InternalDeleteSnapshotSet" );
    
	BS_ASSERT(*plDeletedSnapshots == 0);
	BS_ASSERT(*pNondeletedSnapshotID == GUID_NULL);

	// Enumerate snapshots through all the volumes
	CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
	CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes
	bool bObjectFound = false;
	bool bFinished = false;
	
	// Search for snapshots in all mounted volumes
	CVssAutoPWSZ awszSnapshotName;
	WCHAR wszVolumeName[MAX_PATH+1];
	CVssVolumeIterator volumeIterator;
	while(!bFinished) {
	
		// Get the volume name
		if (!volumeIterator.SelectNewVolume(ft, wszVolumeName, MAX_PATH))
		    break;

		// Check if the snapshot(s) within this snapshot set is belonging to that volume
		// Open a IOCTL channel on that volume
		// Eliminate the last backslash in order to open the volume
		// The call will throw on error
		ft.hr = volumeIChannel.Open(ft, wszVolumeName, true, false, VSS_ICHANNEL_LOG_NONE, 0);
		if (ft.HrFailed()) {
		    ft.hr = S_OK;
		    continue;
		}

		// Get the list of snapshots
		// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
		// supported then try with the next volume.

		ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
		if (ft.HrFailed()) {
			ft.hr = S_OK;
			continue;
		}

		// Get the length of snapshot names multistring
		ULONG ulMultiszLen;
		volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
		// Try to find the snapshot with the corresponding Id
		DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif
        bool bFirstSnapshot = true;
		for (;volumeIChannel.UnpackZeroString(ft, awszSnapshotName.GetRef()) && !bFinished; bFirstSnapshot = false) 
		{
			// Compose the snapshot name in a user-mode style
			WCHAR wszUserModeSnapshotName[MAX_PATH];
            ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
                x_wszGlobalRootPrefix, awszSnapshotName );
				
			// Open that snapshot and verify if it has our ID
            // If we fail we do not throw since the snapshot may be deleted in the meantime
            // Do NOT eliminate the trailing backslash
            // The call will NOT throw on error
            //
            //  Open the snapshot with no access rights for perf reasons (bug #537974)
			ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, false, 
			            VSS_ICHANNEL_LOG_NONE, 0);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be opened", wszUserModeSnapshotName);
                continue;
            }

			// Get the application buffer
            // If we fail we do not throw since the snapshot may be deleted in the meantime
			ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be queried for properties",
                          wszUserModeSnapshotName);
                continue;
            }

            // Load the snapshot properties
            VSS_SNAPSHOT_PROP prop;
    		::VssZeroOut(&prop);
            
            LONG lStructureContext;
            bool bHidden;

            // Ignore structures with unrecognized AppInfoID (bug # 585939)
            if (!CVssQueuedSnapshot::LoadStructure(snapshotIChannel, 
                                        &prop, &lStructureContext, &bHidden, false))
                continue;

            // Filter, if needed
            switch(eSourceObjectType) {
    		case VSS_OBJECT_SNAPSHOT_SET:
				// Check if this snapshot belongs to the snapshot set.
				if (prop.m_SnapshotSetId != SourceObjectId) 
					continue;
				break;

    		case VSS_OBJECT_SNAPSHOT:
				if (prop.m_SnapshotId != SourceObjectId)
					continue;
    			break;
    			
    		default:
    			BS_ASSERT(false);
    			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Incompatible type %d", eSourceObjectType);
    		}

              // If we've found a snapshot with a matching GUID, than no other snapshots
              // will match;  this is the last iteration of the loop.
    		bFinished = (eSourceObjectType == VSS_OBJECT_SNAPSHOT);
		
			// Filter more.
			if ((lContext != VSS_CTX_ALL) && 
			    (lContext != lStructureContext))
			    continue;

			// Check if the snapshot is already deleted
			if (bHidden)
			    continue;

			// We found a snapshot belonging to the set.
			bObjectFound = true;

			// Set in order to deal with failure cases
			(*pNondeletedSnapshotID) = prop.m_SnapshotId;

            // Try to delete/hide the snapshot. We ignore the return code
            DeleteOrHideSnapshot(
                bFirstSnapshot, 
                wszVolumeName, 
                awszSnapshotName.GetRef(),
                wszUserModeSnapshotName, 
                prop,
                lStructureContext);
            
			(*plDeletedSnapshots)++;

    		//  Delete all the subsequent hidden snapshots here
			PurgeSnapshotsOnVolume(wszVolumeName, false);
		}

#ifdef _DEBUG
		// Check if all strings were browsed correctly
		DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset - dwInitialOffset <= ulMultiszLen);
#endif
	}

	if (!bObjectFound)
		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Object not found");

	if (ft.HrSucceeded())
		(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}


void CVsSoftwareProvider::PurgeSnapshots(
    IN  bool bPurgeAlsoAutoReleaseSnapshots
    )

/*++

Description:

	This routine deletes all snapshots in the snapshot set.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PurgeSnapshots" );
    

	// Enumerate snapshots through all the volumes
	WCHAR wszVolumeName[MAX_PATH+1];

	// Search for snapshots in all mounted volumes
	CVssVolumeIterator volumeIterator;
	while(true) {
	
		// Get the volume name
		if (!volumeIterator.SelectNewVolume(ft, wszVolumeName, MAX_PATH))
		    break;

        // Check to see if the volume is snapshotted
        // If is does not have snapshots, ignore it.
        LONG lVolAttr = CVsSoftwareProvider::GetVolumeInformationFlags(wszVolumeName, VSS_CTX_ALL, NULL, FALSE);
        if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED) == 0)
            continue;

        BS_ASSERT(lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT);

        // The volume has snapshots. Purge the hidden ones.
        PurgeSnapshotsOnVolume(wszVolumeName, bPurgeAlsoAutoReleaseSnapshots);
	}
}


void CVsSoftwareProvider::PurgeSnapshotsOnVolume(
    IN      VSS_PWSZ		wszVolumeName,
    IN      bool            bPurgeAlsoAutoReleaseSnapshots,
    IN      DWORD           dwMaxTimewarpSnapshots /* = MAXDWORD */
    )

/*++

Description:

	This routine deletes, if possible, all hidden snapshots starting with the oldest one.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PurgeSnapshotsOnVolume" );
    
	BS_ASSERT(wszVolumeName);

    ft.Trace( VSSDBG_SWPRV, L"Parameters: %s %s", wszVolumeName, bPurgeAlsoAutoReleaseSnapshots? L"TRUE": L"FALSE");

	// Enumerate snapshots through all the volumes
	CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
	CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes

    try
    {
    	// Open a IOCTL channel on that volume
    	// Eliminate the last backslash in order to open the volume
    	// The call will throw on error
    	volumeIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV, 0);

        //  Compute the number of timewarp snapshots to be deleted (if needed)
        DWORD dwTimewarpSnapshotsToBeDeleted = 0;
        if (dwMaxTimewarpSnapshots != MAXDWORD)
        {
            DWORD dwTimewarpSnapshots = GetTimewarpSnapshotsCount(volumeIChannel);

            // Compute the number of snapshots to be deleted
            if (dwTimewarpSnapshots > dwMaxTimewarpSnapshots)
                dwTimewarpSnapshotsToBeDeleted = dwTimewarpSnapshots - dwMaxTimewarpSnapshots;

            ft.Trace(VSSDBG_SWPRV, L"Timewarp snapshots to be deleted: %lu from %lu (max: %lu)", 
                dwTimewarpSnapshotsToBeDeleted, dwTimewarpSnapshots, dwMaxTimewarpSnapshots);
        }

    	// Get the list of snapshots
    	volumeIChannel.ResetOffsets();
    	volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, true, VSS_ICHANNEL_LOG_PROV);

    	// Get the length of snapshot names multistring
    	ULONG ulMultiszLen;
    	volumeIChannel.Unpack(ft, &ulMultiszLen);

        // Enumerate through all snapshots, starting with the oldest one.
        // When we encounter a snapshot to be deleted/hidden we will delete it if there are no older snapshots.
        // Otherwise we will just hide it.
        bool bTrueDeleteMode = true;
        
        // 1) If (bPurgeAlsoAutoReleaseSnapshots == false) We will try to delete 
        // each hidden snapshot starting with the olderst one
        // We will stop when we will encounter the first non-hidden snapshot
        // 2) Else (bPurgeAlsoAutoReleaseSnapshots == true) we are in OnLoad and we will try to delete 
        // each hidden snapshot and each auto-released snapshot (the bTrueDeleteMode = true phase). After encountering the first 
        // non-hidden and non-autoreleased snapshot (the bTrueDeleteMode = false phase) 
        // we cannot delete snapshots anymore but we will mark all autodelete snapshots as hidden.
    	CVssAutoPWSZ awszSnapshotName;
    	for (;volumeIChannel.UnpackZeroString(ft, awszSnapshotName.GetRef());) 
    	{
    		// Compose the snapshot name in a user-mode style
    		WCHAR wszUserModeSnapshotName[MAX_PATH];
            ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
                x_wszGlobalRootPrefix, awszSnapshotName );
    			
    		// Open that snapshot and verify if it has our ID
            // If we fail we do not throw since the snapshot may be deleted in the meantime
            // Do NOT eliminate the trailing backslash
            // The call will NOT throw on error
            //
            //  Open the snapshot with no access rights for perf reasons (bug #537974)
    		ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, true, 
    		            VSS_ICHANNEL_LOG_PROV, 0);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be opened", wszUserModeSnapshotName);
                break; // the snapshot dissapeared in the meantime?
            }

    		// Get the application buffer
            // If we fail we do not throw since the snapshot may be deleted in the meantime
    		ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be queried for properties",
                          wszUserModeSnapshotName);
                break; // the snapshot dissapeared in the meantime?
            }

            // Load the snapshot properties
            VSS_SNAPSHOT_PROP prop;
    		::VssZeroOut(&prop);
    		
            LONG lContext;
            bool bHidden;

            // Ignore structures with unrecognized AppInfoID (bug # 585939)
            if (!CVssQueuedSnapshot::LoadStructure(snapshotIChannel, &prop, &lContext, &bHidden, false))
            {
                bTrueDeleteMode = false;
                continue;
            }

            // If the snaphsot is already hidden and there is no need to delete it, just continue
            if (bHidden && !bTrueDeleteMode)
                continue;

    		// If the snapshot is not hidden, see if we need to delete it.
    		if (!bHidden)
    		{
        		if (bPurgeAlsoAutoReleaseSnapshots && ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) == 0))
                {   
                    // We encountered an auto-delete snapshot?
                    // If yes, delete it (or make it hidden). If not, continue.
                    // If this is an old timewarp snapshot, delete it
                    ft.Trace(VSSDBG_SWPRV, L"Deleting AutoRelease snapshot %s", 
                        wszUserModeSnapshotName);
                }
        		else if ((dwTimewarpSnapshotsToBeDeleted > 0) && (lContext == VSS_CTX_CLIENT_ACCESSIBLE))
        		{
                    // If this is an old timewarp snapshot, delete it
                    ft.Trace(VSSDBG_SWPRV, L"Deleting old Timewarp snapshot %s [index %lu]", 
                        wszUserModeSnapshotName, dwTimewarpSnapshotsToBeDeleted);

                    // Decrease the number of Timewarp snapshots to be deleted in next iterations...
                    dwTimewarpSnapshotsToBeDeleted--;
        		}
                else
                {
                    // We encountered a true snapshot which should not be deleted.
                    // From now on, we will hide the newer snapshots and not attempt to really delete them
                    bTrueDeleteMode = false;
        		    continue;
                }
            }

            // Try to delete/hide the snapshot. We ignore the return code
            DeleteOrHideSnapshot(
                bTrueDeleteMode, 
                wszVolumeName, 
                awszSnapshotName.GetRef(),
                wszUserModeSnapshotName, 
                prop,
                lContext);
    	}
    }
    VSS_STANDARD_CATCH(ft)
        
    if (ft.HrFailed())
        ft.Trace(VSSDBG_SWPRV, 
            L"Error 0x%08lx detected while purging snapshots on %s volume ", ft.hr, wszVolumeName);
}


// Delete or hide the snapshot, depending on the first boolean flag
// The return value is TRUE if the snapshot was deleted.
bool CVsSoftwareProvider::DeleteOrHideSnapshot(
    IN  bool bTrueDeleteMode,
    IN  LPWSTR wszVolumeName,
    IN  LPWSTR wszSnapshotName,
    IN  LPWSTR wszUserModeSnapshotName,
    IN  VSS_SNAPSHOT_PROP & prop,
    IN  LONG lContext
    )

/*++

Description:

    This routine deletes or hides the given snapshot.

Returns:

    TRUE - if the snapshot waas hidden/deleted,

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::DeleteOrHideSnapshot" );

    try
    {
        // Delete or hide the snapshot
        if (bTrueDeleteMode)
        {
            // Delete the snapshot
            BS_ASSERT(wszVolumeName);
            BS_ASSERT(wszSnapshotName);
            
            CVssIOCTLChannel volumeIChannel;    // For snapshots deletion
            
            // We found a snapshot. 
            volumeIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);
            
            // Pack the snapshot name
            volumeIChannel.PackSmallString(ft, wszSnapshotName);
            
            // Delete the snapshot
            volumeIChannel.Call(ft, IOCTL_VOLSNAP_DELETE_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV_NOTFOUND);
        }
        else
        {
            // Open that snapshot in "write mode"
            // If we fail we do not throw since the snapshot may be deleted in the meantime
            // Do NOT eliminate the trailing backslash
            // The call will NOT throw on error
            CVssIOCTLChannel snapshotIWriteChannel;
            ft.hr = snapshotIWriteChannel.Open(ft, wszUserModeSnapshotName, 
                        false, true, VSS_ICHANNEL_LOG_PROV);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be opened", wszUserModeSnapshotName);
                return false; // the snapshot dissapeared in the meantime?
            }

            // Save the snapshot properties (with the "hidden" flag turned on)
            CVssQueuedSnapshot::SaveStructure(snapshotIWriteChannel, &prop, lContext, true);

            // Send the IOCTL
            snapshotIWriteChannel.Call(ft, IOCTL_VOLSNAP_SET_APPLICATION_INFO, 
                true, VSS_ICHANNEL_LOG_PROV);

            // Dismount the snapshot (bug #585945)
            snapshotIWriteChannel.ResetOffsets();
            snapshotIWriteChannel.Call(ft, FSCTL_DISMOUNT_VOLUME, true, VSS_ICHANNEL_LOG_PROV);

            // Take the snapshot offline (bug #585945)
            snapshotIWriteChannel.ResetOffsets();
            snapshotIWriteChannel.Call(ft, IOCTL_VOLUME_OFFLINE, true, VSS_ICHANNEL_LOG_PROV);
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.HrSucceeded();
}


DWORD CVsSoftwareProvider::GetTimewarpSnapshotsCount(
    CVssIOCTLChannel&  volumeIChannel
    ) throw(HRESULT)

/*++

Description:

    This routine deletes or hides the given snapshot.

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::GetTimewarpSnapshotsCount" );

    DWORD dwTimewarpSnapshots = 0;

    // Get the list of snapshots
    volumeIChannel.ResetOffsets();
    volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, true, VSS_ICHANNEL_LOG_PROV);

    // Get the length of snapshot names multistring
    ULONG ulMultiszLen;
    volumeIChannel.Unpack(ft, &ulMultiszLen);

    // Enumerate through all snapshots, starting with the oldest one.
    CVssAutoPWSZ awszSnapshotName;
    for (;volumeIChannel.UnpackZeroString(ft, awszSnapshotName.GetRef());) 
    {
        // Compose the snapshot name in a user-mode style
        WCHAR wszUserModeSnapshotName[MAX_PATH];
        ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
            x_wszGlobalRootPrefix, awszSnapshotName );
            
        // Open that snapshot and verify if it is a timewarp snapshot
        CVssIOCTLChannel snapshotIChannel;
        ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, true, 
                    VSS_ICHANNEL_LOG_PROV, 0);
        if (ft.HrFailed()) {
            ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be opened", wszUserModeSnapshotName);
            continue; // the snapshot dissapeared in the meantime?
        }

        // Get the application buffer
        // If we fail we do not throw since the snapshot may be deleted in the meantime
        ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
        if (ft.HrFailed()) {
            ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be queried for properties",
                      wszUserModeSnapshotName);
            continue; // the snapshot dissapeared in the meantime?
        }

        // Unpack the length of the application buffer
        ULONG ulLen;
        snapshotIChannel.Unpack(ft, &ulLen);
        
        if (ulLen < sizeof(GUID)) {
            BS_ASSERT(false);
            ft.Trace(VSSDBG_SWPRV, L"Warning: small size snapshot detected: %s %ld", 
                snapshotIChannel.GetDeviceName(), ulLen);
            ft.m_hr = S_OK;
            continue;
        }
        
        // Unpack the Appinfo ID
        VSS_ID AppinfoId;
        snapshotIChannel.Unpack(ft, &AppinfoId);

        // Check if this is a timewarp snapshot
        if (AppinfoId == VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE)
            dwTimewarpSnapshots++;
    }

    return dwTimewarpSnapshots;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by swprv.rc
//
#define IDS_PROJNAME                    100
#define IDR_SWPRV                       101
#define IDS_SERVICE_DESCRIPTION         102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\mgmt.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Mgmt.cxx | Implementation of IVssSnapshotMgmt
    @end

Author:

    Adi Oltean  [aoltean]  03/05/2001

Revision History:

    Name        Date        Comments
    aoltean     03/07/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"
#include "vs_reg.hxx"
#include "vs_sec.hxx"

// Generated file from Coord.IDL
#include "vss.h"
#include "vscoordint.h"
#include "vsevent.h"
#include "vsprov.h"
#include "vsswprv.h"
#include "vsmgmt.h"

#include "swprv.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diffreg.hxx"
#include "diffmgmt.hxx"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRMGMTC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVsSoftwareProvider


STDMETHODIMP CVsSoftwareProvider::GetProviderMgmtInterface(							
	IN  	VSS_ID 	    ProviderId,     //  It might be a software or a system provider.
	IN  	REFIID 	    InterfaceId,    //  Might be IID_IVssDifferentialSoftwareSnapshotMgmt
	OUT     IUnknown**  ppItf           
	)
/*++

Routine description:

    Returns an interface to further configure a snapshot provider

Error codes:

    E_ACCESSDENIED
        - The user is not a administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    E_NOINTERFACE
        - the provider does not support the interface with the given ID.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - unexpected error when calling QueryInteface
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::GetProviderMgmtInterface" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppItf );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  InterfaceId = " WSTR_GUID_FMT L"\n"
             L"  ppItf = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             GUID_PRINTF_ARG( InterfaceId ),
             ppItf);

        // Argument validation
		BS_ASSERT(ppItf);
        if (ProviderId != VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid provider ID");
        if (ppItf == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppItf");

        // Right now we support only IVssDifferentialSoftwareSnapshotMgmt. In future version we might support more interfaces.
        // WARNING: with the current implementation the client may still use QueryInterface to reach other provider's custom interfaces.
        // We cannot prevent that unless we decide to create a wrapper object around the returned provider interface, in order to 
        // intercept QueryInterface calls also.
        if ( InterfaceId != IID_IVssDifferentialSoftwareSnapshotMgmt )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid Interface ID");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // 
        // Create the instance
        //
        ft.hr = CVssDiffMgmt::CreateInstance( ppItf, InterfaceId );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareProvider::QueryVolumesSupportedForSnapshots(
	IN  	VSS_ID 	    ProviderId,     
    IN      LONG        lContext,
	OUT 	IVssEnumMgmtObject **ppEnum
	)
/*++

Routine description:

    Query volumes (on the local machine) that support snapshots.

Parameters:

    ProviderID - the provider on which we should return the supported volumes for snapshot. 
        If NULL ID is provided, then return the volumes that are supported by at least one provider.
        
    ppEnum - the returned list of volumes.

Remarks:

    The result of the query is independent by context.

Error codes:

    S_FALSE
        - If returning an empty array
    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    E_UNEXPECTED
        Error while getting the list of volumes. (for example dismounting a volume in the middle of an enumeration)
        A error log entry contains more information.

    [CVssSoftwareProvider::IsVolumeSupported() failures]
        S_OK
            The function completed with success
        E_ACCESSDENIED
            The user is not an administrator.
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources           
        E_UNEXPECTED
            Unexpected programming error. Logging not done and not needed.
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.

        [CVssSoftwareProvider::GetVolumeInformation]
            E_OUTOFMEMORY
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            E_UNEXPECTED
                Unexpected programming error. Nothing is logged.
            VSS_E_OBJECT_NOT_FOUND
                The device does not exist or it is not ready.
        
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::QueryVolumesSupportedForSnapshots" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             ppEnum);

        // Argument validation
		BS_ASSERT(ppEnum);
        if (ProviderId != VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid provider ID");
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		WCHAR wszVolumeName[MAX_PATH+1];
    	CVssVolumeIterator volumeIterator;
		while(true) {

    		// Get the volume name
    		if (!volumeIterator.SelectNewVolume(ft, wszVolumeName, MAX_PATH))
    		    break;

            //
            //  Verify if the volume is supported
            //

            BOOL bIsSupported = FALSE;

            ft.hr = S_OK;
            try
            {
                // Get volume information.
                LONG lVolAttr = GetVolumeInformationFlags(wszVolumeName, lContext);
                bIsSupported = ((lVolAttr & VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) != 0);
            }
            VSS_STANDARD_CATCH(ft)

            // Treatment of errors
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND) {
                // May happen, on clustered systems for example.
                // Just trace and ingore the volume
                ft.Trace(VSSDBG_SWPRV, L"Volume %s is not found, therefore, it is being skipped", wszVolumeName);
                continue;
            } else if (ft.HrFailed()) {
                // Other error - abort
                ft.Throw(VSSDBG_SWPRV, ft.hr, 
                    L"IsVolumeSupported failed for volume %s . Rethrowing hr = 0x%08lx", wszVolumeName, ft.hr);
            }

            // Ignore volumes that are not supported.
            if (!bIsSupported)
                continue;

            // 
            //  Calculate the volume display name
            //

            WCHAR wszVolumeDisplayName[MAX_PATH];
            VssGetVolumeDisplayName( wszVolumeName, wszVolumeDisplayName, MAX_PATH);

            // 
            //  Add the supported volume to the list
            //

			// Initialize an empty snapshot properties structure
			VSS_MGMT_OBJECT_PROP_Ptr ptrVolumeProp;
			ptrVolumeProp.InitializeAsVolume( ft,
				wszVolumeName,
				wszVolumeDisplayName);

			if (!pArray->Add(ptrVolumeProp))
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"Cannot add element to the array");

			// Reset the current pointer to NULL
			ptrVolumeProp.Reset(); // The internal pointer was detached into pArray.
            
		}

        // Create the enumerator object. 
		ft.hr = VssBuildEnumInterface<CVssMgmtEnumFromArray>( VSSDBG_SWPRV, pArray, ppEnum );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



/*++

Routine description:

    Query snapshots on the given volume.

Error codes:

    E_ACCESSDENIED
        - The user is not a administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    E_OBJECT_NOT_FOUND
        - Invalid volume name
        
--*/
STDMETHODIMP CVsSoftwareProvider::QuerySnapshotsByVolume(
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_ID 	    ProviderId,     
	OUT 	IVssEnumObject **ppEnum
	)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::QuerySnapshotsByVolume" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             pwszVolumeName,
             GUID_PRINTF_ARG( ProviderId ),
             ppEnum);

        // Argument validation
		BS_ASSERT(ppEnum);
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszVolumeName");
        if (ProviderId != VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid provider ID");
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Fill the array with the snapshots on the given volume
        CVssQueuedSnapshot::EnumerateSnapshotsOnVolume(pwszVolumeName, 
            false, GUID_NULL, VSS_CTX_ALL, pArray, true);

        // Create the enumerator object. 
		ft.hr = VssBuildEnumInterface<CVssEnumFromArray>( VSSDBG_SWPRV, pArray, ppEnum );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\find.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Find.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"
#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRFINDC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::EnumerateSnapshots(
	    IN  bool bSearchBySnapshotID,
	    IN  VSS_ID SnapshotID,
		IN  LONG lContext,
		IN OUT	VSS_OBJECT_PROP_Array* pArray
	    ) throw(HRESULT)

/*++

Description:

	This method enumerates all snapshots

Throws:

    VSS_E_PROVIDER_VETO
        - On runtime errors
    E_OUTOFMEMORY

--*/

{	
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EnumerateSnapshots");
		
	// Enumerate snapshots through all the volumes
	WCHAR wszVolumeName[MAX_PATH+1];
	CVssVolumeIterator volumeIterator;
	bool bFinished = false;
	while(!bFinished) {
	    
		// Get the volume name
		if (!volumeIterator.SelectNewVolume(ft, wszVolumeName, MAX_PATH))
		    break;

        // Enumerate the snapshots on that volume
        int size = pArray->GetSize();

        // Ignore the return value (eliminate /W4 warning)
        EnumerateSnapshotsOnVolume( wszVolumeName, 
            bSearchBySnapshotID, SnapshotID, lContext, pArray );

        // we're done if we're looking for a snapshot id, and we've put at least one snapshot in the list.
	    bFinished = (bSearchBySnapshotID && (pArray->GetSize() > size));
	}
}


bool CVssQueuedSnapshot::EnumerateSnapshotsOnVolume(
		IN  VSS_PWSZ wszVolumeName,
	    IN  bool bSearchBySnapshotID,
	    IN  VSS_ID SnapshotID,
		IN  LONG lContext,
		IN OUT	VSS_OBJECT_PROP_Array* pArray,
	    IN  bool bThrowOnError // = false  By default do not throw on error
	    ) throw(HRESULT)

/*++

Description:

	This method enumerates all snapshots o the give volume

Returns:

    false - if the enumeration of volumes may continue
    true - otherwise

Throws:

    VSS_E_PROVIDER_VETO
        - On runtime errors
    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EnumerateSnapshotsOnVolume");
		
	// Check if the snapshot is belonging to that volume
	// Open a IOCTL channel on that volume
	// Eliminate the last backslash in order to open the volume
	CVssIOCTLChannel volumeIChannel;
	ft.hr = volumeIChannel.Open(ft, wszVolumeName, true, bThrowOnError, 
	            bThrowOnError? VSS_ICHANNEL_LOG_PROV: VSS_ICHANNEL_LOG_NONE, 0);
	if (ft.HrFailed())
		return false;

	// Get the list of snapshots
	// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
	// supported then try with the next volume.
	ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, 
	            bThrowOnError, bThrowOnError? VSS_ICHANNEL_LOG_PROV: VSS_ICHANNEL_LOG_NONE);
	if (ft.HrFailed())
		return false;

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
	// Try to find the snapshot with the corresponding Id
	DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif

	bool bFinished = false;
	CVssAutoPWSZ pwszSnapshotName;
	while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName.GetRef()) && !bFinished) {
	    
		// Compose the snapshot name in a user-mode style
		WCHAR wszUserModeSnapshotName[MAX_PATH];
        ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
            x_wszGlobalRootPrefix, pwszSnapshotName );
		
		// Open that snapshot 
		// Do not eliminate the trailing backslash
		// Do not throw on error
        //
        //  Open the snapshot with no access rights for perf reasons (bug #537974)
    	CVssIOCTLChannel snapshotIChannel;
		ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, 
		            bThrowOnError, bThrowOnError? VSS_ICHANNEL_LOG_PROV: VSS_ICHANNEL_LOG_NONE, 0);
		if (ft.HrFailed()) {
			ft.Trace( VSSDBG_SWPRV, L"Warning: Error opening the snapshot device name %s [0x%08lx]",
						wszUserModeSnapshotName, ft.hr );
			return false;
		}

		// Send the IOCTL to get the application buffer
		ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, 
		            bThrowOnError, bThrowOnError? VSS_ICHANNEL_LOG_PROV: VSS_ICHANNEL_LOG_NONE);
		if (ft.HrFailed()) {
			ft.Trace( VSSDBG_SWPRV,
						L"Warning: Error sending the query IOCTL to the snapshot device name %s [0x%08lx]",
						wszUserModeSnapshotName, ft.hr );
			return false;
		}

		// Unpack the length of the application buffer
		ULONG ulLen;
		snapshotIChannel.Unpack(ft, &ulLen);

        if (ulLen < sizeof(GUID)) {
		    BS_ASSERT(false);
            ft.Trace(VSSDBG_SWPRV, L"Warning: small size snapshot detected: %s %ld", pwszSnapshotName, ulLen);
			ft.m_hr = S_OK;
			continue;
		}

    	// Unpack the Appinfo ID
    	VSS_ID AppinfoId;
    	snapshotIChannel.Unpack(ft, &AppinfoId);

    	// Get the snapshot Id
    	VSS_ID CurrentSnapshotId;
    	snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

        // If we are filtering, ignore the rest...
        if (bSearchBySnapshotID)
        {
            if (SnapshotID != CurrentSnapshotId)
                continue;
            else
            	bFinished  = true;	// once we find the snapshot, stop looping
        }
            
        // We encountered a hidden snapshot
        if (AppinfoId == VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN)
            continue;

        // Check for invalid values
    	if ((AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU) &&
    	    (AppinfoId != VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE) &&
    	    (AppinfoId != VOLSNAP_APPINFO_GUID_NAS_ROLLBACK) &&
    	    (AppinfoId != VOLSNAP_APPINFO_GUID_APP_ROLLBACK) && 
    	    (AppinfoId != VOLSNAP_APPINFO_GUID_FILE_SHARE_BACKUP))
    	{
    	    ft.Trace(VSSDBG_SWPRV, L"Unsupported app info for snapshot %s: " WSTR_GUID_FMT, 
    	        pwszSnapshotName.GetRef(), GUID_PRINTF_ARG(AppinfoId));
    	    continue;
    	}

		// Get the snapshot set Id
		VSS_ID CurrentSnapshotSetId;
		snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);

        // Get the snapshot context
        LONG lStructureContext;
		snapshotIChannel.Unpack(ft, &lStructureContext);

        // Further validation
        switch(lStructureContext)
        {
        case VSS_CTX_BACKUP:
            BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU);
            break;
        case VSS_CTX_CLIENT_ACCESSIBLE:
            BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE);
            break;
        case VSS_CTX_NAS_ROLLBACK:
            BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_NAS_ROLLBACK);
            break;
        case VSS_CTX_APP_ROLLBACK:
            BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_APP_ROLLBACK);
            break;
        case VSS_CTX_FILE_SHARE_BACKUP:
            BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_FILE_SHARE_BACKUP);
            break;
        default:
            // For known AppInfoID we should operate only with known contexts
            BS_ASSERT(false);
            continue;
        }

		// If the snapshot belongs to the wrong context, then ignore it.
		if (lContext != VSS_CTX_ALL)
		    if (lContext != lStructureContext)
                continue;
		
        //
		// Process the snapshot that was just found
		//
		
		// Initialize an empty snapshot properties structure
		VSS_OBJECT_PROP_Ptr ptrSnapProp;
		ptrSnapProp.InitializeAsSnapshot( ft,
			CurrentSnapshotId,
			CurrentSnapshotSetId,
			0,
			wszUserModeSnapshotName,
			wszVolumeName,
			NULL,
			NULL,
			NULL,
			NULL,
			VSS_SWPRV_ProviderId,
			lStructureContext,
			0,
			VSS_SS_UNKNOWN);

		// Get the snapshot structure
		VSS_OBJECT_PROP* pObj = ptrSnapProp.GetStruct();
		BS_ASSERT(pObj);
		VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

		// Load the rest of properties
		// Do not load the Name and the Original volume name fields
		// twice since they are already known
		bool bRecognized = LoadStructure( snapshotIChannel, pSnap, NULL, NULL, true );
        if (!bRecognized)
        {
            BS_ASSERT(false);
            ft.Trace( VSSDBG_SWPRV, L"Error while loading the snapshot structure. Volume = %s, Snapshot = %s, "
                L" AppInfoID = " WSTR_GUID_FMT
                L" SnapshotID = " WSTR_GUID_FMT, 
                wszVolumeName, snapshotIChannel.GetDeviceName(), AppinfoId, CurrentSnapshotId);
            BS_ASSERT(false);
            continue;
        }

    	// Get the original volume name and Id
		CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
		    snapshotIChannel, 
		    &(pSnap->m_pwszOriginalVolumeName));

    	// Get the timestamp
    	CVssQueuedSnapshot::LoadTimestampIoctl(
    	    snapshotIChannel, 
    	    &(pSnap->m_tsCreationTimestamp));
    		
		if (!pArray->Add(ptrSnapProp))
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
					  L"Cannot add element to the array");

		// Reset the current pointer to NULL
		ptrSnapProp.Reset(); // The internal pointer was detached into pArray.
	}

#ifdef _DEBUG
	// Check if all strings were browsed correctly
	DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
	BS_ASSERT( (dwFinalOffset - dwInitialOffset <= ulMultiszLen));
#endif

	return true;
}



bool CVssQueuedSnapshot::FindPersistedSnapshotByID(
    IN  VSS_ID SnapshotID,
    IN  LONG lContext,
    OUT LPWSTR * ppwszSnapshotDeviceObject
    ) throw(HRESULT)

/*++

Description:

	Finds a snapshot (and its device name) based on ID.

Throws:

    E_OUTOFMEMORY

    [EnumerateSnapshots() failures]
        VSS_E_PROVIDER_VETO
            - On runtime errors (like Unpack)
        E_OUTOFMEMORY    

--*/
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::FindPersistedSnapshotByID");
		
	BS_ASSERT(SnapshotID != GUID_NULL);
	if (ppwszSnapshotDeviceObject != NULL) {
    	BS_ASSERT((*ppwszSnapshotDeviceObject) == NULL);
	}

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
    if (pArray == NULL)
        ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
	// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
	// Now pArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
    BS_ASSERT(pArrayItf);

    // Put into the array only one element.
    EnumerateSnapshots(
	    true,
    	SnapshotID,
    	lContext,
    	pArray
    	);

    // Extract the element from the array.
    if (pArray->GetSize() == 0)
    	return false;

    if (ppwszSnapshotDeviceObject) {
    	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
    	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
    	BS_ASSERT(pObj);
    	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
    	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);
    	BS_ASSERT(pSnap->m_pwszSnapshotDeviceObject);
    	::VssSafeDuplicateStr(ft, (*ppwszSnapshotDeviceObject), 
    	    pSnap->m_pwszSnapshotDeviceObject);
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\provider.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Provider.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     08/17/1999  Change CommitSnapshots to CommitSnapshot
    aoltean     09/23/1999  Using CComXXX classes for better memory management
                            Renaming back XXXSnapshots -> XXXSnapshot
    aoltean     09/26/1999  Returning a Provider Id in OnRegister
    aoltean     09/09/1999  Adding PostCommitSnapshots
                            dss->vss
	aoltean		09/20/1999	Making asserts more cleaner.
	aoltean		09/21/1999	Small renames

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes



#include "stdafx.hxx"
#include <winnt.h>

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diff.hxx"
#include "alloc.hxx"

#include "vs_quorum.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRPROVC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Global Definitions

CVssCriticalSection CVsSoftwareProvider::m_cs;

CVssDLList<CVssQueuedSnapshot*>	 CVssQueuedSnapshot::m_list;


STDMETHODIMP CVsSoftwareProvider::SetContext(
		IN  	LONG 	lContext				
		)
/*++

Routine description:

    Implements IVssSnapshotProvider::SetContext

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Attempt to change the context while it is frozen. It is illegal to
        change the context after the first call on the IVssSnapshotProvider object.

--*/
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::SetContext");

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                      L"The client is not an administrator");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: lContext = %ld\n", lContext );

        // Lock in order to update both variables atomically
		// The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Check if the context has been freezed
        if (m_bContextFrozen) {
            BS_ASSERT(false);
            ft.Throw( VSSDBG_SWPRV, VSS_E_BAD_STATE,
                      L"The context is already frozen");
        }

        // Change the context
        // Our provider is a DIFFERENTIAL snapshot provider, therefore reject PLEX snapshots
        if (lContext == VSS_CTX_ALL) {
            m_lSnapContext = lContext;
            m_bContextFrozen = true;
        } else {
            if (lContext & VSS_VOLSNAP_ATTR_PLEX) 
                ft.Throw( VSSDBG_SWPRV, VSS_E_UNSUPPORTED_CONTEXT, L"Invalid context (Plex)");
    
            if (lContext & VSS_VOLSNAP_ATTR_DIFFERENTIAL) {
                // Note (752794): In the future we may need to store the exact context in SWPRV
                // This requires more code changes though in filtering code (find.cxx , delete.cxx),
                // validation code (persist.cxx) and others. 
                // Right now we are just removing the differential attribute from the SWPRV internal context
                ft.Trace( VSSDBG_SWPRV, L"Removing DIFFERENTIAL attribute from internal snapshot context\n");
                lContext &= ~(VSS_VOLSNAP_ATTR_DIFFERENTIAL);
            }
    
            switch(lContext) {
            case VSS_CTX_CLIENT_ACCESSIBLE:
            case VSS_CTX_BACKUP:
            case VSS_CTX_FILE_SHARE_BACKUP:
            case VSS_CTX_NAS_ROLLBACK:  
            case VSS_CTX_APP_ROLLBACK:  
                m_lSnapContext = lContext;
                m_bContextFrozen = true;
                break;
    
            default:
                ft.Throw( VSSDBG_SWPRV, VSS_E_UNSUPPORTED_CONTEXT, L"Invalid context");
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


LONG CVsSoftwareProvider::GetContextInternal() const
/*++

Routine description:

    Returns the current context

--*/
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::GetContextInternal");

    return m_lSnapContext;
}


void CVsSoftwareProvider::FreezeContext()
/*++

Routine description:

    Freezes the current context. To be called in IVssSoftwareProvider methods.

--*/
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::FreezeContext");

    // m_bContextFrozen may be already true...
    m_bContextFrozen = true;
}



/////////////////////////////////////////////////////////////////////////////
//  Definitions


STDMETHODIMP CVsSoftwareProvider::BeginPrepareSnapshot(
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_ID          SnapshotId,
    IN      VSS_PWSZ     pwszVolumeName,
    IN      LONG             lNewContext      
    )

/*++

Description:

	Creates a Queued Snapshot object to be committed later.

Algorithm:

	1) Creates an internal VSS_SNAPSHOT_PROP structure that will keep most of the properties.
	2) Creates an CVssQueuedSnapshot object and insert it into the global queue of snapshots pending to commit.
	3) Set the state of the snapshot as PREPARING.
	4) If needed, create the snapshot object and return it to the caller.

Remarks:

	The queued snapshot object keeps a reference count. At the end of this function it will be:
		1 = the queued snap obj is reffered by the global queue (if no snapshot COM object was returned)
		2 = reffered by the global queue and by the returned snapshot COM object

Called by:

	IVssCoordinator::AddToSnapshotSet

Error codes:

    VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
        - Volume not supported by provider.
    VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
        - Maximum number of snapshots reached.
    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid arguments

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

--*/


{
    UNREFERENCED_PARAMETER(lNewContext);

    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::BeginPrepareSnapshot" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  SnapshotId = " WSTR_GUID_FMT 	L"\n"
             L"  SnapshotSetId = " WSTR_GUID_FMT 	L"\n"
             L"  VolumeName = %s,\n"
             L"  ppSnapshot = %p,\n",
             GUID_PRINTF_ARG( SnapshotId ),
             GUID_PRINTF_ARG( SnapshotSetId ),
             pwszVolumeName);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
        if ( pwszVolumeName == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if ( SnapshotId == GUID_NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Snapshot ID is NULL");

        if (m_ProviderInstanceID == GUID_NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"The Provider instance ID could not be generated");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        // Check to see if the volume is supported.
        // This may throw VSS_E_OBJECT_NOT_FOUND or even VSS_E_PROVIDER_VETO if an error occurs.
        //
        LONG lVolAttr = GetVolumeInformationFlags(pwszVolumeName, GetContextInternal());
        if ((lVolAttr & VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER, L"Volume not supported");

        //
        //  Freeze the context
        //
        FreezeContext();
        BS_ASSERT((GetContextInternal() == VSS_CTX_BACKUP) 
            || (GetContextInternal() == VSS_CTX_CLIENT_ACCESSIBLE)
            || (GetContextInternal() == VSS_CTX_NAS_ROLLBACK)
            || (GetContextInternal() == VSS_CTX_APP_ROLLBACK)
            || (GetContextInternal() == VSS_CTX_FILE_SHARE_BACKUP)
            );

        //
        //  Remove the non-autodelete snapshots from previous snapshot sets, if any
        //
        RemoveSnapshotsFromGlobalList(m_ProviderInstanceID, SnapshotSetId, VSS_QST_REMOVE_ALL_NON_AUTORELEASE);

        //
        //  Get local computer name
        //

        // compute size of computer name.  Initially a null output buffer is
        // passed in in order to figure out the size of the computer name.  We
        // expect that the error from this call is ERROR_MORE_DATA.
        DWORD cwc = 0;
        BOOL bResult = ::GetComputerNameEx(ComputerNameDnsFullyQualified, NULL, &cwc);
        BS_ASSERT(bResult == FALSE);
        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_MORE_DATA)
            ft.TranslateInternalProviderError(VSSDBG_SWPRV, 
                HRESULT_FROM_WIN32(dwErr),
                VSS_E_PROVIDER_VETO,
                L"GetComputerNameEx(%d, NULL, [%lu]) [%ld]", 
                ComputerNameDnsFullyQualified,
                cwc, (LONG)bResult);

        // allocate space for computer name
        CVssAutoPWSZ awszComputerName;
        awszComputerName.Allocate(cwc);

        // get the computer name
        if (!GetComputerNameEx(ComputerNameDnsFullyQualified, awszComputerName.GetRef(), &cwc))
            ft.TranslateInternalProviderError(VSSDBG_SWPRV, 
                HRESULT_FROM_WIN32(GetLastError()),
                VSS_E_PROVIDER_VETO,
                L"GetComputerNameEx(%d, %p, %lu)", 
                ComputerNameDnsFullyQualified,
                awszComputerName.GetRef(),
                cwc);

        //
		// Create the structure that will keep the prepared snapshot state.
        //

		VSS_OBJECT_PROP_Ptr ptrSnapshot;
		ptrSnapshot.InitializeAsSnapshot( ft,
			SnapshotId,
			SnapshotSetId,
			0,
			NULL,
			pwszVolumeName,
			awszComputerName,
			awszComputerName,
			NULL,
			NULL,
			VSS_SWPRV_ProviderId,
			// always add DIFFERENTIAL attribute
            (GetContextInternal() | (VSS_VOLSNAP_ATTR_DIFFERENTIAL)),  
			0,
			VSS_SS_PREPARING
			);

		// Create the snapshot object. After this assignment the ref count becomes 1.
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnap = new CVssQueuedSnapshot(
            ptrSnapshot, m_ProviderInstanceID, GetContextInternal());
		if (ptrQueuedSnap == NULL)
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

		// The structure was detached into the queued object
		// since the ownership was passed to the constructor.
		ptrSnapshot.Reset();

		// Add the snapshot object to the global queue. No exceptions should be thrown here.
		// The reference count will be 2.
		ptrQueuedSnap->AttachToGlobalList();

        // The destructor for the smart pointer will be called. The reference count will be 1
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareProvider::EndPrepareSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as a rendez-vous method
    in order to finish the prepare phase for snapshots
    (like ending the background prepare tasks or performing the lengthly operations before
    issuing the snapshots freeze).

	This function acts on the given snapshot set (i.e. to call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
    on each snapshotted volume)

Algorithm:

	For each preparing snapshot (but not prepared yet) in this snapshot set:
		2) Call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_PREPARED

	Compute the number of prepared snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the first phase (i.e. EndPrepare All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many EndPrepareSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after PrepareSnapshots therefore the state of all snapshots must be PREPARING before calling this function.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors. Logging done.
    VSS_E_INSUFFICIENT_STORAGE
        Not enough disk storage to create a snapshot (for ex. diff area)
        (remark: when a snapshot is not created since there is not enough disk space 
        this error is not guaranteed to be returned. VSS_E_PROVIDER_VETO or VSS_E_OBJECT_NOT_FOUND 
        may also be returned in that case.)
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::EndPrepareSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId )
			);

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

        //
        // Allocate the diff areas
        //

        CVssDiffAreaAllocator allocator(GetContextInternal(), SnapshotSetId);

        // Compute all new diff areas
        // This method may throw
        allocator.AssignDiffAreas();

        //
        // Change the state for the existing snapshots
        //

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-committed.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARING:

                {
                    // Purge previous Timewarp snapshots, as needed
                    DWORD dwMaxCAOlderShadowCopies = (m_dwMaxCAShadowCopies > 0)? m_dwMaxCAShadowCopies - 1: 0;
                    PurgeSnapshotsOnVolume(
                        pProp->m_pwszOriginalVolumeName, 
                        false,
                        dwMaxCAOlderShadowCopies
                        );
                }

                // Remark - we are supposing here that only one snaphsot set can be
                // in progress. We are not checking again if the volume has snapshots.

				// Mark the state of this snapshot as failed
                // in order to correctly handle the state
				ptrQueuedSnapshot->MarkAsProcessingPrepare();

				// Open the volume IOCTL channel for that snapshot.
				ptrQueuedSnapshot->OpenVolumeChannel();
					
				// Send the IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT ioctl.
				ptrQueuedSnapshot->PrepareForSnapshotIoctl();

				// Mark the snapshot as prepared
				ptrQueuedSnapshot->MarkAsPrepared();
				break;

			case VSS_SS_PREPARED:

				// Snapshot was already prepared in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }

        // Commit all diff areas allocations
        // (otherwise the diff areas changes will be rollbacked in destructor)
        allocator.Commit();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PreCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator in order to pre-commit all snapshots
	on the given snapshot set

Algorithm:

	For each prepared snapshot (but not precommitted yet) in this snapshot set:
		1) Change the state of the snapshot to VSS_SS_PRECOMMITTED

	Compute the number of pre-committed snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordiantor::DoSnapshotsSet in the second phase (i.e. Pre-Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many PreCommitSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after EndPrepareSnapshots therefore the state of all snapshots must be PREPARED before calling this function.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PreCommitSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId )
			);

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-committed.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARED:

				// Mark the snapshot as processing pre-commit
				ptrQueuedSnapshot->MarkAsProcessingPreCommit();

				// Mark the snapshot as pre-committed
                // Do nothing in Babbage provider
				ptrQueuedSnapshot->MarkAsPreCommitted();

				break;

			case VSS_SS_PRECOMMITTED:

				// Snapshot was already pre-committed in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::CommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator in order to commit all snapshots
	on the given snapshot set (i.e. to call IOCTL_VOLSNAP_COMMIT_SNAPSHOT on each snapshotted volume)

Algorithm:

	For each precommitted (but not yet committed) snapshot in this snapshot set:
		2) Call IOCTL_VOLSNAP_COMMIT_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_COMMITTED

	Return the number of committed snapshots, if success.
	Otherwise return 0 (even if some snapshots were committed).

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is already holding writes on snapshotted volumes.
	- The coordinator may issue many CommitSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::CommitSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Commit the snapshot, if not failed in pre-commit phase.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PRECOMMITTED:

				// Mark the snapshot as processing commit
				ptrQueuedSnapshot->MarkAsProcessingCommit();

				// Send the IOCTL_VOLSNAP_COMMIT_SNAPSHOT ioctl.
				ptrQueuedSnapshot->CommitSnapshotIoctl();

				// Mark the snapshot as committed
				ptrQueuedSnapshot->MarkAsCommitted();
				break;

			case VSS_SS_COMMITTED:

				// Commit was already done.
				// The provider may receive many CommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PostCommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )

/*++

Description:

	This function gets called by the coordinator as a last phase after commit for all snapshots
	on the given snapshot set

Algorithm:

	For each committed snapshot in this snapshot set:
		1) Call IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT. The purpose of this
			IOCTL is to get the Snapshot Device object name.
		2) Create a unique snapshot ID
		3) Change the state of the snapshot to VSS_SS_CREATED
		4) Set the "number of committed snapshots" attribute of the snapshot set
		5) Save the snapshot properties using the IOCTL_VOLSNAP_SET_APPLICATION_INFO ioctl.
		6) If everything is OK then remove all snapshots from the global list.

	Keep the number of post-committed snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots), after releasing writes
	by Lovelace

Remarks:

	- While calling this, Lovelace is not holding writes anymore.
	- The coordinator may issue many PostCommitSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PostCommitSnapshots" );
	LONG lProcessedSnapshotsCount = 0;

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				  L"  SnapshotSetId = " WSTR_GUID_FMT L" \n"
				  L"  lSnapshotsCount = %ld",
				  GUID_PRINTF_ARG( SnapshotSetId ),
				  lSnapshotsCount);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
		if ( lSnapshotsCount < 0 )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"lSnapshotsCount < 0");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

		// On each committed snapshot store the lSnapshotsCount
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Get the snapshot volume name and set the snapshot data.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_COMMITTED:

				// Mark the snapshot as processing post-commit
				ptrQueuedSnapshot->MarkAsProcessingPostCommit();

				// Remark: the snapshot device name will not be persisted

				// Fill the required properties - BEFORE the snapshot properties are saved!
				ptrQueuedSnapshot->SetPostcommitInfo(lSnapshotsCount);

				// Send the IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT ioctl.
				// Get the snapshot device name
				ptrQueuedSnapshot->EndCommitSnapshotIoctl(pProp);
				ft.Trace( VSSDBG_SWPRV, L"Snapshot created");

				// Increment the number of processed snapshots
				lProcessedSnapshotsCount++;

				// Mark the snapshot as created
				ptrQueuedSnapshot->MarkAsCreated();

				break;
				
			case VSS_SS_CREATED:

				// This snapshot is already created.
				// The provider may receive many PostCommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        } // end while(true)
    }
    VSS_STANDARD_CATCH(ft)

	// If an error occured then the coordinator is responsible to call AbortSnapshots
    return ft.hr;
}

STDMETHODIMP CVsSoftwareProvider::PreFinalCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    UNREFERENCED_PARAMETER(SnapshotSetId);
    
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PreFinalCommitSnapshots" );

    ft.hr = E_NOTIMPL;
    return ft.hr;
}

STDMETHODIMP CVsSoftwareProvider::PostFinalCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    UNREFERENCED_PARAMETER(SnapshotSetId);
    
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PostFinalCommitSnapshots" );

    ft.hr = E_NOTIMPL;
    return ft.hr;
}
    
STDMETHODIMP CVsSoftwareProvider::AbortSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as to abort all snapshots from the given snapshot set.
    The snapshots are "reset" to the preparing state, so that a new DoSnapshotSet sequence can start.

Algorithm:

 	For each pre-committed snapshot in this snapshot set calls IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
 	For each committed or created snapshot it deletes the snapshot

Called by:

	IVssCoordinator::DoSnapshotsSet to abort precommitted snapshots

Remarks:

	- While calling this, Lovelace is not holding writes on snapshotted volumes.
	- The coordinator may receive many AbortSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::AbortSnapshots" );

    HRESULT hIncompleteError = S_OK;	
    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

        LONG lProcessedSnapshotsCount = 0;
        CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Switch the snapshot back to "Preparing" state
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PREPARING:
			case VSS_SS_PROCESSING_PREPARE: // Bug 207793

                // Nothing to do.
				break;

			case VSS_SS_PREPARED:
			case VSS_SS_PROCESSING_PRECOMMIT:
			case VSS_SS_PRECOMMITTED:

				// If snapshot was prepared, send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
				ft.hr = ptrQueuedSnapshot->AbortPreparedSnapshotIoctl();
				if (ft.HrFailed())
				{
					ft.Trace( VSSDBG_SWPRV,
                                L"sending IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT failed 0x%08lx", ft.hr);
					ft.hr = S_OK;
					hIncompleteError = S_FALSE;
				}
                break;

			case VSS_SS_PROCESSING_COMMIT:
			case VSS_SS_COMMITTED:
			case VSS_SS_PROCESSING_POSTCOMMIT:
			case VSS_SS_CREATED:

			    try
                {
    				// If snapshot was committed, delete the snapshot
    				LONG lDeletedSnapshots = 0;
    				VSS_ID NondeletedSnapshotID = GUID_NULL;
    				ft.hr = CVsSoftwareProvider::InternalDeleteSnapshots(pProp->m_SnapshotId,
    				            VSS_OBJECT_SNAPSHOT,
            					GetContextInternal(),
    				            &lDeletedSnapshots,
    				            &NondeletedSnapshotID);
    				if (ft.HrFailed())
    				{
    					ft.Trace( VSSDBG_SWPRV,
                                    L"InternalDeleteSnapshots failed (%ld) " WSTR_GUID_FMT L"0x%08lx",
                                    lDeletedSnapshots,
                                    GUID_PRINTF_ARG(NondeletedSnapshotID),
                                    ft.hr);
    					ft.hr = S_OK;
    					hIncompleteError = S_FALSE;
    				}
    			}
			    VSS_STANDARD_CATCH(ft)
			
                break;

			default:
				BS_ASSERT(false);
			}

            // Reset the snapshot as preparing
            ptrQueuedSnapshot->ResetAsPreparing();

			lProcessedSnapshotsCount++;
        }

        ft.Trace( VSSDBG_SWPRV, L"%ld snapshots were aborted", lProcessedSnapshotsCount);
    }
    VSS_STANDARD_CATCH(ft)

    if (SUCCEEDED(ft.hr))
    	ft.hr = hIncompleteError;
    
    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::GetSnapshotProperties(
    IN      VSS_ID          SnapshotId,
    OUT     PVSS_SNAPSHOT_PROP  pSavedProp
    )
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::GetSnapshotProperties

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
    E_UNEXPECTED
        - Dev error. No logging.
    E_ACCESSDENIED
        - The user is not a backup operator or administrator

    [FindPersistedSnapshotByID() failures]
        E_OUTOFMEMORY

        [EnumerateSnapshots() failures]
            VSS_E_PROVIDER_VETO
                - On runtime errors (like Unpack)
            E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssSoftwareProvider::GetSnapshotProperties" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pSavedProp );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: pSavedProp = %p", pSavedProp );

        // Argument validation
		BS_ASSERT(pSavedProp);
		if ( SnapshotId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotId == GUID_NULL");
        if (pSavedProp == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pSavedProp");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// Get the list of snapshots in the give array
		CVssQueuedSnapshot::EnumerateSnapshots( true, SnapshotId, GetContextInternal(), pArray);

        // Extract the element from the array.
        if (pArray->GetSize() == 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Snapshot not found.");

        // Get the snapshot structure
    	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
    	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
    	BS_ASSERT(pObj);
    	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
    	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

        // Fill out the [out] parameter
        VSS_OBJECT_PROP_Copy::copySnapshot(pSavedProp, pSnap);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::SetSnapshotProperty(
	IN   VSS_ID  			SnapshotId,
	IN   VSS_SNAPSHOT_PROPERTY_ID	eSnapshotPropertyId,
	IN   VARIANT 			vProperty
	)
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssSoftwareProvider::SetSnapshotProperty" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument checking
		if ( SnapshotId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotId == GUID_NULL");

        // Further argument checking
        CComVariant value = vProperty;
        switch(eSnapshotPropertyId)
        {
            case VSS_SPROPID_SNAPSHOT_ATTRIBUTES:
                if (value.vt != VT_I4)
                {
                    BS_ASSERT(false); // The coordinator must give us the right data
                    ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid variant %ul for property %d", 
                        value.vt, eSnapshotPropertyId);
                }
                
                // Trace parameters
                ft.Trace( VSSDBG_SWPRV, L"Parameters: SnapshotId: " WSTR_GUID_FMT 
                    L", eSnapshotPropertyId = %d, vProperty = 0x%08lx" , 
                    GUID_PRINTF_ARG(SnapshotId), eSnapshotPropertyId, value.lVal );
                break;
            case VSS_SPROPID_EXPOSED_NAME:
            case VSS_SPROPID_EXPOSED_PATH:
            case VSS_SPROPID_SERVICE_MACHINE:
                if (value.vt != VT_BSTR)
                {
                    BS_ASSERT(false); // The coordinator must give us the right data
                    ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid variant %ul for property %d", 
                        value.vt, eSnapshotPropertyId);
                }

                // Trace parameters
                ft.Trace( VSSDBG_SWPRV, L"Parameters: SnapshotId: " WSTR_GUID_FMT 
                    L", eSnapshotPropertyId = %d, vProperty = %s" ,
                    GUID_PRINTF_ARG(SnapshotId), eSnapshotPropertyId, value.bstrVal );

                // We should not allow empty strings
                if (value.bstrVal == NULL)
                    ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL exposed name/path", value.bstrVal);
                
                break;
            default:
                ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid property %d", eSnapshotPropertyId);
        }

        // Load the snapshot properties
        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// Get the list of snapshots in the give array
		CVssQueuedSnapshot::EnumerateSnapshots( true, SnapshotId, GetContextInternal(), pArray);

        // Extract the element from the array. Throw if snapshot not found.
        if (pArray->GetSize() == 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Snapshot not found.");

        // Get the snapshot structure
    	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
    	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
    	BS_ASSERT(pObj);
    	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
    	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

    	// Set the member in the structure
        switch(eSnapshotPropertyId)
        {
            case VSS_SPROPID_SNAPSHOT_ATTRIBUTES:
                // The attributes must be applied to the snapshot attributes
                // Currently, the only attributes that can be changed here are the exposure attributes
                BS_ASSERT(value.vt == VT_I4);
                if ((((LONG)value.lVal ^ pSnap->m_lSnapshotAttributes) & ~x_lInputAttributes) !=0)
                	ft.Throw (VSSDBG_SWPRV, E_INVALIDARG, L"Invalid attributes 0x%08lx, previous attributes are 0x%08lx", (LONG)value.lVal,
                																					pSnap->m_lSnapshotAttributes);
                
                pSnap->m_lSnapshotAttributes = (LONG)value.lVal;
                break;

            case VSS_SPROPID_EXPOSED_NAME:
                // Change the exposed name
                BS_ASSERT(value.vt == VT_BSTR);
                ::VssFreeString(pSnap->m_pwszExposedName);
                ::VssSafeDuplicateStr(ft, pSnap->m_pwszExposedName, value.bstrVal);
                break;

            case VSS_SPROPID_EXPOSED_PATH:
                // Change the exposed path
                BS_ASSERT(value.vt == VT_BSTR);
                ::VssFreeString(pSnap->m_pwszExposedPath);
                ::VssSafeDuplicateStr(ft, pSnap->m_pwszExposedPath, value.bstrVal);
                break;

            case VSS_SPROPID_SERVICE_MACHINE:
                // Change the service machine
                BS_ASSERT(value.vt == VT_BSTR);
                ::VssFreeString(pSnap->m_pwszServiceMachine);
                ::VssSafeDuplicateStr(ft, pSnap->m_pwszServiceMachine, value.bstrVal);
                break;

            default:
                BS_ASSERT(false);
                ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid property %d", eSnapshotPropertyId);
        }

        // Open a IOCTL channel to the snapshot
        BS_ASSERT(pSnap->m_pwszSnapshotDeviceObject);
    	CVssIOCTLChannel snapshotIChannel;	
    	snapshotIChannel.Open(ft, pSnap->m_pwszSnapshotDeviceObject, false, true, VSS_ICHANNEL_LOG_PROV);

    	// Save the snapshot properties
    	LONG lStructureContext = pSnap->m_lSnapshotAttributes & ~ x_lNonCtxAttributes;
    	CVssQueuedSnapshot::SaveStructure(snapshotIChannel, pSnap, lStructureContext, false);

    	// Send the IOCTL
    	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_SET_APPLICATION_INFO, true, VSS_ICHANNEL_LOG_PROV);
    }
    VSS_STANDARD_CATCH(ft)
    return ft.hr;
}

STDMETHODIMP CVsSoftwareProvider::RevertToSnapshot(
   IN       VSS_ID              SnapshotId
)
{
    UNREFERENCED_PARAMETER(SnapshotId);
    
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::RevertToSnapshot");

    ft.hr = E_NOTIMPL;
    return ft.hr;
}

STDMETHODIMP CVsSoftwareProvider::QueryRevertStatus(
   IN      VSS_PWSZ                         pwszVolume,
   OUT    IVssAsync**                  ppAsync
 )
{
    UNREFERENCED_PARAMETER(pwszVolume);
    UNREFERENCED_PARAMETER(ppAsync);
    
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::QueryRevertStatus");

    ft.hr = E_NOTIMPL;
    return ft.hr;
}

void CVsSoftwareProvider::RemoveSnapshotsFromGlobalList(
	IN	VSS_ID FilterID,
	IN	VSS_ID CurrentSnapshotSetID,
    IN  VSS_QSNAP_REMOVE_TYPE eRemoveType
	) throw(HRESULT)

/*++

Description:

	Detach from the global list all snapshots in this snapshot set

Remark:

	We detach all snapshots at once only in case of total success or total failure.
	This is because we want to be able to retry DoSnapshotSet if a failure happens.
	Therefore we must keep the list of snapshots as long as the client wants.

    VSS_QST_REMOVE_SPECIFIC_QS,  // Remove the remaining specific QS     (called in Provider itf. destructor)
    VSS_QST_REMOVE_ALL_QS,       // Remove all remaining QS              (called in OnUnload)

Called by:

	PostCommitSnapshots, AbortSnapshots, destructor and OnUnload

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::RemoveSnapshotsFromGlobalList" );
		
    ft.Trace( VSSDBG_SWPRV, L"FilterId = " WSTR_GUID_FMT L"CurrentSSID = " WSTR_GUID_FMT L"eRemoveType = %d",
                            GUID_PRINTF_ARG(FilterID),GUID_PRINTF_ARG(CurrentSnapshotSetID),eRemoveType );

	// For each snapshot in the snapshot set...
	LONG lProcessedSnapshotsCount = 0;
	CVssSnapIterator snapIterator;
    while (true)
    {
        CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot;

        // Check if we need to return all snapshots (OnUnload case)
        switch( eRemoveType ) {
        case VSS_QST_REMOVE_ALL_QS:
            BS_ASSERT( FilterID == GUID_NULL )
	        BS_ASSERT(CurrentSnapshotSetID == GUID_NULL);
		    ptrQueuedSnapshot = snapIterator.GetNext();
            break;
        case VSS_QST_REMOVE_SPECIFIC_QS:
	        BS_ASSERT(FilterID != GUID_NULL);
	        BS_ASSERT(CurrentSnapshotSetID == GUID_NULL);
		    ptrQueuedSnapshot = snapIterator.GetNextByProviderInstance(FilterID);
            break;
        case VSS_QST_REMOVE_ALL_NON_AUTORELEASE:
	        BS_ASSERT(FilterID != GUID_NULL);
	        BS_ASSERT(CurrentSnapshotSetID != GUID_NULL);
		    ptrQueuedSnapshot = snapIterator.GetNextByProviderInstance(FilterID);
            // BUG 385538: This is a snapshot that belongs to the same snapshot set. Ignore it.
	        if (ptrQueuedSnapshot && (CurrentSnapshotSetID == ptrQueuedSnapshot->GetSnapshotSetID()))
	            continue;
            // If we are trying to remove the non-autodelete qs then ignore the autodelete ones.
            // These ones will be removed when the interface is released
            if (ptrQueuedSnapshot &&
                (0 == (ptrQueuedSnapshot->GetContextInternal() & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE)))
            {
                // This is an auto-release snapshot.
                // Since the current context didn't change, it should also refer to autorelease snapshots
		        continue;
            }
            break;
        default:
            BS_ASSERT(false);
            ptrQueuedSnapshot = NULL;
        }

		// End of enumeration?
		if (ptrQueuedSnapshot == NULL)
			break;

		// Get the snapshot structure
		PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
		BS_ASSERT(pProp != NULL);

        ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
             L" *ProvInstanceId = " WSTR_GUID_FMT L"\n"
             L"  SnapshotId = " WSTR_GUID_FMT L"\n"
             L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
             L"  VolumeName = %s\n"
             L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
             L"  lAttributes = 0x%08lx\n"
             L"  status = %d\n",
             pProp,
             GUID_PRINTF_ARG( ptrQueuedSnapshot->GetProviderInstanceId() ),
             GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
             GUID_PRINTF_ARG( pProp->m_SnapshotId ),
			 pProp->m_pwszOriginalVolumeName,
             LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
             pProp->m_lSnapshotAttributes,
			 pProp->m_eStatus);

        // The destructor (and the autodelete stuff) is called here.
		ptrQueuedSnapshot->DetachFromGlobalList();
		lProcessedSnapshotsCount++;
	}

	ft.Trace( VSSDBG_SWPRV, L" %ld snapshots were detached", lProcessedSnapshotsCount);
}


STDMETHODIMP CVsSoftwareProvider::OnLoad(
	IN  	IUnknown* pCallback	
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::OnLoad" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED, L"Access denied");

        try
        {
            CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

            // Purge all hidden snapshots that may become available for delete
            PurgeSnapshots(true);
        }
        VSS_STANDARD_CATCH(ft)

        // Log warning and ignore error code
        // (bug 406920	CVsSoftwareProvider::OnLoad fails if drive goes away)
        if (ft.HrFailed())
            ft.LogGenericWarning(VSSDBG_SWPRV, L"PurgeSnapshots(true)");
    }
    VSS_STANDARD_CATCH(ft)

    return S_OK;
    UNREFERENCED_PARAMETER(pCallback);
}


STDMETHODIMP CVsSoftwareProvider::OnUnload(
	IN  	BOOL	bForceUnload				
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::OnUnload" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED, L"Access denied");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Remove all snapshots that belong to all provider instance IDs
    	RemoveSnapshotsFromGlobalList(GUID_NULL, GUID_NULL, VSS_QST_REMOVE_ALL_QS);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    UNREFERENCED_PARAMETER(bForceUnload);
}


STDMETHODIMP CVsSoftwareProvider::IsVolumeSupported(
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSupportedByThisProvider
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the
    corresponding provider.

Parameters
    pwszVolumeName
        [in] The volume name to be checked. It must be one of those returned by
        GetVolumeNameForVolumeMountPoint, in other words in
        the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format
        with the corresponding unique ID.(with trailing backslash)
    pbSupportedByThisProvider
        [out] Non-NULL pointer that receives TRUE if the volume can be
        snapshotted using this provider or FALSE otherwise.

Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not an administrator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    E_OUTOFMEMORY
        Out of memory or other system resources
    E_UNEXPECTED
        Unexpected programming error. Logging not done and not needed.
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.


Remarks
    The function will return TRUE in the pbSupportedByThisProvider
    parameter if it is possible to create a snapshot on the given volume.
    The function must return TRUE on that volume even if the current
    configuration does not allow the creation of a snapshot on that volume.
    For example, if the maximum number of snapshots were reached on the
    given volume (and therefore no more snapshots can be created on that volume),
    the method must still indicate that the volume can be snapshotted.

--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::IsVolumeSupported" );

    try
    {
        ::VssZeroOut(pbSupportedByThisProvider);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n",
             pwszVolumeName,
             pbSupportedByThisProvider);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSupportedByThisProvider == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid bool");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Freeze the context
        //
        FreezeContext();

        // Get volume information. This may throw.
        LONG lVolAttr = GetVolumeInformationFlags(pwszVolumeName, GetContextInternal());
        (*pbSupportedByThisProvider) = ((lVolAttr & VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) != 0);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}




STDMETHODIMP CVsSoftwareProvider::IsVolumeSnapshotted(
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSnapshotsPresent,
	OUT 	LONG *		    plSnapshotCompatibility
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the
    corresponding provider.

Parameters
    pwszVolumeName
        [in] The volume name to be checked. It must be one of those returned by
        GetVolumeNameForVolumeMountPoint, in other words in
        the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format
        with the corresponding unique ID.(with trailing backslash)
    pbSnapshotPresent
        [out] Non-NULL pointer that receives TRUE if the volume has at least
        one snapshot or FALSE otherwise.
    plSnapshotCompatibility
        [out] Flags denoting the compatibility of the snapshotted volume with various operations

Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not an administrator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    E_OUTOFMEMORY
        Out of memory or other system resources
    E_UNEXPECTED
        Unexpected programming error. Logging not done and not needed.
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.


Remarks
    The function will return S_OK even if the current volume is a non-supported one.
    In this case FALSE must be returned in the pbSnapshotPresent parameter.

--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::IsVolumeSnapshotted" );

    try
    {
        ::VssZeroOut(pbSnapshotsPresent);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %p\n"
             L"  pbSnapshotsPresent = %p\n"
             L"  plSnapshotCompatibility = %p\n",
             pwszVolumeName,
             pbSnapshotsPresent,
             plSnapshotCompatibility);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSnapshotsPresent == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid bool");
        if (plSnapshotCompatibility == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid plSnapshotCompatibility");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Freeze the context
        //
        FreezeContext();

        // Get volume information. This may throw,
        LONG lVolAttr = GetVolumeInformationFlags(pwszVolumeName, GetContextInternal());

        // Bug 500069: Allow DEFRAG on Babbage snapshotted volumes
        (*pbSnapshotsPresent) = ((lVolAttr & VSS_VOLATTR_SNAPSHOTTED) != 0);
        (*plSnapshotCompatibility) = ((lVolAttr & VSS_VOLATTR_SNAPSHOTTED) != 0)?
            (/*VSS_SC_DISABLE_DEFRAG|*/VSS_SC_DISABLE_CONTENTINDEX): 0 ;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


LONG CVsSoftwareProvider::GetVolumeInformationFlags(
    IN  LPCWSTR pwszVolumeName,
    IN  LONG    lContext,
    IN OUT CVssAutoPWSZ * pawszLastSnapshotName,  /* = NULL */
    IN  BOOL bThrowIfError                        /* = TRUE */
    ) throw(HRESULT)

/*++

Description:

    This function returns various attributes that describe
        - if the volume is supported by this provider
        - if the volume has snapshots.

Parameter:

    [in] The volume name to be checked. It must be one of those returned by
    GetVolumeNameForVolumeMountPoint, in other words in
    the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format
    with the corresponding unique ID.(with trailing backslash)

    [in] The context.

Return values:

    A combination of _VSS_VOLUME_INFORMATION_ATTR flags.

    If pwszLastSnapshotName is not NULL, return the name of the last snapshot

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.
    E_UNEXPECTED
        Unexpected programming error. Nothing is logged.
    VSS_E_OBJECT_NOT_FOUND
        The device does not exist or it is not ready.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::GetVolumeInformationFlags" );
	CVssIOCTLChannel volumeIChannel;	// For checking the snapshots on a volume
    LONG lReturnedFlags = 0;

    // Argument validation
    BS_ASSERT(pwszVolumeName);
   	BS_ASSERT(::IsVolMgmtVolumeName( pwszVolumeName ));

    // Check if the volume is fixed (i.e. no CD-ROM, no removable)
    UINT uDriveType = ::GetDriveTypeW(pwszVolumeName);
    if ( uDriveType != DRIVE_FIXED) {
        ft.Trace( VSSDBG_SWPRV, L"Warning: Ignoring the non-fixed volume (%s) - %ud",
                  pwszVolumeName, uDriveType);
        return lReturnedFlags;
    }

    //
    //  Static member to keep the quorum volume (and not to recompute it each time)
    //
    //  NOTE: 
    //      We presume that the quorum volume doesn't change for the lifetime of this process, 
    //      so we don't need to recompute it each time (that would be inefficient)
    //
    static CVssClusterQuorumVolume objQuorumVolumeHolder;
    bool bIsQuorum = objQuorumVolumeHolder.IsQuorumVolume(pwszVolumeName);

    if (bIsQuorum)
        lReturnedFlags |= VSS_VOLATTR_IS_QUORUM;

    // Check if the volume is NTFS
    DWORD dwFileSystemFlags = 0;
    WCHAR wszFileSystemNameBuffer[MAX_PATH+1];
    wszFileSystemNameBuffer[0] = L'\0';
    if (!::GetVolumeInformationW(pwszVolumeName,
            NULL,   // lpVolumeNameBuffer
            0,      // nVolumeNameSize
            NULL,   // lpVolumeSerialNumber
            NULL,   // lpMaximumComponentLength
            &dwFileSystemFlags,
            wszFileSystemNameBuffer,
            MAX_PATH
            ))
    {
        DWORD dwLastErr =  GetLastError();
        ft.Trace( VSSDBG_SWPRV,
                  L"Warning: Error calling GetVolumeInformation on volume '%s' 0x%08lx",
                  pwszVolumeName, dwLastErr);

        // Check if the volume was found
        if ((dwLastErr == ERROR_NOT_READY) ||
            (dwLastErr == ERROR_DEVICE_NOT_CONNECTED)) {
            if (bThrowIfError)
                ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
                      L"Volume not found: error calling GetVolumeInformation on volume '%s' : %u",
                      pwszVolumeName, dwLastErr );
            else
                return lReturnedFlags;
        }

        // Eliminate the cases when GetVolumeInformationW failed from other reasons
        if (dwLastErr != ERROR_UNRECOGNIZED_VOLUME) {
            // Log an warning. 
            // Make sure that GetVolumeInformationW doesn't fail here for obvious reasons.
            wszFileSystemNameBuffer[MAX_PATH]=L'\0';
            ft.LogGenericWarning(VSSDBG_SWPRV, 
                L"GetVolumeInformationW(%s,NULL,0,NULL,NULL,[0x%08lx], %s, %ld) == 0x%08lx", 
                    pwszVolumeName, dwFileSystemFlags, wszFileSystemNameBuffer, (LONG)MAX_PATH, dwLastErr);
            return lReturnedFlags;
        }

        // RAW volumes (error ERROR_UNRECOGNIZED_VOLUME) are supported by VSS (bug 209059, 457354)
        lReturnedFlags |= VSS_VOLATTR_VOLUME_IS_RAW;

        if ( (lContext != VSS_CTX_ALL) && (
             (lContext & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE) ||
             (lContext & VSS_VOLSNAP_ATTR_PERSISTENT) )
            ) {
            // ...but they are not supported for timewarp nor persistent snapshots (bug 504783)
            ft.Trace( VSSDBG_SWPRV, L"Encountered a RAW volume (%s)", pwszVolumeName);
            return lReturnedFlags;
        }
    }
    else
    {
        // We do not support snapshots on read-only volumes
        if (dwFileSystemFlags & FILE_READ_ONLY_VOLUME) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a read-only volume (%s)", pwszVolumeName);
            return lReturnedFlags;
        }

        // If the file system is NTFS then mark the volume as supported for diff area
        if (::wcscmp(wszFileSystemNameBuffer, wszFileSystemNameNTFS) == 0) {
            // Check first that the volume is large enough
            ULARGE_INTEGER ulnNotUsed1;
            ULARGE_INTEGER ulnTotalNumberOfBytes;
            ULARGE_INTEGER ulnNotUsed2;
            ulnTotalNumberOfBytes.QuadPart = 0;

            // Mark the volume as supported since it is NTFS and large enough
            if (::GetDiskFreeSpaceEx(pwszVolumeName,
                    &ulnNotUsed1,
                    &ulnTotalNumberOfBytes,
                    &ulnNotUsed2
                    )) {
                ft.Trace(VSSDBG_SWPRV, L"RANK: total=%I64d max=%I64d",
                     ulnTotalNumberOfBytes.QuadPart, (LONGLONG)x_nDefaultInitialSnapshotAllocation);
                if (ulnTotalNumberOfBytes.QuadPart >= (LONGLONG)x_nDefaultInitialSnapshotAllocation)
                {
                    // Supports diff area only if this is not the quorum volume (bug# 661583)
                    if (!bIsQuorum)
            	        lReturnedFlags |= VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA;
                }

            } else {
                DWORD dwLastErr = GetLastError();
                ft.Trace( VSSDBG_SWPRV, L"Cannot get the free space for volume (%s) - [0x%08lx]",
                          pwszVolumeName, dwLastErr);
                ft.LogGenericWarning(VSSDBG_SWPRV, 
                    L"GetDiskFreeSpaceEx() for %s failed with 0x%08lx", pwszVolumeName, dwLastErr);
            }
        }
        else if ( (lContext != VSS_CTX_ALL) && (
            (lContext & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE) ||
            (lContext & VSS_VOLSNAP_ATTR_PERSISTENT) )
            )
        {
            // For timewarp & persistent context do not support FAT
            ft.Trace( VSSDBG_SWPRV, L"Encountered a non-NTFS volume (%s) - %s",
                      pwszVolumeName, wszFileSystemNameBuffer);
            return lReturnedFlags;
        }
    }

    try {
        // Open the volume. Throw "object not found" if needed.
	    volumeIChannel.Open(ft, pwszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV, 0);

        // Check to see if there are existing snapshots
	    ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS);
        if (ft.HrFailed()) {
            // The volume is not even supported
            lReturnedFlags = 0;
            ft.Throw( VSSDBG_SWPRV, S_OK, 
                L"Volume is not supported by volsnap driver. Call returned 0x%08lx", ft.hr);
        }

	    // Mark the volume as supported since the query succeeded.
	    // But do not mark the quorum volume as supported for Timewarp.
        if ( !(bIsQuorum 
                && ((lContext & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE) != 0) 
                && (lContext != VSS_CTX_ALL)))
    	    lReturnedFlags |= VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT;

	    // Get the length of snapshot names multistring
	    ULONG ulMultiszLen;
	    volumeIChannel.Unpack(ft, &ulMultiszLen);

        // If the multistring is empty, then ulMultiszLen is necesarily 2
        // (i.e. two l"\0' characters)
        // Then mark the volume as snapshotted.
	    if (ulMultiszLen != x_nEmptyVssMultiszLen)
	    {
	        lReturnedFlags |= VSS_VOLATTR_SNAPSHOTTED;

            // Return the last snapshot if needed
       	    if (pawszLastSnapshotName)
       	    {
       	        CVssAutoPWSZ awszSnapshotName;
        	    while(volumeIChannel.UnpackZeroString(ft, awszSnapshotName.GetRef()))
        	        pawszLastSnapshotName->TransferFrom(awszSnapshotName);
       	    }
	    }
    }
    VSS_STANDARD_CATCH(ft);

    if (FAILED(ft.hr)  && bThrowIfError)
        ft.Throw( VSSDBG_SWPRV, ft.hr, L"Rethrowing");

    return lReturnedFlags;
}



CVsSoftwareProvider::CVsSoftwareProvider():
    m_bContextFrozen(false),
    m_lSnapContext(VSS_CTX_BACKUP),
    m_dwMaxCAShadowCopies(x_MaxCAShadowCopiesDefault)
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::CVsSoftwareProvider");

    // Create the provider instance Id (which is used to mark the queued snapshots that belongs to it)
    ft.hr = ::CoCreateGuid(&m_ProviderInstanceID);
    if (ft.HrFailed()) {
        m_ProviderInstanceID = GUID_NULL;
        ft.Trace( VSSDBG_SWPRV, L"CoCreateGuid failed 0x%08lx", ft.hr );
        // TBD: Add event log here.
    }
    else {
        BS_ASSERT(m_ProviderInstanceID != GUID_NULL);
    }

    // Try to read the "max shadow copies" registry key
    try
    {
        CVssRegistryKey keyMaxCAShadowCopies(KEY_READ);
        if (keyMaxCAShadowCopies.Open(HKEY_LOCAL_MACHINE, x_wszVssCASettingsPath))
        {
            DWORD dwMaxCAShadowCopies = 0;
            if (keyMaxCAShadowCopies.GetValue(x_wszVssCAMaxShadowCopiesValueName, 
                    dwMaxCAShadowCopies, false))
            {
                // Zero means "no limit"
                if (dwMaxCAShadowCopies == 0)
                    dwMaxCAShadowCopies = MAXDWORD;

                m_dwMaxCAShadowCopies = dwMaxCAShadowCopies;
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

    // Ignore the falures - logging is already done
}


CVsSoftwareProvider::~CVsSoftwareProvider()
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::~CVsSoftwareProvider");

    // Lock in order to update both variables atomically
    // The critical section will be left automatically at the end of scope.
    CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());


    // Remove here all [Auto-Delete] queued snapshots that belong to this particular
    // Provider Instance ID.
    // The volume handle gets closed here and this will delete the underlying snapshots.
    if (m_ProviderInstanceID != GUID_NULL)
        RemoveSnapshotsFromGlobalList(m_ProviderInstanceID, GUID_NULL, VSS_QST_REMOVE_SPECIFIC_QS);
    else {
        BS_ASSERT(false);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
#include "vs_inc.hxx"

#include "swprv.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */

// Define the VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE guid
#include "initguid.h"
#include "ntddsnap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\query.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Query.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   09/15/1999

Revision History:

    Name        Date        Comments

    aoltean     09/23/1999  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRQRYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsSoftwareProvider::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )
/*++

Routine description:

    Implements IVssSnapshotProvider::Query

Return values:

    E_OUTOFMEORY
    E_ACCESSDENIED
        - if the user is not administrator
    E_INVALIARG
    E_UNEXPECTED
        - Dev error - no logging.

    [CVssQueuedSnapshot::EnumerateSnapshots() failures]
        VSS_E_PROVIDER_VETO
            - On runtime errors
        E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");
        
        ft.Trace( VSSDBG_SWPRV, L"Parameters: QueriedObjectId = " WSTR_GUID_FMT
				  L"eQueriedObjectType = %d. eReturnedObjectsType = %d, ppEnum = %p",
				  GUID_PRINTF_ARG( QueriedObjectId ),
				  eQueriedObjectType,
				  eReturnedObjectsType,
				  ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");
        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");
        if (eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

        //
        //  Freeze the context
        //
        FreezeContext();

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// Get the list of snapshots in the give array
		CVssQueuedSnapshot::EnumerateSnapshots( false, GUID_NULL, GetContextInternal(), pArray);

        // Create the enumerator object. 
		ft.hr = VssBuildEnumInterface<CVssEnumFromArray>( VSSDBG_SWPRV, pArray, ppEnum );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\qsnap.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module QSnap.hxx | Defines the internal data structure attached to a snapshot.
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     11/??/1999  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "vssmsg.h"

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRQSNPC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssQueuedSnapshot IOCTL commands


void CVssQueuedSnapshot::OpenVolumeChannel() throw(HRESULT)

/*++

Description:

	Open the volume IOCTL.

Warning:

	The original volume name must be already known!

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::OpenVolumeChannel");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Open the volume channel, if needed.
	if( !m_snapIChannel.IsOpen() )
	{
		if (pProp->m_pwszOriginalVolumeName == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown volume name." );
		}

		// Open the channel. Remove the trailing backslash. It will throw on error.
		BS_ASSERT(::wcslen(pProp->m_pwszOriginalVolumeName) == x_nLengthOfVolMgmtVolumeName);
		m_volumeIChannel.Open(ft, pProp->m_pwszOriginalVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);
	}
}


void CVssQueuedSnapshot::OpenSnapshotChannel() throw(HRESULT)

/*++

Description:

	Open the snapshot IOCTL.

Warning:

	The snapshot device name must be already known!

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::OpenSnapshotChannel");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Open the snapshot channel, if needed.
   	BS_ASSERT(!IsDuringCreation());
	if( !m_snapIChannel.IsOpen() )
	{
		if (pProp->m_pwszSnapshotDeviceObject == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown device object." );
		}
		
        // Open the snapshot. There is no trailing backslash to eliminate.
        // It will throw on error and log it.
        //
        //  Open the snapshot with no access rights for perf reasons (bug #537974)
		m_snapIChannel.Open(ft, pProp->m_pwszSnapshotDeviceObject, false, true, 
                        		VSS_ICHANNEL_LOG_PROV, 0);
	}
}


void CVssQueuedSnapshot::PrepareForSnapshotIoctl()

/*++

Description:

	Send IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::PrepareForSnapshotIoctl");

	BS_ASSERT(m_volumeIChannel.IsOpen());
	

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_VERIFY(pProp && (pProp->m_pwszOriginalVolumeName != NULL));

/* 
    TBD: Replace this code with the correct code that rejects creation of multiple backup snapshots

    // Check to see if there are existing snapshots
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, true, VSS_ICHANNEL_LOG_PROV);

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	m_volumeIChannel.Unpack(ft, &ulMultiszLen);

    // If the multistring is empty, then ulMultiszLen is necesarily 2
    // (i.e. two l"\0' characters)
	if (ulMultiszLen != 2) {
	    ft.LogError( VSS_ERROR_MULTIPLE_SNAPSHOTS_UNSUPPORTED,
	        VSSDBG_SWPRV << pProp->m_pwszOriginalVolumeName );
	    ft.Throw( VSSDBG_SWPRV, VSS_E_PROVIDER_VETO,
	              L"A snapshot already exist on the current volume" );
	}
*/

	// Pack snapshot attributes
	ULONG ulTmp = static_cast<ULONG>(0);
    // Make snapshot persistent, if needed
    if (GetContextInternal() & VSS_VOLSNAP_ATTR_PERSISTENT)
        ulTmp |= VOLSNAP_ATTRIBUTE_PERSISTENT;
	m_volumeIChannel.Pack(ft, ulTmp);

	// Pach the reserved field
	ulTmp = 0;
	m_volumeIChannel.Pack(ft, ulTmp);

	// Pack initial allocation size
	m_volumeIChannel.Pack(ft, m_llInitialAllocation);

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssQueuedSnapshot::CommitSnapshotIoctl()  throw(HRESULT)

/*++

Description:

	Send IOCTL_VOLSNAP_COMMIT_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::CommitSnapshotIoctl");

	BS_ASSERT(m_volumeIChannel.IsOpen());

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_COMMIT_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV_TIMEOUT);
}


void CVssQueuedSnapshot::EndCommitSnapshotIoctl(
	IN	PVSS_SNAPSHOT_PROP pProp
	) throw(HRESULT)

/*++

Description:

	Send IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT. Save also the snapshot properties.

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EndCommitSnapshotIoctl");

    BS_ASSERT(pProp);
    BS_ASSERT(pProp->m_pwszSnapshotDeviceObject == NULL);
	BS_ASSERT(m_volumeIChannel.IsOpen());

    // Save the snapshot properties
    SaveStructure(m_volumeIChannel, pProp, GetContextInternal(), false);

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
}



HRESULT CVssQueuedSnapshot::AbortPreparedSnapshotIoctl()

/*++

Description:

	Send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::AbortPreparedSnapshotIoctl");

	try
	{
		BS_ASSERT(m_volumeIChannel.IsOpen());

		// send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssQueuedSnapshot constructor


CVssQueuedSnapshot::CVssQueuedSnapshot(
	IN  VSS_OBJECT_PROP_Ptr& ptrSnap,	// Ownership passed to the Constructor
    IN  VSS_ID ProviderInstanceId,
    IN  LONG   lContext
	):
	m_cookie(VSS_NULL_COOKIE),
	m_llInitialAllocation(x_nDefaultInitialSnapshotAllocation),			// Babbage-related properties
	m_ptrSnap(ptrSnap),					// Properties related to the standard structure.
	m_lRefCount(0),						// Life-management
    m_ProviderInstanceId(ProviderInstanceId),
    m_lContext(lContext)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::CVssQueuedSnapshot");
}


CVssQueuedSnapshot::~CVssQueuedSnapshot()
/*++

Remarks: 

    Delete here all auto-delete snapshots

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::~CVssQueuedSnapshot");
    VSS_ID SnapshotId = GUID_NULL;
    
    try
    {
        // Get the snapshot Id
    	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
        BS_ASSERT(pProp);
    	SnapshotId = pProp->m_SnapshotId;

        ft.Trace( VSSDBG_SWPRV, L"INFO: Attempting to garbage collect snapshot with Id " WSTR_GUID_FMT L" [0x%08lx]", 
            GUID_PRINTF_ARG(SnapshotId), ft.hr);
        
        // If the snapshot is auto-release then delete it now.
        if ((SnapshotId != GUID_NULL) && 
            ((GetContextInternal() & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) == 0))
        {
            LONG lDeletedSnapshots = 0;
            VSS_ID SnapshotWithProblem = GUID_NULL;
            ft.hr = CVsSoftwareProvider::InternalDeleteSnapshots( SnapshotId, 
                        VSS_OBJECT_SNAPSHOT,
                        GetContextInternal(),
                        &lDeletedSnapshots,
                        &SnapshotWithProblem
                        );
            BS_ASSERT(lDeletedSnapshots <= 1);
        }
    }
    VSS_STANDARD_CATCH(ft)

    // Do not throw or log any error, we are in a destructor.
    if (ft.HrFailed())
        ft.Trace( VSSDBG_SWPRV, L"Error deleting snapshot with Id " WSTR_GUID_FMT L" [0x%08lx]", 
            GUID_PRINTF_ARG(SnapshotId), ft.hr);
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot Operations


PVSS_SNAPSHOT_PROP CVssQueuedSnapshot::GetSnapshotProperties()
{
	CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVssQueuedSnapshot::GetSnapshotProperties");

	if (m_ptrSnap.GetStruct() == NULL ||
		m_ptrSnap.GetStruct()->Type != VSS_OBJECT_SNAPSHOT)
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL  or invalid properties structure.");

	return &(m_ptrSnap.GetStruct()->Obj.Snap);
}

void CVssQueuedSnapshot::SetInitialAllocation(
	LONGLONG llInitialAllocation
	)
{
	m_llInitialAllocation = llInitialAllocation;
}


LONGLONG CVssQueuedSnapshot::GetInitialAllocation()
{
	return m_llInitialAllocation;
}


VSS_SNAPSHOT_STATE CVssQueuedSnapshot::GetStatus()	
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	return pProp->m_eStatus;
}


bool CVssQueuedSnapshot::IsDuringCreation()

/*++

Description:

	This method returns true if the snapshot is during creation

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::IsDuringCreation");

	VSS_SNAPSHOT_STATE eState = GetStatus();

	switch(eState)
	{
	case VSS_SS_PREPARING:
	case VSS_SS_PROCESSING_PREPARE:
	case VSS_SS_PREPARED:
	case VSS_SS_PROCESSING_PRECOMMIT:
	case VSS_SS_PRECOMMITTED:
	case VSS_SS_PROCESSING_COMMIT:
	case VSS_SS_COMMITTED:
	case VSS_SS_PROCESSING_POSTCOMMIT:
		return true;
	default:
		return false;
	}
}


void CVssQueuedSnapshot::ResetSnapshotProperties() throw(HRESULT)

/*++

Description:

	Reset the internal fields that can change between Get calls.
	Cache only the immutable fields (for the future Gets on the same interface):
	- Snapshot ID
	- Snapshot Set ID
	- Provider ID
	- Snapshot Device name
	
--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::ResetSnapshotProperties");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Reset the non-immutable property fields
	::VssFreeString(pProp->m_pwszOriginalVolumeName);
	pProp->m_eStatus = VSS_SS_UNKNOWN;

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();
}


void CVssQueuedSnapshot::ResetAsPreparing()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::ResetAsPreparing");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT((pProp->m_eStatus == VSS_SS_PREPARING)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_PREPARE)||
        (pProp->m_eStatus == VSS_SS_PREPARED)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_PRECOMMIT)||
		(pProp->m_eStatus == VSS_SS_PRECOMMITTED) ||
        (pProp->m_eStatus == VSS_SS_PROCESSING_COMMIT)||
		(pProp->m_eStatus == VSS_SS_COMMITTED)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_POSTCOMMIT)||
		(pProp->m_eStatus == VSS_SS_CREATED));

	// Reset the properties/members that were completed during PreCommit, Commit or PostCommit
	pProp->m_SnapshotId = GUID_NULL;
	BS_ASSERT(pProp->m_pwszSnapshotDeviceObject == NULL);
	pProp->m_eStatus = VSS_SS_PREPARING;

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();
}


void CVssQueuedSnapshot::MarkAsProcessingPrepare()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPrepare");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_eStatus == VSS_SS_PREPARING);
    pProp->m_eStatus = VSS_SS_PROCESSING_PREPARE;
}


void CVssQueuedSnapshot::MarkAsPrepared()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsPrepared");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_PREPARE);
	pProp->m_eStatus = VSS_SS_PREPARED;
}


void CVssQueuedSnapshot::MarkAsProcessingPreCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPreCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_eStatus == VSS_SS_PREPARED);
    pProp->m_eStatus = VSS_SS_PROCESSING_PRECOMMIT;
}


void CVssQueuedSnapshot::MarkAsPreCommitted()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsPreCommitted");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_PRECOMMIT);
	pProp->m_eStatus = VSS_SS_PRECOMMITTED;
}


void CVssQueuedSnapshot::MarkAsProcessingCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PRECOMMITTED);
    pProp->m_eStatus = VSS_SS_PROCESSING_COMMIT;
}


void CVssQueuedSnapshot::MarkAsCommitted()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsCommitted");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_COMMIT);
	pProp->m_eStatus = VSS_SS_COMMITTED;
}


void CVssQueuedSnapshot::MarkAsProcessingPostCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPostCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_COMMITTED);
    pProp->m_eStatus = VSS_SS_PROCESSING_POSTCOMMIT;
}


void CVssQueuedSnapshot::MarkAsCreated()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsCreated");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Reset the properties/members that were completed during PreCommit, Commit or PostCommit
	BS_VERIFY(pProp && (pProp->m_pwszSnapshotDeviceObject == NULL));

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();

	// Assert that the snapshot state
	// is set before "save"
	BS_ASSERT(pProp->m_eStatus == VSS_SS_CREATED);
}


void CVssQueuedSnapshot::SetPostcommitInfo(
    IN  LONG lSnapshotsCount
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SetPostcommitInfo");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_SnapshotId != GUID_NULL);

	// Set the snapshots count
	BS_ASSERT(lSnapshotsCount != 0);
	BS_ASSERT(pProp->m_lSnapshotsCount == 0);
	pProp->m_lSnapshotsCount = lSnapshotsCount;

	// Set the snapshot state to "created" since it will be saved.
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_POSTCOMMIT);
	pProp->m_eStatus = VSS_SS_CREATED;
}


VSS_ID CVssQueuedSnapshot::GetProviderInstanceId()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::GetProviderInstanceId");

    return m_ProviderInstanceId;
}


void CVssQueuedSnapshot::AttachToGlobalList() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::AttachToGlobalList");

	// The caller must have a separate reference to the object
	AddRef();

	BS_ASSERT( m_cookie == VSS_NULL_COOKIE );
	m_cookie = m_list.AddTail( ft, this );
}


void CVssQueuedSnapshot::DetachFromGlobalList()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::DetachFromGlobalList");

	BS_ASSERT( m_cookie != VSS_NULL_COOKIE );

	CVssQueuedSnapshot* pThis;
	m_list.ExtractByCookie( m_cookie, pThis );
	BS_ASSERT( this == pThis );
	m_cookie = VSS_NULL_COOKIE;

	// The caller must have a separate reference to the object
	Release();
}


VSS_ID CVssQueuedSnapshot::GetSnapshotID()
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

    return pProp->m_SnapshotId;
}


VSS_ID CVssQueuedSnapshot::GetSnapshotSetID()
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

    return pProp->m_SnapshotSetId;
}
	


/////////////////////////////////////////////////////////////////////////////
// CVssSnapIterator
//


CVssSnapIterator::CVssSnapIterator():
	CVssDLListIterator<CVssQueuedSnapshot*>(CVssQueuedSnapshot::m_list)
{}


CVssQueuedSnapshot* CVssSnapIterator::GetNext()
{
	CVssQueuedSnapshot* pObj;
	if (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
        return pObj;
    else
        return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextBySnapshot(
	IN		VSS_ID SID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->GetSnapshotID() == SID)
			return pObj;
	return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextBySnapshotSet(
	IN		VSS_ID SSID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->GetSnapshotSetID() == SSID)
			return pObj;
	return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextByProviderInstance(
	IN		VSS_ID PIID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->m_ProviderInstanceId == PIID)
			return pObj;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\clogmsg.h ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: snapsql.cpp
//
// PURPOSE:
//
//      Implement the SQLServer Volume Snapshot Writer.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************

class CLogMsg
	{
public:
	CLogMsg() :
		m_cwc(0),
		m_bEof(false)
		{
		m_rgwc[0] = L'\0';
		}

	LPCWSTR GetMsg()
		{
		return m_rgwc;
		}

	void Add(LPCWSTR wsz)
		{
		if (m_bEof)
			return;

		UINT cwc = (UINT) wcslen(wsz);

		if (cwc + m_cwc + 5 > x_MAX_MSG_SIZE)
			{
			wcscpy(m_rgwc + m_cwc, L" ...");
			m_cwc += 4;
			m_bEof = TRUE;
			}
		else
			{
			wcscpy(m_rgwc + m_cwc, wsz);
			m_cwc += cwc;
			}
		}

private:
	enum
		{
		x_MAX_MSG_SIZE = 2048
		};

    // size of string
    UINT m_cwc;

	// string
	WCHAR m_rgwc[x_MAX_MSG_SIZE];

	// end of string encountered
	bool m_bEof;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\persist.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Persist.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


Storage Format for all structures:

	The snapshot structures for the MS Software Snapshot Provider
	have the following format:

	+-----------------+
	|  AppInfo GUID   |   GUID: VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU,
	|                 |         VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE or
	|                 |         VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN
	|                 |
	+-----------------+
	|   Snapshot ID   |   GUID: Snapshot ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshot Set ID |   GUID: Snapshot Set ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	|  Snapshot ctx   |   LONG: Snapshot context
	+-----------------+
	| Snapshots count |   LONG: Snapshots count in the snapshot set.
	+-----------------+
	|  Snapshot attr  |   LONG: Snapshot attributes
	+-----------------+
	| Exposed name    |   Packed small string: Exposed name 
	| ...             |   
	+-----------------+
	| Exposed path    |   Packed small string: Exposed path
	| ...             |   
	+-----------------+
	| Originating m.  |   Packed small string: Originating machine
	| ...             |   
	+-----------------+
	| Service machine |   Packed small string: Service machine
	| ...             |   
	+-----------------+

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRPERSC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::SaveStructure(
    IN  CVssIOCTLChannel& channel,
	IN	PVSS_SNAPSHOT_PROP pProp,
  	IN  LONG lContext, 
  	IN  bool bHidden
    ) throw(HRESULT)

/*++

Description:

	This function will save the properties related to the snapshot in the given IOCTL channel

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SaveStructure");

	BS_ASSERT(lContext != VSS_CTX_ALL);
    BS_ASSERT(pProp);
    BS_ASSERT(channel.IsOpen());

	// Pack the length of the entire buffer
	PVOID pulBufferLength = channel.Pack(ft, (ULONG)0 ); // unknown right now
	
	// Start counting entire buffer length
	DWORD dwInitialOffset = channel.GetCurrentInputOffset();
	
	// Pack the AppInfo ID
	VSS_ID AppinfoId;
	if (bHidden)
	    AppinfoId = VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN;
    else 
        switch(lContext)
    	{
        case VSS_CTX_BACKUP:
    	    AppinfoId = VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU;
    	    break;
        case VSS_CTX_CLIENT_ACCESSIBLE:
    	    AppinfoId = VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE;
    	    break;
        case VSS_CTX_NAS_ROLLBACK:
    	    AppinfoId = VOLSNAP_APPINFO_GUID_NAS_ROLLBACK;
    	    break;
        case VSS_CTX_APP_ROLLBACK:
    	    AppinfoId = VOLSNAP_APPINFO_GUID_APP_ROLLBACK;
    	    break;
        case VSS_CTX_FILE_SHARE_BACKUP:
    	    AppinfoId = VOLSNAP_APPINFO_GUID_FILE_SHARE_BACKUP;
    	    break;
    	default: 
    	    BS_ASSERT(false); // programming error?
    	    ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid conext 0x%08lx", lContext );
    	}
	channel.Pack(ft, AppinfoId);
	
	// Pack the Snapshot ID
	channel.Pack(ft, pProp->m_SnapshotId);
	
	// Pack the Snapshot Set ID
	channel.Pack(ft, pProp->m_SnapshotSetId);
	
	// Pack the snapshot context
	channel.Pack(ft, lContext);

	// Pack the number of snapshots in this snapshot set
	channel.Pack(ft, pProp->m_lSnapshotsCount);

	// Pack the snapshot attributes
	BS_ASSERT(lContext == (pProp->m_lSnapshotAttributes & ~x_lNonCtxAttributes));
	channel.Pack(ft, pProp->m_lSnapshotAttributes);

	// Pack the exposed name
	channel.PackSmallString(ft, pProp->m_pwszExposedName);

	// Pack the exposed path
	channel.PackSmallString(ft, pProp->m_pwszExposedPath);

	// Pack the originating machine
	channel.PackSmallString(ft, pProp->m_pwszOriginatingMachine);

	// Pack the service machine
	channel.PackSmallString(ft, pProp->m_pwszServiceMachine);

	// Compute the entire buffer length and save it.
	// TBD: move to ULONG
	DWORD dwFinalOffset = channel.GetCurrentInputOffset();
	
	BS_ASSERT( dwFinalOffset > dwInitialOffset );
	DWORD dwBufferLength = dwFinalOffset - dwInitialOffset;
	if ( dwBufferLength > (DWORD)((USHORT)(-1)) )
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
				L"Error: the buffer length cannot be stored in a USHORT %ld", dwBufferLength );
				
	ULONG ulBufferLength = (ULONG)dwBufferLength;
	BS_ASSERT( pulBufferLength );
	::CopyMemory(pulBufferLength, &ulBufferLength, sizeof(ULONG));
	BS_ASSERT( (DWORD)ulBufferLength == dwBufferLength );
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::LoadXXX methods
//



bool CVssQueuedSnapshot::LoadStructure(
    IN  CVssIOCTLChannel& channel,
	OUT PVSS_SNAPSHOT_PROP pProp,
   	OUT LONG * plContext,  
   	OUT bool * pbHidden,
	IN  bool bIDsAlreadyLoaded /* = false */
    )

/*++

Description:

	This function will load the properties related to the snapshot from the given IOCTL channel

Arguments:

    IN  CVssIOCTLChannel& channel,
	OUT PVSS_SNAPSHOT_PROP pProp,
   	OUT LONG * plContext,       = NULL   // If NULL do not return the context.
	IN  bool bIDsAlreadyLoaded  = false  // If true, do not load the buffer length, the IDs and the ctx

Returns:

    true - if the structure was succesfully loaded
    false - if the structure loading failed 

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadStructure");

	ULONG ulBufferLength = 0;
    DWORD dwInitialOffset = 0;

    // Set the properties that have a constant value.
    BS_ASSERT(pProp);
    pProp->m_eStatus = VSS_SS_CREATED;

    // Start unpacking
    VSS_ID AppinfoId = GUID_NULL;
    try
    {
        // if IDs not loaded yet
        if (!bIDsAlreadyLoaded) 
        {
        	// Unpack the length of the entire buffer
        	channel.Unpack(ft, &ulBufferLength );
        	if (ulBufferLength == 0)
        	    ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Warning: zero-size snapshot detected");

        	// Start counting entire buffer length, for checking
        	dwInitialOffset = channel.GetCurrentOutputOffset();

        	// Unpack the Appinfo ID
        	channel.Unpack(ft, &AppinfoId);
        	if ((AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU) &&
        	    (AppinfoId != VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE) &&
        	    (AppinfoId != VOLSNAP_APPINFO_GUID_NAS_ROLLBACK) &&
        	    (AppinfoId != VOLSNAP_APPINFO_GUID_APP_ROLLBACK) &&
        	    (AppinfoId != VOLSNAP_APPINFO_GUID_FILE_SHARE_BACKUP) &&
        	    (AppinfoId != VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN))
        	{
                // Unknown App Info GUID. The VSS code must ignore these snapshots
        	    ft.Trace(VSSDBG_SWPRV, L"Unknown app info " WSTR_GUID_FMT, GUID_PRINTF_ARG(AppinfoId));
        	    return false;
        	}

        	// Unpack the Snapshot ID
        	channel.Unpack(ft, &(pProp->m_SnapshotId));

        	// Unpack the Snapshot Set ID
        	channel.Unpack(ft, &(pProp->m_SnapshotSetId));

            // Unpack the context
            LONG lContext;
        	channel.Unpack(ft, &lContext);

    	    // Consistency check
    	    bool bHidden = !!(AppinfoId == VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN);
    	    if (!bHidden)
    	    {
    	        switch(lContext)
    	        {
                case VSS_CTX_BACKUP:
                    BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU);
                    break;
                case VSS_CTX_CLIENT_ACCESSIBLE:
                    BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE);
                    break;
                case VSS_CTX_NAS_ROLLBACK:
                    BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_NAS_ROLLBACK);
                    break;
                case VSS_CTX_APP_ROLLBACK:
                    BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_APP_ROLLBACK);
                    break;
                case VSS_CTX_FILE_SHARE_BACKUP:
                    BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_FILE_SHARE_BACKUP);
                    break;
                default:
                    // For known AppInfoID we should operate only with known contexes
                    BS_ASSERT(false);
                    ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid context 0x%08lx", lContext);
    	        }
    	    }

            // Return the context
            BS_ASSERT(plContext != NULL);
       	    (*plContext) = lContext;
        	
            // Return the Hidden flag
            BS_ASSERT(pbHidden)
           	(*pbHidden) = bHidden;
        }
        else 
        {
            BS_ASSERT(plContext == NULL);
            BS_ASSERT(pbHidden == NULL);
        }

        // Unpack the snapshots count
        channel.Unpack(ft, &(pProp->m_lSnapshotsCount) );

        // Unpack the attributes
    	channel.Unpack(ft, &(pProp->m_lSnapshotAttributes));
        
        if (!bIDsAlreadyLoaded) 
        {
        	BS_ASSERT(*plContext == (pProp->m_lSnapshotAttributes & ~x_lNonCtxAttributes));
        }

        // Unpack the exposed name
    	channel.UnpackSmallString(ft, pProp->m_pwszExposedName);

        // Unpack the exposed name
    	channel.UnpackSmallString(ft, pProp->m_pwszExposedPath);

        // Unpack the originating machine
    	channel.UnpackSmallString(ft, pProp->m_pwszOriginatingMachine);

        // Unpack the service machine
    	channel.UnpackSmallString(ft, pProp->m_pwszServiceMachine);

        if (bIDsAlreadyLoaded == false) {
    		// Compute the entire buffer length and check it.
    #ifdef _DEBUG
    		DWORD dwFinalOffset = channel.GetCurrentOutputOffset();
    		BS_ASSERT( dwFinalOffset > dwInitialOffset );
    		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulBufferLength );
    #endif
        }
    }
    VSS_STANDARD_CATCH(ft)

    // Return TRUE iif the structure was loaded completely.
    if (ft.HrFailed())
    {
        BS_ASSERT(false);
        ft.Trace( VSSDBG_SWPRV, L"Error while loading the structure. "
            L"hr = 0x%08lx, offset = %lu, "
            L" AppInfoID = " WSTR_GUID_FMT
            L" SnapshotID = " WSTR_GUID_FMT, 
            ft.hr, channel.GetCurrentOutputOffset(),
            AppinfoId, pProp->m_SnapshotId);
        return false;
    }

    return true;
}



void CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
    IN  CVssIOCTLChannel & snapshotIChannel,
    OUT LPWSTR * ppwszOriginalVolumeName
    ) throw(HRESULT)

/*++

Description:

	Load the original volume name and ID.
	Uses IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME.

Throws:

    VSS_E_PROVIDER_VETO
        - on runtime failures (like OpenSnapshotChannel, GetVolumeNameForVolumeMountPointW)
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl");
	LPCWSTR pwszDeviceVolumeName = NULL;

	try
	{
	    BS_ASSERT(ppwszOriginalVolumeName);
	    
    	// send the IOCTL.
    	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME, 
    	    true, VSS_ICHANNEL_LOG_PROV);

    	// Load the Original volume name
    	snapshotIChannel.UnpackSmallString(ft, pwszDeviceVolumeName);

    	// Get the user-mode style device name
    	WCHAR wszVolNameUsermode[MAX_PATH];
    	ft.hr = StringCchPrintfW(STRING_CCH_PARAM(wszVolNameUsermode),
        			L"%s%s\\", x_wszGlobalRootPrefix, pwszDeviceVolumeName);
        if (ft.HrFailed())
    		ft.TranslateGenericError( VSSDBG_SWPRV, ft.hr, L"StringCchPrintfW(,%s,%s)",
    		    x_wszGlobalRootPrefix, pwszDeviceVolumeName);

    	// Get the mount point for the original volume
    	WCHAR wszMPMVolumeName[MAX_PATH];
    	BOOL bSucceeded = ::GetVolumeNameForVolumeMountPointW(
    							wszVolNameUsermode,
    							wszMPMVolumeName, MAX_PATH );			
    	if (!bSucceeded)
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszVolNameUsermode);

        ::VssFreeString(*ppwszOriginalVolumeName);
        ::VssSafeDuplicateStr(ft, *ppwszOriginalVolumeName, wszMPMVolumeName);
    }
	VSS_STANDARD_CATCH(ft)

	::VssFreeString(pwszDeviceVolumeName);

	if (ft.HrFailed())
	    ft.Throw( VSSDBG_SWPRV, ft.hr, L"Exception detected");
}


void CVssQueuedSnapshot::LoadTimestampIoctl(
    IN  CVssIOCTLChannel &  snapshotIChannel,
    OUT VSS_TIMESTAMP    *  pTimestamp
    ) throw(HRESULT)

/*++

Description:

	Load the timestamp
	Uses IOCTL_VOLSNAP_QUERY_CONFIG_INFO.

Throws:

    VSS_E_PROVIDER_VETO
        - on runtime failures
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl");

    BS_ASSERT(pTimestamp);
    
	// send the IOCTL.
	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, 
	    true, VSS_ICHANNEL_LOG_PROV);

	// Load the attributes
	ULONG ulAttributes = 0;
	snapshotIChannel.Unpack(ft, &ulAttributes);

	// Load the reserved field
	ULONG ulReserved = 0;
	snapshotIChannel.Unpack(ft, &ulReserved);

	// Load the timestamp
	BS_ASSERT(sizeof(LARGE_INTEGER) == sizeof(*pTimestamp));
	snapshotIChannel.Unpack(ft, pTimestamp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\swprv.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module swprv.hxx | Definition the COM server of the Software Shadow Copy provider
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     09/09/1999  dss->vss

--*/


///////////////////////////////////////////////////////////////////////////////
//   Includes
//


#include "stdafx.hxx"
#include <process.h>
#include "initguid.h"

#include "vs_idl.hxx"

#include "vssmsg.h"
#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_reg.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provider.hxx"

#include <comadmin.h>
#include "comadmin.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRSWPRC"
//
////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//   Static objects
//

CSwprvServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VSSoftwareProvider, CVsSoftwareProvider)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
//   DLL Exports
//


//
// The real DLL Entry Point is _DLLMainCrtStartup (initializes global objects and after that calls DllMain
// this is defined in the runtime libaray
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        // Set the proper way for displaying asserts
//        ::VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}



// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer
STDAPI DllRegisterServer(void)
{
	return _Module.DllInstall(TRUE);
}


// DllUnregisterServer
STDAPI DllUnregisterServer(void)
{
	return _Module.DllInstall(FALSE);
}


// DllInstall - install the component into the COM+ catalog.
STDAPI DllInstall(	
	IN	BOOL bInstall,
	IN	LPCWSTR /* pszCmdLine */
)
{
	return _Module.DllInstall(bInstall);
}


// ServiceMain
VOID WINAPI ServiceMain(
    DWORD   /* dwNumServicesArgs */,
    LPWSTR* /* lpServiceArgVectors */
    )
{
    _Module.OnServiceMain();
}


///////////////////////////////////////////////////////////////////////////////////////
//  COM Server initialization
//

CSwprvServiceModule::CSwprvServiceModule()

/*++

Routine Description:

    Default constructor. Initialize ALL members with predefined values.

--*/

{
    ::VssZeroOut(&m_status);
    m_hInstance = NULL;
    m_hServiceStatus = NULL;
    m_dwThreadID = 0;
    m_bShutdownInProgress = false;
    m_bCOMStarted = false;

    // Initialize the members of the SERVICE_STATUS that don't change
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwControlsAccepted =
        SERVICE_ACCEPT_STOP |
        SERVICE_ACCEPT_SHUTDOWN;
}


void CSwprvServiceModule::InitializeCOM(
    IN  bool bMayAlreadyInit
    ) throw(HRESULT)

/*++

Routine Description:

    Initialize the service.

    If the m_status.dwWin32ExitCode is S_OK then initialization succeeded.
    Otherwise ServiceMain must silently shutdown the service.

Called by:

    CSwprvServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::InitializeCOM" );

    m_dwThreadID = GetCurrentThreadId();

    // Initialize the COM library
    ft.hr = CoInitializeEx(
            NULL,
            COINIT_MULTITHREADED
            );
    // We might ignore it if already initialized 
    if (bMayAlreadyInit && (ft.hr == RPC_E_CHANGED_MODE))
        return;
    if (ft.HrFailed())
        ft.TranslateGenericError( VSSDBG_SWPRV, ft.hr, L"CoInitializeEx");

    BS_ASSERT( ft.hr == S_OK );

    m_bCOMStarted = true;
}


void CSwprvServiceModule::UninitializeCOM()

/*++

Routine Description:

    Initialize the service.

    If the m_status.dwWin32ExitCode is S_OK then initialization succeeded.
    Otherwise ServiceMain must silently shutdown the service.

Called by:

    CSwprvServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::UninitializeCOM" );

    // Uninitialize the COM library
    if (m_bCOMStarted)
    {
        CoUninitialize();
        m_bCOMStarted = false;
    }
}




///////////////////////////////////////////////////////////////////////////////////////
// Service control routines (i.e. ServiceMain-related methods)
//


// Main service routine
void CSwprvServiceModule::OnServiceMain()

/*++

Routine Description:

    The main service control dispatcher.

Called by:

    Called by the NT Service framework following
    the StartServiceCtrlDispatcherW which was called in CSwprvServiceModule::StartDispatcher

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::OnServiceMain");

    try
    {
        // Needed for SERVICE_CONTROL_INTERROGATE that may come between the next two calls
        m_status.dwCurrentState = SERVICE_START_PENDING;

        // Register the control request handler
        m_hServiceStatus = ::RegisterServiceCtrlHandlerEx(GetServiceName(), _Handler, NULL);
        if ( m_hServiceStatus == NULL )
            ft.TranslateWin32Error( VSSDBG_SWPRV, L"RegisterServiceCtrlHandlerEx(%s)", g_wszSvcName);

        // Now we will really inform the SCM that the service is pending its start.
        SetServiceStatus(SERVICE_START_PENDING);

        // Internal initialization
        OnInitializing();

        // The service is started now.
        SetServiceStatus(SERVICE_RUNNING);

        // Wait for shutdown attempt
        OnRunning();

        // Shutdown was started either by receiving the SERVICE_CONTROL_STOP
        // or SERVICE_CONTROL_SHUTDOWN events either because the COM objects number is zero.
        SetServiceStatus(SERVICE_STOP_PENDING);

        // Perform the un-initialization tasks
        OnStopping();

        // The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed()) {

        // Present the error codes to the caller.
        m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        m_status.dwServiceSpecificExitCode = ft.hr;

        // Perform the un-initialization tasks
        OnStopping();

        // The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED, false);
    }
}


// Standard handler (static function)
DWORD WINAPI CSwprvServiceModule::_Handler
    (
    DWORD dwOpcode,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpEventContext
    )
    {
    return _Module.Handler(dwOpcode, dwEventType, lpEventData, lpEventContext);
    }


// The real handler
DWORD CSwprvServiceModule::Handler
    (
    DWORD dwOpcode,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpEventContext
    )

/*++

Routine Description:

    Used by Service Control Manager to inform this service about the service-related events

Called by:

    Service Control Manager.

--*/

    {
    UNREFERENCED_PARAMETER(lpEventContext);
    UNREFERENCED_PARAMETER(lpEventData);
    UNREFERENCED_PARAMETER(dwEventType);
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::Handler");
    DWORD dwResult = ERROR_CALL_NOT_IMPLEMENTED;

    try
        {
        // re-initialize "volatile" members
        m_status.dwCheckPoint = 0;
        m_status.dwWaitHint = 0;
        m_status.dwWin32ExitCode = 0;
        m_status.dwServiceSpecificExitCode = 0;

        switch (dwOpcode)
            {
            case SERVICE_CONTROL_INTERROGATE:
                dwResult = NOERROR;
                // Present the previous state.
                SetServiceStatus(m_status.dwCurrentState);
                break;

            case SERVICE_CONTROL_STOP:
            case SERVICE_CONTROL_SHUTDOWN:
                dwResult = NOERROR;
                SetServiceStatus(SERVICE_STOP_PENDING);
                OnSignalShutdown();
                // The SERVICE_STOPPED status must be communicated
                // in Service's main function.
                break;
            }
        }
    VSS_STANDARD_CATCH(ft)

    return dwResult;
    }


void CSwprvServiceModule::SetServiceStatus(
        IN  DWORD dwState,
        IN  bool bThrowOnError /* = true */
        )

/*++

Routine Description:

    Informs the Service Control Manager about the new status.

Called by:

    CSwprvServiceModule methods

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::SetServiceStatus");

    try
    {
        ft.Trace( VSSDBG_SWPRV, L"Attempt to change the service status to %lu", dwState);

        BS_ASSERT(m_hServiceStatus != NULL);

        // Inform SCM about the new status
        m_status.dwCurrentState = dwState;
        if ( !::SetServiceStatus(m_hServiceStatus, &m_status) )
            ft.TranslateWin32Error( VSSDBG_SWPRV, L"SetServiceStatus(%ld)", dwState);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.ThrowIf( bThrowOnError, VSSDBG_SWPRV, ft.hr,
                    L"Error on calling SetServiceStatus. 0x%08lx", ft.hr );
}


///////////////////////////////////////////////////////////////////////////////////////
// Service initialization, running and finalization routines
//


void CSwprvServiceModule::OnInitializing()

/*++

Routine Description:

    Initialize the service.

    If the m_status.dwWin32ExitCode is S_OK then initialization succeeded.
    Otherwise ServiceMain must silently shutdown the service.

Called by:

    CSwprvServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::OnInitializing" );

    //  Call CoInitialize(Ex)
    InitializeCOM(false);

    //
    // Initialize the security descriptor from registry
    // Contents: Admin, BO, System always enabled.
    // The rest of users are read from the SYSTEM\\CurrentControlSet\\Services\\VSS\\VssAccessControl key
    // The format of this registry key is a set of values of the form:
    //      REG_DWORD Name "domain1\user1", 1
    //      REG_DWORD Name "domain2\user2", 1
    //      REG_DWORD Name "domain3\user3", 0
    // where 1 means "Allow" and 0 means "Deny"
    //
    CVssSidCollection sidCollection;
    sidCollection.Initialize();

    // Get the SD. The pointer cannot be NULL
    PSECURITY_DESCRIPTOR pSD = sidCollection.GetSecurityDescriptor();
    BS_ASSERT(pSD);

    // Initialize COM security
    ft.hr = CoInitializeSecurity(
           pSD,                                 //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,       //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_DISABLE_AAA | EOAC_SECURE_REFS | EOAC_NO_CUSTOM_MARSHAL,
                                                //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );
    if (ft.HrFailed())
        ft.TranslateGenericError( VSSDBG_SWPRV, ft.hr, L"CoInitializeSecurity");

    //  Turns off SEH exception handing for COM servers (BUG# 530092)
    ft.ComDisableSEH(VSSDBG_SWPRV);

    // Create the event needed to synchronize
    m_hShutdownTimer.Attach( CreateWaitableTimer(
        NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
        TRUE,       //  IN BOOL bManualReset,
        NULL        //  IN LPCTSTR lpName
        ));
    if (! m_hShutdownTimer.IsValid() )
        ft.TranslateWin32Error( VSSDBG_SWPRV, L"CreateWaitableTimer");

    //  Register the COM class objects
    ft.hr = RegisterClassObjects( CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE );
    if (ft.HrFailed())
        ft.TranslateGenericError( VSSDBG_SWPRV, ft.hr, L"RegisterClassObjects");

    // The service is started now to prevent the service startup from
    // timing out.  The COM registration is done after we fully complete
    // initialization
    SetServiceStatus(SERVICE_RUNNING);
}


void CSwprvServiceModule::OnRunning()

/*++

Routine Description:

    Keeps the service alive until the job is done.

Called by:

    CSwprvServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::OnRunning" );

    // Wait for shutdown
    DWORD dwRet = WaitForSingleObject(
        m_hShutdownTimer,             // IN HANDLE hHandle,
        INFINITE                            // IN DWORD dwMilliseconds
        );
    if( dwRet != WAIT_OBJECT_0 )
        ft.TranslateWin32Error(VSSDBG_SWPRV, 
                L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hShutdownTimer.Get());

    // Trace the fact that the service will be shutdown
    ft.Trace( VSSDBG_SWPRV, L"SWPRV: %s event received",
        m_bShutdownInProgress? L"Shutdown": L"Idle timeout");
}


void CSwprvServiceModule::OnStopping()

/*++

Routine Description:

    Performs the uninitialization tasks.

Called by:

    CSwprvServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::OnStopping" );

    try
    {
        //  Unregister the COM classes
        ft.hr = RevokeClassObjects();
        if (ft.HrFailed())
            ft.Trace( VSSDBG_SWPRV, L" Error: RevokeClassObjects returned hr = 0x%08lx", ft.hr );

        // uninitialize COM, if needed
        UninitializeCOM();
    }
    VSS_STANDARD_CATCH(ft)
}


void CSwprvServiceModule::OnSignalShutdown()

/*++

Routine Description:

    Called when the current service should not be stopping its activity.
    Too bad about COM calls in progress - the running clients will get an error.

Called by:

    CSwprvServiceModule::Handler

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::OnSignalShutdown" );

    try
    {
        // Trace the fact that the service will be shutdown
        ft.Trace( VSSDBG_SWPRV, L"SWPRV: Trying to shutdown the service");
        
        if (m_hShutdownTimer.IsValid())
        {
            LARGE_INTEGER liDueTime;
            liDueTime.QuadPart = x_llSwprvShutdownTimeout;

            m_bShutdownInProgress = true;
            
            // Set the timer to become signaled immediately.
            if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
                ft.TranslateWin32Error( VSSDBG_SWPRV, L"SetWaitableTimer");
            
            BS_ASSERT(GetLastError() == 0);
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed()) {
        m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        m_status.dwServiceSpecificExitCode = ft.hr;
    }
}


///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//


LONG CSwprvServiceModule::Lock()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::Lock" );

    // If we are not shutting down then we are cancelling the "idle timeout" timer.
    if (!m_bShutdownInProgress) {

        // Trace the fact that the idle period is done.
        ft.Trace( VSSDBG_SWPRV, L"SWPRV: Idle period is finished");

        // Cancel the timer
        if (!::CancelWaitableTimer(m_hShutdownTimer))
            ft.Trace(VSSDBG_SWPRV, L"Error cancelling the waitable timer 0x%08lx", GetLastError());
    }

    return CComModule::Lock();
}


LONG CSwprvServiceModule::Unlock()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::Unlock" );

    // Check if we entered in the idle period.
    LONG lRefCount = CComModule::Unlock();
    if ( lRefCount == 0) {
        LARGE_INTEGER liDueTime;
        liDueTime.QuadPart = x_llSwprvIdleTimeout;

        // Trace the fact that the idle period begins
        ft.Trace( VSSDBG_SWPRV, L"SWPRV: Idle period begins");

        // Set the timer to become signaled after the proper idle time.
        // We cannot fail at this point (BUG 265455)
        if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
            ft.LogGenericWarning( VSSDBG_SWPRV, L"SetWaitableTimer(...) [0x%08lx]", GetLastError());
        BS_ASSERT(GetLastError() == 0);

        return 0;
    }
    return lRefCount;
}



///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//


HRESULT CSwprvServiceModule::DllInstall(
	IN	BOOL bInstall
    )

/*++

Routine Description:

    Initialize the service.

    If the m_status.dwWin32ExitCode is S_OK then initialization succeeded.
    Otherwise ServiceMain must silently shutdown the service.

Called by:

    CSwprvServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::DllInstall" );

    try
    {
        //  Call CoInitialize(Ex)
        InitializeCOM(true);

        // Unregister the old app
        OnUnregister();

        // Register the new app if needed
    	if (bInstall)
    	{
            try
            {
                // Try registration
                OnRegister();
            }
            VSS_STANDARD_CATCH(ft)

            // If registration failed, rollback
            if (ft.HrFailed())
                OnUnregister();
    	}
    }
    VSS_STANDARD_CATCH(ft)

    // uninitialize COM, if needed
    UninitializeCOM();

    return ft.hr;
}


// Registers the service
void CSwprvServiceModule::OnRegister() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::OnRegister" );

    //
    // Register the service with SVCHOST
    //

    // Get the SCM handle
    CVssAutoWin32ScHandle hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (!hSCM.IsValid())
        ft.TranslateWin32Error( VSSDBG_SWPRV, L"OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE)");

    // Create the service

    // Do the creation in a loop since the previous 
    // deletion (i.e. DeleteService) is asynchronous.
    //
    // Note: since the SWPRV service is not started at this 
    // point, the DeleteService should complete soon.
    //
    // In total we will spend here five minutes (60 * 5000 milliseconds) which 
    // is half of the SWPRV.DLL registration timeout in syssetup.inx
    //
    CVssAutoWin32ScHandle hService;
    for(INT nRetries = 0; nRetries < x_nMaxNumberOfCreateServiceRetries; nRetries++)
    {
         hService.Attach( ::CreateService(
            hSCM, 
            GetServiceName(), 
            GetServiceDisplayName(),
            SERVICE_CHANGE_CONFIG,
            SERVICE_WIN32_OWN_PROCESS,  // Not a shared SVCHOST
            SERVICE_DEMAND_START,
            SERVICE_ERROR_NORMAL,
            GetServiceBinaryPath(),
            NULL,
            NULL,
            GetServiceDependencies(),
            NULL,
            NULL
            ));

        // If we hit a ERROR_SERVICE_MARKED_FOR_DELETE this means that 
        // the previous (asynchronous) DeleteService is still running.
        // This is expected - retry the CreateService call until we get 
        // in a different state.
        if (GetLastError() != ERROR_SERVICE_MARKED_FOR_DELETE)
            break;

        // Wait for DeleteService to complete and try again
        Sleep(x_nSleepBetweenCreateServiceRetries);

        // Set last error to ERROR_SERVICE_MARKED_FOR_DELETE again (Sleep might reset it)
        SetLastError(ERROR_SERVICE_MARKED_FOR_DELETE);
    }

    // Check for the possible errors
    if (!hService.IsValid())
        ft.TranslateWin32Error( VSSDBG_SWPRV, 
            L"CreateService(%s,%s,SERVICE_CHANGE_CONFIG,"
            L"SERVICE_WIN32_OWN_PROCESS,SERVICE_ERROR_NORMAL,%s,%s)",
            GetServiceName(), 
            GetServiceDisplayName(),
            GetServiceBinaryPath(),
            GetServiceDependencies()
        );

    // Loads the service description from resource
    WCHAR wszDescription[x_nMaxStringResourceLen];
    if (!LoadStringW(GetModuleInstance(), IDS_SERVICE_DESCRIPTION, STRING_CCH_PARAM(wszDescription)))
        ft.TranslateWin32Error( VSSDBG_SWPRV, L"LoadStringW()");

    // Sets the service description
    SERVICE_DESCRIPTION sDescription;
    sDescription.lpDescription = wszDescription;
    if(!ChangeServiceConfig2( hService, SERVICE_CONFIG_DESCRIPTION, (LPVOID)(&sDescription)))
        ft.TranslateWin32Error( VSSDBG_SWPRV, L"ChangeServiceConfig2()");

    //
    // Register the COM server
    //

    // Update registry entries
    ft.hr = CComModule::RegisterServer();
    if ( ft.HrFailed() )
		ft.TranslateGenericError( VSSDBG_SWPRV, ft.hr, L"CComModule::RegisterServer(TRUE)");

    //
    // Add the svchost\swprv REG_MULTI_SZ value (it cannot be added with the RGS script)
    //
    CVssRegistryKey keySvchost(KEY_SET_VALUE);
    if (!keySvchost.Open(HKEY_LOCAL_MACHINE, g_wszSvchostKey))
        ft.TranslateGenericError( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
            L"keySvchost.Open(HKEY_LOCAL_MACHINE, %s)", g_wszSvchostKey);

    // Add the new registry value
    keySvchost.SetMultiszValue(g_wszSvcName, g_wszMultiszSvcName);
        
    //
    //  Add the swprv\Parameters\ServiceDll REG_EXPAND_SZ value 
    //  (it cannot be added with the RGS script)
    //  We assume that the key already exist (it should be created by the RGS above)
    //
    CVssRegistryKey keyServiceDll(KEY_SET_VALUE);
    if (!keyServiceDll.Open(HKEY_LOCAL_MACHINE, g_wszServiceDllKey))
        ft.TranslateGenericError( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
            L"keySvchost.Open(HKEY_LOCAL_MACHINE, %s)", g_wszServiceDllKey);

    // Add the new registry value
    keyServiceDll.SetValue(g_wszServiceDllValName, g_wszServiceDllValue, REG_EXPAND_SZ);
}


// Unregisters the service
// This routine doesn't throw
void CSwprvServiceModule::OnUnregister()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CSwprvServiceModule::OnUnregister" );

    //
    // Remove any old COM+ applications
    //
    
    DeleteOldComPlusAppIfExists(g_wszAppNameOldName);
    DeleteOldComPlusAppIfExists(g_wszAppNameOldName2);
    DeleteOldComPlusAppIfExists(g_wszAppNameOldName3);

    //
    // Remove the svchost\swprv REG_MULTI_SZ value (it cannot be removed with the RGS script)
    //
    
    try
    {
        CVssRegistryKey keySvchost(KEY_SET_VALUE);
        if (keySvchost.Open(HKEY_LOCAL_MACHINE, g_wszSvchostKey))
        {
            // Delete the value
            keySvchost.DeleteValue(g_wszSvcName);
        }
    }
    VSS_STANDARD_CATCH(ft)
        
    //
    // Unregister the COM server
    //
    
    ft.hr = CComModule::UnregisterServer();
    if ( ft.HrFailed() )
		ft.LogGenericWarning( VSSDBG_SWPRV, L"CComModule::RegisterServer(TRUE)");

    //
    // Delete the service
    //
    
    try
    {
        // Get the SCM handle
        CVssAutoWin32ScHandle hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (!hSCM.IsValid())
            ft.TranslateWin32Error( VSSDBG_SWPRV, L"OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT)");

        // Open the service, if present
        CVssAutoWin32ScHandle hService = OpenService( hSCM, GetServiceName(), DELETE);
        if (GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST)
        {
            if (!hService.IsValid())
                ft.TranslateWin32Error( VSSDBG_SWPRV, L"OpenService(hSCM, %s, DELETE)", GetServiceName());

            // Delete the service
            if (!DeleteService(hService))
                ft.TranslateWin32Error( VSSDBG_SWPRV, L"DeleteService(hService)");
        }
    }
    VSS_STANDARD_CATCH(ft)
}


// Delete an existing COM+ app with the given name
// Do not throw on errors
void CSwprvServiceModule::DeleteOldComPlusAppIfExists(
        IN  LPCWSTR wszAppName
        )
{
	CVssFunctionTracer ft(VSSDBG_SWPRV, L"CSwprvServiceModule::DeleteOldComPlusAppIfExists");

    try
    {
    	CVssCOMAdminCatalog     catalog;
    	ft.hr = catalog.Attach(wszAppName);
    	if (ft.HrFailed())
    		ft.TranslateComError(VSSDBG_SWPRV, L"catalog.Attach(%s)", wszAppName);

    	// Get the list of applications
    	CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
    	ft.hr = appsList.Attach(catalog);
    	if (ft.HrFailed())
    		ft.TranslateComError(VSSDBG_SWPRV, L"appsList.Attach(catalog) [%s], %s", wszAppName);

        // Attach to app
    	CVssCOMApplication application;
    	ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
    	if (ft.HrFailed())
    		ft.TranslateComError(VSSDBG_SWPRV, L"application.AttachByName( appsList, %s )", wszAppName);

    	// if the application doesn't exist then return
    	if (ft.hr == S_FALSE)
    		return;

        // now make the application changeable so we can delete it.
    	application.m_bChangeable = true;
    	application.m_bDeleteable = true;
    	ft.hr = appsList.SaveChanges();
    	if (ft.HrFailed())
    		ft.TranslateComError(VSSDBG_SWPRV, L"appsList.SaveChanges() [%s]", wszAppName);

    	// now delete it
    	LONG lIndex = application.GetIndex();
    	BS_ASSERT(lIndex != -1);
    	ft.hr = appsList.GetInterface()->Remove(lIndex);
    	if (ft.HrFailed())
    		ft.TranslateComError(VSSDBG_SWPRV, L"appsList.Remove(%ld) [%s]", lIndex, wszAppName);

    	// commit changes
    	ft.hr = appsList.SaveChanges();
    	if (ft.HrFailed())
    		ft.TranslateComError(VSSDBG_SWPRV, L"appsList.SaveChanges() [%s]", wszAppName);
    }
    VSS_STANDARD_CATCH(ft)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\auto.h ===
//--------------------------------------------------------------------
// Microsoft DART Utilities
//
// Copyright 1994 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module auto.h | Definition of <c CAutoRg> and <c CAutoP>
//
// @devnote None
//
// @rev   0 | 24-Oct-94 | matthewb	| Created
// @rev   1 | 01-May-95 | rossbu	| Updated and consolidated interface
// @rev   2 | 23-May-95 | eugenez	| Added support for TaskAlloc'ed pointers
//

extern IMalloc * g_pIMalloc;

//--------------------------------------------------------------------
//
// @class CAutoBase | This template class is a base class, used to give dynamic memory
// local (auto) scope within a function.  For instance a large character
// buffer can be allocated from a memory object, but be cleanup up as if were
// allocated on the stack.	An additional feature is the ability to
// 'unhook' the object from the local scope using the PvReturn().  For
// instance, you may want to return a  newly allocated object to the
// caller, but still have the benefit of error clean up any error
// scenario.  <c CAutoRg> is a derived class which cleans up arrays allocated
// with new[].	<c CAutoP> is an analagous but works for single objects
// rather than arrays (allocated with new).
//
// @tcarg class | T | Type of auto object
//
// @ex This declaration would allocate a 100 char buffer from pmem, and
// automatically free the buffer when rgbBuf goes out of scope. |
//
//	CAutoRg<lt>char<gt> rgbBuf(New(pmem) char[100]);
//
// @xref <c CAutoRg>
//
// @ex This CAutoP example allocates a CFoo object and returns it if there
// are no errors. |
//
//	/* inilize pfoo */
//	CAutoP<lt>CFoo<gt> pfoo(New(pmem) CFoo);
//	/* do stuff */
//	/* call pfoo methods */
//	pfoo->Bar();
//	/* return w/o destroying foo */
//	return pfoo .PvReturn;
//
// @xref <c CAutoP>
//

// ************************ CAutoBase - base class for all AutoPointers *****************************

template <class T>
class CAutoBase
	{
public:		// @access public
	inline CAutoBase(T* pt);
	inline ~CAutoBase();

	inline T* operator= (T*);
	inline operator T* (void);
	inline operator const T* (void)const;
	inline T ** operator & (void);
	inline T* PvReturn(void);

protected:	// @access protected
	T* m_pt;

private:	// Never-to-use
	inline CAutoBase& operator= (CAutoBase&);
	CAutoBase(CAutoBase&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoBase giving the array of objects pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoBase<T>::CAutoBase(T *pt)
	{
	m_pt = pt;
	}

//--------------------------------------------------------------------
// @mfunc CAutoBase destructor.  Asserts that the object has been free'd
// 	(set to NULL).	Setting to NULL does not happen in the retail build
// @side None
// @rdesc None
//

template <class T>
inline CAutoBase<T>::~CAutoBase()
	{
//	_ASSERT(NULL == m_pt);
	}

//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//
// @ex Assign CAutoBase variable after construction. |
//
//		CAutoBase<lt>char<gt>	rgb;
//		/* ... */
//		rgb(NewG char[100]);
//

template <class T>
inline T* CAutoBase<T>::operator=(T* pt)
	{
	_ASSERT(m_pt == NULL);
	m_pt = pt;
	return pt;
	}

//--------------------------------------------------------------------
// @mfunc Cast operator used to "unwrap" the pointed object
// as if the CAutoBase variable were a pointer of type T.
// In many situations this is enough for an autopointer to
// look exactly like an ordinary pointer.
// @side None
// @rdesc None
//

template <class T>
inline CAutoBase<T>::operator T*(void)
	{
	return m_pt;
	}

template <class T>
inline CAutoBase<T>::operator const T*(void)const
	{
	return m_pt;
	}

//--------------------------------------------------------------------
// @mfunc Address-of operator is used to make the autopointer even more
//	similar to an ordinary pointer. When you take an address of an
//	autopointer, you actually get an address of the wrapped
//	pointer.
// @side None
// @rdesc None

template <class T>
inline T ** CAutoBase<T>::operator & ()
	{
	return & m_pt;
	}

//--------------------------------------------------------------------
// @mfunc Returns the object(s) pointed to by the CAutoBase variable.
// In addition this method 'unhooks' the object(s), such that
// the scope of the object(s) are no longer local.
//
// See <c CAutoBase> for an example.
// @side None
// @rdesc None
//

template <class T>
inline T * CAutoBase<T>::PvReturn(void)
	{
	T *ptT = m_pt;
	m_pt = NULL;
	return ptT;
	}



//************************* CAutoRg - autopointers to arrays ******************************

//--------------------------------------------------------------------
// @class This derived class is primarily used to implement the
//	vector deleting destructor.  Should only be used on objects allocated
//	with new[]
//

template <class T>
class CAutoRg :
	public CAutoBase<T>
	{
public:		// @access public
	inline CAutoRg(T *pt);
	inline ~CAutoRg();

	inline T* operator= (T*);

private:	// Never-to-use
	inline CAutoRg& operator= (CAutoRg&);
	CAutoRg(CAutoRg&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoRg giving the array of objects pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoRg<T>::CAutoRg(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc CAutoRg destructor.  When an object of class CAutoRg goes out
// of scope, free the associated object (if any).
// @side calls the vector delete method
// @rdesc None
//

template <class T>
inline CAutoRg<T>::~CAutoRg()
	{
	delete [] m_pt;
	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//
// @ex Assign CAutoRg variable after construction. |
//
//		CAutoRg<lt>char<gt>	rgb;
//		/* ... */
//		rgb(NewG char[100]);
//

template <class T>
inline T* CAutoRg<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//*************************** CAutoP - autopointers to scalars **************

//--------------------------------------------------------------------
// @class This is analagous to <c CAutoRg> but calls scalar delete
//	of an object rather than arrays.
//
// @xref <c CAutoRg>

template <class T>
class CAutoP :
	public CAutoBase<T>
	{
public: 	// @access public
	inline CAutoP(T *pt);
	inline ~CAutoP();
	inline T* operator= (T*);
	inline T* operator->(void);

private:	// Never-to-use
	inline CAutoP& operator= (CAutoP&);
	CAutoP(CAutoP&);
	};


//--------------------------------------------------------------------
// @mfunc Create a CAutoP giving the object pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoP<T>::CAutoP(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc Delete the object pointed by CAutoP variable if any.
// @side None
// @rdesc None
//

template <class T>
inline CAutoP<T>::~CAutoP()
	{
	delete m_pt;
	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoP<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//--------------------------------------------------------------------
// @mfunc The 'follow' operator on the CAutoP allows an CAutoP variable
// to act like a pointer of type T.  This overloading generally makes using
// a CAutoP simple as using a regular T pointer.
//
// See <c CAutoRg> example.
// @side None
// @rdesc None

template <class T>
inline T * CAutoP<T>::operator->()
	{
	_ASSERT(m_pt != NULL);
	return m_pt;
	}


//******************** CAutoTask - autopointers to TaskAlloc'ed memory ***************

//--------------------------------------------------------------------
// @class CAutoTask is an autopointer to an area allocated using TaskAlloc.
//	May be used for scalars or vectors alike, but beware: object destructors
//	are not called by the autopointer, just the memory gets released.
//

template <class T>
class CAutoTask :
	public CAutoBase<T>
	{
public: 	// @access public
	inline CAutoTask (T *pt);
	inline ~CAutoTask ();
	inline T* operator= (T*);

private:	// Never-to-use
	inline CAutoTask& operator= (CAutoTask&);
	CAutoTask(CAutoTask&);
	};


//--------------------------------------------------------------------
// @mfunc Constructor simply calls the constructor for CAutoBase<lt>T<gt>.
// @side None
// @rdesc None

template <class T>
inline CAutoTask<T>::CAutoTask(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc Free the memory pointed to by CAutoTask variable.
// @side None
// @rdesc None
//

template <class T>
inline CAutoTask<T>::~CAutoTask()
	{
	if (m_pt)
		g_pIMalloc->Free(m_pt);

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoTask<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//************************* CAutoUnivRg - universal autopointers to arrays ******************************

//--------------------------------------------------------------------
// @class CAutoUnivRg and CAutoUnivP are "universal" autopointer classes.
//	They can handle those rare occasions when the "auto-scoped" pointer
//	might have been allocated by either New or TaskAlloc, depending on
//	the circumstances. You have to always know however just how it was
//	allocated this time, and pass this knowledge to the CAutoUniv object
//	at construction time.
//
//	CAutoUniv objects have the additional construction parameter of type
//	BOOL. It is used in fact as a BOOL flag: TRUE means that the
//	pointer is allocated by TaskAlloc, and FALSE means NewG.
//

template <class T>
class CAutoUnivRg :
	public CAutoRg<T>
	{
public:		// @access public
	inline CAutoUnivRg (T *pt, BOOL fIsTaskAlloc);
	inline ~CAutoUnivRg ();

	inline T* operator= (T*);

private:
	BOOL m_fTaskAlloc;

private:	// Never-to-use
	inline CAutoUnivRg& operator= (CAutoUnivRg&);
	CAutoUnivRg(CAutoUnivRg&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoUnivRg giving the array of objects pointed to by pt
// auto scope. Takes a pointer to a memory object, NULL indicates global
// IMalloc (not a global memory object!).
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoUnivRg<T>::CAutoUnivRg (T *pt, BOOL fIsTaskAlloc)
	: CAutoRg<T>(pt)
	{
	m_fTaskAlloc = fIsTaskAlloc;
	}

//--------------------------------------------------------------------
// @mfunc CAutoUnivRg destructor.  When an object of class CAutoUnivRg goes out
// of scope, free the associated object (if any).
// @side calls the vector delete method
// @rdesc None
//

template <class T>
inline CAutoUnivRg<T>::~CAutoUnivRg()
	{
	if (m_fTaskAlloc)
		{
		// m_pt->~T();	// Awaits VC++ 3.0...
		g_pIMalloc->Free(m_pt);
		}
	else
		delete [] m_pt;

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoUnivRg<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//*************************** CAutoUnivP - universal autopointers to scalars **************

//--------------------------------------------------------------------
// @class This is analagous to <c CAutoUnivRg> but calls scalar delete
//	of an object rather than arrays.
//

template <class T>
class CAutoUnivP :
	public CAutoP<T>
	{
public: 	// @access public
	inline CAutoUnivP(T *pt, BOOL fIsTaskAlloc);
	inline ~CAutoUnivP();
	inline T* operator= (T*);
	inline T* operator->(void);

private:
	BOOL m_fTaskAlloc;

private:	// Never-to-use
	inline CAutoUnivP& operator= (CAutoUnivP&);
	CAutoUnivP(CAutoUnivP&);
	};


//--------------------------------------------------------------------
// @mfunc Constructor
// @side None
// @rdesc None

template <class T>
inline CAutoUnivP<T>::CAutoUnivP(T *pt, BOOL fIsTaskAlloc)
	: CAutoBase<T>(pt)
	{
	m_fTaskAlloc = fIsTaskAlloc;
	}


//--------------------------------------------------------------------
// @mfunc Delete the object pointed by CAutoUnivP variable if any.
// @side None
// @rdesc None
//

template <class T>
inline CAutoUnivP<T>::~CAutoUnivP()
	{
	if (m_fTaskAlloc)
		{
		// m_pt->~T();	// Awaits VC++ 3.0...
		g_pIMalloc->Free(m_pt);
		}
	else
		delete m_pt;

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoUnivP<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//--------------------------------------------------------------------
// @mfunc The 'follow' operator on the CAutoUnivP allows an CAutoUnivP variable
// to act like a pointer of type T.  This overloading generally makes using
// a CAutoUnivP simple as using a regular T pointer.
//
// @side None
// @rdesc None

template <class T>
inline T * CAutoUnivP<T>::operator->()
	{
	_ASSERT(m_pt != NULL);
	return m_pt;
	}


//------------------------------------------------------------------
// @class auto handle class
//
class CAutoHandle
	{
public:
	// @cmember constructor
	inline CAutoHandle(HANDLE h) : m_handle(h)
		{
		}

	inline CAutoHandle() :
		m_handle(INVALID_HANDLE_VALUE)
		{
		}

	// @cmember destructor
	inline ~CAutoHandle()
		{
		if (m_handle != INVALID_HANDLE_VALUE)
			CloseHandle(m_handle);
		}

	// coercion to handle value
	inline operator HANDLE (void)
		{
		return m_handle;
		}

	inline HANDLE PvReturn(void)
		{
		HANDLE h = m_handle;
		m_handle = INVALID_HANDLE_VALUE;
		return h;
		}

private:

	// @cmember handle value
	HANDLE m_handle;
	};


//----------------------------------------------------------------------
// @class auto class for registry keys
//
class CAutoHKEY
	{
public:
	// @cmember constructor
	inline CAutoHKEY(HKEY hkey) : m_hkey(hkey)
		{
		}

	// @cmember destructor
	inline ~CAutoHKEY()
		{
		if (m_hkey != NULL)
			RegCloseKey(m_hkey);
		}

	inline operator HKEY(void)
		{
		return m_hkey;
		}

	inline HKEY PvReturn(void)
		{
		HKEY hkey = m_hkey;

		m_hkey = NULL;
		return hkey;
		}
private:
	HKEY m_hkey;
	};


//------------------------------------------------------------------
// @class automatically unmap view of file on function exit
//
class CAutoUnmapViewOfFile
	{
public:
	// @cmember constructor
	inline CAutoUnmapViewOfFile(PVOID pv) : m_pv(pv)
		{
		}

	// @cmember destructor
	inline ~CAutoUnmapViewOfFile()
		{
		if (m_pv != NULL)
			UnmapViewOfFile(m_pv);
		}

	// @cmember indicate that region should not be unmapped by destructor
	inline PVOID PvReturn()
		{
		PVOID pv = m_pv;
		m_pv = NULL;
		return pv;
		}

private:
	// @cmember handle value
	PVOID m_pv;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\stdafx.h ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: stdafx.h
//
// PURPOSE:
//
//		The precompiled header in the NT source code.
//     
// NOTES:
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     76910 SRS  08/08/01 Rollforward from VSS snapshot
//     68228      12/05/00 ntsnap work
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************

#include <memory>

#ifndef __VSS_STDAFX_HXX__
#define __VSS_STDAFX_HXX__

#if _MSC_VER > 1000
#pragma once
#endif

// Disable warning: 'identifier' : identifier was truncated to 'number' characters in the debug information
//
#ifdef DISABLE_4786
#pragma warning(disable:4786)
#endif


//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)

//
// C4511: copy constructor could not be generated
//
#pragma warning(disable:4511)


//
//  Warning: ATL debugging turned off (BUG 250939)
//
//  #ifdef _DEBUG
//  #define _ATL_DEBUG_INTERFACES
//  #define _ATL_DEBUG_QI
//  #define _ATL_DEBUG_REFCOUNT
//  #endif // _DEBUG


#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>
#include <odbcss.h>

#include "vs_inc.hxx"

#include "sqlsnap.h"
#include "sqlsnapi.h"
#include <auto.h>
#include "vssmsg.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\sqlconnect.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlconnect.cpp
//
// PURPOSE:
//
//		Handle the OLEDB connection and commands
//
// NOTES:
//
// Extern dependencies:
//   provision of "_Module" and the COM guids....
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************


// the templates make awful, long names which result in excessive warnings
//
#ifdef HIDE_WARNINGS
#pragma warning( disable : 4663)
#pragma warning( disable : 4786)
#pragma warning( disable : 4100)
#pragma warning( disable : 4511)
#endif


#include <stdafx.h>
#include <atlbase.h>
#include <clogmsg.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLCONNC"
//
////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------------------
// routine to print out error information for a failed OLEDB request
//
// An optional parm is used to check for the 3014 code when a successful backup is
// erroneously marked as failed due to other problems (such as msdb access)
//
void DumpErrorInfo (
	IUnknown* pObjectWithError,
	REFIID IID_InterfaceWithError,
	CLogMsg &msg,
	BOOL*	pBackupSuccess = NULL
	)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"DumpErrorInfo");

    CComPtr<IErrorInfo> apIErrorInfoAll;
	CComPtr<IErrorInfo> apIErrorInfoRecord;
	CComPtr<IErrorRecords> apIErrorRecords;
	CComPtr<ISupportErrorInfo> apISupportErrorInfo;
	CComPtr<ISQLErrorInfo> apISQLErrorInfo;
	CComPtr<ISQLServerErrorInfo> apISQLServerErrorInfo;

    // Number of error records.
    ULONG nRecs;
    ULONG nRec;

    // Basic error information from GetBasicErrorInfo.
    ERRORINFO               errorinfo;

    // IErrorInfo values.
    CComBSTR bstrDescription;
    CComBSTR bstrSource;

    // ISQLErrorInfo parameters.
    CComBSTR bstrSQLSTATE;
    LONG lNativeError;
	

    // ISQLServerErrorInfo parameter pointers.
    SSERRORINFO* pSSErrorInfo = NULL;
    LPWSTR pSSErrorStrings = NULL;

    // Hard-code an American English locale for the example.
	//
	// **UNDONE** How should we internationalize properly?
	//
    DWORD MYLOCALEID = 0x0409;

	BOOL	msg3014seen = FALSE;
	BOOL	msg3013seen = FALSE;
	WCHAR buf[80];

    // Only ask for error information if the interface supports
    // it.
    if (FAILED(pObjectWithError->QueryInterface
					(
					IID_ISupportErrorInfo,
					(void**) &apISupportErrorInfo)
					))
    {
		ft.Trace (VSSDBG_SQLLIB, L"SupportErrorErrorInfo interface not supported");
		return;
    }

    if (FAILED(apISupportErrorInfo->InterfaceSupportsErrorInfo(IID_InterfaceWithError)))
    {
		ft.Trace (VSSDBG_SQLLIB, L"InterfaceWithError interface not supported");
		return;
    }


    // Do not test the return of GetErrorInfo. It can succeed and return
    // a NULL pointer in pIErrorInfoAll. Simply test the pointer.
    GetErrorInfo(0, &apIErrorInfoAll);

    if (apIErrorInfoAll != NULL)
    {
        // Test to see if it's a valid OLE DB IErrorInfo interface
        // exposing a list of records.

        if (SUCCEEDED(apIErrorInfoAll->QueryInterface (
						IID_IErrorRecords,
						(void**) &apIErrorRecords)))
        {
            apIErrorRecords->GetRecordCount(&nRecs);

			// Within each record, retrieve information from each
            // of the defined interfaces.
            for (nRec = 0; nRec < nRecs; nRec++)
            {
                // From IErrorRecords, get the HRESULT and a reference
                // to the ISQLErrorInfo interface.
                apIErrorRecords->GetBasicErrorInfo(nRec, &errorinfo);
				apIErrorRecords->GetCustomErrorObject (
					nRec,
                    IID_ISQLErrorInfo,
					(IUnknown**) &apISQLErrorInfo);

                // Display the HRESULT, then use the ISQLErrorInfo.
                ft.Trace(VSSDBG_SQLLIB, L"HRESULT:\t%#X\n", errorinfo.hrError);
                if (apISQLErrorInfo != NULL)
                {
                    apISQLErrorInfo->GetSQLInfo(&bstrSQLSTATE, &lNativeError);

                    // Display the SQLSTATE and native error values.
                    ft.Trace(
				        VSSDBG_SQLLIB,
						L"SQLSTATE:\t%s\nNative Error:\t%ld\n",
                        bstrSQLSTATE,
						lNativeError);

                    msg.Add(L"SQLSTATE: ");
					msg.Add(bstrSQLSTATE);
					swprintf(buf, L", Native Error: %d\n", lNativeError);
					msg.Add(buf);
					

					if (lNativeError == 3013)
						msg3013seen = TRUE;
					else if (lNativeError == 3014)
						msg3014seen = TRUE;

                    // Get the ISQLServerErrorInfo interface from
                    // ISQLErrorInfo before releasing the reference.
                    apISQLErrorInfo->QueryInterface (
                        IID_ISQLServerErrorInfo,
                        (void**) &apISQLServerErrorInfo);

					// Test to ensure the reference is valid, then
					// get error information from ISQLServerErrorInfo.
					if (apISQLServerErrorInfo != NULL)
					{
						apISQLServerErrorInfo->GetErrorInfo (
							&pSSErrorInfo,
							&pSSErrorStrings);

						// ISQLServerErrorInfo::GetErrorInfo succeeds
						// even when it has nothing to return. Test the
						// pointers before using.
						if (pSSErrorInfo)
						{
							// Display the state and severity from the
							// returned information. The error message comes
							// from IErrorInfo::GetDescription.
							ft.Trace
								(
								VSSDBG_SQLLIB,
								L"Error state:\t%d\nSeverity:\t%d\n",
								pSSErrorInfo->bState,
								pSSErrorInfo->bClass
								);

                            swprintf(buf, L"Error state: %d, Severity: %d\n",pSSErrorInfo->bState, pSSErrorInfo->bClass);
							msg.Add(buf);

							// IMalloc::Free needed to release references
							// on returned values. For the example, assume
							// the g_pIMalloc pointer is valid.
							g_pIMalloc->Free(pSSErrorStrings);
							g_pIMalloc->Free(pSSErrorInfo);
						}
						apISQLServerErrorInfo.Release ();
					}
					apISQLErrorInfo.Release ();

				} // got the custom error info

                if (SUCCEEDED(apIErrorRecords->GetErrorInfo	(
						nRec,
						MYLOCALEID,
						&apIErrorInfoRecord)))
				{
                    // Get the source and description (error message)
                    // from the record's IErrorInfo.
                    apIErrorInfoRecord->GetSource(&bstrSource);
					apIErrorInfoRecord->GetDescription(&bstrDescription);

					if (bstrSource != NULL)
						{
                        ft.Trace(VSSDBG_SQLLIB, L"Source:\t\t%s\n", bstrSource);
						msg.Add(L"Source: ");
						msg.Add(bstrSource);
						msg.Add(L"\n");
						}

                    if (bstrDescription != NULL)
						{
                        ft.Trace(VSSDBG_SQLLIB, L"Error message:\t%s\n", bstrDescription);
						msg.Add(L"Error message: ");
						msg.Add(bstrDescription);
						msg.Add(L"\n");
						}

					apIErrorInfoRecord.Release ();
                }
            } // for each record
		}
        else
        {
            // IErrorInfo is valid; get the source and
            // description to see what it is.
            apIErrorInfoAll->GetSource(&bstrSource);
            apIErrorInfoAll->GetDescription(&bstrDescription);
            if (bstrSource != NULL)
				{
                ft.Trace(VSSDBG_SQLLIB, L"Source:\t\t%s\n", bstrSource);
				msg.Add(L"Source: ");
				msg.Add(bstrSource);
				msg.Add(L"\n");
				}

            if (bstrDescription != NULL)
				{
                ft.Trace(VSSDBG_SQLLIB, L"Error message:\t%s\n", bstrDescription);
				msg.Add(L"Error message: ");
				msg.Add(bstrDescription);
				msg.Add(L"\n");
				}
        }
	}
    else
	{
        ft.Trace(VSSDBG_SQLLIB, L"GetErrorInfo failed.");
    }

	if (pBackupSuccess)
	{
		*pBackupSuccess = (msg3014seen && !msg3013seen);
	}
}

//------------------------------------------------------------------
//
SqlConnection::~SqlConnection ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::~SqlConnection");
	Disconnect ();
}

//------------------------------------------------------------------
//
void
SqlConnection::ReleaseRowset ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::ReleaseRowset");

	if (m_pBuffer)
	{
		delete[] m_pBuffer;
		m_pBuffer = NULL;
	}
	if (m_pBindings)
	{
		delete[] m_pBindings;
		m_pBindings = NULL;
	}
	m_cBindings = 0;
	if (m_pAccessor)
	{
		if (m_hAcc)
		{
			m_pAccessor->ReleaseAccessor (m_hAcc, NULL);
			m_hAcc = NULL;
		}
		m_pAccessor->Release ();
		m_pAccessor = NULL;
	}
	if (m_pRowset)
	{
		m_pRowset->Release ();
		m_pRowset = NULL;
	}
}

//------------------------------------------------------------------
//
void
SqlConnection::Disconnect ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConenction::Disconnect");

	ReleaseRowset ();
	if (m_pCommand)
	{
		m_pCommand->Release ();
		m_pCommand = NULL;
	}
	if (m_pCommandFactory)
	{
		m_pCommandFactory->Release ();
		m_pCommandFactory = NULL;
	}
}

// log an error if not an out of resource error
void SqlConnection::LogOledbError
	(
	CVssFunctionTracer &ft,
	CVssDebugInfo &dbgInfo,
	LPCWSTR wszRoutine,
	CLogMsg &msg
	)
	{
	if (ft.hr == E_OUTOFMEMORY ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		ft.Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected in function %s", wszRoutine);
	else
		{
		ft.LogError(VSS_ERROR_SQLLIB_OLEDB_ERROR, dbgInfo << wszRoutine << ft.hr << msg.GetMsg());
		ft.Throw
			(
			dbgInfo,
			E_UNEXPECTED,
			L"Error calling %s.  hr = 0x%08lx.\n%s",
			wszRoutine,
			ft.hr,
			msg.GetMsg()
			);
        }
	}
	

//------------------------------------------------------------------
// Setup a session, ready to receive commands.
//
// This call may block for a long time while establishing the connection.
//
// See the "FrozenServer" object for a method to determine if the local
// server is up or not prior to requesting a connection.
//
// The "trick" of prepending "tcp:" to the servername isn't fast or robust
// enough to detect a shutdown server.
//
// Note for C programmers....BSTRs are used as part of the COM
// environment to be interoperable with VisualBasic.  The VARIANT
// datatype doesn't work with standard C strings.
//
void
SqlConnection::Connect (
	const WString&	serverName)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::Connect");
	CLogMsg msg;

	CComPtr<IDBInitialize> apdbInitialize;

	// "Connect" always implies a "fresh" connection.
	//
	ReleaseRowset ();

	if (m_ServerName.compare (serverName) == 0 && m_pCommand)
	{
		// Requesting the same server and we are connected.
		//
		return;
	}

	Disconnect ();
	m_ServerName = serverName;

    ft.CoCreateInstanceWithLog(
            VSSDBG_SQLLIB,
            CLSID_SQLOLEDB,
            L"SQLOLEDB",
            CLSCTX_INPROC_SERVER,
            IID_IDBInitialize,
            (IUnknown**)&(apdbInitialize));
	if (ft.HrFailed())
		ft.CheckForError(VSSDBG_SQLLIB, L"CoCreateInstance");

	CComPtr<IDBProperties> apdbProperties;
	ft.hr = apdbInitialize->QueryInterface(IID_IDBProperties, (void **) &apdbProperties);
	if (ft.HrFailed())
		ft.CheckForError(VSSDBG_SQLLIB, L"IDBInitialize::QueryInterface");

	CComBSTR bstrComputerName = serverName.c_str ();

	// initial database context
	CComBSTR bstrDatabaseName = L"master";

	// use NT Authentication
	CComBSTR bstrSSPI = L"SSPI";

	const unsigned x_CPROP = 3;
	DBPROPSET propset;
	DBPROP rgprop[x_CPROP];

	propset.guidPropertySet = DBPROPSET_DBINIT;
	propset.cProperties = x_CPROP;
	propset.rgProperties = rgprop;

	for (unsigned i = 0; i < x_CPROP; i++)
	{
		VariantInit(&rgprop[i].vValue);
		rgprop[i].dwOptions = DBPROPOPTIONS_REQUIRED;
		rgprop[i].colid = DB_NULLID;
		rgprop[i].vValue.vt = VT_BSTR;
	}

	rgprop[0].dwPropertyID = DBPROP_INIT_DATASOURCE;
	rgprop[1].dwPropertyID = DBPROP_INIT_CATALOG;
	rgprop[2].dwPropertyID = DBPROP_AUTH_INTEGRATED;
	rgprop[0].vValue.bstrVal = bstrComputerName;
	rgprop[1].vValue.bstrVal = bstrDatabaseName;
	rgprop[2].vValue.bstrVal = bstrSSPI;

	ft.hr = apdbProperties->SetProperties(1, &propset);
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbProperties, IID_IDBProperties, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBProperties::SetProperties", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Connecting to server %s...", serverName.c_str ());

	ft.hr = apdbInitialize->Initialize();
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbInitialize, IID_IDBInitialize, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBInitialize::Initialize", msg);
	}

	CComPtr<IDBCreateSession> apCreateSession;
	ft.hr = apdbInitialize->QueryInterface(IID_IDBCreateSession, (void **) &apCreateSession);
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbInitialize, IID_IDBInitialize, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBInitialize::QueryInterface", msg);
	}

	// We keep the command factory around to generate commands.
	//
	ft.hr = apCreateSession->CreateSession (
			NULL,
			IID_IDBCreateCommand,
			(IUnknown **) &m_pCommandFactory);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apCreateSession, IID_IDBCreateSession, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBCreateSession::CreateSession", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Connected\n");

	// Request the version of this server
	//
	DBPROPIDSET		versionSet;
	DBPROPID		versionID = DBPROP_DBMSVER;

	versionSet.guidPropertySet	= DBPROPSET_DATASOURCEINFO;
	versionSet.cPropertyIDs		= 1;
	versionSet.rgPropertyIDs	= &versionID;

	ULONG		propCount;
	DBPROPSET*	pPropSet;

	ft.hr = apdbProperties->GetProperties (1, &versionSet, &propCount, &pPropSet);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbProperties, IID_IDBProperties, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBProperties::GetProperties", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Version: %s\n", pPropSet->rgProperties->vValue.bstrVal);

	swscanf (pPropSet->rgProperties->vValue.bstrVal, L"%d", &m_ServerVersion);

	g_pIMalloc->Free(pPropSet->rgProperties);
	g_pIMalloc->Free(pPropSet);
}

//---------------------------------------------------------------------
//	Setup the command with some SQL text
//
void
SqlConnection::SetCommand (const WString& command)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::SetCommand");

	CLogMsg msg;

	// Release the result of the previous command
	//
	ReleaseRowset ();

	// We create the command on the first request, then keep only one
	// around in the SqlConnection.
	//
	if (!m_pCommand)
	{
		ft.hr = m_pCommandFactory->CreateCommand (NULL, IID_ICommandText,
			(IUnknown **) &m_pCommand);

		if (ft.HrFailed())
		{
			DumpErrorInfo(m_pCommandFactory, IID_IDBCreateCommand, msg);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IDBCreateCommand::CreateCommand", msg);
		}
	}

	ft.hr = m_pCommand->SetCommandText(DBGUID_DBSQL, command.c_str ());
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pCommand, IID_ICommandText, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"ICommandText::SetCommandText", msg);
	}
	ft.Trace (VSSDBG_SQLLIB, L"SetCommand (%s)\n", command.c_str ());
}

//---------------------------------------------------------------------
//	Execute the command.  "SetCommand" must have been called previously.
//
BOOL
SqlConnection::ExecCommand ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::ExecCommand");

	CLogMsg msg;

	CComPtr<IRowset> apRowset;
	DBROWCOUNT	crows;
	HRESULT		hr;

	// Release the result of the previous command
	//
	ReleaseRowset ();

	ft.hr = m_pCommand->Execute (
			NULL,
			IID_IRowset,
			NULL,
			&crows,
			(IUnknown **) &m_pRowset);

    if (ft.HrFailed())
	{
		BOOL	backupSuccess = FALSE;

		DumpErrorInfo (m_pCommand, IID_ICommandText, msg, &backupSuccess);

		if (!backupSuccess)
			LogOledbError(ft, VSSDBG_SQLLIB, L"ICommandText::Execute", msg);
	}

	if (!m_pRowset)
	{
		ft.Trace(VSSDBG_SQLLIB, L"Command completed successfully with no rowset\n");
		return FALSE;
	}
	return TRUE;
}

//---------------------------------------------------------------------
// return a vector of string, one for each row of the output.
// The query should have returned a single column.
//
StringVector*
SqlConnection::GetStringColumn ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::GetStringColumn");
	CLogMsg msg;

	//ASSERT (m_pRowset)
	//

	CComPtr<IColumnsInfo> apColumnsInfo;
	ft.hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **) &apColumnsInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	// get columns info
	//
	DBCOLUMNINFO *rgColumnInfo;
	DBORDINAL cColumns;
	WCHAR *wszColumnInfo;
	ft.hr = apColumnsInfo->GetColumnInfo(&cColumns, &rgColumnInfo, &wszColumnInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (apColumnsInfo, IID_IColumnsInfo, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IColumnsInfo::GetColumnInfo", msg);
	}

	// Auto objects ensure that memory is freed on exit
	//
	CAutoTask<DBCOLUMNINFO> argColumnInfo = rgColumnInfo;
	CAutoTask<WCHAR> awszColumnInfo = wszColumnInfo;

	// Setup a buffer to hold the string.
	// The output buffer holds a 4byte length, followed by the string column.
	//
	// "bufferSize" is in units of characters (not bytes)
	// Note that the "ulColumnSize" is in characters.
	// 1 char is used for the null term and we actually allocate one additional
	// char (hidden), just incase our provider gets the boundary condition wrong.
	//
	ULONG bufferSize = 1 + rgColumnInfo[0].ulColumnSize + (sizeof(ULONG)/sizeof(WCHAR));
	std::auto_ptr<WCHAR> rowBuffer(new WCHAR[bufferSize+1]);

	// Describe the binding for our single column of interest
	//
	DBBINDING	rgbind[1];
	unsigned	cBindings = 1;

	rgbind[0].dwPart	= DBPART_VALUE|DBPART_LENGTH;
	rgbind[0].wType		= DBTYPE_WSTR;	// retrieve a
	rgbind[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	rgbind[0].eParamIO	= DBPARAMIO_NOTPARAM;
	rgbind[0].pObject	= NULL;
	rgbind[0].pBindExt	= NULL;
	rgbind[0].pTypeInfo = NULL;
	rgbind[0].dwFlags	= 0;
	rgbind[0].obLength	= 0;		// offset to the length field
	rgbind[0].iOrdinal	= 1;		// column id's start at 1
	rgbind[0].obValue	= sizeof(ULONG);	// offset to the string field		
	rgbind[0].cbMaxLen	= (unsigned) (bufferSize*sizeof(WCHAR)-sizeof(ULONG));

	CComPtr<IAccessor> apAccessor;
	ft.hr = m_pRowset->QueryInterface(IID_IAccessor, (void **) &apAccessor);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	HACCESSOR hacc;
	ft.hr = apAccessor->CreateAccessor (
		DBACCESSOR_ROWDATA,
		cBindings,
		rgbind,
        0,
		&hacc,
		NULL);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apAccessor, IID_IAccessor, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IAccessor::CreateAccessor", msg);
	}

	// loop through rows, generating a vector of strings.
	//

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;
	std::auto_ptr<StringVector> aVec (new StringVector);
	
	// pString points into the output buffer for the string column
	//
	WCHAR*	pString = (WCHAR*)((BYTE*)rowBuffer.get () + sizeof (ULONG));

	while(TRUE)
	{
		ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
		if (ft.hr == DB_S_ENDOFROWSET)
			break;

		if (ft.HrFailed())
		{
			DumpErrorInfo (m_pRowset, IID_IRowset, msg);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
		}

		ft.hr = m_pRowset->GetData (hrow, hacc, rowBuffer.get());
		if (ft.HrFailed())
		{
			DumpErrorInfo(m_pRowset, IID_IRowset, msg);
			m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
		}

		unsigned	tempChars = (*(ULONG*)rowBuffer.get ())/sizeof (WCHAR);
		WString	tempStr (pString, tempChars);
		aVec->push_back (tempStr);

		ft.Trace(VSSDBG_SQLLIB, L"StringColumn: %s\n", tempStr.c_str ());

		m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);
	}

	// UNDONE...make this an auto object to avoid leaks
	//
	apAccessor->ReleaseAccessor (hacc, NULL);

	return aVec.release ();
}


//---------------------------------------------------------------------
// Fetch the first row of the result.
//
BOOL
SqlConnection::FetchFirst ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::FetchFirst");
	CLogMsg msg;


	// UNDONE...make this nicely restep back to the first row.
	//
	if (m_pBindings)
	{
		throw HRESULT(E_SQLLIB_PROTO);
	}

	CComPtr<IColumnsInfo> apColumnsInfo;
	ft.hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **) &apColumnsInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInteface", msg);
	}

	// get columns info
	//
	DBCOLUMNINFO *rgColumnInfo;
	DBORDINAL cColumns;
	WCHAR *wszColumnInfo;
	ft.hr = apColumnsInfo->GetColumnInfo(&cColumns, &rgColumnInfo, &wszColumnInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (apColumnsInfo, IID_IColumnsInfo, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IColumnsInfo::GetColumnInfo", msg);
	}

	// Auto objects ensure that memory is freed on exit
	//
	CAutoTask<DBCOLUMNINFO> argColumnInfo = rgColumnInfo;
	CAutoTask<WCHAR> awszColumnInfo = wszColumnInfo;

	// allocate bindings
	unsigned m_cBindings = (unsigned) cColumns;
	m_pBindings = new DBBINDING[m_cBindings];

	// Set up the bindings onto a buffer we'll allocate
	// UNDONE: do this properly for alignment & handling null indicators
	//

	unsigned cb = 0;
	for (unsigned icol = 0; icol < m_cBindings; icol++)
	{
		unsigned maxBytes;

		m_pBindings[icol].iOrdinal	= icol + 1;
		m_pBindings[icol].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_pBindings[icol].eParamIO	= DBPARAMIO_NOTPARAM;
		m_pBindings[icol].pObject	= NULL;
		m_pBindings[icol].pBindExt	= NULL;
		m_pBindings[icol].pTypeInfo	= NULL;
		m_pBindings[icol].dwFlags	= 0;
		m_pBindings[icol].bPrecision	= rgColumnInfo[icol].bPrecision;
		m_pBindings[icol].bScale		= rgColumnInfo[icol].bScale;

		m_pBindings[icol].obStatus = 0; // no status info

		if (rgColumnInfo[icol].wType == DBTYPE_WSTR)
		{	// do we need the length?
			m_pBindings[icol].dwPart = DBPART_VALUE; //|DBPART_LENGTH;
			m_pBindings[icol].wType	= DBTYPE_WSTR;
			m_pBindings[icol].obLength = 0; //icol * sizeof(DBLENGTH);
			maxBytes = rgColumnInfo[icol].ulColumnSize * sizeof(WCHAR);
		}
		else
		{
			m_pBindings[icol].dwPart = DBPART_VALUE;
			m_pBindings[icol].wType = rgColumnInfo[icol].wType;
			m_pBindings[icol].obLength = 0;  // no length
			maxBytes = rgColumnInfo[icol].ulColumnSize;
		}

		m_pBindings[icol].obValue = cb;
		m_pBindings[icol].cbMaxLen = maxBytes;
		
		cb += maxBytes;
	}

	// allocate data buffer
	//
	m_pBuffer = new BYTE[cb];
	m_BufferSize = cb;

	ft.hr = m_pRowset->QueryInterface(IID_IAccessor, (void **) &m_pAccessor);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	ft.hr = m_pAccessor->CreateAccessor (
		DBACCESSOR_ROWDATA,
		m_cBindings,
		m_pBindings,
        0,
		&m_hAcc,
		NULL);

	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pAccessor, IID_IAccessor, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IAccessor::CreateAccessor", msg);
	}

	// Fetch the first row
	//

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;

	ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
	if (ft.hr == DB_S_ENDOFROWSET)
	{
		// No rows in this set
		//
		return FALSE;
	}

	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
	}

	ft.hr = m_pRowset->GetData (hrow, m_hAcc, m_pBuffer);
	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pRowset, IID_IRowset, msg);
		m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
	}

	m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);

	return TRUE;
}


//---------------------------------------------------------------------
// Fetch the next row of the result.
//
BOOL
SqlConnection::FetchNext ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::FetchNext");

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;
	CLogMsg msg;

	ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
	if (ft.hr == DB_S_ENDOFROWSET)
	{
		return FALSE;
	}

	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
	}

	ft.hr = m_pRowset->GetData (hrow, m_hAcc, m_pBuffer);
	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pRowset, IID_IRowset, msg);
		m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
	}

	m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);

	return TRUE;
}

//-----------------------------------------------------------
// Provide a pointer to the n'th column.
//
void*
SqlConnection::AccessColumn (int colid)
{
	return m_pBuffer + m_pBindings[colid-1].obValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\sqlsnapi.h ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlsnapi.h
//
// PURPOSE:
//
//		The internal include file for the sql snapshot module
//
// NOTES:
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     85581 SRS  08/15/01 Event security
//     76910 SRS  08/08/01 Rollforward from VSS snapshot
//     68228      12/05/00 ntsnap work
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************


#include <string>
#include <vector>
#include <list>

#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>

#include "vdi.h"        // interface declaration from SQLVDI kit

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLSNPIH"
//
////////////////////////////////////////////////////////////////////////


typedef unsigned long	ULONG;
typedef wchar_t			WCHAR;

#define TRUE 1
#define FALSE 0

class CLogMsg;

// Converting from int to bool "naturally" gives a 4800 warning....
//
inline bool IntToBool (int v)
{
	return v ? true : false;
}

// Unexpected, "internal" errors can be logged with some
// generic international text, like "Internal error: <English servicibility text>"
//
// Situations we expect, for which the user needs to know should
// occur with proper internationalization
//

// Process wide globals used by the sql modules
//
extern IMalloc *	g_pIMalloc;

//-------------------------------------------------------------------------
//
typedef std::wstring					WString;
typedef std::vector<WString>			StringVector;
typedef StringVector::const_iterator	StringVectorIter;
typedef std::list<WString>				StringList;
typedef StringList::const_iterator		StringListIter;

StringVector* EnumerateServers ();

//--------------------------------------------------------------------------------
// database names need special syntactical handling
//
const MaxSysNameLen = 128;
const SysNameBufferLen = MaxSysNameLen * 2; // easily accomodate doubled quotes and delimiters

void
FormStringForName (WCHAR* pString, const WCHAR* pName);
void
FormDelimitedIdentifier (WCHAR* pString, const WCHAR* pName);

//-------------------------------------------------------------------------
// Handle our simple needs for DB services.
//
// Useage:
//    - Connect :		establish a connection to a given server
//    - SetCommand:		setup the SQL text to send
//    - ExecCommand:	execute some SQL, returns TRUE if a result set
//					is open and ready for retrieval
//	  - Get*:			retrieve info from the result set
//	
// The destructor will automatically disconnect from the server.
//
class SqlConnection
{
public:
	SqlConnection () :
		m_pCommandFactory (NULL),
		m_pCommand (NULL),
		m_pRowset (NULL),
		m_pBuffer (NULL),
		m_BufferSize (0),
		m_hAcc (NULL),
		m_pAccessor (NULL),
		m_pBindings (NULL),
		m_cBindings (0)
	{}

	~SqlConnection ();

	void
	Connect (const std::wstring& serverName);

	void
	Disconnect ();

	void
	ReleaseRowset ();
		
	void	
	SetCommand (const std::wstring& command);

	BOOL	
	ExecCommand ();

	StringVector*
	GetStringColumn ();

	ULONG
	GetServerVersion () {return m_ServerVersion;}

	BOOL
	FetchFirst ();
	
	BOOL
	FetchNext ();
	
	void*
	AccessColumn (int id);

private:
	void LogOledbError
		(
		CVssFunctionTracer &ft,
		CVssDebugInfo &dbgInfo,
		LPCWSTR wszRoutine,
		CLogMsg &msg
		);

	WString						m_ServerName;
	IDBCreateCommand*			m_pCommandFactory;
	ICommandText*				m_pCommand;
	IRowset*					m_pRowset;
	ULONG						m_ServerVersion;

	// used for the generic findfirst/findnext
	DBBINDING*					m_pBindings;
	ULONG						m_cBindings;
	BYTE*						m_pBuffer;
	ULONG						m_BufferSize;
	HACCESSOR					m_hAcc;
	IAccessor*					m_pAccessor;
};

BOOL
IsServerOnline (const WCHAR*	serverName);

//-------------------------------------------------------------------------
// Provide a simple container for BACKUP metadata.
//
class MetaData
{
public:
	MetaData ();
	~MetaData ();

	// Data is appended until complete
	//
	void
	Append (const BYTE* pData, UINT length);

	// At completion, a checksum is appended
	//
	void
	Finalize ();

	// The buffer and its length are made available.
	//
	const BYTE*
	GetImage (UINT*	pLength);

	// Verify the checksum
	//
	static
	BOOL
	IsValidImage (const BYTE* pData, UINT length);

private:
	static 
	UINT
	Checksum (const BYTE* pData, UINT length);

	BYTE*					m_pData;
	UINT					m_AllocatedLength;
	UINT					m_UsedLength;
};

class Freeze2000;
class FrozenServer;

//-------------------------------------------------------------------------
// Handle a single frozen database (>=SQL2000 only).
//
class FrozenDatabase
{
	friend Freeze2000;
	friend FrozenServer;
	
//protected:
	enum VDState
	{
		Unknown=0, 
		Created, 
		Open, 
		PreparedToFreeze,
		Frozen
	};

	FrozenDatabase () :
		m_pContext (NULL),
		m_hThread (NULL),
		m_pIVDSet (NULL),
		m_pIVD (NULL),
		m_pSnapshotCmd (NULL),
		m_VDState (Unknown),
		m_SuccessDetected (FALSE)
	{}

	Freeze2000*					m_pContext;
	HANDLE						m_hThread;
	IClientVirtualDeviceSet2*   m_pIVDSet;
	IClientVirtualDevice*       m_pIVD;
	WString						m_DbName;
	VDC_Command*				m_pSnapshotCmd;
	VDState						m_VDState;
	WCHAR						m_SetName [80];
	bool						m_SuccessDetected;
	MetaData					m_MetaData;
//	bool						m_IsSimpleModel; // true if recovery model is simple
	bool						m_IsMaster;		 // true if this is the "master" database
};

//-------------------------------------------------------------------------
//
// Handle a SQL2000 server.
//
// In SQL2000 we'll use VDI snapshots to avoid bug 58266: thaw fails.
//
//  We'll prepare each database by starting a BACKUP WITH SNAPSHOT.
//  This will require one thread per database.
//  The backups will stall waiting for the VDI client to pull metadata.
//  When the "freeze" message comes along, the controlling thread will
//  pull all the BACKUPs to the frozen state.
//  Later the "thaw" message results in gathering the "success" report
//  from each thread.
//
//
class Snapshot;
class Freeze2000
{
	friend Snapshot;
	friend FrozenServer;

public:
	Freeze2000 (
		const WString&	serverName,
		ULONG			maxDatabases);

	~Freeze2000 ();

	void
	PrepareDatabase (
		const WString&	dbName);
	
	const BYTE*
	GetMetaData (
		const WString&	dbName,
		UINT*			pDataLength);
	
	void
	WaitForPrepare ();

	void
	Freeze ();

	BOOL
	Thaw () throw ();

	static DWORD
	DatabaseThreadStart (LPVOID	pContext);

private:
	enum State {
		Unprepared,
		Preparing,
		Prepared,
		Frozen,
		Complete,
		Aborted
	};

	DWORD
	DatabaseThread (
		FrozenDatabase*	pDbContext);

	void
	WaitForThreads ();

	void
	AdvanceVDState (
		FrozenDatabase::VDState	targetState);

	void		// race-free method to persist an abort condition
	SetAbort ()
	{
		InterlockedIncrement (&m_AbortCount);
	}

	bool		// return true if the freeze is aborting
	CheckAbort ()
	{
		return 0 != InterlockedCompareExchange (
#ifdef DOWNLEVEL_WINBASE
			(void**)
#endif
			&m_AbortCount, 0, 0);
	}

	void
	Abort () throw ();

	void
	Lock ()
	{
		EnterCriticalSection (&m_Latch);
	}
	void
	Unlock ()
	{	
		LeaveCriticalSection (&m_Latch);
	}
	BOOL	// return TRUE if we got the lock
	TryLock ()
	{
		return TryEnterCriticalSection (&m_Latch);
	}

	LONG				m_AbortCount;
	CRITICAL_SECTION	m_Latch;		
	State				m_State;
	WString				m_ServerName;
	GUID				m_BackupId;
	UINT				m_NumDatabases;
	UINT				m_MaxDatabases;
	FrozenDatabase*		m_pDBContext;
};

//-------------------------------------------------------------------------
// Represent a server which can be frozen.
//
class FrozenServer
{
	friend Snapshot;

public:
	FrozenServer (const std::wstring& serverName) :
		m_Name (serverName),
		m_pFreeze2000 (NULL)
	{}

	~FrozenServer ()
	{
		if (m_pFreeze2000)
		{
			delete m_pFreeze2000;
			m_pFreeze2000 = NULL;
		}
	}

	const std::wstring& GetName () const
	{ return m_Name; }

	BOOL
	FindDatabasesToFreeze (
		CCheckPath*		checker);

	BOOL
	Prepare ();

	BOOL
	Freeze ();

	BOOL
	Thaw () throw ();

#if 0
	void
	GetServerInfo (ServerInfo* pSrv);

	UINT
	GetDatabaseCount ();
#endif

	void
	GetDatabaseInfo (UINT dbIndex, FrozenDatabaseInfo* pInfo);

private:
	BOOL
	FindDatabases2000 (
		CCheckPath*		checker);

	void
	GetDatabaseProperties70 (const WString& dbName,
		BOOL*	pSimple,
		BOOL*	pOnline);

private:
	std::wstring	m_Name;
	SqlConnection	m_Connection;
	StringList		m_FrozenDatabases;
	Freeze2000*		m_pFreeze2000;
};


//-------------------------------------------------------------------------
//
class Snapshot : public CSqlSnapshot
{
	enum Status {
		NotInitialized,
		Enumerated,
		Prepared,
		Frozen };

public:
	HRESULT Prepare (
		CCheckPath*		checker) throw ();

	HRESULT Freeze () throw ();

	HRESULT Thaw () throw ();

	Snapshot () {m_Status = NotInitialized;}

	~Snapshot () throw ();

#if 0
	CSqlEnumerator* GetEnumerator () throw ()
	{return (CSqlEnumerator*)this;}

	// Call this at "Post-snapshot" time, after all databases are frozen and MD is complete.
	//
	HRESULT GetBackupMetadata (
		const WCHAR*		pInstance,
		const WCHAR*		pDatabase,
		BYTE**				ppData,		// returns a pointer to the string of metadata
		unsigned int*		pDataLen)	// length of the metadata (in bytes)
							throw ();

	// The enumeration interface
	//
	HRESULT FirstServer (
		ServerInfo*			pServer) throw ();

	HRESULT NextServer (
		ServerInfo*			pServer) throw ();

	HRESULT FirstDatabase (
		const WCHAR*		pServerName,
		DatabaseInfo*		pDbInfo) throw ()
	{return E_NOTIMPL;}

	HRESULT FirstDatabase (
		DatabaseInfo*		pDbInfo) throw ();

	HRESULT NextDatabase (
		DatabaseInfo*		pDbInfo) throw ();

	HRESULT FirstFile (
		const WCHAR*		pServerName,
		const WCHAR*		pDbName,
		DatabaseFileInfo*	pDbInfo) throw ()
	{return E_NOTIMPL;}

	HRESULT NextFile (
		DatabaseFileInfo*	pDbInfo) throw ()
	{return E_NOTIMPL;}
#endif

	HRESULT GetFirstDatabase (
		FrozenDatabaseInfo*	pInfo)	throw ();
	HRESULT GetNextDatabase (
		FrozenDatabaseInfo*	pInfo)	throw ();

private:
	void
	Deinitialize ();

	Status						m_Status;
	std::list<FrozenServer*>	m_FrozenServers;

	typedef std::list<FrozenServer*>::iterator ServerIter;

	ServerIter					m_ServerIter;	// iterate over the frozen servers
	UINT						m_DbIndex;		// iterate over databases within a server
};

//-------------------------------------------------------------------------
//
class RestoreHandler : public CSqlRestore
{
public:
	RestoreHandler ();

	// Inform SQLServer that data laydown is desired on the full database.
	// Performs a DETACH, preventing SQLServer from touching the files.
	//
	virtual HRESULT	PrepareToRestore (
		const WCHAR*		pInstance,
		const WCHAR*		pDatabase)
							throw ();

	// After data is laid down, this performs RESTORE WITH SNAPSHOT[,NORECOVERY]
	//
	virtual HRESULT	FinalizeRestore (
		const WCHAR*		pInstance,
		const WCHAR*		pDatabase,
		bool				compositeRestore,	// true if WITH NORECOVERY desired
		const BYTE*			pMetadata,			// metadata obtained from BACKUP
		unsigned int		dataLen)			// size of metadata (in bytes)
							throw ();

	// Internal use only. Called from the thread proc wrapper.
	//
	void
	RestoreVD ();

private:
	SqlConnection				m_Connection;
	HANDLE						m_hThread;
	IClientVirtualDeviceSet2*   m_pIVDSet;
	IClientVirtualDevice*       m_pIVD;
	WCHAR						m_SetName [80];
	GUID						m_VDSId;
	const BYTE*					m_pMetaData;
	UINT						m_MetaDataSize;
};


// We'll use very simple exception handling.
//
#define THROW_GENERIC  throw exception ();

//----------------------------------------------------------
// Implement our simple enumeration service
//
class SqlEnumerator : public CSqlEnumerator
{
	enum Status {
		Unknown = 0,
		DatabaseQueryActive,
		FileQueryActive
	};

public:
	~SqlEnumerator () throw ();

	SqlEnumerator () :
		m_State (Unknown),
		m_pServers (NULL)
	{}

	HRESULT FirstServer (
		ServerInfo*			pServer) throw ();

	HRESULT NextServer (
		ServerInfo*			pServer) throw ();

	HRESULT FirstDatabase (
		const WCHAR*		pServerName,
		DatabaseInfo*		pDbInfo) throw ();

	HRESULT NextDatabase (
		DatabaseInfo*		pDbInfo) throw ();

	HRESULT FirstFile (
		const WCHAR*		pServerName,
		const WCHAR*		pDbName,
		DatabaseFileInfo*	pDbInfo) throw ();

	HRESULT NextFile (
		DatabaseFileInfo*	pDbInfo) throw ();

private:
	void 
	SetupDatabaseInfo (
		DatabaseInfo*	pDbInfo);

	Status			m_State;
	SqlConnection	m_Connection;
	StringVector*	m_pServers;
	UINT			m_CurrServer;
};

#if defined (DEBUG)

// Type of assertion passed through to utassert_fail function.
//


#define DBG_ASSERT(exp)  BS_ASSERT(exp)

// Allow for noop 64 bit asserts on win32 for things like
// overflowing 32 bit long, etc.
//
#ifdef _WIN64
 #define DBG64_ASSERT(exp) BS_ASSERT(exp)
#else
 #define DBG64_ASSERT(exp)
#endif

#else
 #define DBG_ASSERT(exp)
 #define DBG64_ASSERT(exp)
 #define DBG_ASSERTSZ(exp, txt)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\inc\vdierror.h ===
#ifndef VDIERROR_H_
#define VDIERROR_H_
//****************************************************************************
//		Copyright (c) 1998-2000 Microsoft Corporation.
//
// @File: vdierror.h
//
// Purpose:
//  Declare the error codes emitted by the virtual device interface.
//
// Notes:
//	
// History:
//     
//
// @EndHeader@
//****************************************************************************

//
// Define all the VDI errors.
//


//---------------------------------------------------------------------------------------
// Error code handling will be done in standard COM fashion:
//
// an HRESULT is returned and the caller can use
// SUCCEEDED(code) or FAILED(code) to determine
// if the function failed or not.
//

// form an error code
//
#define VD_ERROR(code) MAKE_HRESULT(SEVERITY_ERROR, 0x77, code)

// The object was not open
//
#define VD_E_NOTOPEN        VD_ERROR( 2 )   /* 0x80770002 */

// The api was waiting and the timeout interval had elapsed.
//
#define VD_E_TIMEOUT        VD_ERROR( 3 )   /* 0x80770003 */

// An abort request is preventing anything except termination actions.
//
#define VD_E_ABORT          VD_ERROR( 4 )   /* 0x80770004 */

// Failed to create security environment.
//
#define VD_E_SECURITY		VD_ERROR( 5 )   /* 0x80770005 */

// An invalid parameter was supplied
//
#define VD_E_INVALID        VD_ERROR( 6 )   /* 0x80770006 */

// Failed to recognize the SQL Server instance name
//
#define VD_E_INSTANCE_NAME  VD_ERROR( 7 )   /* 0x80770007 */

// The requested configuration is invalid
#define VD_E_NOTSUPPORTED   VD_ERROR( 9 )   /* 0x80770009 */

// Out of memory
#define VD_E_MEMORY         VD_ERROR( 10 )  /* 0x8077000a */

// Unexpected internal error
#define VD_E_UNEXPECTED     VD_ERROR (11)   /* 0x8077000b */

// Protocol error
#define VD_E_PROTOCOL       VD_ERROR (12)   /* 0x8077000c */

// All devices are open
#define VD_E_OPEN           VD_ERROR (13)   /* 0x8077000d */

// the object is now closed
#define VD_E_CLOSE          VD_ERROR (14)   /* 0x8077000e */

// the resource is busy
#define VD_E_BUSY           VD_ERROR (15)   /* 0x8077000f */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\vdifreeze.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: vdifreeze.cpp
//
// PURPOSE:
//
//		Use a coordinated VDI BACKUP WITH SNAPSHOT (SQL2000 and above)
//
// NOTES:
//		We'll now support rollforward from the snapshot by providing the
//	BACKUP metadata in the BackupComponentsDocument.
//
//		The VDI method of freeze/thaw avoids the potential resource deadlock
//	which prevents SQLServer from accepting a "dbcc thaw_io" when one or more
//  databases is frozen.
//
// Extern dependencies:
//   provision of "_Module" and the COM guids....
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     85581 SRS  08/15/01 Event security
//     76910 SRS  08/08/01 Rollforward from VSS snapshot
//     68228      12/05/00 ntsnap work
//     68202      11/07/00 ntsnap work
//
// @EndHeader@
// ***************************************************************************


#if DISABLE_4786
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>

#include "vdierror.h"
#include "vdiguid.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLVFRZC"
//
////////////////////////////////////////////////////////////////////////

Freeze2000::Freeze2000 (
	const WString&	serverName,
	ULONG			maxDatabases) :
		m_ServerName (serverName),
		m_MaxDatabases (maxDatabases),
		m_NumDatabases (0),
		m_State (Unprepared),
		m_AbortCount (0)
{
	CVssFunctionTracer(VSSDBG_SQLLIB, L"Freeze2000::Freeze2000");

	m_pDBContext = new FrozenDatabase [maxDatabases];
	CoCreateGuid (&m_BackupId);
	try
	{
		InitializeCriticalSection (&m_Latch);
	}
	catch(...)
	{
		// delete created object if we fail InitializeCriticalSection
		delete m_pDBContext;
	}
}


//----------------------------------------------------------
// Wait for all the database threads to terminate.
// This is only called by the coordinating thread while
// holding exclusive access on the object.
//
void
Freeze2000::WaitForThreads ()
{
	CVssFunctionTracer(VSSDBG_SQLLIB, L"Freeze2000::WaitForThreads");

	for (UINT i=0; i<m_NumDatabases; i++)
	{
		FrozenDatabase* pDb = m_pDBContext+i;
		if (pDb->m_hThread != NULL)
		{
			DWORD	status;
			do
			{
				status = WaitForSingleObjectEx (pDb->m_hThread, 2000, TRUE);

				if (m_State != Aborted && CheckAbort ())
					Abort ();

			} while (status != WAIT_OBJECT_0);

			CloseHandle (pDb->m_hThread);
			pDb->m_hThread = NULL;
		}
	}
}

//---------------------------------------------------------
// Handle an abort.
// The main thread will already hold the the lock and so
// will always be successful at aborting the operation.
// The database threads will attempt to abort, but won't
// block in order to do so.  The abort count is incremented
// and the main thread is ulimately responsible for cleanup.
//
void
Freeze2000::Abort () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Abort");

	SetAbort ();	
	if (TryLock ())
	{
		m_State = Aborted;
		for (UINT i=0; i<m_NumDatabases; i++)
		{
			if (m_pDBContext[i].m_pIVDSet)
			{
				m_pDBContext[i].m_pIVDSet->SignalAbort ();
				m_pDBContext[i].m_pIVDSet->Close ();
				m_pDBContext[i].m_pIVDSet->Release ();
				m_pDBContext[i].m_pIVDSet = NULL;
				m_pDBContext[i].m_pIVD = NULL;
			}
		}
		Unlock ();
	}
}

Freeze2000::~Freeze2000 ()
{
	Lock ();

	if (m_State != Complete)
	{
		// Trigger any waiting threads, cleaning up any VDI's.
		//
		Abort ();

		WaitForThreads ();
	}

	delete[] m_pDBContext;
	DeleteCriticalSection (&m_Latch);
}

//-------------------------------------------
// Map the voids and proc call stuff to the real
// thread routine.
//
DWORD WINAPI FreezeThreadProc(
  LPVOID lpParameter )  // thread data
{
	return Freeze2000::DatabaseThreadStart (lpParameter);
}

DWORD Freeze2000::DatabaseThreadStart (
  LPVOID lpParameter )  // thread data
{
	FrozenDatabase*	pDbContext = (FrozenDatabase*)lpParameter;
	return pDbContext->m_pContext->DatabaseThread (pDbContext);
}

//-------------------------------------------
// Add a database to the freeze set.
//
void
Freeze2000::PrepareDatabase (
	const WString&		dbName)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Free2000::PrepareDatabase");

	// can't backup tempdb!
	//
	if (dbName == L"tempdb")
		return;

	Lock ();

	try
	{
		if (m_State == Unprepared)
		{
			m_State = Preparing;
		}

		if (m_NumDatabases >= m_MaxDatabases ||
			m_State != Preparing)
		{
			DBG_ASSERT(FALSE && L"Too many databases or not preparing");
			THROW_GENERIC;
		}

		FrozenDatabase*	pDbContext = m_pDBContext+m_NumDatabases;
		m_NumDatabases++;

		pDbContext->m_pContext = this;

#ifdef TESTDRV
		ft.hr = CoCreateInstance (
			CLSID_MSSQL_ClientVirtualDeviceSet,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IClientVirtualDeviceSet2,
			(void**)&pDbContext->m_pIVDSet);
#else
        ft.CoCreateInstanceWithLog(
                VSSDBG_SQLLIB,
                CLSID_MSSQL_ClientVirtualDeviceSet,
                L"MSSQL_ClientVirtualDeviceSet",
                CLSCTX_INPROC_SERVER,
                IID_IClientVirtualDeviceSet2,
                (IUnknown**)&(pDbContext->m_pIVDSet));
#endif

		if (ft.HrFailed())
		{
			ft.LogError(VSS_ERROR_SQLLIB_CANTCREATEVDS, VSSDBG_SQLLIB << ft.hr);
			ft.Throw
				(
				VSSDBG_SQLLIB,
				ft.hr,
				L"Failed to create VDS object.  hr = 0x%08lx",
				ft.hr
				);
		}

		VDConfig	config;
		memset (&config, 0, sizeof(config));
		config.deviceCount = 1;
		config.features |= VDF_SnapshotPrepare;

		StringFromGUID2 (m_BackupId, pDbContext->m_SetName, sizeof (pDbContext->m_SetName)/sizeof(WCHAR));
		swprintf (pDbContext->m_SetName+wcslen(pDbContext->m_SetName), L"%d", m_NumDatabases);

		// A "\" indicates a named instance; we need the "raw" instance name
		//
		WCHAR* pInstance = wcschr (m_ServerName.c_str (), L'\\');

		if (pInstance)
		{
			pInstance++;  // step over the separator
		}

		// Create the virtual device set
		//
		ft.hr = pDbContext->m_pIVDSet->CreateEx (pInstance, pDbContext->m_SetName, &config);
		if (ft.HrFailed())
		{
			ft.LogError(VSS_ERROR_SQLLIB_CANTCREATEVDS, VSSDBG_SQLLIB << ft.hr);
			ft.Throw
				(
				VSSDBG_SQLLIB,
				ft.hr,
				L"Failed to create VDS object.  hr = 0x%08lx",
				ft.hr
				);
		}
		pDbContext->m_VDState = FrozenDatabase::Created;
		pDbContext->m_DbName = dbName;

		pDbContext->m_IsMaster = (dbName == L"master");

		pDbContext->m_hThread = CreateThread (NULL, 0,
			FreezeThreadProc, pDbContext, 0, NULL);

		if (pDbContext->m_hThread == NULL)
		{
			ft.hr = HRESULT_FROM_WIN32(GetLastError());
			ft.CheckForError(VSSDBG_SQLLIB, L"CreateThread");
		}
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}

//---------------------------------------------------------
// Prep a database by setting up a BACKUP WITH SNAPSHOT
// Since the backup has no way to stall for the prepare, we stall it by delaying
// the VDI processing until freeze time.
// We use 1024 bytes as the block size because the MTF FLBSize is 1024,
// so we'll see fewer VD commands with no larger resulting MD size.
//
// It would be nice to add a Prepare phase to SQLServer so that the database
// checkpoint could occur during Prepare, rather than during FREEZE.
//
DWORD
Freeze2000::DatabaseThread (
	FrozenDatabase*		pDbContext)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"Freeze2000::DatabaseThread");

	try
	{
		SqlConnection	sql;
		sql.Connect (m_ServerName);

		WCHAR	delimitedName [SysNameBufferLen];
		FormDelimitedIdentifier (delimitedName, pDbContext->m_DbName.c_str ());

		WString command =
			L"BACKUP DATABASE " + WString (delimitedName) + L" TO VIRTUAL_DEVICE='" +
			pDbContext->m_SetName + L"' WITH SNAPSHOT,BUFFERCOUNT=1,BLOCKSIZE=1024";

		sql.SetCommand (command);
		sql.ExecCommand ();
		pDbContext->m_SuccessDetected = TRUE;
	}
	catch (...)
	{
		Abort ();
	}

	return 0;
}

//---------------------------------------------------------
// Advance the status of each VD.
// Will throw if problems are encountered.
//
// This routine is called in two contexts:
//  1. During the "Prepare" phase, 'targetState' is 'PreparedToFreeze'.
//		The goal is to move each VD to an "PreparedToFreeze" state.
//
//  2. During the "Freeze" phase, 'targetState' is 'Frozen'.
//		The remaining metadata is consumed, then the BACKUP will freeze 
//		the database and send the 'VDC_Snapshot' command.
//
// Master must be frozen last, so we skip pulling its VD commands until all other
// databases are complete.  If master is frozen before other databases, SQLServer
// can hang.  
//
void
Freeze2000::AdvanceVDState (
	FrozenDatabase::VDState	targetState)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::AdvanceVDState");
	bool	oneDatabaseLeft = (m_NumDatabases == 1);

	// Poll over the VD's moving them to the target state.
	//
	while (1)
	{
		bool	didSomething = false;
		int		nDatabasesReady = 0;
		DWORD	timeOut = oneDatabaseLeft ? 1000 : 0;
		
		for (UINT i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			if (CheckAbort ())
			{
				THROW_GENERIC;
			}

			if (pDb->m_VDState >= targetState)
			{
				nDatabasesReady++;

				if (nDatabasesReady == m_NumDatabases)
					return;

				if (nDatabasesReady == m_NumDatabases-1)
				{
					oneDatabaseLeft = true;
				}

				continue; // with the next database
			}

			switch (pDb->m_VDState)
			{
				case FrozenDatabase::Created:
					VDConfig	config;
					ft.hr = pDb->m_pIVDSet->GetConfiguration (timeOut, &config);
					if (ft.hr == VD_E_TIMEOUT)
						continue;	// nothing to do for this database right now

					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDeviceSet2::GetConfiguration");

					ft.hr = pDb->m_pIVDSet->OpenDevice (pDb->m_SetName, &pDb->m_pIVD);
					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDeviceSet2::OpenDevice");

					pDb->m_VDState = FrozenDatabase::Open;
					didSomething = true;
					
					// fall thru

				case FrozenDatabase::PreparedToFreeze:

					if (pDb->m_IsMaster && 
						targetState == FrozenDatabase::Frozen &&
						!oneDatabaseLeft)
					{
#ifdef DEBUG_PRINTF
						printf ("Skipping master\n");
#endif
						continue;	// try another database
					}

					if (pDb->m_pSnapshotCmd)
					{
						// Acknowledge the prepare command, which lets the
						// database proceed to frozen.
						//
						ft.hr = pDb->m_pIVD->CompleteCommand (
							pDb->m_pSnapshotCmd, ERROR_SUCCESS, 0, 0);

						// only attempt completion once
						//
						pDb->m_pSnapshotCmd = NULL;

						if (ft.HrFailed())
							ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::CompletePrepare");

						didSomething = true;
					}

					// fall thru

				case FrozenDatabase::Open:

					// pull commands until we see a "prepare" or "mountSnapshot"
					//

					VDC_Command *   cmd;
					HRESULT hr;

					while (SUCCEEDED (hr=pDb->m_pIVD->GetCommand (timeOut, &cmd)))
					{
						DWORD           completionCode;
						DWORD           bytesTransferred=0;
						didSomething = true;

						switch (cmd->commandCode)
						{
							case VDC_Write:
								bytesTransferred = cmd->size;
								pDb->m_MetaData.Append (cmd->buffer, bytesTransferred);
								// fall thru

							case VDC_Flush:
								completionCode = ERROR_SUCCESS;

								ft.hr = pDb->m_pIVD->CompleteCommand (
									cmd, completionCode, bytesTransferred, 0);
								if (ft.HrFailed())
									ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::CompleteCommand");

								break;

							case VDC_PrepareToFreeze:
								// Record the state transition and
								// save the command for completion during the freeze phase.
								//
								DBG_ASSERT (targetState == FrozenDatabase::PreparedToFreeze);

								pDb->m_VDState = FrozenDatabase::PreparedToFreeze;
								pDb->m_pSnapshotCmd = cmd;

#ifdef DEBUG_PRINTF
								printf ("DBPrepared: %ls\n", pDb->m_DbName.c_str ());
#endif
								continue;

							case VDC_Snapshot:
								// Record the state transition and
								// save the command for completion during the thaw phase.
								//
								// Running with SQL2000 prior to SP2 will hit this assert.
								// We'll need to tell customers to use SP2 with Whistler snapshots.
								// The effect is that the databases will freeze during the prepare
								// phase, thus the freeze interval is longer than needed.
								//
								//DBG_ASSERT (targetState == FrozenDatabase::Frozen);

								pDb->m_VDState = FrozenDatabase::Frozen;
								pDb->m_pSnapshotCmd = cmd;

#ifdef DEBUG_PRINTF
								printf ("DBFrozen: %ls\n", pDb->m_DbName.c_str ());
#endif
								continue;

							default:
								ft.Trace(VSSDBG_SQLLIB, L"Unexpected VDCmd: x%x\n", cmd->commandCode);
								THROW_GENERIC;
						} // end command switch
					} // end command loop

					ft.hr = hr;

					if (ft.hr == VD_E_TIMEOUT)
						break;	// no command was ready.
					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::GetCommand");

					break;

				default:
					DBG_ASSERT(FALSE && L"Shouldn't get here");
					THROW_GENERIC;
			} // end switch to handle this db
		} // end loop over each db
	
		// Unless we found something to do,
		// delay a bit and try again.
		//
		if (!didSomething && !oneDatabaseLeft)
		{
#ifdef DEBUG_PRINTF
			printf ("Sleep(100)\n");
#endif

			SleepEx (100, TRUE);
		}

	} // wait for all databases to go "Ready"
}

//---------------------------------------------------------
// Wait for the databases to finish preparing.
// This waits for the virtual devices to open up
//
void
Freeze2000::WaitForPrepare ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::WaitForPrepare");

	Lock ();
	if (m_State != Preparing || CheckAbort ())
	{
		Abort ();
		Unlock ();
		THROW_GENERIC;
	}
	m_State = Prepared;
	try
	{
		AdvanceVDState (FrozenDatabase::PreparedToFreeze);
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}


//------------------------------------------------------------------
// Perform the freeze, waiting for a "Take-snapshot" from each db.
//
void
Freeze2000::Freeze ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Freeze");

	Lock ();
	if (m_State != Prepared || CheckAbort ())
	{
		Abort ();
		Unlock ();
		THROW_GENERIC;
	}

	try
	{
		m_State = Frozen;
		AdvanceVDState (FrozenDatabase::Frozen);
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}


//---------------------------------------------------------
// Perform the thaw.
//
// Return TRUE if the databases were all successfully backed up
// and were thawed out as expected.
// FALSE is returned in any other case.
// No exceptions are thrown (this routine can be used as a cleanup routine).
//
BOOL
Freeze2000::Thaw () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Thaw");

	Lock ();

	if (m_State != Frozen || CheckAbort ())
	{
		Abort ();
		Unlock ();
		return FALSE;
	}

	try
	{

		// Send the "snapshot complete" messages.
		//
		UINT i;

		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			DBG_ASSERT (pDb->m_VDState == FrozenDatabase::Frozen);
			ft.hr = pDb->m_pIVD->CompleteCommand (pDb->m_pSnapshotCmd, ERROR_SUCCESS, 0, 0);
			if (FAILED (ft.hr))
				ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::CompleteCommand");
		}

		// Wait for the BACKUP threads to report success.
		//
		WaitForThreads ();

		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			if (!pDb->m_SuccessDetected)
			{
				THROW_GENERIC;
			}
		}

		// Pull the "close" message from each VD
		//
		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;
		    VDC_Command *   cmd;
			ft.hr=pDb->m_pIVD->GetCommand (INFINITE, &cmd);
			if (ft.hr != VD_E_CLOSE)
				ft.LogError(VSS_ERROR_SQLLIB_FINALCOMMANDNOTCLOSE, VSSDBG_SQLLIB << ft.hr);

			pDb->m_pIVDSet->Close ();
			pDb->m_pIVDSet->Release ();
			pDb->m_pIVDSet = NULL;
			pDb->m_pIVD = NULL;

			pDb->m_MetaData.Finalize ();
		}

		m_State = Complete;
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		return FALSE;
	}
	Unlock ();

	return TRUE;
}

//---------------------------------------------------------
// Fetch the metadata for a database
//
const BYTE*
Freeze2000::GetMetaData (
	const WString&		dbName,
	UINT				*pLength) // return area for data length.
{
	UINT i;
	for (i=0; i<m_NumDatabases; i++)
	{
		FrozenDatabase*	pDb = m_pDBContext+i;

		if (pDb->m_DbName == dbName)
		{
			return pDb->m_MetaData.GetImage (pLength);
		}
	}
	*pLength = 0;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\inc\vdiguid.h ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Jun 30 16:43:31 1999
 */
/* Compiler settings for vdi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IClientVirtualDevice = {0x40700424,0x0080,0x11d2,{0x85,0x1f,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IClientVirtualDeviceSet = {0x40700425,0x0080,0x11d2,{0x85,0x1f,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IClientVirtualDeviceSet2 = {0xd0e6eb07,0x7a62,0x11d2,{0x85,0x73,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDevice = {0xb5e7a131,0xa7bd,0x11d1,{0x84,0xc2,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDeviceSet = {0xb5e7a132,0xa7bd,0x11d1,{0x84,0xc2,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDeviceSet2 = {0xAECBD0D6,0x24C6,0x11d3,{0x85,0xB7,0x00,0xC0,0x4F,0xC2,0x17,0x59}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\sqlenum.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlenum.cpp
//
// PURPOSE:
//
//      Enumerate the sqlservers available on the local node.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     76910 SRS  08/08/01 Rollforward from VSS snapshot
//     68228      12/05/00 ntsnap work
//     68067 srs  11/06/00 ntsnap fix
//     67026 srs  10/05/00 Server enumeration bugs
//
//
// @EndHeader@
// ***************************************************************************

#ifdef HIDE_WARNINGS
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>
#include <clogmsg.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLENUMC"
//
////////////////////////////////////////////////////////////////////////


//------------------------------------------------------------------------
// Determine if the given service name is for a sql server instance.
// If so, return TRUE, the version (7,8,9) and the name of the server
//  The servername is the name used to connect to the server.
//  This will always be of the form: <ComputerName> [\<NamedInstanceName>]
//  On a cluster, the ComputerName is a virtual server name.
//
BOOL							// TRUE if the service is a sqlserver instance
IsSQL (
	PCWSTR		pServiceName,	// in: name of a service
	UINT*		pVersion,		// out: version of the sql instance 
	WString&    serverName)		// out: servername to use to connect to instance
{
    BOOL isDefault = FALSE;
    PCWSTR pInstanceName = NULL;

	if (_wcsicmp (pServiceName, L"MSSQLSERVER") != 0)
	{
		if (_wcsnicmp (pServiceName, L"MSSQL$", 6) != 0)
		{
			return FALSE;
		}
		// we have a named instance
		//
		pInstanceName = pServiceName+6;
		isDefault = FALSE;
	}
	else
	{
		// default instance....  pInstanceName remains null...
		isDefault = TRUE;
	}

    WString rootKey = L"Software\\Microsoft\\";

    if (isDefault)
    {
        rootKey += L"MSSQLServer";
    }
    else
    {
        rootKey += L"Microsoft SQL Server\\" + WString (pInstanceName);
    }

    // First determine the "machinename".
	// when clustered, we pull the the virtual server name from the registry.
    //
    BOOL isClustered = FALSE;
    WString keyName = rootKey + L"\\Cluster";
	HKEY	regHandle;

	if (RegOpenKeyExW (
		HKEY_LOCAL_MACHINE,
		keyName.c_str (),
		0, KEY_QUERY_VALUE, &regHandle) == ERROR_SUCCESS)
	{
#define MAX_CLUSTER_NAME 256
        DWORD 	keytype;
		WCHAR	clusterName [MAX_CLUSTER_NAME+1];
        DWORD   valueLen = sizeof (clusterName)- sizeof(WCHAR);

        clusterName[MAX_CLUSTER_NAME] = L'\0';
		if (RegQueryValueExW (
				regHandle, L"ClusterName",
				NULL, &keytype, (LPBYTE) clusterName,
				&valueLen) == ERROR_SUCCESS &&
			keytype == REG_SZ)
        {
            isClustered = TRUE;
            serverName = WString(clusterName);
        }

		RegCloseKey (regHandle);
	}

    if (!isClustered)
    {
        WCHAR compName [MAX_COMPUTERNAME_LENGTH + 2];
        DWORD nameLen = MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerNameW (compName, &nameLen))
        {
			// In the unlikely event that this fails,
			// let's just use '.'
			//
            compName [0] = L'.';
            compName [1] = 0;
        }


        serverName = compName;
    }

	// For named instances, append the instance name to the "machine" name.
	//
    if (!isDefault)
    {
        serverName += L"\\" + WString (pInstanceName);
    }

	*pVersion = 9; // assume post sql2000 if we can't tell

    keyName = rootKey + L"\\MSSQLServer\\CurrentVersion";

	if (RegOpenKeyExW (
		HKEY_LOCAL_MACHINE,
		keyName.c_str (),
		0, KEY_QUERY_VALUE, &regHandle) == ERROR_SUCCESS)
	{
        DWORD 	keytype;
        const   bufferSize = 20;
		WCHAR	versionString [bufferSize+1];
        DWORD   valueLen = sizeof (versionString) - sizeof(WCHAR);

        versionString[bufferSize] = L'\0';
		if (RegQueryValueExW (
				regHandle, L"CurrentVersion",
				NULL, &keytype, (LPBYTE) versionString,
				&valueLen) == ERROR_SUCCESS &&
			keytype == REG_SZ)
        {
			swscanf (versionString, L"%d", pVersion);
		}

		RegCloseKey (regHandle);
	}

	return TRUE;
}




//------------------------------------------------------------------------
// Build the list of servers on the current machine.
// Throws exception if any errors occur.
//
StringVector*
EnumerateServers ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"EnumerateServers");

	RETCODE		rc;
	BYTE*		pBuf		= NULL;
	std::auto_ptr<StringVector>	serverList (new StringVector);
    SC_HANDLE               hSCManager = NULL;

	BOOL		restrict2000 = FALSE;

	// Read a registry key to see if we should avoid sql versions 
	// beyond SQL2000.
	//
	{
		CVssRegistryKey	restrictKey (KEY_QUERY_VALUE);

		if (restrictKey.Open (HKEY_LOCAL_MACHINE, x_wszVssCASettingsPath))
        {
    		DWORD val;
    		if (restrictKey.GetValue (L"MSDEVersionChecking", val, FALSE))
    		{
			    if (val != 0)
			    {
				    restrict2000 = TRUE;
				    ft.Trace(VSSDBG_SQLLIB, L"Restricting Enumeration - MSDE writer will skip every SQL version newer than 2000");
			    }
		    }
		    restrictKey.Close ();
        }
	}

	try
	{
	    // open SCM
        //
        hSCManager = OpenSCManagerW (NULL, NULL, 
		    SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_CONNECT);

        if (hSCManager == NULL )
            ft.TranslateWin32Error(VSSDBG_SQLLIB, L"OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_CONNECT)");


	    LPENUM_SERVICE_STATUSW pServStat;
	    DWORD bytesNeeded;
	    DWORD sizeOfBuffer;
	    DWORD entriesReturned;
	    DWORD resumeHandle = 0;
	    DWORD status;

	    EnumServicesStatusW (hSCManager,
			    SERVICE_WIN32,
			    SERVICE_ACTIVE,
			    NULL,
			    0,
			    &bytesNeeded,
			    &entriesReturned,
			    &resumeHandle);
	    status = GetLastError ();
        if (status != ERROR_MORE_DATA)
            ft.TranslateWin32Error(VSSDBG_SQLLIB, L"EnumServicesStatus(SERVICE_WIN32, SERVICE_STATE_ALL, ...)");

	    sizeOfBuffer = bytesNeeded;
	    pBuf = new BYTE [sizeOfBuffer]; // "new" will throw on err

	    BOOL moreExpected = FALSE;
        do
        {
		    pServStat = (LPENUM_SERVICE_STATUSW)pBuf;

            moreExpected = FALSE;
		    if (!EnumServicesStatusW (hSCManager,
			    SERVICE_WIN32,
			    SERVICE_ACTIVE,
			    pServStat,	
			    sizeOfBuffer,
			    &bytesNeeded,
			    &entriesReturned,
			    &resumeHandle))
		    {
			    status = GetLastError ();
			    if (status != ERROR_MORE_DATA)
                    ft.TranslateWin32Error(VSSDBG_SQLLIB, L"EnumServicesStatus(SERVICE_WIN32, SERVICE_STATE_ALL, ...)");

		        moreExpected = TRUE;
	        }

		    while (entriesReturned-- > 0)
		    {
			    UINT version = 0;
			    WString serverName;

                // We only need the running servers.
                //
				if (pServStat->ServiceStatus.dwCurrentState == SERVICE_RUNNING)
                {
			        if (IsSQL (pServStat->lpServiceName, &version, serverName))
			        {
           				ft.Trace(VSSDBG_SQLLIB, L"Service: %s Server: %s. Version=%d\n",
					        pServStat->lpServiceName, serverName.c_str (), version);

                        if (version >= 7)
                        {
							if (version < 9 || !restrict2000)
							{
	        				    serverList->push_back (serverName);
							}
                        }
    		        }
		        }
		        pServStat++;
            }    
        }
	    while (moreExpected);


		if (pBuf)
		{
			delete [] pBuf;
		}

        if (hSCManager)
	    {
            CloseServiceHandle (hSCManager);
	    }
	}
	catch (HRESULT)
	{
		if (pBuf)
		{
			delete [] pBuf;
		}

        if (hSCManager)
	    {
            CloseServiceHandle (hSCManager);
	    }

		throw;
	}
    catch (std::exception)
	{
		if (pBuf)
		{
			delete [] pBuf;
		}

        if (hSCManager)
	    {
            CloseServiceHandle (hSCManager);
	    }

		throw;
	}

	return serverList.release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\inc\odbcss.h ===
/*
** ODBCSS.H - This is the application include file for the
** SQL Server driver specific defines.
**
** (C) Copyright 1993-1998 By Microsoft Corp.
**
*/

#ifndef __ODBCSS
#define __ODBCSS

#ifdef __cplusplus
extern "C" { 			/* Assume C declarations for C++   */
#endif  /* __cplusplus */

//	Useful defines
#define SQL_MAX_SQLSERVERNAME	128		// max SQL Server identifier length

//	SQLSetConnectOption/SQLSetStmtOption driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

//	Connection Options
#define SQL_COPT_SS_BASE				1200
#define SQL_COPT_SS_REMOTE_PWD			(SQL_COPT_SS_BASE+1) // dbrpwset SQLSetConnectOption only
#define SQL_COPT_SS_USE_PROC_FOR_PREP	(SQL_COPT_SS_BASE+2) // Use create proc for SQLPrepare
#define SQL_COPT_SS_INTEGRATED_SECURITY	(SQL_COPT_SS_BASE+3) // Force integrated security on login
#define SQL_COPT_SS_PRESERVE_CURSORS	(SQL_COPT_SS_BASE+4) // Preserve server cursors after SQLTransact
#define SQL_COPT_SS_USER_DATA			(SQL_COPT_SS_BASE+5) // dbgetuserdata/dbsetuserdata
#define SQL_COPT_SS_ENLIST_IN_DTC		SQL_ATTR_ENLIST_IN_DTC // Enlist in a DTC transaction
#define SQL_COPT_SS_ENLIST_IN_XA		SQL_ATTR_ENLIST_IN_XA // Enlist in a XA transaction
#define SQL_COPT_SS_CONNECTION_DEAD		SQL_ATTR_CONNECTION_DEAD // dbdead SQLGetConnectOption only
#define SQL_COPT_SS_FALLBACK_CONNECT	(SQL_COPT_SS_BASE+10) // Enables FallBack connections
#define SQL_COPT_SS_PERF_DATA			(SQL_COPT_SS_BASE+11) // Used to access SQL Server ODBC driver performance data
#define SQL_COPT_SS_PERF_DATA_LOG		(SQL_COPT_SS_BASE+12) // Used to set the logfile name for the Performance data
#define SQL_COPT_SS_PERF_QUERY_INTERVAL (SQL_COPT_SS_BASE+13) // Used to set the query logging threshold in milliseconds.
#define SQL_COPT_SS_PERF_QUERY_LOG		(SQL_COPT_SS_BASE+14) // Used to set the logfile name for saving queryies.
#define SQL_COPT_SS_PERF_QUERY			(SQL_COPT_SS_BASE+15) // Used to start and stop query logging.
#define SQL_COPT_SS_PERF_DATA_LOG_NOW	(SQL_COPT_SS_BASE+16) // Used to make a statistics log entry to disk.
#define SQL_COPT_SS_QUOTED_IDENT		(SQL_COPT_SS_BASE+17) // Enable/Disable Quoted Identifiers
#define SQL_COPT_SS_ANSI_NPW			(SQL_COPT_SS_BASE+18) // Enable/Disable ANSI NULL, Padding and Warnings
#define SQL_COPT_SS_BCP					(SQL_COPT_SS_BASE+19) // Allow BCP usage on connection
#define SQL_COPT_SS_TRANSLATE			(SQL_COPT_SS_BASE+20) // Perform code page translation
#define SQL_COPT_SS_ATTACHDBFILENAME	(SQL_COPT_SS_BASE+21) // File name to be attached as a database
#define SQL_COPT_SS_CONCAT_NULL			(SQL_COPT_SS_BASE+22) // Enable/Disable CONCAT_NULL_YIELDS_NULL
#define SQL_COPT_SS_ENCRYPT             (SQL_COPT_SS_BASE+23) // Allow strong encryption for data

#define SQL_COPT_SS_MAX_USED			SQL_COPT_SS_ENCRYPT

//	Statement Options
#define SQL_SOPT_SS_BASE				1225
#define SQL_SOPT_SS_TEXTPTR_LOGGING		(SQL_SOPT_SS_BASE+0) // Text pointer logging
#define SQL_SOPT_SS_CURRENT_COMMAND		(SQL_SOPT_SS_BASE+1) // dbcurcmd SQLGetStmtOption only
#define SQL_SOPT_SS_HIDDEN_COLUMNS		(SQL_SOPT_SS_BASE+2) // Expose FOR BROWSE hidden columns
#define SQL_SOPT_SS_NOBROWSETABLE		(SQL_SOPT_SS_BASE+3) // Set NOBROWSETABLE option
#define SQL_SOPT_SS_REGIONALIZE			(SQL_SOPT_SS_BASE+4) // Regionalize output character conversions
#define SQL_SOPT_SS_CURSOR_OPTIONS		(SQL_SOPT_SS_BASE+5) // Server cursor options
#define SQL_SOPT_SS_NOCOUNT_STATUS      (SQL_SOPT_SS_BASE+6) // Real vs. Not Real row count indicator
#define SQL_SOPT_SS_DEFER_PREPARE		(SQL_SOPT_SS_BASE+7) // Defer prepare until necessary

#define SQL_SOPT_SS_MAX_USED			SQL_SOPT_SS_DEFER_PREPARE

#define SQL_COPT_SS_BASE_EX   1240
#define SQL_COPT_SS_BROWSE_CONNECT		(SQL_COPT_SS_BASE_EX+1) // Browse connect mode of operation
#define SQL_COPT_SS_BROWSE_SERVER		(SQL_COPT_SS_BASE_EX+2) // Single Server browse request.
#define SQL_COPT_SS_WARN_ON_CP_ERROR	(SQL_COPT_SS_BASE_EX+3) // Issues warning when data from the server 
																// had a loss during code page conversion.

#define SQL_COPT_SS_EX_MAX_USED			SQL_COPT_SS_WARN_ON_CP_ERROR

//	Defines for use with SQL_COPT_SS_USE_PROC_FOR_PREP
#define SQL_UP_OFF		0L			//	Procedures won't be used for prepare
#define SQL_UP_ON		1L			//	Procedures will be used for prepare
#define SQL_UP_ON_DROP	2L			//	Temp procedures will be explicitly dropped
#define SQL_UP_DEFAULT	SQL_UP_ON

//	Defines for use with SQL_COPT_SS_INTEGRATED_SECURITY - Pre-Connect Option only
#define SQL_IS_OFF		0L			//	Integrated security isn't used
#define SQL_IS_ON		1L			//	Integrated security is used
#define SQL_IS_DEFAULT	SQL_IS_OFF

//	Defines for use with SQL_COPT_SS_PRESERVE_CURSORS
#define SQL_PC_OFF		0L			//	Cursors are closed on SQLTransact
#define SQL_PC_ON		1L			//	Cursors remain open on SQLTransact
#define SQL_PC_DEFAULT	SQL_PC_OFF

//	Defines for use with SQL_COPT_SS_USER_DATA
#define SQL_UD_NOTSET	NULL			//	No user data pointer set

//	Defines for use with SQL_COPT_SS_TRANSLATE
#define SQL_XL_OFF		0L			//	Code page translation is not performed
#define SQL_XL_ON		1L			//	Code page translation is performed
#define SQL_XL_DEFAULT	SQL_XL_ON

//	Defines for use with SQL_COPT_SS_FALLBACK_CONNECT - Pre-Connect Option only
#define SQL_FB_OFF		0L			//	FallBack connections are disabled
#define SQL_FB_ON		1L			//	FallBack connections are enabled
#define SQL_FB_DEFAULT	SQL_FB_OFF

//	Defines for use with SQL_COPT_SS_BCP - Pre-Connect Option only
#define SQL_BCP_OFF		0L			//	BCP is not allowed on connection
#define SQL_BCP_ON		1L			//	BCP is allowed on connection
#define SQL_BCP_DEFAULT	SQL_BCP_OFF

//	Defines for use with SQL_COPT_SS_QUOTED_IDENT
#define SQL_QI_OFF		0L			//	Quoted identifiers are enable
#define SQL_QI_ON		1L			//	Quoted identifiers are disabled
#define SQL_QI_DEFAULT	SQL_QI_ON

//	Defines for use with SQL_COPT_SS_ANSI_NPW - Pre-Connect Option only
#define SQL_AD_OFF		0L			//	ANSI NULLs, Padding and Warnings are enabled
#define SQL_AD_ON		1L			//	ANSI NULLs, Padding and Warnings are disabled
#define SQL_AD_DEFAULT	SQL_AD_ON

//	Defines for use with SQL_COPT_SS_CONCAT_NULL - Pre-Connect Option only
#define SQL_CN_OFF	  0L		  //  CONCAT_NULL_YIELDS_NULL is off
#define SQL_CN_ON	  1L		  //  CONCAT_NULL_YIELDS_NULL is on
#define SQL_CN_DEFAULT	SQL_CN_ON


//	Defines for use with SQL_SOPT_SS_TEXTPTR_LOGGING
#define SQL_TL_OFF		0L			//	No logging on text pointer ops
#define SQL_TL_ON		1L			//	Logging occurs on text pointer ops
#define SQL_TL_DEFAULT	SQL_TL_ON

//	Defines for use with SQL_SOPT_SS_HIDDEN_COLUMNS
#define SQL_HC_OFF		0L		  //  FOR BROWSE columns are hidden
#define SQL_HC_ON		1L		  //  FOR BROWSE columns are exposed
#define SQL_HC_DEFAULT	SQL_HC_OFF

//	Defines for use with SQL_SOPT_SS_NOBROWSETABLE
#define SQL_NB_OFF		0L			//	NO_BROWSETABLE is off
#define SQL_NB_ON		1L			//	NO_BROWSETABLE is on
#define SQL_NB_DEFAULT	SQL_NB_OFF

//	Defines for use with SQL_SOPT_SS_REGIONALIZE
#define SQL_RE_OFF		0L			//	No regionalization occurs on output character conversions
#define SQL_RE_ON		1L			//	Regionalization occurs on output character conversions
#define SQL_RE_DEFAULT	SQL_RE_OFF

//	Defines for use with SQL_SOPT_SS_CURSOR_OPTIONS
#define SQL_CO_OFF		0L			//	Clear all cursor options
#define SQL_CO_FFO		1L			//	Fast-forward cursor will be used
#define SQL_CO_AF		2L			//	Autofetch on cursor open
#define SQL_CO_FFO_AF	(SQL_CO_FFO|SQL_CO_AF)	//	Fast-forward cursor with autofetch
#define SQL_CO_FIREHOSE_AF 4L       //  Auto fetch on fire-hose cursors 
#define SQL_CO_DEFAULT	SQL_CO_OFF

//SQL_SOPT_SS_NOCOUNT_STATUS
#define SQL_NC_OFF      0L 
#define SQL_NC_ON       1L 

//SQL_SOPT_SS_DEFER_PREPARE
#define SQL_DP_OFF      0L 
#define SQL_DP_ON       1L 

//SQL_COPT_SS_ENCRYPT
#define SQL_EN_OFF      0L
#define SQL_EN_ON       1L

//SQL_COPT_SS_BROWSE_CONNECT
#define SQL_MORE_INFO_NO  0L
#define SQL_MORE_INFO_YES 1L

//SQL_COPT_SS_WARN_ON_CP_ERROR
#define SQL_WARN_NO   0L
#define SQL_WARN_YES  1L

//	Defines returned by SQL_ATTR_CURSOR_TYPE/SQL_CURSOR_TYPE
#define SQL_CURSOR_FAST_FORWARD_ONLY	8	//	Only returned by SQLGetStmtAttr/Option


//	SQLColAttributes driver specific defines.
//	SQLSet/GetDescField driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

#define SQL_CA_SS_BASE				1200
#define SQL_CA_SS_COLUMN_SSTYPE		(SQL_CA_SS_BASE+0)	//	dbcoltype/dbalttype
#define SQL_CA_SS_COLUMN_UTYPE		(SQL_CA_SS_BASE+1)	//	dbcolutype/dbaltutype
#define SQL_CA_SS_NUM_ORDERS		(SQL_CA_SS_BASE+2)	//	dbnumorders
#define SQL_CA_SS_COLUMN_ORDER		(SQL_CA_SS_BASE+3)	//	dbordercol
#define SQL_CA_SS_COLUMN_VARYLEN	(SQL_CA_SS_BASE+4)	//	dbvarylen
#define SQL_CA_SS_NUM_COMPUTES		(SQL_CA_SS_BASE+5)	//	dbnumcompute
#define SQL_CA_SS_COMPUTE_ID		(SQL_CA_SS_BASE+6)	//	dbnextrow status return
#define SQL_CA_SS_COMPUTE_BYLIST	(SQL_CA_SS_BASE+7)	//	dbbylist
#define SQL_CA_SS_COLUMN_ID			(SQL_CA_SS_BASE+8)	//	dbaltcolid
#define SQL_CA_SS_COLUMN_OP			(SQL_CA_SS_BASE+9)	//	dbaltop
#define SQL_CA_SS_COLUMN_SIZE		(SQL_CA_SS_BASE+10)	//	dbcollen
#define SQL_CA_SS_COLUMN_HIDDEN		(SQL_CA_SS_BASE+11) //	Column is hidden (FOR BROWSE)
#define SQL_CA_SS_COLUMN_KEY		(SQL_CA_SS_BASE+12) //	Column is key column (FOR BROWSE)
//#define SQL_DESC_BASE_COLUMN_NAME_OLD	(SQL_CA_SS_BASE+13) //This is defined at another location.
#define SQL_CA_SS_COLUMN_COLLATION	(SQL_CA_SS_BASE+14) //	Column collation (only for chars)
#define SQL_CA_SS_VARIANT_TYPE      (SQL_CA_SS_BASE+15)
#define SQL_CA_SS_VARIANT_SQL_TYPE  (SQL_CA_SS_BASE+16)
#define SQL_CA_SS_VARIANT_SERVER_TYPE (SQL_CA_SS_BASE+17)
#define SQL_CA_SS_MAX_USED			(SQL_CA_SS_BASE+18)




//	SQL Server Data Type Tokens.
//	New types for 6.0 and later servers
/* SQL Server Data Type Tokens. */
#define SQLTEXT 			0x23
#define SQLVARBINARY		0x25
#define SQLINTN 			0x26
#define SQLVARCHAR			0x27
#define SQLBINARY			0x2d
#define SQLIMAGE			0x22
#define SQLCHARACTER		0x2f
#define SQLINT1 			0x30
#define SQLBIT				0x32
#define SQLINT2 			0x34
#define SQLINT4 			0x38
#define SQLMONEY			0x3c
#define SQLDATETIME 		0x3d
#define SQLFLT8 			0x3e
#define SQLFLTN 			0x6d
#define SQLMONEYN			0x6e
#define SQLDATETIMN 		0x6f
#define SQLFLT4 			0x3b
#define SQLMONEY4			0x7a
#define SQLDATETIM4 		0x3a
//	New types for 6.0 and later servers
#define SQLDECIMAL			0x6a
#define SQLNUMERIC			0x6c
//	New types for 7.0 and later servers
#define SQLUNIQUEID			0x24
#define SQLBIGCHAR			0xaf
#define SQLBIGVARCHAR		0xa7
#define SQLBIGBINARY		0xad
#define SQLBIGVARBINARY		0xa5
#define SQLBITN				0x68
#define SQLNCHAR			0xef
#define SQLNVARCHAR 		0xe7
#define SQLNTEXT			0x63
// New for 7.x
#define SQLINT8	            0x7f
#define SQLVARIANT          0x62

//	User Data Type definitions.
//	Returned by SQLColAttributes/SQL_CA_SS_COLUMN_UTYPE.
#define SQLudtBINARY			3
#define SQLudtBIT				16
#define SQLudtBITN				0
#define SQLudtCHAR				1
#define SQLudtDATETIM4			22
#define SQLudtDATETIME			12
#define SQLudtDATETIMN			15
#define SQLudtDECML 			24
#define SQLudtDECMLN			26
#define SQLudtFLT4				23
#define SQLudtFLT8				8
#define SQLudtFLTN				14
#define SQLudtIMAGE 			20
#define SQLudtINT1				5
#define SQLudtINT2				6
#define SQLudtINT4				7
#define SQLudtINTN				13
#define SQLudtMONEY 			11
#define SQLudtMONEY4			21
#define SQLudtMONEYN			17
#define SQLudtNUM				10
#define SQLudtNUMN				25
#define SQLudtSYSNAME			18
#define SQLudtTEXT				19
#define SQLudtTIMESTAMP 		80
#define SQLudtUNIQUEIDENTIFIER	0
#define SQLudtVARBINARY 		4
#define SQLudtVARCHAR			2
#define MIN_USER_DATATYPE		256

//	Aggregate operator types.
//	Returned by SQLColAttributes/SQL_CA_SS_COLUMN_OP.
#define SQLAOPSTDEV 	0x30	// Standard deviation
#define SQLAOPSTDEVP	0x31	// Standard deviation population
#define SQLAOPVAR		0x32	// Variance
#define SQLAOPVARP		0x33	// Variance population
#define SQLAOPCNT		0x4b	// Count
#define SQLAOPSUM		0x4d	// Sum
#define SQLAOPAVG		0x4f	// Average
#define SQLAOPMIN		0x51	// Min
#define SQLAOPMAX		0x52	// Max
#define SQLAOPANY		0x53	// Any
#define SQLAOPNOOP		0x56	// None


//	SQLGetInfo driver specific defines.
//	Microsoft has 1151 thru 1200 reserved for Microsoft SQL Server driver usage.

#define SQL_INFO_SS_FIRST		1199
#define SQL_INFO_SS_NETLIB_NAMEW (SQL_INFO_SS_FIRST+0) //  dbprocinfo
#define SQL_INFO_SS_NETLIB_NAMEA (SQL_INFO_SS_FIRST+1) //  dbprocinfo
#define SQL_INFO_SS_MAX_USED	SQL_INFO_SS_NETLIB_NAMEA
#ifdef UNICODE
#define SQL_INFO_SS_NETLIB_NAME		SQL_INFO_SS_NETLIB_NAMEW
#else
#define SQL_INFO_SS_NETLIB_NAME		SQL_INFO_SS_NETLIB_NAMEA
#endif


//	Driver specific SQL type defines.
//	Microsoft has -150 thru -199 reserved for Microsoft SQL Server driver usage.
#define SQL_SS_VARIANT    -150


//	SQLGetDiagField driver specific defines.
//	Microsoft has -1150 thru -1199 reserved for Microsoft SQL Server driver usage.

#define SQL_DIAG_SS_BASE		(-1150)
#define SQL_DIAG_SS_MSGSTATE	(SQL_DIAG_SS_BASE)
#define SQL_DIAG_SS_SEVERITY	(SQL_DIAG_SS_BASE-1)
#define SQL_DIAG_SS_SRVNAME 	(SQL_DIAG_SS_BASE-2)
#define SQL_DIAG_SS_PROCNAME	(SQL_DIAG_SS_BASE-3)
#define SQL_DIAG_SS_LINE		(SQL_DIAG_SS_BASE-4)


//	SQLGetDiagField/SQL_DIAG_DYNAMIC_FUNCTION_CODE driver specific defines.
//	Microsoft has -200 thru -299 reserved for Microsoft SQL Server driver usage.

#define SQL_DIAG_DFC_SS_BASE					(-200)
#define SQL_DIAG_DFC_SS_ALTER_DATABASE			(SQL_DIAG_DFC_SS_BASE-0)
#define SQL_DIAG_DFC_SS_CHECKPOINT				(SQL_DIAG_DFC_SS_BASE-1)
#define SQL_DIAG_DFC_SS_CONDITION				(SQL_DIAG_DFC_SS_BASE-2)
#define SQL_DIAG_DFC_SS_CREATE_DATABASE 		(SQL_DIAG_DFC_SS_BASE-3)
#define SQL_DIAG_DFC_SS_CREATE_DEFAULT			(SQL_DIAG_DFC_SS_BASE-4)
#define SQL_DIAG_DFC_SS_CREATE_PROCEDURE		(SQL_DIAG_DFC_SS_BASE-5)
#define SQL_DIAG_DFC_SS_CREATE_RULE 			(SQL_DIAG_DFC_SS_BASE-6)
#define SQL_DIAG_DFC_SS_CREATE_TRIGGER			(SQL_DIAG_DFC_SS_BASE-7)
#define SQL_DIAG_DFC_SS_CURSOR_DECLARE			(SQL_DIAG_DFC_SS_BASE-8)
#define SQL_DIAG_DFC_SS_CURSOR_OPEN 			(SQL_DIAG_DFC_SS_BASE-9)
#define SQL_DIAG_DFC_SS_CURSOR_FETCH			(SQL_DIAG_DFC_SS_BASE-10)
#define SQL_DIAG_DFC_SS_CURSOR_CLOSE			(SQL_DIAG_DFC_SS_BASE-11)
#define SQL_DIAG_DFC_SS_DEALLOCATE_CURSOR		(SQL_DIAG_DFC_SS_BASE-12)
#define SQL_DIAG_DFC_SS_DBCC					(SQL_DIAG_DFC_SS_BASE-13)
#define SQL_DIAG_DFC_SS_DISK					(SQL_DIAG_DFC_SS_BASE-14)
#define SQL_DIAG_DFC_SS_DROP_DATABASE			(SQL_DIAG_DFC_SS_BASE-15)
#define SQL_DIAG_DFC_SS_DROP_DEFAULT			(SQL_DIAG_DFC_SS_BASE-16)
#define SQL_DIAG_DFC_SS_DROP_PROCEDURE			(SQL_DIAG_DFC_SS_BASE-17)
#define SQL_DIAG_DFC_SS_DROP_RULE				(SQL_DIAG_DFC_SS_BASE-18)
#define SQL_DIAG_DFC_SS_DROP_TRIGGER			(SQL_DIAG_DFC_SS_BASE-19)
#define SQL_DIAG_DFC_SS_DUMP_DATABASE			(SQL_DIAG_DFC_SS_BASE-20)
#define SQL_DIAG_DFC_SS_DUMP_TABLE				(SQL_DIAG_DFC_SS_BASE-21)
#define SQL_DIAG_DFC_SS_DUMP_TRANSACTION		(SQL_DIAG_DFC_SS_BASE-22)
#define SQL_DIAG_DFC_SS_GOTO					(SQL_DIAG_DFC_SS_BASE-23)
#define SQL_DIAG_DFC_SS_INSERT_BULK 			(SQL_DIAG_DFC_SS_BASE-24)
#define SQL_DIAG_DFC_SS_KILL					(SQL_DIAG_DFC_SS_BASE-25)
#define SQL_DIAG_DFC_SS_LOAD_DATABASE			(SQL_DIAG_DFC_SS_BASE-26)
#define SQL_DIAG_DFC_SS_LOAD_HEADERONLY 		(SQL_DIAG_DFC_SS_BASE-27)
#define SQL_DIAG_DFC_SS_LOAD_TABLE				(SQL_DIAG_DFC_SS_BASE-28)
#define SQL_DIAG_DFC_SS_LOAD_TRANSACTION		(SQL_DIAG_DFC_SS_BASE-29)
#define SQL_DIAG_DFC_SS_PRINT					(SQL_DIAG_DFC_SS_BASE-30)
#define SQL_DIAG_DFC_SS_RAISERROR				(SQL_DIAG_DFC_SS_BASE-31)
#define SQL_DIAG_DFC_SS_READTEXT				(SQL_DIAG_DFC_SS_BASE-32)
#define SQL_DIAG_DFC_SS_RECONFIGURE 			(SQL_DIAG_DFC_SS_BASE-33)
#define SQL_DIAG_DFC_SS_RETURN					(SQL_DIAG_DFC_SS_BASE-34)
#define SQL_DIAG_DFC_SS_SELECT_INTO 			(SQL_DIAG_DFC_SS_BASE-35)
#define SQL_DIAG_DFC_SS_SET 					(SQL_DIAG_DFC_SS_BASE-36)
#define SQL_DIAG_DFC_SS_SET_IDENTITY_INSERT 	(SQL_DIAG_DFC_SS_BASE-37)
#define SQL_DIAG_DFC_SS_SET_ROW_COUNT			(SQL_DIAG_DFC_SS_BASE-38)
#define SQL_DIAG_DFC_SS_SET_STATISTICS			(SQL_DIAG_DFC_SS_BASE-39)
#define SQL_DIAG_DFC_SS_SET_TEXTSIZE			(SQL_DIAG_DFC_SS_BASE-40)
#define SQL_DIAG_DFC_SS_SETUSER 				(SQL_DIAG_DFC_SS_BASE-41)
#define SQL_DIAG_DFC_SS_SHUTDOWN				(SQL_DIAG_DFC_SS_BASE-42)
#define SQL_DIAG_DFC_SS_TRANS_BEGIN 			(SQL_DIAG_DFC_SS_BASE-43)
#define SQL_DIAG_DFC_SS_TRANS_COMMIT			(SQL_DIAG_DFC_SS_BASE-44)
#define SQL_DIAG_DFC_SS_TRANS_PREPARE			(SQL_DIAG_DFC_SS_BASE-45)
#define SQL_DIAG_DFC_SS_TRANS_ROLLBACK			(SQL_DIAG_DFC_SS_BASE-46)
#define SQL_DIAG_DFC_SS_TRANS_SAVE				(SQL_DIAG_DFC_SS_BASE-47)
#define SQL_DIAG_DFC_SS_TRUNCATE_TABLE			(SQL_DIAG_DFC_SS_BASE-48)
#define SQL_DIAG_DFC_SS_UPDATE_STATISTICS		(SQL_DIAG_DFC_SS_BASE-49)
#define SQL_DIAG_DFC_SS_UPDATETEXT				(SQL_DIAG_DFC_SS_BASE-50)
#define SQL_DIAG_DFC_SS_USE 					(SQL_DIAG_DFC_SS_BASE-51)
#define SQL_DIAG_DFC_SS_WAITFOR 				(SQL_DIAG_DFC_SS_BASE-52)
#define SQL_DIAG_DFC_SS_WRITETEXT				(SQL_DIAG_DFC_SS_BASE-53)
#define SQL_DIAG_DFC_SS_DENY					(SQL_DIAG_DFC_SS_BASE-54)
#define SQL_DIAG_DFC_SS_SET_XCTLVL				(SQL_DIAG_DFC_SS_BASE-55)

//	Severity codes for SQL_DIAG_SS_SEVERITY
#define	EX_ANY			0
#define	EX_INFO			10
#define EX_MAXISEVERITY EX_INFO
#define	EX_MISSING		11
#define	EX_TYPE			12
#define	EX_DEADLOCK		13
#define	EX_PERMIT		14
#define	EX_SYNTAX		15
#define	EX_USER			16
#define	EX_RESOURCE		17
#define	EX_INTOK		18
#define	MAXUSEVERITY	EX_INTOK
#define	EX_LIMIT		19
#define	EX_CMDFATAL		20
#define	MINFATALERR		EX_CMDFATAL
#define	EX_DBFATAL		21
#define	EX_TABCORRUPT	22
#define	EX_DBCORRUPT	23
#define	EX_HARDWARE		24
#define	EX_CONTROL		25

//	Internal server datatypes - used when binding to SQL_C_BINARY
#ifndef MAXNUMERICLEN	// Resolve ODS/DBLib conflicts
// DB-Library datatypes
#define DBMAXCHAR		(8000+1)	// Max length of DBVARBINARY and DBVARCHAR, etc. +1 for zero byte
#define MAXNAME 		(SQL_MAX_SQLSERVERNAME+1)	// Max server identifier length including zero byte

#ifdef UNICODE
typedef wchar_t			DBCHAR;
#else
typedef char            DBCHAR;
#endif
typedef unsigned char   DBBINARY;
typedef unsigned char   DBTINYINT;
typedef short           DBSMALLINT;
typedef unsigned short  DBUSMALLINT;
typedef double          DBFLT8;
typedef unsigned char   DBBIT;
typedef unsigned char   DBBOOL;
typedef float           DBFLT4;

typedef DBFLT4 DBREAL;
typedef UINT   DBUBOOL;

typedef struct dbvarychar
{
	DBSMALLINT  len;
	DBCHAR      str[DBMAXCHAR];
} DBVARYCHAR;

typedef struct dbvarybin
{
	DBSMALLINT  len;
	BYTE        array[DBMAXCHAR];
} DBVARYBIN;

typedef struct dbmoney
{						// Internal representation of MONEY data type
	LONG  mnyhigh;		// Money value *10,000 (High 32 bits/signed)
	ULONG mnylow;		// Money value *10,000 (Low 32 bits/unsigned)
} DBMONEY;

typedef struct dbdatetime
{						// Internal representation of DATETIME data type
	LONG  dtdays;		// No of days since Jan-1-1900 (maybe negative)
	ULONG dttime;		// No. of 300 hundredths of a second since midnight
} DBDATETIME;

typedef struct dbdatetime4
{						// Internal representation of SMALLDATETIME data type
	USHORT numdays; 	// No of days since Jan-1-1900
	USHORT nummins; 	// No. of minutes since midnight
} DBDATETIM4;

typedef LONG DBMONEY4;	// Internal representation of SMALLMONEY data type
						// Money value *10,000

#define DBNUM_PREC_TYPE BYTE
#define DBNUM_SCALE_TYPE BYTE
#define DBNUM_VAL_TYPE BYTE

#if (ODBCVER < 0x0300)
#define MAXNUMERICLEN 16

typedef struct dbnumeric
{							// Internal representation of NUMERIC data type
	DBNUM_PREC_TYPE   precision;			// Precision
	DBNUM_SCALE_TYPE  scale;				// Scale
	BYTE			  sign; 				// Sign (1 if positive, 0 if negative)
	DBNUM_VAL_TYPE	  val[MAXNUMERICLEN];	// Value
} DBNUMERIC;
typedef DBNUMERIC DBDECIMAL;// Internal representation of DECIMAL data type
#else	//	Use ODBC 3.0 definitions since same as DBLib
#define MAXNUMERICLEN SQL_MAX_NUMERIC_LEN
typedef SQL_NUMERIC_STRUCT DBNUMERIC;
typedef SQL_NUMERIC_STRUCT DBDECIMAL;
#endif

#endif //	MAXNUMERICLEN

#ifndef INT
typedef int INT;
typedef long            DBINT;
#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const LPBYTE	LPCBYTE;
#endif
typedef DBINT *			LPDBINT;
#endif

/*****************************************************************
 This struct is a global used for 
 gathering statistical data on the driver.
 Access to this structure is controlled via the
 pStatCrit;
******************************************************************/

typedef struct sqlperf
{
	// Application Profile Statistics
	DWORD TimerResolution;
	DWORD SQLidu;
	DWORD SQLiduRows;
	DWORD SQLSelects;
	DWORD SQLSelectRows;
	DWORD Transactions;
	DWORD SQLPrepares;
	DWORD ExecDirects;
	DWORD SQLExecutes;
	DWORD CursorOpens;
	DWORD CursorSize;
	DWORD CursorUsed;
	LDOUBLE PercentCursorUsed;
	LDOUBLE AvgFetchTime;
	LDOUBLE AvgCursorSize; 
	LDOUBLE AvgCursorUsed;
	DWORD SQLFetchTime;
	DWORD SQLFetchCount;
	DWORD CurrentStmtCount;
	DWORD MaxOpenStmt;
	DWORD SumOpenStmt;
	
	// Connection Statistics
	DWORD CurrentConnectionCount;
	DWORD MaxConnectionsOpened;
	DWORD SumConnectionsOpened;
	DWORD SumConnectiontime;
	LDOUBLE AvgTimeOpened;

	// Network Statistics
	DWORD ServerRndTrips;
	DWORD BuffersSent;
	DWORD BuffersRec;
	DWORD BytesSent;
	DWORD BytesRec;

	// Time Statistics;
	DWORD msExecutionTime;
	DWORD msNetWorkServerTime;

} 	SQLPERF;

// The following are options for SQL_COPT_SS_PERF_DATA and SQL_COPT_SS_PERF_QUERY
#define SQL_PERF_START	1			// Starts the driver sampling performance data.
#define SQL_PERF_STOP	2			// Stops the counters from sampling performance data.

// The following are defines for SQL_COPT_SS_PERF_DATA_LOG
#define SQL_SS_DL_DEFAULT	TEXT("C:\\STATS.LOG")

// The following are defines for SQL_COPT_SS_PERF_QUERY_LOG
#define SQL_SS_QL_DEFAULT	TEXT("C:\\QUERY.LOG")

// The following are defines for SQL_COPT_SS_PERF_QUERY_INTERVAL
#define SQL_SS_QI_DEFAULT	30000	//	30,000 milliseconds

//	ODBC BCP prototypes and defines

//	Return codes
#define SUCCEED 		1
#define FAIL			0
#define SUCCEED_ABORT	2
#define SUCCEED_ASYNC	3

//	Transfer directions
#define DB_IN			1	// Transfer from client to server
#define DB_OUT			2	// Transfer from server to client

//	bcp_control option
#define BCPMAXERRS		1	// Sets max errors allowed
#define BCPFIRST		2	// Sets first row to be copied out
#define BCPLAST 		3	// Sets number of rows to be copied out
#define BCPBATCH		4	// Sets input batch size
#define BCPKEEPNULLS	5	// Sets to insert NULLs for empty input values
#define BCPABORT		6	// Sets to have bcpexec return SUCCEED_ABORT
#define BCPODBC 		7	// Sets ODBC canonical character output
#define BCPKEEPIDENTITY	8	// Sets IDENTITY_INSERT on
#define BCP6xFILEFMT	9	// DEPRECATED: Sets 6x file format on
#define BCPHINTSA		10	// Sets server BCP hints (ANSI string)
#define BCPHINTSW		11	// Sets server BCP hints (UNICODE string)
#define BCPFILECP		12	// Sets clients code page for the file
#define BCPUNICODEFILE	13	// Sets that the file contains unicode header
#define BCPTEXTFILE		14	// Sets BCP mode to expect a text file and to detect Unicode or ANSI automatically
#define BCPFILEFMT		15	// Sets file format version

//	BCPFILECP values
//	Any valid code page that is installed on the client can be passed plus:
#define BCPFILECP_ACP	0	// Data in file is in Windows code page
#define BCPFILECP_OEMCP	1	// Data in file is in OEM code page (default)
#define BCPFILECP_RAW	(-1)// Data in file is in Server code page (no conversion)

//	bcp_collen definition
#define SQL_VARLEN_DATA (-10)	//	Use default length for column

// BCP functions
DBINT	SQL_API bcp_batch (HDBC);
RETCODE SQL_API bcp_bind (HDBC, LPCBYTE, INT, DBINT, LPCBYTE, INT, INT, INT);
RETCODE SQL_API bcp_colfmt (HDBC, INT, BYTE, INT, DBINT, LPCBYTE, INT, INT);
RETCODE SQL_API bcp_collen (HDBC, DBINT, INT);
RETCODE SQL_API bcp_colptr (HDBC, LPCBYTE, INT);
RETCODE SQL_API bcp_columns (HDBC, INT);
RETCODE SQL_API bcp_control (HDBC, INT, void *);
DBINT	SQL_API bcp_done (HDBC);
RETCODE SQL_API bcp_exec (HDBC, LPDBINT);
RETCODE SQL_API bcp_getcolfmt (HDBC, INT, INT, void *, INT, INT *);
RETCODE SQL_API bcp_initA (HDBC, LPCSTR, LPCSTR, LPCSTR, INT);
RETCODE SQL_API bcp_initW (HDBC, LPCWSTR, LPCWSTR, LPCWSTR, INT);
RETCODE SQL_API bcp_moretext (HDBC, DBINT, LPCBYTE);
RETCODE SQL_API bcp_readfmtA (HDBC, LPCSTR);
RETCODE SQL_API bcp_readfmtW (HDBC, LPCWSTR);
RETCODE SQL_API bcp_sendrow (HDBC);
RETCODE SQL_API bcp_setcolfmt (HDBC, INT, INT, void *, INT);
RETCODE SQL_API bcp_writefmtA (HDBC, LPCSTR);
RETCODE SQL_API bcp_writefmtW (HDBC, LPCWSTR);
CHAR *	SQL_API dbprtypeA (INT);
WCHAR * SQL_API dbprtypeW (INT);

#ifdef UNICODE
#define bcp_init		bcp_initW
#define bcp_readfmt		bcp_readfmtW
#define bcp_writefmt	bcp_writefmtW
#define dbprtype		dbprtypeW
#define BCPHINTS		BCPHINTSW

#else
#define bcp_init		bcp_initA
#define bcp_readfmt		bcp_readfmtA
#define bcp_writefmt	bcp_writefmtA
#define dbprtype		dbprtypeA
#define BCPHINTS		BCPHINTSA
#endif

//	SQL Server catalog extensions for distributed queries
SQLRETURN SQL_API SQLLinkedServers (SQLHSTMT);
SQLRETURN SQL_API SQLLinkedCatalogsA (SQLHSTMT, LPCSTR, SWORD);
SQLRETURN SQL_API SQLLinkedCatalogsW (SQLHSTMT, LPCWSTR, SWORD);

//	SQL Server extensions for server enumeration
HANDLE   SQL_API SQLInitEnumServers (WCHAR * pwchServerName,WCHAR *pwchInstanceName);
RETCODE  SQL_API SQLGetNextEnumeration (HANDLE hEnumHandle,BYTE * prgEnumData,INT * piEnumLength);
RETCODE  SQL_API SQLCloseEnumServers (HANDLE hEnumHandle);

#ifdef UNICODE
#define SQLLinkedCatalogs	SQLLinkedCatalogsW
#else
#define SQLLinkedCatalogs	SQLLinkedCatalogsA
#endif

//  BCP column format properties
#define BCP_FMT_TYPE			0x01
#define BCP_FMT_INDICATOR_LEN	0x02
#define BCP_FMT_DATA_LEN		0x03
#define	BCP_FMT_TERMINATOR		0x04
#define BCP_FMT_SERVER_COL		0x05
#define BCP_FMT_COLLATION		0x06
#define BCP_FMT_COLLATION_ID	0x07

//	The following options have been deprecated

#define SQL_FAST_CONNECT				(SQL_COPT_SS_BASE+0)
//	Defines for use with SQL_FAST_CONNECT - only useable before connecting
#define SQL_FC_OFF		0L			//	Fast connect is off
#define SQL_FC_ON		1L			//	Fast connect is on
#define SQL_FC_DEFAULT	SQL_FC_OFF
#define SQL_COPT_SS_ANSI_OEM			(SQL_COPT_SS_BASE+6)
#define SQL_AO_OFF						0L
#define SQL_AO_ON						1L
#define SQL_AO_DEFAULT					SQL_AO_OFF

//	Define old names
#define SQL_REMOTE_PWD					SQL_COPT_SS_REMOTE_PWD
#define SQL_USE_PROCEDURE_FOR_PREPARE	SQL_COPT_SS_USE_PROC_FOR_PREP
#define SQL_INTEGRATED_SECURITY 		SQL_COPT_SS_INTEGRATED_SECURITY
#define SQL_PRESERVE_CURSORS			SQL_COPT_SS_PRESERVE_CURSORS
#define SQL_TEXTPTR_LOGGING 			SQL_SOPT_SS_TEXTPTR_LOGGING
#define SQL_CA_SS_BASE_COLUMN_NAME		SQL_DESC_BASE_COLUMN_NAME
#define SQLDECIMALN						0x6a
#define SQLNUMERICN 					0x6c

#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif  /* __cplusplus */
#endif

//	End of odbcss.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\snapsql.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: snapsql.cpp
//
// PURPOSE:
//
//      Implement the SQLServer Volume Snapshot Writer.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Yukon
//     90690 SRS  10/10/01 Minor sqlwriter changes
//     85581 SRS  08/15/01 Event security
//     76910 SRS  08/08/01 Rollforward from VSS snapshot
//     68228      12/05/00 ntsnap work
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************

#if HIDE_WARNINGS
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>

#include <new.h>
#include "vdierror.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLSNAPC"
//
////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------
// Database status bits (from ntdbms/ntinc/database.h)
//
const long DBT_CLOSED =		0x2;		// database is uninitialized because 
										// nobody is in it (see DBT_CLOSE_ON_EXIT)
const long DBT_NOTREC = 	0x40;    /* set for each db by recovery before recovering
			   						any of them */
const long DBT_INRECOVER =	0x80;	/* set by recovery as seach db is recovered */
const long DBT_CKPT =		0x2000;  /* database being checkpointed */
const long DBT_SHUTDOWN =   0x40000; // database hasn't been bootstrapped yet

const long DBT_INLDDB = 	0x20;    /* set by loaddb - tells recovery not to recover
		   						this database */
const long DBT_SUSPECT =	0x100;	/* database not recovered successfully */
const long DBT_DETACHED =   0x80000; // This database has been detached
const long DBT_STANDBY =	0x200000;	// DB is online readonly with RESTORE LOG
									// allowed.  This state is set by RECOVERDB.

/* set by user - saved in Sysdatabases - moved to DBTABLE at checkpoint */
const long DBT_CLOSE_ON_EXIT =	0x1;	// shutdown if you were last user in 
										// this DB
// WARNING:  note that DBT_CLOSED is 0x2
const long DBT_SELBULK = 0x4;
const long DBT_AUTOTRUNC = 0x8; 
const long DBT_TORNPAGE =		0x10;	// enable torn page detection
// 0x10 is available (used to be no checkpoint on recovery)
// WARNING: note that DBT_INLDDB is 0x20
// WARNING: note that DBT_NOTREC is 0x40
// WARNING: note that DBT_INRECOVER is 0x80
// WARNING: note that DBT_SUSPECT is 0x100
const long DBT_OFFLINE = 		0x200;  	/* database is currently offline */
const long DBT_RDONLY = 		0x400;   /* database is read only */
const long DBT_DBO =    		0x800;   /* only available to owner, dbcreator of db and sa */
const long DBT_SINGLE = 		0x1000;  /* single user only */
// WARNING: note that DBT_CKPT is 0x2000
const long DBT_PENDING_UPGRADE = 0x4000; // RESERVED:  We are using this bit in Sphinx
                                        // but not sure if we'll need it in Shiloh.
                                        // DO NOT take it without consultation.
const long DBT_USE_NOTREC = 	0x8000;	/* emergency mode - set to allow db to be not
		   							        recovered but usable */
// WARNING: note that DBT_SHUTDOWN is 0x40000
// WARNING: note that DBT_DETACHED is 0x80000
// WARNING: note that DBT_STANDBY is 0x200000
const long DBT_AUTOSHRINK =     0x400000; /* autoshrink is enable for the database */

// WARNING: in utables 0x8000000 is being added in u_tables.cql to indicate 'table lock on bulk load'
const long DBT_CLEANLY_SHUTDOWN = 0x40000000;	//This database was shutdown in a 
											// clean manner with no open 
											// transactions and all writes
											// flushed to disk											

const long DBT_MINIMAL_LOG_IN_DB = 0x10000000;	// The database contains pages marked
												// changed due to minimally logged ops.
const long DBT_MINIMAL_LOG_AFTER_BACKUP = 0x20000000;	// The database contains pages marked
												// changed due to 


//--------------------------------------------------------------------------------
// Build a literal string from for an identifier.
// We need to provide database names as strings in some T-SQL contexts.
// This routine ensures that we handle them all the same way.
// The output buffer should be SysNameBufferLen in size.
//
void
FormStringForName (WCHAR* pString, const WCHAR* pName)
{
	pString [0] = 'N';   // unicode prefix
	pString [1] = '\'';  // string delimiter

	UINT ix = 2;
	while (*pName && ix < SysNameBufferLen-3)
	{
		if (*pName == '\'')
		{
			// need to double all quotes
			//
			pString [ix++] = '\'';
		}
		pString [ix++] = *pName;
		pName++;
	}

	pString [ix++] = '\'';
	pString [ix] = 0;
}

//--------------------------------------------------------------------------------
// Build a delimited identifier from an identifier.
// We need to handle special characters in database names via delimited identifiers.
// This routine ensures that we handle them all the same way.
// The output buffer should be SysNameBufferLen in size.
//
void
FormDelimitedIdentifier (WCHAR* pString, const WCHAR* pName)
{
	pString [0] = '[';   // unicode prefix

	UINT ix = 1;
	while (*pName && ix < SysNameBufferLen-3)
	{
		if (*pName == ']')
		{
			// need to double embedded brackets
			//
			pString [ix++] = ']';
		}
		pString [ix++] = *pName;
		pName++;
	}

	pString [ix++] = ']';
	pString [ix] = 0;
}


//--------------------------------------------------------------------------------------------------
// A handler to call when out of memory.
//
int __cdecl out_of_store(size_t size)
	{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"out_of_store");
	ft.Trace(VSSDBG_SQLLIB, L"out of memory");

	throw HRESULT (E_OUTOFMEMORY);
	return 0;
	}

class AutoNewHandler
{
public:
	AutoNewHandler ()
	{
	   m_oldHandler = _set_new_handler (out_of_store);
	}

	~AutoNewHandler ()
	{
	   _set_new_handler (m_oldHandler);
	}

private:
   _PNH		m_oldHandler;
};

//-------------------------------------------------------------------------
// Handle enviroment stuff:
//	- tracing/error logging
//  - mem alloc
//
IMalloc * g_pIMalloc = NULL;

HRESULT
InitSQLEnvironment()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"InitSqlEnvironment");
	try
	{
		ft.hr = CoGetMalloc(1, &g_pIMalloc);
		if (ft.HrFailed())
			ft.Trace(VSSDBG_SQLLIB, L"Failed to get task allocator: hr=0x%X", ft.hr);
	}
	catch (...)
	{
		ft.hr = E_SQLLIB_GENERIC;
	}

	return ft.hr;
}



//-------------------------------------------------------------------------
// Return TRUE if the database properties are retrieved:
//		simple: TRUE if using the simple recovery model.
//		online: TRUE if the database is available for backup usable and currently open
//
//  This is only intended to work for SQL70 databases.
//
void
FrozenServer::GetDatabaseProperties70 (const WString& dbName,
	BOOL*	pSimple,
	BOOL*	pOnline)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::GetDatabaseProperties");

	// We use status bit 0x40000000 (1073741824) to identify
	// clean-shutdown databases which are "offline".
	//
	WCHAR	stringName[SysNameBufferLen];
	FormStringForName (stringName, dbName.c_str ());
	WString		query =
		L"select status "
		L"from master..sysdatabases where name = " + WString (stringName);		

	m_Connection.SetCommand (query);
	m_Connection.ExecCommand ();

	if (!m_Connection.FetchFirst ())
	{
		LPCWSTR wsz = dbName.c_str();
		ft.LogError(VSS_ERROR_SQLLIB_DATABASE_NOT_IN_SYSDATABASES, VSSDBG_SQLLIB << wsz);
		THROW_GENERIC;
	}

	UINT32 status = (*(UINT32*)m_Connection.AccessColumn (1));

	if (status & (DBT_INLDDB | DBT_NOTREC | DBT_INRECOVER | DBT_SUSPECT | 
			DBT_OFFLINE | DBT_USE_NOTREC | DBT_SHUTDOWN | DBT_DETACHED | DBT_STANDBY))
	{
		*pOnline = FALSE;
	}
	else
	{
		*pOnline = TRUE;
	}
}


//------------------------------------------------------------------------------
// Build the list of databases to BACKUP for a SQL2000 server for
// the case of a non-component-based backup.
//
//      Only volumes are identified. 
//      Any database with a file on those volumes is included.
//		"Torn" checking is performed.
//		"Autoclosed" databases are skipped (assume they will stay closed).
//		Only simple recovery is allowed.
//		Skip databases which aren't freezable.
//
// Called only by "FindDatabasesToFreeze" to implement a smart access strategy:
//    - use sysaltfiles to qualify the databases.
//      This avoids access to shutdown or damaged databases.
//
// Autoclose databases which are not started are left out of the freeze-list.
// We do this to avoid scaling problems, especially on desktop systems.
// However, such db's are still evaluated to see if they are "torn".
//
// The 'model' database is allowed to be a full recovery database, since only
// database backups are sensible for it.  It is set to full recovery only
// to provide defaults for new databases.
//
// "Freezable" databases are those in a state suitable for BACKUP.
// This excludes databases which are not in an full-ONLINE state 
// (due to damage, partially restored, warm standby, etc).
//
// UNDONE:
// In Yukon, the autoclose determination was unstable.  Re-check it.
//
BOOL
FrozenServer::FindDatabases2000 (
	CCheckPath*		checker)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::FindDatabases2000");

	// Query the databases on this server, looking at properties:
	// (dbname, filename, simpleRecovery, online, inStandby, AutoClose, Autoclosed)
	//
	// We use status bit 0x40000000 (1073741824) to identify
	// clean-shutdown databases which are not really online.
	//
	m_Connection.SetCommand (
		L"select db_name(af.dbid), "
		L"rtrim(af.filename), "
		L"case databasepropertyex(db_name(af.dbid),'recovery') "
			L"when 'SIMPLE' then 1 "
			L"else 0 end, "
		L"case databasepropertyex(db_name(af.dbid),'Status') "
			L"when 'ONLINE' then 1 "
			L"else 0 end, "
		L"convert (int, databasepropertyex(db_name(af.dbid),'IsInStandby')), "
		L"convert (int, databasepropertyex(db_name(af.dbid),'IsAutoClose')), "
		L"case db.status & 1073741824 "
			L"when 1073741824 then 1 "
			L"else 0 end "
		L"from master..sysaltfiles af, master..sysdatabases db "
		L"where af.dbid = db.dbid and af.dbid != db_id('tempdb') "
		L"order by af.dbid"
		);

	m_Connection.ExecCommand ();

	// Results of the query
	//
	WCHAR*	pDbName;
	WCHAR*	pFileName;
	int*	pIsSimple;
	int*	pIsOnline;
	int*	pIsInStandby;
	int*	pIsAutoClose;
	int*	pIsClosed;

	// Track transitions between databases/database files
	//
	bool	firstFile = true;
	bool	done = false;

	// Info about the current database being examined
	//
	WString currDbName;
	bool	currDbInSnapshot;
	bool	currDbIsFreezable;
	bool	currDbIsSimple;
	bool	currDbIsClosed;

	if (!m_Connection.FetchFirst ())
	{
		ft.LogError(VSS_ERROR_SQLLIB_SYSALTFILESEMPTY, VSSDBG_SQLLIB);
		THROW_GENERIC;
	}

	pDbName			= (WCHAR*)	m_Connection.AccessColumn (1);
	pFileName		= (WCHAR*)	m_Connection.AccessColumn (2);
	pIsSimple		= (int*)	m_Connection.AccessColumn (3);
	pIsOnline		= (int*)	m_Connection.AccessColumn (4);
	pIsInStandby	= (int*)	m_Connection.AccessColumn (5);
	pIsAutoClose	= (int*)	m_Connection.AccessColumn (6);
	pIsClosed		= (int*)	m_Connection.AccessColumn (7);

	while (!done)
	{
		bool fileInSnap = checker->IsPathInSnapshot (pFileName);

		// Trace what's happening
		//
		if (firstFile)
		{
			ft.Trace(VSSDBG_SQLLIB, 
				L"Examining database <%s>\nSimpleRecovery:%d Online:%d Standby:%d AutoClose:%d Closed:%d\n",
				pDbName, *pIsSimple, *pIsOnline, *pIsInStandby, *pIsAutoClose, *pIsClosed);
		}
		ft.Trace(VSSDBG_SQLLIB, L"InSnap(%d): %s\n", (int)fileInSnap, pFileName);

		if (firstFile)
		{
			firstFile = FALSE;

			// Remember some facts about this database
			//
			currDbName = WString (pDbName);

			currDbIsSimple = (*pIsSimple || wcscmp (L"model", pDbName) == 0);

			currDbIsFreezable = (*pIsOnline && !*pIsInStandby);
			
			currDbIsClosed = *pIsAutoClose && *pIsClosed;

			currDbInSnapshot = fileInSnap;

			// We can check recovery model and snapshot configuration now
			//
			if (currDbInSnapshot && !currDbIsSimple && currDbIsFreezable)
			{
				ft.LogError(VSS_ERROR_SQLLIB_DATABASENOTSIMPLE, VSSDBG_SQLLIB << pDbName);
				throw HRESULT (E_SQLLIB_NONSIMPLE);
			}
		}
		else
		{
			if (currDbInSnapshot ^ fileInSnap)
			{
				ft.LogError(VSS_ERROR_SQLLIB_DATABASEISTORN, VSSDBG_SQLLIB);
				throw HRESULT (E_SQLLIB_TORN_DB);
			}
		}

		if (!m_Connection.FetchNext ())
		{
			done = true;
		}
		else if (currDbName.compare (pDbName))
		{
			firstFile = TRUE;
		}

		if (done || firstFile)
		{
			// To be part of the BACKUP, the database must:
			//   - be covered by the snapshot
			//   - in a freezeable state
			//
			// IsSimpleOnly implicitly selects all open databases.
			// Non-open databases are also part of the volume snapshot,
			// but there is no need to freeze them, since they aren't
			// changing.
			//
			if (currDbInSnapshot && currDbIsFreezable && !currDbIsClosed)
			{
				m_FrozenDatabases.push_back (currDbName);
			}
		}
	}

	return m_FrozenDatabases.size () > 0;
}

//------------------------------------------------------------------------------
// Determine if there are databases which qualify for a freeze on this server.
// Returns TRUE if so.
//
// Processing varies based on the type of snapshot:
//  1) ComponentBased 
//      The requestor explicitly identifies databases of interest.
//		All recovery models are allowed.
//		"Torn" checking isn't performed (database filenames are irrelevant)
//
//  2) NonComponentBased
// Throws if any qualified databases are any of:
//    - "torn" (not fully covered by the snapshot)
//    - hosted by a server which can't support freeze
//    - are not "simple" databases
//
BOOL
FrozenServer::FindDatabasesToFreeze (
	CCheckPath*		checker)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::FindDatabasesToFreeze");

	m_Connection.Connect (m_Name);

	m_FrozenDatabases.clear ();

	if (checker->IsComponentBased ())
	{
		PCWSTR	dbName;
		UINT	nextIndex = 0;
		while (dbName = checker->EnumerateSelectedDatabases (m_Name.c_str (), &nextIndex))
		{
			m_FrozenDatabases.push_back (WString (dbName));
		}
		return m_FrozenDatabases.size () > 0;
	}

	// Handle non-component-based snapshot
	//


	if (m_Connection.GetServerVersion () > 7)
	{
		// SQL2000 allows us to use a better access strategy.
		//
		return FindDatabases2000 (checker);
	}

	m_Connection.SetCommand (L"select name from sysdatabases where name != 'tempdb'");
	m_Connection.ExecCommand ();
	std::auto_ptr<StringVector> dbList (m_Connection.GetStringColumn ());
	BOOL	masterLast = FALSE;

	for (StringVectorIter i = dbList->begin (); i != dbList->end (); i++)
	{
		// We'll avoid freezing shutdown db's, but we don't avoid
		// enumerating their files (they might be torn)
		//

		// Note the [] around the dbname to handle non-trivial dbnames.
		//
		WCHAR	stringName[SysNameBufferLen];
		FormDelimitedIdentifier (stringName, (*i).c_str ());
		WString		command = L"select rtrim(filename) from " 
			+ WString (stringName) + L"..sysfiles";

		m_Connection.SetCommand (command);
		try
		{
			m_Connection.ExecCommand ();
		}
		catch (...)
		{
			// We've decided to be optimistic:
			// If we can't get the list of files, ignore this database.
			//
			ft.Trace(VSSDBG_SQLLIB, L"Failed to get db files for %s\n", i->c_str ());

			continue;
		}

		std::auto_ptr<StringVector> fileList (m_Connection.GetStringColumn ());

		BOOL first=TRUE;
		BOOL shouldFreeze;

		for (StringVectorIter iFile = fileList->begin ();
			iFile != fileList->end (); iFile++)
		{
			BOOL fileInSnap = checker->IsPathInSnapshot (iFile->c_str ());

			if (first)
			{
				shouldFreeze = fileInSnap;
			}
			else
			{
				if (shouldFreeze ^ fileInSnap)
				{
					ft.LogError(VSS_ERROR_SQLLIB_DATABASEISTORN, VSSDBG_SQLLIB << i->c_str());
					throw HRESULT (E_SQLLIB_TORN_DB);
				}
			}
		}

		if (shouldFreeze)
		{
			BOOL	simple, online;
			GetDatabaseProperties70 (i->c_str (), &simple, &online);
			if (!simple && L"model" != *i)
			{
				ft.LogError(VSS_ERROR_SQLLIB_DATABASENOTSIMPLE, VSSDBG_SQLLIB << i->c_str ());
				throw HRESULT (E_SQLLIB_NONSIMPLE);
			}
			if (online)
			{
				if (L"master" == *i)
				{
					masterLast = TRUE;
				}
				else
				{
					m_FrozenDatabases.push_back (*i);
				}
			}
		}
	}
	if (masterLast)
	{
		m_FrozenDatabases.push_back (L"master");
	}


	return m_FrozenDatabases.size () > 0;
}

//-------------------------------------------------------------------
// Prep the server for the freeze.
// For SQL2000, start a BACKUP WITH SNAPSHOT.
// For SQL7, issuing checkpoints to each database.
// This minimizes the recovery processing needed when the snapshot is restored.
//
BOOL
FrozenServer::Prepare ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Prepare");

	if (m_Connection.GetServerVersion () > 7)
	{
		m_pFreeze2000 = new Freeze2000 (m_Name, m_FrozenDatabases.size ());

		// Release the connection, we won't need it anymore
		//
		m_Connection.Disconnect ();

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			m_pFreeze2000->PrepareDatabase (*i);
		}
		m_pFreeze2000->WaitForPrepare ();
	}
	else
	{
		WString		command;

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			WCHAR	stringName[SysNameBufferLen];
			FormDelimitedIdentifier (stringName, (*i).c_str ());
			command += L"use " + WString (stringName) + L"\ncheckpoint\n";
		}
		
		m_Connection.SetCommand (command);
		m_Connection.ExecCommand ();
	}
	return TRUE;
}

//---------------------------------------------
// Freeze the server by issuing freeze commands
// to each database.
// Returns an exception if any failure occurs.
//
BOOL
FrozenServer::Freeze ()
{
    CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Freeze");
	if (m_pFreeze2000)
	{
		m_pFreeze2000->Freeze ();
	}
	else
	{
		WString		command;

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			WCHAR	stringName[SysNameBufferLen];
			FormStringForName (stringName, (*i).c_str ());
			command += L"dbcc freeze_io (" + WString (stringName) + L")\n";
		}
		
		m_Connection.SetCommand (command);
		m_Connection.ExecCommand ();
	}

	return TRUE;
}

//---------------------------------------------
// Thaw the server by issuing thaw commands
// to each database.
// For SQL7, we can't tell if the database was
// already thawn.
// But for SQL2000, we'll return TRUE only if
// the databases were still all frozen at the thaw time.
BOOL
FrozenServer::Thaw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Thaw");
	if (m_pFreeze2000)
	{
		return m_pFreeze2000->Thaw ();
	}

	WString		command;

	for (StringListIter i=m_FrozenDatabases.begin ();
		i != m_FrozenDatabases.end (); i++)
	{
		WCHAR	stringName[SysNameBufferLen];
		FormStringForName (stringName, (*i).c_str ());
		command += L"dbcc thaw_io (" + WString (stringName) + L")\n";
	}
	
	m_Connection.SetCommand (command);
	m_Connection.ExecCommand ();

	return TRUE;
}


void
FrozenServer::GetDatabaseInfo (UINT dbIndex, FrozenDatabaseInfo* pInfo)
{
	FrozenDatabase* pDb = &m_pFreeze2000->m_pDBContext [dbIndex];

	pInfo->serverName = m_Name.c_str ();
	pInfo->databaseName = pDb->m_DbName.c_str ();
	//pInfo->isSimpleRecovery = pDb->m_IsSimpleModel;
	pInfo->pMetaData = pDb->m_MetaData.GetImage (&pInfo->metaDataSize);
}


//-------------------------------------------------------------------------
// Create an object to handle the SQL end of the snapshot.
//
CSqlSnapshot*
CreateSqlSnapshot () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"CreateSqlSnapshot");
	try
	{
		return new Snapshot;
	}
	catch (...)
	{
	ft.Trace(VSSDBG_SQLLIB, L"Out of memory");
	}
	return NULL;
}

//---------------------------------------------------------------
// Move to an uninitialized state.
//
void
Snapshot::Deinitialize ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Deinitialize");

	if (m_Status == Frozen)
	{
		Thaw ();
	}
	for (ServerIter i=m_FrozenServers.begin ();
		i != m_FrozenServers.end (); i++)
	{
		delete *i;
	}
	m_FrozenServers.clear ();
	m_Status = NotInitialized;
}

Snapshot::~Snapshot ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::~Snapshot");

	try
	{
		ft.Trace(VSSDBG_SQLLIB, L"\n~CSqlSnapshot called\n");
		Deinitialize ();
	}
	catch (...)
	{
		// swallow!
	}
}


//---------------------------------------------------------------------------------------
// Prepare for the snapshot:
//   - identify the installed servers
//   - for each server that is "up":
//		- identify databases affected by the snapshot
//		- if there are such databases, fail the snapshot if:
//			- the server doesn't support snapshots
//			- the database isn't a SIMPLE database
//			- the database is "torn" (not all files in the snapshot)
//
//
HRESULT
Snapshot::Prepare (CCheckPath*	checker) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Prepare");

	HRESULT		hr = S_OK;

	try
	{
		AutoNewHandler	t;

		if (m_Status != NotInitialized)
		{
			Deinitialize ();
		}

		// The state moves immediately to enumerated, indicating
		// that the frozen server list may be non-empty.
		//
		m_Status = Enumerated;

		// Build a list of servers on this machine.
		//
		{
			std::auto_ptr<StringVector>	servers (EnumerateServers ());

			// Scan over the servers, picking out the online ones.
			//
			for (UINT i=0; i < servers->size (); i++)
			{
				FrozenServer* p = new FrozenServer ((*servers)[i]);

				m_FrozenServers.push_back (p);
			}
		}

		// Evaulate the server databases to find those which need to freeze.
		//
		ServerIter i=m_FrozenServers.begin ();
		while (i != m_FrozenServers.end ())
		{
			if (!(**i).FindDatabasesToFreeze (checker))
			{
				ft.Trace(VSSDBG_SQLLIB, L"Server %s has no databases to freeze\n", ((**i).GetName ()).c_str ());

				// Forget about this server, it's got nothing to do.
				//
				delete *i;
				i = m_FrozenServers.erase (i);
			}
			else
			{
				i++;
			}
		}
		
		// Prep the servers for the freeze
		// 	
		for (i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
		{
			(*i)->Prepare ();
		}

		m_Status = Prepared;
	}
	catch (HRESULT& e)
	{
		hr = e;
	}
	catch (...)
	{
		hr = E_SQLLIB_GENERIC;
	}

	return hr;
}

//---------------------------------------------------------------------------------------
// Freeze any prepared servers
//
HRESULT
Snapshot::Freeze () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Freeze");
	HRESULT hr = S_OK;

	if (m_Status != Prepared)
	{
		return E_SQLLIB_PROTO;
	}

	try
	{
		AutoNewHandler	t;

		// If any server is frozen, we are frozen.
		//
		m_Status = Frozen;

		// Ask the servers to freeze
		// 	
		for (ServerIter i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
		{
			(*i)->Freeze ();
		}
	}
	catch (...)
	{
		hr = E_SQLLIB_GENERIC;
	}

	return hr;
}

//-----------------------------------------------
// Thaw all the servers.
// This routine must not throw.  It's safe in a destructor
//
// DISCUSS WITH BRIAN....WE MUST RETURN "SUCCESS" only if the
// servers were all still frozen.  Otherwise the snapshot must
// have been cancelled.
//
HRESULT
Snapshot::Thaw () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Thaw");
	HRESULT	hr = S_OK;
	AutoNewHandler	t;

	// Ask the servers to thaw
	// 	
	for (ServerIter i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
	{
		try
		{
			if (!(*i)->Thaw ())
			{
				hr = E_SQLLIB_GENERIC;
			}
		}
		catch (...)
		{
			hr = E_SQLLIB_GENERIC;
			ft.LogError(VSS_ERROR_SQLLIB_ERRORTHAWSERVER, VSSDBG_SQLLIB << ((**i).GetName ()).c_str ());
		}
	}

	// We still have the original list of servers.
	// The snapshot object is reusable if another "Prepare" is done, which will
	// re-enumerate the servers.
	//
	m_Status = Enumerated;

	return hr;
}


// Fetch info about the first interesting database
//
HRESULT
Snapshot::GetFirstDatabase (
	FrozenDatabaseInfo*		pInfo) throw ()
{
	m_DbIndex = 0;
	m_ServerIter = m_FrozenServers.begin ();

	return GetNextDatabase (pInfo);

}

//---------------------------------------------------------------
// We don't return any info about SQL7 databases since
// the purpose here is to retrieve VDI metadata needed for
// BACKUP/RESTORE WITH SNAPSHOT.
//
HRESULT
Snapshot::GetNextDatabase (
	FrozenDatabaseInfo*		pInfo) throw ()
{
	while (m_ServerIter != m_FrozenServers.end ())
	{
		FrozenServer*	pSrv = *m_ServerIter;

		if (pSrv->m_pFreeze2000 &&
			m_DbIndex < pSrv->m_pFreeze2000->m_NumDatabases)
		{
			pSrv->GetDatabaseInfo (m_DbIndex, pInfo);
			m_DbIndex++;
			return NOERROR;
		}

		m_DbIndex = 0;
		m_ServerIter++;
	}
	return DB_S_ENDOFROWSET;
}

//---------------------------------------------------------------------

// Setup some try/catch/handlers for our interface...
// The invoker defines "hr" which is set if an exception
// occurs.
//
#define TRY_SQLLIB \
	try	{\
		AutoNewHandler	_myNewHandler;

#define END_SQLLIB \
	} catch (HRESULT& e)\
	{\
		ft.hr = e;\
	}\
	catch (...)\
	{\
		ft.hr = E_SQLLIB_GENERIC;\
	}

//-------------------------------------------------------------------------
// Create an object to handle the SQL end of the snapshot.
//
CSqlRestore*
CreateSqlRestore () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"CreateSqlRestore");
	try
	{
		return new RestoreHandler;
	}
	catch (...)
	{
	ft.Trace(VSSDBG_SQLLIB, L"Out of memory");
	}
	return NULL;
}

RestoreHandler::RestoreHandler ()
{
	// This GUID is used as the name for the VDSet
	// We can reuse it for multiple restores, since only one
	// will run at a time.
	//
	CoCreateGuid (&m_VDSId);
}



// Inform SQLServer that data laydown is desired on the full database.
// Performs a DETACH, preventing SQLServer from touching the files.
//
HRESULT	
RestoreHandler::PrepareToRestore (
	const WCHAR*		pInstance,
	const WCHAR*		pDatabase) 
	throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"RestoreHandler::PrepareToRestore");

	TRY_SQLLIB
	{
		m_Connection.Connect (pInstance);
		WCHAR	stringName[SysNameBufferLen];

		FormStringForName (stringName, pDatabase);

		WString		command = 
			L"if exists (select name from sysdatabases where name=" + 
			WString(stringName) + 
			L") ALTER DATABASE ";
		FormDelimitedIdentifier (stringName, pDatabase);
		command += WString (stringName) + L" SET OFFLINE WITH ROLLBACK IMMEDIATE";

		m_Connection.SetCommand (command);
		m_Connection.ExecCommand ();
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------
// Map the voids and proc call stuff to the real
// thread routine.
//
DWORD WINAPI RestoreVDProc(
  LPVOID lpParameter )  // thread data
{
	((RestoreHandler*)lpParameter)->RestoreVD ();
	return 0;
}

//----------------------------------------------------------------------
// Feed the MD back to SQLServer
// Our caller setup the VDS, but we've got to finish the open processing.
//
void
RestoreHandler::RestoreVD ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"RestoreHandler::RestoreVD");

    VDC_Command *   cmd;
    DWORD           completionCode;
    DWORD           bytesTransferred;
    HRESULT         hr;
	const BYTE		*pCurData = m_pMetaData;
	VDConfig		config;

	hr = m_pIVDSet->GetConfiguration (INFINITE, &config);
	if (FAILED (hr))
	{
		ft.Trace (VSSDBG_SQLLIB, L"Unexpected GetConfiguration hr: x%X\n", hr);
		m_pIVDSet->SignalAbort ();
		return;
	}

	hr = m_pIVDSet->OpenDevice (m_SetName, &m_pIVD);
	if (FAILED (hr))
	{
		ft.Trace (VSSDBG_SQLLIB, L"Unexpected OpenDevice hr: x%X\n", hr);
		m_pIVDSet->SignalAbort ();
		return;
	}

    while (SUCCEEDED (hr=m_pIVD->GetCommand (INFINITE, &cmd)))
    {
        bytesTransferred = 0;
        switch (cmd->commandCode)
        {
            case VDC_Read:
				if (pCurData+cmd->size > m_pMetaData+m_MetaDataSize)
				{
					// attempting to read past end of data.
					//
                    completionCode = ERROR_HANDLE_EOF;
				}
				else
				{
					memcpy (cmd->buffer, pCurData, cmd->size);
					pCurData+= cmd->size;
					bytesTransferred = cmd->size;
				}

            case VDC_ClearError:
                completionCode = ERROR_SUCCESS;
                break;

			case VDC_MountSnapshot:
				// There is nothing to do here, since the snapshot
				// is already mounted.
				//
				completionCode = ERROR_SUCCESS;
				break;

            default:
                // If command is unknown...
                completionCode = ERROR_NOT_SUPPORTED;
        }

        hr = m_pIVD->CompleteCommand (cmd, completionCode, bytesTransferred, 0);
        if (!SUCCEEDED (hr))
        {
            break;
        }
    }

    if (hr == VD_E_CLOSE)
    {
		ft.hr = NOERROR;
	}
	else
	{
		ft.Trace (VSSDBG_SQLLIB, L"Unexpected VD termination: x%X\n", hr);
		ft.hr = hr;
	}
}



// After data is laid down, this performs RESTORE WITH SNAPSHOT[,NORECOVERY]
//
HRESULT	
RestoreHandler::FinalizeRestore (
	const WCHAR*		pInstance,
	const WCHAR*		pDatabase,
	bool				compositeRestore,	// true if WITH NORECOVERY desired
	const BYTE*			pMetadata,			// metadata obtained from BACKUP
	unsigned int		dataLen)			// size of metadata (in bytes)
						throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"RestoreHandler::FinalizeRestore");

	if (!MetaData::IsValidImage (pMetadata, dataLen))
	{
		// Brian, do we want to log something here?
		// This shouldn't happen, but I add a csum just to be sure....
		//
		ft.Trace (VSSDBG_SQLLIB, L"Bad metadata for database %s\\%s", pInstance, pDatabase);
		return E_SQLLIB_GENERIC;
	}

	m_pIVDSet = NULL;
	m_pIVD = NULL;
	m_pMetaData = pMetadata;
	m_MetaDataSize = dataLen - sizeof(UINT); // chop off the checksum
	m_hThread = NULL;

	TRY_SQLLIB
	{
		// Make sure we have a connection to the server
		//
		m_Connection.Connect (pInstance);

		// Build a VDS for the RESTORE
		//

#ifdef TESTDRV
		ft.hr = CoCreateInstance (
			CLSID_MSSQL_ClientVirtualDeviceSet,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IClientVirtualDeviceSet2,
			(void**)&m_pIVDSet);
#else
        ft.CoCreateInstanceWithLog (
                VSSDBG_SQLLIB,
                CLSID_MSSQL_ClientVirtualDeviceSet,
                L"MSSQL_ClientVirtualDeviceSet",
                CLSCTX_INPROC_SERVER,
                IID_IClientVirtualDeviceSet2,
                (IUnknown**)&(m_pIVDSet));
#endif

		if (ft.HrFailed())
		{
			ft.LogError(VSS_ERROR_SQLLIB_CANTCREATEVDS, VSSDBG_SQLLIB << ft.hr);
			ft.Throw
				(
				VSSDBG_SQLLIB,
				ft.hr,
				L"Failed to create VDS object.  hr = 0x%08lx",
				ft.hr
				);
		}

		VDConfig	config;
		memset (&config, 0, sizeof(config));
		config.deviceCount = 1;

		StringFromGUID2 (m_VDSId, m_SetName, sizeof (m_SetName)/sizeof(WCHAR));

		// A "\" indicates a named instance; we need the "raw" instance name
		//
		WCHAR* pShortInstance = wcschr (pInstance, L'\\');

		if (pShortInstance)
		{
			pShortInstance++;  // step over the separator
		}

		// Create the virtual device set
		//
		ft.hr = m_pIVDSet->CreateEx (pShortInstance, m_SetName, &config);
		if (ft.HrFailed())
		{
			ft.LogError(VSS_ERROR_SQLLIB_CANTCREATEVDS, VSSDBG_SQLLIB << ft.hr);
			ft.Throw
				(
				VSSDBG_SQLLIB,
				ft.hr,
				L"Failed to create VDS object.  hr = 0x%08lx",
				ft.hr
				);
		}

		// Spawn a thread to feed the VD metadata....
		//
		m_hThread = CreateThread (NULL, 0,
			RestoreVDProc, this, 0, NULL);

		if (m_hThread == NULL)
		{
			ft.hr = HRESULT_FROM_WIN32(GetLastError());
			ft.CheckForError(VSSDBG_SQLLIB, L"CreateThread");
		}

		// Send the RESTORE command, which will cause the VD metadata
		// to be consumed.
		//
		WCHAR	stringName[SysNameBufferLen];
		FormDelimitedIdentifier (stringName, pDatabase);

		WString		command = 
			L"RESTORE DATABASE " + WString(stringName) + L" FROM VIRTUAL_DEVICE='" +
			m_SetName + L"' WITH SNAPSHOT,BUFFERCOUNT=1,BLOCKSIZE=1024";
		if (compositeRestore)
		{
			command += L",NORECOVERY";
		}

		m_Connection.SetCommand (command);
		m_Connection.ExecCommand ();

		// Unless an exception is thrown, we were sucessful.
		//
		ft.hr = NOERROR;
	}
	END_SQLLIB

	if (m_pIVDSet)
	{
		// If we hit an error, we'll need to clean up
		//
		if (ft.hr != NOERROR)
		{
			m_pIVDSet->SignalAbort ();
		}

		if (m_hThread)
		{
			// We gotta wait for our thread, since it's using our resources.
			//
			DWORD status = WaitForSingleObjectEx (m_hThread, INFINITE, TRUE);
			if (status != WAIT_OBJECT_0)
			{
				ft.Trace (VSSDBG_SQLLIB, L"Unexpected thread-wait status: x%x", status);
			}
			CloseHandle (m_hThread);
		}
		m_pIVDSet->Close ();
		m_pIVDSet->Release ();
	}

	return ft.hr;
}

//-------------------------------------------------------------------------
// Create an object to handle enumerations
//
CSqlEnumerator*
CreateSqlEnumerator () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"CreateSqlEnumerator");
	try
	{
		return new SqlEnumerator;
	}
	catch (...)
	{
		ft.Trace(VSSDBG_SQLLIB, L"Out of memory");
	}
	return NULL;
}

//-------------------------------------------------------------------------
//
SqlEnumerator::~SqlEnumerator ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::~SqlEnumerator");

	if (m_pServers)
		delete m_pServers;
}

//-------------------------------------------------------------------------
// Begin retrieval of the servers.
//
HRESULT
SqlEnumerator::FirstServer (ServerInfo* pSrv) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstServer");


	if (m_pServers)
	{
		delete m_pServers;
		m_pServers = NULL;
	}

	m_CurrServer = 0;

	TRY_SQLLIB
	{
		m_pServers = EnumerateServers ();

		if (m_pServers->size () == 0)
		{
			ft.hr = DB_S_ENDOFROWSET;
		}
		else
        {
			wcscpy (pSrv->name, (*m_pServers)[0].c_str ());
			pSrv->isOnline = true;

			// Bummer, the enumeration is just a list of strings.....
			//pSrv->supportsCompositeRestore = true;

			m_CurrServer = 1;
			
			ft.hr = NOERROR;
        }
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------------------------------------
// Continue retrieval of the servers.
//
HRESULT
SqlEnumerator::NextServer (ServerInfo* pSrv) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextServer");


	if (!m_pServers)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
	{
		TRY_SQLLIB
		{
			if (m_CurrServer >= m_pServers->size ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
			{
				wcscpy (pSrv->name, (*m_pServers)[m_CurrServer].c_str ());
				m_CurrServer++;

				pSrv->isOnline = true;

				//pSrv->supportsCompositeRestore = true;
				
				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}

//-------------------------------------------------------------------------
// Copy out the info from the result set
//
void
SqlEnumerator::SetupDatabaseInfo (DatabaseInfo* pDbInfo)
{
	WCHAR *pDbName = (WCHAR*)m_Connection.AccessColumn (1);
	UINT status = *(int*)m_Connection.AccessColumn (2);

	wcscpy (pDbInfo->name, pDbName);

	pDbInfo->isSimpleRecovery = (DBT_AUTOTRUNC & status) ? true : false;
	pDbInfo->status = status;

	pDbInfo->supportsFreeze = false;
	if (wcscmp (pDbName, L"tempdb") != 0)
	{
		// Databases not fully online are not eligible for backup.
		//
		if (!(status & (DBT_INLDDB | DBT_NOTREC | DBT_INRECOVER | DBT_SUSPECT | 
			DBT_OFFLINE | DBT_USE_NOTREC | DBT_SHUTDOWN | DBT_DETACHED | DBT_STANDBY)))
		{
			pDbInfo->supportsFreeze = true;
		}
	}
}

//-------------------------------------------------------------------------
// Begin retrieval of the databases
//
HRESULT
SqlEnumerator::FirstDatabase (const WCHAR *pServerName, DatabaseInfo* pDbInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstDatabase");

	TRY_SQLLIB
	{
		m_Connection.Connect (pServerName);
		m_Connection.SetCommand (
			L"select name,convert (int,status) from master.dbo.sysdatabases");
		m_Connection.ExecCommand ();

		if (!m_Connection.FetchFirst ())
		{
			ft.LogError(VSS_ERROR_SQLLIB_NORESULTFORSYSDB, VSSDBG_SQLLIB);
			THROW_GENERIC;
		}

		SetupDatabaseInfo (pDbInfo);

		m_State = DatabaseQueryActive;

		ft.hr = NOERROR;
	}
	END_SQLLIB

	return ft.hr;
}


//-------------------------------------------------------------------------
// Continue retrieval of the databases
//
HRESULT
SqlEnumerator::NextDatabase (DatabaseInfo* pDbInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextDatabase");

	if (m_State != DatabaseQueryActive)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
    {
		TRY_SQLLIB
		{
			if (!m_Connection.FetchNext ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
			{
				SetupDatabaseInfo (pDbInfo);

				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}

//-------------------------------------------------------------------------
// Begin retrieval of the database files
//
HRESULT
SqlEnumerator::FirstFile (
	const WCHAR*		pServerName,
	const WCHAR*		pDbName,
	DatabaseFileInfo*	pFileInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstFile");

	TRY_SQLLIB
	{
		m_Connection.Connect (pServerName);

		WString query;

		if (m_Connection.GetServerVersion () >= 8)
		{
			WCHAR	stringName[SysNameBufferLen];
			FormStringForName (stringName, pDbName);

			query =	L"select rtrim(filename),status & 64 from sysaltfiles where DB_ID("
				+ WString(stringName) + L") = dbid";
		}
		else
		{
			WCHAR	stringName[SysNameBufferLen];
			FormDelimitedIdentifier (stringName, pDbName);

			query = L"select rtrim(filename),status & 64 from "
				+ WString(stringName) + L"..sysfiles";
		}

		m_Connection.SetCommand (query);
		m_Connection.ExecCommand ();

		if (!m_Connection.FetchFirst ())
		{
			ft.LogError(VSS_ERROR_SQLLIB_NORESULTFORSYSDB, VSSDBG_SQLLIB);
			THROW_GENERIC;
		}

		WCHAR* pName = (WCHAR*)m_Connection.AccessColumn (1);
		int* pLogFile = (int*)m_Connection.AccessColumn (2);

		wcscpy (pFileInfo->name, pName);
		pFileInfo->isLogFile = (*pLogFile != 0);

		m_State = FileQueryActive;

		ft.hr = NOERROR;
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------------------------------------
// Continue retrieval of the files
//
HRESULT
SqlEnumerator::NextFile (DatabaseFileInfo* pFileInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextFile");

	if (m_State != FileQueryActive)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
    {
		TRY_SQLLIB
		{
			if (!m_Connection.FetchNext ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
            {
				WCHAR* pName = (WCHAR*)m_Connection.AccessColumn (1);
				int* pLogFile = (int*)m_Connection.AccessColumn (2);

				wcscpy (pFileInfo->name, pName);
				pFileInfo->isLogFile = (*pLogFile != 0);

				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}

//-------------------------------------------------------------------------
// Provide a simple container for BACKUP metadata.
//
MetaData::MetaData ()
{
	m_UsedLength = 0;
	m_AllocatedLength = 0x2000; // 8K will represent any small database
	m_pData = new BYTE [m_AllocatedLength];
}
MetaData::~MetaData ()
{
	if (m_pData)
	{
		delete[] m_pData;
	}
}
void
MetaData::Append (const BYTE* pData, UINT length)
{
	// We don't need to handle misalignment for the csum.
	//
	DBG_ASSERT (length % sizeof(UINT) == 0);

	if (m_UsedLength + length > m_AllocatedLength)
	{
		BYTE*	pNew = new BYTE [m_AllocatedLength*2];
		memcpy (pNew, m_pData, m_UsedLength);
		delete[] m_pData;
		m_pData = pNew;
		m_AllocatedLength *= 2;
	}
	memcpy (m_pData+m_UsedLength, pData, length);
	m_UsedLength += length;
}
void
MetaData::Finalize ()
{
	UINT	csum = Checksum (m_pData, m_UsedLength);
	Append ((BYTE*)&csum, sizeof(csum));
}
const BYTE*
MetaData::GetImage (UINT *pLength)
{
	*pLength = m_UsedLength;
	return m_pData;
}
BOOL
MetaData::IsValidImage (const BYTE* pData, UINT length)
{
	return (0 == Checksum (pData, length));
}
UINT
MetaData::Checksum (const BYTE* pData, UINT length)
{
	UINT	csum = 0;
	UINT	nwords = length/sizeof(csum);
	UINT*	pWord = (UINT*)pData;
	while (nwords>0)
	{
		csum ^= *pWord;
		pWord++;
		nwords--;
	}
	return csum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\tracing\bsconcur.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsconcur.cxx

Abstract:

    Implementation of CBsXXXX classes that wrap Win32 concurrency controls.

Author:

    Stefan R. Steiner   [SSteiner]      11-Apr-1998

Revision History:

--*/

#include <windows.h>
#include "bsconcur.hxx"

//////////////////////////////////////////////////////////////////////
// CBsAutoLock class implementation
//////////////////////////////////////////////////////////////////////

CBsAutoLock::~CBsAutoLock()
{
    BOOL bStatus = TRUE;

    switch( m_type ) {
    case BS_AUTO_MUTEX_HANDLE: 
        bStatus = ::ReleaseMutex( m_hMutexHandle );
        break;
    case BS_AUTO_CRIT_SEC:
        ::LeaveCriticalSection( m_pCritSec );
        break;
    case BS_AUTO_CRIT_SEC_CLASS:
        m_pcCritSec->Leave();
        break;
    }

    if ( bStatus == FALSE ) {
        throw( ::GetLastError() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\stswriter\globals.cpp ===
#define INITGUID
#include "iadmw.h"
#include "iiscnfg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqllib\inc\vdi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Tue Jul 24 13:59:27 2001
 */
/* Compiler settings for vdi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vdi_h__
#define __vdi_h__

/* Forward Declarations */ 

#ifndef __IClientVirtualDevice_FWD_DEFINED__
#define __IClientVirtualDevice_FWD_DEFINED__
typedef interface IClientVirtualDevice IClientVirtualDevice;
#endif 	/* __IClientVirtualDevice_FWD_DEFINED__ */


#ifndef __IClientVirtualDeviceSet_FWD_DEFINED__
#define __IClientVirtualDeviceSet_FWD_DEFINED__
typedef interface IClientVirtualDeviceSet IClientVirtualDeviceSet;
#endif 	/* __IClientVirtualDeviceSet_FWD_DEFINED__ */


#ifndef __IClientVirtualDeviceSet2_FWD_DEFINED__
#define __IClientVirtualDeviceSet2_FWD_DEFINED__
typedef interface IClientVirtualDeviceSet2 IClientVirtualDeviceSet2;
#endif 	/* __IClientVirtualDeviceSet2_FWD_DEFINED__ */


#ifndef __IServerVirtualDevice_FWD_DEFINED__
#define __IServerVirtualDevice_FWD_DEFINED__
typedef interface IServerVirtualDevice IServerVirtualDevice;
#endif 	/* __IServerVirtualDevice_FWD_DEFINED__ */


#ifndef __IServerVirtualDeviceSet_FWD_DEFINED__
#define __IServerVirtualDeviceSet_FWD_DEFINED__
typedef interface IServerVirtualDeviceSet IServerVirtualDeviceSet;
#endif 	/* __IServerVirtualDeviceSet_FWD_DEFINED__ */


#ifndef __IServerVirtualDeviceSet2_FWD_DEFINED__
#define __IServerVirtualDeviceSet2_FWD_DEFINED__
typedef interface IServerVirtualDeviceSet2 IServerVirtualDeviceSet2;
#endif 	/* __IServerVirtualDeviceSet2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_vdi_0000 */
/* [local] */ 


#pragma pack(push, _vdi_h_)

#pragma pack(8)
struct VDConfig
    {
    unsigned long deviceCount;
    unsigned long features;
    unsigned long prefixZoneSize;
    unsigned long alignment;
    unsigned long softFileMarkBlockSize;
    unsigned long EOMWarningSize;
    unsigned long serverTimeOut;
    unsigned long blockSize;
    unsigned long maxIODepth;
    unsigned long maxTransferSize;
    unsigned long bufferAreaSize;
    };

enum VDFeatures
    {	VDF_Removable	= 0x1,
	VDF_Rewind	= 0x2,
	VDF_Position	= 0x10,
	VDF_SkipBlocks	= 0x20,
	VDF_ReversePosition	= 0x40,
	VDF_Discard	= 0x80,
	VDF_FileMarks	= 0x100,
	VDF_RandomAccess	= 0x200,
	VDF_SnapshotPrepare	= 0x400,
	VDF_WriteMedia	= 0x10000,
	VDF_ReadMedia	= 0x20000,
	VDF_LatchStats	= 0x80000000,
	VDF_LikePipe	= 0,
	VDF_LikeTape	= VDF_FileMarks | VDF_Removable | VDF_Rewind | VDF_Position | VDF_SkipBlocks | VDF_ReversePosition,
	VDF_LikeDisk	= VDF_RandomAccess
    };

enum VDCommands
    {	VDC_Read	= 1,
	VDC_Write	= VDC_Read + 1,
	VDC_ClearError	= VDC_Write + 1,
	VDC_Rewind	= VDC_ClearError + 1,
	VDC_WriteMark	= VDC_Rewind + 1,
	VDC_SkipMarks	= VDC_WriteMark + 1,
	VDC_SkipBlocks	= VDC_SkipMarks + 1,
	VDC_Load	= VDC_SkipBlocks + 1,
	VDC_GetPosition	= VDC_Load + 1,
	VDC_SetPosition	= VDC_GetPosition + 1,
	VDC_Discard	= VDC_SetPosition + 1,
	VDC_Flush	= VDC_Discard + 1,
	VDC_Snapshot	= VDC_Flush + 1,
	VDC_MountSnapshot	= VDC_Snapshot + 1,
	VDC_PrepareToFreeze	= VDC_MountSnapshot + 1
    };

enum VDWhence
    {	VDC_Beginning	= 0,
	VDC_Current	= VDC_Beginning + 1,
	VDC_End	= VDC_Current + 1
    };
struct VDC_Command
    {
    DWORD commandCode;
    DWORD size;
    DWORDLONG position;
    BYTE __RPC_FAR *buffer;
    };


extern RPC_IF_HANDLE __MIDL_itf_vdi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0000_v0_0_s_ifspec;

#ifndef __IClientVirtualDevice_INTERFACE_DEFINED__
#define __IClientVirtualDevice_INTERFACE_DEFINED__

/* interface IClientVirtualDevice */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40700424-0080-11d2-851f-00c04fc21759")
    IClientVirtualDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCommand( 
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteCommand( 
            /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
            /* [in] */ DWORD dwCompletionCode,
            /* [in] */ DWORD dwBytesTransferred,
            /* [in] */ DWORDLONG dwlPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCommand )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompleteCommand )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
            /* [in] */ DWORD dwCompletionCode,
            /* [in] */ DWORD dwBytesTransferred,
            /* [in] */ DWORDLONG dwlPosition);
        
        END_INTERFACE
    } IClientVirtualDeviceVtbl;

    interface IClientVirtualDevice
    {
        CONST_VTBL struct IClientVirtualDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDevice_GetCommand(This,dwTimeOut,ppCmd)	\
    (This)->lpVtbl -> GetCommand(This,dwTimeOut,ppCmd)

#define IClientVirtualDevice_CompleteCommand(This,pCmd,dwCompletionCode,dwBytesTransferred,dwlPosition)	\
    (This)->lpVtbl -> CompleteCommand(This,pCmd,dwCompletionCode,dwBytesTransferred,dwlPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDevice_GetCommand_Proxy( 
    IClientVirtualDevice __RPC_FAR * This,
    /* [in] */ DWORD dwTimeOut,
    /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd);


void __RPC_STUB IClientVirtualDevice_GetCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDevice_CompleteCommand_Proxy( 
    IClientVirtualDevice __RPC_FAR * This,
    /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
    /* [in] */ DWORD dwCompletionCode,
    /* [in] */ DWORD dwBytesTransferred,
    /* [in] */ DWORDLONG dwlPosition);


void __RPC_STUB IClientVirtualDevice_CompleteCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDevice_INTERFACE_DEFINED__ */


#ifndef __IClientVirtualDeviceSet_INTERFACE_DEFINED__
#define __IClientVirtualDeviceSet_INTERFACE_DEFINED__

/* interface IClientVirtualDeviceSet */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDeviceSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40700425-0080-11d2-851f-00c04fc21759")
    IClientVirtualDeviceSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenInSecondary( 
            /* [in] */ LPCWSTR lpSetName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferHandle( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBufferHandle( 
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondary )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferHandle )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBufferHandle )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);
        
        END_INTERFACE
    } IClientVirtualDeviceSetVtbl;

    interface IClientVirtualDeviceSet
    {
        CONST_VTBL struct IClientVirtualDeviceSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDeviceSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDeviceSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDeviceSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDeviceSet_Create(This,lpName,pCfg)	\
    (This)->lpVtbl -> Create(This,lpName,pCfg)

#define IClientVirtualDeviceSet_GetConfiguration(This,dwTimeOut,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,dwTimeOut,pCfg)

#define IClientVirtualDeviceSet_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IClientVirtualDeviceSet_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IClientVirtualDeviceSet_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IClientVirtualDeviceSet_OpenInSecondary(This,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondary(This,lpSetName)

#define IClientVirtualDeviceSet_GetBufferHandle(This,pBuffer,pBufferHandle)	\
    (This)->lpVtbl -> GetBufferHandle(This,pBuffer,pBufferHandle)

#define IClientVirtualDeviceSet_MapBufferHandle(This,dwBuffer,ppBuffer)	\
    (This)->lpVtbl -> MapBufferHandle(This,dwBuffer,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_Create_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_GetConfiguration_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ DWORD dwTimeOut,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_OpenDevice_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IClientVirtualDeviceSet_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_Close_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IClientVirtualDeviceSet_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_SignalAbort_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IClientVirtualDeviceSet_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_OpenInSecondary_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IClientVirtualDeviceSet_OpenInSecondary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_GetBufferHandle_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [out] */ DWORD __RPC_FAR *pBufferHandle);


void __RPC_STUB IClientVirtualDeviceSet_GetBufferHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_MapBufferHandle_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ DWORD dwBuffer,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IClientVirtualDeviceSet_MapBufferHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDeviceSet_INTERFACE_DEFINED__ */


#ifndef __IClientVirtualDeviceSet2_INTERFACE_DEFINED__
#define __IClientVirtualDeviceSet2_INTERFACE_DEFINED__

/* interface IClientVirtualDeviceSet2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDeviceSet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0e6eb07-7a62-11d2-8573-00c04fc21759")
    IClientVirtualDeviceSet2 : public IClientVirtualDeviceSet
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEx( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenInSecondaryEx( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceSet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondary )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferHandle )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBufferHandle )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEx )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondaryEx )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName);
        
        END_INTERFACE
    } IClientVirtualDeviceSet2Vtbl;

    interface IClientVirtualDeviceSet2
    {
        CONST_VTBL struct IClientVirtualDeviceSet2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDeviceSet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDeviceSet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDeviceSet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDeviceSet2_Create(This,lpName,pCfg)	\
    (This)->lpVtbl -> Create(This,lpName,pCfg)

#define IClientVirtualDeviceSet2_GetConfiguration(This,dwTimeOut,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,dwTimeOut,pCfg)

#define IClientVirtualDeviceSet2_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IClientVirtualDeviceSet2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IClientVirtualDeviceSet2_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IClientVirtualDeviceSet2_OpenInSecondary(This,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondary(This,lpSetName)

#define IClientVirtualDeviceSet2_GetBufferHandle(This,pBuffer,pBufferHandle)	\
    (This)->lpVtbl -> GetBufferHandle(This,pBuffer,pBufferHandle)

#define IClientVirtualDeviceSet2_MapBufferHandle(This,dwBuffer,ppBuffer)	\
    (This)->lpVtbl -> MapBufferHandle(This,dwBuffer,ppBuffer)


#define IClientVirtualDeviceSet2_CreateEx(This,lpInstanceName,lpName,pCfg)	\
    (This)->lpVtbl -> CreateEx(This,lpInstanceName,lpName,pCfg)

#define IClientVirtualDeviceSet2_OpenInSecondaryEx(This,lpInstanceName,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondaryEx(This,lpInstanceName,lpSetName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet2_CreateEx_Proxy( 
    IClientVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpName,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet2_CreateEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet2_OpenInSecondaryEx_Proxy( 
    IClientVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IClientVirtualDeviceSet2_OpenInSecondaryEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDeviceSet2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdi_0011 */
/* [local] */ 

struct VDS_Command
    {
    DWORD commandCode;
    DWORD size;
    DWORDLONG inPosition;
    DWORDLONG outPosition;
    BYTE __RPC_FAR *buffer;
    BYTE __RPC_FAR *completionRoutine;
    BYTE __RPC_FAR *completionContext;
    DWORD completionCode;
    DWORD bytesTransferred;
    };


extern RPC_IF_HANDLE __MIDL_itf_vdi_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0011_v0_0_s_ifspec;

#ifndef __IServerVirtualDevice_INTERFACE_DEFINED__
#define __IServerVirtualDevice_INTERFACE_DEFINED__

/* interface IServerVirtualDevice */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5e7a131-a7bd-11d1-84c2-00c04fc21759")
    IServerVirtualDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendCommand( 
            /* [in] */ struct VDS_Command __RPC_FAR *pCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseDevice( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendCommand )( 
            IServerVirtualDevice __RPC_FAR * This,
            /* [in] */ struct VDS_Command __RPC_FAR *pCmd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseDevice )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceVtbl;

    interface IServerVirtualDevice
    {
        CONST_VTBL struct IServerVirtualDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDevice_SendCommand(This,pCmd)	\
    (This)->lpVtbl -> SendCommand(This,pCmd)

#define IServerVirtualDevice_CloseDevice(This)	\
    (This)->lpVtbl -> CloseDevice(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDevice_SendCommand_Proxy( 
    IServerVirtualDevice __RPC_FAR * This,
    /* [in] */ struct VDS_Command __RPC_FAR *pCmd);


void __RPC_STUB IServerVirtualDevice_SendCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDevice_CloseDevice_Proxy( 
    IServerVirtualDevice __RPC_FAR * This);


void __RPC_STUB IServerVirtualDevice_CloseDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDevice_INTERFACE_DEFINED__ */


#ifndef __IServerVirtualDeviceSet_INTERFACE_DEFINED__
#define __IServerVirtualDeviceSet_INTERFACE_DEFINED__

/* interface IServerVirtualDeviceSet */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDeviceSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5e7a132-a7bd-11d1-84c2-00c04fc21759")
    IServerVirtualDeviceSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ LPCWSTR lpName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConfiguration( 
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteCompletionAgent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSharedBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConfiguration )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteCompletionAgent )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSharedBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceSetVtbl;

    interface IServerVirtualDeviceSet
    {
        CONST_VTBL struct IServerVirtualDeviceSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDeviceSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDeviceSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDeviceSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDeviceSet_Open(This,lpName)	\
    (This)->lpVtbl -> Open(This,lpName)

#define IServerVirtualDeviceSet_GetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet_SetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> SetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet_ExecuteCompletionAgent(This)	\
    (This)->lpVtbl -> ExecuteCompletionAgent(This)

#define IServerVirtualDeviceSet_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IServerVirtualDeviceSet_AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)	\
    (This)->lpVtbl -> AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)

#define IServerVirtualDeviceSet_FreeBuffer(This,pBuffer,dwSize)	\
    (This)->lpVtbl -> FreeBuffer(This,pBuffer,dwSize)

#define IServerVirtualDeviceSet_IsSharedBuffer(This,pBuffer)	\
    (This)->lpVtbl -> IsSharedBuffer(This,pBuffer)

#define IServerVirtualDeviceSet_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IServerVirtualDeviceSet_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_Open_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName);


void __RPC_STUB IServerVirtualDeviceSet_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_GetConfiguration_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_SetConfiguration_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet_SetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_ExecuteCompletionAgent_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_ExecuteCompletionAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_OpenDevice_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IServerVirtualDeviceSet_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_AllocateBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment);


void __RPC_STUB IServerVirtualDeviceSet_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_FreeBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IServerVirtualDeviceSet_FreeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_IsSharedBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer);


void __RPC_STUB IServerVirtualDeviceSet_IsSharedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_SignalAbort_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_Close_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDeviceSet_INTERFACE_DEFINED__ */


#ifndef __IServerVirtualDeviceSet2_INTERFACE_DEFINED__
#define __IServerVirtualDeviceSet2_INTERFACE_DEFINED__

/* interface IServerVirtualDeviceSet2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDeviceSet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AECBD0D6-24C6-11d3-85B7-00C04FC21759")
    IServerVirtualDeviceSet2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginConfiguration( 
            /* [in] */ DWORD dwFeatures,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwBlockSize,
            /* [in] */ DWORD dwMaxTransferSize,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndConfiguration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestBuffers( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAvailableBuffers( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [out] */ DWORD __RPC_FAR *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteCompletionAgent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSharedBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceSet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwFeatures,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwBlockSize,
            /* [in] */ DWORD dwMaxTransferSize,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestBuffers )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryAvailableBuffers )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [out] */ DWORD __RPC_FAR *pCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteCompletionAgent )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSharedBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceSet2Vtbl;

    interface IServerVirtualDeviceSet2
    {
        CONST_VTBL struct IServerVirtualDeviceSet2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDeviceSet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDeviceSet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDeviceSet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDeviceSet2_Open(This,lpInstanceName,lpSetName)	\
    (This)->lpVtbl -> Open(This,lpInstanceName,lpSetName)

#define IServerVirtualDeviceSet2_GetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet2_BeginConfiguration(This,dwFeatures,dwAlignment,dwBlockSize,dwMaxTransferSize,dwTimeout)	\
    (This)->lpVtbl -> BeginConfiguration(This,dwFeatures,dwAlignment,dwBlockSize,dwMaxTransferSize,dwTimeout)

#define IServerVirtualDeviceSet2_EndConfiguration(This)	\
    (This)->lpVtbl -> EndConfiguration(This)

#define IServerVirtualDeviceSet2_RequestBuffers(This,dwSize,dwAlignment,dwCount)	\
    (This)->lpVtbl -> RequestBuffers(This,dwSize,dwAlignment,dwCount)

#define IServerVirtualDeviceSet2_QueryAvailableBuffers(This,dwSize,dwAlignment,pCount)	\
    (This)->lpVtbl -> QueryAvailableBuffers(This,dwSize,dwAlignment,pCount)

#define IServerVirtualDeviceSet2_ExecuteCompletionAgent(This)	\
    (This)->lpVtbl -> ExecuteCompletionAgent(This)

#define IServerVirtualDeviceSet2_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IServerVirtualDeviceSet2_AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)	\
    (This)->lpVtbl -> AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)

#define IServerVirtualDeviceSet2_FreeBuffer(This,pBuffer,dwSize)	\
    (This)->lpVtbl -> FreeBuffer(This,pBuffer,dwSize)

#define IServerVirtualDeviceSet2_IsSharedBuffer(This,pBuffer)	\
    (This)->lpVtbl -> IsSharedBuffer(This,pBuffer)

#define IServerVirtualDeviceSet2_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IServerVirtualDeviceSet2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_Open_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IServerVirtualDeviceSet2_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_GetConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet2_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_BeginConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwFeatures,
    /* [in] */ DWORD dwAlignment,
    /* [in] */ DWORD dwBlockSize,
    /* [in] */ DWORD dwMaxTransferSize,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IServerVirtualDeviceSet2_BeginConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_EndConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_EndConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_RequestBuffers_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment,
    /* [in] */ DWORD dwCount);


void __RPC_STUB IServerVirtualDeviceSet2_RequestBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_QueryAvailableBuffers_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment,
    /* [out] */ DWORD __RPC_FAR *pCount);


void __RPC_STUB IServerVirtualDeviceSet2_QueryAvailableBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_ExecuteCompletionAgent_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_ExecuteCompletionAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_OpenDevice_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IServerVirtualDeviceSet2_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_AllocateBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment);


void __RPC_STUB IServerVirtualDeviceSet2_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_FreeBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IServerVirtualDeviceSet2_FreeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_IsSharedBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer);


void __RPC_STUB IServerVirtualDeviceSet2_IsSharedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_SignalAbort_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_Close_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDeviceSet2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdi_0014 */
/* [local] */ 

#define CLSID_MSSQL_ClientVirtualDeviceSet IID_IClientVirtualDeviceSet
#define CLSID_MSSQL_ServerVirtualDeviceSet IID_IServerVirtualDeviceSet

#pragma pack(pop, _vdi_h_)


extern RPC_IF_HANDLE __MIDL_itf_vdi_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0014_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqlwriter\globals.cpp ===
//
// globals.cpp : define all the global vars
//

#define INITGUID

#include "guiddef.h"
#include "sqlwrtguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\sqlwriter\sqlwriter.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module sqlwriter.cpp | Implementation of Writer
    @end

Author:

    Brian Berkowitz  [brianb]  04/17/2000

TBD:


Revision History:

    Name        Date        Comments
    brianb      04/17/2000  created
    brianb      04/20/2000  integrated with coordinator
    brainb      05/05/2000  add OnIdentify support
    mikejohn    06/01/2000  fix minor but confusing typos in trace messages
    mikejohn    09/19/2000  176860: Add the missing calling convention specifiers

--*/
#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "vs_idl.hxx"
#include <vs_hash.hxx>
#include <base64coder.h>

#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "allerror.h"
#include "sqlwrtguid.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQWWRTRC"
//
////////////////////////////////////////////////////////////////////////

static LPCWSTR x_wszSqlServerWriter = L"SqlServerWriter";

static LPCWSTR s_wszWriterName = L"MSDEWriter";

HRESULT STDMETHODCALLTYPE CSqlWriter::Initialize()
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::Initialize");

    try
        {
        InitSQLEnvironment();

        ft.hr = CVssWriter::Initialize
            (
            WRITERID_SqlWriter,
            s_wszWriterName,
            VSS_UT_SYSTEMSERVICE,
            VSS_ST_TRANSACTEDDB,
            VSS_APP_BACK_END,
            60000
            );

        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_SQLWRITER,
                E_UNEXPECTED,
                L"Failed to initialize the Sql writer.  hr = 0x%08lx",
                ft.hr
                );

        ft.hr = Subscribe();
        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_SQLWRITER,
                E_UNEXPECTED,
                L"Subscribing the Sql server writer failed. hr = %0x08lx",
                ft.hr
                );
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

HRESULT STDMETHODCALLTYPE CSqlWriter::Uninitialize()
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::Uninitialize");

    return Unsubscribe();
    }

bool STDMETHODCALLTYPE CSqlWriter::OnPrepareBackup
    (
    IN IVssWriterComponents *pComponents
    )
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::OnPrepareBackup");

    LPWSTR *rgwszDB = NULL;
    UINT cwszDB = 0;
    LPWSTR *rgwszInstances = NULL;
    UINT cwszInstances = 0;

    bool bSuccess = true;

    try
        {
        // clear existing arrays
        if (m_rgwszDatabases)
            {
            for(UINT i = 0; i < m_cDatabases; i++)
                {
                delete m_rgwszDatabases[i];
                delete m_rgwszInstances[i];
                }

            delete m_rgwszDatabases;
            delete m_rgwszInstances;
            m_rgwszDatabases = NULL;
            m_rgwszInstances = NULL;
            m_cDatabases = 0;
            }

        m_bComponentsSelected = AreComponentsSelected();
        if (m_bComponentsSelected)
            {
            UINT cComponents;

            ft.hr = pComponents->GetComponentCount(&cComponents);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterComponents::GetComponentCount");

            rgwszDB = new LPWSTR[cComponents];
            rgwszInstances = new LPWSTR[cComponents];
            if (rgwszDB == NULL || rgwszInstances == NULL)
                ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"out of memory");


            for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
                {
                CComPtr<IVssComponent> pComponent;
                ft.hr = pComponents->GetComponent(iComponent, &pComponent);
                ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterComponents::GetComponent");

                CComBSTR bstrLogicalPath;
                CComBSTR bstrDBName;

                ft.hr = pComponent->GetLogicalPath(&bstrLogicalPath);
                ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetLogicalPath");

                ft.hr = pComponent->GetComponentName(&bstrDBName);
                ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetComponentName");

                LPWSTR wszDB = new WCHAR[wcslen(bstrDBName) + 1];
                if (wszDB == NULL)
                    ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"out of memory");

                wcscpy(wszDB, bstrDBName);
                rgwszDB[cwszDB++] = wszDB;

                LPWSTR wszInstance = new WCHAR[wcslen(bstrLogicalPath) + 1];
                if (wszInstance == NULL)
                    ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"out of memory");

                wcscpy(wszInstance, bstrLogicalPath);
                rgwszInstances[cwszInstances++] = wszInstance;
                }
            }

        m_rgwszDatabases = rgwszDB;
        m_rgwszInstances = rgwszInstances;
        m_cDatabases = cwszDB;
        }
    catch(...)
        {
        for(UINT iwsz = 0; iwsz < cwszDB; iwsz++)
            delete rgwszDB[iwsz];

        delete rgwszDB;

        for(UINT iwsz = 0; iwsz < cwszInstances; iwsz++)
            delete rgwszInstances[iwsz];

        delete rgwszInstances;
        bSuccess = false;
        }

    return bSuccess;
    }









bool STDMETHODCALLTYPE CSqlWriter::OnPrepareSnapshot()
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::OnPrepareSnapshot");

    try
        {
        BS_ASSERT(!m_fFrozen);

        // delete sql snapshot element if it exists
        delete m_pSqlSnapshot;
        m_pSqlSnapshot = NULL;

        m_pSqlSnapshot = CreateSqlSnapshot();
        if (m_pSqlSnapshot == NULL)
            ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"Failed to allocate CSqlSnapshot object.");

        ft.hr = m_pSqlSnapshot->Prepare(this);
        }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    return !ft.HrFailed();
    }



bool STDMETHODCALLTYPE CSqlWriter::OnFreeze()
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::OnFreeze");


    try
        {
        BS_ASSERT(!m_fFrozen);
        ft.hr = m_pSqlSnapshot->Freeze();
        if (!ft.HrFailed())
            m_fFrozen = true;
        }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    return !ft.HrFailed();
    }


bool STDMETHODCALLTYPE CSqlWriter::OnThaw()
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::OnThaw");


    try
        {
        if (m_fFrozen)
            {
            m_fFrozen = false;
            ft.hr = m_pSqlSnapshot->Thaw();
            }
        }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    return !ft.HrFailed();
    }


bool STDMETHODCALLTYPE CSqlWriter::OnPostSnapshot
    (
    IN IVssWriterComponents *pWriter
    )
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"STDMETHODCALLTYPE CSqlWriter::OnPostSnapshot");

    // map of databases that were actually successfully frozen
    CVssSimpleMap<VSS_PWSZ, FrozenDatabaseInfo *> mapDatabases;

    FrozenDatabaseInfo fInfo;
    WCHAR *wsz = NULL;
    FrozenDatabaseInfo *pfInfo = NULL;
    try
        {
        ft.hr = m_pSqlSnapshot->GetFirstDatabase(&fInfo);
        while(ft.hr != DB_S_ENDOFROWSET)
            {
            // check for error code
            if (ft.HrFailed())
                ft.Throw
                    (
                    VSSDBG_SQLWRITER,
                    E_UNEXPECTED,
                    L"Enumerating database servers failed.  hr = 0x%08lx",
                    ft.hr
                    );


            wsz = (WCHAR *) new WCHAR[wcslen(fInfo.serverName) + wcslen(fInfo.databaseName) + 2];
            pfInfo = new FrozenDatabaseInfo;
            if (wsz ==  NULL || pfInfo == NULL)
                ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"Cannot allocate frozen info mapping.");

            // name is server\database
            wcscpy(wsz, fInfo.serverName);
            wcscat(wsz, L"\\");
            wcscat(wsz, fInfo.databaseName);
            memcpy(pfInfo, &fInfo, sizeof(fInfo));
            if (!mapDatabases.Add(wsz, pfInfo))
                ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"Cannot allocate frozen info mapping.");

            // ownership is transfered to the map
            wsz = NULL;
            pfInfo = NULL;

            ft.hr = m_pSqlSnapshot->GetNextDatabase(&fInfo);
            }


        UINT cComponents;
        ft.hr = pWriter->GetComponentCount(&cComponents);
        ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterComponents::GetComponentCount");

        // loop through components supplied by the user.
        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            WCHAR wszName[MAX_SERVERNAME + MAX_DBNAME + 1];
            CComPtr<IVssComponent> pComponent;

            ft.hr = pWriter->GetComponent(iComponent, &pComponent);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterComponents::GetComponent");

            VSS_COMPONENT_TYPE ct;
            ft.hr = pComponent->GetComponentType(&ct);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetComponentType");

            if (ct != VSS_CT_DATABASE)
                ft.Throw(VSSDBG_SQLWRITER, VSS_E_WRITERERROR_NONRETRYABLE, L"requesting a non-database component");

            CComBSTR bstrLogicalPath;
            ft.hr = pComponent->GetLogicalPath(&bstrLogicalPath);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetLogicalPath");

            CComBSTR bstrComponentName;
            ft.hr = pComponent->GetComponentName(&bstrComponentName);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterCokmponents::GetComponentName");

            wcscpy(wszName, bstrLogicalPath);
            wcscat(wszName, L"\\");
            wcscat(wszName, bstrComponentName);
            FrozenDatabaseInfo *pfInfoFound = mapDatabases.Lookup(wszName);
            if (pfInfoFound == NULL)
                ft.Throw(VSSDBG_SQLWRITER, VSS_E_WRITERERROR_RETRYABLE, L"database was not successfully snapshotted");

            Base64Coder coder;
            coder.Encode(pfInfoFound->pMetaData, pfInfoFound->metaDataSize);
            ft.hr = pComponent->SetBackupMetadata(coder.EncodedMessage());
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::SetBackupMetadata");
            }
        }
    VSS_STANDARD_CATCH(ft)

    int cBuckets = mapDatabases.GetSize();
    for(int iBucket = 0; iBucket < cBuckets; iBucket++)
        {
        delete mapDatabases.GetKeyAt(iBucket);
        delete mapDatabases.GetValueAt(iBucket);
        }

    delete wsz;
    delete pfInfo;

    delete m_pSqlSnapshot;
    m_pSqlSnapshot = NULL;

    TranslateWriterError(ft.hr);

    return !ft.HrFailed();
    }



bool STDMETHODCALLTYPE CSqlWriter::OnAbort()
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::OnAbort");


    try
        {
        if (m_fFrozen)
            {
            m_fFrozen = false;
            ft.hr = m_pSqlSnapshot->Thaw();
            }

        delete m_pSqlSnapshot;
        m_pSqlSnapshot = NULL;
        }
    VSS_STANDARD_CATCH(ft)

    return !ft.HrFailed();
    }

bool CSqlWriter::IsPathInSnapshot(const WCHAR *wszPath) throw()
    {
    return IsPathAffected(wszPath);
    }

// returns whether backup supports component based backup/restore
bool CSqlWriter::IsComponentBased()
    {
    return m_bComponentsSelected;
    }

// enumerate selected databases for a given instance,  pNextIndex indicates the
// next instance to look for.  0 indicates find first instance
LPCWSTR CSqlWriter::EnumerateSelectedDatabases(LPCWSTR wszInstanceName, UINT *pNextIndex)
    {
    // should only be called for component based backups
    BS_ASSERT(m_bComponentsSelected);
    BS_ASSERT(pNextIndex);
    if (!m_bComponentsSelected)
        return NULL;

    // starting point in array
    UINT iwsz = *pNextIndex;

    // loop until a matching instance is found
    for(iwsz; iwsz < m_cDatabases; iwsz++)
        {
        if (wcscmp(wszInstanceName, m_rgwszInstances[iwsz]) == 0)
            break;
        }

    if (iwsz >= m_cDatabases)
        {
        // no more matching entries
        *pNextIndex = m_cDatabases;
        return NULL;
        }

    // seach should start at next database entry
    *pNextIndex = iwsz + 1;

    // return current database name
    return m_rgwszDatabases[iwsz];
    }



// handle request for WRITER_METADATA
// implements CVssWriter::OnIdentify
bool STDMETHODCALLTYPE CSqlWriter::OnIdentify(IVssCreateWriterMetadata *pMetadata)
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::OnIdentify");

    ServerInfo server;
    DatabaseInfo database;
    DatabaseFileInfo file;

    // create enumerator
    CSqlEnumerator *pEnumServers = NULL;
    CSqlEnumerator *pEnumDatabases = NULL;
    CSqlEnumerator *pEnumFiles = NULL;
    try
        {
                ft.hr = pMetadata->SetRestoreMethod
                                                                (
                                                                VSS_RME_RESTORE_IF_CAN_REPLACE,
                                                                NULL,
                                                                NULL,
                                                                VSS_WRE_ALWAYS,
                                                                false
                                                                );

        ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssCreateWriterMetadata::SetRestoreMethod");

        pEnumServers = CreateSqlEnumerator();
        if (pEnumServers == NULL)
            ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

        // find first server
        ft.hr = pEnumServers->FirstServer(&server);
        while(ft.hr != DB_S_ENDOFROWSET)
            {
            // check for error code
            if (ft.HrFailed())
                ft.Throw
                    (
                    VSSDBG_SQLWRITER,
                    E_UNEXPECTED,
                    L"Enumerating database servers failed.  hr = 0x%08lx",
                    ft.hr
                    );

            // only look at server if it is online
            if (server.isOnline)
                {
                // recreate enumerator for databases
                BS_ASSERT(pEnumDatabases == NULL);
                pEnumDatabases = CreateSqlEnumerator();
                if (pEnumDatabases == NULL)
                    ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

                // find first database
                ft.hr = pEnumDatabases->FirstDatabase(server.name, &database);


                while(ft.hr != DB_S_ENDOFROWSET)
                    {
                    // check for error
                    if (ft.HrFailed())
                        ft.Throw
                            (
                            VSSDBG_SQLWRITER,
                            E_UNEXPECTED,
                            L"Enumerating databases failed.  hr = 0x%08lx",
                            ft.hr
                            );

                    // only include database if it supports Freeze and
                    // don't include the tempdb
                    if (wcscmp(database.name, L"tempdb") != 0 &&
                        database.supportsFreeze)
                        {
                        // add database component
                        ft.hr = pMetadata->AddComponent
                                    (
                                    VSS_CT_DATABASE,        // component type
                                    server.name,            // logical path
                                    database.name,          // component name
                                    NULL,                   // caption
                                    NULL,                   // pbIcon
                                    0,                      // cbIcon
                                    false,                  // bRestoreMetadata
                                    false,                  // bNotifyOnBackupComplete
                                    true                    // bSelectable
                                    );

                        if (ft.HrFailed())
                            ft.Throw
                                (
                                VSSDBG_SQLWRITER,
                                E_UNEXPECTED,
                                L"IVssCreateWriterMetadata::AddComponent failed.  hr = 0x%08lx",
                                ft.hr
                                );

                        // recreate enumerator for files
                        BS_ASSERT(pEnumFiles == NULL);
                        pEnumFiles = CreateSqlEnumerator();
                        if (pEnumFiles == NULL)
                            ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");


                        // findfirst database file
                        ft.hr = pEnumFiles->FirstFile(server.name, database.name, &file);
                        while(ft.hr != DB_S_ENDOFROWSET)
                            {
                            // check for error
                            if (ft.HrFailed())
                                ft.Throw
                                    (
                                    VSSDBG_SQLWRITER,
                                    E_UNEXPECTED,
                                    L"Enumerating database files failed.  hr = 0x%08lx",
                                    ft.hr
                                    );

                            // split file name into separate path
                            // and filename components.  Path is everything
                            // before the last backslash.
                            WCHAR logicalPath[MAX_PATH];
                            WCHAR *pFileName = file.name + wcslen(file.name);
                            while(--pFileName > file.name)
                                {
                                if (*pFileName == '\\')
                                    break;
                                }

                            // if no backslash, then there is no path
                            if (pFileName == file.name)
                                logicalPath[0] = '\0';
                            else
                                {
                                // extract path
                                size_t cwc = wcslen(file.name) - wcslen(pFileName);
                                memcpy(logicalPath, file.name, cwc*sizeof(WCHAR));
                                logicalPath[cwc] = L'\0';
                                pFileName++;
                                }


                            if (file.isLogFile)
                                // log file
                                ft.hr = pMetadata->AddDatabaseLogFiles
                                                (
                                                server.name,
                                                database.name,
                                                logicalPath,
                                                pFileName
                                                );
                            else
                                // physical database file
                                ft.hr = pMetadata->AddDatabaseFiles
                                                (
                                                server.name,
                                                database.name,
                                                logicalPath,
                                                pFileName
                                                );

                            // continue at next file
                            ft.hr = pEnumFiles->NextFile(&file);
                            }

                        delete pEnumFiles;
                        pEnumFiles = NULL;
                        }

                    // continue at next database
                    ft.hr = pEnumDatabases->NextDatabase(&database);
                    }

                delete pEnumDatabases;
                pEnumDatabases = NULL;
                }

            // continue at next server
            ft.hr = pEnumServers->NextServer(&server);
            }
        }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    delete pEnumServers;
    delete pEnumDatabases;
    delete pEnumFiles;

    return ft.HrFailed() ? false : true;
    }

// translate a sql writer error code into a writer error
void CSqlWriter::TranslateWriterError(HRESULT hr)
    {
    if (SUCCEEDED(hr))
        return;

    switch(hr)
        {
        default:
            SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            break;

        case S_OK:
            break;

        case E_OUTOFMEMORY:
        case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
        case HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES):
        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES):
            SetWriterFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            break;

        case HRESULT_FROM_WIN32(E_SQLLIB_TORN_DB):
            SetWriterFailure(VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT);
            break;
        }
    }


bool STDMETHODCALLTYPE CSqlWriter::OnPreRestore
    (
    IN IVssWriterComponents *pWriter
    )
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::OnPreRestore");

    try
        {
        // delete sql restore element if it exists
        delete m_pSqlRestore;
        m_pSqlRestore = NULL;


        UINT cComponents;
        ft.hr = pWriter->GetComponentCount(&cComponents);
        ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterComponents::GetComponentCount");

        if (cComponents == 0)
            return true;

        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;
            ft.hr = pWriter->GetComponent(iComponent, &pComponent);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterComponents::GetComponent");

            bool bSelectedForRestore;
            ft.hr = pComponent->IsSelectedForRestore(&bSelectedForRestore);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::IsSelectedForRestore");

            if (!bSelectedForRestore)
                continue;

            if (m_pSqlRestore == NULL)
                {
                m_pSqlRestore = CreateSqlRestore();
                if (m_pSqlRestore == NULL)
                    ft.Throw(VSSDBG_SQLWRITER, E_OUTOFMEMORY, L"cannot allocate CSqlRestore object");
                }


            VSS_COMPONENT_TYPE ct;
            ft.hr = pComponent->GetComponentType(&ct);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetComponentType");

            if (ct != VSS_CT_DATABASE)
                ft.Throw(VSSDBG_SQLWRITER, VSS_E_WRITERERROR_NONRETRYABLE, L"requesting a non-database component");

            CComBSTR bstrLogicalPath;
            ft.hr = pComponent->GetLogicalPath(&bstrLogicalPath);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetLogicalPath");

            CComBSTR bstrComponentName;
            ft.hr = pComponent->GetComponentName(&bstrComponentName);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterCokmponents::GetComponentName");
            ft.hr = m_pSqlRestore->PrepareToRestore(bstrLogicalPath, bstrComponentName);
            if (ft.HrFailed())
                {
                WCHAR wsz[128];
                swprintf(wsz, L"CSqlRestor::PrepareToRestore failed with HRESULT = 0x%08lx", ft.hr);
                ft.hr = pComponent->SetPreRestoreFailureMsg(wsz);
                ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::SetPreRestoreFailureMsg");
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    return true;
    }


bool STDMETHODCALLTYPE CSqlWriter::OnPostRestore
    (
    IN IVssWriterComponents *pWriter
    )
    {
    CVssFunctionTracer ft(VSSDBG_SQLWRITER, L"CSqlWriter::OnPostRestore");
    try
        {
        if (m_pSqlRestore == NULL)
            return true;

        UINT cComponents;
        ft.hr = pWriter->GetComponentCount(&cComponents);
        ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterComponents::GetComponentCount");

        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            CComPtr<IVssComponent> pComponent;
            ft.hr = pWriter->GetComponent(iComponent, &pComponent);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterComponents::GetComponent");

            bool bSelectedForRestore;
            ft.hr = pComponent->IsSelectedForRestore(&bSelectedForRestore);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::IsSelectedForRestore");

            if (!bSelectedForRestore)
                continue;


            VSS_COMPONENT_TYPE ct;
            ft.hr = pComponent->GetComponentType(&ct);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetComponentType");

            if (ct != VSS_CT_DATABASE)
                ft.Throw(VSSDBG_SQLWRITER, VSS_E_WRITERERROR_NONRETRYABLE, L"requesting a non-database component");

            CComBSTR bstrLogicalPath;
            ft.hr = pComponent->GetLogicalPath(&bstrLogicalPath);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetLogicalPath");

            CComBSTR bstrComponentName;
            ft.hr = pComponent->GetComponentName(&bstrComponentName);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssWriterCokmponents::GetComponentName");

            CComBSTR bstrPreRestoreFailure;
            ft.hr = pComponent->GetPreRestoreFailureMsg(&bstrPreRestoreFailure);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetPreRestoreFailureMsg");

            // if we got an error during prerestore don't do a post restore
            if (bstrPreRestoreFailure)
                continue;

            bool bAdditionalRestores;
            ft.hr = pComponent->GetAdditionalRestores(&bAdditionalRestores);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetAdditionalRestores");


            CComBSTR bstrMetadata;
            ft.hr = pComponent->GetBackupMetadata(&bstrMetadata);
            ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::GetBackupMetadata");
            Base64Coder coder;
            coder.Decode(bstrMetadata);
            BYTE *pbVal = coder.DecodedMessage();
            ft.hr = m_pSqlRestore->FinalizeRestore
                                        (
                                        bstrLogicalPath,
                                        bstrComponentName,
                                        bAdditionalRestores,
                                        pbVal + sizeof(UINT),
                                        *(UINT *) pbVal
                                        );

            if (ft.HrFailed())
                {
                WCHAR wsz[128];
                swprintf(wsz, L"CSqlRestore::FinalizeRestore failed with HRESULT = 0x%08lx", ft.hr);
                ft.hr = pComponent->SetPostRestoreFailureMsg(wsz);
                ft.CheckForErrorInternal(VSSDBG_SQLWRITER, L"IVssComponent::SetPreRestoreFailureMsg");
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    return true;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\stswriter\stssites.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module stssites.cxx | Implementation of CSTSSites
    @end

Author:

    Brian Berkowitz  [brianb]  10/15/2001

Revision History:

    Name        Date        Comments
    brianb     10/15/2001  Created

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "vs_reg.hxx"


#include "iadmw.h"
#include "iiscnfg.h"
#include "mdmsg.h"


#include "stssites.hxx"
#include "vswriter.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "STSSITEC"
//
////////////////////////////////////////////////////////////////////////


// toplevel key for enumeration of sites and their DSNs
static LPCWSTR x_STSSECUREKEY = L"Software\\Microsoft\\Shared Tools\\Web Server Extensions\\Secure";

// bottom level keys for sharepoint sites
static LPCWSTR x_STSRegistryKey = L"/LM/W3SVC/";
static LPCWSTR x_STSRegistryKeyFormat = L"/LM/W3SVC/%d:";
static LPCWSTR x_STSMetabaseKey = L"/LM/W3SVC";
static LPCWSTR x_STSMetabaseKeyFormat= L"/LM/W3SVC/%d";
// DSN value
static LPCWSTR x_ValueDSN = L"DSN";

// version key for Sharepoint Team Services 5.0"
static LPCWSTR x_STSVERSIONKEY = L"Software\\Microsoft\\Shared Tools\\Web Server Extensions\\5.0";

// key to Shell Folders properties.  Used to get Applications Data directory"
static LPCWSTR x_ShellFoldersKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";

// value of applications data directory under Shell folders key
static LPCWSTR x_AppDataValue = L"Common AppData";

// subfolder under Applications data directory for STS data"
static LPCWSTR x_STSSubfolder = L"\\Microsoft\\Web Server Extensions\\50";

// constructor
CSTSSites::CSTSSites() :
    m_cSites(0),
    m_rgSiteIds(NULL),
    m_rootKey(KEY_READ|KEY_ENUMERATE_SUB_KEYS),
    m_hQuotaLock(INVALID_HANDLE_VALUE),
    m_wszAppDataFolder(NULL)
    {
    }

// destructor
CSTSSites::~CSTSSites()
    {
    delete m_rgSiteIds;
    UnlockSites();
    UnlockQuotaDatabase();
    CoTaskMemFree(m_wszAppDataFolder);
    }


// initialize the array of site ids.  Returns FALSE if there are no sites
bool CSTSSites::Initialize()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::Initialize");

    if (!m_rootKey.Open(HKEY_LOCAL_MACHINE, x_STSSECUREKEY))
        return false;

    CVssRegistryKeyIterator iter;
    iter.Attach(m_rootKey);
    try
        {
        m_cSites = iter.GetSubkeysCount();
        m_rgSiteIds = new DWORD[m_cSites];
        if (m_rgSiteIds == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"can't allocate site id array");

        for(UINT iSite = 0; iSite < m_cSites; iSite++)
            {
            DWORD siteId;

            BS_ASSERT(!iter.IsEOF());
            LPCWSTR wszSiteName = iter.GetCurrentKeyName();
            BS_ASSERT(wcslen(wszSiteName) > wcslen(x_STSRegistryKey));
            BS_ASSERT(wcsncmp(wszSiteName, x_STSRegistryKey, wcslen(x_STSRegistryKey)) == 0);
#ifdef DEBUG
            DWORD cFields =
#endif
            swscanf(wszSiteName, x_STSRegistryKeyFormat, &siteId);
            BS_ASSERT(cFields == 1);
            m_rgSiteIds[iSite] = siteId;
            iter.MoveNext();
            }

        }
    catch(...)
        {
        iter.Detach();
        throw;
        }

    iter.Detach();
    return true;
    }

// return the id of a specific site
VSS_PWSZ CSTSSites::GetSiteDSN(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteDSN");

    CVssRegistryKey key(KEY_READ);
    BS_ASSERT(iSite < m_cSites);
    DWORD siteId = m_rgSiteIds[iSite];
    WCHAR buf[MAX_PATH];
    swprintf(buf, x_STSRegistryKeyFormat, siteId);
    if (!key.Open(m_rootKey.GetHandle(), buf))
        ft.Throw(VSSDBG_STSWRITER, E_UNEXPECTED, L"missing registry key");

    VSS_PWSZ pwszDSN = NULL;
    key.GetValue(x_ValueDSN, pwszDSN);
    BS_ASSERT(pwszDSN);
    
    return pwszDSN;
    }

// determine if this is the correct sharepoint version
bool CSTSSites::ValidateSharepointVersion()
    {
    CVssRegistryKey key;

    return key.Open(HKEY_LOCAL_MACHINE, x_STSVERSIONKEY);
    }


void CSTSSites::SetupMetabaseInterface()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::SetupMetabaseInterface");

    if (!m_pMetabase)
        {
        ft.hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, IID_IMSAdminBase, (void **) &m_pMetabase);
        ft.CheckForError(VSSDBG_STSWRITER, L"CoCreateInstance MSAdminBase");
        }
    }

// return pointer to site content root.  The return value should be
// freed using CoTaskMemFree by the caller
VSS_PWSZ CSTSSites::GetSiteRoot(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteRoles");
    METADATA_HANDLE h;
    static const DWORD x_MDTimeout = 2000;

    BS_ASSERT(iSite < m_cSites);
    DWORD siteId = m_rgSiteIds[iSite];
    WCHAR buf[METADATA_MAX_NAME_LEN];

    SetupMetabaseInterface();

    swprintf(buf, x_STSMetabaseKeyFormat, siteId);

    ft.hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, buf, METADATA_PERMISSION_READ, x_MDTimeout, &h);
    ft.CheckForError(VSSDBG_STSWRITER, L"IMSAdminBase::OpenKey");
    CVssAutoMetabaseHandle MetaHandle(m_pMetabase, h);
    METADATA_RECORD rec;
    DWORD dwBufLen = METADATA_MAX_NAME_LEN;
    PBYTE pbBuffer = (BYTE *) CoTaskMemAlloc(dwBufLen);
    if (pbBuffer == NULL)
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

    rec.dwMDAttributes = METADATA_INHERIT;
    rec.dwMDUserType = IIS_MD_UT_SERVER,
    rec.dwMDDataType = ALL_METADATA;
    rec.dwMDDataLen = dwBufLen;
    rec.pbMDData = pbBuffer;
    rec.dwMDIdentifier = MD_VR_PATH;

    DWORD dwReqSize;
    ft.hr = m_pMetabase->GetData(h, L"/root", &rec, &dwReqSize);
    if (ft.hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
        CoTaskMemFree(pbBuffer);
        pbBuffer = (BYTE *) CoTaskMemAlloc(dwReqSize);
        if (pbBuffer == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        rec.dwMDDataLen = dwReqSize;
        rec.pbMDData = pbBuffer;
        ft.hr = m_pMetabase->GetData(h, L"/root", &rec, &dwReqSize);
        }

    ft.CheckForError(VSSDBG_STSWRITER, L"IMSAdminBase::GetData");

    return (WCHAR *) pbBuffer;
    }

void CSTSSites::LockSiteContents(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::LockSiteContents");

    VSS_PWSZ wszContentRoot = GetSiteRoot(iSite);
    WCHAR *wszCurrentFile = NULL;
    char *szFile = NULL;
    WCHAR *wszFile = NULL;
    WCHAR *wszNewRoot = NULL;
    CSimpleArray<VSS_PWSZ> rgwszRoots;
    try
        {
        wszCurrentFile = new WCHAR[wcslen(wszContentRoot) + 1];
        if (wszCurrentFile == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        wcscpy(wszCurrentFile, wszContentRoot);
        rgwszRoots.Add(wszCurrentFile);
        wszCurrentFile = NULL;
        
        DWORD iCurrentPos = 0;
        DWORD iEndLevel = 1;
        CoTaskMemFree(wszContentRoot);
        wszContentRoot = NULL;
        while(iCurrentPos < iEndLevel)
            {
            for(; iCurrentPos < iEndLevel; iCurrentPos++)
                {
                LPCWSTR wszCurrentRoot = rgwszRoots[iCurrentPos];
                wszCurrentFile = new WCHAR[wcslen(wszCurrentRoot) + MAX_PATH + 2];
                if (wszCurrentFile == NULL)
                    ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

                // get front page lock
                wcscpy(wszCurrentFile, wszCurrentRoot);
                wcscat(wszCurrentFile, L"\\_vti_pvt\\frontpg.lck");
                TryLock(wszCurrentFile, false);

                // get service lock
                wcscpy(wszCurrentFile, wszCurrentRoot);
                wcscat(wszCurrentFile, L"\\_vti_pvt\\service.lck");
                TryLock(wszCurrentFile, false);

                // find child sub webs
                wcscpy(wszCurrentFile, wszCurrentRoot);
                wcscat(wszCurrentFile, L"\\_vti_pvt\\services.cnf");
                CVssAutoWin32Handle h = CreateFile
                                        (
                                        wszCurrentFile,
                                        GENERIC_READ,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL
                                        );

                if (h == INVALID_HANDLE_VALUE)
                    {
                    DWORD dwErr = GetLastError();
                    if (dwErr == ERROR_PATH_NOT_FOUND ||
                        dwErr == ERROR_FILE_NOT_FOUND)
                        continue;

                    ft.TranslateGenericError
                        (
                        VSSDBG_STSWRITER,
                        HRESULT_FROM_WIN32(GetLastError()),
                        L"CreateFile(%s)",
                        wszCurrentFile
                        );
                    }

                DWORD dwSize = GetFileSize(h, NULL);
                if (dwSize == 0)
                    ft.TranslateGenericError
                        (
                        VSSDBG_STSWRITER,
                        HRESULT_FROM_WIN32(GetLastError()),
                        L"GetFileSize(%s)",
                        wszCurrentFile
                        );

                szFile = new char[dwSize + 1];
                wszFile = new WCHAR[dwSize + 1];
                if (szFile == NULL || wszFile == NULL)
                    ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

                DWORD dwRead;
                if (!ReadFile(h, szFile, dwSize, &dwRead, NULL))
                    ft.TranslateGenericError
                        (
                        VSSDBG_STSWRITER,
                        HRESULT_FROM_WIN32(GetLastError()),
                        L"ReadFile(%s)",
                        wszCurrentFile
                        );

                szFile[dwSize] = '\0';

                if (!MultiByteToWideChar
                        (
                        CP_ACP,
                        MB_ERR_INVALID_CHARS,
                        szFile,
                        dwSize,
                        wszFile,
                        dwSize))
                    {
                    ft.hr = HRESULT_FROM_WIN32(GetLastError());
                    ft.CheckForError(VSSDBG_STSWRITER, L"MultiByteToWideChar");
                    }


                WCHAR *pwcCur = wszFile;
                WCHAR *pwcMax = wszFile + dwSize;
                while(pwcCur < pwcMax)
                    {
                    WCHAR *pwcEnd = wcschr(pwcCur, L'\n');
                    if (pwcEnd == NULL)
                    	   pwcEnd = pwcMax;
                    
                    *pwcEnd = L'\0';
                    stripWhiteChars(pwcCur);
                    if (*pwcCur == L'\0' || *pwcCur != L'/' || pwcCur[1] == L'\0')
                        {
                        pwcCur = pwcEnd + 1;
                        continue;
                        }

                    wszNewRoot = new WCHAR[wcslen(pwcCur) + wcslen(wszCurrentRoot) + 1];
                    if (wszNewRoot == NULL)
                        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

                    wcscpy(wszNewRoot, wszCurrentRoot);

                    // use backslash instead of forward slash
                    wcscat(wszNewRoot, L"\\");

                    // root of subweb
                    wcscat(wszNewRoot, pwcCur+1);
                    rgwszRoots.Add(wszNewRoot);
                    wszNewRoot = NULL;
                    pwcCur = pwcEnd + 1;
                    }

                delete [] wszFile;
                wszFile = NULL;
                delete [] szFile;
                szFile = NULL;
                }

            iCurrentPos = iEndLevel;
            iEndLevel = rgwszRoots.GetSize();
            }
        }
    catch(...)
        {
        UnlockSites();
        delete [] wszNewRoot;
        delete [] wszFile;
        delete [] szFile;
        delete wszCurrentFile;
        CoTaskMemFree(wszContentRoot);

        for (int x = 0; x < rgwszRoots.GetSize(); x++)
       	delete [] rgwszRoots[x];
        
        throw;
        }

    for (int x = 0; x < rgwszRoots.GetSize(); x++)
    	delete [] rgwszRoots[x];
    }



// remove white characters from beginning and ending of the string
void CSTSSites::stripWhiteChars(LPWSTR &wsz)
    {
    static LPCWSTR x_wszWhiteChars = L"^[ \t]+";
    while(*wsz != L'\0')
        {
        if (wcschr(x_wszWhiteChars, *wsz) == NULL)
            break;

        wsz++;
        }

    if (*wsz == L'\0')
        return;

    LPWSTR wszEnd = wsz + wcslen(wsz) - 1;
    while(wszEnd > wsz)
        {
        if (wcschr(x_wszWhiteChars, *wszEnd) == NULL && *wszEnd != L'\r')
            break;

        *wszEnd = L'\0';
        wszEnd--;
        }
    }

void CSTSSites::TryLock(LPCWSTR wszFile, bool bQuotaFile)
    {
    static const DWORD x_MAX_RETRIES = 60;
    static const DWORD x_SLEEP_INTERVAL = 1000;

    HANDLE h = INVALID_HANDLE_VALUE;
    for(DWORD i = 0; i < x_MAX_RETRIES; i++)
        {
        h = CreateFile
                (
                wszFile,
                GENERIC_READ|GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

        if (h != INVALID_HANDLE_VALUE)
            break;

        DWORD dwErr = GetLastError();
        if (dwErr == ERROR_SHARING_VIOLATION)
            {
            Sleep(x_SLEEP_INTERVAL);
            continue;
            }

        // assume file doesn't exist
        return;
        }

    if (i >= x_MAX_RETRIES)
        throw VSS_E_WRITERERROR_TIMEOUT;

    BS_ASSERT(h != INVALID_HANDLE_VALUE);

    try
        {
        if (bQuotaFile)
            {
            BS_ASSERT(m_hQuotaLock == INVALID_HANDLE_VALUE);
            m_hQuotaLock = h;
            }
        else
            m_rgContentLocks.Add(h);
        }
    catch(...)
        {
        // add failed, close handle and rethrow error
        CloseHandle(h);
        throw;
        }
    }

void CSTSSites::UnlockSites()
    {
    DWORD dwSize = m_rgContentLocks.GetSize();
    for(DWORD i = 0; i < dwSize; i++)
        CloseHandle(m_rgContentLocks[i]);

    m_rgContentLocks.RemoveAll();
    }

// lock the quota database
void CSTSSites::LockQuotaDatabase()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::LockQuotaDatabase");

    // do nothing if quota database is already locked
    if (m_hQuotaLock != INVALID_HANDLE_VALUE)
        return;

    static LPCWSTR x_wszLockFile = L"\\owsuser.lck";

    VSS_PWSZ wszDbRoot = GetQuotaDatabase();
    LPWSTR wsz = NULL;
    try
        {
        wsz = new WCHAR[wcslen(wszDbRoot) + 1 + wcslen(x_wszLockFile)];
        if (wsz == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        wcscpy(wsz, wszDbRoot);
        wcscat(wsz, x_wszLockFile);
        TryLock(wsz, true);
        delete wsz;
        CoTaskMemFree(wszDbRoot);
        }
    catch(...)
        {
        delete wsz;
        CoTaskMemFree(wszDbRoot);
        throw;
        }
    }

// unlock the quota database
void CSTSSites::UnlockQuotaDatabase()
    {
    if (m_hQuotaLock != INVALID_HANDLE_VALUE)
        {
        CloseHandle(m_hQuotaLock);
        m_hQuotaLock = INVALID_HANDLE_VALUE;
        }
    }


// get location of Documents And Settings/All Users folder
LPCWSTR CSTSSites::GetAppDataFolder()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetAppDataFolder");
    if (m_wszAppDataFolder)
        return m_wszAppDataFolder;

    CVssRegistryKey key;
    if (!key.Open(HKEY_LOCAL_MACHINE, x_ShellFoldersKey))
        ft.Throw(VSSDBG_STSWRITER, E_UNEXPECTED, L"shell folders key is missing");


    key.GetValue(x_AppDataValue, m_wszAppDataFolder);
    return m_wszAppDataFolder;
    }

// get location of directory containing the quota database for
// sharepoint.  Caller should call CoTaskMemFree on the returned value
VSS_PWSZ CSTSSites::GetQuotaDatabase()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetQuotaDatabase");
    LPCWSTR wszAppData = GetAppDataFolder();
    DWORD cwc = (DWORD) (wcslen(wszAppData) + wcslen(x_STSSubfolder) + 1);
    VSS_PWSZ wsz = (VSS_PWSZ) CoTaskMemAlloc(cwc * sizeof(WCHAR));
    if (wsz == NULL)
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");
	
    wcscpy(wsz, wszAppData);
    wcscat(wsz, x_STSSubfolder);
    return wsz;
    }

// return of the root directory for the sites roles database under
// the app data folder
VSS_PWSZ CSTSSites::GetSiteRoles(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteRoles");

    DWORD siteId = GetSiteId(iSite);
    WCHAR buf[32];
    swprintf(buf, L"\\W3SVC%d", siteId);
    LPCWSTR wszAppData = GetAppDataFolder();
    DWORD cwc = (DWORD) (wcslen(wszAppData) + wcslen(x_STSSubfolder) + wcslen(buf) + 1);
    VSS_PWSZ wsz = (VSS_PWSZ) CoTaskMemAlloc(cwc * sizeof(WCHAR));
    if (wsz == NULL)
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");
    
    wcscpy(wsz, wszAppData);
    wcscat(wsz, x_STSSubfolder);
    wcscat(wsz, buf);
    return wsz;
    }

VSS_PWSZ CSTSSites::GetSiteBasicInfo(DWORD iSite, DWORD propId)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteBasicInfo");

    METADATA_HANDLE h;
    static const DWORD x_MDTimeout = 2000;

    BS_ASSERT(iSite < m_cSites);
    DWORD siteId = m_rgSiteIds[iSite];

    SetupMetabaseInterface();

    ft.hr = m_pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, x_STSMetabaseKey, METADATA_PERMISSION_READ, x_MDTimeout, &h);
    ft.CheckForError(VSSDBG_STSWRITER, L"IMSAdminBase::OpenKey");
    CVssAutoMetabaseHandle MetaHandle(m_pMetabase, h);
    METADATA_RECORD rec;
    DWORD dwBufLen = METADATA_MAX_NAME_LEN;
    PBYTE pbBuffer = (BYTE *) CoTaskMemAlloc(dwBufLen);
    if (pbBuffer == NULL)
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

    rec.dwMDAttributes = METADATA_INHERIT;
    rec.dwMDUserType = IIS_MD_UT_SERVER,
    rec.dwMDDataType = ALL_METADATA;
    rec.dwMDDataLen = dwBufLen;
    rec.pbMDData = pbBuffer;
    rec.dwMDIdentifier = propId;

    WCHAR buf[16];
    swprintf(buf, L"/%d", siteId);

    DWORD dwReqSize;
    ft.hr = m_pMetabase->GetData(h, buf, &rec, &dwReqSize);
    if (ft.hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
        CoTaskMemFree(pbBuffer);
        pbBuffer = (BYTE *) CoTaskMemAlloc(dwReqSize);
        if (pbBuffer == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        rec.dwMDDataLen = dwReqSize;
        rec.pbMDData = pbBuffer;
        ft.hr = m_pMetabase->GetData(h, buf, &rec, &dwReqSize);
        }

    if (ft.hr == MD_ERROR_DATA_NOT_FOUND)
        return NULL;

    ft.CheckForError(VSSDBG_STSWRITER, L"IMSAdminBase::GetData");

    return (WCHAR *) pbBuffer;
    }



// return comments for site (site description).  Caller is responsible
// for freeing up the memory using CoTaskMemFree
VSS_PWSZ CSTSSites::GetSiteComment(DWORD iSite)
    {
    return GetSiteBasicInfo(iSite, MD_SERVER_COMMENT);
    }

// return ip address of the site if it exists.  Caller is responsible for
// freeing up the memory using CoTaskMemFree
VSS_PWSZ CSTSSites::GetSiteIpAddress(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteIpAddress");

    VSS_PWSZ wszBindings = GetSiteBasicInfo(iSite, MD_SERVER_BINDINGS);

    if (wszBindings == NULL)
        return NULL;

    LPWSTR wszHost = wcsrchr(wszBindings, L':');
    if (wszHost == NULL)
        {
        CoTaskMemFree(wszBindings);
        return NULL;
        }

    *wszHost = '\0';
    LPCWSTR wszPort = wcsrchr(wszBindings, L':');
    if (wszPort == NULL || wszPort == wszBindings)
        {
        CoTaskMemFree(wszBindings);
        return NULL;
        }

    DWORD cwc = (DWORD) (wszPort - wszBindings);
    VSS_PWSZ pwszRet = (VSS_PWSZ) CoTaskMemAlloc(cwc * sizeof(WCHAR));
    if (pwszRet == NULL)
        {
        CoTaskMemFree(wszBindings);
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");
        }

    wcsncpy(pwszRet, wszBindings, cwc - 1);
    pwszRet[cwc - 1] = L'\0';
    return pwszRet;
    }

// return port address of the site if it exists.  Caller is responsible for
// freeing up the memory using CoTaskMemFree
DWORD CSTSSites::GetSitePort(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteIpAddress");

    VSS_PWSZ wszBindings = GetSiteBasicInfo(iSite, MD_SERVER_BINDINGS);

    if (wszBindings == NULL)
        return NULL;

    LPWSTR wszHost = wcsrchr(wszBindings, L':');
    if (wszHost == NULL)
        {
        CoTaskMemFree(wszBindings);
        return NULL;
        }

    *wszHost = L'\0';
    LPWSTR wszPort = wcsrchr(wszBindings, L':');
    if (wszPort == NULL || wszPort + 1 == wszHost)
        {
        CoTaskMemFree(wszBindings);
        return 0;
        }

    DWORD dwPort = _wtoi(wszPort + 1);
    CoTaskMemFree(wszBindings);
    return dwPort;
    }


// return port address of the site if it exists.  Caller is responsible for
// freeing up the memory using CoTaskMemFree
VSS_PWSZ CSTSSites::GetSiteHost(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSSites::GetSiteIpAddress");

    VSS_PWSZ wszBindings = GetSiteBasicInfo(iSite, MD_SERVER_BINDINGS);

    if (wszBindings == NULL)
        return NULL;

    LPCWSTR wszHost = wcsrchr(wszBindings, L':');
    if (wszHost == NULL || wcslen(wszHost) == 1)
        {
        CoTaskMemFree(wszBindings);
        return NULL;
        }

    VSS_PWSZ pwszRet = (VSS_PWSZ) CoTaskMemAlloc(wcslen(wszHost));
    if (pwszRet == NULL)
        {
        CoTaskMemFree(wszBindings);
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");
        }

    wcscpy(pwszRet, wszHost + 1);
    CoTaskMemFree(wszBindings);
    return pwszRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\tracing\vs_seh.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_seh.cxx

Abstract:

    Exception handling support code

Author:

   Stefan R. Steiner   [SSteiner]      15-Apr-1998

Revision History:

    ssteiner   09/10/98		- Removed the exception classes.  Now only throwing
							HRESULTs.
	aoltean		02/02/2000	- moved into Vss project under the name from bsexcept.cxx 
							into "vs_seh" 
    
--*/

#include <windows.h>
#include "vs_seh.hxx"
#include "vs_trace.hxx"

/*++

Routine Description:

    The Structured Exception Handling translator function.  Translates
    SEH exceptions to C++ Native exceptions.  Generates a trace message.

Arguments:

    ExceptionCode - SEH exception code.

    pEP - pointer to a more detailed explanation of why the exception
          was thrown.
        
Return Value:

    None

Throws:

    HRESULT - translated exception code from windows exception code to HRESULT.

--*/

void _cdecl BsSeHandler::SeHandler(
    unsigned int uiExceptionCode,
    struct _EXCEPTION_POINTERS *pEP
    )
{
    BsDebugTraceAlways( 0, DEBUG_TRACE_CATCH_EXCEPTIONS, 
                        ( L"BsSeHandler::SeHandler: Caught SEH exception, code: 0x%08x", uiExceptionCode ) );                        
    BS_THROW( (HRESULT)uiExceptionCode );
    UNREFERENCED_PARAMETER( pEP );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\tracing\assrt.cxx ===
/*++

Copyright (c) 200  Microsoft Corporation

Module Name:

    assrt.cxx

Abstract:
	assertion code used by BS_ASSERT

Author:


Revision History:
	Name		Date		Comments
	brianb		04/19/2000	created
	aoltean     06/20/2000  Adding VssSetDebugReport

--*/


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <stdio.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#undef ASSERT

#include "vs_assert.hxx"
#include "vs_trace.hxx"
#include "vssmsg.h"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCASRTC"
//
////////////////////////////////////////////////////////////////////////


// Size of a constant array
#define SIZEOF_ARRAY(_array)   (sizeof (_array) / sizeof ((_array)[0]))


// First two parameters to StringCChPrintf routines.
#define STRING_CCH_PARAM(_array)   _array, (SIZEOF_ARRAY(_array))


// No MP protection...
static LONG g_lVssDebugReportFlags = VSS_DBG_TO_DEBUG_CONSOLE | VSS_DBG_MESSAGE_BOX;

const CHAR x_szEventLogVssSourceName[] = "VSS";


VOID
AssertFail
	(
    IN LPCSTR FileName,
    IN UINT LineNumber,
    IN LPCSTR Condition
    )
	{
    int i;
    CHAR Title[4096];
    CHAR Msg[4096];

    DWORD dwCurrentProcessId = GetCurrentProcessId();
    DWORD dwCurrentThreadId = GetCurrentThreadId();
    
    if (g_lVssDebugReportFlags & VSS_DBG_TO_DEBUG_CONSOLE) 
        {
        StringCchPrintfA(
            STRING_CCH_PARAM(Msg),
            "VSS(PID:%ld,TID:%ld): %s(%d): *** Assertion failure  *** %s\n",
            dwCurrentProcessId,
            dwCurrentThreadId,
            FileName,
            LineNumber,
            Condition
            );


        ::OutputDebugStringA(Msg);
/*
        ::DbgPrintEx(
            DPFLTR_VSS_ID,
            1,
            Msg
            );
 */
        }

    if (g_lVssDebugReportFlags & VSS_DBG_MESSAGE_BOX) 
        {
        LPSTR szCommandLine = GetCommandLineA();

        //
        // Print the assertion and the command line
        //
        StringCchPrintfA(
            STRING_CCH_PARAM(Msg),
            "Assertion failure: %s\nFile: %s\nLine: %u\nCommand: %s\nProcess ID: %ld\nThread ID: %ld",
            Condition,
            FileName,
            LineNumber,
            szCommandLine,
            dwCurrentProcessId,
            dwCurrentThreadId
            );

        // Get a handle to use with ReportEvent()
        HANDLE hEventSource = ::RegisterEventSourceA(
            NULL,                           //  IN LPCWSTR lpUNCServerName,
            x_szEventLogVssSourceName       //  IN LPCWSTR lpSourceName
            );
        if (hEventSource)
        {
            LPCSTR ppszStringTable[1];
            ppszStringTable[0] = const_cast<LPCSTR>(Msg);
            
            // Write to event log. Ignore return code.
            ::ReportEventA(
                hEventSource,                           //  IN HANDLE     hEventLog,
                EVENTLOG_ERROR_TYPE,                    //  IN WORD       wType,
                0,                                      //  IN WORD       wCategory,
                VSS_ERROR_ASSERT,                       //  IN DWORD      dwEventID,
                NULL,                                   //  IN PSID       lpUserSid,
                1,                                      //  IN WORD       wNumStrings,
                0,                                      //  IN DWORD      dwDataSize,
                ppszStringTable,                        //  IN LPCWSTR   *lpStrings,
                NULL                                    //  IN LPVOID     lpRawData
                );

            // Close the handle to the event log
            ::DeregisterEventSource( hEventSource );
        }

        //
        // Use dll name as caption
        //
        StringCchPrintfA(
            STRING_CCH_PARAM(Title),
            "Volume Snapshots (PID:%ld,TID:%ld)",
            dwCurrentProcessId,
            dwCurrentThreadId
            );

        //
        // Print the assertion and the command line
        //
        StringCchPrintfA(
            STRING_CCH_PARAM(Msg),
            "Assertion failure at line %u in file %s: %s\n\nCommand line: %s\n\nHit Cancel to break into the debugger.",
            LineNumber,
            FileName,
            Condition,
            szCommandLine
            );

        i = MessageBoxA
    			(
                NULL,
                Msg,
    			Title,
    			MB_SYSTEMMODAL | MB_ICONSTOP | MB_OKCANCEL | MB_SERVICE_NOTIFICATION
                );

        if(i == IDCANCEL)
            DebugBreak();
        }
    }

void VssSetDebugReport( LONG lDebugReportFlags )
{
    g_lVssDebugReportFlags = lDebugReportFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\stswriter\stswriter.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stswriter.cpp | Implementation of Sharepoint Team Services Writer
    @end

Author:

    Brian Berkowitz  [brianb]  08/17/2001

TBD:


Revision History:

    Name        Date        Comments
    brianb      08/17/2001  created

--*/
#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "vs_reg.hxx"
#include "vssmsg.h"

#include "iadmw.h"
#include "iiscnfg.h"
#include "mdmsg.h"
#include "stssites.hxx"

#include "vswriter.h"
#include "stswriter.h"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "bsstring.hxx"
#include "wrtcommon.hxx"
#include "allerror.h"
#include "sqlwrtguid.h"
#include "sqlsnap.h"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "STSWRTRC"
//
////////////////////////////////////////////////////////////////////////

// writer id
static GUID s_writerId =
    {
    0x4dd6f8dd, 0xbf50, 0x4585, 0x95, 0xde, 0xfb, 0x43, 0x7c, 0x08, 0x31, 0xa6
    };

// writer name
static LPCWSTR s_wszWriterName = L"SharepointTSWriter";

STDMETHODCALLTYPE CSTSWriter::~CSTSWriter()
{
        Uninitialize();
        delete [] m_rgiSites;
        delete m_pSites;
}

// initialize and subscribe the writer
HRESULT STDMETHODCALLTYPE CSTSWriter::Initialize()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::Initialize");

    try
        {
        // only initialize the writer if the correct version of sharepoint
        // is running on the system
        m_pSites = new CSTSSites;
        if (m_pSites == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        if (m_pSites->ValidateSharepointVersion())
            {
            if (!m_pSites->Initialize())
            	{
            	ft.Throw (VSSDBG_STSWRITER, E_UNEXPECTED, 
            		L"Failed to initialize the SharepointTS writer.");
              }
            
            ft.hr = CVssWriter::Initialize
                (
                s_writerId,             // writer id
                s_wszWriterName,        // writer name
                VSS_UT_USERDATA,        // writer handles user data
                VSS_ST_OTHER,           // not a database
                VSS_APP_FRONT_END,      // sql server freezes after us
                60000                   // 60 second freeze timeout
                );

            if (ft.HrFailed())
                ft.Throw
                    (
                    VSSDBG_STSWRITER,
                    E_UNEXPECTED,
                    L"Failed to initialize the SharepointTS writer.  hr = 0x%08lx",
                    ft.hr
                    );

            // subscribe the writer for COM+ events
            ft.hr = Subscribe();
            if (ft.HrFailed())
                ft.Throw
                    (
                   VSSDBG_STSWRITER,
                    E_UNEXPECTED,
                    L"Subscribing the SharepointTS server writer failed. hr = %0x08lx",
                    ft.hr
                    );

            // indicate that th writer is successfully subscribed
            m_bSubscribed = true;
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// uninitialize the writer.  This means unsubscribing the writer
HRESULT STDMETHODCALLTYPE CSTSWriter::Uninitialize()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::Uninitialize");

    // unsubscribe writer if it is already subscribed
    if (m_bSubscribed)
        return Unsubscribe();

    return ft.hr;
    }

// handle OnPrepareBackup event.  Determine whether components selected for
// backup are valid and if so store some metadata in them that is used
// to verify that restore properly restores the sites data to its original
// locations.  Keep
bool STDMETHODCALLTYPE CSTSWriter::OnPrepareBackup
    (
    IN IVssWriterComponents *pComponents
    )
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::OnPrepareBackup");

    VSS_PWSZ wszMetadataForSite = NULL;

    try
        {
        // count of components
        UINT cComponents = 0;

        // clear array of sites being operated on
        delete m_rgiSites;
        m_rgiSites = NULL;
        m_cSites = 0;

        // determine if we are doing a component or volume based backup
        m_bVolumeBackup = !AreComponentsSelected();
        if (!m_bVolumeBackup)
            {
            // get count of components
            ft.hr = pComponents->GetComponentCount(&cComponents);
            ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssWriterComponents::GetComponentCount");

            // allocate array of sites
            m_rgiSites = new DWORD[cComponents];
            if (m_rgiSites == NULL)
                ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

            // loop through components
            for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
                {
                // get component
                CComPtr<IVssComponent> pComponent;
                ft.hr = pComponents->GetComponent(iComponent, &pComponent);
                ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssWriterComponents::GetComponent");

                CComBSTR bstrLogicalPath;
                CComBSTR bstrSiteName;

                // get logal path and component name
                ft.hr = pComponent->GetLogicalPath(&bstrLogicalPath);
                ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssComponent::GetLogicalPath");

                ft.hr = pComponent->GetComponentName(&bstrSiteName);
                ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssComponent::GetComponentName");

                // logical paths are not supported for STS components
                if (bstrLogicalPath && wcslen(bstrLogicalPath) != 0)
                    ft.Throw(VSSDBG_STSWRITER, VSS_E_OBJECT_NOT_FOUND, L"STS components do not have logical paths");

                // try parsing the component name as a site name
                DWORD iSite;
                STSSITEPROBLEM problem;
                if (!ParseComponentName(bstrSiteName, iSite, problem))
                    ft.Throw(VSSDBG_STSWRITER, VSS_E_OBJECT_NOT_FOUND, L"sites name is not valid");

                // see if site is already in array of sites being backed up
                for(DWORD iC = 0; iC < iComponent; iC++)
                    {
                    if (m_rgiSites[iC] == iSite)
                        break;
                    }

                // if site already exists then throw an error
                if (iC < iComponent)
                    ft.Throw(VSSDBG_STSWRITER, VSS_E_OBJECT_ALREADY_EXISTS, L"site backed up twice");

                // build backup metadata for site
                wszMetadataForSite = BuildSiteMetadata(iSite);

                // save backup metadata for site
                ft.hr = pComponent->SetBackupMetadata(wszMetadataForSite);
                ft.CheckForError(VSSDBG_STSWRITER, L"IVssComponent::SetBackupMetadata");

                // free allocated metadat for site
                CoTaskMemFree(wszMetadataForSite);
                wszMetadataForSite = NULL;

                // save site to be backed up
                m_rgiSites[iComponent] = iSite;
                }
            }

        // number of sites to be backed up is number of components
        m_cSites = cComponents;
        }
    VSS_STANDARD_CATCH(ft)

    // free dangling metadata for site if operation failed
    CoTaskMemFree(wszMetadataForSite);
    TranslateWriterError(ft.hr);

    return !ft.HrFailed();
    }


// parse a component name to see if it refers to a valid site
// the component name is comment_[instanceId] where comment is
// the server comment for the site and the instance id is the
// IIS instance id
bool CSTSWriter::ParseComponentName
    (
    LPCWSTR wszComponentName,
    DWORD &iSite,
    STSSITEPROBLEM &problem
    )
    {
    CVssFunctionTracer(VSSDBG_STSWRITER, L"CSTSWriter::ParseComponentName");

    // pointer to CSTSSites object should already be initialized
    BS_ASSERT(m_pSites);

    // compute length of component name
    DWORD cwc = (DWORD) wcslen(wszComponentName);

    // assume site name is properly parsed
    problem = STSP_SUCCESS;

    // search for last underline site name looks like
    // servercomment_instanceid where servercomment is the
    // IIS server comment field for the virtual web and instance id
    // is the IIS instance id for the virtual web
    LPWSTR wszId = wcsrchr(wszComponentName, L'_');
    if (wszId == NULL || wcslen(wszId) < 4)
        return false;

    // scan for instance id of site
    DWORD siteId;
    DWORD cFields = swscanf(wszId, L"_[%d]", &siteId);
    if (cFields == 0)
        {
        // if instance id doesn't parse then there is a syntax error
        problem = STSP_SYNTAXERROR;
        return false;
        }

    // get # of sites on the current machine
    DWORD cSites = m_pSites->GetSiteCount();

    // loop through sites
    for(iSite = 0; iSite < cSites; iSite++)
        {
        // break out of loop if site id matches
        if (m_pSites->GetSiteId(iSite) == siteId)
            break;
        }

    // if site id is not found then return false
    if (iSite == cSites)
        {
        problem = STSP_SITENOTFOUND;
        return false;
        }

    // get site comment
    VSS_PWSZ wszComment = m_pSites->GetSiteComment(iSite);

    // validate that comment matches prefix of component name
    bool bValid = wcslen(wszComment) == cwc - wcslen(wszId) &&
                  _wcsnicmp(wszComment, wszComponentName, wcslen(wszComment)) == 0;

    // free site comment
    CoTaskMemFree(wszComment);
    if (!bValid)
        {
        problem = STSP_SITENAMEMISMATCH;
        return false;
        }

    // validate that site can be backed up.
    return ValidateSiteValidity(iSite, problem);
    }

// validate site validity to be backed up and restored.  This means
// that all files and the database are local to the current machine
bool CSTSWriter::ValidateSiteValidity(DWORD iSite, STSSITEPROBLEM &problem)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::ValidateSiteValidity");

    BS_ASSERT(m_pSites);

    // co task strings that need to be freed if function throws
    VSS_PWSZ wszDsn = NULL;
    VSS_PWSZ wszContentRoot = NULL;
    VSS_PWSZ wszConfigRoot = NULL;

    try
        {
        // get dsn for site
        wszDsn = m_pSites->GetSiteDSN(iSite);
        LPWSTR wszServer, wszInstance, wszDb;

        // parse the dsn into server name, instance name and database name
        if (!ParseDsn(wszDsn, wszServer, wszInstance, wszDb))
            {
            // site DSN is invalid
            problem = STSP_SITEDSNINVALID;
            CoTaskMemFree(wszDsn);
            return false;
            }

        // verify that the server is local
        if (!ValidateServerIsLocal(wszServer))
            {
            problem = STSP_SQLSERVERNOTLOCAL;
            CoTaskMemFree(wszDsn);
            return false;
            }

        // free up dsn.  we are done with it
        CoTaskMemFree(wszDsn);
        wszDsn = NULL;


        // get content root of the site
        wszContentRoot = m_pSites->GetSiteRoot(iSite);

        // validate that path to root is on the local machine
        if (!ValidatePathIsLocal(wszContentRoot))
            {
            problem = STSP_CONTENTNOTLOCAL;
            CoTaskMemFree(wszContentRoot);
            return false;
            }

        // free up content root
        CoTaskMemFree(wszContentRoot);
        wszContentRoot = NULL;

        // get configuration root of the site
        wszConfigRoot = m_pSites->GetSiteRoles(iSite);

        // validate that configuration path is local
        if (!ValidatePathIsLocal(wszConfigRoot))
            {
            problem = STSP_CONFIGNOTLOCAL;
            CoTaskMemFree(wszConfigRoot);
            return false;
            }

        // free up configuration root
        CoTaskMemFree(wszConfigRoot);
        return true;
        }
    catch(...)
        {
        // free allocated memory and rethrow error
        CoTaskMemFree(wszDsn);
        CoTaskMemFree(wszContentRoot);
        CoTaskMemFree(wszConfigRoot);
        throw;
        }
    }


// build metadata for the site
// the metadata is used to validate that the site can be restored properly
// it consists of the content root of the site, the configuration root
// of the site, and the sql database.  All need to match
VSS_PWSZ CSTSWriter::BuildSiteMetadata(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::BuildSiteMetadata");

    BS_ASSERT(m_pSites);

    // co task allocated strings that need to be freed if the function throws
    VSS_PWSZ wszDsn = NULL;
    VSS_PWSZ wszContentRoot = NULL;
    VSS_PWSZ wszConfigRoot = NULL;
    VSS_PWSZ wszMetadata = NULL;
    try
        {
        // get dsn for site
        wszDsn = m_pSites->GetSiteDSN(iSite);
        LPWSTR wszInstance, wszDb, wszServer;

        // break dsn into server, instance, and database names
        if (!ParseDsn(wszDsn, wszServer, wszInstance, wszDb))
            {
            // since we already parsed the dsn once, we don't expect
            // parsing it to fail when we try a second time
            BS_ASSERT(FALSE && L"shouldn't get here");
            ft.Throw(VSSDBG_STSWRITER, E_UNEXPECTED, L"unexpected failure parsing the DSN");
            }

        // get the content root of the site
        wszContentRoot = m_pSites->GetSiteRoot(iSite);

        // get the configuration path for the site
        wszConfigRoot = m_pSites->GetSiteRoles(iSite);

        // compute size of metadata string.  the format of the string is
        // servername\instancename1111dbname2222siteroot3333configroot where
        // 1111 is the length fo the database name, 2222 is the length of the site
        // root, and 3333 is the length of th econfiguration root.  The lengths
        // are all 4 digit hex numbers
        DWORD cwc = (DWORD) ((wszServer ? wcslen(wszServer) : 0) + (wszInstance ? wcslen(wszInstance) : 0) + wcslen(wszDb) + wcslen(wszContentRoot) + wcslen(wszConfigRoot) + (3 * 4) + 3);
        wszMetadata = (VSS_PWSZ) CoTaskMemAlloc(cwc * sizeof(WCHAR));
        if (wszMetadata == NULL)
        	ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

        // create server and instance parts of path
        if (wszServer && wszInstance)
            swprintf(wszMetadata, L"%s\\%s", wszServer, wszInstance);
        else if (wszServer)
            swprintf(wszMetadata, L"%s\\", wszServer);
        else if (wszInstance)
            wcscpy(wszMetadata, wszInstance);

        // include database name, site root, and configuration root
        swprintf
            (
            wszMetadata + wcslen(wszMetadata),
            L";%04x%s%04x%s%04x%s",
            wcslen(wszDb),
            wszDb,
            wcslen(wszContentRoot),
            wszContentRoot,
            wcslen(wszConfigRoot),
            wszConfigRoot
            );

        // free up dsn, config root and content root
        CoTaskMemFree(wszDsn);
        CoTaskMemFree(wszConfigRoot);
        CoTaskMemFree(wszContentRoot);
        return wszMetadata;
        }
    catch(...)
        {
        // free memory and rethrow error
        CoTaskMemFree(wszDsn);
        CoTaskMemFree(wszConfigRoot);
        CoTaskMemFree(wszContentRoot);
        CoTaskMemFree(wszMetadata);
        throw;
        }
    }

// determine if a database is on a snapshotted device.  If it is partially
// on a snapshotted device throw VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
bool CSTSWriter::IsDatabaseAffected(LPCWSTR wszInstance, LPCWSTR wszDb)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::IsDatabaseAffected");
    CSqlEnumerator *pEnumServers = NULL;
    CSqlEnumerator *pEnumDatabases = NULL;
    CSqlEnumerator *pEnumFiles = NULL;
    try
        {
        ServerInfo server;
        DatabaseInfo database;
        DatabaseFileInfo file;

        // create enumerator for sql server instances
        pEnumServers = CreateSqlEnumerator();
        if (pEnumServers == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

        // find first server
        ft.hr = pEnumServers->FirstServer(&server);
        while(ft.hr != DB_S_ENDOFROWSET)
            {
            // check for error code
            if (ft.HrFailed())
                ft.Throw
                    (
                    VSSDBG_STSWRITER,
                    E_UNEXPECTED,
                    L"Enumerating database servers failed.  hr = 0x%08lx",
                    ft.hr
                    );

            if (server.isOnline &&
                (wszInstance == NULL && wcslen(server.name) == 0) ||
                 _wcsicmp(server.name, wszInstance) == 0)
                {
                // if instance name matches, then try finding the
                // database by creating the database enumerator
                pEnumDatabases = CreateSqlEnumerator();
                if (pEnumDatabases == NULL)
                    ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

                // find first database
                ft.hr = pEnumDatabases->FirstDatabase(server.name, &database);
                while(ft.hr != DB_S_ENDOFROWSET)
                    {
                    // check for error
                    if (ft.HrFailed())
                        ft.Throw
                            (
                            VSSDBG_GEN,
                            E_UNEXPECTED,
                            L"Enumerating databases failed.  hr = 0x%08lx",
                            ft.hr
                            );

                    // if database name matches. then scan files
                    // to see what volumes they are on
                    if (_wcsicmp(database.name, wszDb) == 0 && database.supportsFreeze)
                        {
                        bool fAffected = false;
                        DWORD cFiles = 0;

                        // recreate enumerator for files
                        BS_ASSERT(pEnumFiles == NULL);
                        pEnumFiles = CreateSqlEnumerator();
                        if (pEnumFiles == NULL)
                            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

                        // findfirst database file
                        ft.hr = pEnumFiles->FirstFile(server.name, database.name, &file);
                        while(ft.hr != DB_S_ENDOFROWSET)
                            {
                            // check for error
                            if (ft.HrFailed())
                                ft.Throw
                                    (
                                    VSSDBG_GEN,
                                    E_UNEXPECTED,
                                    L"Enumerating database files failed.  hr = 0x%08lx",
                                    ft.hr
                                    );

                            // determine if database file is included in the
                            // backup
                            if (IsPathAffected(file.name))
                                {
                                // if it is and other files aren't then
                                // the snapshot is inconsistent
                                if (!fAffected && cFiles > 0)
                                    ft.Throw(VSSDBG_STSWRITER, HRESULT_FROM_WIN32(E_SQLLIB_TORN_DB), L"some database files are snapshot and some aren't");

                                fAffected = true;
                                }
                            else
                                {
                                // if it isn't and other files are, then
                                // the snapshot is inconsistent
                                if (fAffected)
                                    ft.Throw(VSSDBG_STSWRITER, HRESULT_FROM_WIN32(E_SQLLIB_TORN_DB), L"some database files are snapshot and some aren't");
                                }


                            // continue at next file
                            ft.hr = pEnumFiles->NextFile(&file);
                            cFiles++;
                            }

                        delete pEnumFiles;
                        pEnumFiles = NULL;
                        delete pEnumDatabases;
                        pEnumDatabases = NULL;
                        delete pEnumServers;
                        pEnumServers = NULL;
                        return fAffected;
                        }

                    // continue at next database
                    ft.hr = pEnumDatabases->NextDatabase(&database);
                    }

                // done with database enumerator
                delete pEnumDatabases;
                pEnumDatabases = NULL;
                }

            // continue at next server
            ft.hr = pEnumServers->NextServer(&server);
            }

        ft.Throw(VSSDBG_STSWRITER, E_UNEXPECTED, L"database is not found %s\\%s", server.name, database.name);
        }
    catch(...)
        {
        // delete enumerators and rethrow error
        delete pEnumFiles;
        delete pEnumServers;
        delete pEnumDatabases;
        throw;
        }

    // we won't really ever get here.  This is just to keep the compiler
    // happy
    return false;
    }



// determine if a site is completely contained in the set of volumes being
// snapshotted.  If it is partially contained then throw
// VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT.
bool CSTSWriter::IsSiteSnapshotted(DWORD iSite)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::IsSiteSnapshotted");

    BS_ASSERT(m_pSites);

    // co task allocated strings that need to be freed
    // in the case of a failure
    VSS_PWSZ wszDsn = NULL;
    VSS_PWSZ wszContentRoot = NULL;
    VSS_PWSZ wszConfigRoot = NULL;
    VSS_PWSZ wszInstanceName = NULL;

    try
        {
        // get dsn for site
        wszDsn = m_pSites->GetSiteDSN(iSite);

        // get content root for the site
        wszContentRoot = m_pSites->GetSiteRoot(iSite);

        // gt configuration root for the site
        wszConfigRoot = m_pSites->GetSiteRoles(iSite);
        LPWSTR wszServer, wszInstance, wszDb;

        // parse the site dsn into server, instance, and database
        if (!ParseDsn(wszDsn, wszServer, wszInstance, wszDb))
            {
            // shouldn't get here since we previously parsed
            // the site's dsn
            BS_ASSERT(FALSE && L"shouldn't get here");
            ft.Throw(VSSDBG_STSWRITER, E_UNEXPECTED, L"dsn is invalid");
            }

        // compute instance name as server\\instance
        wszInstanceName = (VSS_PWSZ) CoTaskMemAlloc(((wszServer ? wcslen(wszServer) : 0) + (wszInstance ? wcslen(wszInstance) : 0) + 2) * sizeof(WCHAR));
        if (wszInstanceName == NULL)
            ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");


        if (wszServer)
            {
            wcscpy(wszInstanceName, wszServer);
            wcscat(wszInstanceName, L"\\");
            if (wszInstance)
                wcscat(wszInstanceName, wszInstance);
            }
        else if (wszInstance)
            wcscpy(wszInstanceName, wszInstance);
        else
            wszInstanceName[0] = L'\0';


        // determine if database is snapshotted
        bool bDbAffected = IsDatabaseAffected(wszInstanceName, wszDb);

        // determine if content root is snapshotted
        bool bContentAffected = IsPathAffected(wszContentRoot);

        // determine if configuration root is snapshotted
        bool bConfigAffected = IsPathAffected(wszConfigRoot);

        // free up memory for dsn, content root, and configuration root
        CoTaskMemFree(wszDsn);
        CoTaskMemFree(wszContentRoot);
        CoTaskMemFree(wszConfigRoot);
        wszDsn = NULL;
        wszContentRoot = NULL;
        wszConfigRoot = NULL;

        if (bDbAffected && bContentAffected && bConfigAffected)
            // if all are snapshotted then return true
            return true;
        else if (bDbAffected || bContentAffected || bConfigAffected)
            // if some but not all are snapshotted, then indicate
            // the inconsistency
            ft.Throw
                (
                VSSDBG_STSWRITER,
                VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT,
                L"site %d partially affected by snapshot",
                m_pSites->GetSiteId(iSite)
                );
        else
            // if none are snapshotted, then return false
            return false;
        }
    catch(...)
        {
        // free memory and rethrow exception
        CoTaskMemFree(wszDsn);
        CoTaskMemFree(wszConfigRoot);
        CoTaskMemFree(wszContentRoot);
        CoTaskMemFree(wszInstanceName);
        throw;
        }

    // will not get here.  Just here to keep the compiler happy
    return false;
    }

// lockdown all sites that are on volumes being snapshotted.  If any sites
// are both on volumes being snapshotted and not being snapshot then
// indicate tht the snapshot is inconsistent.  If the quota database is
// on a volume being snapshoted then lock it as well
void CSTSWriter::LockdownAffectedSites()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::LockdownAffectedSites");

    // co task string that needs to be freed in the case of exception
    VSS_PWSZ wszQuotaDbPath = NULL;
    BS_ASSERT(m_pSites);


    try
        {
        // determine if bootable system state is not being backed up.  If so,
        // then the quota database is locked if its path is being snapshotted.
        // if bootable system state is already being backed up, the the
        // quota database is already locked
        if (!IsBootableSystemStateBackedUp())
            {
            // determine if quota database is being snapshotted
            wszQuotaDbPath = m_pSites->GetQuotaDatabase();
            if (IsPathAffected(wszQuotaDbPath))
                // if so then lock it
                m_pSites->LockQuotaDatabase();

            // free memory for quota db path
            CoTaskMemFree(wszQuotaDbPath);
            wszQuotaDbPath = NULL;
            }

        // get count of sites
        DWORD cSites = m_pSites->GetSiteCount();

        // loop through sites
        for(DWORD iSite = 0; iSite < cSites; iSite++)
            {
            // if site is snapshotted lock it
            if (IsSiteSnapshotted(iSite))
                m_pSites->LockSiteContents(iSite);
            }
        }
    catch(...)
        {
        // free memory and rethrow error
        CoTaskMemFree(wszQuotaDbPath);
        throw;
        }
    }

// handle prepare snapshot event.  Lock any sites that need to be
// locked based on components document or on volumes being snapshotted
bool STDMETHODCALLTYPE CSTSWriter::OnPrepareSnapshot()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::OnPrepareSnapshot");

    BS_ASSERT(m_pSites);

    try
        {
        // lock quota database if bootable system state is being backed up
        if (IsBootableSystemStateBackedUp())
            m_pSites->LockQuotaDatabase();

        if (m_bVolumeBackup)
            // if volume backup, then lock sites based on whether they
            // are fully on the snapshotted volumes.
            LockdownAffectedSites();
        else
            {
            // loop through sites being backed up
            for (DWORD i = 0; i < m_cSites; i++)
                {
                DWORD iSite = m_rgiSites[i];

                // validate that site is on volumes being snapshotted
                if (!IsSiteSnapshotted(iSite))
                    // the site is in selected to be backed up.  it should
                    // be snapshotted as well
                    ft.Throw
                        (
                        VSSDBG_STSWRITER,
                        VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT,
                        L"a site is selected but is on volumes that are not snapshot"
                        );

                // lock site
                m_pSites->LockSiteContents(iSite);
                }
            }

        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        {
        // unlock anything that was locked if operation fails
        m_pSites->UnlockSites();
        m_pSites->UnlockQuotaDatabase();
        TranslateWriterError(ft.hr);
        }

    return !ft.HrFailed();
    }


// freeze operation.  Nothing is done here since all the work is done
// during the prepare phase
bool STDMETHODCALLTYPE CSTSWriter::OnFreeze()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::OnFreeze");
    return true;
    }


// unlock everything at thaw
bool STDMETHODCALLTYPE CSTSWriter::OnThaw()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::OnThaw");

    BS_ASSERT(m_pSites);

    m_pSites->UnlockSites();
    m_pSites->UnlockQuotaDatabase();
    return true;
    }



// unlock everything at abort
bool STDMETHODCALLTYPE CSTSWriter::OnAbort()
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::OnAbort");

    BS_ASSERT(m_pSites);

    m_pSites->UnlockQuotaDatabase();
    m_pSites->UnlockSites();
    return true;
    }

// prefix for dsn strings as stored in registry
static LPCWSTR s_wszDsnPrefix = L"Provider=sqloledb;Server=";

// separtor between fields in DSN string
const WCHAR x_wcDsnSeparator = L';';

// prefix for database name
static LPCWSTR s_wszDsnDbPrefix = L";Database=";
const DWORD x_cwcWriterIdPrefix = 32 + 2 + 4 + 1; // 32 nibbles + 2 braces + 4 dashes + 1 colon
                                                 // {12345678-1234-1234-1234-123456789abc}:

// check validity of dsn and break it up into its components.
bool CSTSWriter::ParseDsn
    (
    LPWSTR wszDsn,
    LPWSTR &wszServer,          // server name [out]
    LPWSTR &wszInstance,        // instance name [out]
    LPWSTR &wszDb               // database name [out]
    )
    {
    // check validity of beginning of dsn
    if (wcslen(wszDsn) <= wcslen(s_wszDsnPrefix) ||
        _wcsnicmp(wszDsn, s_wszDsnPrefix, wcslen(s_wszDsnPrefix)) != 0)
        return false;

    // skip to start of server name
    wszServer = wszDsn + wcslen(s_wszDsnPrefix);

    // search for next semicolon which is the start of the database name
    LPWSTR wszDbSection = wcschr(wszServer, x_wcDsnSeparator);

    // if not found, then dsn is invalid
    if (wszServer == NULL)
        return false;

    // make sure form of name is Database=foo
    if (wcslen(wszDbSection) <= wcslen(s_wszDsnDbPrefix) ||
        _wcsnicmp(wszDbSection, s_wszDsnDbPrefix, wcslen(s_wszDsnDbPrefix)) != 0)
        return false;

    // skip to beginning of database name
    wszDb = wszDbSection + wcslen(s_wszDsnDbPrefix);
    if (wcslen(wszDb) == 0)
        return false;

    // setup separator for server name, i.e., null out the semicolon
    // before the Database=...
    *wszDbSection = L'\0';

    // search for instance name.  Server name is form machine\instance
    wszInstance = wcschr(wszServer, L'\\');
    if (wszInstance != NULL)
        {
        // null out server name and update instance pointer
        // to point after backslash
        *wszInstance = L'\0';
        wszInstance++;

        // set instance to NULL if it is 0 length
        if (wcslen(wszInstance) == 0)
            wszInstance = NULL;
        }

    return true;
    }

// handle request for WRITER_METADATA
// implements CVssWriter::OnIdentify
bool STDMETHODCALLTYPE CSTSWriter::OnIdentify(IVssCreateWriterMetadata *pMetadata)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::OnIdentify");

    BS_ASSERT(m_pSites);

    // co task strings that need to be freed if exception is thrown
    VSS_PWSZ wszSiteName = NULL;
    VSS_PWSZ wszComponentName = NULL;
    VSS_PWSZ wszDsn = NULL;
    VSS_PWSZ wszContentRoot = NULL;
    VSS_PWSZ wszConfigRoot = NULL;
    VSS_PWSZ wszDbComponentPath = NULL;
    try
        {
        // setup restore method to restore if can replace
        ft.hr = pMetadata->SetRestoreMethod
                    (
                    VSS_RME_RESTORE_IF_CAN_REPLACE,
                    NULL,
                    NULL,
                    VSS_WRE_ALWAYS,
                    false
                    );

        ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssCreateWriterMetadata::SetRestoreMethod");

        // loop through sites adding one component for each site
        DWORD cSites = m_pSites->GetSiteCount();
        for(DWORD iSite = 0; iSite < cSites; iSite++)
            {
            do
                {
                // component name is server comment concatenated with
                // _[instance id] so if server comment for site is foo
                // and the instance id is 69105 then the component
                // name is foo_[69105]
                //
                DWORD siteId = m_pSites->GetSiteId(iSite);
                wszSiteName = m_pSites->GetSiteComment(iSite);
                WCHAR buf[32];
                swprintf(buf, L"_[%d]", siteId);

                // allocate string for component name
                wszComponentName = (VSS_PWSZ) CoTaskMemAlloc((wcslen(wszSiteName) + wcslen(buf) + 1) * sizeof(WCHAR));
                if (wszComponentName == NULL)
                    ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

                // construct component name
                wcscpy(wszComponentName, wszSiteName);
                wcscat(wszComponentName, buf);

                // get site dsn and parse it
                wszDsn = m_pSites->GetSiteDSN(iSite);
                LPWSTR wszServer, wszDb, wszInstance;

                // if site dsn is not valid, then skip component
                if (!ParseDsn(wszDsn, wszServer, wszInstance, wszDb))
                    continue;

                // only include component if server name refers to the
                // local machine
                bool bServerIsLocal = ValidateServerIsLocal(wszServer);

                // compute size of funky file name for database component
                DWORD cwcDbComponentPath = (DWORD) (wszServer ? wcslen(wszServer) : 0) + 2 + x_cwcWriterIdPrefix;
                if (wszInstance)
                    cwcDbComponentPath += (DWORD) wcslen(wszInstance) + 1;

                // allocate component name
                wszDbComponentPath = (VSS_PWSZ) CoTaskMemAlloc(cwcDbComponentPath * sizeof(WCHAR));
                if (wszDbComponentPath == NULL)
                    ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

                // fill in component path name
                // {sql id}:server\instance or
                // {sql id}:server\ or
                // {sql id}:\instance or
                // {sql id}:\
                //
                if (wszServer && wszInstance)
                    swprintf
                        (
                        wszDbComponentPath,
                        WSTR_GUID_FMT L":\\%s\\%s",
                        GUID_PRINTF_ARG(WRITERID_SqlWriter),
                        wszServer,
                        wszInstance
                        );
                else if (wszServer && wszInstance == NULL)
                    swprintf
                        (
                        wszDbComponentPath,
                        WSTR_GUID_FMT L":\\%s\\",
                        GUID_PRINTF_ARG(WRITERID_SqlWriter),
                        wszServer
                        );
                else if (wszInstance)
                    swprintf
                        (
                        wszDbComponentPath,
                        WSTR_GUID_FMT L":\\%s",
                        GUID_PRINTF_ARG(WRITERID_SqlWriter),
                        wszInstance
                        );
                else
                    swprintf
                        (
                        wszDbComponentPath,
                        WSTR_GUID_FMT L":\\",
                        GUID_PRINTF_ARG(WRITERID_SqlWriter)
                        );

                // get content root of the site
                wszContentRoot = m_pSites->GetSiteRoot(iSite);
                bool bContentIsLocal = ValidatePathIsLocal(wszContentRoot);

                // get configuration root of the site
                wszConfigRoot = m_pSites->GetSiteRoles(iSite);

                bool bConfigIsLocal = ValidatePathIsLocal(wszConfigRoot);
                bool bNonLocal = !bServerIsLocal || !bContentIsLocal || !bConfigIsLocal;

                // add component to medatadata.  comment indicates
                // whether site is local or not.  Non-local sites may not
                // be backed up
                ft.hr = pMetadata->AddComponent
                            (
                            VSS_CT_FILEGROUP,   // component type
                            NULL,               // logical path
                            wszComponentName,   // component name
                            bNonLocal ? L"!!non-local-site!!" : NULL,       // caption
                            NULL,       // icon
                            0,          // length of icon
                            TRUE,       // restore metadata
                            FALSE,      // notify on backup complete
                            TRUE        // selectable
                            );

                ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssCreateWriterMetadata::AddComponent");

                // add database as recursive component
                ft.hr = pMetadata->AddFilesToFileGroup
                            (
                            NULL,
                            wszComponentName,
                            wszDbComponentPath,
                            wszDb,
                            false,
                            NULL
                            );

                ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssCreateWriterMetadata::AddFilesToFileGroup");

                // add all files under the content root
                ft.hr = pMetadata->AddFilesToFileGroup
                            (
                            NULL,
                            wszComponentName,
                            wszContentRoot,
                            L"*",
                            true,
                            NULL
                            );

                ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssCreateWriterMetadata::AddFilesToFileGroup");

                // add all files under the appropriate directory in
                // Documents and Settings
                ft.hr = pMetadata->AddFilesToFileGroup
                            (
                            NULL,
                            wszComponentName,
                            wszConfigRoot,
                            L"*",
                            true,
                            NULL
                            );

                ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssCreateWriterMetadata::AddFilesToFileGroup");
                } while(FALSE);

            // free up memory allocated in this iteration
            VssFreeString(wszContentRoot);
            VssFreeString(wszConfigRoot);
            VssFreeString(wszDbComponentPath);
            VssFreeString(wszDsn);
            VssFreeString(wszComponentName);
            VssFreeString(wszSiteName);
            }
        }
    VSS_STANDARD_CATCH(ft)

    // free up memory in case of failure
    VssFreeString(wszContentRoot);
    VssFreeString(wszConfigRoot);
    VssFreeString(wszDbComponentPath);
    VssFreeString(wszDsn);
    VssFreeString(wszComponentName);
    VssFreeString(wszSiteName);

    if (ft.HrFailed())
        {
        TranslateWriterError(ft.hr);
        return false;
        }

    return true;
    }

// translate a sql writer error code into a writer error
void CSTSWriter::TranslateWriterError(HRESULT hr)
    {
    switch(hr)
        {
        default:
            // all other errors are treated as non-retryable
            SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            break;

        case S_OK:
            break;

        case E_OUTOFMEMORY:
        case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
        case HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES):
        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES):
            // out of resource errors
            SetWriterFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            break;

        case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
        case E_SQLLIB_TORN_DB:
        case VSS_E_OBJECT_NOT_FOUND:
        case VSS_E_OBJECT_ALREADY_EXISTS:
            // inconsistencies and other errors by the requestor
            SetWriterFailure(VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT);
            break;
        }
    }


// handle pre restore event
bool STDMETHODCALLTYPE CSTSWriter::OnPreRestore
    (
    IN IVssWriterComponents *pWriter
    )
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::OnPreRestore");

    BS_ASSERT(m_pSites);

    // co task allocated strings that need to be freed if an
    // exception is thrown
    VSS_PWSZ wszMetadataForSite = NULL;
    VSS_PWSZ wszContentRoot = NULL;

    // component is at toplevel scope since it will be used to set
    // failure message in failure case
    CComPtr<IVssComponent> pComponent;

    try
        {
        UINT cComponents;
        ft.hr = pWriter->GetComponentCount(&cComponents);
        ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssWriterComponents::GetComponentCount");

        // if no components, then just return immediately
        if (cComponents == 0)
            return true;

        // loop through components
        for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
            {
            ft.hr = pWriter->GetComponent(iComponent, &pComponent);
            ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssWriterComponents::GetComponent");

            bool bSelectedForRestore;
            ft.hr = pComponent->IsSelectedForRestore(&bSelectedForRestore);
            ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssComponent::IsSelectedForRestore");

            if (!bSelectedForRestore)
                {
                // if component is not selected for restore, then
                // skip it
                pComponent = NULL;
                continue;
                }


            // validate component type
            VSS_COMPONENT_TYPE ct;
            ft.hr = pComponent->GetComponentType(&ct);
            ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssComponent::GetComponentType");

            if (ct != VSS_CT_FILEGROUP)
                ft.Throw(VSSDBG_STSWRITER, VSS_E_WRITERERROR_NONRETRYABLE, L"requesting a non-database component");

            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;

            ft.hr = pComponent->GetLogicalPath(&bstrLogicalPath);
            ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssComponent::GetLogicalPath");

            // validate that no logical path is provided
            if (bstrLogicalPath && wcslen(bstrLogicalPath) != 0)
                ft.Throw(VSSDBG_STSWRITER, VSS_E_OBJECT_NOT_FOUND, L"STS components do not have logical paths");

            // get component name
            ft.hr = pComponent->GetComponentName(&bstrComponentName);
            ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssComponent::GetComponentName");
            DWORD iSite;
            STSSITEPROBLEM problem;

            // validate that the component name is valid
            if (!ParseComponentName(bstrComponentName, iSite, problem))
                SetSiteInvalid(pComponent, bstrComponentName, problem);

            // build metadata for the site
            wszMetadataForSite = BuildSiteMetadata(iSite);
            CComBSTR bstrMetadataForComponent;

            // get metadata for site saved when the site was backed up
            ft.hr = pComponent->GetBackupMetadata(&bstrMetadataForComponent);
            ft.CheckForErrorInternal(VSSDBG_STSWRITER, L"IVssComponent::GetBackupMetadata");

            // validate that metadata is identical.  If not, then figure
            // out what changed
            if (_wcsicmp(wszMetadataForSite, bstrMetadataForComponent) != 0)
                SetSiteMetadataMismatch(pComponent, bstrMetadataForComponent, wszMetadataForSite);

            // get content root for site
            wszContentRoot = m_pSites->GetSiteRoot(iSite);

            // try emptying contents from the content root
            ft.hr = RemoveDirectoryTree(wszContentRoot);
            if (ft.HrFailed())
                SetRemoveFailure(pComponent, wszContentRoot, ft.hr);

            // set component to null in preparation of moving to next
            // component
            pComponent = NULL;
            }
        }
    VSS_STANDARD_CATCH(ft)

    CoTaskMemFree(wszContentRoot);
    CoTaskMemFree(wszMetadataForSite);
    if (ft.HrFailed() && pComponent != NULL)
        SetPreRestoreFailure(pComponent, ft.hr);

    return !ft.HrFailed();
    }

// indicate that a site cannot be restored because the site referred to is invalid
void CSTSWriter::SetSiteInvalid
    (
    IVssComponent *pComponent,
    LPCWSTR wszSiteName,
    STSSITEPROBLEM problem
    )
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::SetSiteInvalid");

    WCHAR buf[512];
    LPCWSTR wszSiteError;

    switch(problem)
        {
        default:
        case STSP_SYNTAXERROR:
            wszSiteError = L"Syntax error in site name";
            break;

        case STSP_SITENOTFOUND:
            wszSiteError = L"Site does not exist on this machine";
            break;

        case STSP_SITENAMEMISMATCH:
            wszSiteError = L"Site name does not match the server comment for the IIS Web Server: ";
            break;

        case STSP_SITEDSNINVALID:
            wszSiteError = L"Site has an invalid Database DSN: ";
            break;

        case STSP_SQLSERVERNOTLOCAL:
            wszSiteError = L"Database for the site is not local: ";
            break;

        case STSP_CONTENTNOTLOCAL:
            wszSiteError = L"IIS Web Server root is not local: ";
            break;

        case STSP_CONFIGNOTLOCAL:
            wszSiteError = L"Sharepoint Site Configuration is not local: ";
            break;
        }

    wcscpy(buf, L"Problem with site specified in component -- ");
    wcscat(buf, wszSiteError);
    if (wcslen(wszSiteName) < 256)
        wcscat(buf, wszSiteName);
    else
        {
        DWORD cwc = (DWORD) wcslen(buf);
        memcpy(buf + cwc, wszSiteName, 256 * sizeof(WCHAR));
        *(buf + cwc + 256) = L'\0';
        wcscat(buf, L"...");
        }

    pComponent->SetPreRestoreFailureMsg(buf);
    SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
    ft.Throw(VSSDBG_STSWRITER, VSS_E_WRITERERROR_NONRETRYABLE, L"site can't be restored");
    }


// indicate that a site cannot be restored because its DSN, content,
// or config roots mismatch
void CSTSWriter::SetSiteMetadataMismatch
    (
    IVssComponent *pComponent,
    LPWSTR wszMetadataBackup,
    LPWSTR wszMetadataRestore
    )
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::SetSiteMetadataMismatch");

    // seach for end of server name in metadata
    LPWSTR pwcB = wcschr(wszMetadataBackup, L';');
    LPWSTR pwcR = wcschr(wszMetadataRestore, L';');
    try
        {
        if (pwcB == NULL)
            ft.Throw(VSSDBG_STSWRITER, VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ATTRIBUTE, L"backup metadata is corrupt");


        BS_ASSERT(pwcR != NULL);

        // compute size of server name
        DWORD cwcB = (DWORD) (pwcB - wszMetadataBackup);
        DWORD cwcR = (DWORD) (pwcR - wszMetadataRestore);
        do
        	{
	        if (cwcB != cwcR ||
	            _wcsnicmp(wszMetadataBackup, wszMetadataRestore, cwcB) != 0)
	            {
	            // server/instance name differs
	            LPWSTR wsz = new WCHAR[cwcB + cwcR + 256];
	            if (wsz == NULL)
	                // memory allocation failure, just try saving a simple error message
	                pComponent->SetPreRestoreFailureMsg(L"Mismatch between backup and restore [Server/Instance].");
	            else
	                {
	                // indicate that server/instance name mismatches
	                wcscpy(wsz, L"Mismatch between backup and restore[Server/Instance]: Backup=");
	                DWORD cwc1 = (DWORD) wcslen(wsz);

	                // copy in server/instance from backup components document
	                memcpy(wsz + cwc1, wszMetadataBackup, cwcB * sizeof(WCHAR));
	                wsz[cwc1 + cwcB] = L'\0';

	                // copy in server/instance from current site
	                wcscat(wsz, L", Restore=");
	                cwc1 = (DWORD) wcslen(wsz);
	                memcpy(wsz + cwc1, wszMetadataRestore, cwcR * sizeof(WCHAR));
	                wsz[cwc1 + cwcR] = L'\0';
	                pComponent->SetPreRestoreFailureMsg(wsz);
	                delete wsz;
	                }

	            continue;
	            }

	        pwcB++;
	        pwcR++;
	        if (!compareNextMetadataString
	                (
	                pComponent,
	                pwcB,
	                pwcR,
	                L"Sharepoint database name"
	                ))
	            continue;

	        if (!compareNextMetadataString
	                (
	                pComponent,
	                pwcB,
	                pwcR,
	                L"IIS Web site root"
	                ))
	            continue;

	        compareNextMetadataString
	            (
	            pComponent,
	            pwcB,
	            pwcR,
	            L"Sharepoint site configuration"
	            );
        	}while (false);
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.hr == VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ATTRIBUTE)
        {
        // indication that the backup metadata is corrupt
        WCHAR *pwcT = new WCHAR[64 + wcslen(wszMetadataBackup)];
        if (pwcT == NULL)
            pComponent->SetPreRestoreFailureMsg(L"Backup metadata is corrupt.");
        else
            {
            // if we are able to allocate room for metadata, then include it
            // in string
            wcscpy(pwcT, L"Backup metadata is corrupt.  Metadata = ");
            wcscat(pwcT, wszMetadataBackup);
            pComponent->SetPreRestoreFailureMsg(pwcT);
            delete pwcT;
            }
        }

    // indicate that the error is not-retryable since the site has changed
    SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
    ft.Throw(VSSDBG_STSWRITER, VSS_E_WRITERERROR_NONRETRYABLE, L"site can't be restored");
    }

// compare a component of the metadata string.  Each component begins
// with a 4 digit hex number which is the length of the component string
// that follows.
bool CSTSWriter::compareNextMetadataString
    (
    IVssComponent *pComponent,
    LPWSTR &pwcB,
    LPWSTR &pwcR,
    LPCWSTR wszMetadataComponent
    )
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::compareNextMetadataString");
    DWORD cwcB, cwcR;
    if (swscanf(pwcB, L"%04x", &cwcB) != 1)
        ft.Throw(VSSDBG_STSWRITER, VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ATTRIBUTE, L"invalid backup metadata");

    BS_VERIFY(swscanf(pwcR, L"%04x", &cwcR) == 1);
    if (cwcR != cwcB ||
        _wcsnicmp(pwcB + 4, pwcR + 4, cwcB) != 0)
        {
        LPWSTR wsz = new WCHAR[cwcB + cwcR + wcslen(wszMetadataComponent) + 256];
        if (wsz == NULL)
            {
            WCHAR buf[256];
            swprintf(buf, L"Mismatch between backup and restore[%s]", wszMetadataComponent);
            pComponent->SetPreRestoreFailureMsg(buf);
            }
        else
            {
            swprintf(wsz, L"Mismatch between backup and restore[%s]: Backup=", wszMetadataComponent);
            DWORD cwc1 = (DWORD) wcslen(wsz);

            // copy in backup component value
            memcpy(wsz + cwc1, pwcB + 4, cwcB * sizeof(WCHAR));
            wsz[cwc1 + cwcB] = L'\0';
            wcscat(wsz, L", Restore=");
            cwc1 = (DWORD) wcslen(wsz);

            // copy in restore component value
            memcpy(wsz + cwc1, pwcR + 4, cwcR * sizeof(WCHAR));
            wsz[cwc1 + cwcR] = L'\0';
            pComponent->SetPreRestoreFailureMsg(wsz);
            delete wsz;
            }

        return false;
        }

    // skip past component name
    pwcB += 4 + cwcB;
    pwcR += 4 + cwcR;
    return true;
    }



// indicate that a site could not be restored because its content root
// could not be completely deleted.
void CSTSWriter::SetRemoveFailure
    (
    IVssComponent *pComponent,
    LPCWSTR wszContentRoot,
    HRESULT hr
    )
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::SetRemoveFailure");

    WCHAR buf[256];

    wprintf(buf, L"PreRestore failed due to error removing files from the IIS Web Site Root %s due to error: hr = 0x%08lx", wszContentRoot, hr);
    pComponent->SetPreRestoreFailureMsg(buf);
    SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
    ft.Throw(VSSDBG_STSWRITER, VSS_E_WRITERERROR_NONRETRYABLE, L"site can't be restored");
    }


// indicate a general failure that causes the PreRestore of a component
// to fail
void CSTSWriter::SetPreRestoreFailure(IVssComponent *pComponent, HRESULT hr)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::SetPreRestoreFailure");

    // if error is set to NONRETRYABLE then we have already set the
    // prerestore failure message and are done
    if (ft.hr != VSS_E_WRITERERROR_NONRETRYABLE)
        return;

    CComBSTR bstr;
    ft.hr = pComponent->GetPreRestoreFailureMsg(&bstr);
    if (!bstr)
        {
        WCHAR buf[256];
        swprintf(buf, L"PreRestore failed with error. hr = 0x%08lx", hr);
        ft.hr = pComponent->SetPreRestoreFailureMsg(buf);
        }

    SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
    }

const DWORD x_cFormats = 8;
static const COMPUTER_NAME_FORMAT s_rgFormats[x_cFormats] =
    {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified
    };


// determine if a SQL Server is on the local machine
bool CSTSWriter::ValidateServerIsLocal(LPCWSTR wszServer)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::ValidateServerIsLocal");

    if (_wcsicmp(wszServer, L"local") == 0 ||
        _wcsicmp(wszServer, L"(local)") == 0)
        return true;

    LPWSTR wsz = new WCHAR[MAX_COMPUTERNAME_LENGTH];
    if (wsz == NULL)
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

    DWORD cwc = MAX_COMPUTERNAME_LENGTH;

    for(DWORD iFormat = 0; iFormat < x_cFormats; iFormat++)
        {
        if (!GetComputerNameEx(s_rgFormats[iFormat], wsz, &cwc))
            {
            if (GetLastError() != ERROR_MORE_DATA)
                continue;

            delete wsz;
            wsz = new WCHAR[cwc + 1];
            if (wsz == NULL)
                ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

            if (!GetComputerNameEx(s_rgFormats[iFormat], wsz, &cwc))
                continue;
            }

        if (_wcsicmp(wsz, wszServer) == 0)
            {
            delete wsz;
            return true;
            }
        }

    delete wsz;
    return false;
    }

// determine whether a path is on the local machine or not
bool CSTSWriter::ValidatePathIsLocal(LPCWSTR wszPath)
    {
    CVssFunctionTracer ft(VSSDBG_STSWRITER, L"CSTSWriter::ValidatePathIsLocal");

    // get full path from supplied path
    ULONG ulMountpointBufferLength = GetFullPathName (wszPath, 0, NULL, NULL);

    LPWSTR pwszMountPointName = new WCHAR[ulMountpointBufferLength * sizeof (WCHAR)];

    if (pwszMountPointName == NULL)
        ft.Throw(VSSDBG_STSWRITER, E_OUTOFMEMORY, L"out of memory");

    BOOL fSuccess = FALSE;
    if (GetVolumePathName(wszPath, pwszMountPointName, ulMountpointBufferLength))
        {
        WCHAR wszVolumeName[MAX_PATH];
        fSuccess = GetVolumeNameForVolumeMountPoint(pwszMountPointName, wszVolumeName, sizeof (wszVolumeName) / sizeof (WCHAR));
        }

    delete pwszMountPointName;
    return fSuccess ? true : false;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\tracing\bsfixalloc.cxx ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bsfixalloc.cxx

Abstract:

    Adapted from MFC 6 SR 1 release of fixalloc.cpp.  Removed all MFC stuff.

Author:

    Stefan R. Steiner   [ssteiner]        4-10-2000

Revision History:

--*/

// fixalloc.cpp - implementation of fixed block allocator

#include <windows.h>
#include <assert.h>
#include "bsfixalloc.hxx"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

// #define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CBsFixedAlloc

CBsFixedAlloc::CBsFixedAlloc(UINT nAllocSize, UINT nBlockSize)
{
	assert(nAllocSize >= sizeof(CNode));
	assert(nBlockSize > 1);
    //wprintf( L"CBsFixedAlloc called, nAllocSize: %d, nBlockSize: %d\n", nAllocSize, nBlockSize );
	m_nAllocSize = nAllocSize;
	m_nBlockSize = nBlockSize;
	m_pNodeFree = NULL;
	m_pBlocks = NULL;
	InitializeCriticalSection(&m_protect);
}

CBsFixedAlloc::~CBsFixedAlloc()
{
	FreeAll();
	DeleteCriticalSection(&m_protect);
}

void CBsFixedAlloc::FreeAll()
{
	EnterCriticalSection(&m_protect);
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
	m_pNodeFree = NULL;
	LeaveCriticalSection(&m_protect);
}

void* CBsFixedAlloc::Alloc()
{
	EnterCriticalSection(&m_protect);
	if (m_pNodeFree == NULL)
	{
		CBsPlex* pNewBlock = NULL;
		try
		{
			// add another block
			pNewBlock = CBsPlex::Create(m_pBlocks, m_nBlockSize, m_nAllocSize);
            //wprintf( L"Alloc getting more core, nAllocSize: %d\n", m_nAllocSize );
		}
		catch( ... )
		{
			LeaveCriticalSection(&m_protect);
			throw;
		}

		// chain them into free list
		CNode* pNode = (CNode*)pNewBlock->data();
		// free in reverse order to make it easier to debug
		(BYTE*&)pNode += (m_nAllocSize * m_nBlockSize) - m_nAllocSize;
		for (int i = m_nBlockSize-1; i >= 0; i--, (BYTE*&)pNode -= m_nAllocSize)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	assert(m_pNodeFree != NULL);  // we must have something

	// remove the first available node from the free list
	void* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;

	LeaveCriticalSection(&m_protect);
	return pNode;
}

void CBsFixedAlloc::Free(void* p)
{
	if (p != NULL)
	{
		EnterCriticalSection(&m_protect);

		// simply return the node to the free list
		CNode* pNode = (CNode*)p;
		pNode->pNext = m_pNodeFree;
		m_pNodeFree = pNode;
		LeaveCriticalSection(&m_protect);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBsPlex
// throws E_OUTOFMEMORY

CBsPlex* PASCAL CBsPlex::Create(CBsPlex*& pHead, UINT nMax, UINT cbElement)
{
	assert(nMax > 0 && cbElement > 0);
	CBsPlex* p = (CBsPlex*) new BYTE[sizeof(CBsPlex) + nMax * cbElement];
	if ( p == NULL )    //  prefix #118827
	    throw E_OUTOFMEMORY;
	
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CBsPlex::FreeDataChain()     // free this one and links
{
	CBsPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CBsPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\tracing\vs_sku.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_sku.cxx

Abstract:

    This module defines the global SKU information implementation. 
	
Author:


Revision History:
	Name		Date		Comments
    ssteiner    05/01/01    Created file
    
--*/

//
//  ***** Includes *****
//

#pragma warning(disable:4290)
#pragma warning(disable:4127)

#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <vssmsg.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"

#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>
#include <ntverp.h>


#include "vs_inc.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCSKUC"
//
////////////////////////////////////////////////////////////////////////

BOOL CVssSKU::ms_bInitialized = FALSE;
CVssSKU::EVssSKUType CVssSKU::ms_eSKU = VSS_SKU_INVALID;
BOOL CVssSKU::ms_bTransportableShadowsAllowed = FALSE;

VOID CVssSKU::Initialize()
{
    if ( ms_bInitialized ) 
        return;

    //  Determine the SKU...
    OSVERSIONINFOEXW sOSV;
    sOSV.dwOSVersionInfoSize = sizeof OSVERSIONINFOEXW;
    if ( !::GetVersionExW( (LPOSVERSIONINFO)&sOSV ) )
    {
        ms_eSKU = VSS_SKU_INVALID;  //  Problem.  The tracing class will print out a trace message flagging this.    
        ms_bInitialized = TRUE;
    }
    
    if ( sOSV.wProductType == VER_NT_DOMAIN_CONTROLLER || sOSV.wProductType == VER_NT_SERVER )
    {            
        if ( sOSV.wSuiteMask & VER_SUITE_EMBEDDEDNT )
            ms_eSKU = VSS_SKU_NAS;
        else
            ms_eSKU = VSS_SKU_SERVER;

        // For Advanced Server or Datacenter allow transportable shadow copies
        if (( sOSV.wSuiteMask & VER_SUITE_ENTERPRISE) || ( sOSV.wSuiteMask & VER_SUITE_DATACENTER))
            ms_bTransportableShadowsAllowed = TRUE;
    }
    else if ( sOSV.wProductType == VER_NT_WORKSTATION )
        ms_eSKU = VSS_SKU_CLIENT;
    else
        ms_eSKU = VSS_SKU_INVALID;  //  Problem.  THe tracing class will print out a trace message flagging this.
    
    ms_bInitialized = TRUE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\tracing\vs_trace.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_trace.cxx

Abstract:

    This module defines the global debug\trace facilities used by the
	Long Term Storage service.
	
	Previous name: bsdebug.cxx

Author:


Revision History:
	Name		Date		Comments
    ssteiner    06/03/98    Made numerious changes and removed iostream
                            dependencies, added a few new registry entries and
                            added serialization.
	aoltean		06/06/99	Taken from atl30\atlbase.h in order to avoid linking ATL with BSCommon.lib
    ssteiner    05/15/00    Fixed bug #116688.  Added file locking to prevent multiple processes from
                            interferring with writing to the trace file.  Added code to place a UNICODE
                            BOM at the beginning of the trace file.
--*/

//
//  ***** Includes *****
//

#pragma warning(disable:4290)
#pragma warning(disable:4127)

#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <vssmsg.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>
#include <ntverp.h>
#include <comadmin.h>

// SEH disabling (from nt\internal\com)
#include <globalopt.h>


#include "vs_inc.hxx"
#include "vs_idl.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCTRCC"
//
////////////////////////////////////////////////////////////////////////

//
//  The following global, g_cDbgTrace must be declared BEFORE any of our
//  objects including _Module, since some of our static objects have destructors
//  that call trace methods.  The following pragma ensures that this
//  module's static objects are initialized before any of our other
//  static objects, assuming they don't use this same pragma.
//
#pragma warning(disable:4073) // ignore init_seg warning
#pragma init_seg(lib)


CBsDbgTrace g_cDbgTrace;


static VOID MakeFileUnicode(
    IN HANDLE hFile
    );

/////////////////////////////////////////////////////////////////////////////
// constants
//

const WCHAR	VSS_TRACINGKEYPATH[]	=
			L"SYSTEM\\CurrentControlSet\\Services\\VSS\\Debug\\Tracing";

const WCHAR	SETUP_KEY[]	=
			L"SYSTEM\\Setup";

const WCHAR	SETUP_INPROGRESS_REG[]	=
			L"SystemSetupInProgress";

const DWORD SETUP_INPROGRESS_VALUE = 1;

const x_nMaxCoCreateInstanceRetries = 10;


/////////////////////////////////////////////////////////////////////////////
//  Globals
//

//
//  NOTE: g_cDbgTrace, the global instance of this class is declared in
//  ltss\modules\ltssvc\src\ltssvc.cxx since we have to make sure
//  this object is the last one being destructed, otherwise possible
//  calls to this object will fail.
//

//
// Define a TLS var, stores the CLTermStg & intention list index.
// The index is a counter that is incremented and set for each thread
// coming into the service, in the CLTermStg::FinalConstruct method.
// The counter is also incremented and set for each intention list
// thread that is created by the service.
//
//  WARNING
//
//
//_declspec( thread ) DWORD CBsDbgTrace::m_dwContextNum = 0;

//
//  Queries a registry value name and if found sets dwValue to the value.
//  If the value name is not found, dwValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    IN OUT DWORD &dwValue,
    IN LPCWSTR pwszValueName
    )
{
    DWORD dwReadValue = 0;
    DWORD dwResult = cRegKey.QueryValue( dwReadValue, pwszValueName );
    
    if ( dwResult == ERROR_SUCCESS )
        dwValue = dwReadValue;

    return dwResult;
}

//
//  Queries a registry value name and if found sets bValue to the value.
//  If the value name is not found, bValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    IN OUT BOOL &bValue,
    IN LPCWSTR pwszValueName
    )
{
    DWORD dwReadValue = 0;
    DWORD dwResult = cRegKey.QueryValue( dwReadValue, pwszValueName );

    if ( dwResult == ERROR_SUCCESS )
        bValue = (BOOL)(dwReadValue != 0);

    return dwResult;
}

//
//  Queries a registry value name and if found sets wsValue to the value.
//  If the value name is not found, wsValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    OUT LPWSTR &wsValue, // If allocated, must be freed before calling with ::VssFreeString
    IN LPCWSTR pwszValueName
    )
{
	WCHAR pszValueBuffer[_MAX_PATH];
    DWORD dwCount = _MAX_PATH;
    DWORD dwResult = cRegKey.QueryValue( pszValueBuffer, pwszValueName, &dwCount );

    BS_ASSERT(wsValue == NULL);
    if ( dwResult == ERROR_SUCCESS ) 
        ::VssDuplicateStr(wsValue, pszValueBuffer);

    return dwResult;
}

//
//  ***** class definitions *****
//


CBsDbgTrace::CBsDbgTrace()

/*++

Routine Description:

    Constructor method. Default values are given to operational
    parameters and overwritten using values from the registry if
    set.  Also prints out the trace file banner.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
	m_bInitialized = false;
	m_bTracingEnabled = false;
	m_pcs = NULL;
    Initialize( TRUE );
}


CBsDbgTrace::~CBsDbgTrace()
/*++

Routine Description:

    Destructor method.  Prints out the last record in the NTMS


Arguments:

	LONG Indent - NOT USED YET [todo] this is the indentation indicator
	LONG Level - this is the debug trace level

Return Value:

    BOOL

--*/
{
    if ( !m_bInitialized )
        return;

    if ( m_bTracingEnabled ) {
        //
        //  Write out a finished tracing message
        //
        m_pcs->Enter();
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  TRACING FINISHED - ProcessId: 0x%x, ContextId: 0x%x",
            m_dwCurrentProcessId, m_dwContextId ) );
        WCHAR pwszCurrentTime[128] = L"";
        time_t ltime;
        time( &ltime );
        struct tm * pToday = localtime( &ltime );
		if (pToday) {
			if (0 == wcsftime( pwszCurrentTime, SIZEOF_ARRAY(pwszCurrentTime), L"%c", pToday ))
			    pwszCurrentTime[0] = L'\0';
		}
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Current time: %s", pwszCurrentTime ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Elapsed time: %d seconds", ltime- m_lTimeStarted ) );
   	    BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Command-line: %s", GetCommandLineW() ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
        m_pcs->Leave();

        //
        //  Make sure the file is flushed before leaving
        //
        if ( m_bTraceToFile ) {
            m_hTraceFile = ::CreateFile( m_pwszTraceFileName?
                                            m_pwszTraceFileName :
                                            BS_DBG_TRACE_FILE_NAME_DFLT,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );
            if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
                ::FlushFileBuffers( m_hTraceFile );
                ::CloseHandle( m_hTraceFile );
                m_hTraceFile = INVALID_HANDLE_VALUE;
            }
        }
    }

    ::VssFreeString(m_pwszTraceFileName);

    //
    //  Delete the critical section
    //
    delete m_pcs;
    m_pcs = NULL;
    m_bInitialized = FALSE;
}

//
//  In certain cases the global trace object doesn't seem to get it's constructor called.
//  To fix this problem, this function was added to perform the initialization of the
//  object.  This function is called both in the constructor and the set context call
//  which all DLLs that use the trace class call.
//
VOID
CBsDbgTrace::Initialize(
    IN  BOOL bInConstructor
    )
{
    if ( !m_bInitialized )
    {
		try
			{
			//
			//  Get the critical section created first
			//
			m_pcs = new CBsCritSec;
			if ( m_pcs == NULL )
				throw E_OUTOFMEMORY;
			m_bInitialized = TRUE;

			m_bTracingEnabled       = FALSE;
			m_bTraceToFile          = BS_DBG_TRACE_TO_FILE_DFLT;
			m_bTraceToDebugger      = BS_DBG_TRACE_TO_DEBUGGER_DFLT;
			m_bTraceEnterExit       = BS_DBG_TRACE_ENTER_EXIT_DFLT;
			m_dwTraceLevel          = BS_DBG_TRACE_LEVEL_DFLT;
			m_bTraceFileLineInfo    = BS_DBG_TRACE_FILE_LINE_INFO_DFLT;
			m_bTraceTimestamp       = BS_DBG_TRACE_TIMESTAMP_DFLT;
			m_pwszTraceFileName     = NULL;
			m_bForceFlush           = BS_DBG_TRACE_FORCE_FLUSH_DFLT;
			m_dwTraceIndent         = 0;
			m_bInTrace              = FALSE;
			m_hTraceFile            = INVALID_HANDLE_VALUE;
			m_dwLineNum             = 0;
			m_dwCurrentProcessId    = GetCurrentProcessId();
			m_bIsDuringSetup        = FALSE;
			
			LARGE_INTEGER liTimer;
			if ( ::QueryPerformanceCounter( &liTimer ) )
				{
				//  Got high performance counter, use the low part
				m_dwContextId = liTimer.LowPart;
				}
			else
				{
				m_dwContextId = ::GetTickCount();
				}

			ReadRegistry();

			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  TRACING STARTED - ProcessId: 0x%x, ContextId: 0x%x",
				m_dwCurrentProcessId, m_dwContextId ) );
			if ( !bInConstructor )
				BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  N.B. NOT INITIALIZED BY THE CONSTRUCTOR" ) );

			WCHAR pwszCurrentTime[128] = L"";
			time( &m_lTimeStarted );
            struct tm * pToday = localtime( &m_lTimeStarted );
			if (pToday) {
    			if (0 == wcsftime( pwszCurrentTime, SIZEOF_ARRAY(pwszCurrentTime), L"%c", pToday ))
    			    pwszCurrentTime[0] = L'\0';
			}
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Current time: %s", pwszCurrentTime ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Command-line: %s", GetCommandLineW() ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Product version: %d.%d.%d.%d", VER_PRODUCTVERSION ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  VSS SKU ID: 0x%02x", (UINT)CVssSKU::GetSKU() ) );			
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );

			if ( CVssSKU::GetSKU() == CVssSKU::VSS_SKU_INVALID )
    			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"ERROR: Unable to determine the Windows SKU" ) );			    
			}
		catch(...)
			{
			delete m_pcs;
			m_pcs = NULL;
			m_bInitialized = false;
			m_bTracingEnabled = false;
			}
		}

}


BOOL
CBsDbgTrace::IsDuringSetup()
{
    return m_bIsDuringSetup;
}



HRESULT
CBsDbgTrace::ReadRegistry()
/*++

Routine Description:

    Tries to read debug specific values from the registry and adds
    the values if they don't exist.

Arguments:

    NONE

Return Value:

    HRESULT

--*/
{

	DWORD dwRes;
	CRegKey cRegKeySetup;
	CRegKey cRegKeyTracing;


    m_bTracingEnabled = FALSE;
    m_bIsDuringSetup = FALSE;
    
	//
	// Open the Setup key
	//

	dwRes = cRegKeySetup.Open( HKEY_LOCAL_MACHINE, SETUP_KEY, KEY_READ );
	if ( dwRes == ERROR_SUCCESS ) {
        DWORD dwSetupInProgress = 0;
        QuerySetValue( cRegKeySetup, dwSetupInProgress, SETUP_INPROGRESS_REG );
        m_bIsDuringSetup = ( dwSetupInProgress == SETUP_INPROGRESS_VALUE );
	}
	
	//
	// Open the VSS tracing key
	//

	dwRes = cRegKeyTracing.Open( HKEY_LOCAL_MACHINE, VSS_TRACINGKEYPATH, KEY_READ );
	if ( dwRes == ERROR_SUCCESS ) {
		
        // The name of the optional trace file
        QuerySetValue( cRegKeyTracing, m_pwszTraceFileName, BS_DBG_TRACE_FILE_NAME_REG );

        // The trace level determines what type of traciung will occur. Zero
        // indicates that no tracing will occur, and is the default.
        QuerySetValue( cRegKeyTracing, m_dwTraceLevel, BS_DBG_TRACE_LEVEL_REG );

        // The TraceEnterExit flag determines whether or not function entry & exit
        // information is output to the trace file & the debug output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceEnterExit, BS_DBG_TRACE_ENTER_EXIT_REG );

        // The TraceToFile flag determines whether or not trace information is output to
        // the trace file. If this value is FALSE, no output is sent to the trace file.
        QuerySetValue( cRegKeyTracing, m_bTraceToFile, BS_DBG_TRACE_TO_FILE_REG );

        // The TraceToDebugger flag determines whether or not trace information is output
        // to the debugger. If this value is FALSE, no output is sent to the debugger.
        QuerySetValue( cRegKeyTracing, m_bTraceToDebugger, BS_DBG_TRACE_TO_DEBUGGER_REG );

        // The Timestamp flag determines whether or not timestamp
        // information is output to the trace file & the debug output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceTimestamp, BS_DBG_TRACE_TIMESTAMP_REG );

        // The FileLineInfo flag determines whether or not the module file name
        // and line number information is output to the trace file & the debug
        // output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceFileLineInfo, BS_DBG_TRACE_FILE_LINE_INFO_REG );

        // The TraceForceFlush flag specifies whether or not after each trace message is
        // written to the trace file a forced flush occurs.  If enabled, no trace records
        // are ever lost, however, performance is greatly reduced.
        QuerySetValue( cRegKeyTracing, m_bForceFlush, BS_DBG_TRACE_FORCE_FLUSH_REG );

        // Determine if tracing should be enabled
        if ( m_bTraceToDebugger || m_bTraceToFile )
            m_bTracingEnabled = TRUE;

	}

    return S_OK;
}


HRESULT
CBsDbgTrace::PrePrint(
    IN LPCWSTR pwszSourceFileName,
    IN DWORD dwLineNum,
    IN DWORD dwIndent,
    IN DWORD dwLevel,
    IN LPCWSTR pwszFunctionName,
    IN BOOL bTraceEnter
    )
/*++

Routine Description:

    Acquires the critical section so that other threads are
    now serialized.  Opens the trace file if necessary.
    N.B. Any A/V's in this code can cause a hang since the SEH translator function
    calls these trace functions.

Arguments:

    pszSourceFileName - Source file name of the module whose
        code called this method.
    dwLineNum - Line number in the source
    dwIndent - Number to increase or decrease the indendation level
    dwLevel - Trace level that specifies for which component
        the code resides in.
    pwszFunctionName - For entry/exit tracing.  Specifies the
        function name constains a call the a trace macro.
    bTraceEnter - True if this is a entry trace.

Return Value:

    HRESULT

--*/
{
    m_pcs->Enter();

    //
    //  Assume the trace macros have already filtered out traces based
    //  on m_bTracingEnabled and on the active trace level.
    //

    if ( m_bTracingEnabled && (dwLevel & m_dwTraceLevel) != 0) {
        if ( pwszSourceFileName == NULL )
            m_pwszSourceFileName = L"(Unknown source file)";
        else
        {
            //
            //  Keep only two levels deep of directory components
            //
            LPCWSTR pwszTemp = pwszSourceFileName + ::wcslen( pwszSourceFileName ) - 1;
            for ( int i = 0; pwszTemp > pwszSourceFileName && i < 3; ++i )
            {
                do
                {
                    --pwszTemp;
                }
                while( *pwszTemp != L'\\' && pwszTemp > pwszSourceFileName ) ;
            }
            if ( pwszTemp > pwszSourceFileName )
                m_pwszSourceFileName = pwszTemp + 1;
            else
                m_pwszSourceFileName = pwszSourceFileName;
        }

        m_pwszFunctionName   = pwszFunctionName;
        m_dwLineNum        = dwLineNum;
        m_bTraceEnter      = bTraceEnter;

        BS_ASSERT( m_hTraceFile == INVALID_HANDLE_VALUE );

        if ( m_bTraceToFile ) {
            m_hTraceFile = ::CreateFile( m_pwszTraceFileName?
                                            m_pwszTraceFileName :
                                            BS_DBG_TRACE_FILE_NAME_DFLT,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );
            if ( m_hTraceFile == INVALID_HANDLE_VALUE ) {
                //
                //  Error opening the file, print a message to the debugger if debugger
                //  tracing is enabled
                //
                Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to open trace file, dwRet: %u", ::GetLastError() );
            } else {
                //
                //  Now lock the process from other processes and threads that are concurrently
                //  accessing the file.  Just lock the first byte of the file.
                //
                OVERLAPPED ovStart = { NULL, NULL, { 0, 0 }, 0 };
                if ( !::LockFileEx( m_hTraceFile,
                                    LOCKFILE_EXCLUSIVE_LOCK,
                                    0,
                                    1,
                                    0,
                                    &ovStart ) ) {
                    //
                    //  Tracing to file will be skipped for this record.  This should
                    //  never happen in practice.
                    //
                    ::CloseHandle( m_hTraceFile );
                    m_hTraceFile = INVALID_HANDLE_VALUE;

                    //
                    //  Try printing a trace message that will get to the debugger if debugger
                    //  tracing is enabled
                    //
                    Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to lock trace file, skipping trace record, dwRet: %u", ::GetLastError() );
                } else {
                    //
                    //  If the file is new (empty) put the UNICODE BOM at the beginning of the file
                    //
                    LARGE_INTEGER liPointer;
                    if ( ::GetFileSizeEx( m_hTraceFile, &liPointer ) ) {
                        if ( liPointer.QuadPart == 0 )
                            ::MakeFileUnicode( m_hTraceFile );
                    }

                    //
                    //  Now move the file pointer to the end of the file
                    //
                    liPointer.QuadPart = 0;
                    if ( !::SetFilePointerEx( m_hTraceFile,
                                              liPointer,
                                              NULL,
                                              FILE_END ) ) {
                        //
                        //  Don't write to the file since it might overwrite valid records.
                        //  Tracing to file will be skipped for this record.  This should
                        //  never happen in practice.
                        //
                        ::CloseHandle( m_hTraceFile );
                        m_hTraceFile = INVALID_HANDLE_VALUE;

                        //
                        //  Try printing a trace message that will get to the debugger if debugger
                        //  tracing is enabled
                        //
                        Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to set end of file, skipping trace record, dwRet: %u", ::GetLastError() );
                    }
                }
            }
        }

        m_bInTrace = TRUE;
    }

    return S_OK;
    UNREFERENCED_PARAMETER( dwIndent );
}

HRESULT
CBsDbgTrace::PostPrint(
    IN DWORD dwIndent
    )
/*++

Routine Description:

    Releases the critical section so that other threads
    can now call perform tracing.  Closes the trace file
    and resets variables.

Arguments:

    dwIndent - Number to increase or decrease the indendation level

Return Value:

    HRESULT

--*/
{
    if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
        OVERLAPPED ovStart = { NULL, NULL, { 0, 0 }, 0 };
        if ( !::UnlockFileEx( m_hTraceFile,
                              0,
                              1,
                              0,
                              &ovStart ) ) {
            Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to unlock trace file, dwRet: %u", ::GetLastError() );
        }
        if ( m_bForceFlush )
            ::FlushFileBuffers( m_hTraceFile );
        ::CloseHandle( m_hTraceFile );
        m_hTraceFile = INVALID_HANDLE_VALUE;
    }

    m_pwszSourceFileName = NULL;
    m_pwszFunctionName = NULL;
    m_dwLineNum = 0;
    m_bInTrace  = FALSE;

    m_pcs->Leave();

    return S_OK;
    UNREFERENCED_PARAMETER( dwIndent );
}

HRESULT _cdecl
CBsDbgTrace::Print(
    IN LPCWSTR pwszFormatStr,
    IN ...
    )
/*++

Routine Description:

    Formats the trace message out to the trace file and/or debugger.

Arguments:

    pwszFormatStr - printf style format string
    ... - Arguments for the message

Return Value:

    HRESULT

--*/
{
    va_list pArg;

    if ( m_bInTrace ) {
        if ( m_bTraceTimestamp )
            StringCchPrintfW( STRING_CCH_PARAM(m_pwszOutBuf), 
                          L"[%010u,",
                          GetTickCount() );
        else
            StringCchPrintfW( STRING_CCH_PARAM(m_pwszOutBuf), 
                          L"[-," );

        StringCchPrintfW( m_pwszOutBuf + wcslen( m_pwszOutBuf ), 
                  SIZEOF_ARRAY(m_pwszOutBuf) - wcslen( m_pwszOutBuf ),
                  L"0x%06x:0x%04x:0x%08x] ",
                  m_dwCurrentProcessId,
                  GetCurrentThreadId(),
                  m_dwContextId );

        if ( m_bTraceFileLineInfo )
            StringCchPrintfW( m_pwszOutBuf + wcslen( m_pwszOutBuf ), 
                        SIZEOF_ARRAY(m_pwszOutBuf) - wcslen( m_pwszOutBuf ),
                        L"%s(%04u): ",
                        m_pwszSourceFileName,
                        m_dwLineNum );

        OutputString();

	    //
        // read the variable length parameter list into a formatted string
        //

        va_start( pArg, pwszFormatStr );
	    StringCchVPrintfW( STRING_CCH_PARAM(m_pwszOutBuf), pwszFormatStr, pArg );
	    va_end( pArg );

        OutputString();

        //
        //  Finish up with a carriage return.
        //
        wcscpy( m_pwszOutBuf, L"\r\n" );
        OutputString();
    }

    return S_OK;
}

HRESULT _cdecl
CBsDbgTrace::PrintEnterExit(
    IN LPCWSTR pwszFormatStr,
    IN ...
    )
/*++

Routine Description:

    Formats the entry/exit trace message out to the trace file and/or debugger.

Arguments:

    pwszFormatStr - printf style format string
    ... - Arguments for the message

Return Value:

    HRESULT

--*/
{
    va_list pArg;

    if ( m_bInTrace ) {
        if ( m_bTraceTimestamp )
            StringCchPrintfW( STRING_CCH_PARAM(m_pwszOutBuf), 
                      L"[%010u,",
                      GetTickCount() );
        else
            StringCchPrintfW( STRING_CCH_PARAM(m_pwszOutBuf), 
                      L"[-," );

        StringCchPrintfW( m_pwszOutBuf + wcslen( m_pwszOutBuf ), 
                  SIZEOF_ARRAY(m_pwszOutBuf) - wcslen( m_pwszOutBuf ), 
                  L"0x%06x:0x%04x:0x%08x] %s {%s}: ",
                  m_dwCurrentProcessId,
                  GetCurrentThreadId(),
                  m_dwContextId,
                  m_bTraceEnter ? L"ENTER" : L"EXIT ",
                  m_pwszFunctionName );

        OutputString();

	    //
        // read the variable length parameter list into a formatted string
        //

        va_start( pArg, pwszFormatStr );
	    StringCchVPrintfW( STRING_CCH_PARAM(m_pwszOutBuf), pwszFormatStr, pArg );
	    va_end( pArg );

        OutputString();

        //
        //  Finish up with a carriage return.
        //
        wcscpy( m_pwszOutBuf, L"\r\n" );
        OutputString();
    }

    return S_OK;
}

HRESULT
CBsDbgTrace::OutputString()
/*++

Routine Description:

    Prints the trace message out to the trace file and/or debugger.

Arguments:

    Assumes m_pwszOutBuf has the string to be printed.

Return Value:

    HRESULT

--*/
{
    //
    //  Make sure we didn't go off the end.  Can't use BS_ASSERT(), it
    //  will cause an deadlock.
    //
    _ASSERTE( wcslen( m_pwszOutBuf ) < BS_DBG_OUT_BUF_SIZE );

    //
    // Print to the debug stream for debug builds
    //
    if ( m_bTraceToDebugger )
        OutputDebugString( m_pwszOutBuf );

    //
    // If file tracing is enabled, dump to file
    //
    if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
        DWORD dwBytesWritten;
        ::WriteFile( m_hTraceFile,
                     m_pwszOutBuf,
                     (DWORD)(wcslen( m_pwszOutBuf ) * sizeof(WCHAR)),
                     &dwBytesWritten,
                     NULL );
    }

    return S_OK;
}


VOID CBsDbgTrace::SetContextNum(
    IN DWORD dwContextNum
    )
/*++

Routine Description:

    Use to be used to set the context number of the operation.  Now it is only
    used to determine if a DLL is loading using the trace class.

Arguments:

    LTS_CONTEXT_DELAYED_DLL - DLL is using the class object.

--*/
{
    if (dwContextNum == LTS_CONTEXT_DELAYED_DLL && !m_bInitialized )
    {
        Initialize();
    }

}


/*++

Routine Description:

    Puts the UNICODE UCS-2 BOM (Byte Order Mark) at the beginning of the file
    to let applications know that 1. this is a UCS-2 UNICODE file and 2. that
    the byte ordering is little-endian.

    Assumes the file is empty.

Arguments:

    hFile - Handle to the file

Return Value:

    <Enter return values here>

--*/
static VOID MakeFileUnicode(
    IN HANDLE hFile
    )
{
    BS_ASSERT( hFile != INVALID_HANDLE_VALUE );
    BYTE byteBOM[2] = { 0xFF, 0xFE };

    DWORD dwBytesWritten;
    ::WriteFile( hFile,
                 byteBOM,
                 sizeof byteBOM,
                 &dwBytesWritten,
                 NULL );
}


void __cdecl CVssFunctionTracer::TranslateError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
		IN LPCWSTR wszRoutine
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

--*/

    {
	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected in function %s", wszRoutine);
	else
		{
		LogError(VSS_ERROR_UNEXPECTED_CALLING_ROUTINE, dbgInfo << wszRoutine << hr);
		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error in routine %s.  hr = 0x%08lx", wszRoutine, hr);
		}
	}


void __cdecl CVssFunctionTracer::TranslateComError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

Throws:

    E_UNEXPECTED
        - on unrecognized error codes

--*/

    {
        CVssOutputBuffer buffer;
        if (!buffer.IsBufferValid())
            throw(E_OUTOFMEMORY);
    
        WSNPRINTF_BUFFER(buffer, wszErrorTextFormat)
    
        // Get the HR from the internal member
        HRESULT hr = m_hr;
        if (hr == S_OK)
            hr = E_UNEXPECTED;

        // Get the COM error (in a fault-tolerant manner)
        CComPtr<IErrorInfo> pErrorInfo;
        CComBSTR bstrDescription;
        HRESULT hr2 = ::GetErrorInfo(0, &pErrorInfo);
        if (SUCCEEDED(hr2)) {
            if (pErrorInfo != NULL) {
                // Intentionally ignore return code
                pErrorInfo->GetDescription(&bstrDescription);
            }
        }

        // Setup a non-NULL error description always
        LPWSTR pwszErrorDescription = (LPWSTR) bstrDescription;
        if (NULL == pwszErrorDescription)
            pwszErrorDescription = L"";

        // Translate the obtained hr.
    	if (hr == E_OUTOFMEMORY ||
    		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
    		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
    		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s - %s", 
    		    buffer.GetBuffer(), pwszErrorDescription);
    	else
		{
    		LogError(VSS_ERROR_UNEXPECTED_COM_ERRORCODE, 
    		    dbgInfo << buffer.GetBuffer() << pwszErrorDescription << hr);
    		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error: %s - %s [hr = 0x%08lx]", 
   		        buffer.GetBuffer(), pwszErrorDescription, hr);
		}
	}



void __cdecl CVssFunctionTracer::TranslateWin32Error
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

Throws:

    E_UNEXPECTED
        - on unrecognized error codes

--*/

    {
        CVssOutputBuffer buffer;
        if (!buffer.IsBufferValid())
            throw(E_OUTOFMEMORY);
    
        WSNPRINTF_BUFFER(buffer, wszErrorTextFormat)
    
        // Get the HR from GetLastError - note that this API may return S_OK on Win32 failed calls
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        if (hr == S_OK)
            hr = E_UNEXPECTED;

        // Translate the obtained hr.
    	if (hr == E_OUTOFMEMORY ||
    		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
    		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
    		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s", buffer.GetBuffer());
    	else
    		{
    		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << buffer.GetBuffer() << hr);
    		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error: %s  [hr = 0x%08lx]", buffer.GetBuffer(), hr);
    		}
	}



void __cdecl CVssFunctionTracer::TranslateGenericError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

Throws:

    E_UNEXPECTED
        - on unrecognized error codes

--*/

    {
        CVssOutputBuffer buffer;
        if (!buffer.IsBufferValid())
            throw(E_OUTOFMEMORY);
    
        WSNPRINTF_BUFFER(buffer, wszErrorTextFormat)

    	if (hr == E_OUTOFMEMORY ||
    		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
    		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
    		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s", buffer.GetBuffer());
    	else
    		{
    		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << buffer.GetBuffer() << hr);
    		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error: %s  [hr = 0x%08lx]", buffer.GetBuffer(), hr);
    		}
	}



void __cdecl CVssFunctionTracer::TranslateProviderError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN GUID ProviderID,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a provider call

Throws:

    E_OUTOFMEMORY
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Unexpected provider error. The error code is logged into the event log.
    VSS_E_PROVIDER_VETO
        - Expected provider error. The provider already did the logging.

--*/

    {
    CVssOutputBuffer buffer;
    if (!buffer.IsBufferValid())
        throw(E_OUTOFMEMORY);

    WSNPRINTF_BUFFER(buffer, wszErrorTextFormat)

	if (hr == E_OUTOFMEMORY)
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    buffer.GetBuffer(), GUID_PRINTF_ARG(ProviderID));
	else if (hr == E_INVALIDARG) {
		LogError(VSS_ERROR_CALLING_PROVIDER_ROUTINE_INVALIDARG, dbgInfo << ProviderID << buffer.GetBuffer() );
		Throw(dbgInfo, E_INVALIDARG, L"Invalid argument detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    buffer.GetBuffer(), GUID_PRINTF_ARG(ProviderID));
	}
	else if (hr == VSS_E_PROVIDER_VETO)
		Throw(dbgInfo, VSS_E_PROVIDER_VETO, L"Provider veto detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    buffer.GetBuffer(), GUID_PRINTF_ARG(ProviderID));
    else
		{
		LogError(VSS_ERROR_CALLING_PROVIDER_ROUTINE, dbgInfo << ProviderID << buffer.GetBuffer() << hr );
		Throw(dbgInfo, VSS_E_UNEXPECTED_PROVIDER_ERROR, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] Provider ID = " WSTR_GUID_FMT, 
		    buffer.GetBuffer(), hr, GUID_PRINTF_ARG(ProviderID));
		}
	}



void __cdecl CVssFunctionTracer::TranslateInternalLovelaceError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
        IN BOOL bHold,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a volsnap generic Ioctls (which Lovelace calls)

Throws:

    E_UNEXPECTED
        - on unrecognized error codes

--*/

    {
        CVssOutputBuffer buffer;
        if (!buffer.IsBufferValid())
            throw(E_OUTOFMEMORY);
    
        WSNPRINTF_BUFFER(buffer, wszErrorTextFormat)

    	if (hr == E_OUTOFMEMORY ||
    		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
    		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) ||
    		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
    		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s", buffer.GetBuffer());
        else if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ||
            hr ==  HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED)) 
            {
            // No need to log - this is a timeout case and Lovelave already logs an error for those
            HRESULT hrThrow = (bHold? VSS_E_FLUSH_WRITES_TIMEOUT : VSS_E_HOLD_WRITES_TIMEOUT);
    		Throw(dbgInfo, hrThrow, L"Timeout detected. %s  [hr = 0x%08lx]", buffer.GetBuffer(), hr);
            }
    	else
    		{
    		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << buffer.GetBuffer() << hr);
    		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error: %s  [hr = 0x%08lx]", buffer.GetBuffer(), hr);
    		}
	}

void __cdecl CVssFunctionTracer::TranslateInternalProviderError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hrToBeTreated,
		IN HRESULT hrToBeThrown,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a provider call

Throws:

    E_OUTOFMEMORY
    
    hrToBeThrown

--*/

    {
    CVssOutputBuffer buffer;
    if (!buffer.IsBufferValid())
        throw(E_OUTOFMEMORY);

    WSNPRINTF_BUFFER(buffer, wszErrorTextFormat)

    hr = hrToBeTreated;

	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s.", buffer.GetBuffer());
    else if (hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL))
		Throw(dbgInfo, VSS_E_INSUFFICIENT_STORAGE, L"Out of disk space detected. %s.", buffer.GetBuffer());
	else if ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
	    hr == HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED) || 
		hr == HRESULT_FROM_WIN32(ERROR_NOT_READY))
	    {
		LogError(VSS_ERROR_DEVICE_NOT_CONNECTED, dbgInfo << buffer.GetBuffer() );
		Throw(dbgInfo, VSS_E_OBJECT_NOT_FOUND, 
		    L"Invalid device when calling a provider routine: %s", buffer.GetBuffer());
    	}
    else if (hr == HRESULT_FROM_WIN32(ERROR_TIMEOUT))
        {
		LogError(VSS_ERROR_COMMIT_TIMEOUT, dbgInfo << buffer.GetBuffer() );
		Throw(dbgInfo, hrToBeThrown, L"Timeout error calling a provider routine: %s.", buffer.GetBuffer());
        }
    else
		{
        if (hrToBeThrown != VSS_E_OBJECT_NOT_FOUND)
    		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << buffer.GetBuffer() << hr );
		Throw(dbgInfo, hrToBeThrown, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] ", buffer.GetBuffer(), hr );
		}
	}



void __cdecl CVssFunctionTracer::TranslateWriterReturnCode
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a writer call (CoCreteInstance of the writer COM+ event class
	or sending an event.

Throws:

    E_OUTOFMEMORY
    VSS_E_UNEXPECTED_WRITER_ERROR
        - Unexpected writer error. The error code is logged into the event log.

--*/

    {

    if (HrSucceeded()) {
        BS_ASSERT(hr == S_OK || hr == EVENT_S_NOSUBSCRIBERS || hr == EVENT_S_SOME_SUBSCRIBERS_FAILED);
        hr = S_OK;
        return;
    }
    
    CVssOutputBuffer buffer;
    if (!buffer.IsBufferValid())
        throw(E_OUTOFMEMORY);

    WSNPRINTF_BUFFER(buffer, wszErrorTextFormat)
    
    if (hr == EVENT_E_ALL_SUBSCRIBERS_FAILED) {
		Trace( VSSDBG_COORD, L"%s event failed at one writer. hr = 0x%08lx", buffer.GetBuffer(), hr);
		hr = S_OK;
		// ignore the error;
        return;
        }
	else if (hr == E_OUTOFMEMORY)
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s.", buffer.GetBuffer());
    else
		{
		LogError(VSS_ERROR_UNEXPECTED_WRITER_ERROR, dbgInfo << buffer.GetBuffer() << hr );
		Throw(dbgInfo, VSS_E_UNEXPECTED_WRITER_ERROR, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] ", buffer.GetBuffer(), hr);
		}
    }



void __cdecl CVssFunctionTracer::LogGenericWarning
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Log a generic warning.

--*/

    {
    CVssOutputBuffer buffer;
    if (!buffer.IsBufferValid())
        throw(E_OUTOFMEMORY);

    WSNPRINTF_BUFFER(buffer, wszErrorTextFormat)

	LogError(VSS_WARNING_UNEXPECTED, dbgInfo << buffer.GetBuffer() << hr, EVENTLOG_WARNING_TYPE);
	Trace(dbgInfo, L"WARNING: %s [hr = 0x%08lx]", buffer.GetBuffer(), hr);
	}


// This method must be called prior to calling a CoCreateInstance that may start VSS
void CVssFunctionTracer::LogVssStartupAttempt()
{
    // the name of the Volume Snapshot Service
    const LPCWSTR wszVssvcServiceName = L"VSS";
    
    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;

    try
	{
        //
        //  Check to see if VSSVC is running. If not, we are putting an entry into the trace log if enabled.
        //

    	// Connect to the local service control manager
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
        if (!shSCManager) 
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L"OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)");

    	// Get a handle to the service
        shSCService = OpenService (shSCManager, wszVssvcServiceName, SERVICE_QUERY_STATUS);
        if (!shSCService) 
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L" OpenService (shSCManager, \'%s\', SERVICE_QUERY_STATUS)", wszVssvcServiceName);

    	// Now query the service to see what state it is in at the moment.
        SERVICE_STATUS	sSStat;
        if (!QueryServiceStatus (shSCService, &sSStat))
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L"QueryServiceStatus (shSCService, &sSStat)");

        // If the service is not running, then we will put an informational error log entry 
        // if (sSStat.dwCurrentState != SERVICE_RUNNING)
        //     LogError(VSS_INFO_SERVICE_STARTUP, 
        //         VSSDBG_GEN << GetCommandLineW() << (HRESULT)sSStat.dwCurrentState, 
        //         EVENTLOG_INFORMATION_TYPE);
        if (sSStat.dwCurrentState != SERVICE_RUNNING)
            Trace( VSSDBG_GEN, 
                L"Volume Snapshots Service information: Service starting at request of process '%s'. [0x%08x]",
                GetCommandLineW(), sSStat.dwCurrentState );        
	} VSS_STANDARD_CATCH ((*this));

    // Close handles
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);
}


void CVssFunctionTracer::CoCreateInstanceWithLog(
		IN  CVssDebugInfo   dbgInfo,          // Caller debugging info
        IN  CLSID           ServerClassID,
        IN  LPCWSTR         ServerName,
        IN  DWORD           dwContext,
        IN  IID             InterfaceID,
        OUT IUnknown **     ppUnknown
        )
{
    for(int nRetries = 0; nRetries < x_nMaxCoCreateInstanceRetries; nRetries++)
    {
        hr = ::CoCreateInstance( 
                            ServerClassID, 
                            NULL, 
                            dwContext, 
                            InterfaceID, 
                            (void**)ppUnknown);
        if (hr != CO_E_SERVER_EXEC_FAILURE)
            break;
    }

    // Treatment of the error cases
    switch(hr)
    {
    case S_OK:
        break;
    case E_OUTOFMEMORY:
        break;
    case HRESULT_FROM_WIN32(ERROR_NOT_SAFEBOOT_SERVICE):
      	LogError( VSS_ERROR_STARTING_COM_SERVER_SAFEBOOT, 
      	    dbgInfo << ServerClassID << ServerName << hr );
        break;
    case EVENT_E_INTERNALERROR: // This is only for CLSID_CEventSystem
      	LogError( VSS_ERROR_STARTING_EVENTS_SAFEBOOT, 
      	    dbgInfo << ServerClassID << ServerName << hr );
        break;
    case CO_E_SERVER_EXEC_FAILURE:
      	LogError( VSS_ERROR_STARTING_COM_SERVER_HEAVYLOAD, 
      	    dbgInfo << ServerClassID << ServerName << hr );
        break;
    case E_NOINTERFACE:
    case REGDB_E_CLASSNOTREG:
        if ((ServerClassID == CLSID_CEventSystem) || 
            (ServerClassID == __uuidof(COMAdminCatalog)) ||
            (ServerClassID == CLSID_CEventClass))
          	LogError( VSS_ERROR_COMPLUS_CORRUPTED, 
          	    dbgInfo << ServerClassID << ServerName << hr );
        else
          	LogError( VSS_ERROR_COM_SERVER_NOT_REGISTERED, 
          	    dbgInfo << ServerClassID << ServerName << hr );
        break;
    default:
        BS_ASSERT(FAILED(hr));
      	LogError( VSS_ERROR_STARTING_COM_SERVER, 
      	    dbgInfo << ServerClassID << ServerName << hr );
        break;
    }        
}


//  Turns off SEH exception handing for COM servers (BUG# 530092)
void CVssFunctionTracer::ComDisableSEH(
        IN  CVssDebugInfo   dbgInfo          // Caller debugging info
) throw(HRESULT)
{
    // CoCreate the Global options object
    CComPtr<IGlobalOptions> ptrIGLB;
    hr = ptrIGLB.CoCreateInstance(CLSID_GlobalOptions, NULL, CLSCTX_INPROC_SERVER);
    if (HrFailed()) {
        LogError( VSS_ERROR_STARTING_COM_SERVER, 
            dbgInfo << CLSID_GlobalOptions << L"CLSID_GlobalOptions" << hr );
        Throw( dbgInfo, hr, L"CoCreateInstance(CLSID_GlobalOptions) failed [0x%08lx]");
    }

    // Set the global COM option
    hr = ptrIGLB->Set(COMGLB_EXCEPTION_HANDLING, COMGLB_EXCEPTION_DONOT_HANDLE);
    if (HrFailed())
        TranslateGenericError( dbgInfo, hr, 
            L"pIGLB->Set(COMGLB_EXCEPTION_HANDLING, COMGLB_EXCEPTION_DONOT_HANDLE)");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\tracing\vs_thunking.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_thunking.cxx

Abstract:

    Thunking implementation

Author:
    Adi Oltean  [aoltean]  01/11/2002

Revision History:

    Name        Date        Comments
    aoltean     01/11/2002  Created
    
--*/

//
//  ***** Includes *****
//

#pragma warning(disable:4290)
#pragma warning(disable:4127)

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"

#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>
#include <ntverp.h>

#include "vs_inc.hxx"

#include "vs_thunk.hxx"
#include "vs_reg.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCTHUC"
//
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
//  Static member declarations

// ID for the last returned thunk
volatile LONG CVssQIThunk::m_NewestThunkID = 0;

// Map of IUnknown for thunked identities 
//    Key: the IUnknown identity of the managed interface 
//    Value: the thunk for the managed identity interface.
// - An entry is added in this array whenever a thunked obkect is created for the 
// identity IUnknown
// - This will guarantee identity closure over thunked objects.
CVssSimpleMap<IUnknown*, CVssQIThunk*> CVssQIThunk::m_mapIdentities;

// Lock around the map
CVssSafeCriticalSection CVssQIThunk::m_csMapCriticalSection;

////////////////////////////////////////////////////////////////////////
//  Implementation


// Standard constructor
CVssQIThunk::CVssQIThunk(
    IN  IUnknown* pManagedInterface, 
    IN  const IID& iid,
    IN  LPCWSTR wszObjectName
    )
{
    m_pManagedInterface = pManagedInterface;
    m_iid = iid;
    m_cInternalRefCount = 1;
    m_ThunkID = ::InterlockedIncrement(&m_NewestThunkID);
    BS_ASSERT(m_NewestThunkID != 0);
    m_bIsAddedToTheMap = false; 

    // Set the object name. If a failure happens, this becomes NULL
    m_aszObjectName.CopyFrom(wszObjectName);

    // Set the inteface name. If a serious failure happens, this becomes NULL
    GetInterfaceNameFromRegistry(iid, m_aszInterfaceName);
}


// Standard destructor
CVssQIThunk::~CVssQIThunk()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssQIThunk::~CVssQIThunk" );

    if (IsAddedToTheMap())
    {
        BS_ASSERT(IsIdentity());
        RemoveIdentity(m_pManagedInterface);
    }

    CVssAutoPWSZ aszInterfaceName;

    // Trace the destruction
    ft.Trace(VSSDBG_GEN, L"[%p:%s.%s:%lu] deleted... pItf: %p, identity:%s%s",
        this,
        GetObjectName(),
        GetInterfaceName(),
        GetThunkID(),
        m_pManagedInterface, 
        IsIdentity()? L"yes": L"no",
        IsAddedToTheMap()? L"(added)": L"");
}


// static constructor
HRESULT CVssQIThunk::CreateNewThunk(
    IN  IUnknown* pManagedUnknown,
    IN  LPCWSTR wszObjectName, 
    IN  const IID& iid, 
    OUT IUnknown** pp
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssQIThunk::CreateNewThunk" );

    try
    {
        // Assert parameters
        BS_ASSERT(pManagedUnknown);
        BS_ASSERT(wszObjectName);
        BS_ASSERT(pp);

        ::VssZeroOutPtr(pp);

        // Detect the original reference count
        DWORD dwRefCount1 = pManagedUnknown->AddRef();
        DWORD dwRefCount2 = pManagedUnknown->Release();
        if (dwRefCount1 != dwRefCount2 + 1) 
            ft.Trace(VSSDBG_GEN, 
                L"Cannot reliably detect the reference count for %p [%s, %lu:%lu]",
                pManagedUnknown, wszObjectName, dwRefCount1, dwRefCount2);

        // Create a new thunk object
        // This assignment will increase the internal ref count to 1.
        CVssQIThunk * pThunk = new CVssQIThunk(pManagedUnknown, iid, wszObjectName);
        if (!pThunk->IsValid())
        {
            delete pThunk;
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");
        }

        // If the interface is IUnknown add an entry in the identities table
        // (only if this is the first entry)
        if (::InlineIsEqualUnknown(iid)
            && (LookupForIdentity(pManagedUnknown) == NULL))
        {
            if (!AddIdentity(pManagedUnknown, pThunk))
            {
                delete pThunk;
                ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");
            }
            pThunk->MarkAsAddedToTheMap();
        }

        // Trace the creation
        ft.Trace(VSSDBG_GEN, L"[%p:%s.%s:%lu] created... pItf: %p, identity:%s%s, ext:%lu",
            pThunk,
            pThunk->GetObjectName(),
            pThunk->GetInterfaceName(),
            pThunk->GetThunkID(),
            pManagedUnknown, 
            pThunk->IsIdentity()? L"yes": L"no",
            pThunk->IsAddedToTheMap()? L"(added)": L"",
            dwRefCount2
            );

        (*pp) = static_cast<IUnknown*>(pThunk);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssQIThunk::QueryInterface(
    IN  REFIID iid, 
    IN  void** pp
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssQIThunk::QueryInterface" );

    try
    {
        // Assert paramters
        BS_ASSERT(pp);
        ::VssZeroOutPtr(pp);

        CVssAutoPWSZ aszNewInterfaceName;
        GetInterfaceNameFromRegistry(iid, aszNewInterfaceName);

        // Perform QI
        CComPtr<IUnknown> pNewManagedItf;
        BS_ASSERT(m_pManagedInterface);
        ft.hr = m_pManagedInterface->QueryInterface(iid, 
                    reinterpret_cast<void**>(&pNewManagedItf));
        ft.Trace(VSSDBG_GEN, L"[%p:%s.%s:%lu]->QI(%s, %p) => 0x%08lx", this, 
            GetObjectName(), 
            GetInterfaceName(), 
            GetThunkID(), 
            aszNewInterfaceName.GetRef(), 
            pNewManagedItf, ft.hr );
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, ft.hr, L"QueryInterface failed [0x%08lx]", ft.hr);

        // If this is an identity interface, make sure we don't build another thunk
        CComPtr<IUnknown> pUnkNewThunk;
        CVssQIThunk* pExistingIdentityThunk = LookupForIdentity(pNewManagedItf);
        if (pExistingIdentityThunk)
        {
            // Only pure IUnknown interfaces are allowed in the map
            BS_ASSERT(::InlineIsEqualUnknown(iid));
            // This will increase the internal and external ref count
            ft.Trace(VSSDBG_GEN, L"[%p:%s:%lu]: Reusing identity [%p:%s:%lu]",
                this, GetObjectName(), GetThunkID(), 
                pExistingIdentityThunk, 
                pExistingIdentityThunk->GetObjectName(), 
                pExistingIdentityThunk->GetThunkID()
                );
            pExistingIdentityThunk->ReuseIdentity();
            pUnkNewThunk.Attach(static_cast<IUnknown*>(pExistingIdentityThunk));
        }
        else
        {
            // We must build a new thunk
            ft.hr = CreateNewThunk(pNewManagedItf, GetObjectName(), iid, &pUnkNewThunk);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, ft.hr, L"CreateNewThunk failed [0x%08lx]", ft.hr);
        }

        // Detach the managed interface into the thunk
        pNewManagedItf.Detach();

        // Detach the thunk into the out parameter
        (*pp) = pUnkNewThunk.Detach();
    }
    VSS_STANDARD_CATCH(ft)
    
    return ft.hr;
}


STDMETHODIMP_(ULONG) CVssQIThunk::AddRef()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssQIThunk::AddRef" );

    // Increment reference counts
    BS_ASSERT(m_pManagedInterface);
    ULONG ulManagedRefCount = m_pManagedInterface->AddRef();
    ::InterlockedIncrement(&m_cInternalRefCount);

    // Trace new ref counts
    ft.Trace(VSSDBG_GEN, L"[%p:%s.%s:%lu]->AddRef() => ext:%lu, int:%lu",
        this, GetObjectName(), GetInterfaceName(), GetThunkID(), ulManagedRefCount, 
        m_cInternalRefCount );

    return m_cInternalRefCount;
}


STDMETHODIMP_(ULONG) CVssQIThunk::Release()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssQIThunk::Release" );

    // Decrement the ref counts
    BS_ASSERT(m_pManagedInterface);
    ULONG ulManagedRefCount = m_pManagedInterface->Release();
    ::InterlockedDecrement(&m_cInternalRefCount);

    // Trace new ref counts
    ft.Trace(VSSDBG_GEN, L"[%p:%s.%s:%lu]->Release() => ext:%lu, int:%lu",
        this, GetObjectName(), GetInterfaceName(), GetThunkID(), ulManagedRefCount, 
        m_cInternalRefCount );

    // If we reached zero, delete the thunk
    if (m_cInternalRefCount == 0)
        delete this;
    
    return m_cInternalRefCount;
}        


// Lookup for this identity in the global identity table
CVssQIThunk* CVssQIThunk::LookupForIdentity(
    IN  IUnknown* pManagedItf
    )
{
    // CVssFunctionTracer ft( VSSDBG_GEN, L"CVssQIThunk::LookupForIdentity" );

    return m_mapIdentities.Lookup(pManagedItf);
}


// Add this identity in the global identity table
bool CVssQIThunk::AddIdentity(
    IN  IUnknown* pManagedItf, 
    IN  CVssQIThunk* pThunk
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssQIThunk::AddIdentity" );

    return !! m_mapIdentities.Add(pManagedItf, pThunk);
}


// Remove this identity from the global identity table
void CVssQIThunk::RemoveIdentity(
    IN  IUnknown* pManagedItf
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssQIThunk::RemoveIdentity" );

    BS_VERIFY(m_mapIdentities.Remove(pManagedItf));
}


// Reuse this identity 
void CVssQIThunk::ReuseIdentity()
{
    BS_ASSERT(::InlineIsEqualUnknown(m_iid));
    BS_ASSERT(IsIdentity());
    BS_ASSERT(IsAddedToTheMap());

    // We assume that the managed interface is already AddRef-ed in QI
    m_cInternalRefCount++;
}


// Get the name of an Interface using the IID
void CVssQIThunk::GetInterfaceNameFromRegistry(
    IN  REFIID  iid,
	OUT CVssAutoPWSZ & aszInterfaceName
    )
{
    // no function tracer (avoid unnecesary tracing)
    
    try
    {
        // Open the key and read the default value
        CVssRegistryKey key(KEY_READ);
        if (key.Open( HKEY_CLASSES_ROOT, L"Interface\\" WSTR_GUID_FMT L"\\", GUID_PRINTF_ARG(iid)))
            key.GetValue(L"", aszInterfaceName.GetRef());
    }
    catch(...)
    {}

    try
    {
        // One more try
        if (aszInterfaceName.GetRef() == NULL)
        {
            // Enough number of characters to hold a GUID
            const x_cMaxGuidLen = 50;
            aszInterfaceName.Allocate(x_cMaxGuidLen);
            ::ZeroMemory(aszInterfaceName.GetRef(), (x_cMaxGuidLen + 1) * sizeof(WCHAR));
            _snwprintf(aszInterfaceName.GetRef(), x_cMaxGuidLen, 
                WSTR_GUID_FMT, GUID_PRINTF_ARG(iid));
        }
    }
    catch(...)
    {}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\commandverifier.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module commandverifier.cpp | definition for the command verifier
    @end

Author:

    Reuven Lax [reuvenl]  11/20/2001


    
Revision History:

    Name        Date        	Comments
    reuvenl     11/20/2001 	Created

--*/

#include "vssadmin.h"
#include "commandverifier.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMVERFR"
//
////////////////////////////////////////////////////////////////////////

#define VSSADM_ONE_MB ( 1024 * 1024 )
#define VSSADM_HUNDRED_MB (100 * VSSADM_ONE_MB)

////////////////////////////////////////////////////////////////////////
//  Implementation of the CInternalVerifier class


void CInternalVerifier::CreateSnapshot (long type, LPCWSTR forVolume, VSS_ID idProvider, ULONGLONG autoRetry,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(type);
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(autoRetry);
	UNREFERENCED_PARAMETER(ft);
	UNREFERENCED_PARAMETER(forVolume);
	BS_ASSERT (forVolume != NULL);
}

void CInternalVerifier::ListProviders (CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(ft);
}

void CInternalVerifier::ListSnapshots (long type, VSS_ID idProvider, LPCWSTR forVolume, VSS_ID idShadow, VSS_ID idSet,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(type);
	UNREFERENCED_PARAMETER(idProvider);
	
       if (!::IsEqualGUID (idShadow, GUID_NULL) && !::IsEqualGUID (idSet, GUID_NULL))	{
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
                L"CVssAdminCLI::ListSnapshots: Cannot specify both /Set and /Shadow options at the same time" );
       }

	if (forVolume != NULL && wcslen(forVolume) > x_nLengthOfVolMgmtVolumeName)	{
		ft.Throw(VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
		L"CVssAdminCLI::ListSnapshots:  Must specify a valid volume name for list snapshots");
	}
}

void CInternalVerifier::ListWriters (CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(ft);
}

void CInternalVerifier::AddDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(forVolume);
	UNREFERENCED_PARAMETER(onVolume);
	
	BS_ASSERT (forVolume != NULL);
	BS_ASSERT (onVolume != NULL);

	if (maxSize < VSSADM_ONE_MB)	{
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
                L"CVssAdminCLI::AddDiffarea: A maxsize of less than 1 MB specified, invalid");
	}
}

void CInternalVerifier::ResizeDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(forVolume);
	UNREFERENCED_PARAMETER(onVolume);
	
	BS_ASSERT (forVolume != NULL);
	BS_ASSERT (onVolume != NULL);

	if (maxSize < VSSADM_ONE_MB)	{
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
                L"CVssAdminCLI::ResizeDiffarea: maxsize of less than 1 MB specified, invalid");
	}
}

void CInternalVerifier::DeleteDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, bool quiet,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(onVolume);
	UNREFERENCED_PARAMETER(forVolume);
	UNREFERENCED_PARAMETER(quiet);
	UNREFERENCED_PARAMETER(ft);
	
	BS_ASSERT (forVolume != NULL);
}

void CInternalVerifier::ListDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	
	if  ((forVolume != NULL) && (onVolume != NULL))	{
	        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
       	     L"CVssAdminCLI::ListDiffAreas: Can't specify both ON and FOR volume options" );
	}
}

void CInternalVerifier::DeleteSnapshots (long type, LPCWSTR forVolume, bool all, bool oldest, VSS_ID idShadow, bool quiet,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(quiet);
	
	if (!::IsEqualGUID (idShadow, GUID_NULL))	{
		if (forVolume != NULL || type != VSS_CTX_ALL || oldest || all)	{
	            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
       	         L"CVssAdminCLI::DeleteSnapshots: Invalid set of options" );
		}		
	}	else		{
		if ((forVolume == NULL && type == VSS_CTX_ALL && !all && !oldest) || 
		     (type != VSS_CTX_ALL && forVolume == NULL) ||
		     (oldest && forVolume == NULL))	{
	            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_REQUIRED_OPTION_MISSING,
       	         L"CVssAdminCLI::DeleteSnapshots: Required option missing" );
		}

		if ((type != VSS_CTX_ALL && all) ||
		     (all && oldest))	{
		     ft.Throw (VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
		     	L"CVssAdminCLI::DeleteSnapshots: Invalid set of options:");
		}
	}

	if (forVolume != NULL && wcslen(forVolume) > x_nLengthOfVolMgmtVolumeName)	{
		ft.Throw(VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
			L"CVssAdminCLI::DeleteSnapshots: invalid volume name");
	}
}

void CInternalVerifier::ExposeSnapshot (VSS_ID idShadow, LPCWSTR exposeUsing, LPCWSTR sharePath, bool locally,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idShadow);
	UNREFERENCED_PARAMETER(exposeUsing);
	
	BS_ASSERT (!locally || (::wcslen(exposeUsing) >= 2 && exposeUsing[1] == L':' ));
	
	if (locally && sharePath != NULL)	{
       	ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
	            L"CVssAdminCLI::ExposeSnapshot: Specified a ShareUsing option with an expose locally command" );
	}

	if (sharePath != NULL && sharePath[0] != L'\\')	{
	        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
       	     L"CVssAdminCLI::ExposeSnapshot: Specified SharePath doesn't start with '\\'" );
	}
}

void CInternalVerifier::ListVolumes (VSS_ID idProvider, long type, CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(type);
	UNREFERENCED_PARAMETER(ft);
}


////////////////////////////////////////////////////////////////////////
//  Implementation of the CExternalVerifier class

void CExternalVerifier::CreateSnapshot (long type, LPCWSTR forVolume, VSS_ID idProvider, ULONGLONG autoRetry,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(type);
	UNREFERENCED_PARAMETER(forVolume);
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(autoRetry);
	UNREFERENCED_PARAMETER(ft);
	
	BS_ASSERT (forVolume != NULL);
	BS_ASSERT (type == VSS_CTX_CLIENT_ACCESSIBLE);
	BS_ASSERT (::IsEqualGUID (idProvider, VSS_SWPRV_ProviderId));
}

void CExternalVerifier::ListProviders (CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(ft);
}

void CExternalVerifier::ListSnapshots (long type, VSS_ID idProvider, LPCWSTR forVolume, VSS_ID idShadow, VSS_ID idSet,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(type);
	UNREFERENCED_PARAMETER(idProvider);
	
	BS_ASSERT (type == VSS_CTX_ALL);
	BS_ASSERT (::IsEqualGUID (idProvider, VSS_SWPRV_ProviderId));

	if (!::IsEqualGUID (idShadow, GUID_NULL) && !::IsEqualGUID (idSet, GUID_NULL))	{
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
                L"CVssAdminCLI::ListSnapshots: Cannot specify both /Set and /Shadow options at the same time" );
       }

	if (forVolume != NULL && wcslen(forVolume) > x_nLengthOfVolMgmtVolumeName)	{
		ft.Throw(VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
		L"CVssAdminCLI::ListSnapshots:  Must specify a valid volume name for list snapshots");
	}

}

void CExternalVerifier::ListWriters (CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(ft);
}

void CExternalVerifier::AddDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize,
							CVssFunctionTracer& ft)
{	
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(forVolume);
	UNREFERENCED_PARAMETER(onVolume);
	
	BS_ASSERT (::IsEqualGUID (idProvider, VSS_SWPRV_ProviderId));
	BS_ASSERT (forVolume != NULL);
	BS_ASSERT (onVolume != NULL);

	if (maxSize < VSSADM_HUNDRED_MB)	{
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
                L"CVssAdminCLI::AddDiffarea: A maxsize of less than 100 MB specified, invalid");
	}
}

void CExternalVerifier::ResizeDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(forVolume);
	UNREFERENCED_PARAMETER(onVolume);

	BS_ASSERT (::IsEqualGUID (idProvider, VSS_SWPRV_ProviderId));
	BS_ASSERT (forVolume != NULL);
	BS_ASSERT (onVolume != NULL);

	if (maxSize < VSSADM_HUNDRED_MB)	{
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
                L"CVssAdminCLI::ResizeDiffarea: maxsize of less than 100 MB specified, invalid");
	}
}

void CExternalVerifier::DeleteDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, bool quiet,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(forVolume);
	UNREFERENCED_PARAMETER(onVolume);
	UNREFERENCED_PARAMETER(quiet);
	UNREFERENCED_PARAMETER(ft);
	
	BS_ASSERT (::IsEqualGUID (idProvider, VSS_SWPRV_ProviderId));
	BS_ASSERT (forVolume != NULL);
}

void CExternalVerifier::ListDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	
	BS_ASSERT (::IsEqualGUID (idProvider, VSS_SWPRV_ProviderId));

	if  ((forVolume != NULL) && (onVolume != NULL))	{
	        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
       	     L"CVssAdminCLI::ListDiffAreas: Can't specify both ON and FOR volume options" );
	}
}

void CExternalVerifier::DeleteSnapshots (long type, LPCWSTR forVolume, bool all, bool oldest, VSS_ID idShadow, bool quiet,
							CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(type);
	UNREFERENCED_PARAMETER(quiet);
	
	BS_ASSERT (type == VSS_CTX_CLIENT_ACCESSIBLE);

	if (!::IsEqualGUID (idShadow, GUID_NULL))	{
		if (forVolume != NULL || all || oldest)	{
	            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
       	         L"CVssAdminCLI::DeleteSnapshots: Invalid set of options" );
		}		
	}	else		{
		if ( (forVolume == NULL && !all && !oldest) ||
			(oldest && forVolume == NULL))	{
	            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_REQUIRED_OPTION_MISSING,
       	         L"CVssAdminCLI::DeleteSnapshots: Required option missing" );
		}		

		if (all && oldest)	{
			ft.Throw(VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
				L"CVssAdminCLI::DeleteSnapshots: Invalid set of options");
		}
	}

	if (forVolume != NULL && wcslen(forVolume) > x_nLengthOfVolMgmtVolumeName)	{
		ft.Throw(VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
			L"CVssAdminCLI::DeleteSnapshots: invalid volume name");
	}
}

void CExternalVerifier::ExposeSnapshot (VSS_ID idShadow, LPCWSTR exposeUsing, LPCWSTR sharePath,
							bool locally, CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idShadow);
	UNREFERENCED_PARAMETER(exposeUsing);
	UNREFERENCED_PARAMETER(sharePath);
	UNREFERENCED_PARAMETER(locally);
	UNREFERENCED_PARAMETER(ft);
	
	BS_ASSERT (false);
}

void CExternalVerifier::ListVolumes (VSS_ID idProvider, long type, CVssFunctionTracer& ft)
{
	UNREFERENCED_PARAMETER(idProvider);
	UNREFERENCED_PARAMETER(type);
	UNREFERENCED_PARAMETER(ft);
	
	BS_ASSERT (::IsEqualGUID (idProvider, VSS_SWPRV_ProviderId));
	BS_ASSERT (type == VSS_CTX_CLIENT_ACCESSIBLE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\commandverifier.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module commandverifier.hxx | declaration for the command verifier
    @end

Author:

    Reuven Lax [reuvenl]  11/20/2001


    
Revision History:

    Name        Date        	Comments
    reuvenl     11/20/2001 	Created

--*/

#ifndef _COMMANDVERIFIER_H_
#define _COMMANDVERIFIER_H_

#include "versionspecific.h"

class CCommandVerifier	{
public:
	virtual ~CCommandVerifier()
		{}
	static CCommandVerifier* Instance();
	virtual void CreateSnapshot (long type, LPCWSTR forVolume, VSS_ID idProvider, ULONGLONG autoRetry, 
		CVssFunctionTracer& ft) = 0;
	virtual void ListProviders (CVssFunctionTracer& ft) = 0;
	virtual void ListSnapshots (long type, VSS_ID idProvider, LPCWSTR forVolume, VSS_ID idShadow, VSS_ID idSet, 
		CVssFunctionTracer& ft) = 0;
	virtual void ListWriters (CVssFunctionTracer& ft) = 0;
	virtual void AddDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize, 
		CVssFunctionTracer& ft) = 0;
	virtual void ResizeDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize, 
		CVssFunctionTracer& ft) = 0;
	virtual void DeleteDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, bool quiet, 
		CVssFunctionTracer& ft) = 0;
	virtual void ListDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, CVssFunctionTracer& ft) = 0;
	virtual void DeleteSnapshots (long type, LPCWSTR forVolume, bool all, bool oldest, VSS_ID idShadow, bool quiet, 
		CVssFunctionTracer& ft) = 0;
	virtual void ExposeSnapshot (VSS_ID idShadow, LPCWSTR exposeUsing, LPCWSTR sharePath, bool locally, 
		CVssFunctionTracer& ft) = 0;
	virtual void ListVolumes (VSS_ID idProvider, long type, CVssFunctionTracer& ft) = 0;
};

class CInternalVerifier : public CCommandVerifier	{
public:
	virtual void CreateSnapshot (long type, LPCWSTR forVolume, VSS_ID idProvider, ULONGLONG autoRetry, 
		CVssFunctionTracer& ft);
	virtual void ListProviders (CVssFunctionTracer& ft);
	virtual void ListSnapshots (long type, VSS_ID idProvider, LPCWSTR forVolume, VSS_ID idShadow, VSS_ID idSet,
		CVssFunctionTracer& ft);
	virtual void ListWriters (CVssFunctionTracer& ft);
	virtual void AddDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize,
		CVssFunctionTracer& ft);
	virtual void ResizeDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize,
		CVssFunctionTracer& ft);
	virtual void DeleteDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, bool quiet,
		CVssFunctionTracer& ft);
	virtual void ListDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, CVssFunctionTracer& ft);
	virtual void DeleteSnapshots (long type, LPCWSTR forVolume, bool all, bool oldest, VSS_ID idShadow, bool quiet,
		CVssFunctionTracer& ft);
	virtual void ExposeSnapshot (VSS_ID idShadow, LPCWSTR exposeUsing, LPCWSTR sharePath, bool locally,
		CVssFunctionTracer& ft);
	virtual void ListVolumes (VSS_ID idProvider, long type, CVssFunctionTracer& ft);
};

class CExternalVerifier : public CCommandVerifier	{
public:
	virtual void CreateSnapshot (long type, LPCWSTR forVolume, VSS_ID idProvider, ULONGLONG autoRetry, 
		CVssFunctionTracer& ft);
	virtual void ListProviders (CVssFunctionTracer& ft);
	virtual void ListSnapshots (long type, VSS_ID idProvider, LPCWSTR forVolume, VSS_ID idShadow, VSS_ID idSet, 
		CVssFunctionTracer& ft);
	virtual void ListWriters (CVssFunctionTracer& ft);
	virtual void AddDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize,
		CVssFunctionTracer& ft);
	virtual void ResizeDiffArea (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, ULONGLONG maxSize,
		CVssFunctionTracer& ft);
	virtual void DeleteDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume, bool quiet,
		CVssFunctionTracer& ft);
	virtual void ListDiffAreas (VSS_ID idProvider, LPCWSTR forVolume, LPCWSTR onVolume,
		CVssFunctionTracer& ft);
	virtual void DeleteSnapshots (long type, LPCWSTR forVolume, bool all, bool oldest, VSS_ID idShadow, bool quiet,
		CVssFunctionTracer& ft);
	virtual void ExposeSnapshot (VSS_ID idShadow, LPCWSTR exposeUsing, LPCWSTR sharePath, bool locally,
		CVssFunctionTracer& ft);
	virtual void ListVolumes (VSS_ID idProvider, long type, CVssFunctionTracer& ft);
};

/////////////////////////////////////////////////////////////////////////////
// Define creation of parameter verifier

inline CCommandVerifier* CCommandVerifier::Instance()
{
	switch (dCurrentSKU)	{
		case SKU_INT:
			return new CInternalVerifier();						
		default:
			return new CExternalVerifier();
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\tracing\bsstring.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsstring.cxx

Abstract:

    This module implements the CBsString class.  This class manages character
    arrays in a similar manner as the CString class in VC++.  In fact, this
    class is a copy of the CString class with the MFC specific stuff ripped
    out since LTS doesn't use MTF.

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    Stefan R. Steiner   [SSteiner]      10-Apr-2000
        Added fixed allocator code and resynced with MFC 6 SR-1 code
        
--*/

#include <Nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "bsstring.hxx"
#include "malloc.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct _BSAFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _BSAFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// #define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

TCHAR bsafxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int _bsafxInitData[] = { -1, 0, 0, 0 };
static CBsStringData* _bsafxDataNil = (CBsStringData*)&_bsafxInitData;
static LPCTSTR _bsafxPchNil = (LPCTSTR)(((BYTE*)&_bsafxInitData)+sizeof(CBsStringData));
// special function to make bsafxEmptyString work even during initialization
const CBsString& BSAFXAPI BsAfxGetEmptyString()
	{ return *(CBsString*)&_bsafxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CBsString::CBsString()
{
	Init();
}

CBsString::CBsString(const CBsString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != _bsafxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CBsString::CBsString(GUID guid)
{
	Init();
	AllocBuffer(38);
    _stprintf( m_pchData, _T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
               guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1], 
               guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], 
               guid.Data4[6], guid.Data4[7] );
}

#ifndef _DEBUG

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

#define ROUND(x,y) (((x)+(y-1))&~(y-1))
#define ROUND4(x) ROUND(x, 4)
static CBsFixedAlloc _bsafxAlloc8(ROUND4(9*sizeof(TCHAR)+sizeof(CBsStringData)), 1024);
static CBsFixedAlloc _bsafxAlloc16(ROUND4(17*sizeof(TCHAR)+sizeof(CBsStringData)), 512);
static CBsFixedAlloc _bsafxAlloc32(ROUND4(33*sizeof(TCHAR)+sizeof(CBsStringData)), 256);
static CBsFixedAlloc _bsafxAlloc64(ROUND4(65*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc128(ROUND4(129*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc256(ROUND4(257*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc512(ROUND4(513*sizeof(TCHAR)+sizeof(CBsStringData)));

#endif //!_DEBUG

void CBsString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
// Throws E_OUTOFMEMORY when out of memory
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CBsStringData* pData;	    
#ifndef _DEBUG
		if (nLen <= 8)
		{
			pData = (CBsStringData*)_bsafxAlloc8.Alloc();
			pData->nAllocLength = 8;
		} 
		else if (nLen <= 16)
		{
			pData = (CBsStringData*)_bsafxAlloc16.Alloc();
			pData->nAllocLength = 16;
		} 
		else if (nLen <= 32)
		{
			pData = (CBsStringData*)_bsafxAlloc32.Alloc();
			pData->nAllocLength = 32;
		} 
		else if (nLen <= 64)
		{
			pData = (CBsStringData*)_bsafxAlloc64.Alloc();
			pData->nAllocLength = 64;
		}
		else if (nLen <= 128)
		{
			pData = (CBsStringData*)_bsafxAlloc128.Alloc();
			pData->nAllocLength = 128;
		}
		else if (nLen <= 256)
		{
			pData = (CBsStringData*)_bsafxAlloc256.Alloc();
			pData->nAllocLength = 256;
		}
		else if (nLen <= 512)
		{
			pData = (CBsStringData*)_bsafxAlloc512.Alloc();
			pData->nAllocLength = 512;
		}
		else
#endif
		{
			pData = (CBsStringData*)
				new BYTE[sizeof(CBsStringData) + (nLen+1)*sizeof(TCHAR)];
			if ( pData == NULL )    // Prefix #118828
			    throw E_OUTOFMEMORY;
			pData->nAllocLength = nLen;
		}
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		m_pchData = pData->data();
	}
}

void FASTCALL CBsString::FreeData(CBsStringData* pData)
{
#ifndef _DEBUG
	int nLen = pData->nAllocLength;
	if (nLen == 8)
		_bsafxAlloc8.Free(pData);
	else if (nLen == 16)
		_bsafxAlloc16.Free(pData);
	else if (nLen == 32)
		_bsafxAlloc32.Free(pData);
	else if (nLen == 64)
		_bsafxAlloc64.Free(pData);
	else if (nLen == 128)
		_bsafxAlloc128.Free(pData);
	else if (nLen == 256)
		_bsafxAlloc256.Free(pData);
	else  if (nLen == 512)
		_bsafxAlloc512.Free(pData);
	else
	{
		ASSERT(nLen > 512);
		delete[] (BYTE*)pData;
	}
#else
	delete[] (BYTE*)pData;
#endif
}

void CBsString::Release()
{
	if (GetData() != _bsafxDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
		Init();
	}
}

void PASCAL CBsString::Release(CBsStringData* pData)
{
	if (pData != _bsafxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			FreeData(pData);
	}
}

void CBsString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &bsafxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CBsString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CBsStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CBsString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CBsString::~CBsString()
//  free any attached data
{
	if (GetData() != _bsafxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CBsString::AllocCopy(CBsString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(LPCTSTR lpsz)
{
	Init();
	int nLen = SafeStrlen(lpsz);
	if (nLen != 0)
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}

CBsString::CBsString(PUNICODE_STRING pucsSource)
{
	Init();
	int nSrcLen = (pucsSource != NULL) ? pucsSource->Length : 0;	// in bytes
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen / sizeof(WCHAR));
		memcpy(m_pchData, pucsSource->Buffer, nSrcLen);
		m_pchData[nSrcLen / sizeof(WCHAR)] = UNICODE_NULL;
		ReleaseBuffer();
	}
}

#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}

CBsString::CBsString(PUNICODE_STRING pucsSource)
{
	Init();
	int nSrcLen = (pucsSource != NULL) ? pucsSource->Length : 0;	// in bytes
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_wcstombsz(m_pchData, pucsSource, nSrcLen);
		m_pchData[nSrcLen] = L'\0';
		ReleaseBuffer();
	}
}

#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CBsString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CBsString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CBsString& CBsString::operator=(const CBsString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _bsafxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != _bsafxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CBsString& CBsString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CBsString& CBsString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CBsString& CBsString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CBsString + CBsString
// and for ? = TCHAR, LPCTSTR
//          CBsString + ?
//          ? + CBsString

void CBsString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CBsString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CBsString BSAFXAPI operator+(const CBsString& string1, const CBsString& string2)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CBsString BSAFXAPI operator+(const CBsString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CBsString::SafeStrlen(lpsz), lpsz);
	return s;
}

CBsString BSAFXAPI operator+(LPCTSTR lpsz, const CBsString& string)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(CBsString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CBsString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CBsStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CBsString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CBsString& CBsString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CBsString& CBsString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CBsString& CBsString::operator+=(const CBsString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CBsString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CBsStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CBsString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CBsString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CBsString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CBsString::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CBsStringData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CBsString::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CBsString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CBsString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != _bsafxDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CBsString::Find(TCHAR ch) const
{
	return Find(ch, 0);
}

int CBsString::Find(TCHAR ch, int nStart) const
{
	int nLength = GetData()->nDataLength;
	if (nStart >= nLength)
		return -1;

	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData + nStart, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CBsString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CBsString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

void CBsString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

void CBsString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

void CBsString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CBsString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
void CBsString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CBsString conversion helpers (these use the current system locale)

int BSAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, (INT)count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int BSAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, (INT)count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR BSAFXAPI BsAfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
    UNREFERENCED_PARAMETER( nChars );
}

LPSTR BSAFXAPI BsAfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
    UNREFERENCED_PARAMETER( nChars );
}


//
//  the following is from strex.cpp
//

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(TCHAR ch, int nLength)
{
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CBsString::CBsString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ASSERT(BsAfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength);
		int n = ::MultiByteToWideChar(CP_ACP, 0, lpsz, nLength, m_pchData, nLength+1);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength*2);
		int n = ::WideCharToMultiByte(CP_ACP, 0, lpsz, nLength, m_pchData,
			(nLength*2)+1, NULL, NULL);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CBsString& CBsString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CBsString BSAFXAPI operator+(const CBsString& string1, TCHAR ch)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CBsString BSAFXAPI operator+(TCHAR ch, const CBsString& string)
{
	CBsString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Advanced manipulation

int CBsString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memcpy(m_pchData + nIndex,
			m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength - nCount;
	}

	return nNewLength;
}

int CBsString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CBsStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		AllocBuffer(nNewLength);
		memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
		CBsString::Release(pOldData);
	}

	// move existing bytes down
	memcpy(m_pchData + nIndex + 1,
		m_pchData + nIndex, (nNewLength-nIndex)*sizeof(TCHAR));
	m_pchData[nIndex] = ch;
	GetData()->nDataLength = nNewLength;

	return nNewLength;
}

int CBsString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}

		// move existing bytes down
		memcpy(m_pchData + nIndex + nInsertLength,
			m_pchData + nIndex,
			(nNewLength-nIndex-nInsertLength+1)*sizeof(TCHAR));
		memcpy(m_pchData + nIndex,
			pstr, nInsertLength*sizeof(TCHAR));
		GetData()->nDataLength = nNewLength;
	}

	return nNewLength;
}

int CBsString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = _tcsinc(psz);
		}
	}
	return nCount;
}

int CBsString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - (int)(lpszTarget - m_pchData + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen,
					nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ASSERT(m_pchData[nNewLength] == '\0');
		GetData()->nDataLength = nNewLength;
	}

	return nCount;
}

int CBsString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = _tcsinc(pstrDest);
		}
		pstrSource = _tcsinc(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = ( int )( pstrSource - pstrDest );
	GetData()->nDataLength -= nCount;

	return nCount;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CBsString CBsString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CBsString CBsString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	ASSERT(nFirst >= 0);
	ASSERT(nFirst + nCount <= GetData()->nDataLength);

	// optimize case of returning entire string
	if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CBsString CBsString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CBsString CBsString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CBsString CBsString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CBsString CBsString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CBsString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CBsString::Find(LPCTSTR lpszSub) const
{
	return Find(lpszSub, 0);
}

int CBsString::Find(LPCTSTR lpszSub, int nStart) const
{
	ASSERT(BsAfxIsValidString(lpszSub));

	int nLength = GetData()->nDataLength;
	if (nStart > nLength)
		return -1;

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData + nStart, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CBsString formatting

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#ifdef _X86_
	#define DOUBLE_ARG  _BSAFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000
#define FORCE_INT64		0x40000

void CBsString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += (INT)_tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		if (_tcsncmp(lpsz, _T("I64"), 3) == 0)
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
#if !defined(_X86_) && !defined(_ALPHA_)
			// __int64 is only available on X86 and ALPHA platforms
			ASSERT(FALSE);
#endif
		}
		else
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = _tcsinc(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = _tcsinc(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = _tcsinc(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
			{
				LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = lstrlen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 'S':
			{
#ifndef _UNICODE
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#else
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#endif
			}
			break;

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			{
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			{
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = (INT)wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
			nItemLen = max(nItemLen, nWidth);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'f':
				{
					double f;
					LPTSTR pszTemp;

					// 312 == strlen("-1+(309 zeroes).")
					// 309 zeroes == max precision of a double
					// 6 == adjustment in case precision is not specified,
					//   which means that the precision defaults to 6
					pszTemp = (LPTSTR)_alloca(max(nWidth, 312+nPrecision+6));

					f = va_arg(argList, double);
					_stprintf( pszTemp, _T( "%*.*f" ), nWidth, nPrecision+6, f );
					nItemLen = (int)_tcslen(pszTemp);
				}
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

    //  Use the new _vsctprintf() CRT function to get the length of the formatted string
    //  INT nMaxLen = _vsctprintf( lpszFormat, argList );
	GetBuffer( nMaxLen );
	INT i = _vstprintf( m_pchData, lpszFormat, argListSave );
	ASSERT( i <= nMaxLen && i != -1 );
	ReleaseBuffer();

	va_end(argListSave);

	UNREFERENCED_PARAMETER( i );
}

// formatting (using wsprintf style formatting)
void BSAFX_CDECL CBsString::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void CBsString::TrimRight(LPCTSTR lpszTargetList)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargetList, *lpsz) != NULL)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimRight(TCHAR chTarget)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (*lpsz == chTarget)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}


void CBsString::TrimRight()
{
	// find beginning of trailing spaces by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimLeft(LPCTSTR lpszTargets)
{
	// if we're not trimming anything, we're not doing any work
	if (SafeStrlen(lpszTargets) == 0)
		return;

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargets, *lpsz) == NULL)
			break;
		lpsz = _tcsinc(lpsz);
	}

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft(TCHAR chTarget)
{
	// find first non-matching character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (chTarget == *lpsz)
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft()
{
	// find first non-space character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;
	
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
    	// fix up data and length
    	int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    	GetData()->nDataLength = nDataLength;
	}
}


BOOL CBsString::ExpandEnvironmentStrings( LPCTSTR lpszSrc )
{
    INT nMaxLen;
    nMaxLen = (int)::ExpandEnvironmentStringsW( lpszSrc, NULL, 0 );
    if ( nMaxLen == 0 )
    {
        return FALSE;
    }
    
    GetBufferSetLength( nMaxLen - 1 );

    INT i = (int)::ExpandEnvironmentStringsW( lpszSrc, m_pchData, nMaxLen );
    if ( i == 0 || i > nMaxLen )
    {
        Release();
        return FALSE;
    }
	return TRUE;
}


//
//  From validadd.cpp
//

BOOL BSAFXAPI BsAfxIsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vssadmin.rc
//
#define IDS_UNKNOWN_PROVIDER            102
#define IDS_PROV_TYPE_SYSTEM            103
#define IDS_PROV_TYPE_SOFTWARE          104
#define IDS_PROV_TYPE_HARDWARE          105
#define IDS_PROV_TYPE_UNKNOWN           106
#define IDS_WRITER_STATUS_STABLE        107
#define IDS_WRITER_STATUS_FAILED        108
#define IDS_WRITER_STATUS_UNKNOWN       109
#define IDS_WRITER_STATUS_WAITING_FOR_FREEZE        110
#define IDS_WRITER_STATUS_FROZEN        111
#define IDS_WRITER_STATUS_WAITING_FOR_COMPLETION    112
#define IDS_WRITER_ERROR_INCONSISTENTSNAPSHOT       113
#define IDS_WRITER_ERROR_OUTOFRESOURCES 114
#define IDS_WRITER_ERROR_TIMEOUT        115
#define IDS_WRITER_ERROR_RETRYABLE      116
#define IDS_WRITER_ERROR_NONRETRYABLE   117
#define IDS_WRITER_ERROR_UNEXPECTED     118
#define IDS_WRITER_ERROR_SUCCESS        119
#define IDS_WRITER_STATUS_WAITING_FOR_POST_SNAPSHOT 120
#define IDS_WRITER_ERROR_NOT_RESPONDING 121

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         301
#define _APS_NEXT_SYMED_VALUE           401
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssapi\delayloadhandler.cpp ===
//***************************************************************************

//

//  DELAYLOADHANDLER.CPP

//

//  Module: Delay load handler functions

//

//  Purpose: When delay loaded libraries either fail to load, or functions

//           in them are not found, this handler is called as a result of

//           the //DELAYLOAD linker specification.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdafx.h>
#include <delayimp.h>


// Skeleton DliHook function that does nothing interesting
FARPROC WINAPI DliHook(
    unsigned dliNotify,
    PDelayLoadInfo pdli)
{
   FARPROC fp = NULL;   // Default return value

   // NOTE: The members of the DelayLoadInfo structure pointed
   // to by pdli shows the results of progress made so far.

   switch (dliNotify)
   {
   case dliStartProcessing:
      // Called when __delayLoadHelper attempts to find a DLL/function
      // Return 0 to have normal behavior, or non-0 to override
      // everything (you will still get dliNoteEndProcessing)
      break;

   case dliNotePreLoadLibrary:
      // Called just before LoadLibrary
      // Return NULL to have __delayLoadHelper call LoadLibary
      // or you can call LoadLibrary yourself and return the HMODULE
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliFailLoadLib:
      // Called if LoadLibrary fails
      // Again, you can call LoadLibary yourself here and return an HMODULE
      // If you return NULL, __delayLoadHelper raises the
      // ERROR_MOD_NOT_FOUND exception
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliNotePreGetProcAddress:
      // Called just before GetProcAddress
      // Return NULL to have __delayLoadHelper call GetProcAddress
      // or you can call GetProcAddress yourself and return the address
      fp = (FARPROC) NULL;
      break;

   case dliFailGetProc:
      // Called if GetProcAddress fails
      // Again, you can call GetProcAddress yourself here and return an address
      // If you return NULL, __delayLoadHelper raises the
      // ERROR_PROC_NOT_FOUND exception
      fp = (FARPROC) NULL;
      break;

   case dliNoteEndProcessing:
      // A simple notification that __delayLoadHelper is done
      // You can examine the members of the DelayLoadInfo structure
      // pointed to by pdli and raise an exception if you desire
      break;
   }

   return(fp);
}

// Tell __delayLoadHelper to call my hook function
PfnDliHook __pfnDliNotifyHook  = DliHook;
PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETTYPE = PROGRAM


UMTYPE = console
UMENTRY = wmain

MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=-DWIN_32 -D_WINDOWS -DNT -D_WIN32_DCOM -DUNICODE -D_UNICODE -D_ATL_NO_DEBUG_CRT

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -D_DEBUG
!endif

SUBSYSTEM_VERSION = 5.00
USE_IOSTREAM = 1
USE_NATIVE_EH=ASYNC
USE_MSVCRT = 1
USE_ATL=1
ATL_VER=30
USE_NTDLL=1

SOURCES =				\
        ..\vssadmin.cpp	\
        ..\versionspecific.cpp \
        ..\commandverifier.cpp\
	..\process.cpp		\
        ..\utility.cpp     \
        ..\msg.mc          \
        ..\vssadmin.rc

INCLUDES = ..\;\
        ..\..\..\inc; \
        ..\..\..\..\inc\derived; \
        $(BASE_INC_PATH)

TARGETLIBS = \
         $(SDK_LIB_PATH)\ole32.lib		\
         $(SDK_LIB_PATH)\user32.lib		\
         $(SDK_LIB_PATH)\oleaut32.lib	\
         $(SDK_LIB_PATH)\uuid.lib		\
         $(SDK_LIB_PATH)\ntmsapi.lib	\
         $(SDK_LIB_PATH)\kernel32.lib	\
         ..\..\..\lib\$(O)\tracing.lib		\
         $(SDK_LIB_PATH)\vss_uuid.lib	\
         ..\..\..\lib\$(O)\comadmin.lib		\
         ..\..\..\lib\$(O)\prop.lib			\
         $(SDK_LIB_PATH)\vssapi.lib		\
         $(SDK_LIB_PATH)\kernl32p.lib	\
		 $(COM_LIB_PATH)\prvidl.lib

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\vssadmin.h
PRECOMPILED_OBJ = precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\process.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module process.cpp | The processing functions for the VSS admin CLI
    @end

Author:

    Adi Oltean  [aoltean]  04/04/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     04/04/2000  Created
    ssteiner    10/20/2000  Changed List SnapshotSets to use more limited VSS queries.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

// The rest of includes are specified here
#include "vssadmin.h"
#include "commandverifier.h"
#include "versionspecific.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMPROCC"
//
////////////////////////////////////////////////////////////////////////

#define VSSADM_INFINITE_DIFFAREA 0xFFFFFFFFFFFFFFFF

#define VSS_CTX_ATTRIB_MASK 0x01F

/////////////////////////////////////////////////////////////////////////////
//  Implementation


class CVssAdmSnapshotSetEntry {
public:
    // Constructor - Throws NOTHING
    CVssAdmSnapshotSetEntry(
        IN VSS_ID SnapshotSetId,
        IN INT nOriginalSnapshotsCount
        ) : m_SnapshotSetId( SnapshotSetId ),
            m_nOriginalSnapshotCount(nOriginalSnapshotsCount)
            { }

    ~CVssAdmSnapshotSetEntry()
    {
        // Have to delete all snapshots entries
        int iCount = GetSnapshotCount();
        for ( int i = 0; i < iCount; ++i )
        {
            VSS_SNAPSHOT_PROP *pSSProp;
            pSSProp = GetSnapshotAt( i );
			::VssFreeSnapshotProperties(pSSProp);

            delete pSSProp;
        }

    }

    // Add new snapshot to the snapshot set
    HRESULT AddSnapshot(
        IN VSS_SNAPSHOT_PROP *pVssSnapshotProp )
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdmSnapshotSetEntry::AddSnapshot" );

        HRESULT hr = S_OK;
        try
        {
            VSS_SNAPSHOT_PROP *pNewVssSnapshotProp = new VSS_SNAPSHOT_PROP;
            if ( pNewVssSnapshotProp == NULL )
    			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );

            *pNewVssSnapshotProp = *pVssSnapshotProp;

            //
            //  Transfer of pointer ownership
            //
            if ( !m_mapSnapshots.Add( pNewVssSnapshotProp->m_SnapshotId, pNewVssSnapshotProp ) )
            {
                delete pNewVssSnapshotProp;
    			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
            }
        }
        BS_STANDARD_CATCH();

        return hr;
    }

    INT GetSnapshotCount() { return m_mapSnapshots.GetSize(); }

    INT GetOriginalSnapshotCount() { return m_nOriginalSnapshotCount; }

    VSS_ID GetSnapshotSetId() { return m_SnapshotSetId; }

    VSS_SNAPSHOT_PROP *GetSnapshotAt(
        IN int nIndex )
    {
        BS_ASSERT( !(nIndex < 0 || nIndex >= GetSnapshotCount()) );
        return m_mapSnapshots.GetValueAt( nIndex );
    }

private:
    VSS_ID  m_SnapshotSetId;
    INT     m_nOriginalSnapshotCount;
    CVssSimpleMap<VSS_ID, VSS_SNAPSHOT_PROP *> m_mapSnapshots;
};


// This class queries the list of all snapshots and assembles from the query
// the list of snapshotsets and the volumes which are in the snapshotset.
class CVssAdmSnapshotSets
{
public:
    // Constructor
    CVssAdmSnapshotSets() { };

    void Initialize(
        IN LONG lSnapshotContext,
        IN VSS_ID FilteredSnapshotSetId,
        IN VSS_ID FilteredSnapshotId,
        IN VSS_ID FilteredProviderId,
        IN LPCWSTR pwszFilteredForVolume
        )
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdmSnapshotSets::CVssAdmSnapshotSets" );

    	// Create the coordinator object
    	CComPtr<IVssCoordinator> pICoord;

        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VSSCoordinator,
                L"Coordinator",
                CLSCTX_ALL,
                IID_IVssCoordinator,
                (IUnknown**)&(pICoord));
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

        // Set the context
		ft.hr = pICoord->SetContext( lSnapshotContext );
        
        //
        //  If access denied, don't stop, it probably is a backup operator making this
        //  call.  Continue.  Also continue if E_NOTIMPL.  The coordinator will use the backup context.
        //
		if ( ft.HrFailed() && ft.hr != E_ACCESSDENIED && ft.hr != E_NOTIMPL )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"SetContext failed with hr = 0x%08lx", ft.hr);

		// Get list all snapshots
		CComPtr<IVssEnumObject> pIEnumSnapshots;
		ft.hr = pICoord->Query( GUID_NULL,
					VSS_OBJECT_NONE,
					VSS_OBJECT_SNAPSHOT,
					&pIEnumSnapshots );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

		// For all snapshots do...
		VSS_OBJECT_PROP Prop;
		for(;;) {
			// Get next element
			ULONG ulFetched;
			ft.hr = pIEnumSnapshots->Next( 1, &Prop, &ulFetched );
			if ( ft.HrFailed() )
				ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
			
			// Test if the cycle is finished
			if (ft.hr == S_FALSE) {
				BS_ASSERT( ulFetched == 0);
				break;
			}

            // Use auto delete class to manage the snapshot properties
            CVssAutoSnapshotProperties cSnap( Prop );
                
            // If filtering, skip entry if snapshot set id is not in the specified snapshot set
			if ( ( FilteredSnapshotSetId != GUID_NULL ) && 
			     !( cSnap->m_SnapshotSetId == FilteredSnapshotSetId ) )
			{
			    continue;
			}
			
            // If filtering, skip entry if snapshot id is not in the specified snapshot set
			if ( ( FilteredSnapshotId != GUID_NULL ) && 
			     !( cSnap->m_SnapshotId == FilteredSnapshotId ) )
			{
			    continue;
			}

            // If filtering, skip entry if provider ID is not in the specified snapshot
			if ( ( FilteredProviderId != GUID_NULL ) && 
			     !( cSnap->m_ProviderId == FilteredProviderId ) )
			{
			    continue;
			}

            // If filtering, skip entry if FOR volume is not in the specified snapshot
			if ( ( pwszFilteredForVolume != NULL ) && ( pwszFilteredForVolume[0] != '\0' ) && 
			     ( ::_wcsicmp( pwszFilteredForVolume, cSnap->m_pwszOriginalVolumeName ) != 0 ) )
			{
			    continue;
			}

            ft.Trace( VSSDBG_VSSADMIN, L"Snapshot: %s", cSnap->m_pwszOriginalVolumeName );

            // Look up the snapshot set id in the list of snapshot sets
            CVssAdmSnapshotSetEntry *pcSSE;
			pcSSE = m_mapSnapshotSets.Lookup( cSnap->m_SnapshotSetId );
			if ( pcSSE == NULL )
			{
			    // Haven't seen this snapshot set before, add it to list
			    pcSSE = new CVssAdmSnapshotSetEntry( cSnap->m_SnapshotSetId,
			                    cSnap->m_lSnapshotsCount );
			    if ( pcSSE == NULL )
        			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
			    if ( !m_mapSnapshotSets.Add( cSnap->m_SnapshotSetId, pcSSE ) )
			    {
			        delete pcSSE;
        			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
			    }
			}

			// Now add the snapshot to the snapshot set.  Transfer of pointer
			// ownership of &Snap.
			ft.hr = pcSSE->AddSnapshot( cSnap.GetPtr() );
			if ( ft.HrFailed() )
			{
      			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"AddSnapshot failed" );			
			}
			cSnap.Transferred();
		}
    }

    ~CVssAdmSnapshotSets()
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdmSnapshotSets::~CVssAdmSnapshotSets" );
        // Have to delete all
        int iCount;
        iCount = m_mapSnapshotSets.GetSize();
        for ( int i = 0; i < iCount; ++i )
        {
            delete m_mapSnapshotSets.GetValueAt( i );
        }
    }

    INT GetSnapshotSetCount() { return m_mapSnapshotSets.GetSize(); }

    CVssAdmSnapshotSetEntry *GetSnapshotSetAt(
        IN int nIndex )
    {
        BS_ASSERT( !(nIndex < 0 || nIndex >= GetSnapshotSetCount()) );
        return m_mapSnapshotSets.GetValueAt( nIndex );
    }


private:
    CVssSimpleMap<VSS_ID, CVssAdmSnapshotSetEntry *> m_mapSnapshotSets;
};

void CVssAdminCLI::GetDifferentialSoftwareSnapshotMgmtInterface(
    IN   VSS_ID ProviderId,
    IN   IVssSnapshotMgmt *pIMgmt,
	OUT  IUnknown**  ppItf
	)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"GetDifferentialSoftwareSnapshotMgmtInterface" );

    BS_ASSERT( pIMgmt != NULL );
    
	ft.hr = pIMgmt->GetProviderMgmtInterface( ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, ppItf );
	if ( ft.HrFailed() )
	{
	    if ( ft.hr == E_NOINTERFACE )
	    {
	        //  The provider doesn't support this interface
            OutputErrorMsg( MSG_ERROR_PROVIDER_DOESNT_SUPPORT_DIFFAREAS, GetOptionValueStr( VSSADM_O_PROVIDER ) );
      		ft.Throw( VSSDBG_VSSADMIN, S_OK, L"Provider doesn't support diff aras");
	    }
  		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetProviderMgmtInterface failed with hr = 0x%08lx", ft.hr);
	}
}
	
/////////////////////////////////////////////////////////////////////////////
//  Implementation


void CVssAdminCLI::PrintUsage(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::PrintUsage" );

    //
    //  Based on parsed command line type, print detailed command usage if
    //  eAdmCmd is valid, else print general vssadmin usage
    //
    if ( m_sParsedCommand.eAdmCmd != VSSADM_C_INVALID )
    {
        OutputMsg( g_asAdmCommands[m_sParsedCommand.eAdmCmd].lMsgDetail,
                   g_asAdmCommands[m_sParsedCommand.eAdmCmd].pwszMajorOption,
                   g_asAdmCommands[m_sParsedCommand.eAdmCmd].pwszMinorOption);
        if ( g_asAdmCommands[m_sParsedCommand.eAdmCmd].bShowSSTypes )
            DumpSnapshotTypes();
        return;
    }

    //
    //  Print out header
    //
    OutputMsg( MSG_USAGE );

    //
    //  Figure out the maximum command length to help with formatting
    //
    INT idx;
    INT iMaxLen = 0;

    
    for ( idx = VSSADM_C_FIRST; idx < VSSADM_C_NUM_COMMANDS; ++idx )
    {        
        if ( dCurrentSKU & g_asAdmCommands[idx].dwSKUs )
        {
            size_t cCmd;
            cCmd = ::wcslen( g_asAdmCommands[idx].pwszMajorOption ) +
                   ::wcslen( g_asAdmCommands[idx].pwszMinorOption ) + 2;
            if ( iMaxLen < (INT)cCmd )
                iMaxLen = (INT)cCmd;
        }
    }

    //
    //  Get a string to hold the string
    //
    CVssAutoPWSZ awszCommand;
    awszCommand.Allocate( iMaxLen );    
    LPWSTR pwszCommand = awszCommand;  // will be automatically deleted

    //
    //  Go through the list of commands and print the general information
    //  about each.
    //
    for ( idx = VSSADM_C_FIRST; idx < VSSADM_C_NUM_COMMANDS; ++idx )
    {
        if ( dCurrentSKU & g_asAdmCommands[idx].dwSKUs )
        {
            //  stick both parts of the command together
            ::wcscpy( pwszCommand, g_asAdmCommands[idx].pwszMajorOption );
            ::wcscat( pwszCommand, L" " );
            ::wcscat( pwszCommand, g_asAdmCommands[idx].pwszMinorOption );
            //  pad with spaces at the end
            for ( INT i = (INT) ::wcslen( pwszCommand); i < iMaxLen; ++i )
                pwszCommand[i] = L' ';
            pwszCommand[iMaxLen] = L'\0';
            OutputMsg( g_asAdmCommands[idx].lMsgGen, pwszCommand );
        }
    }

	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}

void CVssAdminCLI::AddDiffArea(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::AddDiffArea" );

    // grab all of the options
    VSS_ID ProviderId = GUID_NULL;
    GetProviderId( &ProviderId );

    LPWSTR forVolume = GetOptionValueStr( VSSADM_O_FOR );
    LPWSTR onVolume = GetOptionValueStr( VSSADM_O_ON );
    
    LONGLONG llMaxSize;
    if (!GetOptionValueNum( VSSADM_O_MAXSIZE, &llMaxSize ) )
        llMaxSize = VSSADM_INFINITE_DIFFAREA;

    // Verify the passed-in parameters
    m_pVerifier->AddDiffArea (ProviderId, forVolume, onVolume, llMaxSize, ft);
    
    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VssSnapshotMgmt,
            L"VssSnapshotMgmt",
            CLSCTX_ALL,
            IID_IVssSnapshotMgmt,
            (IUnknown**)&(pIMgmt));
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pIDiffSnapMgmt;
    GetDifferentialSoftwareSnapshotMgmtInterface( ProviderId, pIMgmt, (IUnknown**)&pIDiffSnapMgmt );

    //  Now add the assocation
    ft.hr = pIDiffSnapMgmt->AddDiffArea(forVolume, onVolume, llMaxSize );
	if ( ft.HrFailed() )
	{
	    switch( ft.hr )
	    {
	        case VSS_E_OBJECT_ALREADY_EXISTS:
                OutputErrorMsg( MSG_ERROR_ASSOCIATION_ALREADY_EXISTS );                        
	            break;
	        default: 
    	 		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"AddDiffArea failed with hr = 0x%08lx", ft.hr);
    	 		break;
	    }
	    
	    return;
	}
	
    //
    //  Print results, if needed
    //
    OutputMsg( MSG_INFO_ADDED_DIFFAREA );

	m_nReturnValue = VSS_CMDRET_SUCCESS;
}

void CVssAdminCLI::CreateSnapshot(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::CreateSnapshot" );

    // Grab all parameters to the function
    LONG lSnapshotContext = (dCurrentSKU & SKU_INT) ? 
    				DetermineSnapshotType( GetOptionValueStr( VSSADM_O_SNAPTYPE ) ) :
    				VSS_CTX_CLIENT_ACCESSIBLE;
                                         
    BS_ASSERT( lSnapshotContext | VSS_VOLSNAP_ATTR_NO_WRITERS );

    LPWSTR forVolume = GetOptionValueStr( VSSADM_O_FOR );

    VSS_ID ProviderId = GUID_NULL;
    GetProviderId( &ProviderId );

    LONGLONG llTimeout = 0;
    GetOptionValueNum (VSSADM_O_AUTORETRY, &llTimeout, false);

    // Verify the passed-in parameters
    m_pVerifier->CreateSnapshot (lSnapshotContext, forVolume, ProviderId, llTimeout, ft);
    
	// Create the coordinator object
	CComPtr<IVssCoordinator> pICoord;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VSSCoordinator,
            L"Coordinator",
            CLSCTX_ALL,
            IID_IVssCoordinator,
            (IUnknown**)&(pICoord));
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

    ft.hr = pICoord->SetContext(lSnapshotContext);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error from SetContext(0x%x) hr = 0x%08lx", lSnapshotContext, ft.hr);

	CComPtr<IVssAsync> pAsync;
	VSS_ID SnapshotSetId = GUID_NULL;

    // Starting a new snapshot set.  Note, if another process is creating snapshots, then
    // this will fail.  If AutoRetry was specified, then retry the start snapshot set for
    // that the specified number of minutes.
    if (llTimeout > 0)
    {
        LARGE_INTEGER liPerfCount;
        (void)QueryPerformanceCounter( &liPerfCount );
        ::srand( liPerfCount.LowPart );
        DWORD dwTickcountStart = ::GetTickCount();
        do
        {
            ft.hr = pICoord->StartSnapshotSet(&SnapshotSetId);
            if ( ft.HrFailed() )
            {
                if ( ft.hr == VSS_E_SNAPSHOT_SET_IN_PROGRESS && 
                     ( (LONGLONG)( ::GetTickCount() - dwTickcountStart ) < ( llTimeout * 1000 * 60 ) ) )
                {
                    static dwMSec = 250; // Starting retry time
                    if ( dwMSec < 10000 )
                    {
                        dwMSec += ::rand() % 750;
                    }
                    ft.Trace( VSSDBG_VSSADMIN, L"Snapshot already in progress, retrying in %u millisecs", dwMSec );
                    Sleep( dwMSec );
                }
                else
                {
                    ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error from StartSnapshotSet hr = 0x%08lx", ft.hr);
                }
            }
        } while ( ft.HrFailed() );
    }
    else
    {
        //
        //  Error right away with out a timeout when there is another snapshot in progress.
        //
        ft.hr = pICoord->StartSnapshotSet(&SnapshotSetId);
        if ( ft.HrFailed() )
        {
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error from StartSnapshotSet hr = 0x%08lx", ft.hr);
        }
    }
    
    // Add the volume to the snapshot set
    VSS_ID SnapshotId = GUID_NULL;
    ft.hr = pICoord->AddToSnapshotSet(
            forVolume,
            ProviderId,
            &SnapshotId);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error from AddToSnapshotSet hr = 0x%08lx", ft.hr);

    ft.hr = S_OK;
    pAsync = NULL;
    ft.hr = pICoord->DoSnapshotSet(NULL, &pAsync);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"Error from DoSnapshotSet hr = 0x%08lx", ft.hr);

	ft.hr = pAsync->Wait();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"Error from Wait hr = 0x%08lx", ft.hr);

    HRESULT hrStatus;
	ft.hr = pAsync->QueryStatus(&hrStatus, NULL);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"Error from QueryStatus hr = 0x%08lx", ft.hr);

    //
    // If VSS failed to create the snapshot, it's result code is in hrStatus.  Process
    // it.
    //
    ft.hr = hrStatus;
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"QueryStatus hrStatus parameter returned error, hr = 0x%08lx", ft.hr);

    //
    //  Print results
    //
    VSS_SNAPSHOT_PROP sSSProp;
    ft.hr = pICoord->GetSnapshotProperties( SnapshotId, &sSSProp );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"Error from GetId hr = 0x%08lx", ft.hr);

    CVssAutoPWSZ awszSnapshotId( ::GuidToString( SnapshotId ) );

    OutputMsg( MSG_INFO_SNAPSHOT_CREATED, forVolume,
        (LPWSTR)awszSnapshotId, sSSProp.m_pwszSnapshotDeviceObject );
        
    ::VssFreeSnapshotProperties(&sSSProp);

    m_nReturnValue = VSS_CMDRET_SUCCESS;    
}

void CVssAdminCLI::DisplayDiffAreasPrivate(
   	IVssEnumMgmtObject *pIEnumMgmt	
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::DisplayDiffAreasPrivate" );

	// For all diffareas do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_AREA_PROP& DiffArea = Prop.Obj.DiffArea; 
	for(;;) 
	{
		// Get next element
		ULONG ulFetched;
		ft.hr = pIEnumMgmt->Next( 1, &Prop, &ulFetched );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

                
        CVssAutoPWSZ awszVolumeName( DiffArea.m_pwszVolumeName );
        CVssAutoPWSZ awszDiffAreaVolumeName( DiffArea.m_pwszDiffAreaVolumeName );
        CVssAutoPWSZ awszUsedSpace( FormatNumber( DiffArea.m_llUsedDiffSpace ) );
        CVssAutoPWSZ awszAllocatedSpace( FormatNumber( DiffArea.m_llAllocatedDiffSpace ) );
        CVssAutoPWSZ awszMaxSpace( FormatNumber( DiffArea.m_llMaximumDiffSpace ) );
        LPCWSTR pwszVolumeDisplayName = GetVolumeDisplayName( awszVolumeName );
        LPCWSTR pwszDiffAreaVolumeDisplayName = GetVolumeDisplayName( awszDiffAreaVolumeName );

        OutputMsg( MSG_INFO_SNAPSHOT_STORAGE_CONTENTS,
            pwszVolumeDisplayName,
            (LPWSTR)awszVolumeName, 
            pwszDiffAreaVolumeDisplayName,
            (LPWSTR)awszDiffAreaVolumeName,
            (LPWSTR)awszUsedSpace,
            (LPWSTR)awszAllocatedSpace,
            (LPWSTR)awszMaxSpace
            );
   	}
}

void CVssAdminCLI::ListDiffAreas(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ListDiffAreas" );

    // Grab all parameters
    VSS_ID ProviderId = GUID_NULL;
    GetProviderId( &ProviderId );

    LPWSTR forVolume = GetOptionValueStr (VSSADM_O_FOR);
    LPWSTR onVolume = GetOptionValueStr (VSSADM_O_ON);

    // Verify all parameters
    m_pVerifier->ListDiffAreas (ProviderId, forVolume, onVolume, ft);
    
    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VssSnapshotMgmt,
            L"VssSnapshotMgmt",
            CLSCTX_ALL,
            IID_IVssSnapshotMgmt,
            (IUnknown**)&(pIMgmt));
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pIDiffSnapMgmt;
    GetDifferentialSoftwareSnapshotMgmtInterface( ProviderId, pIMgmt, (IUnknown**)&pIDiffSnapMgmt );

    //  See if query by for volume
    if (forVolume != NULL )
    {        
        //  Query by For volume
    	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
        ft.hr = pIDiffSnapMgmt->QueryDiffAreasForVolume( 
                    forVolume,
                    &pIEnumMgmt );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryDiffAreasForVolume failed, hr = 0x%08lx", ft.hr);

        if ( ft.hr == S_FALSE )
            // empty query
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::ListDiffareas: No diffareas found that satisfy the query" );

        DisplayDiffAreasPrivate( pIEnumMgmt );
    }
    else if (onVolume != NULL )
    {
        //  Query by On volume
    	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
        ft.hr = pIDiffSnapMgmt->QueryDiffAreasOnVolume( 
                    onVolume,
                    &pIEnumMgmt );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryDiffAreasOnVolume failed, hr = 0x%08lx", ft.hr);
            
        if ( ft.hr == S_FALSE )
            // empty query
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::ListDiffareas: No diffareas found that satisfy the query" );

        DisplayDiffAreasPrivate( pIEnumMgmt );
    }
    else
    {
        //  Query all diff areas

        BOOL bEmptyQuery = TRUE;
        
        //
        //  Get the list of all volumes
        //
    	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
        ft.hr = pIMgmt->QueryVolumesSupportedForSnapshots( 
                    ProviderId,
                    VSS_CTX_ALL,
                    &pIEnumMgmt );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryVolumesSupportedForSnapshots failed, hr = 0x%08lx", ft.hr);

        if ( ft.hr == S_FALSE )
            // empty query
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::ListDiffareas: No diffareas found that satisfy the query" );

        //
        //  Query each volume to see if diff areas exist.
        //
    	VSS_MGMT_OBJECT_PROP Prop;
    	VSS_VOLUME_PROP& VolProp = Prop.Obj.Vol; 
    	for(;;) 
    	{
    		// Get next element
    		ULONG ulFetched;
    		ft.hr = pIEnumMgmt->Next( 1, &Prop, &ulFetched );
    		if ( ft.HrFailed() )
    			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
    		
    		// Test if the cycle is finished
    		if (ft.hr == S_FALSE) {
    			BS_ASSERT( ulFetched == 0);
    			break;
    		}

            CVssAutoPWSZ awszVolumeName( VolProp.m_pwszVolumeName );
            CVssAutoPWSZ awszVolumeDisplayName( VolProp.m_pwszVolumeDisplayName );
            
        	// For all volumes do...
        	CComPtr<IVssEnumMgmtObject> pIEnumMgmtDiffArea;
            ft.hr = pIDiffSnapMgmt->QueryDiffAreasForVolume( 
                        awszVolumeName,
                        &pIEnumMgmtDiffArea );
            if ( ft.HrFailed() )
            {
                ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryDiffAreasForVolume failed, hr = 0x%08lx", ft.hr);
            }
            
            if ( ft.hr == S_FALSE )
            {
                // empty query
                continue;
            }
            
            DisplayDiffAreasPrivate( pIEnumMgmtDiffArea );
            bEmptyQuery = FALSE;
       	}
        if ( bEmptyQuery )
            // empty query
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::ListDiffareas: No diffareas found that satisfy the query" );    	
    }

    m_nReturnValue = VSS_CMDRET_SUCCESS;
}

void CVssAdminCLI::ListSnapshots(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ListSnapshots" );

    // gather parameters
    LONG lSnapshotContext = (dCurrentSKU & SKU_INT) ? 
    						    DetermineSnapshotType( GetOptionValueStr( VSSADM_O_SNAPTYPE ) ) :
    						    VSS_CTX_ALL;

    VSS_ID ProviderId = GUID_NULL;
    GetProviderId( &ProviderId );

    LPCWSTR forVolume = GetOptionValueStr( VSSADM_O_FOR );
    
    bool bNonEmptyResult = false;

    // --- get the set id
    VSS_ID guidSSID = GUID_NULL;
    if ( GetOptionValueStr( VSSADM_O_SET ) != NULL && 
    	   !ScanGuid( GetOptionValueStr( VSSADM_O_SET ), guidSSID ))	
    {
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
            L"CVssAdminCLI::ListSnapshots: invalid snapshot set ID: %s",
            GetOptionValueStr( VSSADM_O_SET ) );
    }

    // --- get the snapshot id
    VSS_ID guidSnapID = GUID_NULL;
    if ( GetOptionValueStr( VSSADM_O_SNAPSHOT ) != NULL &&
    	   !ScanGuid( GetOptionValueStr( VSSADM_O_SNAPSHOT ), guidSnapID ))
    {
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
                L"CVssAdminCLI::ListSnapshots: invalid snapshot ID: %s",
                GetOptionValueStr( VSSADM_O_SNAPSHOT ) );
    }

    // verify the parameters
    m_pVerifier->ListSnapshots (lSnapshotContext, ProviderId, forVolume, guidSnapID, guidSSID, ft);
    
    // See if we have to filter by volume name
  	WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1] = L"";    
    if (forVolume != NULL )
    {
        // Calculate the unique volume name, just to make sure that we have the right path
        // If FOR volume name starts with the '\', assume it is already in the correct volume name format.
        // This is important for transported volumes since GetVolumeNameForVolumeMountPointW() won't work.
        if ( forVolume[0] != L'\\' )
        {
    	    if (!::GetVolumeNameForVolumeMountPointW(forVolume,
    		    	wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
        		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
        				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
        				  L"failed with error code 0x%08lx", forVolume, ::GetLastError());
        }
        else
        {
            ::wcsncpy( wszVolumeNameInternal, forVolume, STRING_LEN(wszVolumeNameInternal) );
            wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName] = L'\0';
        }
    }
    
    //
    //  See if we have to filter by provider
    //

    //  Query the snapshots
    CVssAdmSnapshotSets cVssAdmSS;
    cVssAdmSS.Initialize( lSnapshotContext, guidSSID, guidSnapID, ProviderId, wszVolumeNameInternal );

    INT iSnapshotSetCount = cVssAdmSS.GetSnapshotSetCount();

    // If there are no present snapshots then display a message.
    if (iSnapshotSetCount == 0) {
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
            L"CVssAdminCLI::ListSnapshots: No snapshots found that satisfy the query");
    }

	// For all snapshot sets do...
    for ( INT iSSS = 0; iSSS < iSnapshotSetCount; ++iSSS )
    {
        CVssAdmSnapshotSetEntry *pcSSE;

        pcSSE = cVssAdmSS.GetSnapshotSetAt( iSSS );
        BS_ASSERT( pcSSE != NULL );

        CVssAutoPWSZ awszGuid( ::GuidToString( pcSSE->GetSnapshotSetId() ) ) ;
        CVssAutoPWSZ awszDateTime( ::DateTimeToString( &( pcSSE->GetSnapshotAt( 0 )->m_tsCreationTimestamp ) ) );
        
		// Print each snapshot set
		OutputMsg( 
		    MSG_INFO_SNAPSHOT_SET_HEADER,
			(LPWSTR)awszGuid, 
			pcSSE->GetOriginalSnapshotCount(), 
			(LPWSTR)awszDateTime );
		
		INT iSnapshotCount = pcSSE->GetSnapshotCount();
		
		VSS_SNAPSHOT_PROP *pSnap;
		for( INT iSS = 0; iSS < iSnapshotCount; ++iSS ) {
		    pSnap = pcSSE->GetSnapshotAt( iSS );
            BS_ASSERT( pSnap != NULL );

    		// Get the provider name
			LPCWSTR pwszProviderName = GetProviderName( pSnap->m_ProviderId );
            CVssAutoPWSZ awszAttributeStr( BuildSnapshotAttributeDisplayString( pSnap->m_lSnapshotAttributes ) );			
            CVssAutoPWSZ awszSnapshotType( DetermineSnapshotType( pSnap->m_lSnapshotAttributes ) );
            
            // Print each snapshot            
			CVssAutoPWSZ awszSnapGuid( ::GuidToString( pSnap->m_SnapshotId ) );  
            LPCWSTR pwszVolumeDisplayName = GetVolumeDisplayName( pSnap->m_pwszOriginalVolumeName );
            
			OutputMsg(  
			    MSG_INFO_SNAPSHOT_CONTENTS,                
				(LPWSTR)awszSnapGuid, 
				pwszVolumeDisplayName ? pwszVolumeDisplayName : L"?",
				pSnap->m_pwszOriginalVolumeName, 
				pSnap->m_pwszSnapshotDeviceObject,
				pSnap->m_pwszOriginatingMachine ? pSnap->m_pwszOriginatingMachine : L"",
				pSnap->m_pwszServiceMachine ? pSnap->m_pwszServiceMachine : L"",  // fix this when the idl file changes
				pwszProviderName ? pwszProviderName : L"?",
				(LPWSTR)awszSnapshotType,
				(LPWSTR)awszAttributeStr
				);

			bNonEmptyResult = true;
		}
	}

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}


void CVssAdminCLI::DumpSnapshotTypes(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::DumpSnapshotTypes" );

    //
    //  Dump list of snapshot types based on SKU
    //
    INT idx;

    // Determine type of snapshot
    for ( idx = 0; g_asAdmTypeNames[idx].pwszName != NULL; ++idx )
    {
        if ( dCurrentSKU & g_asAdmTypeNames[idx].dwSKUs )
        {
            OutputMsg (g_asAdmTypeNames[idx].pwszDescription,
            			g_asAdmTypeNames[idx].pwszName);
        }
    }    
}

void CVssAdminCLI::ListWriters(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ListWriters" );

    // verify the parameters
    m_pVerifier->ListWriters (ft);
    
    bool bNonEmptyResult = false;

    // Get the backup components object
    CComPtr<IVssBackupComponents> pBackupComp;
	CComPtr<IVssAsync> pAsync;
    ft.hr = ::CreateVssBackupComponents(&pBackupComp);
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"CreateVssBackupComponents failed with hr = 0x%08lx", ft.hr);

    ft.hr = pBackupComp->InitializeForBackup();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"InitializeForBackup failed with hr = 0x%08lx", ft.hr);

	UINT unWritersCount;
	// get metadata for all writers
	ft.hr = pBackupComp->GatherWriterMetadata(&pAsync);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GatherWriterMetadata failed with hr = 0x%08lx", ft.hr);

    // Using polling, try to obtain the list of writers as soon as possible
    HRESULT hrReturned = S_OK;
    for (int nRetries = 0; nRetries < x_nMaxRetriesCount; nRetries++ ) {

        // Wait a little
        ::Sleep(x_nPollingInterval);

        // Check if finished
        INT nReserved = 0;
    	ft.hr = pAsync->QueryStatus(
    	    &hrReturned,
    	    &nReserved
    	    );
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, ft.hr,
                L"IVssAsync::QueryStatus failed with hr = 0x%08lx", ft.hr);
        if (hrReturned == VSS_S_ASYNC_FINISHED)
            break;
        if (hrReturned == VSS_S_ASYNC_PENDING)
            continue;
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"IVssAsync::QueryStatus returned hr = 0x%08lx", hrReturned);
    }

    // If still not ready, then print the "waiting for responses" message and wait.
    if (hrReturned == VSS_S_ASYNC_PENDING) {
        OutputMsg( MSG_INFO_WAITING_RESPONSES );
    	ft.hr = pAsync->Wait();
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::Wait failed with hr = 0x%08lx", ft.hr);
    }

	pAsync = NULL;
	
    // Free the writer metadata
	ft.hr = pBackupComp->FreeWriterMetadata();
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"FreeWriterMetadata failed with hr = 0x%08lx", ft.hr);
	
    // Gather the status of all writers
	ft.hr = pBackupComp->GatherWriterStatus(&pAsync);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GatherWriterStatus failed with hr = 0x%08lx", ft.hr);

	ft.hr = pAsync->Wait();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::Wait failed with hr = 0x%08lx", ft.hr);

	pAsync = NULL;

	ft.hr = pBackupComp->GetWriterStatusCount(&unWritersCount);
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetWriterStatusCount failed with hr = 0x%08lx", ft.hr);

    // Print each writer status+supplementary info
	for(UINT unIndex = 0; unIndex < unWritersCount; unIndex++)
	{
		VSS_ID idInstance = GUID_NULL;
		VSS_ID idWriter = GUID_NULL;
		CComBSTR bstrWriter;
		VSS_WRITER_STATE eStatus;
		HRESULT hrWriterFailure;

        // Get the status for the (unIndex)-th writer
		ft.hr = pBackupComp->GetWriterStatus(unIndex, &idInstance, &idWriter, &bstrWriter, &eStatus, &hrWriterFailure);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetWriterStatus failed with hr = 0x%08lx", ft.hr);

        // Get the status description strings
        LPCWSTR pwszStatusDescription;
        switch (eStatus) 
        {
            case VSS_WS_STABLE:
                pwszStatusDescription = LoadString( IDS_WRITER_STATUS_STABLE);
                break;
            case VSS_WS_WAITING_FOR_FREEZE:
                pwszStatusDescription = LoadString( IDS_WRITER_STATUS_WAITING_FOR_FREEZE);
                break;
            case VSS_WS_WAITING_FOR_THAW:
                pwszStatusDescription = LoadString( IDS_WRITER_STATUS_FROZEN);
                break;
            case VSS_WS_WAITING_FOR_POST_SNAPSHOT:
                pwszStatusDescription = LoadString( IDS_WRITER_STATUS_WAITING_FOR_POST_SNAPSHOT);
                break;
            case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
                pwszStatusDescription = LoadString( IDS_WRITER_STATUS_WAITING_FOR_COMPLETION);
                break;
            case VSS_WS_FAILED_AT_IDENTIFY:
            case VSS_WS_FAILED_AT_PREPARE_BACKUP:
            case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
            case VSS_WS_FAILED_AT_FREEZE:
            case VSS_WS_FAILED_AT_THAW:
            case VSS_WS_FAILED_AT_POST_SNAPSHOT:
            case VSS_WS_FAILED_AT_BACKUP_COMPLETE:
            case VSS_WS_FAILED_AT_PRE_RESTORE:                
            case VSS_WS_FAILED_AT_POST_RESTORE:                
                pwszStatusDescription = LoadString( IDS_WRITER_STATUS_FAILED);
                break;
            default:
                pwszStatusDescription = LoadString( IDS_WRITER_STATUS_UNKNOWN);
                break;
        }
        BS_ASSERT(pwszStatusDescription);

        LPCWSTR pwszWriterError;
        switch ( hrWriterFailure )
        {
            case S_OK:
                pwszWriterError = LoadString ( IDS_WRITER_ERROR_SUCCESS );
                break;
            case VSS_E_WRITER_NOT_RESPONDING:
                pwszWriterError = LoadString( IDS_WRITER_ERROR_NOT_RESPONDING );
                break; 
            case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
                pwszWriterError = LoadString( IDS_WRITER_ERROR_INCONSISTENTSNAPSHOT);
                break; 
            case VSS_E_WRITERERROR_OUTOFRESOURCES:
                pwszWriterError = LoadString( IDS_WRITER_ERROR_OUTOFRESOURCES);
                break;
            case VSS_E_WRITERERROR_TIMEOUT:
                pwszWriterError = LoadString( IDS_WRITER_ERROR_TIMEOUT);
                break;        
            case VSS_E_WRITERERROR_RETRYABLE:
                pwszWriterError = LoadString( IDS_WRITER_ERROR_RETRYABLE);
                break;
            case VSS_E_WRITERERROR_NONRETRYABLE:
                pwszWriterError = LoadString( IDS_WRITER_ERROR_NONRETRYABLE);
                break;
            default:
                pwszWriterError = LoadString( IDS_WRITER_ERROR_UNEXPECTED);
                ft.Trace( VSSDBG_VSSADMIN, L"Unexpected writer error failure: 0x%08x", hrWriterFailure );
                break;                
        }
        
        CVssAutoPWSZ awszWriterId( ::GuidToString( idWriter ) );
		CVssAutoPWSZ awszInstanceId( ::GuidToString( idInstance ) );
		
		OutputMsg( MSG_INFO_WRITER_CONTENTS,
            (LPWSTR)bstrWriter ? (LPWSTR)bstrWriter : L"",
			(LPWSTR)awszWriterId,
			(LPWSTR)awszInstanceId,
            (INT)eStatus,
			pwszStatusDescription,
			pwszWriterError
			);
		
		bNonEmptyResult = true;
    }

	ft.hr = pBackupComp->FreeWriterStatus();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"FreeWriterStatus failed with hr = 0x%08lx", ft.hr);

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}


void CVssAdminCLI::ListProviders(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ListProviders" );

    // verify the parameters
    m_pVerifier->ListProviders (ft);
    
    bool bNonEmptyResult = false;

	// Create the coordinator object
	CComPtr<IVssCoordinator> pICoord;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VSSCoordinator,
            L"Coordinator",
            CLSCTX_ALL,
            IID_IVssCoordinator,
            (IUnknown**)&(pICoord));
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Query all (filtered) snapshot sets
	CComPtr<IVssEnumObject> pIEnumProv;
	ft.hr = pICoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_PROVIDER,
				&pIEnumProv );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

	// For all snapshot sets do...
	VSS_OBJECT_PROP Prop;
	VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		ft.hr = pIEnumProv->Next( 1, &Prop, &ulFetched );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
		
		// Test if the cycle is ended
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        // Get the provider type strings
        LPCWSTR pwszProviderType;
        switch (Prov.m_eProviderType) {
        case VSS_PROV_SYSTEM:
            pwszProviderType = LoadString( IDS_PROV_TYPE_SYSTEM);
            break;
        case VSS_PROV_SOFTWARE:
            pwszProviderType = LoadString( IDS_PROV_TYPE_SOFTWARE);
            break;
        case VSS_PROV_HARDWARE:
            pwszProviderType = LoadString( IDS_PROV_TYPE_HARDWARE);
            break;
        default:
            pwszProviderType = LoadString( IDS_PROV_TYPE_UNKNOWN);
            break;
        }
        BS_ASSERT(pwszProviderType);

		// Print each snapshot set
		CVssAutoPWSZ awszProviderId( ::GuidToString( Prov.m_ProviderId ) );
        CVssAutoPWSZ awszProviderName( Prov.m_pwszProviderName );
        CVssAutoPWSZ awszProviderVersion( Prov.m_pwszProviderVersion );

		OutputMsg( MSG_INFO_PROVIDER_CONTENTS,
            (LPWSTR)awszProviderName ? (LPWSTR)awszProviderName: L"",
			pwszProviderType,
			(LPWSTR)awszProviderId,
            (LPWSTR)awszProviderVersion ? (LPWSTR)awszProviderVersion: L"");

		bNonEmptyResult = true;
	}

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}

void CVssAdminCLI::ListVolumes(
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ListVolumes" );

    // gather the parameters
    LONG lContext = (dCurrentSKU & SKU_INT) ?
    			DetermineSnapshotType( GetOptionValueStr( VSSADM_O_SNAPTYPE ) ) :
    			VSS_CTX_CLIENT_ACCESSIBLE;

    VSS_ID ProviderId = GUID_NULL;
    GetProviderId( &ProviderId );

    // verify the parameters
    m_pVerifier->ListVolumes (ProviderId, lContext, ft);
    
    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VssSnapshotMgmt,
            L"VssSnapshotMgmt",
            CLSCTX_ALL,
            IID_IVssSnapshotMgmt,
            (IUnknown**)&(pIMgmt));
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

    //
    //  Get the list of all volumes
    //
	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
    ft.hr = pIMgmt->QueryVolumesSupportedForSnapshots( 
                ProviderId,
                lContext,
                &pIEnumMgmt );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryVolumesSupportedForSnapshots failed, hr = 0x%08lx", ft.hr);

    if ( ft.hr == S_FALSE )
        // empty query
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
            L"CVssAdminCLI::ListVolumes: No volumes found that satisfy the query" );

    //
    //  Query each volume to see if diff areas exist.
    //
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_VOLUME_PROP& VolProp = Prop.Obj.Vol; 

	for(;;) 
	{
		// Get next element
		ULONG ulFetched;
		ft.hr = pIEnumMgmt->Next( 1, &Prop, &ulFetched );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        CVssAutoPWSZ awszVolumeName( VolProp.m_pwszVolumeName );
        CVssAutoPWSZ awszVolumeDisplayName( VolProp.m_pwszVolumeDisplayName );
        OutputMsg( MSG_INFO_VOLUME_CONTENTS, (LPWSTR)awszVolumeDisplayName, (LPWSTR)awszVolumeName );        
	}

	m_nReturnValue = VSS_CMDRET_SUCCESS;
}

void CVssAdminCLI::ResizeDiffArea(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ResizeDiffArea" );

    // gather the parameters
    VSS_ID ProviderId = GUID_NULL;
    GetProviderId( &ProviderId );

    LPWSTR forVolume = GetOptionValueStr( VSSADM_O_FOR );
    LPWSTR onVolume = GetOptionValueStr( VSSADM_O_ON );
    LONGLONG llMaxSize = 0;
    if (!GetOptionValueNum( VSSADM_O_MAXSIZE, &llMaxSize ))
    {
    	llMaxSize = VSSADM_INFINITE_DIFFAREA;
    }

    // verify the parameters
    m_pVerifier->ResizeDiffArea (ProviderId, forVolume, onVolume, llMaxSize, ft);
    
    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VssSnapshotMgmt,
            L"VssSnapshotMgmt",
            CLSCTX_ALL,
            IID_IVssSnapshotMgmt,
            (IUnknown**)&(pIMgmt));
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pIDiffSnapMgmt;
    GetDifferentialSoftwareSnapshotMgmtInterface( ProviderId, pIMgmt, (IUnknown**)&pIDiffSnapMgmt );

    //  Now add the assocation
    ft.hr = pIDiffSnapMgmt->ChangeDiffAreaMaximumSize(forVolume, onVolume, llMaxSize );
	if ( ft.HrFailed() )
	{
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )  // should be VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS
        {
	        //  The associations was not found
            OutputErrorMsg( MSG_ERROR_ASSOCIATION_NOT_FOUND );                        
	        return;
        }
        else
    		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"ResizeDiffArea failed with hr = 0x%08lx", ft.hr);
	}
	
    //
    //  Print results, if needed
    //
    OutputMsg( MSG_INFO_RESIZED_DIFFAREA );
 
	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}
    

void CVssAdminCLI::DeleteDiffAreas(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::DeleteDiffAreas" );

    // gather the parameters
    VSS_ID ProviderId = GUID_NULL;
    GetProviderId( &ProviderId );
    
    LPWSTR forVolume = GetOptionValueStr( VSSADM_O_FOR );
    LPWSTR onVolume = GetOptionValueStr( VSSADM_O_ON );

    // verify the parameters
    m_pVerifier->DeleteDiffAreas (ProviderId, forVolume, onVolume, IsQuiet() == TRUE, ft);
    
    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VssSnapshotMgmt,
            L"VssSnapshotMgmt",
            CLSCTX_ALL,
            IID_IVssSnapshotMgmt,
            (IUnknown**)&(pIMgmt));
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pIDiffSnapMgmt;
    GetDifferentialSoftwareSnapshotMgmtInterface( ProviderId, pIMgmt, (IUnknown**)&pIDiffSnapMgmt );

    //
    //  See if the on option was provided.  If not, determine what the on value is:
    //
    CVssAutoPWSZ awszOnVol;
    
    if (onVolume == NULL )
    {
        //  Need to query the association to get the on value...
    	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
        ft.hr = pIDiffSnapMgmt->QueryDiffAreasForVolume( 
                    forVolume,
                    &pIEnumMgmt );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryDiffAreasForVolume failed, hr = 0x%08lx", ft.hr);

        if ( ft.hr == S_FALSE )
        {
            // empty query
            OutputErrorMsg( MSG_ERROR_ASSOCIATION_NOT_FOUND );                        
	        return;
        }

        
    	VSS_MGMT_OBJECT_PROP Prop;
    	VSS_DIFF_AREA_PROP& DiffArea = Prop.Obj.DiffArea; 
  		// Get next element
   		ULONG ulFetched;
   		ft.hr = pIEnumMgmt->Next( 1, &Prop, &ulFetched );
   		if ( ft.HrFailed() )
   			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
   		
   		// Test if the cycle is finished
   		if (ft.hr == S_FALSE) 
   		{
            OutputErrorMsg( MSG_ERROR_ASSOCIATION_NOT_FOUND );                        
	        return;
   		}

        ::VssFreeString( DiffArea.m_pwszVolumeName );

        CVssAutoPWSZ awszDiffAreaVolumeName( DiffArea.m_pwszDiffAreaVolumeName );

   		//  Save it away in the auto delete object.
        awszOnVol.CopyFrom( awszDiffAreaVolumeName );
        onVolume = awszOnVol;
    }
    
    //  Now delete the assocation by changing the size to zero
    ft.hr = pIDiffSnapMgmt->ChangeDiffAreaMaximumSize( 
        forVolume, 
        onVolume, 
        0 );
	if ( ft.HrFailed() )
	{
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )  // should be VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS
        {
	        //  The associations was not found
            OutputErrorMsg( MSG_ERROR_ASSOCIATION_NOT_FOUND );                        
	        return;
        }
        else if ( ft.hr == VSS_E_VOLUME_IN_USE ) 
        {
	        //  Can't delete associations that are in use
            OutputErrorMsg( MSG_ERROR_ASSOCIATION_IS_IN_USE );                        
	        return;
        }
        else
    		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"ResizeDiffArea to 0 failed with hr = 0x%08lx", ft.hr);
	}
	
    //
    //  Print results, if needed
    //
    if ( !IsQuiet() )
    {
        OutputMsg( MSG_INFO_DELETED_DIFFAREAS );
    }

	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}
    
void CVssAdminCLI::DeleteSnapshots(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::DeleteSnapshots" );

   // gather the parameters
    LONG lContext = (dCurrentSKU & SKU_INT) ? 
    			DetermineSnapshotType( GetOptionValueStr( VSSADM_O_SNAPTYPE ) ) :
    			VSS_CTX_CLIENT_ACCESSIBLE;


    LPCWSTR forVolume = GetOptionValueStr( VSSADM_O_FOR );
    BOOL oldest = GetOptionValueBool( VSSADM_O_OLDEST );
    BOOL all = GetOptionValueBool(VSSADM_O_ALL);
    
    VSS_ID SnapshotId = GUID_NULL;
    if (GetOptionValueStr (VSSADM_O_SNAPSHOT) &&
    	  !ScanGuid (GetOptionValueStr (VSSADM_O_SNAPSHOT), SnapshotId))
    {
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
                L"CVssAdminCLI::DeleteSnapshots: Invalid snapshot id" );    
    }

    // verify the parameters
    m_pVerifier->DeleteSnapshots (lContext, forVolume, all == TRUE, oldest==TRUE, SnapshotId, IsQuiet()==TRUE, ft);
    
    LONG lNumDeleted = 0;
    
    if ( GetOptionValueStr( VSSADM_O_SNAPSHOT ) )
    {
        //
        //  Let's try to delete the snapshot
        //
        if ( PromptUserForConfirmation( MSG_INFO_PROMPT_USER_FOR_DELETE_SNAPSHOTS, 1 ) )
        {
            // Create the coordinator object
        	CComPtr<IVssCoordinator> pICoord;

            ft.CoCreateInstanceWithLog(
                    VSSDBG_VSSADMIN,
                    CLSID_VSSCoordinator,
                    L"Coordinator",
                    CLSCTX_ALL,
                    IID_IVssCoordinator,
                    (IUnknown**)&(pICoord));
            if ( ft.HrFailed() )
                ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

            //  Set all context
            ft.hr = pICoord->SetContext( lContext );
            if ( ft.HrFailed() )
                ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"SetContext failed with hr = 0x%08lx", ft.hr);
            
            VSS_ID NondeletedSnapshotId = GUID_NULL;
            
            ft.hr = pICoord->DeleteSnapshots(
                        SnapshotId,
                        VSS_OBJECT_SNAPSHOT,
                        TRUE,
                        &lNumDeleted,
                        &NondeletedSnapshotId );
            if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
            {
                OutputErrorMsg( MSG_ERROR_SNAPSHOT_NOT_FOUND, GetOptionValueStr( VSSADM_O_SNAPSHOT ) );
            } 
            else if ( ft.HrFailed() )
            {
                ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"DeleteSnapshots failed with hr = 0x%08lx", ft.hr);
            }
        }
    }
    else
    {   
        BS_ASSERT (GetOptionValueStr(VSSADM_O_SNAPSHOT) == NULL);

        // Calculate the unique volume name, just to make sure that we have the right path
    	WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
        memset (wszVolumeNameInternal, 0, sizeof(wszVolumeNameInternal));
        
        // If FOR volume name starts with the '\', assume it is already in the correct volume name format.
        // This is important for transported volumes since GetVolumeNameForVolumeMountPointW() won't work.
        if (forVolume != NULL && forVolume[0] != L'\\' )
        {
    	    if (!::GetVolumeNameForVolumeMountPointW( forVolume,
    		    	wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
        		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
        				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
        				  L"failed with error code 0x%08lx", GetOptionValueStr( VSSADM_O_FOR ), ::GetLastError());
        }
        else if (forVolume != NULL)
        {
            ::wcsncpy( wszVolumeNameInternal, forVolume, STRING_LEN(wszVolumeNameInternal) );
            wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName] = L'\0';
        }
        
    	// Create the coordinator object
    	CComPtr<IVssCoordinator> pICoord;

        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VSSCoordinator,
                L"Coordinator",
                CLSCTX_ALL,
                IID_IVssCoordinator,
                (IUnknown**)&(pICoord));
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

        // Set the context
		ft.hr = pICoord->SetContext( lContext);
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"SetContext failed with hr = 0x%08lx", ft.hr);

		// Get list all snapshots
		CComPtr<IVssEnumObject> pIEnumSnapshots;
		ft.hr = pICoord->Query( GUID_NULL,
					VSS_OBJECT_NONE,
					VSS_OBJECT_SNAPSHOT,
					&pIEnumSnapshots );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

		// For all snapshots do...
		VSS_ID OldestSnapshotId = GUID_NULL;   // used if Oldest option is specified
		VSS_TIMESTAMP OldestSnapshotTimestamp = 0x7FFFFFFFFFFFFFFF; // Used if Oldest option is specified
		
		VSS_OBJECT_PROP Prop;
        
        //
        //  If not asking to delete the oldest snapshot, this could possibly delete multiple snapshots
        //  Let's determine how many snapshots will be deleted.  If one or more, ask the user if we
		//  should continue.  If in quiet mode, don't bother the user and skip this step.
        //   
		if ( !oldest  && !IsQuiet() )
		{
    		ULONG ulNumToBeDeleted = 0;
    		
		    for (;;) 
		    {
    			ULONG ulFetched;
    			ft.hr = pIEnumSnapshots->Next( 1, &Prop, &ulFetched );
    			if ( ft.HrFailed() )
    				ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);

    			// Test if the cycle is finished
    			if (ft.hr == S_FALSE) {
    				BS_ASSERT( ulFetched == 0);
    				break;
    			}

                // Use auto delete class to manage the snapshot properties
                CVssAutoSnapshotProperties cSnap( Prop );
                
                if (::_wcsicmp( cSnap->m_pwszOriginalVolumeName, wszVolumeNameInternal ) == 0 ||
                	(forVolume == NULL && all))
                    ++ulNumToBeDeleted;                
		    }

            if ( ulNumToBeDeleted == 0 )
                ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                    L"CVssAdminCLI::DeleteSnapshots: No snapshots found that satisfy the query");
                
            if ( !PromptUserForConfirmation( MSG_INFO_PROMPT_USER_FOR_DELETE_SNAPSHOTS, ulNumToBeDeleted ) )
                return;

            //  Reset the enumerator to the beginning.
			ft.hr = pIEnumSnapshots->Reset();
			if ( ft.HrFailed() )
				ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Reset failed with hr = 0x%08lx", ft.hr);		    
		}

		//
		//  Now iterate through the list of snapshots looking for matches and delete them.
		//
		for(;;) 
		{
			// Get next element
			ULONG ulFetched;
			ft.hr = pIEnumSnapshots->Next( 1, &Prop, &ulFetched );
			if ( ft.HrFailed() )
				ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
			
			// Test if the cycle is finished
			if (ft.hr == S_FALSE) {
				BS_ASSERT( ulFetched == 0);
				break;
			}

            // Use auto delete class to manage the snapshot properties
            CVssAutoSnapshotProperties cSnap( Prop );
            
            if (::_wcsicmp( cSnap->m_pwszOriginalVolumeName, wszVolumeNameInternal ) == 0  ||
            	   (forVolume == NULL && all))
            {
                //  We have a volume name match
                if (oldest)
                {   
                    // Stow away snapshot info if this is the oldest one so far
                    if ( OldestSnapshotTimestamp > cSnap->m_tsCreationTimestamp )
                    {
                        OldestSnapshotId        = cSnap->m_SnapshotId;
                        OldestSnapshotTimestamp = cSnap->m_tsCreationTimestamp;
                    }
                }
                else
                {
                    //  Delete the snapshot
                    VSS_ID NondeletedSnapshotId = GUID_NULL;
                    LONG lNumDeletedPrivate;
                    ft.hr = pICoord->DeleteSnapshots(
                                cSnap->m_SnapshotId,
                                VSS_OBJECT_SNAPSHOT,
                                TRUE,
                                &lNumDeletedPrivate,
                                &NondeletedSnapshotId );
                    if ( ft.HrFailed() )
                    {
                        //  If it is object not found, the snapshot must have gotten deleted by someone else
                        if ( ft.hr != VSS_E_OBJECT_NOT_FOUND )
                        {
                            //  Print out an error message but keep going
                            CVssAutoPWSZ awszSnapshotId( ::GuidToString( cSnap->m_SnapshotId ) );
                            OutputErrorMsg( MSG_ERROR_UNABLE_TO_DELETE_SNAPSHOT, ft.hr, (LPWSTR)awszSnapshotId );
                        } 
                    }
                    else 
                    {
                        lNumDeleted += lNumDeletedPrivate;
                    }                    
                }
            }
		}

        // If in delete oldest mode, do the delete
        if (oldest && OldestSnapshotId != GUID_NULL )
        {
            if ( PromptUserForConfirmation( MSG_INFO_PROMPT_USER_FOR_DELETE_SNAPSHOTS, 1 ) )
            {
                //  Delete the snapshot
                VSS_ID NondeletedSnapshotId = GUID_NULL;
                ft.hr = pICoord->DeleteSnapshots(
                            OldestSnapshotId,
                            VSS_OBJECT_SNAPSHOT,
                            TRUE,
                            &lNumDeleted,
                            &NondeletedSnapshotId );
                if ( ft.HrFailed() )
                {
                    
                    CVssAutoPWSZ awszSnapshotId( ::GuidToString( OldestSnapshotId ) );
                    //  If it is object not found, the snapshot must have gotten deleted by someone else
                    if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
                    {
                        OutputErrorMsg( MSG_ERROR_SNAPSHOT_NOT_FOUND, awszSnapshotId );
                    }
                    else
                    {
                        OutputErrorMsg( MSG_ERROR_UNABLE_TO_DELETE_SNAPSHOT, ft.hr, awszSnapshotId );
                    } 
                }
            }
            else
                return;
        }		

        if ( lNumDeleted == 0 )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::DeleteSnapshots: No snapshots found that satisfy the query");
            
    }
    
    if ( !IsQuiet() && lNumDeleted > 0 )
        OutputMsg( MSG_INFO_SNAPSHOTS_DELETED_SUCCESSFULLY, lNumDeleted );

	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}


void CVssAdminCLI::ExposeSnapshot(
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ExposeSnapshot" );

    // gather the parameters
    BOOL bExposeLocally = FALSE;
    LPWSTR pwszExposeUsing = GetOptionValueStr( VSSADM_O_EXPOSE_USING );
    LPWSTR pwszPathFromRoot = GetOptionValueStr( VSSADM_O_SHAREPATH );
    
    if ( pwszExposeUsing != NULL && ::wcslen( pwszExposeUsing ) >= 2 && pwszExposeUsing[1] == L':' )
    {
        //  User specified a mountpoint or a drive letter.
        bExposeLocally = TRUE;
    }

    BS_ASSERT (GetOptionValueStr (VSSADM_O_SNAPSHOT) != NULL);
    VSS_ID SnapshotId = GUID_NULL;
    if (!ScanGuid (GetOptionValueStr (VSSADM_O_SNAPSHOT), SnapshotId))	
    {
      ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
            L"CVssAdminCLI::ExposeSnapshot: Invalid snapshot id" );    
     }

    // verify the parameters
    m_pVerifier->ExposeSnapshot (SnapshotId, pwszExposeUsing, pwszPathFromRoot, bExposeLocally==TRUE, ft);
    
    LONG lAttributes;
    if ( bExposeLocally )
        lAttributes = VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY;
    else
        lAttributes = VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY;
    
    // Create the coordinator object
	CComPtr<IVssCoordinator> pICoord;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VSSCoordinator,
            L"Coordinator",
            CLSCTX_ALL,
            IID_IVssCoordinator,
            (IUnknown**)&(pICoord));
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

    //  Set the context to all so that we don't have to specify a specific context which would require either
    //  the user to specify it on the command-line or for us to first query the snapshot to determine its
    //  context.
    ft.hr = pICoord->SetContext( VSS_CTX_ALL );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error returned from IVssCoordinator::SetContext( CTX_ALL) hr = 0x%08x", ft.hr);
    
    LPWSTR wszExposedAs = NULL;
    
    //  Now try to expose
    ft.hr = pICoord->ExposeSnapshot( SnapshotId, 
                                     pwszPathFromRoot, 
                                     lAttributes, 
                                     pwszExposeUsing, 
                                     &wszExposedAs );
    if ( ft.HrFailed() )
    {
    	 switch (ft.hr)		{
        	case E_INVALIDARG:
	             OutputErrorMsg( MSG_ERROR_EXPOSE_INVALID_ARG);                        
	             return;
	       case VSS_E_OBJECT_ALREADY_EXISTS:
	       	OutputErrorMsg(MSG_ERROR_EXPOSE_OBJECT_EXISTS);
	       	return;
	       case VSS_E_OBJECT_NOT_FOUND:
	       	OutputErrorMsg( MSG_ERROR_SNAPSHOT_NOT_FOUND, GetOptionValueStr( VSSADM_O_SNAPSHOT ) );
	       	return;
	       default:
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error returned from ExposeSnapshot: hr = 0x%08x", ft.hr);
    	 }
    }
    
    CVssAutoPWSZ awszExposedAs( wszExposedAs );
    
    //  The snapshot is exposed, print the results to the user
    OutputMsg( MSG_INFO_EXPOSE_SNAPSHOT_SUCCESSFUL, awszExposedAs );

	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}


LPWSTR CVssAdminCLI::BuildSnapshotAttributeDisplayString(
    IN DWORD Attr
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::BuildSnapshotAttributeDisplayString" );

    WCHAR pwszDisplayString[1024] = L"";
    WORD wBit = 0;

    //  Go through the bits of the attribute
    for ( ; wBit < (sizeof ( Attr ) * 8) ; ++wBit )
    {
        switch ( Attr & ( 1 << wBit ) )
        {
        case 0:
            break;
        case VSS_VOLSNAP_ATTR_PERSISTENT:
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_PERSISTENT, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE:
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_CLIENT_ACCESSIBLE, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE: 	
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_NO_AUTO_RELEASE, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_NO_WRITERS:         
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_NO_WRITERS, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_TRANSPORTABLE:
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_TRANSPORTABLE, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_NOT_SURFACED:	    
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_NOT_SURFACED, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED:	
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_HARDWARE_ASSISTED, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_DIFFERENTIAL:		
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_DIFFERENTIAL, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_PLEX:				
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_PLEX, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_IMPORTED:			
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_IMPORTED, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY:    
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_EXPOSED_LOCALLY, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY:   
            AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_EXPOSED_REMOTELY, 0, L", " );
            break;
        default:
             AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                0, Attr & ( 1 << wBit ), L", " );
            break;

        }
    }

    // If this is a backup snapshot, most like there will not be any attributes
    if ( pwszDisplayString[0] == L'\0' )
    {
         AppendMessageToStr( pwszDisplayString, STRING_LEN( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_NONE, 0, L", " );
    }
    
    LPWSTR pwszRetString = NULL;
    ::VssSafeDuplicateStr( ft, pwszRetString, pwszDisplayString );
    return pwszRetString;
}


LONG CVssAdminCLI::DetermineSnapshotType(
    IN LPCWSTR pwszType
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::DetermineSnapshotType" );

    //  Determine the snapshot type based on the entered snapshot type string.

    //  See if the snapshot type was specified, if not, return all context
    if ( pwszType == NULL || pwszType[0] == L'\0' )
    {
        return VSS_CTX_ALL;
    }
    
    INT idx;
    
    // Determine type of snapshot
    for ( idx = 0; g_asAdmTypeNames[idx].pwszName != NULL; ++idx )
    {
        if ( ( dCurrentSKU  & g_asAdmTypeNames[idx].dwSKUs ) && 
             ( ::_wcsicmp( pwszType, g_asAdmTypeNames[idx].pwszName ) == 0 ) )
        {
            break;
        }
    }

    if ( g_asAdmTypeNames[idx].pwszName == NULL )
    {
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
            L"DetermineSnapshotType: Invalid type specified: %s",
            pwszType );
    }

    //
    //  Now return the context
    //
    return( g_asAdmTypeNames[idx].lSnapshotContext );
}

LPWSTR CVssAdminCLI::DetermineSnapshotType(
    IN LONG lSnapshotAttributes
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::DetermineSnapshotType" );

    //  Determine the snapshot type string based on the snapshot attributes
    LPWSTR pwszType = NULL;

    INT idx;
    
    // Determine type of snapshot
    for ( idx = 0; g_asAdmTypeNames[idx].pwszName != NULL; ++idx )
    {
        if ( g_asAdmTypeNames[idx].lSnapshotContext == ( lSnapshotAttributes & VSS_CTX_ATTRIB_MASK ) )
            break;
    }

    if ( g_asAdmTypeNames[idx].pwszName == NULL )
    {
        ft.Trace( VSSDBG_VSSADMIN, L"DetermineSnapshotType: Invalid context in lSnapshotAttributes: 0x%08x",
            lSnapshotAttributes );
        LPWSTR pwszMsg = GetMsg( FALSE, MSG_UNKNOWN );
        if ( pwszMsg == NULL ) 
        {
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
        			  L"Error on loading the message string id %d. 0x%08lx",
    	    		  MSG_UNKNOWN, ::GetLastError() );
        }    
        return pwszMsg;
    }

    //
    //  Now return the context
    //
    ::VssSafeDuplicateStr( ft, pwszType, g_asAdmTypeNames[idx].pwszName );

    return pwszType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\versionspecific.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module versionspecific.h | All conditionally-compiled code is accessed through here
    @end

Author:

    Reuven Lax [reuvenl]  11/28/01

TBD:
	
	Add comments.

Revision History:

    Name        Date        	Comments
    reuvenl     11/28/2001  	Created

--*/

#ifndef _VERSIONSPECIFIC_H_
#define _VERSIONSPECIFIC_H_

extern DWORD dCurrentSKU;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\versionspecific.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module versionspecific.cpp | All conditionally-compiled code lives here
    @end

Author:

    Reuven Lax [reuvenl]  11/28/01

TBD:
	
	Add comments.

Revision History:

    Name        Date        	Comments
    reuvenl     11/28/2001  	Created

--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes

#include "vssadmin.h"
#include "versionspecific.h"

/////////////////////////////////////////////////////////////////////////////
// Define current SKU
#ifdef FULLFEATURE
DWORD dCurrentSKU = (!CVssSKU::IsClient()) ?  SKU_INT : CVssSKU::GetSKU();
#else
DWORD dCurrentSKU = CVssSKU::GetSKU();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\vssadmin.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module vssadmin.hxx | header of VSS demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


#ifndef __VSS_DEMO_H_
#define __VSS_DEMO_H_


/////////////////////////////////////////////////////////////////////////////
//  Defines and pragmas

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>

// Application specific
#include "vs_inc.hxx"

// Generated MIDL headers
#include "vs_idl.hxx"

#include "copy.hxx"
#include "pointer.hxx"

#include "resource.h"

#include "vssmsg.h"
#include "msg.h"

#include "vswriter.h"
#include "vsbackup.h"

/////////////////////////////////////////////////////////////////////////////
//  Constants

const x_nStringBufferSize = 1024;	    // Includes the zero character

const x_nPollingInterval  = 2500;     // Three seconds

const x_nMaxRetriesCount = 4;        // Retries for polling

const WCHAR x_wszVssOptBoolTrue[] = L"TRUE";

#define VSSADM_E_NO_ITEMS_IN_QUERY          S_FALSE
#define VSSADM_E_FIRST_PARSING_ERROR        0x1001
#define VSSADM_E_INVALID_NUMBER             0x1001
#define VSSADM_E_INVALID_COMMAND            0x1002
#define VSSADM_E_INVALID_OPTION             0x1003
#define VSSADM_E_INVALID_OPTION_VALUE       0x1004
#define VSSADM_E_DUPLICATE_OPTION           0x1005
#define VSSADM_E_OPTION_NOT_ALLOWED_FOR_COMMAND 0x1006
#define VSSADM_E_REQUIRED_OPTION_MISSING    0x1007
#define VSSADM_E_INVALID_SET_OF_OPTIONS     0x1008
#define VSSADM_E_SNAPSHOT_NOT_FOUND	      0x1009
#define VSSADM_E_DELETION_DENIED			0x100a
#define VSSADM_E_LAST_PARSING_ERROR         0x100a

// Note: if any skus are added in the CVssSKU class, they need to 
// be updated here.  Make sure to update the SKU_INT and SKU_A 
// definitions as well.
#define SKU_C   CVssSKU::VSS_SKU_CLIENT
#define SKU_S   CVssSKU::VSS_SKU_SERVER
#define SKU_N   CVssSKU::VSS_SKU_NAS
#define SKU_I   CVssSKU::VSS_SKU_INVALID

#define SKU_INT  ((DWORD)(~SKU_C & ~ SKU_S & ~SKU_N))		

#define SKU_A   ( SKU_C | SKU_S | SKU_N | SKU_INT) // 0xffff
#define SKU_SN  ( SKU_S | SKU_N )
#define SKU_SNI (SKU_S | SKU_N | SKU_INT)

enum EVssAdmSnapshotType
{
    VSSADM_ST_FIRST = 0,
    VSSADM_ST_NAS_ROLLBACK = 0,
    VSSADM_ST_PERSISTENT_TIMEWARP,
    VSSADM_ST_TIMEWARP,
    VSSADM_ST_NUM_TYPES,
    VSSADM_ST_INVALID,
    VSSADM_ST_ALL
};

struct SVssAdmSnapshotTypeName
{
    LPCWSTR pwszName;
    DWORD dwSKUs;       // Specifies which SKUs this type is supported for snapshot creation using vssadmin, formed from ORing CVssSKU::EVssSKUType
    LONG lSnapshotContext;  // The snapshot context from vss.idl
    LONG pwszDescription;
};

//
//  List of all options.  This list must remain in sync with the g_asAdmOptions list.
//
enum EVssAdmOption
{
    VSSADM_O_FIRST = 0,
    VSSADM_O_ALL = 0,
    VSSADM_O_AUTORETRY,
    VSSADM_O_EXPOSE_USING,
    VSSADM_O_FOR,
    VSSADM_O_MAXSIZE,
    VSSADM_O_OLDEST,
    VSSADM_O_ON,
    VSSADM_O_PROVIDER,
    VSSADM_O_QUIET,
    VSSADM_O_SET,
    VSSADM_O_SHAREPATH,
    VSSADM_O_SNAPSHOT,
    VSSADM_O_SNAPTYPE,
    VSSADM_O_NUM_OPTIONS,
    VSSADM_O_INVALID
};

//
//  LIst of all commands.  This list must remain in sync with the g_asAdmCommands list.
//
enum EVssAdmCommand
{
    VSSADM_C_FIRST = 0,
    VSSADM_C_ADD_DIFFAREA_INT = 0,
    VSSADM_C_ADD_DIFFAREA_PUB,
    VSSADM_C_CREATE_SNAPSHOT_INT,
    VSSADM_C_CREATE_SNAPSHOT_PUB,
    VSSADM_C_DELETE_SNAPSHOTS_INT,
    VSSADM_C_DELETE_SNAPSHOTS_PUB,
    VSSADM_C_DELETE_DIFFAREAS_INT,
    VSSADM_C_DELETE_DIFFAREAS_PUB,
    VSSADM_C_EXPOSE_SNAPSHOT,
    VSSADM_C_LIST_PROVIDERS,
    VSSADM_C_LIST_SNAPSHOTS_INT,
    VSSADM_C_LIST_SNAPSHOTS_PUB,
    VSSADM_C_LIST_DIFFAREAS_INT,
    VSSADM_C_LIST_DIFFAREAS_PUB,
    VSSADM_C_LIST_VOLUMES_INT,
    VSSADM_C_LIST_VOLUMES_PUB,
    VSSADM_C_LIST_WRITERS,
    VSSADM_C_RESIZE_DIFFAREA_INT,
    VSSADM_C_RESIZE_DIFFAREA_PUB,
    VSSADM_C_NUM_COMMANDS,
    VSSADM_C_INVALID
};

enum EVssAdmOptionType
{
    VSSADM_OT_BOOL = 0,  // no qualifier on the option, i.e. /quiet, TRUE if present
    VSSADM_OT_STR,
    VSSADM_OT_NUM
};

struct SVssAdmOption
{
    EVssAdmOption eOpt;
    LPCWSTR pwszOptName;  // The option name as typed on the command-line, i.e. the "for" in /for=XXXX
    EVssAdmOptionType eOptType;
};

//
//  Specifies the validity of the option for a particular command.
//
enum EVssAdmOptionFlag
{
    V_NO = 0,  //  Option not allowed
    V_YES,     //  Option manditory
    V_OPT      //  Option optional
};

//
//  The main command structure.  The commands are structured like:
//  vssadmin <pwszMajorOption> <pwszMinorOption> <OPTIONS>
//
struct SVssAdmCommandsEntry
{
    LPCWSTR pwszMajorOption;
    LPCWSTR pwszMinorOption;
    EVssAdmCommand eAdmCmd;
    DWORD dwSKUs;       // Specifies which SKUs this command is supported, formed from ORing CVssSKU::EVssSKUType
    LONG lMsgGen;
    LONG lMsgDetail;
    BOOL bShowSSTypes;  //  If true, in detailed usage show a list of valid snapshot types at end of message
    EVssAdmOptionFlag aeOptionFlags[VSSADM_O_NUM_OPTIONS]; // Array of option flags indexed by EVssAdmOption
};


//
//  The structure of the parsed command.  One of these is created by the 
//  ParseCmdLine method.
//
struct SVssAdmParsedCommand
{
    EVssAdmCommand eAdmCmd;
    LPWSTR apwszOptionValues[VSSADM_O_NUM_OPTIONS];

    //  Simple initializer constructor
    SVssAdmParsedCommand()
    {
        eAdmCmd = VSSADM_C_INVALID;
        // psUnnamedOptions = NULL;
        
        //  Clear out the option values arrays
        for ( INT i = 0; i < VSSADM_O_NUM_OPTIONS; ++i )
            apwszOptionValues[ i ] = NULL;
    };
    ~SVssAdmParsedCommand()
    {
        //  Free any allocated memory
        for ( INT i = 0; i < VSSADM_O_NUM_OPTIONS; ++i )
            ::VssFreeString( apwszOptionValues[ i ] );
        
    }
};

extern const SVssAdmOption g_asAdmOptions[];
extern const SVssAdmCommandsEntry g_asAdmCommands[];
extern const SVssAdmSnapshotTypeName g_asAdmTypeNames[];

LPWSTR GuidToString(
    IN GUID guid
    );

LPWSTR LonglongToString(
    IN LONGLONG llValue
    );

LPWSTR DateTimeToString(
    IN VSS_TIMESTAMP *pTimeStamp
    );

WCHAR MyGetChar(
    );

BOOL MapVssErrorToMsg(
	IN HRESULT hr,
	OUT LONG *plMsgNum
    ) throw( HRESULT );
   

/////////////////////////////////////////////////////////////////////////////
//	class CVssAdminCLI

class CCommandVerifier;

class CVssAdminCLI
{
// Enums and typedefs
private:

	enum _RETURN_VALUE
	{
		VSS_CMDRET_SUCCESS      = 0,
		VSS_CMDRET_EMPTY_RESULT = 1,
		VSS_CMDRET_ERROR        = 2,
	};

// Constructors& destructors
private:
	CVssAdminCLI(const CVssAdminCLI&);
	CVssAdminCLI();

public:
	CVssAdminCLI(
        IN INT argc,
        IN PWSTR argv[]
		);
	~CVssAdminCLI();

// Attributes
private:
    BOOL       IsQuiet() { return GetOptionValueBool( VSSADM_O_QUIET ); }
    
	INT        GetReturnValue() { return m_nReturnValue; };

    LPWSTR     GetOptionValueStr(
        IN EVssAdmOption eOption
        )
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetOptionValueStr" );

        BS_ASSERT( g_asAdmOptions[ eOption ].eOptType == VSSADM_OT_STR );
//        BS_ASSERT( g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[ eOption ] != V_NO );
        return m_sParsedCommand.apwszOptionValues[ eOption ];
    };

    BOOL        GetOptionValueBool(
        IN EVssAdmOption eOption
        )
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetOptionValueBool" );

        BS_ASSERT( g_asAdmOptions[ eOption ].eOptType == VSSADM_OT_BOOL );
        BS_ASSERT( g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[ eOption ] != V_NO );
        return m_sParsedCommand.apwszOptionValues[ eOption ] != NULL;
    };

    BOOL        GetOptionValueNum(
        IN EVssAdmOption eOption,
        OUT LONGLONG *pllValue,
    	IN BOOL bSuffixAllowed = TRUE    
        ) throw( HRESULT )
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetOptionValueNum" );

        BS_ASSERT( g_asAdmOptions[ eOption ].eOptType == VSSADM_OT_NUM );
        BS_ASSERT( g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[ eOption ] != V_NO );
        if ( m_sParsedCommand.apwszOptionValues[ eOption ] == NULL )
        {
            BS_ASSERT( g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[ eOption ] == V_OPT );
            //  Option wasn't specified on command line - an optional one
            *pllValue = 0;
            return FALSE; 
        }
        *pllValue = ScanNumber( m_sParsedCommand.apwszOptionValues[ eOption ], bSuffixAllowed );

        return TRUE;
    };


// Operations
public:

    static HRESULT Main(
        IN INT argc,
        IN PWSTR argv[]
	    );

private:

	void Initialize(
		) throw(HRESULT);

	BOOL ParseCmdLine(
		) throw(HRESULT);

	void DoProcessing(
		) throw(HRESULT);

	void Finalize();

// Processing
private:

	void PrintUsage(
		) throw(HRESULT);

    // The following are the methods that get called for each command.
	void AddDiffArea(
		) throw(HRESULT);
    
	void CreateSnapshot(
		) throw(HRESULT);

	void DeleteDiffAreas(
		) throw(HRESULT);

	void DeleteSnapshots(
		) throw(HRESULT);

	void ExposeSnapshot(
		) throw(HRESULT);

	void ListDiffAreas(
		) throw(HRESULT);
	
	void ListProviders(
		) throw(HRESULT);

	void ListSnapshots(
		) throw(HRESULT);

	void ListVolumes(
		) throw(HRESULT);

	void ListWriters(
		) throw(HRESULT);

	void ResizeDiffArea(
		) throw(HRESULT);

// Implementation
private:
    static BOOL UnloggableError(IN HRESULT hError);

    void GetDifferentialSoftwareSnapshotMgmtInterface(
        IN   VSS_ID ProviderId,
        IN   IVssSnapshotMgmt *pIMgmt,
    	OUT  IUnknown**  ppItf
    	);

    LPCWSTR GetVolumeDisplayName( 
        IN  LPCWSTR pwszVolumeName
        );
    
    LONG DetermineSnapshotType(
        IN LPCWSTR pwszType
        ) throw(HRESULT);

    LPWSTR DetermineSnapshotType(
        IN LONG lSnapshotAttributes
        ) throw(HRESULT);

    void DisplayDiffAreasPrivate(
   	    IVssEnumMgmtObject *pIEnumMgmt	
	    ) throw(HRESULT);

    LPWSTR BuildSnapshotAttributeDisplayString(
        IN DWORD Attr
        ) throw(HRESULT);
    
	void DumpSnapshotTypes(
		) throw(HRESULT);

	LPCWSTR LoadString(
		IN	UINT nStringId
		) throw(HRESULT);

	LPCWSTR GetNextCmdlineToken(
		IN	bool bFirstToken = false
		) throw(HRESULT);

	bool Match(
		IN	LPCWSTR wszString,
		IN	LPCWSTR wszPatternString
		) throw(HRESULT);

	bool ScanGuid(
		IN	LPCWSTR wszString,
		OUT	VSS_ID& Guid
		) throw(HRESULT);

	void Output(
    	IN	LPCWSTR wszFormat,
		...
		) throw(HRESULT);

    void OutputMsg(
        IN  LONG msgId,
        ...
        ) throw(HRESULT);

    void OutputOnConsole(
        IN	LPCWSTR wszStr
        );

   
    LPWSTR GetMsg(
    	IN  BOOL bLineBreaks,	
        IN  LONG msgId,
        ...
        );

    void AppendMessageToStr(
        IN LPWSTR pwszString,
        IN SIZE_T cMaxStrLen,
        IN LONG lMsgId,
        IN DWORD AttrBit,
        IN LPCWSTR pwszDelimitStr
        ) throw( HRESULT );
    
    LONGLONG ScanNumber(
    	IN LPCWSTR pwszNumToConvert,
    	IN BOOL bSuffixAllowed
        ) throw( HRESULT );
    
    LPWSTR FormatNumber(
    	IN LONGLONG llNum
        ) throw(HRESULT);
    
    void OutputErrorMsg(
        IN  LONG msgId,
        ...
        ) throw(HRESULT);

    BOOL PromptUserForConfirmation(
    	IN LONG lPromptMsgId,
    	IN ULONG ulNum	
    	);

    void GetProviderId(
	    OUT	VSS_ID *pProviderId
        );
    
	LPCWSTR GetProviderName(
		IN	VSS_ID& ProviderId
		) throw(HRESULT);

    BOOL GetProviderIdByName(
	    IN  LPCWSTR pwszProviderName,
	    OUT	VSS_ID *pProviderId
	    ) throw(HRESULT);

// Data members
private:
    CCommandVerifier* m_pVerifier;
	HANDLE              m_hConsoleOutput;
    CVssSimpleMap<UINT, LPCWSTR> m_mapCachedResourceStrings;
    CVssSimpleMap<VSS_ID, LPCWSTR> m_mapCachedProviderNames;
    CVssSimpleMap<LPCWSTR, LPCWSTR> *m_pMapVolumeNames;
    
	INT                 m_nReturnValue;

    INT                 m_argc;
    PWSTR               *m_argv;
	
	EVssAdmCommand      m_eCommandType;
	SVssAdmParsedCommand m_sParsedCommand;
	VSS_OBJECT_TYPE		m_eFilterObjectType;
	VSS_OBJECT_TYPE		m_eListedObjectType;
	VSS_ID				m_FilterSnapshotId;
};

class CVssAutoSnapshotProperties
{
// Constructors/destructors
private:
	CVssAutoSnapshotProperties(const CVssAutoSnapshotProperties&);

public:
	CVssAutoSnapshotProperties(VSS_SNAPSHOT_PROP &Snap): m_pSnap(&Snap) {};
	CVssAutoSnapshotProperties(VSS_OBJECT_PROP &Prop): m_pSnap(&Prop.Obj.Snap) {};

	// Automatically closes the handle
	~CVssAutoSnapshotProperties() {
	    Clear();
	};

// Operations
public:

	// Returns the value
	VSS_SNAPSHOT_PROP *GetPtr() {
		return m_pSnap;
	}
	
	// NULLs out the pointer.  Used after a pointer has been transferred to another
	// funtion.
	void Transferred() {
		m_pSnap = NULL;
	}

	// Clears the contents of the auto string
	void Clear() {
	    if ( m_pSnap != NULL )
	    {
    		::VssFreeSnapshotProperties(m_pSnap);
    		m_pSnap = NULL;
	    }
	}

    // Returns the value to the actual pointer
	VSS_SNAPSHOT_PROP* operator->() const {
	    return m_pSnap;
	}
	
	// Returns the value of the actual pointer
	operator VSS_SNAPSHOT_PROP* () const {
		return m_pSnap;
	}

private:
	VSS_SNAPSHOT_PROP *m_pSnap;
};


#endif //__VSS_DEMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\utility.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module utility.cpp | Implementation of the Volume Snapshots admin utility
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999
    Stefan Steiner [ssteiner] 03/27/2001
    
TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    ssteiner    03/27/2001  Created
--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

// The rest of includes are specified here
#include "vssadmin.h"
#include <float.h>

#define VSS_LINE_BREAK_COLUMN (79)

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMUTILC"

LPCWSTR CVssAdminCLI::GetVolumeDisplayName( 
    IN  LPCWSTR pwszVolumeName
    )
{
    //
    //  Note that if something fails in this function, the program can continue
    //  to run.  It's just that certain output will not show the volume display
    //  name along with the volume name
    //
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetVolumeDisplayName" );
    
    if ( m_pMapVolumeNames == NULL )
    {
        // Create a Coordinator interface
        CComPtr<IVssSnapshotMgmt> pIMgmt;

        ft.CoCreateInstanceWithLog(
                VSSDBG_VSSADMIN,
                CLSID_VssSnapshotMgmt,
                L"VssSnapshotMgmt",
                CLSCTX_ALL,
                IID_IVssSnapshotMgmt,
                (IUnknown**)&(pIMgmt));
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

        //
        //  Get the list of all volumes
        //
    	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
        ft.hr = pIMgmt->QueryVolumesSupportedForSnapshots( 
                    VSS_SWPRV_ProviderId,
                    VSS_CTX_ALL,
                    &pIEnumMgmt );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryVolumesSupportedForSnapshots failed, hr = 0x%08lx", ft.hr);

        if ( ft.hr == S_FALSE )
            // empty query
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::ListVolumes: No volumes found that satisfy the query" );

        //
        //  Query each volume to see if diff areas exist.
        //
    	VSS_MGMT_OBJECT_PROP Prop;
    	VSS_VOLUME_PROP& VolProp = Prop.Obj.Vol; 
        m_pMapVolumeNames = new CVssSimpleMap<LPCWSTR, LPCWSTR>;
        if ( m_pMapVolumeNames == NULL )
       		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
            
    	for(;;) 
    	{
    		// Get next element
    		ULONG ulFetched;
    		ft.hr = pIEnumMgmt->Next( 1, &Prop, &ulFetched );
    		if ( ft.HrFailed() )
    			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
    		
    		// Test if the cycle is finished
    		if (ft.hr == S_FALSE) {
    			BS_ASSERT( ulFetched == 0);
    			break;
    		}

            //  If it is a simple drive letter it comes back like V:\, change to V:
            if ( ::wcslen( VolProp.m_pwszVolumeDisplayName ) == 3 && VolProp.m_pwszVolumeDisplayName[2] == L'\\' )
                VolProp.m_pwszVolumeDisplayName[2] = L'\0';

            //  Add it to the map.  Note that the strings in the volume property struct are transferred to the 
            //  map.
        	if ( !m_pMapVolumeNames->Add( VolProp.m_pwszVolumeName, VolProp.m_pwszVolumeDisplayName ) ) 
        	{
        		::VssFreeString( VolProp.m_pwszVolumeName );
        		::VssFreeString( VolProp.m_pwszVolumeDisplayName );
        		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
        	}
    	}
    }

    //  Returns NULL if the volume name is not found
    return m_pMapVolumeNames->Lookup(pwszVolumeName);
}
    

LPCWSTR CVssAdminCLI::LoadString(
		IN	UINT uStringId
		)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::LoadString" );

    LPCWSTR wszReturnedString = m_mapCachedResourceStrings.Lookup(uStringId);
	if (wszReturnedString)
		return wszReturnedString;

	// Load the string from resources.
	WCHAR	wszBuffer[x_nStringBufferSize];
	INT nReturnedCharacters = ::LoadStringW(
			GetModuleHandle(NULL),
			uStringId,
			wszBuffer,
			x_nStringBufferSize - 1
			);
	if (nReturnedCharacters == 0)
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
				  L"Error on loading the string %u. 0x%08lx",
				  uStringId, ::GetLastError() );

	// Duplicate the new string
	LPWSTR wszNewString = NULL;
	::VssSafeDuplicateStr( ft, wszNewString, wszBuffer );
	wszReturnedString = wszNewString;

	// Save the string in the cache
	if ( !m_mapCachedResourceStrings.Add( uStringId, wszReturnedString ) ) {
		::VssFreeString( wszReturnedString );
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
	}

	return wszReturnedString;
}


LPCWSTR CVssAdminCLI::GetNextCmdlineToken(
	IN	bool bFirstToken /* = false */
	) throw(HRESULT)

/*++

Description:

	This function returns the tokens in the command line.

	The function will skip any separators (space and tab).

	If bFirstCall == true then it will return the first token.
	Otherwise subsequent calls will return subsequent tokens.

	If the last token is NULL then there are no more tokens in the command line.

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetNextCmdlineToken" );

    static INT iCurrArgc;
    WCHAR *pwsz;

    if ( bFirstToken )
        iCurrArgc = 0; 

    if ( iCurrArgc >= m_argc )
        return NULL;
    
    pwsz = m_argv[iCurrArgc++];

	return pwsz;
}


bool CVssAdminCLI::Match(
	IN	LPCWSTR wszString,
	IN	LPCWSTR wszPatternString
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches the
	pattern string. The comparison is case insensitive.

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::Match" );

	// If the string is NULL then the Match failed.
	if (wszString == NULL) return false;

	// Check for string equality (case insensitive)
	return (::_wcsicmp( wszString, wszPatternString ) == 0);
}


bool CVssAdminCLI::ScanGuid(
	IN	LPCWSTR wszString,
	OUT	VSS_ID& Guid
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches a guid.
	The guid is returned in the proper variable.
	The formatting is case insensitive.

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ScanGuid" );

	return SUCCEEDED(::CLSIDFromString(W2OLE(const_cast<WCHAR*>(wszString)), &Guid));
}


void CVssAdminCLI::Output(
	IN	LPCWSTR wszFormat,
	...
	) throw(HRESULT)

/*++

Description:

	This function returns true if the given string matches the
	pattern strig from resources. The comparison is case insensitive.

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::Output" );
    
    WCHAR wszOutputBuffer[x_nStringBufferSize];

	// Format the final string
    va_list marker;
    va_start( marker, wszFormat );
    StringCchVPrintfW( STRING_CCH_PARAM(wszOutputBuffer), wszFormat, marker );
    va_end( marker );

	// Print the final string to the output
	OutputOnConsole( wszOutputBuffer );
}


void CVssAdminCLI::OutputMsg(
    IN  LONG msgId,
    ...
    )
/*++

Description:

	This function outputs a msg.mc message.

--*/
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::OutputMsg" );
    
    va_list args;
    LPWSTR lpMsgBuf;
	
    va_start( args, msgId );

    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            &args
            ))
    {
        OutputOnConsole( lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    } 
    else 
    {
        if (::FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                msgId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &lpMsgBuf,
                0,
                &args))
        {
            OutputOnConsole( lpMsgBuf );
            ::LocalFree( lpMsgBuf );
        } 
        else 
        {
            ::wprintf( L"Unable to format message for id %x - %d\n", msgId, ::GetLastError( ));                        
        }
    }
    va_end( args );
}

LPWSTR CVssAdminCLI::GetMsg(
	IN  BOOL bLineBreaks,
    IN  LONG msgId,
    ...
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetMsg" );
    
    va_list args;
    LPWSTR lpMsgBuf;
    LPWSTR lpReturnStr = NULL;
    
    va_start( args, msgId );

    if (::FormatMessageW(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | 
                ( bLineBreaks ? VSS_LINE_BREAK_COLUMN : FORMAT_MESSAGE_MAX_WIDTH_MASK ),
            NULL,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            &args
            ))
    {
        ::VssSafeDuplicateStr( ft, lpReturnStr, lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    }
    else if (::FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
                    ( bLineBreaks ? VSS_LINE_BREAK_COLUMN : FORMAT_MESSAGE_MAX_WIDTH_MASK ),
                NULL,
                msgId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &lpMsgBuf,
                0,
                &args ) )
    {
        ::VssSafeDuplicateStr( ft, lpReturnStr, lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    }

    va_end( args );

    //  Returns NULL if message was not found
    return lpReturnStr;
}

void CVssAdminCLI::AppendMessageToStr(
    IN LPWSTR pwszString,
    IN SIZE_T cMaxStrLen,
    IN LONG lMsgId,
    IN DWORD AttrBit,
    IN LPCWSTR pwszDelimitStr
    ) throw( HRESULT )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::AppendMessageToStr" );

    size_t cMaxAppendChars = cMaxStrLen - wcslen(pwszString);
    
    if ( pwszString[0] != L'\0' )
    {
        //  First append the delimiter
        ::wcsncat( pwszString, pwszDelimitStr, cMaxAppendChars );       
        cMaxAppendChars = cMaxStrLen - wcslen(pwszString);
    }

    //  If this is a known message, lMsgId != 0
    if ( lMsgId != 0 )
    {
        LPWSTR pwszMsg;
        pwszMsg = GetMsg( FALSE, lMsgId );
        if ( pwszMsg == NULL ) 
        {
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
	    			  L"Error on loading the message string id %d. 0x%08lx",
		    		  lMsgId, ::GetLastError() );
        }
        
        ::wcsncat( pwszString, pwszMsg, cMaxAppendChars );
        cMaxAppendChars = cMaxStrLen - wcslen(pwszString);
        ::VssFreeString( pwszMsg );
    }
    else
    {
        //  No message for this one, just append the attribute in hex
        WCHAR pwszBitStr[64];
        StringCchPrintfW( STRING_CCH_PARAM(pwszBitStr), 
                    L"0x%x", AttrBit
                    );
        
        ::wcsncat( pwszString, pwszBitStr, cMaxAppendChars);
        cMaxAppendChars = cMaxStrLen - wcslen(pwszString);

    }
}

//
//  Scans a number input by the user and converts it to a LONGLONG.  Accepts the following
//  unit suffixes: B, K, KB, M, MB, G, GB, T, TB, P, PB, E, EB and floating point.
//
LONGLONG CVssAdminCLI::ScanNumber(
	IN LPCWSTR pwszNumToConvert,
	IN BOOL bSuffixAllowed
    ) throw( HRESULT )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ScanNumber" );
    
    WCHAR wUnit = L'B';
    SIZE_T NumStrLen;

    //  If the string is NULL, assume infinite size
    if ( pwszNumToConvert == NULL )
        return -1;
    
    //
    //  Set up an automatically released temporary string
    //
    CVssAutoPWSZ autoStrNum;
    autoStrNum.CopyFrom( pwszNumToConvert );
    LPWSTR pwszNum = autoStrNum.GetRef();

    NumStrLen = ::wcslen( pwszNum );

    //  Remove trailing spaces
    while ( NumStrLen > 0 && pwszNum[ NumStrLen - 1 ] == L' ' )
    {
        NumStrLen -= 1;        
        pwszNum[ NumStrLen ] = L'\0';
    }
    
    //  If the string is empty, assume infinite size
    if ( NumStrLen == 0 )
        return -1;

    if ( bSuffixAllowed )
    {
        //  See if there is a suffix with three or more alpha chars, if so, error out.
        if ( NumStrLen > 3 && iswalpha( pwszNum[ NumStrLen - 3 ] ) && iswalpha( pwszNum[ NumStrLen - 2 ] ) &&
            iswalpha( pwszNum[ NumStrLen - 1 ] ) )
        {
    		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
        			  L"Invalid input number: '%s', too many alpha chars in suffix.", pwszNumToConvert );
        } 
        //  Now see if there is a single or double byte alpha suffix.  If so, put the suffix in wUnit.
        else if ( NumStrLen > 2 && iswalpha( pwszNum[ NumStrLen - 2 ] ) && ( towupper( pwszNum[ NumStrLen - 1 ] ) == L'B' ) )
        {
            if ( towupper( pwszNum[ NumStrLen - 2 ] ) == L'B' )
        		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
    	    			  L"Invalid input number: '%s', BB is not a valid suffix", pwszNumToConvert );
                
            wUnit = pwszNum[ NumStrLen - 2 ];
            pwszNum[ NumStrLen - 2 ] = L'\0';
            NumStrLen -= 2;
        } 
        else if ( NumStrLen > 1 && iswalpha( pwszNum[ NumStrLen - 1 ] ) )
        {
            wUnit = pwszNum[ NumStrLen - 1 ];
            pwszNum[ NumStrLen - 1 ] = L'\0';
            NumStrLen -= 1;
        }
    }
    else
    {
        //  Let's make sure the string is only filled with digits...
        SIZE_T cStr = ::wcslen( pwszNum );
        for ( SIZE_T i = 0; i < cStr; ++i )
        {
            if ( ! iswdigit( pwszNum[ i ] ) )
        		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
    	    			  L"Invalid input number: '%s', number must be all digits", pwszNumToConvert );                
        }
    }
    
    //  At this point, the rest of the string should be a valid floating point number
    double dSize;
    if ( swscanf( pwszNum, L"%lf", &dSize ) != 1 )
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
				  L"Invalid input number: %s", pwszNumToConvert );
    //  Now bump up the size based on suffix
    
    switch( towupper( wUnit ) )
    {
    case L'B':
        break;
    case L'E':
        dSize *= 1024.;
    case L'P':
        dSize *= 1024.;
    case L'T':
        dSize *= 1024.;
    case L'G':
        dSize *= 1024.;
    case L'M':
        dSize *= 1024.;
    case L'K':
        dSize *= 1024.;
        break;
    default:
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
				  L"Invalid input number: %s", pwszNumToConvert );
        break;
    }

    LONGLONG llRetVal;
    llRetVal = (LONGLONG)dSize;
    if ( llRetVal <= -1 )
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
				  L"Invalid input number: %s", pwszNumToConvert );
            
    return llRetVal;
}

//
//  Format a LONGLONG into the appropriate string using xB (KB, MB, GB, TB, PB, EB) suffixes.
//  Must use ::VssFreeString() to free returned string.
//
LPWSTR CVssAdminCLI::FormatNumber(
	IN LONGLONG llNum
    ) throw( HRESULT )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::FormatNumber" );
    
    // If the string is -1 or less, assume this is infinite.
    if ( llNum < 0 ) 
    {
        LPWSTR pwszMsg = GetMsg( FALSE, MSG_INFINITE );
        if ( pwszMsg == NULL ) 
        {
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
	    			  L"Error on loading the message string id %d. 0x%08lx",
		    		  MSG_INFINITE, ::GetLastError() );
        }
        
        return pwszMsg;
    }
    
    // Now convert the size into string
    UINT nExaBytes =   (UINT)((llNum >> 60));
    UINT nPetaBytes =  (UINT)((llNum >> 50) & 0x3ff);
    UINT nTerraBytes = (UINT)((llNum >> 40) & 0x3ff);
    UINT nGigaBytes =  (UINT)((llNum >> 30) & 0x3ff);
    UINT nMegaBytes =  (UINT)((llNum >> 20) & 0x3ff);
    UINT nKiloBytes =  (UINT)((llNum >> 10) & 0x3ff);
    UINT nBytes =      (UINT)( llNum  & 0x3ff);

    LPCWSTR pwszUnit;
    double dSize = 0.0;

    // Display only biggest units, and never more than 999
    // instead of "1001 KB" we display "0.98 MB"
    if ( (nExaBytes) > 0 || (nPetaBytes > 999) )
    {
        pwszUnit = L"EB";
        dSize = ((double)llNum / (double)( 1 << 30 )) / (double)( 1 << 30 ) ;
    }
    else if ( (nPetaBytes) > 0 || (nTerraBytes > 999) )
    {
        pwszUnit = L"PB";
        dSize = ((double)llNum / (double)( 1 << 30 )) / (double)( 1 << 20 ) ;
    }
    else if ( (nTerraBytes) > 0 || (nGigaBytes > 999) )
    {
        pwszUnit = L"TB";
        dSize = ((double)llNum / (double)( 1 << 30 )) / (double)( 1 << 10 ) ;
    }
    else if ( (nGigaBytes) > 0 || (nMegaBytes > 999) )
    {
        pwszUnit = L"GB";
        dSize = (double)llNum / (double)( 1 << 30 ) ;
    }
    else if ( (nMegaBytes) > 0 || (nKiloBytes > 999) )
    {
        pwszUnit = L"MB";
        dSize = (double)llNum / (double)( 1 << 20 ) ;
    }
    else if ( (nKiloBytes) > 0 || (nBytes > 999) )
    {
        pwszUnit = L"KB";
        dSize = (double)llNum / (double)( 1 << 10 ) ;
    }
    else
    {
        pwszUnit = L"B";  
        dSize = (double)nBytes;
    }

    // BUG 453314: Trunc used instead of Round
    // For explanation of the workaround look for the following KB Article:
    // Q184234: PRB: printf() and _fcvt() Might Produce Incorrect Rounding
    double dRoundedSize = dSize + 1e-10;

    // Format with op to three decimal points
    WCHAR pwszSize[64];
    StringCchPrintfW( STRING_CCH_PARAM(pwszSize), 
                L"%.3f", dRoundedSize 
                );
    
    SIZE_T len = ::wcslen( pwszSize );
        
    // Truncate trailing zeros
    while ( len > 0 && pwszSize[ len - 1 ] == L'0' )
    {
        len -= 1;        
        pwszSize[ len ] = L'\0';
    }
    // Truncate trailing decimal point
    if ( len > 0 && pwszSize[ len - 1 ] == L'.' )
        pwszSize[ len - 1 ] = L'\0';

    // Now attach the unit suffix
    ::wcscat( pwszSize, L" " );
    ::wcscat( pwszSize, pwszUnit );

    // Allocate a string buffer and return it.
    LPWSTR pwszRetStr = NULL;
    ::VssSafeDuplicateStr( ft, pwszRetStr, pwszSize );

    return pwszRetStr;
}


/*++

Description:

	This function outputs a msg.mc message.

--*/
void CVssAdminCLI::OutputErrorMsg(
    IN  LONG msgId,
    ...
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::OutputErrorMsg" );
    
    va_list args;
    LPWSTR lpMsgBuf;
    
    va_start( args, msgId );
 
    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_ERROR,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            NULL
            ))
    {
        OutputOnConsole( lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    }

    if (::FormatMessage(
            (msgId >= MSG_FIRST_MESSAGE_ID ? FORMAT_MESSAGE_FROM_HMODULE :
                                             FORMAT_MESSAGE_FROM_SYSTEM)
            | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf, 
            0,
            &args
            ))
    {
        OutputOnConsole( L" " );
        OutputOnConsole( lpMsgBuf );
        OutputOnConsole( L" \r\n" );
        ::LocalFree( lpMsgBuf );
    } 
    else 
    {
        if (::FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                msgId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &lpMsgBuf,
                0,
                &args))
        {
            OutputOnConsole( L" " );
            OutputOnConsole( lpMsgBuf );
            OutputOnConsole( L" \r\n" );
            ::LocalFree( lpMsgBuf );
        } 
        else 
        {
            ::wprintf( L"Unable to format message for id %x - %d\n", msgId, ::GetLastError( ));            
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
    				  L"Error on loading the message string id %d. 0x%08lx",
    				  msgId, ::GetLastError() );
        }
    }

    va_end( args );
}

BOOL CVssAdminCLI::PromptUserForConfirmation(
	IN LONG lPromptMsgId,
	IN ULONG ulNum
	)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::PromptUserForConfirmation" );
    
    BOOL bRetVal = FALSE;
    
    //
    //  First check to see if in quiet mode.  If so, simply return
    //  true
    //
    if ( GetOptionValueBool( VSSADM_O_QUIET ) )
        return TRUE;

    //
    //  Load the response message string, in English it is "YN"
    //
    LPWSTR pwszResponse;
    pwszResponse = GetMsg( FALSE, MSG_YESNO_RESPONSE_DATA );
    if ( pwszResponse == NULL ) 
    {
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
    			  L"Error on loading the message string id %d. 0x%08lx",
	    		  MSG_YESNO_RESPONSE_DATA, ::GetLastError() );
    }    

    //
    //  Now prompt the user, note, parameter 4 is the affirmative response (Y) and
    //  parameter 5 is the negative reponse (N)
    //
    OutputMsg( lPromptMsgId, ulNum, pwszResponse[0], pwszResponse[1] );
    WCHAR wcIn;
    DWORD fdwMode;

    //  Make sure we are outputting to a real console.
    if ( ( ::GetFileType( m_hConsoleOutput ) & FILE_TYPE_CHAR ) &&
         ::GetConsoleMode( m_hConsoleOutput, &fdwMode ) )
    {
        // Going to the console, ask the user.
        wcIn = ::MyGetChar();
    }
    else
    {
        // Output redirected, assume NO
        wcIn = pwszResponse[1];  // N
    }

    WCHAR wcsOutput[16];
    StringCchPrintfW( STRING_CCH_PARAM(wcsOutput), 
                L"%c\n\n", wcIn
                );
    
    OutputOnConsole( wcsOutput );

    //
    //  Compare the character using the proper W32 function and
    //  not towupper().  
    //
    if ( ::CompareStringW( LOCALE_INVARIANT, 
                           NORM_IGNORECASE | NORM_IGNOREKANATYPE, 
                           &wcIn,
                           1,
                           pwszResponse + 0,  // Y
                           1 ) == CSTR_EQUAL )
    {
        bRetVal = TRUE;
    }
    else
    {
        bRetVal = FALSE;
    }
                                                          
    ::CoTaskMemFree( pwszResponse );
    return bRetVal;
}

void CVssAdminCLI::OutputOnConsole(
    IN	LPCWSTR wszStr
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::OutputOnConsole" );
    
	DWORD dwCharsOutput;
	DWORD fdwMode;
	static BOOL bFirstTime = TRUE;
	static BOOL bIsTrueConsoleOutput;

    if ( m_hConsoleOutput == INVALID_HANDLE_VALUE )
    {
        throw E_UNEXPECTED;
    }

    if ( bFirstTime )
    {
        //
        //  Stash away the results in static vars.  bIsTrueConsoleOutput is TRUE when the 
        //  standard output handle is pointing to a console character device.
        //
    	bIsTrueConsoleOutput = ( ::GetFileType( m_hConsoleOutput ) & FILE_TYPE_CHAR ) && 
    	                       ::GetConsoleMode( m_hConsoleOutput, &fdwMode  );
	    bFirstTime = FALSE;
    }
    
    if ( bIsTrueConsoleOutput )
    {
        //
        //  Output to the console
        //
    	if ( !::WriteConsoleW( m_hConsoleOutput, 
    	                       ( PVOID )wszStr, 
    	                       ( DWORD )::wcslen( wszStr ), 
    	                       &dwCharsOutput, 
    	                       NULL ) )
    	{
    	    throw HRESULT_FROM_WIN32( ::GetLastError() );
    	}    	    	                       
    }
    else
    {
        //
        //  Output being redirected.  WriteConsoleW doesn't work for redirected output.  Convert
        //  UNICODE to the current output CP multibyte charset.
        //
        LPSTR lpszTmpBuffer;
        DWORD dwByteCount;

        //
        //  Get size of temp buffer needed for the conversion.
        //
        dwByteCount = ::WideCharToMultiByte(
                          ::GetConsoleOutputCP(),
                            0,
                            wszStr,
                            -1,
                            NULL,
                            0,
                            NULL,
                            NULL
                            );
        if ( dwByteCount == 0 )
        {
            throw HRESULT_FROM_WIN32( ::GetLastError() );
        }
        
        lpszTmpBuffer = ( LPSTR )::malloc( dwByteCount );
        if ( lpszTmpBuffer == NULL )
        {
            throw E_OUTOFMEMORY;
        }

        //
        //  Now convert it.
        //
        dwByteCount = ::WideCharToMultiByte(
                        ::GetConsoleOutputCP(),
                        0,
                        wszStr,
                        -1,
                        lpszTmpBuffer,
                        dwByteCount,
                        NULL,
                        NULL
                        );
        if ( dwByteCount == 0 )
        {
            ::free( lpszTmpBuffer );
            throw HRESULT_FROM_WIN32( ::GetLastError() );
        }
        
        //  Finally output it.
        if ( !::WriteFile(
                m_hConsoleOutput,
                lpszTmpBuffer,
                dwByteCount - 1,  // Get rid of the trailing NULL char
                &dwCharsOutput,
                NULL ) )
    	{
    	    throw HRESULT_FROM_WIN32( ::GetLastError() );
    	}    	    	                       

        ::free( lpszTmpBuffer );
    }
}

BOOL CVssAdminCLI::UnloggableError(IN HRESULT hError)
{
	switch (hError)
	{
		case VSSADM_E_INVALID_NUMBER:
		case VSSADM_E_INVALID_COMMAND:
		case VSSADM_E_INVALID_OPTION:
		case VSSADM_E_INVALID_OPTION_VALUE:
		case VSSADM_E_DUPLICATE_OPTION:
		case VSSADM_E_OPTION_NOT_ALLOWED_FOR_COMMAND:
		case VSSADM_E_REQUIRED_OPTION_MISSING:
		case VSSADM_E_INVALID_SET_OF_OPTIONS:
			return TRUE;
		default:
			return FALSE;
	}
}

//
//  Returns TRUE if error message was mapped
//
BOOL MapVssErrorToMsg(
	IN HRESULT hr,
	OUT LONG *plMsgNum
    ) throw( HRESULT )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"MapVssErrorToMsg" );

    ft.Trace( VSSDBG_VSSADMIN, L"Input HR: 0x%08x", hr );
    
    LONG msg = 0;
    *plMsgNum = 0;
    
    switch ( hr ) 
    {
    case VSSADM_E_NO_ITEMS_IN_QUERY:
        msg = MSG_ERROR_NO_ITEMS_FOUND;
        break;
    //  Parsing errors:
    case VSSADM_E_INVALID_NUMBER:
        msg = MSG_ERROR_INVALID_INPUT_NUMBER;
        break;
    case VSSADM_E_INVALID_COMMAND:
        msg = MSG_ERROR_INVALID_COMMAND;    	        
        break;
    case VSSADM_E_INVALID_OPTION:
        msg = MSG_ERROR_INVALID_OPTION;    	        
        break;
    case E_INVALIDARG:
    case VSSADM_E_INVALID_OPTION_VALUE:
        msg = MSG_ERROR_INVALID_OPTION_VALUE;    	        
        break;
    case VSSADM_E_DUPLICATE_OPTION:
        msg = MSG_ERROR_DUPLICATE_OPTION;    	        
        break;
    case VSSADM_E_OPTION_NOT_ALLOWED_FOR_COMMAND:
        msg = MSG_ERROR_OPTION_NOT_ALLOWED_FOR_COMMAND;
        break;
    case VSSADM_E_REQUIRED_OPTION_MISSING:
        msg = MSG_ERROR_REQUIRED_OPTION_MISSING;
        break;
    case VSSADM_E_INVALID_SET_OF_OPTIONS:
        msg = MSG_ERROR_INVALID_SET_OF_OPTIONS;
        break;
    case VSSADM_E_SNAPSHOT_NOT_FOUND:
    	msg = MSG_ERROR_SNAPSHOT_NOT_FOUND2;
    	break;
    case VSSADM_E_DELETION_DENIED:
    	msg = MSG_ERROR_DELETION_DENIED;
    	break;
    // VSS errors
    case VSS_E_PROVIDER_NOT_REGISTERED:
        msg = MSG_ERROR_VSS_PROVIDER_NOT_REGISTERED;
        break;    	        
    case VSS_E_OBJECT_NOT_FOUND:
        msg = MSG_ERROR_VSS_VOLUME_NOT_FOUND;
        break;    	            	        
    case VSS_E_PROVIDER_VETO:
        msg = MSG_ERROR_VSS_PROVIDER_VETO;
        break;    	            
    case VSS_E_VOLUME_NOT_SUPPORTED:
        msg = MSG_ERROR_VSS_VOLUME_NOT_SUPPORTED;
        break;
    case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:
        msg = MSG_ERROR_VSS_VOLUME_NOT_SUPPORTED_BY_PROVIDER;
        break;
    case VSS_E_UNEXPECTED_PROVIDER_ERROR:
        msg = MSG_ERROR_VSS_UNEXPECTED_PROVIDER_ERROR;
        break;
    case VSS_E_FLUSH_WRITES_TIMEOUT:
        msg = MSG_ERROR_VSS_FLUSH_WRITES_TIMEOUT;
        break;
    case VSS_E_HOLD_WRITES_TIMEOUT:
        msg = MSG_ERROR_VSS_HOLD_WRITES_TIMEOUT;
        break;
    case VSS_E_UNEXPECTED_WRITER_ERROR:
        msg = MSG_ERROR_VSS_UNEXPECTED_WRITER_ERROR;
        break;
    case VSS_E_SNAPSHOT_SET_IN_PROGRESS:
        msg = MSG_ERROR_VSS_SNAPSHOT_SET_IN_PROGRESS;
        break;
    case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:
        msg = MSG_ERROR_VSS_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED;
        break;
    case VSS_E_UNSUPPORTED_CONTEXT:
        msg = MSG_ERROR_VSS_UNSUPPORTED_CONTEXT;
        break;
    case VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED:
        msg = MSG_ERROR_VSS_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED;
        break;
    case VSS_E_INSUFFICIENT_STORAGE:
        msg = MSG_ERROR_VSS_INSUFFICIENT_STORAGE;
        break;    	            

    case E_OUTOFMEMORY:
        msg = MSG_ERROR_OUT_OF_MEMORY;
        break;
    case E_ACCESSDENIED:
        msg = MSG_ERROR_ACCESS_DENIED;
        break;

    case VSS_E_BAD_STATE:
    case VSS_E_CORRUPT_XML_DOCUMENT:
    case VSS_E_INVALID_XML_DOCUMENT:
    case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:
        msg = MSG_ERROR_INTERNAL_VSSADMIN_ERROR;
        break;
    }    

    if ( msg == 0 )
        return FALSE;
    
    *plMsgNum = msg;
    
    ft.Trace( VSSDBG_VSSADMIN, L"Output Msg#: 0x%08x", msg );

    return TRUE;

}

LPWSTR GuidToString(
    IN GUID guid
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"GuidToString" );

    LPWSTR pwszGuid;
    
    //  {36e4be76-035d-11d5-9ef2-806d6172696f}    
    const x_MaxGuidSize = 40;
    pwszGuid = (LPWSTR)::CoTaskMemAlloc( x_MaxGuidSize * sizeof( WCHAR ) );
    if ( pwszGuid == NULL )
		ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY,
				  L"Error from CoTaskMemAlloc: 0x%08lx",
				  ::GetLastError() );
        
    StringCchPrintfW( pwszGuid, x_MaxGuidSize,
                WSTR_GUID_FMT, GUID_PRINTF_ARG( guid )
                );
    
    return pwszGuid;    
}


LPWSTR DateTimeToString(
    IN VSS_TIMESTAMP *pTimeStamp
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"DateTimeToString" );

    LPWSTR pwszDateTime;
    SYSTEMTIME stLocal;
    FILETIME ftLocal;
    WCHAR pwszDate[ 64 ];
    WCHAR pwszTime[ 64 ];
    
    if ( pTimeStamp == NULL || *pTimeStamp == 0 )
    {
        SYSTEMTIME sysTime;
        FILETIME fileTime;
        
        //  Get current time
        ::GetSystemTime( &sysTime );

        //  Convert system time to file time
        ::SystemTimeToFileTime( &sysTime, &fileTime );
        
        //  Compensate for local TZ
        ::FileTimeToLocalFileTime( &fileTime, &ftLocal );
    }
    else
    {        
        //  Compensate for local TZ
        ::FileTimeToLocalFileTime( (FILETIME *)pTimeStamp, &ftLocal );
    }

    //  Finally convert it to system time
    ::FileTimeToSystemTime( &ftLocal, &stLocal );

    //  Convert timestamp to a date string
    ::GetDateFormatW( GetThreadLocale( ),
                      DATE_SHORTDATE,
                      &stLocal,
                      NULL,
                      pwszDate,
                      sizeof( pwszDate ) / sizeof( pwszDate[0] ));

    //  Convert timestamp to a time string
    ::GetTimeFormatW( GetThreadLocale( ),
                      0,
                      &stLocal,
                      NULL,
                      pwszTime,
                      sizeof( pwszTime ) / sizeof( pwszTime[0] ));

    //  Now combine the strings and return it
    pwszDateTime = (LPWSTR)::CoTaskMemAlloc( ( ::wcslen( pwszDate ) + ::wcslen( pwszTime ) + 2 ) * sizeof( pwszDate[0] ) );
    if ( pwszDateTime == NULL )
		ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY,
				  L"Error from CoTaskMemAlloc, rc: %d",
				  ::GetLastError() );

    ::wcscpy( pwszDateTime, pwszDate );
    ::wcscat( pwszDateTime, L" " );
    ::wcscat( pwszDateTime, pwszTime );
    
    return pwszDateTime;    
}


LPWSTR LonglongToString(
    IN LONGLONG llValue
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"LonglongToString" );

    WCHAR wszLL[64];
    LPWSTR pwszRetVal = NULL;

    ::_i64tow( llValue, wszLL, 10 );

    ::VssSafeDuplicateStr( ft, pwszRetVal, wszLL );
    return pwszRetVal;
}

/*++

Description:

	Uses the win32 console functions to get one character of input.

--*/
WCHAR MyGetChar(
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"MyGetChar" );

    DWORD fdwOldMode, fdwMode;
    HANDLE hStdin;
    WCHAR chBuffer[2];
    
    hStdin = ::GetStdHandle(STD_INPUT_HANDLE); 
    if (hStdin == INVALID_HANDLE_VALUE) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"MyGetChar - Error from GetStdHandle(), rc: %d",
				  ::GetLastError() );
    }

    if (!::GetConsoleMode(hStdin, &fdwOldMode)) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"MyGetChar - Error from GetConsoleMode(), rc: %d",
				  ::GetLastError() );
    }

    fdwMode = fdwOldMode & ~( ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT ); 
    if (!::SetConsoleMode(hStdin, fdwMode)) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"MyGetChar - Error from SetConsoleMode(), rc: %d",
				  ::GetLastError() );
    }

    // Flush the console input buffer to make sure there is no queued input
    ::FlushConsoleInputBuffer( hStdin );
    
    // Without line and echo input modes, ReadFile returns 
    // when any input is available.
    DWORD dwBytesRead;
    if (!::ReadConsoleW(hStdin, chBuffer, 1, &dwBytesRead, NULL)) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"MyGetChar - Error from ReadConsoleW(), rc: %d",
				  ::GetLastError() );
    }

    // Restore the original console mode. 
    ::SetConsoleMode(hStdin, fdwOldMode);

    return chBuffer[0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\vssadmin.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module vssadmin.cpp | Implementation of the Volume Snapshots demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

// The rest of includes are specified here
#include "vssadmin.h"
#include "versionspecific.h"
#include "commandverifier.h"

#include <locale.h>
#include <winnlsp.h>  // in public\internal\base\inc


BOOL AssertPrivilege( 
    IN LPCWSTR privName 
    );

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMVADMC"
//
////////////////////////////////////////////////////////////////////////

//
//  List of hard coded option names.  If you add options, make sure to keep this
//  list in alphabetical order.
//
const SVssAdmOption g_asAdmOptions[] =
{
    { VSSADM_O_ALL,                 L"All",                  VSSADM_OT_BOOL },
    { VSSADM_O_AUTORETRY,      L"AutoRetry",      VSSADM_OT_NUM  },
    { VSSADM_O_EXPOSE_USING,   L"ExposeUsing",    VSSADM_OT_STR  },
    { VSSADM_O_FOR,            L"For",            VSSADM_OT_STR  },
    { VSSADM_O_MAXSIZE,        L"MaxSize",        VSSADM_OT_NUM  },
    { VSSADM_O_OLDEST,         L"Oldest",         VSSADM_OT_BOOL },
    { VSSADM_O_ON,             L"On",             VSSADM_OT_STR  },
    { VSSADM_O_PROVIDER,       L"Provider",       VSSADM_OT_STR  },
    { VSSADM_O_QUIET,          L"Quiet",          VSSADM_OT_BOOL },
    { VSSADM_O_SET,            L"Set",            VSSADM_OT_STR  },
    { VSSADM_O_SHAREPATH,      L"SharePath",      VSSADM_OT_STR  },
    { VSSADM_O_SNAPSHOT,       L"Shadow",         VSSADM_OT_STR  },
    { VSSADM_O_SNAPTYPE,       L"Type",           VSSADM_OT_STR  },
    { VSSADM_O_INVALID,        NULL,              VSSADM_OT_BOOL }
};


//
//  List of vssadmin commands.  Keep this in alphabetical order.  Also, keep the option flags in the same order as
//  the EVssAdmOption and g_asAdmOptions.
//
const SVssAdmCommandsEntry g_asAdmCommands[] = 
{ //  Major      Minor                      Option                                                SKUs        MsgGen                                                MsgDetail                                                       bShowSSTypes  All         AutoRtry ExpUsing  For      MaxSize   Oldest     On         Provider Quiet       Set      ShrePath  Snapshot Type 
{ L"Add",    L"ShadowStorage",   VSSADM_C_ADD_DIFFAREA_INT,         SKU_INT,  MSG_USAGE_GEN_ADD_DIFFAREA,        MSG_USAGE_DTL_ADD_DIFFAREA_INT,          FALSE,                 { V_NO,  V_NO,    V_NO,    V_YES,   V_OPT,   V_NO,    V_YES,   V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Add",    L"ShadowStorage",   VSSADM_C_ADD_DIFFAREA_PUB,         SKU_SN,   MSG_USAGE_GEN_ADD_DIFFAREA,        MSG_USAGE_DTL_ADD_DIFFAREA_PUB,          FALSE,            { V_NO,  V_NO,    V_NO,    V_YES,   V_OPT,   V_NO,    V_YES,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Create", L"Shadow",             VSSADM_C_CREATE_SNAPSHOT_INT,   SKU_INT,  MSG_USAGE_GEN_CREATE_SNAPSHOT,  MSG_USAGE_DTL_CREATE_SNAPSHOT_INT,    TRUE,             { V_NO,  V_OPT,   V_NO,    V_YES,   V_NO,    V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_YES   } },
    { L"Create", L"Shadow",             VSSADM_C_CREATE_SNAPSHOT_PUB,   SKU_SN,   MSG_USAGE_GEN_CREATE_SNAPSHOT,  MSG_USAGE_DTL_CREATE_SNAPSHOT_PUB,   FALSE,            { V_NO,  V_OPT,   V_NO,    V_YES,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Delete", L"Shadows",            VSSADM_C_DELETE_SNAPSHOTS_INT,  SKU_INT,  MSG_USAGE_GEN_DELETE_SNAPSHOTS, MSG_USAGE_DTL_DELETE_SNAPSHOTS_INT,  TRUE,              { V_OPT, V_NO,    V_NO,    V_OPT,   V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_OPT   } },
    { L"Delete", L"Shadows",            VSSADM_C_DELETE_SNAPSHOTS_PUB, SKU_SN,   MSG_USAGE_GEN_DELETE_SNAPSHOTS, MSG_USAGE_DTL_DELETE_SNAPSHOTS_PUB, FALSE,             { V_OPT, V_NO,    V_NO,    V_OPT,   V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_NO   } },
    { L"Delete", L"ShadowStorage",  VSSADM_C_DELETE_DIFFAREAS_INT,   SKU_INT,  MSG_USAGE_GEN_DELETE_DIFFAREAS,  MSG_USAGE_DTL_DELETE_DIFFAREAS_INT,    FALSE,             { V_NO,  V_NO,    V_NO,    V_YES,   V_NO,    V_NO,    V_OPT,   V_OPT,   V_OPT,   V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Delete", L"ShadowStorage",  VSSADM_C_DELETE_DIFFAREAS_PUB,   SKU_SN,   MSG_USAGE_GEN_DELETE_DIFFAREAS,  MSG_USAGE_DTL_DELETE_DIFFAREAS_PUB,   FALSE,             { V_NO,  V_NO,    V_NO,    V_YES,   V_NO,    V_NO,    V_OPT,   V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Expose", L"Shadow",            VSSADM_C_EXPOSE_SNAPSHOT,          SKU_INT,  MSG_USAGE_GEN_EXPOSE_SNAPSHOT,  MSG_USAGE_DTL_EXPOSE_SNAPSHOT,          FALSE,             { V_NO,  V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_OPT,   V_YES,   V_NO    } },
    { L"List",   L"Providers",             VSSADM_C_LIST_PROVIDERS,              SKU_A,     MSG_USAGE_GEN_LIST_PROVIDERS,     MSG_USAGE_DTL_LIST_PROVIDERS,               FALSE,            { V_NO,  V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"List",   L"Shadows",              VSSADM_C_LIST_SNAPSHOTS_INT,      SKU_INT,   MSG_USAGE_GEN_LIST_SNAPSHOTS,     MSG_USAGE_DTL_LIST_SNAPSHOTS_INT,      TRUE,              { V_NO,  V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_OPT,   V_NO,    V_OPT,   V_NO,    V_OPT,   V_OPT   } },
    { L"List",   L"Shadows",              VSSADM_C_LIST_SNAPSHOTS_PUB,      SKU_A,     MSG_USAGE_GEN_LIST_SNAPSHOTS,     MSG_USAGE_DTL_LIST_SNAPSHOTS_PUB,     FALSE,             { V_NO,  V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_OPT,    V_NO,    V_OPT,   V_NO    } },
    { L"List",   L"ShadowStorage",    VSSADM_C_LIST_DIFFAREAS_INT,        SKU_INT,  MSG_USAGE_GEN_LIST_DIFFAREAS,      MSG_USAGE_DTL_LIST_DIFFAREAS_INT,        FALSE,             { V_NO,  V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"List",   L"ShadowStorage",    VSSADM_C_LIST_DIFFAREAS_PUB,        SKU_SN,  MSG_USAGE_GEN_LIST_DIFFAREAS,      MSG_USAGE_DTL_LIST_DIFFAREAS_PUB,       FALSE,             { V_NO,  V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"List",   L"Volumes",               VSSADM_C_LIST_VOLUMES_INT,          SKU_INT,  MSG_USAGE_GEN_LIST_VOLUMES,        MSG_USAGE_DTL_LIST_VOLUMES_INT,          TRUE,               { V_NO,  V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_OPT   } },
    { L"List",   L"Volumes",               VSSADM_C_LIST_VOLUMES_PUB,          SKU_A,    MSG_USAGE_GEN_LIST_VOLUMES,        MSG_USAGE_DTL_LIST_VOLUMES_PUB,          FALSE,             { V_NO,  V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO   } },
    { L"List",   L"Writers",                 VSSADM_C_LIST_WRITERS,                 SKU_A,    MSG_USAGE_GEN_LIST_WRITERS,        MSG_USAGE_DTL_LIST_WRITERS,                  FALSE,              { V_NO,  V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Resize", L"ShadowStorage",  VSSADM_C_RESIZE_DIFFAREA_INT,     SKU_INT,  MSG_USAGE_GEN_RESIZE_DIFFAREA,   MSG_USAGE_DTL_RESIZE_DIFFAREA_INT,     FALSE,               { V_NO,  V_NO,    V_NO,    V_YES,   V_OPT,   V_NO,    V_YES,   V_OPT,  V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Resize", L"ShadowStorage",  VSSADM_C_RESIZE_DIFFAREA_PUB,     SKU_SN,  MSG_USAGE_GEN_RESIZE_DIFFAREA,   MSG_USAGE_DTL_RESIZE_DIFFAREA_PUB,     FALSE,              { V_NO,  V_NO,    V_NO,    V_YES,   V_OPT,   V_NO,    V_YES,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
{ NULL,      NULL,                       VSSADM_C_NUM_COMMANDS,              0,           0,                                                        0,                                                                 FALSE,              { V_NO,  V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } }
};

//
//  List of snapshot types that are supported by the command line
//
const SVssAdmSnapshotTypeName g_asAdmTypeNames[]=
{
    { L"ClientAccessible",           SKU_SNI,   VSS_CTX_CLIENT_ACCESSIBLE,      MSG_TYPE_DESCRIPTION_CLIENTACCESSIBLE},
    { L"DataVolumeRollback",     SKU_SNI,   VSS_CTX_NAS_ROLLBACK,             MSG_TYPE_DESCRIPTION_DATAVOLUMEROLLBACK},
    { L"ApplicationRollback",       SKU_I,       VSS_CTX_APP_ROLLBACK,              MSG_TYPE_DESCRIPTION_APPLICATIONROLLBACK},
    { L"FileShareRollback",         SKU_I,       VSS_CTX_FILE_SHARE_BACKUP,      MSG_TYPE_DESCRIPTION_FILESHAREROLLBACK},    
    { L"Backup",                        SKU_I,       VSS_CTX_BACKUP,                         MSG_TYPE_DESCRIPTION_BACKUP},            
    { NULL,                                0,              0,                                                  0                                    }
};

/////////////////////////////////////////////////////////////////////////////
//  Implementation



CVssAdminCLI::CVssAdminCLI(
    IN INT argc,
    IN PWSTR argv[]
	)

/*++

	Description:

		Standard constructor. Initializes internal members

--*/

{
    m_argc = argc;
    m_argv = argv;
    
	m_eFilterObjectType = VSS_OBJECT_UNKNOWN;
	m_eListedObjectType = VSS_OBJECT_UNKNOWN;
	m_FilterSnapshotId = GUID_NULL;
	m_nReturnValue = VSS_CMDRET_ERROR;
	m_hConsoleOutput = INVALID_HANDLE_VALUE;	
	m_pMapVolumeNames = NULL;

	m_pVerifier = NULL;
}


CVssAdminCLI::~CVssAdminCLI()

/*++

	Description:

		Standard destructor. Calls Finalize and eventually frees the
		memory allocated by internal members.

--*/

{
	// Release the cached resource strings
    for( int nIndex = 0; nIndex < m_mapCachedResourceStrings.GetSize(); nIndex++) {
	    LPCWSTR& pwszResString = m_mapCachedResourceStrings.GetValueAt(nIndex);
		::VssFreeString(pwszResString);
    }

	// Release the cached provider names
    for( int nIndex = 0; nIndex < m_mapCachedProviderNames.GetSize(); nIndex++) {
	    LPCWSTR& pwszProvName = m_mapCachedProviderNames.GetValueAt(nIndex);
		::VssFreeString(pwszProvName);
    }

    // Release the volume name map if necessary
	if ( m_pMapVolumeNames != NULL)
	{
        for( int nIndex = 0; nIndex < m_pMapVolumeNames->GetSize(); nIndex++) 
        {
    	    LPCWSTR& pwsz = m_pMapVolumeNames->GetValueAt(nIndex);
    		::VssFreeString(pwsz);
    		pwsz = m_pMapVolumeNames->GetKeyAt(nIndex);
    		::VssFreeString(pwsz);
        }
        
        delete m_pMapVolumeNames;
	}

       delete m_pVerifier;
       
	// Uninitialize the COM library
	Finalize();
}



/////////////////////////////////////////////////////////////////////////////
//  Implementation

void CVssAdminCLI::GetProviderId(
    OUT VSS_ID *pProviderId
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetProviderId" );
    
    // If a provider is not specified, always return babbage
    if (g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[VSSADM_O_PROVIDER] == V_NO)	{
    	*pProviderId = VSS_SWPRV_ProviderId;
    	return;
    }
    
    *pProviderId = GUID_NULL;
    
    //
    // If user specified a provider, process option
    //
    LPCWSTR pwszProvider = GetOptionValueStr( VSSADM_O_PROVIDER );
    if (pwszProvider != NULL )
    {
        //
        //  Determine if this is an ID or a name
        //
        if ( !ScanGuid( pwszProvider, *pProviderId ) )
        {
            //  Have a provider name, look it up
            if ( !GetProviderIdByName( pwszProvider, pProviderId ) )
            {
                // Provider name not found, print error
                OutputErrorMsg( MSG_ERROR_PROVIDER_NAME_NOT_FOUND, pwszProvider );
                // Throw S_OK since the error message has already been output
                ft.Throw( VSSDBG_VSSADMIN, S_OK, L"Already printed error message" );
            }
        }
    }
}

LPCWSTR CVssAdminCLI::GetProviderName(
	IN	VSS_ID& ProviderId
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetProviderName" );

	LPCWSTR wszReturnedString = m_mapCachedProviderNames.Lookup(ProviderId);
	if (wszReturnedString)
		return wszReturnedString;

	CComPtr<IVssCoordinator> pICoord;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VSSCoordinator,
            L"Coordinator",
            CLSCTX_ALL,
            IID_IVssCoordinator,
            (IUnknown**)&(pICoord));
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);

	CComPtr<IVssEnumObject> pIEnumProvider;
	ft.hr = pICoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_PROVIDER,
				&pIEnumProvider );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

	VSS_OBJECT_PROP Prop;
	VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;

	// Go through the list of providers to find the one we are interested in.
	ULONG ulFetched;
	while( 1 )
	{
    	ft.hr = pIEnumProvider->Next( 1, &Prop, &ulFetched );
    	if ( ft.HrFailed() )
    		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);

    	if (ft.hr == S_FALSE) {
    	    // End of enumeration.
        	// Provider not registered? Where did this snapshot come from?
        	// It might be still possible if a snapshot provider was deleted
        	// before querying the snapshot provider but after the snapshot attributes
        	// were queried.
    		BS_ASSERT(ulFetched == 0);
    		return LoadString( IDS_UNKNOWN_PROVIDER );
    	}

        ::VssFreeString( Prov.m_pwszProviderVersion );

    	if (Prov.m_ProviderId == ProviderId)
    	{
    	    break;
    	}
    	
    	::VssFreeString( Prov.m_pwszProviderName );
	}	

    // Auto delete the string
    CVssAutoPWSZ awszProviderName( Prov.m_pwszProviderName );
    
	// Duplicate the new string
	LPWSTR wszNewString = NULL;
	BS_ASSERT( (LPCWSTR)awszProviderName != NULL );
	::VssSafeDuplicateStr( ft, wszNewString, awszProviderName );
	wszReturnedString = wszNewString;

	// Save the string in the cache, transfer of pointer ownership.
	if (!m_mapCachedProviderNames.Add( ProviderId, wszReturnedString )) {
		::VssFreeString( wszReturnedString );
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
	}

	return wszReturnedString;
}


BOOL CVssAdminCLI::GetProviderIdByName(
	IN  LPCWSTR pwszProviderName,
	OUT	VSS_ID *pProviderId
	) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::GetProviderIdByName" );

	CComPtr<IVssCoordinator> pICoord;

    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSADMIN,
            CLSID_VSSCoordinator,
            L"Coordinator",
            CLSCTX_ALL,
            IID_IVssCoordinator,
            (IUnknown**)&(pICoord));
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	CComPtr<IVssEnumObject> pIEnumProvider;
	ft.hr = pICoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_PROVIDER,
				&pIEnumProvider );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

	VSS_OBJECT_PROP Prop;
	VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;

	// Go through the list of providers to find the one we are interested in.
	ULONG ulFetched;
	while( 1 )
	{
    	ft.hr = pIEnumProvider->Next( 1, &Prop, &ulFetched );
    	if ( ft.HrFailed() )
    		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);

    	if (ft.hr == S_FALSE) {
    	    // End of enumeration.
        	// Provider not registered? Where did this snapshot come from?
        	// It might be still possible if a snapshot provider was deleted
        	// before querying the snapshot provider but after the snapshot attributes
        	// were queried.
    		BS_ASSERT(ulFetched == 0);
    	    *pProviderId = GUID_NULL;
    	    return FALSE;
    	}
    	
    	::VssFreeString( Prov.m_pwszProviderVersion );

    	if (::_wcsicmp( Prov.m_pwszProviderName, pwszProviderName) == 0)
    	{
        	::VssFreeString( Prov.m_pwszProviderName );
    	    break;
    	}

    	::VssFreeString( Prov.m_pwszProviderName );
	}	
	
    *pProviderId = Prov.m_ProviderId;
    
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//  Implementation


void CVssAdminCLI::Initialize(
	) throw(HRESULT)

/*++

	Description:

		Initializes the COM library. Called explicitely after instantiating the CVssAdminCLI object.

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::Initialize" );

    // Use the OEM code page ...
    ::setlocale(LC_ALL, ".OCP");

    // Use the console UI language
    ::SetThreadUILanguage( 0 );

    //
    //  Use only the Console routines to output messages.  To do so, need to open standard
    //  output.
    //
    m_hConsoleOutput = ::GetStdHandle(STD_OUTPUT_HANDLE); 
    if (m_hConsoleOutput == INVALID_HANDLE_VALUE) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"Initialize - Error from GetStdHandle(), rc: %d",
				  ::GetLastError() );
    }
    
	// Initialize COM library
	ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Failure in initializing the COM library 0x%08lx", ft.hr);

    // Initialize COM security
    ft.hr = CoInitializeSecurity(
           NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,           //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IDENTIFY,         //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );

	if (ft.HrFailed()) {
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
                  L" Error: CoInitializeSecurity() returned 0x%08lx", ft.hr );
    }

    //  Turns off SEH exception handing for COM servers (BUG# 530092)
    ft.ComDisableSEH(VSSDBG_VSSADMIN);
    
    //
    //  Assert the Backup privilage.  Not worried about errors here since VSS will
    //  return access denied return codes if the user doesn't have permission.
    //
    
    (void)::AssertPrivilege (SE_BACKUP_NAME);

    // Create an instance of the parameter checker
       m_pVerifier = CCommandVerifier::Instance();
       if (m_pVerifier == NULL)	
       	ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
       
	// Print the header
	OutputMsg( MSG_UTILITY_HEADER );
}


//
//  Returns true if the command line was parsed fine
//
BOOL CVssAdminCLI::ParseCmdLine(
	) throw(HRESULT)

/*++

	Description:

		Parses the command line.

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::ParseCmdLine" );

	// Skip the executable name
	GetNextCmdlineToken( true );

	// Get the first token after the executable name
	LPCWSTR pwszMajor = GetNextCmdlineToken();
    LPCWSTR pwszMinor = NULL;
    if ( pwszMajor != NULL )
    {
        if ( ::wcscmp( pwszMajor, L"/?" ) == 0 || ::wcscmp( pwszMajor, L"-?" ) == 0 )
            return FALSE;
        pwszMinor = GetNextCmdlineToken();
    }
    
    if ( pwszMajor == NULL || pwszMinor == NULL )
    {
   		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_COMMAND, L"Incomplete command");
    }

    INT idx;
    
    // See if the command is found in list of commands
    for ( idx = VSSADM_C_FIRST; idx < VSSADM_C_NUM_COMMANDS; ++idx )
    {
        if ( ( dCurrentSKU & g_asAdmCommands[idx].dwSKUs ) &&
             Match( pwszMajor, g_asAdmCommands[idx].pwszMajorOption ) && 
             Match( pwszMinor, g_asAdmCommands[idx].pwszMinorOption ) )
        {
            //
            //  Got a match
            //
            break;            
        }
    }

    if ( idx == VSSADM_C_NUM_COMMANDS )
    {
   		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_COMMAND, L"Invalid command");
    }

    //
    // Found the command. 
    //
    m_eCommandType = ( EVssAdmCommand )idx;
    m_sParsedCommand.eAdmCmd = ( EVssAdmCommand )idx;

    //
    // Now need to process command line options
    //
    LPCWSTR pwszOption = GetNextCmdlineToken();

    while ( pwszOption != NULL )
    {
        if ( pwszOption[0] == L'/' || pwszOption[0] == L'-' )
        {
            //
            // Got a named option, now see if it is a valid option 
            // for the command.
            //

            // Skip past delimiter
            ++pwszOption;

            //
            // See if they want usage
            //
            if ( pwszOption[0] == L'?' )
                return FALSE;
            
            // Parse out the value part of the named option
            LPWSTR pwszValue = ::wcschr( pwszOption, L'=' );
            if ( pwszValue != NULL )
            {
                // Replace = with NULL char and set value to point to string after the =
                pwszValue[0] = L'\0';
                ++pwszValue;
            }
            
            // At this point, if pwszValue == NULL, it means the option had no = and so no specified value.
            // If pwszValue[0] == L'\0', then the value is an empty value
            
            INT eOpt;
            
            // Now figure out which named option this is
            for ( eOpt = VSSADM_O_FIRST; eOpt < VSSADM_O_NUM_OPTIONS; ++eOpt )
            {
                if ( Match( g_asAdmOptions[eOpt].pwszOptName, pwszOption ) )
                    break;
            }

            // See if this is a bogus option
            if ( eOpt == VSSADM_O_NUM_OPTIONS )
            {
           		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION, L"Invalid option: %s", pwszOption);
            }

            // See if this option has already been specified
            if ( m_sParsedCommand.apwszOptionValues[eOpt] != NULL )
            {
           		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_DUPLICATE_OPTION, L"Duplicate option given: %s", pwszOption);
            }
            
            //  See if this option is allowed for the command
            if ( g_asAdmCommands[ m_sParsedCommand.eAdmCmd ].aeOptionFlags[ eOpt ] == V_NO )
            {
           		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_OPTION_NOT_ALLOWED_FOR_COMMAND, L"Option not allowed for this command: %s", pwszOption);
            }

            // See if this option is supposed to have a value, BOOL options do not
            if ( ( g_asAdmOptions[eOpt].eOptType == VSSADM_OT_BOOL && pwszValue != NULL ) ||
                 ( g_asAdmOptions[eOpt].eOptType != VSSADM_OT_BOOL && ( pwszValue == NULL || pwszValue[0] == L'\0' ) ) )
            {
           		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE, L"Invalid option value: /%s=%s", pwszOption, pwszValue ? pwszValue : L"<MISSING>" );
            }

            // Finally, we have a valid option, save away the option value.  
            // See if it is a boolean type.  In the option array we store the wszVssOptBoolTrue string.  
            // The convention is if the option is NULL, then the boolean option is false, else it
            // is true.
            if ( g_asAdmOptions[eOpt].eOptType == VSSADM_OT_BOOL )
                ::VssSafeDuplicateStr( ft, m_sParsedCommand.apwszOptionValues[eOpt], x_wszVssOptBoolTrue );
            else
                ::VssSafeDuplicateStr( ft, m_sParsedCommand.apwszOptionValues[eOpt], pwszValue );                
        }
        else
        {
            //
            // Got an unnamed option, not valid in any command
            //
       		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_COMMAND, L"Invalid command");
        }
        pwszOption = GetNextCmdlineToken();
    }

    //  We are done parsing the command-line.  Now see if any mandatory named options were missing
    for ( idx = VSSADM_O_FIRST; idx < VSSADM_O_NUM_OPTIONS; ++idx )
    {
        if ( ( m_sParsedCommand.apwszOptionValues[idx] == NULL ) &&
             ( g_asAdmCommands[ m_sParsedCommand.eAdmCmd ].aeOptionFlags[ idx ] == V_YES ) )
        {
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_REQUIRED_OPTION_MISSING, L"Required option missing");
        }
    }

    //
    //  Now fix up certain options if needed
    //
    LPWSTR pwszStr;
    
    //  Need a \ at the end of the FOR option
    pwszStr =  m_sParsedCommand.apwszOptionValues[ VSSADM_O_FOR ];
    if (  pwszStr != NULL )
    {
        if ( pwszStr[ ::wcslen( pwszStr ) - 1 ] != L'\\' )
        {
            pwszStr = ::VssReallocString( ft, pwszStr, (LONG)::wcslen( pwszStr ) + 1 );
            ::wcscat( pwszStr, L"\\" );
            m_sParsedCommand.apwszOptionValues[ VSSADM_O_FOR ] = pwszStr;
        }
    }
    //  Need a \ at the end of the ON option
    pwszStr =  m_sParsedCommand.apwszOptionValues[ VSSADM_O_ON ];
    if (  pwszStr != NULL )
    {
        if ( pwszStr[ ::wcslen( pwszStr ) - 1 ] != L'\\' )
        {
            pwszStr = ::VssReallocString( ft, pwszStr, (LONG)::wcslen( pwszStr ) + 1 );
            ::wcscat( pwszStr, L"\\" );
            m_sParsedCommand.apwszOptionValues[ VSSADM_O_ON ] = pwszStr;
        }
    }

    return TRUE;
}

void CVssAdminCLI::DoProcessing(
	) throw(HRESULT)
{   
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::DoProcessing" );

	switch( m_sParsedCommand.eAdmCmd )
	{
    case VSSADM_C_CREATE_SNAPSHOT_INT:
    case VSSADM_C_CREATE_SNAPSHOT_PUB:
        CreateSnapshot();
        break;

    case VSSADM_C_LIST_PROVIDERS:
        ListProviders();
        break;

    case VSSADM_C_LIST_SNAPSHOTS_INT:
    case VSSADM_C_LIST_SNAPSHOTS_PUB:
        ListSnapshots();
        break;

    case VSSADM_C_LIST_WRITERS:
        ListWriters();
        break;
        
    case VSSADM_C_ADD_DIFFAREA_INT:
    case VSSADM_C_ADD_DIFFAREA_PUB:
        AddDiffArea();
        break;
        
    case VSSADM_C_RESIZE_DIFFAREA_INT:
    case VSSADM_C_RESIZE_DIFFAREA_PUB:
        ResizeDiffArea();
        break;
        
    case VSSADM_C_DELETE_DIFFAREAS_INT:
    case VSSADM_C_DELETE_DIFFAREAS_PUB:
        DeleteDiffAreas();
        break;

    case VSSADM_C_LIST_DIFFAREAS_INT:
    case VSSADM_C_LIST_DIFFAREAS_PUB:
        ListDiffAreas();
        break;

    case VSSADM_C_DELETE_SNAPSHOTS_INT:
    case VSSADM_C_DELETE_SNAPSHOTS_PUB:
        DeleteSnapshots();
        break;

    case VSSADM_C_EXPOSE_SNAPSHOT:
        ExposeSnapshot();
        break;

    case VSSADM_C_LIST_VOLUMES_INT:
    case VSSADM_C_LIST_VOLUMES_PUB:
        ListVolumes();
        break;
        
	default:
		ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Invalid command type: %d", m_eCommandType);
	}
}

void CVssAdminCLI::Finalize()

/*++

	Description:

		Uninitialize the COM library. Called in CVssAdminCLI destructor.

--*/

{
	// Uninitialize COM library
	CoUninitialize();
}


HRESULT CVssAdminCLI::Main(
    IN INT argc,
    IN PWSTR argv[]
	)

/*++

Function:
	
	CVssAdminCLI::Main

Description:

	Static function used as the main entry point in the VSS CLI

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::Main" );
	INT nReturnValue = VSS_CMDRET_ERROR;

    try
    {
		CVssAdminCLI	program(argc, argv);

		try
		{
			// Initialize the program. This calls CoInitialize()
			program.Initialize();
			// Parse the command line
			if ( program.ParseCmdLine() )
			{
    			// Do the work...
	    		program.DoProcessing();
			}
			else
			{
			    // Error parsing the command line, print out usage
			    program.PrintUsage();
			}

			ft.hr = S_OK; // Assume that the above methods printed error
			              // messages if there was an error.
		}
		VSS_STANDARD_CATCH(ft)

        nReturnValue = program.GetReturnValue();

        //
        // Log the error if this is create snapshot
        //
        if ( ft.hr != S_OK  &&  (program.m_eCommandType == VSSADM_C_CREATE_SNAPSHOT_INT ||
        					 program.m_eCommandType == VSSADM_C_CREATE_SNAPSHOT_PUB) &&
        	!UnloggableError(ft.hr))
        {
            // 
            //  Log error message
            //
            LPWSTR pwszSnapshotErrMsg;
            pwszSnapshotErrMsg = program.GetMsg( FALSE, MSG_ERROR_UNABLE_TO_CREATE_SNAPSHOT );
            if ( pwszSnapshotErrMsg == NULL ) 
            {
        		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
            			  L"Error on loading the message string id %d. 0x%08lx",
        	    		  MSG_ERROR_UNABLE_TO_CREATE_SNAPSHOT, ::GetLastError() );
            }    
            
            LONG lMsgNum;        
            LPWSTR pwszMsg = NULL;   
            if ( ::MapVssErrorToMsg( ft.hr, &lMsgNum ) )
            {
                pwszMsg = program.GetMsg( FALSE, lMsgNum );
                if ( pwszMsg == NULL ) 
                {
            		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
                			  L"Error on loading the message string id %d. 0x%08lx",
            	    		  lMsgNum, ::GetLastError() );
                }    
                ft.LogError( VSS_ERROR_VSSADMIN_ERROR, VSSDBG_VSSADMIN << pwszSnapshotErrMsg << pwszMsg << ::GetCommandLineW() );
                ::VssFreeString( pwszMsg );
            }
            else
            {
                // Try to get the system error message
                pwszMsg = program.GetMsg( FALSE, ft.hr );
                if ( pwszMsg != NULL ) 
                {
                    ft.LogError( VSS_ERROR_VSSADMIN_ERROR, VSSDBG_VSSADMIN << pwszSnapshotErrMsg << pwszMsg << ::GetCommandLineW() );
                    ::VssFreeString( pwszMsg );
                }
                else
                {
                    WCHAR wszHr[64];
                    StringCchPrintfW( STRING_CCH_PARAM(wszHr), L"hr = 0x%08x", ft.hr );
                    ft.LogError( VSS_ERROR_VSSADMIN_ERROR, VSSDBG_VSSADMIN << pwszSnapshotErrMsg << wszHr << ::GetCommandLineW() );
                }
            }

            ::VssFreeString( pwszSnapshotErrMsg );            
        }

        //
		// Print the error on the display, if any
		//
		if ( ft.hr != S_OK )
		{
		    LONG lMsgNum;
		    
		    //  If the error is empty query, print out a message stating that
		    if ( ft.hr == VSSADM_E_NO_ITEMS_IN_QUERY )
		    {
      	        nReturnValue = VSS_CMDRET_EMPTY_RESULT;
       			program.OutputMsg( MSG_ERROR_NO_ITEMS_FOUND );    			         	        
		    }
            else if ( ::MapVssErrorToMsg(ft.hr, &lMsgNum ) )
		    {
    		    //  This is a parsing or VSS error, map it to a msg id
      	        program.OutputErrorMsg( lMsgNum );
      	        if ( ft.hr >= VSSADM_E_FIRST_PARSING_ERROR && ft.hr <= VSSADM_E_LAST_PARSING_ERROR )
      	        {
      	            program.PrintUsage();
      	        }
		    }
		    else
		    {
    	        //  Unhandled error, try to get the error string from the system
                LPWSTR pwszMsg;
                // Try to get the system error message
                pwszMsg = program.GetMsg( FALSE, ft.hr );
                if ( pwszMsg != NULL ) 
                {
        			program.OutputMsg( MSG_ERROR_UNEXPECTED_WITH_STRING, pwszMsg );    			    
                    ::VssFreeString( pwszMsg );
                } 
    			else
    			{
        			program.OutputMsg( MSG_ERROR_UNEXPECTED_WITH_HRESULT, ft.hr );    			    
    			}
		    }
        }

		// The destructor automatically calls CoUninitialize()
	}
    VSS_STANDARD_CATCH(ft)

	return nReturnValue;
}


BOOL AssertPrivilege( 
    IN LPCWSTR privName 
    )
{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( ::OpenProcessToken (GetCurrentProcess(),
			   TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			   &tokenHandle))
	{
    	LUID value;

    	if ( ::LookupPrivilegeValueW( NULL, privName, &value ) )
    	{
    	    TOKEN_PRIVILEGES newState;
    	    DWORD            error;

    	    newState.PrivilegeCount           = 1;
    	    newState.Privileges[0].Luid       = value;
    	    newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

    	    /*
    	     * We will always call GetLastError below, so clear
    	     * any prior error values on this thread.
    	     */
    	    ::SetLastError( ERROR_SUCCESS );

    	    stat = ::AdjustTokenPrivileges (tokenHandle,
    					  FALSE,
    					  &newState,
    					  (DWORD)0,
    					  NULL,
    					  NULL );

    	    /*
    	     * Supposedly, AdjustTokenPriveleges always returns TRUE
    	     * (even when it fails). So, call GetLastError to be
    	     * extra sure everything's cool.
    	     */
    	    if ( (error = ::GetLastError()) != ERROR_SUCCESS )
    		{
        		stat = FALSE;
    		}
        }

    	DWORD cbTokens;
    	::GetTokenInformation (tokenHandle,
    			     TokenPrivileges,
    			     NULL,
    			     0,
    			     &cbTokens);

    	TOKEN_PRIVILEGES *pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];
    	::GetTokenInformation (tokenHandle,
    			     TokenPrivileges,
    			     pTokens,
    			     cbTokens,
    			     &cbTokens);

    	delete pTokens;
    	::CloseHandle( tokenHandle );
	}

    return stat;
}


/////////////////////////////////////////////////////////////////////////////
//  WinMain


extern "C" INT __cdecl wmain(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    return CVssAdminCLI::Main(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssapi\stdafx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    StdAfx.h

Abstract:

    Precompiled header file.

Author:

    Stefan R. Steiner   [ssteiner]        02-01-2000

Revision History:

	X-3	MCJ		Michael C. Johnson		12-Jun-2000
		Added vswriter.h and vsbackup.h

	X-2	MCJ		Michael C. Johnson		 6-Mar-2000
		Added coord.h and vsevent.h to include list.

--*/

#ifndef __H_STDAFX_
#define __H_STDAFX_

#pragma once

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)
#pragma warning(disable:4201)    // C4201: nonstandard extension used : nameless struct/union

// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#undef _ASSERTE

#include <windows.h>
#include <ntddstor.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <stdlib.h>
#include <comadmin.h>
#include "vs_assert.hxx"

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <stddef.h>
#include <oleauto.h>
#include <atlbase.h>
#include <atlbase.h>
#include <atlconv.h>
extern CComModule _Module;
#include <atlcom.h>

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include <vswriter.h>
#include <vsbackup.h>

#endif // __H_STDAFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssapi\vssapi.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    vssapi.cpp

Abstract:

    Contains the exported DLL functions for VssAPI.dll.
    BUGBUG: Uses code that currently sets the SE handler.  Since the SEH is process
        wide, this can/will effect the user of this DLL.  Need to fix.

Author:

    reuvenl    5/01/2002

Revision History:

	Name		Date			Comments
	reuvenl		5/01/2002	Created from old wrtrshim.cpp
--*/


#include "stdafx.h"


/*
** ATL
*/
CComModule _Module;
#include <atlcom.h>
#include "vs_sec.hxx"
#include "vs_reg.hxx"
#include "ntddsnap.h"


BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "VSSAPICP"

// the name of the Volume Snapshot Service
const LPCWSTR wszVssvcServiceName = L"VSS";

static ULONG		g_ulThreadAttaches             = 0;
static ULONG		g_ulThreadDetaches             = 0;
static CBsCritSec	g_cCritSec;
static GUID		g_guidSnapshotInProgress       = GUID_NULL;

static IVssShim         *g_pIShim = NULL;  //  Used by the simulate functions.  

/*
**++
**
**  Routine Description:
**
**	The DllMain entry point for this DLL.  Note that this must be called by the
**	CRT DLL Start function since the CRT must be initialized.
**
**
**  Arguments:
**	hInstance
**	dwReason
**	lpReserved
**
**
**  Return Value:
**
**	TRUE - Successful function execution
**	FALSE - Error when executing the function
**
**--
*/

BOOL APIENTRY DllMain (IN HINSTANCE hInstance,
		       IN DWORD     dwReason,
		       IN LPVOID    lpReserved)
    {
    BOOL bSuccessful = TRUE;

    UNREFERENCED_PARAMETER (hInstance);
    UNREFERENCED_PARAMETER (lpReserved);



    if (DLL_PROCESS_ATTACH == dwReason)
	{
	try
	    {
	    /*
	    **  Set the correct tracing context. This is an inproc DLL		
	    */
	    g_cDbgTrace.SetContextNum (VSS_CONTEXT_DELAYED_DLL);
	    }

	catch (...)
	    {
	    /*
	    ** Can't trace from here so just ASSERT() (checked builds only)
	    */
	    bSuccessful = FALSE;


	    BS_ASSERT (bSuccessful && "FAILED to initialise tracing sub-system");
	    }
	}


    if (bSuccessful)
	{
	try
	    {
	    switch (dwReason)
		{
		case DLL_PROCESS_ATTACH:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSSAPI,
				  (L"VssAPI: DllMain - DLL_PROCESS_ATTACH called, %s",
				   lpReserved ? L"Static load" : L"Dynamic load"));


		    /*
		    **  Don't need to know when threads start and stop - Wrong
		    **
		    ** DisableThreadLibraryCalls (hInstance);
		    */
		    _Module.Init (ObjectMap, hInstance);

		    break;
    		
	
		case DLL_PROCESS_DETACH:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSSAPI,
				  (L"VssAPI: DllMain - DLL_PROCESS_DETACH called %s",
				   lpReserved ? L"during process termination" : L"by FreeLibrary"));

		       _Module.Term();

		    break;


		case DLL_THREAD_ATTACH:
		    g_ulThreadAttaches++;

		    if (0 == (g_ulThreadAttaches % 1000))
			{
			BsDebugTrace (0,
				      DEBUG_TRACE_VSSAPI,
				      (L"VssAPI: DllMain thread attaches = %u, detaches = %u, outstanding = %u",
				       g_ulThreadAttaches,
				       g_ulThreadDetaches,
				       g_ulThreadAttaches - g_ulThreadDetaches));
			}
		    break;


		case DLL_THREAD_DETACH:
		    g_ulThreadDetaches++;

		    if (0 == (g_ulThreadDetaches % 1000))
			{
			BsDebugTrace (0,
				      DEBUG_TRACE_VSSAPI,
				      (L"VssAPI: DllMain thread attaches = %u, detaches = %u, outstanding = %u",
				       g_ulThreadAttaches,
				       g_ulThreadDetaches,
				       g_ulThreadAttaches - g_ulThreadDetaches));
			}
		    break;


		default:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSSAPI,
				  (L"VssAPI: DllMain got unexpected reason code, lpReserved: %sNULL",
				   dwReason,
				   lpReserved ? L"non-" : L""));
		    break;
		}
	    }


	catch (...)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSSAPI,
				(L"VssAPI: DllMain - Error, unknown exception caught"));

	    bSuccessful = FALSE;
	    }
	}



    return (bSuccessful);
    } /* DllMain () */


/*
**++
**
**  Routine Description:
**
**	The exported function that is called to simulate a snapshot creation to allow
**	backup to drive the shim writers rather than having the snapshot co-ordinator
**	do so.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**	hCompletionEvent	Handle to an event which will be set when the asynchronous freeze completes
**	phrCompletionStatus	Pointer to an HRESULT which will receive the completion status when the
**				asynchronous freeze completes
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer PrepareForFreeze or Freeze functions.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY SimulateSnapshotFreeze (
    IN GUID         guidSnapshotSetId,
    IN ULONG        ulOptionFlags,	
    IN ULONG        ulVolumeCount,	
    IN LPWSTR     *ppwszVolumeNamesArray,
    OUT IVssAsync **ppAsync )							
    {
    CVssFunctionTracer	ft (VSSDBG_VSSAPI, L"VssAPI::SimulateSnapshotFreeze");
    BOOL		bSucceeded;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);
	
        BOOL  bPrivilegesSufficient = FALSE;
	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_VSSAPI,
		    E_ACCESSDENIED,
		    L"FAILED as insufficient privileges to call shim");

        //
        //  Most parameter checks should be done here in the VssApi DLL and not in the
        //  IVssCoordinator::SimulateSnapshotFreeze method since the shim DLL can be
        //  changed independently from the service.  The service is just a forwarding
        //  agent to get SimulateSnapshotFreezeInternal called within one of the
        //  service's threads.
        //

	ft.ThrowIf ((ulOptionFlags & ~VSS_SW_BOOTABLE_STATE) != 0,
		    VSSDBG_VSSAPI,
		    E_INVALIDARG,
		    L"FAILED as illegal option flags set");


	ft.ThrowIf (!((ulOptionFlags & VSS_SW_BOOTABLE_STATE) || (ulVolumeCount > 0)),
		    VSSDBG_VSSAPI,
		    E_INVALIDARG,
		    L"FAILED as need either BootableState or a volume list");


	ft.ThrowIf ((ulVolumeCount > 0) && (NULL == ppwszVolumeNamesArray),
		    VSSDBG_VSSAPI,
		    E_INVALIDARG,
		    L"FAILED as need at least a one volume in the list if not bootable state");


	ft.ThrowIf ((GUID_NULL == guidSnapshotSetId),
		    VSSDBG_VSSAPI,
		    E_INVALIDARG,
		    L"FAILED as supplied SnapshotSetId should not be GUID_NULL");

	ft.ThrowIf ((NULL == ppAsync),
		    VSSDBG_VSSAPI,
		    E_INVALIDARG,
		    L"FAILED as supplied ppAsync parameter is NULL");

        *ppAsync = NULL;

	/*
	** Try to scan all the volume names in an attempt to trigger
	** an access violation to catch it here rather than in an
	** unfortunate spot later on. It also gives us the
	** opportinutiy to do some very basic validity checks.
	*/
	for (ULONG ulIndex = 0; ulIndex < ulVolumeCount; ulIndex++)
	    {
	    ft.ThrowIf (NULL == ppwszVolumeNamesArray [ulIndex],
			VSSDBG_VSSAPI,
			E_INVALIDARG,
			L"FAILED as NULL value in volume array");

	    ft.ThrowIf (wcslen (L"C:") > wcslen (ppwszVolumeNamesArray [ulIndex]),
			VSSDBG_VSSAPI,
			E_INVALIDARG,
			L"FAILED as volume name too short");
	    }

	/*
	** Now we need to connect to the VssSvc service's IVssCoordinator object
	** and make the simulate freeze happen.
	*/
	ft.ThrowIf ( g_pIShim != NULL,
	             VSSDBG_VSSAPI,
	             VSS_E_SNAPSHOT_SET_IN_PROGRESS,
                     L"SimulateSnapshotThaw() must first be called by this process before calling SimulateSnapshotFreeze() again." );

    ft.LogVssStartupAttempt();
    ft.CoCreateInstanceWithLog(
            VSSDBG_VSSAPI,
            CLSID_VSSCoordinator,
            L"Coordinator",
            CLSCTX_ALL,
            IID_IVssShim,
            (IUnknown**)&(g_pIShim));
    ft.CheckForError(VSSDBG_VSSAPI, L"CoCreateInstance( CLSID_VSSCoordinator, IID_IVssShim)");

	BS_ASSERT( g_pIShim != NULL );
	
    g_guidSnapshotInProgress = guidSnapshotSetId;

    /*
    ** Now call the simulate freeze method in the coordinator
    */
    ft.hr = g_pIShim->SimulateSnapshotFreeze(
            guidSnapshotSetId,
            ulOptionFlags,	
            ulVolumeCount,	
            ppwszVolumeNamesArray,
            ppAsync );
    ft.CheckForError(VSSDBG_VSSAPI, L"IVssShim::SimulateSnapshotFreeze()");

	/*
	** The simulate freeze operation is now running in a thread in VssSvc.
	*/
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* SimulateSnapshotFreeze () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to simulate a snapshot thaw to allow
**	backup to drive the shim writers rather than having the snapshot co-ordinator
**	do so.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer Thaw functions.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY SimulateSnapshotThaw (
    IN GUID guidSnapshotSetId )
    {
    CVssFunctionTracer	ft (VSSDBG_VSSAPI, L"VssAPI::SimulateSnapshotThaw");
    BOOL        bPrivilegesSufficient = FALSE;
    HRESULT	hrBootableState       = NOERROR;
    HRESULT	hrSimulateOnly        = NOERROR;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);
	
	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_VSSAPI,
		    E_ACCESSDENIED,
		    L"FAILED as inssuficient privileges to call shim");

	/*
	** We need to make sure a prior SimulateSnapshotFreeze happened.
	*/
	ft.ThrowIf ( g_pIShim == NULL,
	             VSSDBG_VSSAPI,
	             VSS_E_BAD_STATE,
                     L"Called SimulateSnapshotThaw() without first calling SimulateSnapshotFreeze()" );

	ft.ThrowIf ( g_guidSnapshotInProgress != guidSnapshotSetId,
	             VSSDBG_VSSAPI,
	             VSS_E_BAD_STATE,
                     L"Mismatch between guidSnapshotSetId and the one passed into SimulateSnapshotFreeze()" );
	
        /*
        ** Now call the simulate thaw method in the coordinator
        */
        ft.hr = g_pIShim->SimulateSnapshotThaw( guidSnapshotSetId );

        /*
        ** Regardless of the outcome of the SimulateSnapshotThaw, get rid of the shim interface.
        */
        g_pIShim->Release();
        g_pIShim = NULL;
        g_guidSnapshotInProgress = GUID_NULL;

	ft.CheckForError(VSSDBG_VSSAPI, L"IVssShim::SimulateSnapshotThaw()");
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* SimulateSnapshotThaw () */


/*
**++
**
**  Routine Description:
**
**	The exported function that is called to check if a volume is snapshotted
**
**
**  Arguments:
**
**      IN VSS_PWSZ pwszVolumeName      - The volume to be checked.
**      OUT BOOL * pbSnapshotsPresent   - Returns TRUE if the volume is snapshotted.
**
**
**  Return Value:
**
**	Any HRESULT from the IVssCoordinator::IsVolumeSnapshotted.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY IsVolumeSnapshotted (
        IN VSS_PWSZ pwszVolumeName,
        OUT BOOL *  pbSnapshotsPresent,
    	OUT LONG *  plSnapshotCompatibility
        )
{
    CVssFunctionTracer	ft (VSSDBG_VSSAPI, L"VssAPI::IsVolumeSnapshotted");
    BOOL		bPrivilegesSufficient = FALSE;
    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;
    DWORD		dwOldState  = 0;

    try
	{	
	    // Zero out the out parameter
	    ::VssZeroOut(pbSnapshotsPresent);
	    ::VssZeroOut(plSnapshotCompatibility);
	
    	bPrivilegesSufficient = IsProcessAdministrator ();
    	ft.ThrowIf (!bPrivilegesSufficient,
    		    VSSDBG_VSSAPI,
    		    E_ACCESSDENIED,
    		    L"FAILED as insufficient privileges to call shim");

    	ft.ThrowIf ( (pwszVolumeName == NULL) || (pbSnapshotsPresent == NULL) || 
    		         (plSnapshotCompatibility == NULL),
    		    VSSDBG_VSSAPI,
    		    E_INVALIDARG,
    		    L"FAILED as invalid parameters");

    	CBsAutoLock cAutoLock (g_cCritSec);

        //
        //  Check to see if VSSVC is running. If not ,we are supposing that no snapshots are present on the system.
        //

    	// Connect to the local service control manager
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
        if (!shSCManager)
            ft.TranslateGenericError(VSSDBG_VSSAPI, HRESULT_FROM_WIN32(GetLastError()),
                L"OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)");

    	// Get a handle to the service
        shSCService = OpenService (shSCManager, wszVssvcServiceName, SERVICE_QUERY_STATUS);
        if (!shSCService)
            ft.TranslateGenericError(VSSDBG_VSSAPI, HRESULT_FROM_WIN32(GetLastError()),
                L" OpenService (shSCManager, \'%s\', SERVICE_QUERY_STATUS)", wszVssvcServiceName);

    	// Now query the service to see what state it is in at the moment.
        SERVICE_STATUS	sSStat;
        if (!QueryServiceStatus (shSCService, &sSStat))
            ft.TranslateGenericError(VSSDBG_VSSAPI, HRESULT_FROM_WIN32(GetLastError()),
                L"QueryServiceStatus (shSCService, &sSStat)");

        // BUG 250943: Only if the service is running then check to see if there are any snapsnots
        if (sSStat.dwCurrentState == SERVICE_RUNNING) {

            // Create the coordinator interface
        	CComPtr<IVssCoordinator> pCoord;

            // The service is already started, but...
            // We still log here in order to make our code more robust.
            ft.LogVssStartupAttempt();

            // Create the instance.
            ft.CoCreateInstanceWithLog(
                    VSSDBG_VSSAPI,
                    CLSID_VSSCoordinator,
                    L"Coordinator",
                    CLSCTX_ALL,
                    IID_IVssCoordinator,
                    (IUnknown**)&(pCoord));
        	if (ft.HrFailed())
                ft.TranslateGenericError(VSSDBG_VSSAPI, ft.hr, L"CoCreateInstance(CLSID_VSSCoordinator)");
            BS_ASSERT(pCoord);

            // Call IsVolumeSnapshotted on the coordinator
            ft.hr = pCoord->IsVolumeSnapshotted(
                        GUID_NULL,
                        pwszVolumeName,
                        pbSnapshotsPresent,
                        plSnapshotCompatibility);
        }
        else
        {
            // If the service is not running, then try to see if we have only MS Software Provider installed
            
			// Open the "Providers" key. Throw an error if the key does not exist.
            CVssRegistryKey keyProviders;
            if (!keyProviders.Open( HKEY_LOCAL_MACHINE, L"%s\\%s", x_wszVSSKey, x_wszVSSKeyProviders))
                ft.TranslateGenericError(VSSDBG_VSSAPI, ft.hr, L"RegOpenKeyExW(%ld,%s\\%s,...) = ERROR_FILE_NOT_FOUND", 
                    HKEY_LOCAL_MACHINE, x_wszVSSKey, x_wszVSSKeyProviders);
                
            // Attach an enumerator to the subkeys the subkeys 
            CVssRegistryKeyIterator iter;
            iter.Attach(keyProviders);
            BS_ASSERT(!iter.IsEOF());

            // Get the number of subkeys. If different than one, the we sould go with the standard path
            // If it is only one, this is the MS software provider (since it is always registered)
            if (iter.GetSubkeysCount() != 1)
            {
                // Create the instance.
            	CComPtr<IVssCoordinator> pCoord;
                ft.CoCreateInstanceWithLog(
                        VSSDBG_VSSAPI,
                        CLSID_VSSCoordinator,
                        L"Coordinator",
                        CLSCTX_ALL,
                        IID_IVssCoordinator,
                        (IUnknown**)&(pCoord));
            	if (ft.HrFailed())
                    ft.TranslateGenericError(VSSDBG_VSSAPI, ft.hr, L"CoCreateInstance(CLSID_VSSCoordinator)");
                BS_ASSERT(pCoord);

                // Call IsVolumeSnapshotted on the coordinator
                ft.hr = pCoord->IsVolumeSnapshotted(
                            GUID_NULL,
                            pwszVolumeName,
                            pbSnapshotsPresent,
                            plSnapshotCompatibility);
            }
            else
            {
            	// Getting the volume name
            	WCHAR wszVolumeNameInternal[x_nLengthOfVolMgmtVolumeName + 1];
            	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
            			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
            		ft.Throw( VSSDBG_VSSAPI, VSS_E_OBJECT_NOT_FOUND,
            				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
            				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
            	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
            	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));
            	
                // Check if the volume is fixed (i.e. no CD-ROM, no removable)
                UINT uDriveType = ::GetDriveTypeW(wszVolumeNameInternal);
                if ( uDriveType != DRIVE_FIXED) 
                    ft.Throw( VSSDBG_VSSAPI, VSS_E_VOLUME_NOT_SUPPORTED, 
                            L"Encountering a non-fixed volume (%s) - %ud",
                            pwszVolumeName, uDriveType);

                // Open the volume. Throw "object not found" if needed.
            	CVssIOCTLChannel volumeIChannel;	
            	ft.hr = volumeIChannel.Open(ft, wszVolumeNameInternal, true, false, VSS_ICHANNEL_LOG_NONE, 0);
            	if (ft.HrFailed())
                    ft.Throw( VSSDBG_VSSAPI, VSS_E_VOLUME_NOT_SUPPORTED, 
                            L"Volume (%s) not supported for snapshots 0x%08lx",
                            pwszVolumeName, ft.hr);

                // Check to see if there are existing snapshots
            	ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
            	if (ft.HrFailed())
                    ft.Throw( VSSDBG_VSSAPI, VSS_E_VOLUME_NOT_SUPPORTED, 
                            L"Volume (%s) not supported for snapshots 0x%08lx",
                            pwszVolumeName, ft.hr);

            	// Get the length of snapshot names multistring
            	ULONG ulMultiszLen;
            	volumeIChannel.Unpack(ft, &ulMultiszLen);

                // If the multistring is empty, then ulMultiszLen is necesarily 2
                // (i.e. two l"\0' characters)
                // Then mark the volume as snapshotted.
            	if (ulMultiszLen != x_nEmptyVssMultiszLen) 
            	{
            	    (*pbSnapshotsPresent) = TRUE;
                    // Bug 500069: Allow DEFRAG on Babbage snapshotted volumes
            	    (*plSnapshotCompatibility) = (/*VSS_SC_DISABLE_DEFRAG|*/VSS_SC_DISABLE_CONTENTINDEX);
            	}
            }
        }
	} VSS_STANDARD_CATCH (ft);

    // Close handles
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);

    // Convert the "volume not supported into S_OK.
    if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED)
        ft.hr = S_OK;

    return (ft.hr);
} /* IsVolumeSnapshotted () */


/*
**++
**
**  Routine Description:
**
**	This routine is used to free the contents of hte VSS_SNASPHOT_PROP structure
**
**
**  Arguments:
**
**      IN VSS_SNAPSHOT_PROP*  pProp
**
**--
*/

__declspec(dllexport) void APIENTRY VssFreeSnapshotProperties (
        IN VSS_SNAPSHOT_PROP*  pProp
        )
{
    CVssFunctionTracer	ft (VSSDBG_VSSAPI, L"VssAPI::VssFreeSnapshotProperties");

    if (pProp) {
        ::CoTaskMemFree(pProp->m_pwszSnapshotDeviceObject);
        ::CoTaskMemFree(pProp->m_pwszOriginalVolumeName);
        ::CoTaskMemFree(pProp->m_pwszOriginatingMachine);
        ::CoTaskMemFree(pProp->m_pwszServiceMachine);
        ::CoTaskMemFree(pProp->m_pwszExposedName);
        ::CoTaskMemFree(pProp->m_pwszExposedPath);
    }
} /* VssFreeSnapshotProperties () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssapi\vswriter.cpp ===
/*++
Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsWriter.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  02/02/2000

TBD:
    
    Add comments.

Revision History:

    
    Name        Date        Comments
    brianb     03/28/2000   Created
    mikejohn   05/18/2000   ~CVssWriter() should check that wrapper exists
                            before calling it
    mikejohn   06/23/2000   Add external entry point for SetWriterFailure()
    mikejohn   09/01/2000   Add extra tracing to identify writers in trace output
    mikejohn   09/18/2000   176860: Added calling convention methods where missing
    ssteiner   02/14/2001   Changed class interface to version 2.

--*/


#include <stdafx.h>

#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_idl.hxx"
#include "vs_reg.hxx"
#include "comadmin.hxx"
#include "vswriter.h"
#include "vsevent.h"
#include "vsbackup.h"
#include "vswrtimp.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

extern WCHAR g_ComponentMetadataXML[];
static LPCWSTR x_wszElementRoot = L"root";
static LPCWSTR x_wszElementSnapshotSetDescription = L"SNAPSHOT_SET_DESCRIPTION";
static LPCWSTR x_wszAttrSnapshotSetId = L"snapshotSetId";
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssComponentMetadata";
static LPCWSTR x_wszAttrContext = L"context";


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHVWRTC"
//
////////////////////////////////////////////////////////////////////////



static LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
    {
    case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
    case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
    case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
    case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
                    
    default:
        break;
    }


    return (pwszRetString);
    }



static LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
    {
    case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
    case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
    case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

    default:
        break;
    }


    return (pwszRetString);
    }

static LPCWSTR GetStringFromAlternateWriterState (VSS_ALTERNATE_WRITER_STATE aws)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (aws)
    {
    case VSS_AWS_UNDEFINED:                pwszRetString = L"Undefined";                    break;
    case VSS_AWS_NO_ALTERNATE_WRITER:      pwszRetString = L"No alternate writer";          break;
    case VSS_AWS_ALTERNATE_WRITER_EXISTS:  pwszRetString = L"Alternate writer exists";      break;
    case VSS_AWS_THIS_IS_ALTERNATE_WRITER: pwszRetString = L"This is the alternate writer"; break;

    default:
        break;
    }


    return (pwszRetString);
    }
    
static LPCWSTR GetStringFromApplicationLevel (VSS_APPLICATION_LEVEL eApplicationLevel)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eApplicationLevel)
    {
    case VSS_APP_UNKNOWN:   pwszRetString = L"Unknown";   break;
    case VSS_APP_SYSTEM:    pwszRetString = L"System";    break;
    case VSS_APP_BACK_END:  pwszRetString = L"BackEnd";   break;
    case VSS_APP_FRONT_END: pwszRetString = L"FrontEnd";  break;
    case VSS_APP_AUTO:      pwszRetString = L"Automatic"; break;

    default:
        break;
    }


    return (pwszRetString);
    }





// constructor
__declspec(dllexport)
STDMETHODCALLTYPE CVssWriter::CVssWriter() :
    m_pWrapper(NULL)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::CVssWriter");

    ft.Trace(VSSDBG_GEN, L"**** Constructor: THIS = %p", this);
    }

// destructor
__declspec(dllexport)
STDMETHODCALLTYPE CVssWriter::~CVssWriter()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::CVssWriter");
    ft.Trace(VSSDBG_GEN, L"**** Destructor: THIS = %p", this);
    if (NULL != m_pWrapper)
        {
        ft.Trace(VSSDBG_GEN, L"**** Calling CVssWriter::Uninitialize() [%p]", this);
        m_pWrapper->Uninitialize();
#ifdef _DEBUG
        LONG cRef =
#endif
        m_pWrapper->Release();

#ifdef _DEBUG
        ft.Trace(VSSDBG_GEN, L"**** Final reference count for Wrapper = %ld - [%p]", cRef, this);
#endif

//  disable for now
//      BS_ASSERT(cRef == 0);
        }
    }

// default OnPrepareBackup method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPrepareBackup(IN IVssWriterComponents *pComponent)
    {
    UNREFERENCED_PARAMETER(pComponent);

    return true;
    }

// default OnIdentify method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
    {
    UNREFERENCED_PARAMETER(pMetadata);

    return true;
    }

// default OnBackupComplete method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnBackupComplete(IN IVssWriterComponents *pComponent)
    {
    UNREFERENCED_PARAMETER(pComponent);

    return true;
    }

// default OnBackupShutdown method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnBackupShutdown(IN VSS_ID SnapshotSetId)
    {
    UNREFERENCED_PARAMETER(SnapshotSetId);

    return true;
    }

// default OnPreRestore method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPreRestore(IN IVssWriterComponents *pComponent)
    {
    UNREFERENCED_PARAMETER(pComponent);

    return true;
    }

// default OnPostRestore method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPostRestore(IN IVssWriterComponents *pComponent)
    {
    UNREFERENCED_PARAMETER(pComponent);

    return true;
    }

// default OnPostSnapshot method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPostSnapshot(IN IVssWriterComponents *pComponent)
    {
    UNREFERENCED_PARAMETER(pComponent);

    return true;
    }

// default OnBackOffIOOnVolume
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnBackOffIOOnVolume
    (
    IN VSS_PWSZ wszVolumeName,
    IN VSS_ID snapshotId,
    IN VSS_ID providerId
    )
{
    UNREFERENCED_PARAMETER(wszVolumeName);
    UNREFERENCED_PARAMETER(snapshotId);
    UNREFERENCED_PARAMETER(providerId);

    return true;
}

// default OnContinueIOOnVolume
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnContinueIOOnVolume
    (
    IN VSS_PWSZ wszVolumeName,
    IN VSS_ID snapshotId,
    IN VSS_ID providerId
    )
{
    UNREFERENCED_PARAMETER(wszVolumeName);
    UNREFERENCED_PARAMETER(snapshotId);
    UNREFERENCED_PARAMETER(providerId);

    return true;
}

// default OnVSSShutdown
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnVSSShutdown()
{
    return true;
}

// default OnVSSApplicationStartup
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnVSSApplicationStartup()
{
    return true;
}



// initialize the writer
// This function returns S_FALSE when the writer is inactive (setup or safe mode)
__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Initialize
    (
    IN VSS_ID WriterID,
    IN LPCWSTR wszWriterName,
    IN VSS_USAGE_TYPE ut,
    IN VSS_SOURCE_TYPE st,
    IN VSS_APPLICATION_LEVEL nLevel,
    IN DWORD dwTimeoutFreeze,
    IN VSS_ALTERNATE_WRITER_STATE aws,
    IN bool bIOThrottlingOnly,
    IN LPCWSTR wszReserved
    )
    {
    UNREFERENCED_PARAMETER(wszReserved);
	
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Initialize");

    try
        {
        ft.Trace (VSSDBG_SHIM, L"Called CVssWriter::Initialize() with:");
        ft.Trace (VSSDBG_SHIM, L"    WriterId             = " WSTR_GUID_FMT, GUID_PRINTF_ARG (WriterID));
        ft.Trace (VSSDBG_SHIM, L"    WriterName           = %s",      (NULL == wszWriterName) ? L"(NULL)" : wszWriterName);
        ft.Trace (VSSDBG_SHIM, L"    UsageType            = %s",      GetStringFromUsageType (ut));
        ft.Trace (VSSDBG_SHIM, L"    SourceType           = %s",      GetStringFromSourceType (st));
        ft.Trace (VSSDBG_SHIM, L"    AppLevel             = %s",      GetStringFromApplicationLevel (nLevel));
        ft.Trace (VSSDBG_SHIM, L"    FreezeTimeout        = %d (ms)", dwTimeoutFreeze);
        ft.Trace (VSSDBG_SHIM, L"    AlternateWriterState = %s",      GetStringFromAlternateWriterState(aws));
        ft.Trace (VSSDBG_SHIM, L"    IOThrottlingOnly     = %s",      bIOThrottlingOnly ? L"True" : L"False");

        // The V2 parameters can only be set with default values
        if (aws != VSS_AWS_NO_ALTERNATE_WRITER ||
            bIOThrottlingOnly != false)
            return E_INVALIDARG;
        
        if (ut != VSS_UT_BOOTABLESYSTEMSTATE &&
            ut != VSS_UT_SYSTEMSERVICE &&
            ut != VSS_UT_USERDATA &&
            ut != VSS_UT_OTHER)
            return E_INVALIDARG;
// [aoltean] Previous comment was:
// return S_OK for now since there is a bug in the iis writer
//          return S_OK;

        if (st != VSS_ST_NONTRANSACTEDDB &&
            st != VSS_ST_TRANSACTEDDB &&
            st != VSS_ST_OTHER)
            return E_INVALIDARG;
// [aoltean] Previous comment was:
// return S_OK for now since there is a bug in the IIS writer
//          return S_OK;

        CVssWriterImpl::CreateWriter(this, &m_pWrapper);
        BS_ASSERT(m_pWrapper);

        // call Initialize method on core instance
        m_pWrapper->Initialize
            (
            WriterID,
            wszWriterName,
            ut,
            st,
            nLevel,
            dwTimeoutFreeze
            );
        }
    VSS_STANDARD_CATCH(ft)
    return ft.hr;
    }



// This function returns S_FALSE when the writer is inactive (setup or safe mode)
__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Subscribe
    (
    IN DWORD dwEventFlags   
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Subscribe");

    try
        {
        ft.Trace (VSSDBG_GEN, L"**** Called CVssWriter::Subscribe(%p) with:", this);
        ft.Trace (VSSDBG_GEN, L"    dwEventFlags = 0x%08x ", dwEventFlags);
        //  Only the default parameter setting is supported in V1
        if ( dwEventFlags != ( VSS_SM_BACKUP_EVENTS_FLAG | VSS_SM_RESTORE_EVENTS_FLAG ) )
            return E_INVALIDARG;

        if (m_pWrapper == NULL)
            ft.Throw(VSSDBG_GEN, E_FAIL, L"CVssWriter class was not initialized.");

        m_pWrapper->Subscribe();
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

    
// This function returns S_FALSE when the writer is inactive (setup or safe mode)
__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Unsubscribe()
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Unsubscribe");

    try
        {
        if (m_pWrapper == NULL)
            ft.Throw(VSSDBG_GEN, E_FAIL, L"CVssWriter class was not initialized.");

        ft.Trace (VSSDBG_GEN, L"**** Called CVssWriter::Unsubscribe(%p):", this);
        m_pWrapper->Unsubscribe();
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::InstallAlternateWriter
    (
    IN VSS_ID writerId,
    IN CLSID persistentWriterClassId
    )
    {
    UNREFERENCED_PARAMETER(writerId);
    UNREFERENCED_PARAMETER(persistentWriterClassId);

    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::InstallAlternateWriter");

    // Not supported in V1
    ft.hr = E_NOTIMPL;

    return ft.hr;
    }


__declspec(dllexport)
LPCWSTR* STDMETHODCALLTYPE CVssWriter::GetCurrentVolumeArray() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentVolumeArray");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return NULL;
    else
        return m_pWrapper->GetCurrentVolumeArray();
    }

__declspec(dllexport)
UINT STDMETHODCALLTYPE CVssWriter::GetCurrentVolumeCount() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentVolumeCount");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return 0;
    else
        return m_pWrapper->GetCurrentVolumeCount();
    }

__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::GetSnapshotDeviceName
  (
  IN LPCWSTR wszOriginalVolume,
  OUT  LPCWSTR* ppwszSnapshotDevice
  ) const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetSnapshotDeviceName");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return E_FAIL;
    else
        return m_pWrapper->GetSnapshotDeviceName(wszOriginalVolume, ppwszSnapshotDevice);
    }

__declspec(dllexport)
VSS_ID STDMETHODCALLTYPE CVssWriter::GetCurrentSnapshotSetId() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentSnapshotSetId");
    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return GUID_NULL;
    else
        return m_pWrapper->GetCurrentSnapshotSetId();
    }

    __declspec(dllexport)
    LONG STDMETHODCALLTYPE CVssWriter::GetContext() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetContext");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return 0;
    else 
        return m_pWrapper->GetContext();
    }

__declspec(dllexport)
VSS_APPLICATION_LEVEL STDMETHODCALLTYPE CVssWriter::GetCurrentLevel() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentLevel");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return VSS_APP_AUTO;
    else
        return m_pWrapper->GetCurrentLevel();
    }

__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsPathAffected(IN    LPCWSTR wszPath) const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsPathAffected");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return NULL;
    else
        return m_pWrapper->IsPathAffected(wszPath);
    }


// determine if bootable state is backed up
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsBootableSystemStateBackedUp() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsBootableSystemStateBackedUp");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return false;
    else
        return m_pWrapper->IsBootableSystemStateBackedUp();
    }


// determine if bootable state is backed up
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsPartialFileSupportEnabled() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsPartialFileSupportEnabled");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return false;
    else
        return m_pWrapper->IsPartialFileSupportEnabled();
    }


// determine if the backup application is selecting components
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::AreComponentsSelected() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::AreComponentsSelected");
    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return false;
    else
        return m_pWrapper->AreComponentsSelected();
    }

__declspec(dllexport)
VSS_BACKUP_TYPE STDMETHODCALLTYPE CVssWriter::GetBackupType() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetBackupType");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)	
        return VSS_BT_UNDEFINED;
    else
        return m_pWrapper->GetBackupType();
    }

__declspec(dllexport)
VSS_RESTORE_TYPE STDMETHODCALLTYPE CVssWriter::GetRestoreType() const
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetBackupType");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return VSS_RTYPE_UNDEFINED;
    else
        return m_pWrapper->GetRestoreType();	
    }

__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::SetWriterFailure(IN HRESULT hrStatus)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::SetWriterFailure");

    BS_ASSERT(m_pWrapper);
    if (m_pWrapper == NULL)
        return VSS_BT_UNDEFINED;
    else
        return m_pWrapper->SetWriterFailure(hrStatus);
    }

// create backup components
//
// Returns:
//      S_OK if the operation is successful
//      E_INVALIDARG if ppBackup is NULL
//      E_ACCESSDENIED if the caller does not have backup privileges or
//          is an administrator

__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssBackupComponents(IVssBackupComponents **ppBackup)
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CreateVssBackupComponents");

    try
        {
        if (ppBackup == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

        *ppBackup = NULL;

        if (!IsProcessBackupOperator())
            ft.Throw
                (
                VSSDBG_XML,
                E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled"
                );
	
        CComObject<CVssBackupComponents> *pvbc;
        CComObject<CVssBackupComponents>::CreateInstance(&pvbc);
        pvbc->GetUnknown()->AddRef();
        *ppBackup = (IVssBackupComponents *) pvbc;
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }



__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssExamineWriterMetadata
    (
    IN BSTR bstrXML,
    OUT IVssExamineWriterMetadata **ppMetadata
    )
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CreateVssExamineWriterMetadata");

    CVssExamineWriterMetadata *pMetadata = NULL;
    try
        {
        if (ppMetadata == NULL)
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL output pointer");

        *ppMetadata = NULL;
        pMetadata = new CVssExamineWriterMetadata;
        if (pMetadata == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate CVssExamineWriterMetadata");

        if (!pMetadata->Initialize(bstrXML))
            ft.Throw
                (
                VSSDBG_GEN,
                VSS_E_INVALID_XML_DOCUMENT,
                L"XML passed to CreateVssExamineWriterMetdata was invalid"
                );

        *ppMetadata = (IVssExamineWriterMetadata *) pMetadata;
        pMetadata->AddRef();
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        delete pMetadata;

    return ft.hr;
    }

// create a snapshot set description
//
// Returns:
//      S_OK if it is successful
//      E_OUTOFMEMORY if memory could not be allocated

__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssSnapshotSetDescription
    (
    VSS_ID idSnapshotSet,
    LONG lContext,
    OUT IVssSnapshotSetDescription **ppSnapshotSet
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CreateVssSnapshotSsetDescription");

    CVssSnapshotSetDescription *pSnapshotSetTemp = NULL;

    try
        {
        CXMLDocument doc;

        if (ppSnapshotSet == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // intialize document with <root><schema></root>
        doc.LoadFromXML(g_ComponentMetadataXML);

        // find toplevel <root> element
        if (!doc.FindElement(x_wszElementRoot, true))
            ft.Throw(VSSDBG_XML, VSS_E_INVALID_XML_DOCUMENT, L"Missing root element");

        // create BACKUP_COMPONENTS element under <root> element
        CXMLNode nodeRoot(doc.GetCurrentNode(), doc.GetInterface());

        CXMLNode nodeSnapshotSet = doc.CreateNode
            (
            x_wszElementSnapshotSetDescription,
            NODE_ELEMENT
            );

        nodeSnapshotSet.SetAttribute(x_wszAttrSnapshotSetId, idSnapshotSet);
        nodeSnapshotSet.SetAttribute(x_wszAttrContext, lContext);
        nodeSnapshotSet.SetAttribute(x_wszAttrXmlns, x_wszValueXmlns);
        CXMLNode nodeToplevel = nodeRoot.InsertNode(nodeSnapshotSet);
        doc.SetToplevelNode(nodeSnapshotSet);
        pSnapshotSetTemp = new CVssSnapshotSetDescription
                                    (
                                    doc.GetCurrentNode(),
                                    doc.GetInterface()
                                    );

        if (pSnapshotSetTemp == NULL)
            ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Can't allocate snapshot set description.");

        pSnapshotSetTemp->Initialize(ft);

        *ppSnapshotSet = (IVssSnapshotSetDescription *) pSnapshotSetTemp;
        ((IVssSnapshotSetDescription *) pSnapshotSetTemp)->AddRef();
        pSnapshotSetTemp = NULL;
        }
    VSS_STANDARD_CATCH(ft)

    delete pSnapshotSetTemp;

    return ft.hr;
    }

__declspec(dllexport)
HRESULT STDAPICALLTYPE LoadVssSnapshotSetDescription
    (
    IN  LPCWSTR wszXML,
    OUT IVssSnapshotSetDescription **ppSnapshotSet
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"LoadVssSnapshotSetDescription");

    try
        {
        CVssSnapshotSetDescription *pSnapshotSetDescription = new CVssSnapshotSetDescription;
        if (pSnapshotSetDescription == NULL)
            ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate snapshot set description.");

        pSnapshotSetDescription->Initialize(ft);
        pSnapshotSetDescription->LoadFromXML(wszXML);
        ((IVssSnapshotSetDescription *) pSnapshotSetDescription)->AddRef();
        *ppSnapshotSet = (IVssSnapshotSetDescription *) pSnapshotSetDescription;
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vswriter\vswrtimp.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsWrtImp.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  02/02/2000

TBD:

    Add comments.

    Remove the C++ exception-handler related code.

Revision History:

    Name        Date        Comments
    aoltean     02/02/2000  Created
    brianb      03/25/2000  modified to include additional events
    brianb      03/28/2000  modified to include timeouts and sync for OnPrepareBackup
    brianb      03/28/2000  renamed to vswrtimp.cpp to separate internal state from external interface
    brianb      04/19/2000  added security checks
    brianb      05/03/2000  new security model
    brianb      05/09/2000  fix problem with autolocks

--*/


#include <stdafx.hxx>
#include <eventsys.h>

#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_idl.hxx"
#include "vs_reg.hxx"

#include "vscoordint.h"
#include "comadmin.hxx"
#include "vsevent.h"
#include "vswriter.h"
#include "vsbackup.h"
#include "vssmsg.h"

#include "vswrtimp.h"


// xml support
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"



#include "rpcdce.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WRTWRTIC"
//
////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// Constants


const WCHAR g_wszPublisherID[]          = L"VSS Publisher";

// event names
const WCHAR g_wszRequestInfoMethodName[]        = L"RequestWriterInfo";
const WCHAR g_wszPrepareForBackupMethodName[]   = L"PrepareForBackup";
const WCHAR g_wszBackupCompleteMethodName[]     = L"BackupComplete";

const WCHAR g_wszPrepareForSnapshotMethodName[] = L"PrepareForSnapshot";
const WCHAR g_wszFreezeMethodName[]             = L"Freeze";
const WCHAR g_wszThawMethodName[]               = L"Thaw";
const WCHAR g_wszPostSnapshotMethodName[]       = L"PostSnapshot";
const WCHAR g_wszAbortMethodName[]              = L"Abort";

const WCHAR g_wszPreRestoreMethodName[]         = L"PreRestore";
const WCHAR g_wszPostRestoreMethodName[]        = L"PostRestore";
const WCHAR g_wszBackupShutdownName[]                 = L"BackupShutdown";

// List of received volumes is in the following formatDate
// <Volume Name 1>;<Volume Name 2>: ... :<Volume Name N>
const WCHAR VSS_VOLUME_DELIMITERS[] = L";";

// class describing state machine for writer
class CVssWriterImplStateMachine
    {
private:
    // disable default and copy constructors
    CVssWriterImplStateMachine();

public:
    CVssWriterImplStateMachine
        (
        VSS_WRITER_STATE previousState,
        VSS_WRITER_STATE successfulExitState,
        VSS_WRITER_STATE failureExitState,
        bool bBeginningState,
        bool bSuccessiveState,
        bool bResetSequenceOnLeave
        ) :
        m_previousState(previousState),
        m_successfulExitState(successfulExitState),
        m_failureExitState(failureExitState),
        m_bBeginningState(bBeginningState),
        m_bSuccessiveState(bSuccessiveState),
        m_bResetSequenceOnLeave(bResetSequenceOnLeave)
        {
        }

    // previous state writer must be in to enter the current
    // state unless this is the first state of a sequence
    VSS_WRITER_STATE m_previousState;

    // state we are in if the operation is successful
    VSS_WRITER_STATE m_successfulExitState;

    // state we are in if the operation is uncessful
    VSS_WRITER_STATE m_failureExitState;

    // is this state a possible state for the beginning of the sequence
    bool m_bBeginningState;

    // is this a possible non-beginning state in a sequence
    bool m_bSuccessiveState;

    // should the sequence be reset on successful exit of the state
    bool m_bResetSequenceOnLeave;
    };


// definition of state machine
static CVssWriterImplStateMachine s_rgWriterStates[] =
    {
    // OnPrepareBackup
    CVssWriterImplStateMachine
        (
        VSS_WS_STABLE,                      // previous state
        VSS_WS_STABLE,                      // next state if successful
        VSS_WS_FAILED_AT_PREPARE_BACKUP,    // next state if failure
        true,                               // this can be a first state
        false,                              // this must be a first state
        false                               // do not reset sequence on leaving this state
        ),

    // OnPrepareSnapshot
    CVssWriterImplStateMachine
        (
        VSS_WS_STABLE,                      // previous state
        VSS_WS_WAITING_FOR_FREEZE,          // next state if successful
        VSS_WS_FAILED_AT_PREPARE_SNAPSHOT,  // next state if failure
        true,                               // this can be a first state
        true,                               // this can be a follow on state
        false                               // do not reset sequence on leaving this state
        ),


    // OnFreeze
    CVssWriterImplStateMachine
        (
        VSS_WS_WAITING_FOR_FREEZE,          // previous state
        VSS_WS_WAITING_FOR_THAW,            // next state if successful
        VSS_WS_FAILED_AT_FREEZE,            // next state if unsuccessful
        false,                              // this may not be a first state
        true,                               // this must be a follow on state
        false                               // do not reset sequence on leaving this state
        ),

    // OnThaw
    CVssWriterImplStateMachine
        (
        VSS_WS_WAITING_FOR_THAW,            // previous state
        VSS_WS_WAITING_FOR_POST_SNAPSHOT,   // next state if successful
        VSS_WS_FAILED_AT_THAW,              // next state if unsuccessful
        false,                              // this may not be a first state
        true,                               // this must be a follow on state
        false                               // reset sequence on leaving this state
        ),

    // OnPostSnapshot
    CVssWriterImplStateMachine
        (
        VSS_WS_WAITING_FOR_POST_SNAPSHOT,   // previous state
        VSS_WS_WAITING_FOR_BACKUP_COMPLETE, // next state if successful
        VSS_WS_FAILED_AT_POST_SNAPSHOT,     // next state if unsuccessful
        false,                              // this may not be a first state
        true,                               // this must be a follow on state
        true                                // reset sequence on leaving this state
        )


    };

// state ids
static const unsigned s_ivwsmPrepareForBackup = 0;
static const unsigned s_ivwsmPrepareForSnapshot = 1;
static const unsigned s_ivwsmFreeze = 2;
static const unsigned s_ivwsmThaw = 3;
static const unsigned s_ivwsmPostSnapshot = 4;



/////////////////////////////////////////////////////////////////////////////
// CVssWriterImpl constructors/destructors


// constructor
CVssWriterImpl::CVssWriterImpl():
    m_bInitialized(false),
    m_writerstate(m_diag),
    m_WriterID(GUID_NULL),
    m_InstanceID(GUID_NULL),
    m_usage(VSS_UT_UNDEFINED),
    m_source(VSS_ST_UNDEFINED),
    m_nLevel(VSS_APP_FRONT_END),
    m_dwTimeoutFreeze(VSS_TIMEOUT_FREEZE),
    m_CurrentSnapshotSetId(GUID_NULL),
    m_lContext(VSS_CTX_BACKUP),
    m_nVolumesCount(0),
    m_ppwszVolumesArray(NULL),
    m_pwszLocalVolumeNameList(NULL),
    m_dwEventMask(0),
    m_wszWriterName(NULL),
    m_hevtTimerThread(NULL),
    m_hmtxTimerThread(NULL),
    m_hThreadTimerThread(NULL),
    m_bLocked(false),
    m_bLockCreated(false),
    m_command(VSS_TC_UNDEFINED),
    m_cbstrSubscriptionId(0),
    m_bOnAbortPermitted(false),
    m_bSequenceInProgress(false),
    m_pWriter(NULL),
    m_bBootableSystemStateBackup(false),
    m_bComponentsSelected(false),
    m_backupType(VSS_BT_UNDEFINED),
    m_restoreType(VSS_RTYPE_UNDEFINED),
    m_bPartialFileSupport(false),
    m_bInSafeMode(false),
    m_bInSetup(false)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::CVssWriterImpl");
    ft.Trace( VSSDBG_WRITER, L"*** Constructing object %p", this);
    }

// destructor
CVssWriterImpl::~CVssWriterImpl()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::~CVssWriterImpl");
    ft.Trace( VSSDBG_WRITER, L"*** Destructing object %p", this);
    Uninitialize();
    }

void CVssWriterImpl::Uninitialize()
    {

    if (!m_bInitialized) 
        return;
    
    // terminate timer thread if it is still running
    if (m_bLockCreated)
        {
        if (m_bstrSubscriptionName.Length() > 0)
            {
            try
                {
                Unsubscribe();
                }
            catch(...)
                {
                }
            }

        Lock();
        TerminateTimerThread();
        Unlock();
        m_cs.Uninit();
        m_bLockCreated = false;
        }

    // delete volume array
    delete[] m_ppwszVolumesArray;
    m_ppwszVolumesArray = NULL;

    // delete volume list string
    ::VssFreeString(m_pwszLocalVolumeNameList);

    // delete writer name
    free(m_wszWriterName);
    m_wszWriterName = NULL;


    if (m_hevtTimerThread)
        {
        CloseHandle(m_hevtTimerThread);
        m_hevtTimerThread = NULL;
        }

    if (m_hmtxTimerThread)
        {
        CloseHandle(m_hmtxTimerThread);
        m_hmtxTimerThread = NULL;
        }
    }

    // get the snapshot device name for a particular volume
HRESULT CVssWriterImpl::GetSnapshotDeviceName
        (
        LPCWSTR wszOriginalVolume,
        LPCWSTR* ppwszSnapshotDevice
        ) const
    	{
    	UNREFERENCED_PARAMETER(wszOriginalVolume);
	UNREFERENCED_PARAMETER(ppwszSnapshotDevice);

	return E_NOTIMPL;
    	}
	
// create an event
void CVssWriterImpl::SetupEvent(IN HANDLE *phevt)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImple::SetupEvent");

    BS_ASSERT(phevt);
    // setup events as enabled and manual reset
    *phevt = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (*phevt == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failure to create event object due to error %d.",
            GetLastError()
            );
    }


// initialize writer object
// This function returns S_FALSE when the writer is inactive (setup or safe mode)
void CVssWriterImpl::Initialize
    (
    IN VSS_ID WriterID,             // writer class id
    IN LPCWSTR wszWriterName,       // friendly name of writer
    IN VSS_USAGE_TYPE usage,        // usage type
    IN VSS_SOURCE_TYPE source,      // data source type
    IN VSS_APPLICATION_LEVEL nLevel, // which freeze event this writer handles
    IN DWORD dwTimeoutFreeze         // timeout between freeze and thaw
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Initialize");

    // validate that the writer is initialized
    if (m_bInitialized)
        ft.Throw
            (
            VSSDBG_WRITER,
            VSS_E_BAD_STATE,
            L"You cannot initialize the writer twice"
            );

    // determine if we are in setup.  If we are then reject the
    // initialize call and log an error in the application log
    m_bInSetup = CVssMachineInformation::IsDuringSetup();
    if (m_bInSetup)
    {
        ft.LogError(VSS_ERROR_SETUP_WRITER, VSSDBG_WRITER << wszWriterName << WriterID );
        ft.Throw(VSSDBG_WRITER, S_FALSE, L"Calling Initialize during setup");
    }

    // determine if we are in safe mode.  If we are then reject the
    // initialize call and log an error in the application log
    m_bInSafeMode = CVssMachineInformation::IsDuringSafeMode();
    if (m_bInSafeMode)
    {
        ft.LogError(VSS_ERROR_SAFE_MODE_WRITER, VSSDBG_WRITER << wszWriterName << WriterID );
        ft.Throw(VSSDBG_WRITER, S_FALSE, L"Calling Initialize during safe mode");
    }

    // Initialize the list of possible SIDs from registry
    m_SidCollection.Initialize();

    // Check if the writer runs under a proper user
    if (!m_SidCollection.IsProcessValidWriter())
    {
        ft.LogError(VSS_ERROR_NON_PRIVILEGED_WRITER, VSSDBG_WRITER << wszWriterName << WriterID );
        ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Writer is not privileged");
    }

    // Testing arguments validity
    if (wszWriterName == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_INVALIDARG,
            L"NULL writer name"
            );

    switch(nLevel) {
    case VSS_APP_SYSTEM:
    case VSS_APP_BACK_END:
    case VSS_APP_FRONT_END:
        break;
    default:
        ft.Throw
            (
            VSSDBG_WRITER,
            E_INVALIDARG,
            L"Invalid app level %d", nLevel
            );
    }

    m_cs.Init();  // Warning - may throw NT exceptions...
    m_bLockCreated = true;

    // initialize writer state
    m_writerstate.Initialize();

    // save writer class id
    m_WriterID = WriterID;

    // save writer name
    m_wszWriterName = _wcsdup(wszWriterName);
    if (m_wszWriterName == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot allocate writer name"
            );

    // save usage type
    m_usage = usage;

    // save source type
    m_source = source;

    // create guid for this instance
    ft.hr = ::CoCreateGuid(&m_InstanceID);
    ft.CheckForError(VSSDBG_WRITER, L"CoCreateGuid");
    ft.Trace
        (
        VSSDBG_WRITER,
        L"     InstanceId for Writer %s is" WSTR_GUID_FMT,
        m_wszWriterName,
        GUID_PRINTF_ARG(m_InstanceID)
        );

    // save app level
    m_nLevel = nLevel;

    // save timeout
    m_dwTimeoutFreeze = dwTimeoutFreeze;

    // setup thread mutex
    m_hmtxTimerThread = CreateMutex(NULL, FALSE, NULL);
    if (m_hmtxTimerThread == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failure to create mutex object due to error %d.",
            GetLastError()
            );

    // setup event used to control the timer thread
    SetupEvent(&m_hevtTimerThread);

    // Initialize the diagnose tool
    m_diag.Initialize(m_wszWriterName);

    // Mark the writer as initialized
    m_bInitialized = true;
    }

// start a sequence
// critical section (m_cs) must be locked upone entry to this routine
void CVssWriterImpl::BeginSequence
    (
    IN CVssID &SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::BeginSequence");

    AssertLocked();

    // terminate timer thread if it is still operating
    TerminateTimerThread();

    // setup current snapshot set id
    m_CurrentSnapshotSetId = SnapshotSetId;

    BS_ASSERT(m_bOnAbortPermitted == false);

    // initialize writer state for this snapshot set
    m_writerstate.InitializeCurrentState(SnapshotSetId);

    // indicate we are currently in a snapshot sequence.
    m_bSequenceInProgress = true;
    }





//  Reset the sequence-related data members
// critical section must be locked prior to entering this state
void CVssWriterImpl::ResetSequence(bool bCalledFromTimerThread)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::ResetSequence");

    AssertLocked();

    // save current state to stack of previous snapshot set states
    m_writerstate.PushCurrentState();

    // indicate we are no longer within a sequence
    m_bSequenceInProgress = false;

    // abort is no longer permitted
    m_bOnAbortPermitted = false;

    // reset volumes array
    m_nVolumesCount = 0;
    delete[] m_ppwszVolumesArray;
    m_ppwszVolumesArray = NULL;

    ::VssFreeString(m_pwszLocalVolumeNameList);

    m_CurrentSnapshotSetId = GUID_NULL;

    // if bCalledFromTimerThread is true, this means that the timer
    // thread is causing the sequence to be reset.  We are in the timer
    // thread already and it will terminate upon completion of this call
    // so we shouldn't try causing it to terminate again.
    if (!bCalledFromTimerThread)
        TerminateTimerThread();

    }

// indicate why the writer failed
HRESULT CVssWriterImpl::SetWriterFailure(HRESULT hr)
    {
    // validate failure is one that is allowed
    if (hr != VSS_E_WRITERERROR_TIMEOUT &&
        hr != VSS_E_WRITERERROR_RETRYABLE &&
        hr != VSS_E_WRITERERROR_NONRETRYABLE &&
        hr != VSS_E_WRITERERROR_OUTOFRESOURCES &&
        hr != VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT)
        return E_INVALIDARG;

    // set failure
    m_writerstate.SetCurrentFailure(hr);
    return S_OK;
    }



// determine if path specified is on one of the volumes that is snapshot
bool CVssWriterImpl::IsPathAffected
    (
    IN  LPCWSTR wszPath
    ) const
    {
    // Test the status
    if (!m_bSequenceInProgress)
        return false;

    // check for empty volume count
    if (m_nVolumesCount == 0)
        return false;

    // Get the volume mount point
    WCHAR wszVolumeMP[MAX_PATH];
    BOOL bRes = ::GetVolumePathNameW(wszPath, wszVolumeMP, MAX_PATH);
    if (!bRes)
        return false;

    // Get the volume name
    WCHAR wszVolumeName[MAX_PATH];
    bRes = ::GetVolumeNameForVolumeMountPointW(wszVolumeMP, wszVolumeName, MAX_PATH);
    if (!bRes)
        return false;

    // Search to see if that volume is within snapshotted volumes
    for (int nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
        {
        BS_ASSERT(m_ppwszVolumesArray[nIndex]);
        if (::wcscmp(wszVolumeName, m_ppwszVolumesArray[nIndex]) == 0)
            return true;
        }

    return false;
    }


// obtain IVssWriterCallback from IDispatch pointer
// caller is responsible for releasing interface that is returned
void CVssWriterImpl::GetCallback
    (
    IN IDispatch *pWriterCallback,
    OUT IVssWriterCallback **ppCallback,
    IN BOOL bAllowImpersonate
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::GetCallback");

    // check that pointer is supplied
    BS_ASSERT(pWriterCallback != NULL);

    // try QueryInterface for IVssWriterCallback interface
    ft.hr = pWriterCallback->SafeQI(IVssWriterCallback, ppCallback);
    if (FAILED(ft.hr))
    {
        // If this is a RPC error then the 
        // requestor might died in the meantime (bug 526472)
        if (ft.HrInFacility(FACILITY_RPC))
        {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);

            ft.LogError(VSS_ERROR_RPC_IVSSWRITERCALLBACK, VSSDBG_WRITER << ft.hr);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Error querying for IVssWriterCallback interface.  hr = 0x%08lx",
                ft.hr
                );
        }   
        else // this is a different failure
        {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            ft.LogError(VSS_ERROR_QI_IVSSWRITERCALLBACK, VSSDBG_WRITER << ft.hr);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Error querying for IVssWriterCallback interface.  hr = 0x%08lx",
                ft.hr
                );
        }
    }

    if ( !bAllowImpersonate )
    {
        ft.hr = CoSetProxyBlanket
                    (
                    *ppCallback,
                    RPC_C_AUTHN_DEFAULT,
                    RPC_C_AUTHZ_DEFAULT,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IDENTIFY,
                    NULL,
                    EOAC_NONE
                    );

        // note E_NOINTERFACE means that the pWriterCallback is a in-proc callback
        // and there is no proxy
        if (FAILED(ft.hr) && ft.hr != E_NOINTERFACE)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            ft.LogError(VSS_ERROR_BLANKET_FAILED, VSSDBG_WRITER << ft.hr);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Call to CoSetProxyBlanket failed.  hr = 0x%08lx", ft.hr
                );
            }
        }
    }

// create basic writer metadata for OnIdentify method
CVssCreateWriterMetadata *CVssWriterImpl::CreateBasicWriterMetadata()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::CreateBasicWriterMetadata");

    // create object supporting IVssCreateMetadata interface
    CVssCreateWriterMetadata *pMetadata = new CVssCreateWriterMetadata;
    if (pMetadata == NULL)
        {
        // indicate we failed due to an out of resources failure
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot create CVssCreateWriterMetadata due to allocation failure."
            );
        }


    // call initialize to create IDENTIFICATION section
    ft.hr = pMetadata->Initialize
                    (
                    m_InstanceID,
                    m_WriterID,
                    m_wszWriterName,
                    m_usage,
                    m_source
                    );

    if (ft.HrFailed())
        {
        // indicate that we failed due to an out of resources failure
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
        delete pMetadata;
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"CVssCreateWriterMetadata::Initialize failed. hr = 0x%08lx",
            ft.hr
            );
        }


    // return object
    return pMetadata;
    }

static LPCWSTR x_wszElementRoot = L"root";
static LPCWSTR x_wszElementWriterComponents = L"WRITER_COMPONENTS";

// get writer components for OnPrepareBackup, OnBackupComplete, and OnPostRestore
// methods
void CVssWriterImpl::InternalGetWriterComponents
    (
    IN IVssWriterCallback *pCallback,
    OUT IVssWriterComponentsInt **ppWriter,
    IN bool bWriteable,
    IN bool bInRestore
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::InternalGetWriterComponents");

    BS_ASSERT(pCallback);
    BS_ASSERT(ppWriter);

    *ppWriter = NULL;

    // call GetContent callback method on the backup application
    CComBSTR bstrId(bInRestore ? m_WriterID : m_InstanceID);
    if (!bstrId)
        {
        // indicate we failed due to an out of resources failure
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot allocate instance Id string"
            );
        }

    ft.hr = pCallback->GetBackupState
        (
        &m_bBootableSystemStateBackup,
        &m_bComponentsSelected,
        &m_backupType,
        &m_bPartialFileSupport,
        &m_lContext
        );

    if (ft.HrFailed())
        {
        // if GetBackupState failed assumed that it might work if the
        // backup is retried.
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"IVssWriterCallback::GetBackupState failed.  hr = 0x%08lx",
            ft.hr
            );
        }
	
	ft.hr = pCallback->GetRestoreState
	   (
	   &m_restoreType
	   );

    if (ft.HrFailed())
        {
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"IVssWriterCallback::GetRestoreState failed.  hr = 0x%08lx",
            ft.hr
            );
        }


    CComBSTR bstrWriterComponentsDoc;
    ft.hr = pCallback->GetContent(bstrId, &bstrWriterComponentsDoc);

    if (ft.HrFailed())
        {
        // if GetContent failed assume that the backup might work if
        // the backup was retried
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"Cannot get WRITER_COMPONENTS document.  hr = 0x%08lx",
            ft.hr
            );
        }

    if (ft.hr == S_FALSE)
        {
        // reset status code
        ft.hr = S_OK;
        *ppWriter = (IVssWriterComponentsInt *) new CVssNULLWriterComponents
                                (
                                m_InstanceID,
                                m_WriterID
                                );

        if (*ppWriter == NULL)
            {
            // indicate that the writer failed due to an out of resources condition
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw (VSSDBG_WRITER, E_OUTOFMEMORY, L"Can't allocate CVssWriterComponents object");
            }

        (*ppWriter)->AddRef();
        }

    else
        {
        CXMLDocument doc;
        if (!doc.LoadFromXML(bstrWriterComponentsDoc) ||
            !doc.FindElement(x_wszElementRoot, true))
            {
            // if the XML document is not valid then assume that the backup
            // application is broken.  The backup should not be retried.

            
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.LogError(VSS_ERROR_WRITER_COMPONENTS_CORRUPT, VSSDBG_WRITER);
            ft.Throw
                (
                VSSDBG_WRITER,
                VSS_E_CORRUPT_XML_DOCUMENT,
                L"Internally transferred WRITER_COMPONENTS document is invalid"
                );
            }

        doc.SetToplevel();

        *ppWriter = (IVssWriterComponentsInt *)
                        new CVssWriterComponents
                            (
                            doc.GetCurrentNode(),
                            doc.GetInterface(),
                            bWriteable,
                            false,
                            m_writerstate.IsInRestore()
                            );

        if (*ppWriter == NULL)
            {
            // indicate that the writer failed due to an out of resources condition
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw (VSSDBG_WRITER, E_OUTOFMEMORY, L"Can't allocate CVssWriterComponents object");
            }

        (*ppWriter)->AddRef();
        ft.hr = (*ppWriter)->Initialize(true);
        if (ft.HrFailed())
            {
            // if Initialize failed, assume that the failure is due to an
            // out of resources conditition.
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            (*ppWriter)->Release();
            *ppWriter = NULL;
            ft.Throw
                (
                VSSDBG_WRITER,
                ft.hr,
                L"Failed to initialize WRITER_COMPONENTS document.  hr = 0x%08lx",
                ft.hr
                );
            }
        }
    }


// called when entering a state to verify whether this state can be
// validly entered and generate appropriate error if not.
// this routine always obtains the critical section.  If this routine
// is called then LeaveState must also be called in order to free the
// critical section.
bool CVssWriterImpl::EnterState
    (
    IN const CVssWriterImplStateMachine &vwsm,
    IN BSTR bstrSnapshotSetId
    ) throw(HRESULT)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::EnterState");

    CVssID id;

    // obtain lock just in case next call throws
    // no matter how this routine exits, the critical section must be locked
    Lock();

    // initialize id to snapshot set id
    id.Initialize(ft, (LPWSTR)bstrSnapshotSetId, E_OUTOFMEMORY);

    // Note:
    // 1. There is no check for fail-at-identify because if the writer failed at Identify,
    // then the writer won't get anymore events from the requestor object that sent the identify
    // 2. Other backup sequences should not be disturbed by a writer failing at identify
    // for another requestor

    if (!m_bSequenceInProgress)
        {
        if (!vwsm.m_bBeginningState)
            // not a beginning state.  Sequence must have been
            // interrupted.
            return false;
        else
            {
            // BUG 219757 - PrepareForSnapshot, etc. cannot be
            // called for the same Snapshot Set if PrepareForBackup failed
            // Also we assume here that each new sequence have an UNIQUE SSID.

            // This check is needed since the PrepareForBackup phase is optional
            // and can be skipped sometimes. Therefore we need to distinguish between
            // the case when PrepareForBackup was skipped and the case when PrepareForBackup
            // was called and failed.

            // Search for a previous sequence with the same Snapshot Set ID.
            // If found (this means that a PrepareForBackup was called),
            // then reject the call.
            if (m_writerstate.IsSnapshotSetIdValid(id))
                return false;

            // it is a beginning state, start the sequence
            BeginSequence(id);
            return true;
            }
        }
    else
        {
        if (vwsm.m_bSuccessiveState)
            {
            // it is a valid non-beginning state in the sequence
            if (id != m_CurrentSnapshotSetId)
                {
                // if snapshot set id doesn't match and this is not
                // a beginning state, then the event must be ignored.
                // We must have aborted the sequence it references.
                if (!vwsm.m_bBeginningState)
                    return false;
                }
            else
                {
                // make sure current state matches previous state
                // of state we are about to enter
                return m_writerstate.GetCurrentState() == vwsm.m_previousState;
                }
            }
        }

    // We are trying to start a new sequence.
    // This means that the previous sequence was not properly
    // terminated.  Abort the previous sequence and then
    // start a new one.
    ft.Trace(VSSDBG_WRITER,
        L"*** Warning ***: Writer %s with ID "WSTR_GUID_FMT
        L"attempts to reset the previous sequence with Snapshot Set ID "WSTR_GUID_FMT
        L". Current state = %d",
        m_wszWriterName, GUID_PRINTF_ARG(m_InstanceID), GUID_PRINTF_ARG(m_CurrentSnapshotSetId), (INT)m_writerstate.GetCurrentState());

    DoAbort(false);
    BeginSequence(id);
    return true;
    }

// do abort on failure of the sequence
// critical section must be locked prior to entering this state
void CVssWriterImpl::DoAbort
    (
    IN bool bCalledFromTimerThread,
    IN  BSTR    bstrSnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::DoAbort");

    AssertLocked();
    // do nothing if in a sequence
    if (!m_bSequenceInProgress)
        return;

    BS_ASSERT(m_pWriter);

    // catch any exceptions so that we properly reset the
    // sequence
    try
        {
        // if the snapshot set doesn't match, don't allow an abort
	   if (bstrSnapshotSetId)	
	   	{
	   	CVssID id;
	   	id.Initialize(ft, bstrSnapshotSetId, E_OUTOFMEMORY);
	   	if (id != m_writerstate.GetCurrentSnapshotSet())
	   		return;
	   	}
	   
        // call writer's abort function (depending on the state)
        switch(m_writerstate.GetCurrentState())
            {
            default:
                // Unhandled state?
                BS_ASSERT(false);
                break;
                
            case VSS_WS_FAILED_AT_BACKUP_COMPLETE:
            case VSS_WS_FAILED_AT_PRE_RESTORE:
            case VSS_WS_FAILED_AT_POST_RESTORE:
                // Abort not permitted on these states
                BS_ASSERT(m_bOnAbortPermitted == false);
                break;
                
            case VSS_WS_STABLE:
                // This is possible since you may get an Abort
                // in (or after) PrepareForBackup (BUG # 301686)
                BS_ASSERT(m_bOnAbortPermitted == true);
                break;

            case VSS_WS_WAITING_FOR_POST_SNAPSHOT:
            case VSS_WS_FAILED_AT_POST_SNAPSHOT:
            case VSS_WS_WAITING_FOR_FREEZE:
            case VSS_WS_WAITING_FOR_THAW:
            case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
            case VSS_WS_FAILED_AT_THAW:
            case VSS_WS_FAILED_AT_PREPARE_BACKUP:
            case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
            case VSS_WS_FAILED_AT_FREEZE:
                
                // Fixing bug 225936
                if (m_bOnAbortPermitted)
                    m_pWriter->OnAbort();
                else
                    ft.Trace(VSSDBG_WRITER, L"Abort skipped in state %d", m_writerstate.GetCurrentState());
                m_bOnAbortPermitted = false;
                break;
            }
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Trace
            (
            VSSDBG_WRITER,
            L"OnAbort failed. hr = 0x%08lx",
            ft.hr
            );

    // set appropriate failure state
    switch(m_writerstate.GetCurrentState())
        {
        default:
            m_writerstate.SetCurrentState(VSS_WS_UNKNOWN);
            BS_ASSERT(false);
            break;

        case VSS_WS_FAILED_AT_PREPARE_BACKUP:
        case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
        case VSS_WS_FAILED_AT_FREEZE:
        case VSS_WS_FAILED_AT_THAW:
        case VSS_WS_FAILED_AT_POST_SNAPSHOT:
        case VSS_WS_FAILED_AT_BACKUP_COMPLETE:
        case VSS_WS_FAILED_AT_PRE_RESTORE:
        case VSS_WS_FAILED_AT_POST_RESTORE:
            // don't change state if already in a failure state
            break;

        case VSS_WS_STABLE:
            // if current state is STABLE then it means
            // we were in PrepareBackup
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_PREPARE_BACKUP);
            break;

        case VSS_WS_WAITING_FOR_FREEZE:
            // if we were waiting for freeze then we failed
            // between PrepareSync and Freeze
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_PREPARE_SNAPSHOT);
            break;

        case VSS_WS_WAITING_FOR_THAW:
            // if we were waiting for thaw then we failed
            // between freeze and thaw
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_FREEZE);
            break;

        case VSS_WS_WAITING_FOR_POST_SNAPSHOT:
            // if we were waiting for completion then
            // we failed after thaw.
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_THAW);
            break;
            
        case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
            // if we were waiting for completion then
            // we failed after thaw.
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_POST_SNAPSHOT);
            break;

        }

    if (bCalledFromTimerThread && m_writerstate.GetCurrentFailure() == S_OK)
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_TIMEOUT);

    // reset sequence
    ResetSequence(bCalledFromTimerThread);
    }

// exit a state.  This routine must be called with the critical
// section acquired.  For a state, EnterState is called first, then work is
// done, then LeaveState is called.  This routine will set the state upon
// exit and possibly reset the snapshot sequence if we are at the end of the
// sequence or the sequence is aborted.
void CVssWriterImpl::LeaveState
    (
    IN const CVssWriterImplStateMachine &vwsm,  // current state
    IN bool bSucceeded                          // did operation succeed
    )
    {
    AssertLocked();

    m_writerstate.ExitOperation();

    // don't change state or call abort if we are not in a sequence
    if (m_bSequenceInProgress)
        {
        m_writerstate.SetCurrentState
            (bSucceeded ? vwsm.m_successfulExitState
                        : vwsm.m_failureExitState);

        // call abort on failure when we are not in the exit state
        if ((!bSucceeded || m_writerstate.GetCurrentFailure() == VSS_E_WRITER_NOT_RESPONDING) &&
            !vwsm.m_bResetSequenceOnLeave)
            DoAbort(false);
        else if (vwsm.m_bResetSequenceOnLeave)
            // if sequence ends at this state (THAW) then
            // reset variables
            ResetSequence(false);
        }

    Unlock();
    }



// arguments to timer function
class CVssTimerArgs
    {
private:
    CVssTimerArgs();

public:
    CVssTimerArgs(CVssWriterImpl *pWriter, VSS_ID id) :
        m_snapshotSetId(id),
        m_pWriter(pWriter)
        {
        }

    // snapshot set that we are monitoring
    VSS_ID m_snapshotSetId;

    // pointer to writer
    CVssWriterImpl *m_pWriter;
    };


// timer thread startup routine
DWORD CVssWriterImpl::StartTimerThread(void *pv)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::StartTimerThread");
    CVssTimerArgs *pArgs = (CVssTimerArgs *) pv;
    BS_ASSERT(pArgs);
    BS_ASSERT(pArgs->m_pWriter);

    bool bCoInitializeSucceeded = false;
    try
        {
        // coinitialize thread

        ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (ft.HrFailed())
            {
            pArgs->m_pWriter->m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.TranslateError
                (
                VSSDBG_WRITER,
                ft.hr,
                L"CoInitializeEx"
                );
            }

        bCoInitializeSucceeded = true;
        // call timer func
        pArgs->m_pWriter->TimerFunc(pArgs->m_snapshotSetId);
        }
    VSS_STANDARD_CATCH(ft)

    if (bCoInitializeSucceeded)
        CoUninitialize();

    // delete timer arguments
    delete pArgs;
    return 0;
    }



// function implementing timer functionality
void CVssWriterImpl::TimerFunc(VSS_ID snapshotSetId)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::TimerFunc");

    // wait on event to insure that only one timer is active at
    // any point in time
    if (WaitForSingleObject(m_hmtxTimerThread, INFINITE) == WAIT_FAILED)
        {
        DWORD dwErr = GetLastError();
        ft.Trace(VSSDBG_WRITER, L"WaitForSingleObject failed with error %d", dwErr);
        BS_ASSERT(FALSE && "WaitForSingleObject failed");
        }

    // reset timer event
    if (!ResetEvent(m_hevtTimerThread))
        {
        DWORD dwErr = GetLastError();
        ft.Trace(VSSDBG_WRITER, L"ResetEvent failed with error %d", dwErr);
        BS_ASSERT(FALSE && "ResetEvent failed");
        }

    Lock();

    CVssAutoDiagLogger logger(m_writerstate, VSS_IN_BKGND_FREEZE_THREAD, snapshotSetId);
    
    // make sure that we are still in a snapshot sequence
    if (!m_bSequenceInProgress || snapshotSetId != GetCurrentSnapshotSetId())
        {
        // not in sequence, exit function
        Unlock();
        // allow another timer thread to start
        ReleaseMutex(m_hmtxTimerThread);
        return;
        }

    // initial command is to abort the current sequence on timeout
    m_command = VSS_TC_ABORT_CURRENT_SEQUENCE;

    Unlock();
    DWORD dwTimeout = m_dwTimeoutFreeze;

    if (WaitForSingleObject(m_hevtTimerThread, dwTimeout) == WAIT_FAILED)
        {
        ft.Trace
            (
            VSSDBG_WRITER,
            L"Wait in timer thread failed due to reason %d.",
            GetLastError()
            );

        // allow another thread to start
        ReleaseMutex(m_hmtxTimerThread);
        return;
        }

    CVssWriterImplLock lock(this);
    if (m_command != VSS_TC_TERMINATE_THREAD)
        {
        BS_ASSERT(m_command == VSS_TC_ABORT_CURRENT_SEQUENCE);

        // cause current sequence to abort
        ft.Trace(VSSDBG_WRITER, L"Aborting due to timeout\n");
        DoAbort(true);
        }

    // allow another timer thread to start
    ReleaseMutex(m_hmtxTimerThread);
    }



/////////////////////////////////////////////////////////////////////////////
// IVssWriter implementation


STDMETHODIMP CVssWriterImpl::RequestWriterInfo
    (
    IN      BSTR bstrSnapshotSetId,
    IN      BOOL bWriterMetadata,
    IN      BOOL bWriterState,
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::RequestWriterInfo" );


    // created metadata, deleted on exit from routine
    CVssCreateWriterMetadata *pcwm = NULL;
    try
        {
        // validate that the flags make sense
        if (bWriterMetadata && bWriterState ||
            !bWriterMetadata && !bWriterState)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"Incorrect flags");

        // if we are requesting writer state then we must have a snapshot
        // set id
        if (bWriterState && bstrSnapshotSetId == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

        if (pWriterCallback == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

        if (!IsBackupOperator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");

    _retry_OnIdentify:
    
        if (bWriterMetadata)
            {
            
            // obtain writer metadata
            
            // First, we prevent OnIdentify to be issued between Freeze and Thaw
            DWORD dwTimeout = m_dwTimeoutFreeze;
            if (WaitForSingleObject(m_hevtTimerThread, dwTimeout) == WAIT_FAILED)
                ft.Trace(VSSDBG_WRITER,L"Wait failed due to reason %d.",GetLastError());

            // MTA synchronization: The critical section will be left automatically 
            // at the end of scope.
            CVssWriterImplLock lock(this);

            // Still, do not allow OnIdentify to be called between Freeze and Thaw 
            // - There is an extremely small window where Freeze can be send after 
            // WaitForSingleObject test passed but before acquiring the lock
            VSWRITER_STATE state;
            m_writerstate.GetStateForSnapshot(GUID_NULL, state);

            // A writer cannot stay forever in this state... 
            // (the background timer thread will reset the current VSS_WS_WAITING_FOR_THAW state)
            if ((state.m_state == VSS_WS_WAITING_FOR_THAW) && 
                (state.m_idSnapshotSet != GUID_NULL))
                goto _retry_OnIdentify;

            CVssAutoDiagLogger logger(m_writerstate, VSS_IN_IDENTIFY);

            try
                {
                // get IVssWriterCallback interface
                CComPtr<IVssWriterCallback> pCallback;
                GetCallback(pWriterCallback, &pCallback);


                // create basic metadata using initialization parameters
                pcwm = CreateBasicWriterMetadata();

                // call writer's OnIdentify method to get more metadata
                BS_ASSERT(m_pWriter);
                bool bSucceeded;
                try
                    {
                    bSucceeded = m_pWriter->OnIdentify
                                    (
                                    (IVssCreateWriterMetadata *) pcwm
                                    );
                    }
                catch(...)
                    {
                    ft.Trace(VSSDBG_WRITER, L"Writer's OnIdentify method threw and exception.");
                    throw;
                    }

                if (!bSucceeded)
                    {
                    // indicate failure if writer fails OnIdentify
                    ft.Throw(VSSDBG_WRITER, S_FALSE, L"Writer's OnIdentify method returned false.");
                    }

                CComBSTR bstrXML;
                CComBSTR bstrInstanceId(m_InstanceID);
                CComBSTR bstrWriterId(m_WriterID);
                CComBSTR bstrWriterName(m_wszWriterName);
                if (!bstrInstanceId ||
                    !bstrWriterId ||
                    !bstrWriterName)
                    ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate memory for ids or name");

                // save WRITER_METADATA document as XML string
                ft.hr = pcwm->SaveAsXML(&bstrXML);
                if (FAILED(ft.hr))
                    ft.Throw
                        (
                        VSSDBG_WRITER,
                        E_OUTOFMEMORY,
                        L"Cannot save XML document as string. hr = 0x%08lx",
                        ft.hr
                        );

                // callback through ExposeWriterMetadata method
                try
                    {
                    ft.hr = pCallback->ExposeWriterMetadata
                            (
                            bstrInstanceId,
                            bstrWriterId,
                            bstrWriterName,
                            bstrXML
                            );
                    }
                catch(...)
                    {
                    ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::ExposeWriterMetadata threw an exception.");
                    throw;
                    }

                }
            catch(...)
                {
                }

            }
        else
            {
            // get writer state

            CComBSTR bstrInstanceId(m_InstanceID);
            if (!bstrInstanceId)
                ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate memory for ids or name");

            CVssID id;
            id.Initialize(ft, (LPCWSTR) bstrSnapshotSetId, E_INVALIDARG);

            CVssAutoDiagLogger logger(m_writerstate, VSS_IN_GETSTATE, id);

            // get IVssWriterCallback interface
            CComPtr<IVssWriterCallback> pCallback;
            GetCallback(pWriterCallback, &pCallback);

            VSWRITER_STATE state;
_retry:
            m_writerstate.GetStateForSnapshot(id, state);

            // Special handling for the case where the writer is in the middle of operation
            if (state.m_bInOperation)
                {
                if (state.m_state != VSS_WS_FAILED_AT_PREPARE_BACKUP &&
                    state.m_state != VSS_WS_FAILED_AT_PREPARE_SNAPSHOT &&
                    state.m_state != VSS_WS_FAILED_AT_FREEZE &&
                    state.m_state != VSS_WS_FAILED_AT_THAW)
                    {
                    state.m_hrWriterFailure = VSS_E_WRITER_NOT_RESPONDING;
                    switch(state.m_currentOperation)
                        {
                        default:
                            state.m_state = VSS_WS_UNKNOWN;
                            BS_ASSERT(false);
                            break;

                        case VSS_IN_PREPAREBACKUP:
                            state.m_state = VSS_WS_FAILED_AT_PREPARE_BACKUP;
                            break;

                        case VSS_IN_PREPARESNAPSHOT:
                            state.m_state = VSS_WS_FAILED_AT_PREPARE_SNAPSHOT;
                            break;

                        case VSS_IN_FREEZE:
                            state.m_state = VSS_WS_FAILED_AT_FREEZE;
                            break;

                        case VSS_IN_THAW:
                            state.m_state = VSS_WS_FAILED_AT_THAW;
                            break;

                        case VSS_IN_POSTSNAPSHOT:
                            state.m_state = VSS_WS_FAILED_AT_POST_SNAPSHOT;
                            break;

                        case VSS_IN_BACKUPCOMPLETE:
                            state.m_state = VSS_WS_FAILED_AT_BACKUP_COMPLETE;
                            break;

                        case VSS_IN_PRERESTORE:
                            state.m_state = VSS_WS_FAILED_AT_PRE_RESTORE;
                            break;

                        case VSS_IN_POSTRESTORE:
                            state.m_state = VSS_WS_FAILED_AT_POST_RESTORE;
                            break;

                        case VSS_IN_BACKUPSHUTDOWN:
                            state.m_state = VSS_WS_UNKNOWN;  
                            break;
                        }

                    if (!m_writerstate.SetNoResponseFailure(id, state))
                        goto _retry;
                    }
                }


            // call Backup's ExposeCurrentState callback method
            try
                {
                ft.hr = pCallback->ExposeCurrentState
                                (
                                bstrInstanceId,
                                state.m_state,
                                state.m_hrWriterFailure
                                );
                }
            catch(...)
                {
                ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::ExposeCurrentState threw an exception");
                throw;
                }

            }
        }
    VSS_STANDARD_CATCH(ft)

    delete pcwm;

    // Bug 255996
    return S_OK;
    }


// process PrepareForBackup event
STDMETHODIMP CVssWriterImpl::PrepareForBackup
    (
    IN      BSTR bstrSnapshotSetId,
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PrepareForBackup" );

    bool EnteredStateCalled = false;
    try
        {
        // access check
        if (!IsBackupOperator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");

        if (pWriterCallback == NULL || bstrSnapshotSetId == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");


        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PrepareForBackup\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        CVssAutoDiagLogger logger(m_writerstate, VSS_IN_PREPAREBACKUP, bstrSnapshotSetId);

	    EnteredStateCalled  = true;	// At this point, EnterState will always be called
        // enter PrepareForBackup state
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmPrepareForBackup],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Couldn't properly begin sequence"
                );
            }


        AssertLocked();

        // indicate we are in an operation
        m_writerstate.SetInOperation(VSS_IN_PREPAREBACKUP);

        // get IVssWriterCallback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);

        // get IVssWriterComponentsExt interface
        CComPtr<IVssWriterComponentsInt> pComponents;
        InternalGetWriterComponents(pCallback, &pComponents, true, false);

        BS_ASSERT(m_pWriter);

        // call writer's OnPrepareBackup method
        bool bResult;
        try
            {
            bResult = m_pWriter->OnPrepareBackup(pComponents);
            BS_ASSERT(m_bOnAbortPermitted == false);
            m_bOnAbortPermitted = true;
            }
        catch(...)
            {
            ft.Trace(VSSDBG_WRITER, L"Writer's OnPrepareBackup method threw an exception");
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the preparebackup");


        // save changes to components if any
        if (pComponents)
            SaveChangedComponents(pCallback, false, pComponents);
        }
    VSS_STANDARD_CATCH(ft)

    // leave PrepareBackup state
    if (EnteredStateCalled)
	    LeaveState(s_rgWriterStates[s_ivwsmPrepareForBackup], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }


// if the writer components were changed, save them back to the requestor's
// XML document.
void CVssWriterImpl::SaveChangedComponents
    (
    IN IVssWriterCallback *pCallback,
    IN bool bRestore,
    IN IVssWriterComponentsInt *pComponents
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterImpl::SaveChangedComponents");

    bool bChanged;

    // determine if components are changed
    ft.hr = pComponents->IsChanged(&bChanged);
    BS_ASSERT(ft.hr == S_OK);
    if (bChanged)
        {
        // get instance id
        CComBSTR bstrWriterInstanceId(bRestore ? m_WriterID : m_InstanceID);
        if (!bstrWriterInstanceId)
            ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate instance id string");

        // get WRITER_COMPONENTS XML document
        CComBSTR bstrWriterComponentsDocument;
        ft.hr = pComponents->SaveAsXML(&bstrWriterComponentsDocument);
        if (ft.HrFailed())
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_OUTOFMEMORY,
                L"Saving WRITER_COMPONENTS document as XML failed.  hr = 0x%08lx",
                ft.hr
                );
            }

        // callback to set component in BACKUP_COMPONENTS document
        try
            {
            ft.hr = pCallback->SetContent(bstrWriterInstanceId, bstrWriterComponentsDocument);
            }
        catch(...)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::SetContent threw an exception.");
            throw;
            }

        if (ft.HrFailed() && m_writerstate.GetCurrentFailure() == S_OK)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                ft.hr,
                L"IVssWriterCallback::SetContent failed.  hr = 0x%08lx",
                ft.hr
                );
            }
        }
    }


// process PrepareForSnapshot event
STDMETHODIMP CVssWriterImpl::PrepareForSnapshot
    (
    IN  BSTR    bstrSnapshotSetId,          // snapshot set id
    IN  BSTR    bstrVolumeNamesList         // list of volume names separated by ';'
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PrepareForSnapshot" );

    bool EnterStateCalled = false;
    try
        {
        // should only be called by coordinator
        // check for admin privileges
        if (!IsAdministrator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");

        if (bstrSnapshotSetId == NULL || bstrVolumeNamesList == NULL)
        	{
        	BS_ASSERT(false);
        	ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"A required in parameter is NULL.");        		
              }
        
        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PrepareForSnapshot\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
        ft.Trace(VSSDBG_WRITER, L"\tVolumeNamesList = %s\n", (LPWSTR)bstrVolumeNamesList);

        CVssAutoDiagLogger logger(m_writerstate, VSS_IN_PREPARESNAPSHOT, bstrSnapshotSetId);

        // enter PrepareForSnapshot state
        EnterStateCalled = true;
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmPrepareForSnapshot],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"improper state transition"
                );
            }

        AssertLocked();

        // indicate that we are in an operation
        m_writerstate.SetInOperation(VSS_IN_PREPARESNAPSHOT);

        // Get the array of volume names
        BS_ASSERT(m_pwszLocalVolumeNameList == NULL);
        ::VssSafeDuplicateStr(ft, m_pwszLocalVolumeNameList, (LPWSTR)bstrVolumeNamesList);

        // Get the number of volumes
        BS_ASSERT(m_nVolumesCount == 0);
        m_nVolumesCount = 0; // For safety
        LPWSTR pwszVolumesToBeParsed = m_pwszLocalVolumeNameList;

        // parse volume name string
        while(true)
            {
            // get pointer to next volume
            WCHAR* pwszNextVolume = ::wcstok(pwszVolumesToBeParsed, VSS_VOLUME_DELIMITERS);
            pwszVolumesToBeParsed = NULL;

            if (pwszNextVolume == NULL)
                // no more volumes
                break;

            // skip if volume name is empty
            if (pwszNextVolume[0] == L'\0')
                continue;

            // count of volumes
            m_nVolumesCount++;
            }

        // make sure there is at least one volume
        if (m_nVolumesCount == 0)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.LogError(VSS_ERROR_EMPTY_SNAPSHOT_SET, VSSDBG_WRITER);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"No volumes in the snapshot set"
                );
            }

        // Allocate the array of pointers to volume names
        BS_ASSERT(m_nVolumesCount > 0);
        BS_ASSERT(m_ppwszVolumesArray == NULL);
        m_ppwszVolumesArray = new LPWSTR[m_nVolumesCount];
        if (m_ppwszVolumesArray == NULL)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw( VSSDBG_WRITER, E_OUTOFMEMORY, L"Memory allocation error");
            }

        //
        // Copy the volume names into the array.
        //

        // re-copy the whole volume list
        ::wcscpy(m_pwszLocalVolumeNameList, (LPWSTR)bstrVolumeNamesList);

        // Fill the array by re-parsing the volume list.
        INT nVolumesIndex = 0;
        pwszVolumesToBeParsed = m_pwszLocalVolumeNameList;
        while(true)
            {
            WCHAR* pwszNextVolume = ::wcstok(pwszVolumesToBeParsed, VSS_VOLUME_DELIMITERS);
            pwszVolumesToBeParsed = NULL;

            if (pwszNextVolume == NULL)
                break;

            if (pwszNextVolume[0] == L'\0')
                continue;

            BS_ASSERT(nVolumesIndex < m_nVolumesCount);
            m_ppwszVolumesArray[nVolumesIndex] = pwszNextVolume;

            nVolumesIndex++;
            }

        BS_ASSERT(nVolumesIndex == m_nVolumesCount);

        // Call the writer's OnPrepareSnapshot method
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnPrepareSnapshot();
            m_bOnAbortPermitted = true;
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Trace(VSSDBG_WRITER, L"Writer's OnPrepareSnapshot method threw an execption");
            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the prepare snapshot");
        }
    VSS_STANDARD_CATCH(ft)

    // leave PrepareSnapshot state
    if (EnterStateCalled)
	    LeaveState(s_rgWriterStates[s_ivwsmPrepareForSnapshot], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }


// process freeze event
STDMETHODIMP CVssWriterImpl::Freeze
    (
    IN  BSTR    bstrSnapshotSetId,
    IN  INT     nLevel
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Freeze" );

    bool EnterStateCalled = false;
    try
        {
        // should only be called by the coordinator, access check for admin privileges
        if (!IsAdministrator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");
        
    	if (bstrSnapshotSetId == NULL)
		{
		BS_ASSERT(false);
		ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"A required parameter is NULL.");
		}
	
        ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Freeze\nParameters:\n");
        ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
        ft.Trace( VSSDBG_WRITER, L"\tLevel = %d\n", nLevel);
	
        // Ignore other Levels
        if (m_nLevel != nLevel)
            return S_OK;

        CVssAutoDiagLogger logger(m_writerstate, VSS_IN_FREEZE, bstrSnapshotSetId);

        // enter freeze state
        EnterStateCalled = true;
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmFreeze],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Improper entry into state"
                );
            }

        AssertLocked();

        // indicate that we are in an operation
        m_writerstate.SetInOperation(VSS_IN_FREEZE);

        // Call writer's OnFreeze
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnFreeze();
            BS_ASSERT(m_bOnAbortPermitted == true);
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Trace(VSSDBG_WRITER, L"Writer's OnFreeze Method threw and exception");
            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the freeze");


        // setup arguments to timer thread
        CVssTimerArgs *pArgs = new CVssTimerArgs(this, m_CurrentSnapshotSetId);
        if (pArgs == NULL)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_OUTOFMEMORY,
                L"Cannot create timer args due to allocation failure"
                );
            }

        DWORD tid;

        // create timer thread
        m_hThreadTimerThread =
            CreateThread
                (
                NULL,
                VSS_STACK_SIZE,
                &CVssWriterImpl::StartTimerThread,
                pArgs,
                0,
                &tid
                );

        if (m_hThreadTimerThread == NULL)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            delete pArgs;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_OUTOFMEMORY,
                L"Failure to create thread due to error %d.",
                GetLastError()
                );
           }
        }
    VSS_STANDARD_CATCH(ft)

    // leave OnFreeze state
    if (EnterStateCalled)
	    LeaveState( s_rgWriterStates[s_ivwsmFreeze], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }


// handle IVssWriter::Thaw event
STDMETHODIMP CVssWriterImpl::Thaw
    (
    IN  BSTR    bstrSnapshotSetId
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Thaw" );

    bool EnterStateCalled = false;
    try
        {
        // should only be called by coordinator.  Access check for admin
        if (!IsAdministrator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");

        if (bstrSnapshotSetId == NULL)
        	{
        	BS_ASSERT(false);
        	ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"A required parameter is NULL");
        	}

        ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Thaw\nParameters:\n");
        ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        CVssAutoDiagLogger logger(m_writerstate, VSS_IN_THAW, bstrSnapshotSetId);

        // enter Thaw state
        EnterStateCalled = true;	// this line of code must be immediately before the call of EnterState
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmThaw],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Improper entry into state"
                );
            }


        // indicate that we are in an operation
        m_writerstate.SetInOperation(VSS_IN_THAW);

        AssertLocked();

        // terminate timer thread as we are about to thaw the operation
        // Warning: BUG 488348	VSS: Assert when testing m_bSequenceInProgress	Bug Understood	Server RC1	 

        TerminateTimerThread();

        // We should "live" in a sequence since Thaw is not the first phase of the sequence.
        if (!m_bSequenceInProgress)
        {
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the thaw");
        }

        // Call writer's OnThaw
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnThaw();
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            ft.Trace(VSSDBG_WRITER, L"Writer's OnThaw method threw an exception");
            throw;
            }

        // throw veto if writer vetoes the event
        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the thaw");
        }
    VSS_STANDARD_CATCH(ft)

    // leave OnThaw state
    if (EnterStateCalled)
	    LeaveState(s_rgWriterStates[s_ivwsmThaw], ft.HrSucceeded());
    
    // Bug 255996
    return S_OK;
    }

// process PostSnapshot event
STDMETHODIMP CVssWriterImpl::PostSnapshot
    (
    IN      BSTR bstrSnapshotSetId,
    IN      IDispatch* pWriterCallback,
    IN      BSTR SnapshotDevicesList    
    )
    {
    UNREFERENCED_PARAMETER(SnapshotDevicesList);

    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PostSnapshot" );


    bool  EnterStateCalled = false;
    try
        {
        // access check
        if (!IsAdministrator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");
        
        if (pWriterCallback == NULL || bstrSnapshotSetId == NULL)
            {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");
            }
        
        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PostSnapshot\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        CVssAutoDiagLogger logger(m_writerstate, VSS_IN_POSTSNAPSHOT, bstrSnapshotSetId);

        // enter PostSnapshot state
        EnterStateCalled = true;
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmPostSnapshot],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Couldn't properly begin sequence"
                );
            }


        AssertLocked();

        // indicate we are in an operation
        m_writerstate.SetInOperation(VSS_IN_POSTSNAPSHOT);

        // get IVssWriterCallback interface
        CComPtr<IVssWriterCallback> pCallback;

        //
        //  This is a special case where the writer calls VSS instead of
        //  the requestor.  In this case we have to allow impersonation.
        //
        GetCallback(pWriterCallback, &pCallback, TRUE);

        // get IVssWriterComponentsExt interface
        CComPtr<IVssWriterComponentsInt> pComponents;
        InternalGetWriterComponents(pCallback, &pComponents, true, false);

        BS_ASSERT(m_pWriter);

        // call writer's OnPostSnapshot method
        bool bResult;
        try
            {
            bResult = m_pWriter->OnPostSnapshot(pComponents);
            }
        catch(...)
            {
            ft.Trace(VSSDBG_WRITER, L"Writer's OnPostSnapshot method threw an exception");
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the post Snapshot");

        // save changes to components if any
        if (pComponents)
            SaveChangedComponents(pCallback, false, pComponents);
        }
    VSS_STANDARD_CATCH(ft)

    // leave PostSnapshot state
    if (EnterStateCalled)
	    LeaveState(s_rgWriterStates[s_ivwsmPostSnapshot], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }



// process backup complete event
STDMETHODIMP CVssWriterImpl::BackupComplete
    (
    IN      BSTR bstrSnapshotSetId,
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::BackupComplete" );

            // access check
    try
        {
	 if (!IsBackupOperator())
              ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED,L"Backup Operator privileges are not set");
    	
	    // MTA synchronization: The critical section will be left automatically at the end of scope.
	    CVssWriterImplLock lock(this);
	    CVssID id;
	    bool bIdInitialized = false;


	    try
	        {        
	        if (pWriterCallback == NULL || bstrSnapshotSetId == NULL)
	            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

	        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: OnBackupComplete\nParameters:\n");
	        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

            CVssAutoDiagLogger logger(m_writerstate, VSS_IN_BACKUPCOMPLETE, bstrSnapshotSetId);

	        m_writerstate.SetInOperation(VSS_IN_BACKUPCOMPLETE);

	        BS_ASSERT(!m_bSequenceInProgress);
	        BS_ASSERT(m_CurrentSnapshotSetId == GUID_NULL);

	        id.Initialize(ft, (LPCWSTR) bstrSnapshotSetId, E_INVALIDARG);
	        bIdInitialized = true;

	        m_writerstate.FinishBackupComplete(id);

	        // get IVssWriterCallback interface
	        CComPtr<IVssWriterCallback> pCallback;
	        GetCallback(pWriterCallback, &pCallback);


	        // get IVssWriterComponentsInt object
	        CComPtr<IVssWriterComponentsInt> pComponents;
	        InternalGetWriterComponents(pCallback, &pComponents, false, false);

	        // call writer's OnBackupComplete method
	        BS_ASSERT(m_pWriter);
	        try
	            {
	            if (!m_pWriter->OnBackupComplete(pComponents))
	                ft.hr = S_FALSE;
	            }
	        catch(...)
	            {
	            if (m_writerstate.GetCurrentFailure() == S_OK)
	                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

	            ft.Trace(VSSDBG_WRITER, L"Writer's OnBackupComplete method threw an exception.");
	            throw;
	            }

	        if (ft.hr == S_FALSE)
	            ft.Throw(VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the backup complete");
	        }
	    VSS_STANDARD_CATCH(ft)

	    // indicate that sequence is complete
	    if (m_writerstate.GetCurrentState() == VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
	        m_writerstate.SetCurrentState(VSS_WS_STABLE);

	    m_writerstate.SetBackupCompleteStatus(id, ft.hr);

	    m_writerstate.ExitOperation();
            }
    VSS_STANDARD_CATCH(ft) 

    // Bug 255996
    return S_OK;
    }

STDMETHODIMP CVssWriterImpl::BackupShutdown
    (
    IN BSTR bstrSnapshotSetId
    )
   {
   UNREFERENCED_PARAMETER(bstrSnapshotSetId);
   
   CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::BackupShutdown");

    // access check
    try
        {
	 if (!IsAdministrator())
              ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED,L"Can only be called from the coordinator");
    	
	    // MTA synchronization: The critical section will be left automatically at the end of scope.
	    CVssWriterImplLock lock(this);
	    CVssID id;


	    try
	        {        
	        if (bstrSnapshotSetId == NULL)
	            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

	        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: OnBackupShutdown\nParameters:\n");
	        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

            CVssAutoDiagLogger logger(m_writerstate, VSS_IN_BACKUPSHUTDOWN, bstrSnapshotSetId);
            
	        m_writerstate.SetInOperation(VSS_IN_BACKUPSHUTDOWN);

	        id.Initialize(ft, (LPCWSTR) bstrSnapshotSetId, E_INVALIDARG);

	        // call writer's OnBackupComplete method
	        BS_ASSERT(m_pWriter);
	        try
	            {
	            if (!m_pWriter->OnBackupShutdown(id))
	                ft.hr = S_FALSE;
	            }
	        catch(...)
	            {
	            if (m_writerstate.GetCurrentFailure() == S_OK)
	                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

	            ft.Trace(VSSDBG_WRITER, L"Writer's OnBackupShutdown  method threw an exception.");
	            throw;
	            }

	        if (ft.hr == S_FALSE)
	            ft.Throw(VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the backup shutdown");
	        }
	    VSS_STANDARD_CATCH(ft)


	    m_writerstate.ExitOperation();
            }
    VSS_STANDARD_CATCH(ft) 

    // Bug 255996
    return S_OK;
   }

// handle IVssWriter::Abort event
STDMETHODIMP CVssWriterImpl::Abort
    (
    IN  BSTR    bstrSnapshotSetId
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Abort" );

    try
    {
        if (!IsBackupOperator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup privileges are not set");
    
        ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Abort\nParameters:\n");
        ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        Lock();

        CVssID id;
        id.Initialize(ft, bstrSnapshotSetId, S_OK); // Ignore errors here.

        CVssAutoDiagLogger logger(m_writerstate, VSS_IN_ABORT, id);

        // call do abort function
        DoAbort(false, bstrSnapshotSetId);


        Unlock();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// process prerestore event
STDMETHODIMP CVssWriterImpl::PreRestore
    (
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PreRestore" );
    
    ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PreRestore\n");

    try
    	{
	    // access check
	    if (!IsRestoreOperator())
	    	ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"Restore Operator privileges are not set");

	    // MTA synchronization: The critical section will be left automatically at the end of scope.
	    CVssWriterImplLock lock(this);

        CVssAutoDiagLogger logger(m_writerstate, VSS_IN_PRERESTORE);
        
	    m_writerstate.SetInOperation(VSS_IN_PRERESTORE);
	    m_writerstate.SetCurrentFailure(S_OK);

	    try
	        {
	        if (pWriterCallback == NULL)
	            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

	        // get writer callback interface
	        CComPtr<IVssWriterCallback> pCallback;
	        GetCallback(pWriterCallback, &pCallback);
	        CComPtr<IVssWriterComponentsInt> pComponents;

	        // get IVssWriterComponentsInt object
	        InternalGetWriterComponents(pCallback, &pComponents, true, true);

	        // call writer's OnPreRestore method
	        BS_ASSERT(m_pWriter);
	        try
	            {
	            if (!m_pWriter->OnPreRestore(pComponents))
	                ft.hr = S_FALSE;
	            }
	        catch(...)
	            {
	            if (m_writerstate.GetCurrentFailure() == S_OK)
	                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

	            ft.Trace(VSSDBG_WRITER, L"Writer's OnPreRestore method threw an exception");
	            throw;
	            }

	        if (ft.hr == S_FALSE)
	            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the prerestore");

	        if (pComponents)
	            SaveChangedComponents(pCallback, true, pComponents);
	        }
	    VSS_STANDARD_CATCH(ft)

	    if (FAILED(ft.hr))
	        m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_PRE_RESTORE);
	    else
	        m_writerstate.SetCurrentState(VSS_WS_STABLE);


	    m_writerstate.ExitOperation();
    	}
    VSS_STANDARD_CATCH(ft)
    	
    // Bug 255996
    return S_OK;
    }



// process post restore event
STDMETHODIMP CVssWriterImpl::PostRestore
    (
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PostRestore" );

    try
    	{
	    // access check
	    if (!IsRestoreOperator())
	          ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"Restore Operator privileges are not set");

	    ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PostRestore\n");

	    // MTA synchronization: The critical section will be left automatically at the end of scope.
	    CVssWriterImplLock lock(this);

        CVssAutoDiagLogger logger(m_writerstate, VSS_IN_POSTRESTORE);

	    m_writerstate.SetInOperation(VSS_IN_POSTRESTORE);
	    m_writerstate.SetCurrentFailure(S_OK);

	    try
	        {        
	        if (pWriterCallback == NULL)
	            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

	        // get writer callback interface
	        CComPtr<IVssWriterCallback> pCallback;
	        GetCallback(pWriterCallback, &pCallback);
	        CComPtr<IVssWriterComponentsInt> pComponents;

	        // get IVssWriterComponentsInt object
	        InternalGetWriterComponents(pCallback, &pComponents, true, true);

	        // call writer's OnPostRestore method
	        BS_ASSERT(m_pWriter);
	        try
	            {
	            if (!m_pWriter->OnPostRestore(pComponents))
	                ft.hr = S_FALSE;
	            }
	        catch(...)
	            {
	            if (m_writerstate.GetCurrentFailure() == S_OK)
	                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

	            ft.Trace(VSSDBG_WRITER, L"Writer's OnPostRestore method threw an exception");
	            throw;
	            }

	        if (ft.hr == S_FALSE)
	            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the postrestore");

	        if (pComponents)
	            SaveChangedComponents(pCallback, true, pComponents);
	        }
	    VSS_STANDARD_CATCH(ft)

	    if (FAILED(ft.hr))
	        m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_POST_RESTORE);
	    else
	        m_writerstate.SetCurrentState(VSS_WS_STABLE);


	    m_writerstate.ExitOperation();
	    }
    VSS_STANDARD_CATCH(ft)
    	
    // Bug 255996
    return S_OK;
    }


// table of names of events that we are subscribing to
// NOTE: this table is based on definition of VSS_EVENT_MASK.  Each
// offset corresponds to a bit on that mask
const WCHAR *g_rgwszSubscriptions[] =
    {
    g_wszPrepareForBackupMethodName,        // VSS_EVENT_PREPAREBackup
    g_wszPrepareForSnapshotMethodName,      // VSS_EVENT_PREPARESnapshot
    g_wszFreezeMethodName,                  // VSS_EVENT_FREEZE
    g_wszThawMethodName,                    // VSS_EVENT_THAW
    g_wszPostSnapshotMethodName,            // VSS_EVENT_POST_SNAPSHOT
    g_wszAbortMethodName,                   // VSS_EVENT_ABORT
    g_wszBackupCompleteMethodName,          // VSS_EVENT_BACKUPCOMPLETE
    g_wszRequestInfoMethodName,             // VSS_EVENT_REQUESTINFO
    g_wszPreRestoreMethodName,              // VSS_EVENT_RESTORE
    g_wszPostRestoreMethodName,              // VSS_EVENT_POST_RESTORE
    g_wszBackupShutdownName			     // VSS_EVENT_BACKUPSHUTDOWN 
    };


/////////////////////////////////////////////////////////////////////////////
//  Subscription-related members


// create subscriptions
// This function returns S_FALSE when the writer is inactive (setup or safe mode)
void CVssWriterImpl::Subscribe()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Subscribe");

    // validate that the writer is initialized
    if (m_bInSetup || m_bInSafeMode)
        ft.Throw
            (
            VSSDBG_WRITER,
            S_FALSE,
            L"Writer is inactive during setup or safe mode"
            );

    // validate that the writer is initialized
    if (!m_bInitialized)
        ft.Throw
            (
            VSSDBG_WRITER,
            VSS_E_BAD_STATE,
            L"You must initialize the writer before other operations"
            );

    // currently we subscribe to all events
    m_dwEventMask = VSS_EVENT_ALL;

    if (m_bstrSubscriptionName.Length() > 0)
        ft.Throw
            (
            VSSDBG_XML,
            VSS_E_WRITER_ALREADY_SUBSCRIBED,
            L"The writer has already called the Subscribe function."
            );

    // create event system
    CComPtr<IEventSystem> pSystem;
    ft.CoCreateInstanceWithLog(
            VSSDBG_WRITER,
            CLSID_CEventSystem,
            L"CEventSystem",
            CLSCTX_SERVER,
            IID_IEventSystem,
            (IUnknown**)&(pSystem));
    ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");
    CComBSTR bstrClassId = CLSID_VssEvent;
    CComBSTR bstrIID = IID_IVssWriter;
    CComBSTR bstrProgId = PROGID_EventSubscription;

    // see if event class already exists
    CComBSTR bstrQuery = "EventClassID == ";
    if (!bstrQuery)
        ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

    bstrQuery.Append(bstrClassId);
    if (!bstrQuery)
        ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

    int location;
    CComPtr<IEventObjectCollection> pCollection;
    ft.hr = pSystem->Query
                (
                PROGID_EventClassCollection,
                bstrQuery,
                &location,
                (IUnknown **) &pCollection
                );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");
    long cEvents;
    ft.hr = pCollection->get_Count(&cEvents);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    if (cEvents == 0)
        {
        // event class does not exist, create it.  Note that there is a
        // potential race condition here if two writers try creating the event
        // class at the same time.  We create the event class during installation
        // so that this should rarely happen
        CComPtr<IEventClass> pEvent;

        CComBSTR bstrEventClassName = L"VssEvent";
        WCHAR buf[MAX_PATH*2];

        // event class typelib
        UINT cwc = ExpandEnvironmentStrings
                        (
                        L"%systemroot%\\system32\\eventcls.dll",
                        buf,
                        sizeof(buf)/sizeof(WCHAR)
                        );

        if (cwc == 0)
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_WRITER, L"ExpandEnvironmentStrings");
            }

        CComBSTR bstrTypelib = buf;

        // create event class
        ft.CoCreateInstanceWithLog(
                VSSDBG_WRITER,
                CLSID_CEventClass,
                L"CEventClass",
                CLSCTX_SERVER,
                IID_IEventClass,
                (IUnknown**)&(pEvent));

        ft.CheckForError(VSSDBG_WRITER, L"CoCreatInstance");

        // setup class id
        ft.hr = pEvent->put_EventClassID(bstrClassId);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassID");

        // set up class name
        ft.hr = pEvent->put_EventClassName(bstrEventClassName);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassName");

        // set up typelib
        ft.hr = pEvent->put_TypeLib(bstrTypelib);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_TypeLib");

        // store event class
        ft.hr = pSystem->Store(PROGID_EventClass, pEvent);
        ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Store");
        }

    // create subscription id
    VSS_ID SubscriptionId;
    ft.hr = ::CoCreateGuid(&SubscriptionId);
    ft.CheckForError(VSSDBG_WRITER, L"CoCreateGuid");
    m_bstrSubscriptionName = SubscriptionId;

    // get IUnknown for subscribers class
    IUnknown *pUnkSubscriber = GetUnknown();
    UINT iwsz, mask;

    try
        {
        // loop through subscriptions
        for(mask = 1, iwsz = 0; mask < VSS_EVENT_ALL; mask = mask << 1, iwsz++)
            {
            if (m_dwEventMask & mask && g_rgwszSubscriptions[iwsz] != NULL)
                {
                // create IEventSubscription object
                CComPtr<IEventSubscription> pSubscription;
                ft.CoCreateInstanceWithLog(
                        VSSDBG_WRITER,
                        CLSID_CEventSubscription,
                        L"CEventSubscription",
                        CLSCTX_SERVER,
                        IID_IEventSubscription,
                        (IUnknown**)&(pSubscription));
                ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");

                // set subscription name
                ft.hr = pSubscription->put_SubscriptionName(m_bstrSubscriptionName);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_SubscriptionName");

                // set event class id
                ft.hr = pSubscription->put_EventClassID(bstrClassId);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_EventClassID");

                // set interface id
                ft.hr = pSubscription->put_InterfaceID(bstrIID);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_InterfaceID");

                // set subcriber interface
                ft.hr = pSubscription->put_SubscriberInterface(pUnkSubscriber);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_SubscriberInterface");

                // make subscription per user since this is not necessarily in local system
                ft.hr = pSubscription->put_PerUser(TRUE);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_PerUser");

                // set method name for subscrpition
                ft.hr = pSubscription->put_MethodName(CComBSTR(g_rgwszSubscriptions[iwsz]));
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_MethodName");

                // setup InstanceId and WriterId subscription properties
                VARIANT varWriterId;
                VARIANT varInstanceId;

                CComBSTR bstrWriterId = m_WriterID;
                CComBSTR bstrInstanceId = m_InstanceID;

                varWriterId.vt = VT_BSTR;
                varWriterId.bstrVal = bstrWriterId;
                varInstanceId.vt = VT_BSTR;
                varInstanceId.bstrVal = bstrInstanceId;

                ft.hr = pSubscription->PutSubscriberProperty(L"WriterId", &varWriterId);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::PutSubscriberProperty");

                ft.hr = pSubscription->PutSubscriberProperty(L"WriterInstanceId", &varInstanceId);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::PutSubscriberProperty");

                // store subscription
                ft.hr = pSystem->Store(bstrProgId, pSubscription);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Store");

                // get constructed subscription id and save it
                ft.hr = pSubscription->get_SubscriptionID(&m_rgbstrSubscriptionId[m_cbstrSubscriptionId]);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::get_SubscriptionID");

                // increment count of
                m_cbstrSubscriptionId++;
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    // if the operation fails with us partially subscribed, then unsubscribe
    if (ft.HrFailed() && m_cbstrSubscriptionId)
        {
        Unsubscribe();
        ft.Throw(VSSDBG_WRITER, ft.hr, L"Rethrowing exception");
        }

    ft.Trace(VSSDBG_WRITER, L"**** Subscribe succeeded for [%p]", this);
    }


// terminate timer thread
// assumes caller has the critical section locked
void CVssWriterImpl::TerminateTimerThread()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::TerminateTimerThread");

    AssertLocked();
    if (m_hThreadTimerThread)
        {
        // cause timer thread to terminate
        m_command = VSS_TC_TERMINATE_THREAD;
        if (!SetEvent(m_hevtTimerThread))
            {
            DWORD dwErr = GetLastError();
            ft.Trace(VSSDBG_WRITER, L"SetEvent failed with error %d\n", dwErr);
            BS_ASSERT(FALSE && "SetEvent failed");
            }


        // get thread handle
        HANDLE hThread = m_hThreadTimerThread;
        m_hThreadTimerThread = NULL;

        // unlock during wait
        Unlock();
        if (WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED)
            {
            DWORD dwErr = GetLastError();
            ft.Trace(VSSDBG_WRITER, L"WaitForSingleObject failed with error %d\n", dwErr);
            BS_ASSERT(FALSE && "WaitForSingleObject failed");
            }

        CloseHandle(hThread);
        Lock();
        }
    }


// unsubscribe this writer from IVssWriter events
// This function returns S_FALSE when the writer is inactive (setup or safe mode)
void CVssWriterImpl::Unsubscribe()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Unsubscribe");

    if (m_bInSetup || m_bInSafeMode)
        ft.Throw
            (
            VSSDBG_WRITER,
            S_FALSE,
            L"Writer is inactive during setup or safe mode"
            );

    // validate that the writer is initialized
    if (!m_bInitialized)
        ft.Throw
            (
            VSSDBG_WRITER,
            VSS_E_BAD_STATE,
            L"You must initialize the writer before other operations"
            );

    // terminate timer thread if active
    Lock();
    TerminateTimerThread();
    Unlock();

    // make sure subscription name was assigned; if not assume subscriptions
    // weren't created
    if (m_bstrSubscriptionName.Length() == 0)
        return;

    // create event system
    CComPtr<IEventSystem> pSystem;
    ft.CoCreateInstanceWithLog(
            VSSDBG_WRITER,
            CLSID_CEventSystem,
            L"CEventSystem",
            CLSCTX_SERVER,
            IID_IEventSystem,
            (IUnknown**)&(pSystem));
    ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");

#if 0
    WCHAR buf[256];
    int location;
    swprintf(buf, L"SubscriptionName = \"%s\"", m_bstrSubscriptionName);

    CComPtr<IEventObjectCollection> pCollection;

    ft.hr = pSystem->Query
        (
        PROGID_EventSubscriptionCollection,
        buf,
        &location,
        (IUnknown **) &pCollection
        );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");

    long cSub;
    ft.hr = pCollection->get_Count(&cSub);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    pCollection = NULL;
#endif

    UINT iSubscription;
    for(iSubscription = 0; iSubscription < m_cbstrSubscriptionId; iSubscription++)
        {
        // setup query string
        CComBSTR bstrQuery = L"SubscriptionID == ";
        if (!bstrQuery)
            ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"allocation of BSTR failed");

        // if subscription exists, then remove it
        if (m_rgbstrSubscriptionId[iSubscription])
            {
            bstrQuery.Append(m_rgbstrSubscriptionId[iSubscription]);
            if (!bstrQuery)
                ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"allocation of BSTR failed");

            int location;

            // remove subscription
            ft.hr = pSystem->Remove(PROGID_EventSubscription, bstrQuery, &location);
            ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Remove");

            // indicate that subscription was removed
            m_rgbstrSubscriptionId[iSubscription].Empty();
            }
        }
#if 0
    ft.hr = pSystem->Query
        (
        PROGID_EventSubscriptionCollection,
        buf,
        &location,
        (IUnknown **) &pCollection
        );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");

    ft.hr = pCollection->get_Count(&cSub);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    pCollection = NULL;
#endif

    // reset subscription name so unsubscribe does nothing if called again
    m_bstrSubscriptionName.Empty();
    m_cbstrSubscriptionId = 0;

    // Disconnect the subscription object, if any are left (bug 496343)
    ::CoDisconnectObject(GetUnknown(), 0);
 
    ft.Trace(VSSDBG_WRITER, L"**** Unsubscribe succeeded for [%p] (%u subscriptions removed)", this, iSubscription);
    }

// create a internal writer class and link it up to the external writer class
void CVssWriterImpl::CreateWriter
    (
    CVssWriter *pWriter,            // external writer
    IVssWriterImpl **ppImpl         // interface to be used by external writer
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::CreateWriter");

    BS_ASSERT(ppImpl);
    BS_ASSERT(pWriter);

    *ppImpl = NULL;

    // create internal wrier class
    CComObject<CVssWriterImpl> *pImpl;
    // create CVssWriterImpl object <core writer class>
    ft.hr = CComObject<CVssWriterImpl>::CreateInstance(&pImpl);
    if (ft.HrFailed())
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failed to create CVssWriterImpl.  hr = 0x%08lx",
            ft.hr
            );

    // set reference count of internal writer to 1
    pImpl->GetUnknown()->AddRef();

    // link external writer into internal writer
    pImpl->SetWriter(pWriter);

    // return internal writer interface
    *ppImpl = (IVssWriterImpl *) pImpl;
    }

// constructor for writer state
CVssWriterState::CVssWriterState(
    	IN	CVssDiag& diag
    ) :
    m_iPreviousSnapshots(0),
    m_bSequenceInProgress(false),
    m_diag(diag) 
    {
    // initialize current state
    m_currentState.m_state = VSS_WS_STABLE;
    m_currentState.m_idSnapshotSet = GUID_NULL;
    m_currentState.m_bInOperation = false;
    m_currentState.m_hrWriterFailure = S_OK;

    // initialize stack
    for(UINT i = 0; i < MAX_PREVIOUS_SNAPSHOTS; i++)
        {
        m_rgPreviousStates[i].m_idSnapshotSet = GUID_NULL;
        m_rgPreviousStates[i].m_state = VSS_WS_UNKNOWN;
        m_rgPreviousStates[i].m_bInOperation = false;
        m_rgPreviousStates[i].m_hrWriterFailure = E_UNEXPECTED;
        }
    }

// setup state at the beginning of a snapshot
void CVssWriterState::InitializeCurrentState(IN const VSS_ID &idSnapshot)
    {
    CVssSafeAutomaticLock lock(m_cs);

    // initalize snapshot id
    m_currentState.m_idSnapshotSet = idSnapshot;
    
    // indicate that there is no failure
    m_currentState.m_hrWriterFailure = S_OK;

    // clear that we are in an operation
    m_currentState.m_bInOperation = false;

    // indicate that sequence is in progress
    m_bSequenceInProgress = true;

    // current state is STABLE (i.e., beginning of sequence, clears
    // any completion state we were in)
    SetCurrentState(VSS_WS_STABLE);
    
    }

// push the current state
void CVssWriterState::PushCurrentState()
    {
    CVssSafeAutomaticLock lock(m_cs);

    if (m_bSequenceInProgress)
        {
        // Reset the sequence-related data members
        m_bSequenceInProgress = false;

        // We need to test to not add the same SSID twice - bug 228622.
        if (SearchForPreviousSequence(m_currentState.m_idSnapshotSet) == INVALID_SEQUENCE_INDEX)
            {
            BS_ASSERT(m_iPreviousSnapshots < MAX_PREVIOUS_SNAPSHOTS);
            VSWRITER_STATE *pState = &m_rgPreviousStates[m_iPreviousSnapshots];
            memcpy(pState, &m_currentState, sizeof(m_currentState));
            m_iPreviousSnapshots = (m_iPreviousSnapshots + 1) % MAX_PREVIOUS_SNAPSHOTS;
            }
        else
            BS_ASSERT(false); // The same SSID was already added - programming error.
        }
    }

// find the state for a previous snapshot set
INT CVssWriterState::SearchForPreviousSequence(IN const VSS_ID& idSnapshotSet)
    {
    CVssSafeAutomaticLock lock(m_cs);

    for(INT iSeqIndex = 0;
        iSeqIndex < MAX_PREVIOUS_SNAPSHOTS;
        iSeqIndex++)
        {
        if (idSnapshotSet == m_rgPreviousStates[iSeqIndex].m_idSnapshotSet)
            return iSeqIndex;
        } // end for

    return INVALID_SEQUENCE_INDEX;
    }


// obtain the state given the snapshot id
void CVssWriterState::GetStateForSnapshot
    (
    IN const VSS_ID &id,
    OUT VSWRITER_STATE &state
    )
    {
    // get lock on state class
    CVssSafeAutomaticLock lock(m_cs);
    
    if (id == GUID_NULL ||
        m_bSequenceInProgress && id == m_currentState.m_idSnapshotSet)
        {
        // get state for current snapshot set
        state = m_currentState;
        }
    else
        {
        // return state for a previously created snapshot set

        // Search for the previous sequence with the same ID
        INT nPreviousSequence = SearchForPreviousSequence(id);
        if (nPreviousSequence == INVALID_SEQUENCE_INDEX)
            {
            // don't have any information about the snapshot set
            state.m_idSnapshotSet = id;
            state.m_bInOperation = false;
            state.m_state = VSS_WS_UNKNOWN;
            state.m_hrWriterFailure = E_UNEXPECTED;
            }
        else
            {
            BS_ASSERT(m_rgPreviousStates[nPreviousSequence].m_idSnapshotSet == id);

            // return state from snapshot set
            state = m_rgPreviousStates[nPreviousSequence];
            }
        }
    }



// handle completion of the BackupComplete state.
void CVssWriterState::FinishBackupComplete(const VSS_ID &id)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterState::FinishBackupComplete");

    // lock class
    CVssSafeAutomaticLock lock(m_cs);

    // We must search for a previous state - Thaw already ended the sequence.
    INT iPreviousSequence = SearchForPreviousSequence(id);
    if (iPreviousSequence == INVALID_SEQUENCE_INDEX)
        {
        // couldn't find snapshot set.  We will indicate that this is
        // a retryable error
        SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);

        // unlock class before throwing
        ft.Throw
            (
            VSSDBG_WRITER,
            E_UNEXPECTED,
            L"Couldn't find a previous sequence with the same Snapshot Set ID"
            );
        }

    // We found a previous sequence with the same SSID.
    BS_ASSERT(id == m_rgPreviousStates[iPreviousSequence].m_idSnapshotSet);

    // BUG 228622 - If we do not have a previous successful Thaw transition
    // then we cannot call BackupComplete
    if (m_rgPreviousStates[iPreviousSequence].m_state != VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
        {
        SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);

        ft.Throw
            (
            VSSDBG_WRITER,
            E_UNEXPECTED,
            L"Couldn't call BackupComplete without OnThaw as a previous state [%d]",
            m_rgPreviousStates[iPreviousSequence].m_state
            );
        }

    // BUG 219692 - indicate that sequence is complete even in the saved states
    m_rgPreviousStates[iPreviousSequence].m_state = VSS_WS_STABLE;
    m_rgPreviousStates[iPreviousSequence].m_bInOperation = true;
    m_rgPreviousStates[iPreviousSequence].m_currentOperation = VSS_IN_BACKUPCOMPLETE;
    }

// indicate that backup complete failed
void CVssWriterState::SetBackupCompleteStatus(const VSS_ID &id, HRESULT hr)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterState::SetBackupCompleteFailed");

    // lock class
    CVssSafeAutomaticLock lock(m_cs);

    // We must search for a previous state - Thaw already ended the sequence.
    INT iPreviousSequence = SearchForPreviousSequence(id);
    if (iPreviousSequence == INVALID_SEQUENCE_INDEX)
        return;

    // We found a previous sequence with the same SSID.
    BS_ASSERT(id == m_rgPreviousStates[iPreviousSequence].m_idSnapshotSet);


    if (m_rgPreviousStates[iPreviousSequence].m_state == VSS_WS_STABLE ||
        m_rgPreviousStates[iPreviousSequence].m_state == VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
        {
        if (FAILED(hr))
            {
            // indicate failure and use current failure as the backup completion failure
            m_rgPreviousStates[iPreviousSequence].m_state = VSS_WS_FAILED_AT_BACKUP_COMPLETE;
            m_rgPreviousStates[iPreviousSequence].m_hrWriterFailure = m_currentState.m_hrWriterFailure;
            }

        m_rgPreviousStates[iPreviousSequence].m_bInOperation = false;
        }
    }


// no response error.  It first checks to see if we are still
// in the operation.  If not, then we need to retry obtaining
// the writer's state
bool CVssWriterState::SetNoResponseFailure(
    IN const VSS_ID &id, 
    IN const VSWRITER_STATE &state 
    )
    {
    // lock object
    CVssSafeAutomaticLock lock(m_cs);

    if (m_currentState.m_idSnapshotSet == state.m_idSnapshotSet)
        {
        if (!m_currentState.m_bInOperation ||
            m_currentState.m_currentOperation != state.m_currentOperation)
            {
            // no longer in the operation.  Should not return a no-response
            // failure.  Instead requery the current state
            return false;
            }

        // This should apply only if the ID is the current snapshot set ID
        //
        // The logic is that the writer is now hung from the backup app point of view.
        // We need to set the correct state now, so that the backup app knows what's wrong.
        //
        if ((m_currentState.m_idSnapshotSet == id) && (GUID_NULL != id))
            {
            SetCurrentFailure(VSS_E_WRITER_NOT_RESPONDING);
            SetCurrentState(state.m_state);
            }
        
        return true;
        }

    INT iPreviousSequence = SearchForPreviousSequence(state.m_idSnapshotSet);
    if (iPreviousSequence == INVALID_SEQUENCE_INDEX)
        return true;

    VSWRITER_STATE *pState = &m_rgPreviousStates[iPreviousSequence];
    if (!pState->m_bInOperation ||
        pState->m_currentOperation != state.m_currentOperation)
        {
        // no longer in the operation.  We should not return an no-response
        // failure.  Instead requery the state of the snapshot set.
        return false;
        }

    // indicate that writer is not responding
    pState->m_hrWriterFailure = VSS_E_WRITER_NOT_RESPONDING;

    // get last known state of writer
    pState->m_state = state.m_state;
    return true;
    }


//////////////////////////////////////////////////////////////////////////
// Auto diag class




// Constructor
CVssAutoDiagLogger::CVssAutoDiagLogger( 
    IN CVssWriterState & state,
    IN DWORD dwEventID,
    IN VSS_ID ssid, /* = GUID_NULL */
    IN DWORD dwEventFlags /* = 0 */
    ):
    m_state(state),
    m_dwEventID(dwEventID),
    m_ssid(ssid),
    m_dwEventFlags(dwEventFlags)
{
    m_state.GetDiag().RecordGenericEvent(m_dwEventID, 
        CVssDiag::VSS_DIAG_ENTER_OPERATION,
        m_state.GetCurrentState(), 
        m_state.GetCurrentFailure(), 
        m_ssid);
}


// Constructor
CVssAutoDiagLogger::CVssAutoDiagLogger( 
    IN CVssWriterState & state,
    IN DWORD dwEventID,
    IN WCHAR* pwszSSID,
    IN DWORD dwEventFlags /* = 0 */
    ):
    m_state(state),
    m_dwEventID(dwEventID),
    m_ssid(GUID_NULL),
    m_dwEventFlags(dwEventFlags)
{
    // Try to read the SSID
    if (pwszSSID)
        ::CLSIDFromString(W2OLE(pwszSSID), &m_ssid);
    
    m_state.GetDiag().RecordGenericEvent(m_dwEventID, 
        CVssDiag::VSS_DIAG_ENTER_OPERATION | m_dwEventFlags,
        m_state.GetCurrentState(), 
        m_state.GetCurrentFailure(), 
        m_ssid);
}


// Destructor
CVssAutoDiagLogger::~CVssAutoDiagLogger()
{
    m_state.GetDiag().RecordGenericEvent(m_dwEventID, 
        CVssDiag::VSS_DIAG_LEAVE_OPERATION | m_dwEventFlags,
        m_state.GetCurrentState(), 
        m_state.GetCurrentFailure(), 
        m_ssid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\vssapi\jetwriter.cpp ===
#include <stdafx.h>

#include <esent.h>
#include <comadmin.h>
#include "vs_inc.hxx"

#include "vs_idl.hxx"


#include "comadmin.hxx"
#include "vswriter.h"

#include <jetwriter.h>
#include <ijetwriter.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHJTWRC"
//
////////////////////////////////////////////////////////////////////////

// destructor
__declspec(dllexport) CVssJetWriter::~CVssJetWriter()
	{
	BS_ASSERT(m_pWriter == NULL);
	}


// routine for passing arguments between threads
typedef struct _JW_INIT_ARGS
	{
	VSS_ID idWriter;
	LPCWSTR wszWriterName;
	bool bSystemService;
	bool bBootableSystemState;
	LPCWSTR wszFilesToInclude;
	LPCWSTR wszFilesToExclude;
	CVssJetWriter *pobj;
	} JW_INIT_ARGS;


// separate MTA thread for doing initialization
DWORD CVssJetWriter::InitializeThreadFunc(VOID *pv)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"InitializeThreadFunc");

	JW_INIT_ARGS *pargs = (JW_INIT_ARGS *) pv;

	bool bCoInitialized = false;
	try
		{
		// intialize MTA thread
		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CoInitializeEx failed 0x%08lx", ft.hr
				);

		bCoInitialized = true;
        // call internal object to initialize
		ft.hr = CVssIJetWriter::Initialize
						(
						pargs->idWriter,
						pargs->wszWriterName,
						pargs->bSystemService,
						pargs->bBootableSystemState,
						pargs->wszFilesToInclude,
						pargs->wszFilesToExclude,
						pargs->pobj,
						&pargs->pobj->m_pWriter
						);


        if(ft.HrFailed())
            {
            //
            //  Add more granular error code - 
            //     752163  Application/Service might have inconsistent 
            //     backup for their data-store without any warning or other indication 
            //
            switch(ft.hr)
                {
                case E_INVALIDARG:
                case E_OUTOFMEMORY:
                case E_ACCESSDENIED:
                    ft.Throw(VSSDBG_GEN, ft.hr, 
                        L"CvssIJetWriter::Initialize failed");
                    
                default:
                    ft.Throw(VSSDBG_GEN, E_UNEXPECTED, 
                        L"CvssIJetWriter::Initialize failed [0x%08lx]", ft.hr);
                }
            }
		}
	VSS_STANDARD_CATCH(ft) 

	// save result of initialization
	pargs->pobj->m_hrInitialized = ft.hr;

	if (bCoInitialized)
		CoUninitialize();
	
	return 0;
	}


// initialize method on external thread
__declspec(dllexport) HRESULT CVssJetWriter::Initialize
	(
	IN GUID idWriter,
	IN LPCWSTR wszWriterName,
	bool bSystemService,
	bool bBootableSystemState,
	LPCWSTR wszFilesToInclude,
	LPCWSTR wszFilesToExclude
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::Initialize");

	try
		{
		DWORD tid;
		// setup arguments to thread
		JW_INIT_ARGS args;
		args.idWriter = idWriter;
		args.wszWriterName = wszWriterName;
		args.bSystemService = bSystemService;
		args.bBootableSystemState = bBootableSystemState;
		args.wszFilesToInclude = wszFilesToInclude;
		args.wszFilesToExclude = wszFilesToExclude;
		args.pobj = this;

		// create thread
		HANDLE hThread = CreateThread
								(
								NULL,
								256*1024,
                                CVssJetWriter::InitializeThreadFunc,
								&args,
								0,
								&tid
								);

        if (hThread == NULL)
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CreateThread failed with error %d",
				GetLastError()
				);

		// wait for thread to complete
        WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		}
	VSS_STANDARD_CATCH(ft)

	if (!ft.HrFailed())
		// get result of initialization
		ft.hr = m_hrInitialized;

	return ft.hr;
	}


__declspec(dllexport) void CVssJetWriter::Uninitialize()
	{
	// call uninitialize
	if (m_pWriter)
		{
		CVssIJetWriter::Uninitialize((PVSSIJETWRITER) m_pWriter);
		m_pWriter = NULL;
		}
	}

__declspec(dllexport) bool CVssJetWriter::OnIdentify(IVssCreateWriterMetadata *pIVssWriterMetadata)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnIdentify");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareBackupBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareBackupBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareBackupEnd(IN IVssWriterComponents *pIVssWriterComponents,
							     bool fJetPrepareSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareBackupEnd");
	return fJetPrepareSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareSnapshotBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareSnapshotBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareSnapshotEnd(bool fJetPrepareSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareSnapshotEnd");
	return fJetPrepareSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnFreezeBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnFreezeBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnFreezeEnd(bool fJetFreezeSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnFreezeEnd");
	return fJetFreezeSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnThawBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnThawBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnThawEnd(bool fJetThawSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnThawEnd");
	return fJetThawSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnPostSnapshot(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostSnapshot");
	return true;
	}


__declspec(dllexport) void CVssJetWriter::OnAbortBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnAbortBegin");
  	}

__declspec(dllexport) void CVssJetWriter::OnAbortEnd()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnAbortEnd");
  	}

__declspec(dllexport) bool CVssJetWriter::OnBackupCompleteBegin(IN IVssWriterComponents *pComponent)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnBackupCompleteBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnBackupCompleteEnd(IN IVssWriterComponents *pComponent,
							      bool fJetBackupCompleteSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnBackupCompleteEnd");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPreRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPreRestoreBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPreRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						       IN bool fJetRestoreSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPreRestoreEnd");
	return true;
  	}


__declspec(dllexport) bool CVssJetWriter::OnPostRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostRestoreBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPostRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						       IN bool fJetRestoreSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostRestoreEnd");
	return true;
  	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\writers\comregdbwriter.cxx ===
f/*++

Copyright (c) 2002  Microsoft Corporation

Abstract:

    @doc
    @module comregdbwriter.cxx | Implementation of the COM+ RegDB Writer
    @end

Author:

    Ran Kalach  [rankala]  05/17/2002


Revision History:

    Name        Date        Comments
    rankala     05/17/2002  created

--*/
#include "stdafx.h"
#include "vs_idl.hxx"
#include "vs_hash.hxx"

#include <vswriter.h>
#include <Sddl.h>

#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "vs_reg.hxx"
#include "comregdbwriter.hxx"
#include "allerror.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WRTCDBRC"
//
////////////////////////////////////////////////////////////////////////

static GUID s_writerId =
    {
    0x542da469, 0xd3e1, 0x473c, 0x9f, 0x4f, 0x78, 0x47, 0xf0, 0x1f, 0xc6, 0x4f
    };

//  The display name of the Event Log writer.
static LPCWSTR s_wszWriterName    = L"COM+ REGDB Writer";

//  The file group component name for the Event Log 
static LPCWSTR s_wszComponentName = L"COM+ REGDB";

//  The original location of the RegDB files
static CBsString s_cwsSystemComRegDBDir = L"%SystemRoot%\\Registration";

//  The backup/restore location of the RegDB files
static CBsString s_cwsComRegDBTargetDir = ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR L"\\ComRegistrationDatabase";

//  The backup/restore file name of the RegDB database
static CBsString s_cwsBackupFilename = L"\\ComRegDb.bak";

//  The COM+ System Applicationservice name
static LPCWSTR s_wszCOMSysAppServiceName = L"COMSysApp";

//  Class wide member variables
CComRegDBWriter *CComRegDBWriter::sm_pWriter = NULL;

// RegDB function declarations
typedef HRESULT (*PF_REG_DB_API)(BSTR);

//
//  Methods
//

HRESULT STDMETHODCALLTYPE CComRegDBWriter::Initialize()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::Initialize");

    try
    {
        ft.hr = CVssWriter::Initialize
            (
            s_writerId,
            s_wszWriterName,
            VSS_UT_BOOTABLESYSTEMSTATE,
            VSS_ST_OTHER,
            VSS_APP_SYSTEM,
            60000
            );

        if (ft.HrFailed())
            ft.TranslateGenericError
                (
                VSSDBG_WRITER,
                ft.hr,
                L"CVssWriter::Initialize(" WSTR_GUID_FMT L", %s)",
                GUID_PRINTF_ARG(s_writerId),
                s_wszWriterName
                );

        ft.hr = Subscribe();
        if (ft.HrFailed())
            ft.TranslateGenericError
                (
                VSSDBG_WRITER,
                ft.hr,
                L"CVssWriter::Subscribe for" WSTR_GUID_FMT L" %s)",
                GUID_PRINTF_ARG(s_writerId),
                s_wszWriterName
                );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

HRESULT STDMETHODCALLTYPE CComRegDBWriter::Uninitialize()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::Uninitialize");

    return Unsubscribe();
}


// handle request for WRITER_METADATA
// implements CVssWriter::OnIdentify
bool STDMETHODCALLTYPE CComRegDBWriter::OnIdentify(IVssCreateWriterMetadata *pMetadata)
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::OnIdentify");

    try
    {

        // Converted to CUSTOM restore method (see bug# 688278)
        #if 0

        //
        //  Set the restore method for the writer
        //
        ft.hr = pMetadata->SetRestoreMethod
            (
            VSS_RME_RESTORE_IF_CAN_REPLACE,
            NULL,
            NULL,
            VSS_WRE_ALWAYS,     // writer always involved
            false 
            );
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::SetRestoreMethod");

        #endif

        //
        //  Set the restore method for the writer
        //
        ft.hr = pMetadata->SetRestoreMethod
            (
            VSS_RME_CUSTOM,
            NULL,
            NULL,
            VSS_WRE_NEVER,     // writer never involved in restore
            false 
            );
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::SetRestoreMethod");

        //
        //  Exclude original location of COM+ RegDB files
        //
	    ft.hr = pMetadata->AddExcludeFiles
            (
            s_cwsSystemComRegDBDir, 
            L"*",
			true
            );
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::AddExcludeFiles");

        //
        //  Add the one file-group component
        //
    	ft.hr = pMetadata->AddComponent 
    	    (
            VSS_CT_FILEGROUP,
            NULL,
            s_wszComponentName,
            s_wszComponentName,
            NULL, // icon
            0,
            false,
            false,
            true 
            );
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::AddComponent");

        //
        //  Add files to the file group 
        //
		ft.hr = pMetadata->AddFilesToFileGroup 
            (
            NULL,
            s_wszComponentName,
            s_cwsComRegDBTargetDir,
            L"*",
            true,
            NULL
            );
       ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::AddFilesToFileGroup");			

    }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    return ft.HrSucceeded();
}

// Check whether the writer component is selected
// implements CVssWriter::OnPrepareSnapshot
bool STDMETHODCALLTYPE CComRegDBWriter::OnPrepareBackup(IN IVssWriterComponents *pWriterComponents)
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::OnPrepareBackup");


    try
    {
        m_bPerformSnapshot = FALSE;

        if ( AreComponentsSelected() )
        {
            // We are in component selection mode...
            UINT cComponents;

            ft.hr = pWriterComponents->GetComponentCount( &cComponents );
            ft.CheckForErrorInternal( VSSDBG_WRITER, L"IVssWriterComponents::GetComponentCount" );

            if (cComponents > 0)
                // This writer has only one component so this means the component is selected
                m_bPerformSnapshot = TRUE;
        }

    } 
    VSS_STANDARD_CATCH( ft );

    TranslateWriterError(ft.hr);

    ft.Trace(VSSDBG_WRITER, L"CComRegDBWriter returning with hresult 0x%08lx", ft.hr);
    
    return ft.HrSucceeded();
}

// Backup the database
// implements CVssWriter::OnPrepareSnapshot
bool STDMETHODCALLTYPE CComRegDBWriter::OnPrepareSnapshot()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::OnPrepareSnapshot");

    HMODULE hRegDbDll = NULL;

    try
    {
        CBsString cwsExpanded;
        if (!cwsExpanded.ExpandEnvironmentStrings(s_cwsComRegDBTargetDir))
        {
       	    ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(::GetLastError()), 
       		    L"CBsString::ExpandEnvironmentStrings");
        }

    	// Make sure that we don't backup up old stuff in the COM+ RegDB backup dir
        // (Do this even if this writer is not supposed to spit such that we don't backup old data)
        ft.hr = ::RemoveDirectoryTree(cwsExpanded);	
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"::RemoveDirectoryTree");
	
	    ft.hr = ::CreateTargetPath(cwsExpanded);
	    ft.CheckForErrorInternal(VSSDBG_WRITER, L"::CreateTargetPath");

        
        // Spit only if component is selected or this is a BootableSystemState backup
        if ( !m_bPerformSnapshot && IsBootableSystemStateBackedUp() )
            m_bPerformSnapshot = TRUE;

  	    if (m_bPerformSnapshot) 
        {
            //
            // Backup the Com+ RegDB
            //

            // Load DLL and Get backup-func address
        	hRegDbDll = LoadLibrary(L"catsrvut.dll");
            if (hRegDbDll == NULL)
       	        ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(::GetLastError()), 
       		        L"LoadLibrary catsrvut.dll");

            PF_REG_DB_API pfRegDBBackup;
	        pfRegDBBackup = (PF_REG_DB_API)GetProcAddress(hRegDbDll, "RegDBBackup");
            if (pfRegDBBackup == NULL)
       	        ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(::GetLastError()), 
       		        L"GetProcAddress RegDBBackup catsrvut.dll");

            // Add file-name to backup path
            cwsExpanded += s_cwsBackupFilename;

            // Call backup function
            CComBSTR bstrExpanded = cwsExpanded;
			if (bstrExpanded.Length() == 0)
				ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Memory allocation error");
            ft.hr = pfRegDBBackup(bstrExpanded);
            if (ft.HrFailed())
                ft.TranslateGenericError
                    (
                    VSSDBG_WRITER,
                    ft.hr,
                    L"::RegDBBackup(%s)",
                    bstrExpanded
                    );
        }
    } 
    VSS_STANDARD_CATCH( ft );

    TranslateWriterError(ft.hr);

    if (hRegDbDll != NULL) {
        FreeLibrary(hRegDbDll);
        hRegDbDll = NULL;
    }

    ft.Trace(VSSDBG_WRITER, L"CComRegDBWriter returning with hresult 0x%08lx", ft.hr);
    
    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CComRegDBWriter::OnFreeze()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::OnFreeze");

    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CComRegDBWriter::OnThaw()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::OnThaw");

    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CComRegDBWriter::OnAbort()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::OnAbort");

    return ft.HrSucceeded();
}


// Converted to CUSTOM restore method (see bug# 688278)
#if 0


// Clean-up restore directory
// implements CVssWriter::OnPreRestore
bool STDMETHODCALLTYPE CComRegDBWriter::OnPreRestore(IVssWriterComponents *pComponent)
{
    UNREFERENCED_PARAMETER(pComponent);

    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::OnPreRestore");

    try
    {
        //
        // Note: There is no need to check for selected components here since the writer is being
        //       called during restore only if its component (there's only one) is being selected
        //
        CBsString cwsExpanded;
        if (!cwsExpanded.ExpandEnvironmentStrings(s_cwsComRegDBTargetDir))
        {
       	    ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(::GetLastError()), 
       		    L"CBsString::ExpandEnvironmentStrings");
        }

    	// make sure that we don't mix up old stuff with the new restore in the COM+ RegDB backup dir
        ft.hr = ::RemoveDirectoryTree(cwsExpanded);	
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"::RemoveDirectoryTree");
	
	    ft.hr = ::CreateTargetPath(cwsExpanded);
	    ft.CheckForErrorInternal(VSSDBG_WRITER, L"::CreateTargetPath");
	    
    } 
    VSS_STANDARD_CATCH( ft );

    TranslateWriterError(ft.hr);

    ft.Trace(VSSDBG_WRITER, L"CComRegDBWriter returning with hresult 0x%08lx", ft.hr);
    
    return ft.HrSucceeded();
}

// Restore files using a legacy COM+ API
// implements CVssWriter::OnPostRestore
bool STDMETHODCALLTYPE CComRegDBWriter::OnPostRestore(IVssWriterComponents *pComponent)
{
    UNREFERENCED_PARAMETER(pComponent);

    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::OnPostRestore");

    HMODULE hRegDbDll = NULL;

    try
    {
        //
        // Note: There is no need to check for selected components here since the writer is being
        //       called during restore only if its component (there's only one) is being selected
        //
        CBsString cwsExpanded;
        if (!cwsExpanded.ExpandEnvironmentStrings(s_cwsComRegDBTargetDir))
        {
       	    ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(::GetLastError()), 
       		    L"CBsString::ExpandEnvironmentStrings");
        }

        // Add file-name to backup path
        cwsExpanded += s_cwsBackupFilename;

        CComBSTR bstrExpanded = cwsExpanded;
    	if (bstrExpanded.Length() == 0)
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Memory allocation error");

        //
        // Restore the Com+ RegDB
        // Use similar approach to ICOMAdminCatalog::RestoreREGDB (implemented by CCatalog2::RestoreREGDB)
        //

        // Load DLL and Get restore-func address
        hRegDbDll = LoadLibrary(L"catsrvut.dll");
        if (hRegDbDll == NULL)
       	    ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(::GetLastError()), 
       		    L"LoadLibrary catsrvut.dll");

        PF_REG_DB_API pfRegDBRestore;
	    pfRegDBRestore = (PF_REG_DB_API)GetProcAddress(hRegDbDll, "RegDBRestore");
        if (pfRegDBRestore == NULL)
       	    ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(::GetLastError()), 
       		    L"GetProcAddress RegDBRestore catsrvut.dll");

        // Stop the COMSysApp service (best effort - continue if we fail)
        StopCOMSysAppService(); // should we log a warning here?

        // Call restore function
        for (int iRetry = 0; iRetry < 5; iRetry++) {
            ft.hr = pfRegDBRestore(bstrExpanded);
            if (ft.HrSucceeded())
                break;
			else if (ft.hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
                ft.TranslateGenericError
                    (
                    VSSDBG_WRITER,
                    ft.hr,
                    L"::RegDBRestore(%s)",
                    bstrExpanded
                    );

            Sleep(1000);
		}

        if (! ft.HrSucceeded())
            ft.TranslateGenericError
                (
                VSSDBG_WRITER,
                ft.hr,
                L"::RegDBRestore(%s)",
                bstrExpanded
                );

    } 
    VSS_STANDARD_CATCH( ft );

    TranslateWriterError(ft.hr);

    ft.Trace(VSSDBG_WRITER, L"CComRegDBWriter returning with hresult 0x%08lx", ft.hr);
    
    return ft.HrSucceeded();
}
#endif


// translate a sql writer error code into a writer error
void CComRegDBWriter::TranslateWriterError( HRESULT hr )
{
    //
    // To DO: Check whether the spit backup/restore methods return any "RETRYABLE" errors
    //
    switch(hr)
    {
        default:
            SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            break;

        case S_OK:
            break;

        case E_OUTOFMEMORY:
        case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
        case HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES):
        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES):
            SetWriterFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            break;
    }
}

//  Creates one instance of the Event Log writer class.  If one already exists, it simple returns.
//  Note: This method is not MT-safe - it is not expected that it will be called twice at the same time
HRESULT CComRegDBWriter::CreateWriter()
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::CreateWriter");
    
    if ( sm_pWriter != NULL )
        return S_OK;

    //
    //  Create and initialize a writer
    //
	try
	{
		sm_pWriter = new CComRegDBWriter;
		if (sm_pWriter == NULL)
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Allocation of CComRegDBWriter object failed.");

        ft.hr = sm_pWriter->Initialize();
        if (! ft.HrSucceeded())
			ft.Throw(VSSDBG_WRITER, ft.hr, L"Initialization of CComRegDBWriter object failed.");
    } 
    VSS_STANDARD_CATCH(ft);

	return ft.hr;    
}

// static
void CComRegDBWriter::DestroyWriter()
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::DestroyWriter");
	
	if (sm_pWriter)
	{
		sm_pWriter->Uninitialize();
		delete sm_pWriter;
		sm_pWriter = NULL;
	}
}

//
// Stop the COMSysApp service if exists
//
HRESULT STDMETHODCALLTYPE CComRegDBWriter::StopCOMSysAppService()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CComRegDBWriter::StopCOMSysAppService");

    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;

    try
    {
        SERVICE_STATUS svcStatus;
        BOOL bWait = TRUE;
        BOOL bStop = TRUE;

        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(GetLastError()), L"::OpenSCManager");

        hService = OpenService(hSCM, s_wszCOMSysAppServiceName, (SERVICE_STOP | SERVICE_QUERY_STATUS));
        if (hService == NULL) {
            DWORD dwErr = GetLastError();

            switch (dwErr) {

            case ERROR_SERVICE_DOES_NOT_EXIST:
                // No such service (maybe ASR mode, service is not registered yet), no need to stop or wait
                bStop = FALSE;
                bWait = FALSE;
                break;

            default:
                // Any other error is unexpected
       	        ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(dwErr), L"::OpenService");
                break;
            }
        }

        // Stop the service
        if (bStop) {
            // Retry couple of times if the service caanot accept controls
            for (int iRetry = 0; iRetry < 5; iRetry++) {
                memset(&svcStatus, 0, sizeof(svcStatus));
                if (! ControlService(hService, SERVICE_CONTROL_STOP, &svcStatus)) {
                    DWORD dwErr = GetLastError();

                    switch (dwErr) {

                    case ERROR_SERVICE_NOT_ACTIVE:
                        // Service is not running, no need to wait
                        bWait = FALSE;
                        break;

                    case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
                        // Service may be at STOP_PENDING or START_PENDING, retry
                        break;

                    default:
                        // Any other error is unexpected
       	                ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(dwErr), L"::ControlService");
                        break;
                    }

                    if (! bWait)
                        // Service not active
                        break;

                    // Sleep before retry
                    Sleep(2000);

                } else {
                    // Success, no need to retry
                    break;
                }
            }
        }

        if (bWait) {
            // Wait till service is stopped. 30 seconds max
            DWORD dwWaitTime = 0;
            while (TRUE) {
                memset(&svcStatus, 0, sizeof(svcStatus));
                if (! QueryServiceStatus(hService, &svcStatus))
       	            ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(GetLastError()), L"::QueryServiceStatus");

                if (svcStatus.dwCurrentState == SERVICE_STOPPED)
                    break;

                Sleep(1000);
                dwWaitTime += 1000;
                if (dwWaitTime >= (30 * 1000))
                    ft.TranslateGenericError(
                        VSSDBG_WRITER, 
                        HRESULT_FROM_WIN32(ERROR_SERVICE_CANNOT_ACCEPT_CTRL),
                        L"ControlService (%s, SERVICE_CONTROL_STOP)",
                        s_wszCOMSysAppServiceName
                        );
            }
        }
    } 
    VSS_STANDARD_CATCH( ft );

    if (hService != NULL) {
        CloseServiceHandle(hService);
        hService = NULL;
    }
    if (hSCM != NULL) {
        CloseServiceHandle(hSCM);
        hSCM = NULL;
    }
   
    return (ft.hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\writers\evtlogwriter.cxx ===
f/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module evtlogwriter.cxx | Implementation of the Event Log Writer
    @end

Author:

    Stefan Steiner  [SSteiner]  07/26/2001

TBD:


Revision History:

    Name        Date        Comments
    ssteiner    07/26/2001  created

--*/
#include "stdafx.h"
#include "vs_idl.hxx"
#include "vs_hash.hxx"

#include <vswriter.h>
#include <Sddl.h>

#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "vs_reg.hxx"
#include "evtlogwriter.hxx"
#include "allerror.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WRTEVTRC"
//
////////////////////////////////////////////////////////////////////////

static GUID s_writerId =
    {
    0xeee8c692, 0x67ed, 0x4250, 0x8d, 0x86, 0x39, 0x6, 0x3, 0x7, 0xd, 0x00
    };

//  The display name of the Event Log writer.
static LPCWSTR s_wszWriterName    = L"Event Log Writer";

//  The file group component name for the Event Log 
static LPCWSTR s_wszComponentName = L"Event Logs";

// The Registry key that contains event-log information
static LPCWSTR s_wszLogKey = L"SYSTEM\\CurrentControlSet\\Services\\Eventlog";

// The value field that contains the the event-log file
static LPCWSTR s_wszLogFile = L"File";

//  The location of where the Event Log will be copied.
static CBsString s_cwsEventLogsTargetDir = ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR L"\\EventLogs";

//  The location of the Event Log
static CBsString s_cwsSystemEventLogDir = L"%SystemRoot%\\system32\\config";

// The mask specifying which files to exclude from backup
static CBsString s_cwsSystemEventLogFiles = L"*.evt";

//  Class wide member variables
CEventLogWriter *CEventLogWriter::sm_pWriter;
HRESULT CEventLogWriter::sm_hrInitialize;

HRESULT STDMETHODCALLTYPE CEventLogWriter::Initialize()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::Initialize");

    try
    {
        ft.hr = CVssWriter::Initialize
            (
            s_writerId,
            s_wszWriterName,
            VSS_UT_SYSTEMSERVICE,
            VSS_ST_OTHER,
            VSS_APP_SYSTEM,
            60000
            );

        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Failed to initialize the Event Log writer.  hr = 0x%08lx",
                ft.hr
                );

        ft.hr = Subscribe();
        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Subscribing the Event Log server writer failed. hr = %0x08lx",
                ft.hr
                );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

HRESULT STDMETHODCALLTYPE CEventLogWriter::Uninitialize()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::Uninitialize");

    return Unsubscribe();
}


// handle request for WRITER_METADATA
// implements CVssWriter::OnIdentify
bool STDMETHODCALLTYPE CEventLogWriter::OnIdentify(IVssCreateWriterMetadata *pMetadata)
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::OnIdentify");

    try
    {
        //
        //  Set the restore method for the writer
        //
        ft.hr = pMetadata->SetRestoreMethod
            (
            VSS_RME_RESTORE_AT_REBOOT,
            NULL,
            NULL,
            VSS_WRE_NEVER,
            true 
            );
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::SetRestoreMethod");

        //
        //  Add the one file component
        //
    	ft.hr = pMetadata->AddComponent 
    	    (
            VSS_CT_FILEGROUP,
            NULL,
            s_wszComponentName,
            s_wszComponentName,
            NULL, // icon
            0,
            false,
            false,
            true 
            );
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::AddComponent");

       AddExcludes(pMetadata);
       ScanLogs();
       AddLogs(pMetadata);
    }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CEventLogWriter::OnPrepareSnapshot()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::OnPrepareSnapshot");

    try
    {
       CBsString cwsExpanded;
       if (!cwsExpanded.ExpandEnvironmentStrings(s_cwsEventLogsTargetDir))
       {
       	ft.TranslateError(VSSDBG_WRITER, HRESULT_FROM_WIN32(::GetLastError()), 
       		L"CBsString::ExpandEnvironmentStrings");
       }

    	// make sure that we don't backup up old stuff in the event log backup dir
       ft.hr = ::RemoveDirectoryTree(cwsExpanded);	
       ft.CheckForErrorInternal(VSSDBG_WRITER, L"::RemoveDirectoryTree");
	
	ft.hr = ::CreateTargetPath(cwsExpanded);
	ft.CheckForError(VSSDBG_WRITER, L"::CreateTargetPath");
	
    	if (IsPathAffected(s_cwsSystemEventLogDir))
	    	BackupLogs();
    } 
    VSS_STANDARD_CATCH( ft );

    TranslateWriterError(ft.hr);

    ft.Trace(VSSDBG_WRITER, L"CEventLogWriter returning with hresult 0x%08lx", ft.hr);
    
    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CEventLogWriter::OnFreeze()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::OnFreeze");

    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CEventLogWriter::OnThaw()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::OnThaw");

    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CEventLogWriter::OnAbort()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::OnAbort");

    return ft.HrSucceeded();
}

bool CEventLogWriter::IsPathInSnapshot(const WCHAR *wszPath) throw()
{
    return IsPathAffected(wszPath);
}

// translate a sql writer error code into a writer error
void CEventLogWriter::TranslateWriterError( HRESULT hr )
{
    switch(hr)
    {
        default:
            SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            break;

        case S_OK:
            break;

        case E_OUTOFMEMORY:
        case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
        case HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES):
        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES):
            SetWriterFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            break;
    }
}

//  Creates one instance of the Event Log writer class.  If one already exists, it simple returns.
// static
HRESULT CEventLogWriter::CreateWriter()
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::CreateWriter");
    
    if ( sm_pWriter != NULL )
        return S_OK;

    //
    //  OK, spin up a thread to do the subscription in.
    //
	try
	{
		sm_pWriter = new CEventLogWriter;
		if (sm_pWriter == NULL)
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Allocation of CEventLogWriter object failed.");

		DWORD tid;

		HANDLE hThread = ::CreateThread
							(
							NULL,
							256* 1024,
							InitializeThreadFunc,
							NULL,
							0,
							&tid
							);

		if (hThread == NULL)
			ft.Throw
				(
				VSSDBG_WRITER,
				E_UNEXPECTED,
				L"CreateThread failed with error %d",
				::GetLastError()
				);

		// wait for thread to complete
        ::WaitForSingleObject( hThread, INFINITE );
		::CloseHandle( hThread );
		ft.hr = sm_hrInitialize;
	}
	VSS_STANDARD_CATCH(ft)
	    
	if (ft.HrFailed() && sm_pWriter)
	{
		delete sm_pWriter;
		sm_pWriter = NULL;
	}

	return ft.hr;    
}

void CEventLogWriter::FreeLogs()
{
	// free event-log information
	for (int x = 0; x < m_eventLogs.GetSize(); x++)
	{
		::VssFreeString(m_eventLogs[x].m_pwszName);
		::VssFreeString(m_eventLogs[x].m_pwszFileName);
	}

	m_eventLogs.RemoveAll();
}

void CEventLogWriter::ScanLogs()
{
	CVssFunctionTracer ft (VSSDBG_WRITER, L"CEventLogWriter::ScanLogs");

	FreeLogs();
	
	// open the main registry key
	CVssRegistryKey hkeyEventLogList (KEY_READ);
	if (!hkeyEventLogList.Open(HKEY_LOCAL_MACHINE, s_wszLogKey))
	{
		ft.Trace (VSSDBG_WRITER, L"Failed to open registry key: %s", s_wszLogKey);
		return;
	}

	CVssRegistryKeyIterator iterator;
	iterator.Attach (hkeyEventLogList);

	// for each subkey corresponding to a log
	while (!iterator.IsEOF())
	{
		EventLog currentLog;
		
		// --- get the file entry
		CVssRegistryKey hkeyEventLog(KEY_QUERY_VALUE);
		if (!hkeyEventLog.Open(hkeyEventLogList.GetHandle(), iterator.GetCurrentKeyName()))
		{
			ft.Throw(VSSDBG_WRITER, E_UNEXPECTED, 
				L"Failed to open registry entry for event log %s", iterator.GetCurrentKeyName());
		}

		CVssAutoPWSZ pwszFileName;
		hkeyEventLog.GetValue(s_wszLogFile, pwszFileName.GetRef(), false);
		if (pwszFileName.GetRef()  == NULL)
		{
			ft.Trace(VSSDBG_WRITER, 
				L"Error reading File value for event log %s", iterator.GetCurrentKeyName());
			iterator.MoveNext();
			continue;
		}

		// ensure that the name has at least a single \ in it
   		if (wcschr(pwszFileName, DIR_SEP_CHAR) == NULL)
   		{
			ft.Trace(VSSDBG_WRITER, 
				L"Error in the File value for event log %s", iterator.GetCurrentKeyName());
			iterator.MoveNext();
			continue;
   		}
   		
		// --- get the name of the log
		CVssAutoPWSZ pwszName;
		if (!pwszName.CopyFrom(iterator.GetCurrentKeyName()))
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Failed to allocate memory for event log name");
			

		// -- add the information to the list
		currentLog.m_pwszFileName = pwszFileName;
		currentLog.m_pwszName = pwszName;
		if (!m_eventLogs.Add(currentLog))
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Failed to add entry to list");

		pwszFileName.Detach();
		pwszName.Detach();

		iterator.MoveNext();
	}
}

void CEventLogWriter::AddExcludes(IVssCreateWriterMetadata* pMetadata)
{
	CVssFunctionTracer ft (VSSDBG_WRITER, L"CEventLogWriter::AddExcludes");

	pMetadata->AddExcludeFiles(s_cwsSystemEventLogDir, s_cwsSystemEventLogFiles,
							false);
}

void CEventLogWriter::AddLogs(IVssCreateWriterMetadata* pMetadata)
{
	CVssFunctionTracer ft (VSSDBG_WRITER, L"CEventLogWriter::AddLogs");

	// add each log file to the component
	for (int x = 0; x < m_eventLogs.GetSize(); x++)
	{
		CVssAutoPWSZ pwszEventPath;
		if (!pwszEventPath.CopyFrom(m_eventLogs[x].m_pwszFileName))
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Failed to allocate memory for event log name");

		// --- seperate out the path, and add to the component
		VSS_PWSZ pwszEventFile = wcsrchr(pwszEventPath, DIR_SEP_CHAR);
		BS_ASSERT(pwszEventFile != NULL);
		
		*pwszEventFile = L'\0';
		++pwszEventFile;

		ft.hr = pMetadata->AddFilesToFileGroup 
                (NULL,
                s_wszComponentName,
                pwszEventPath,
                pwszEventFile,
                false,
                s_cwsEventLogsTargetDir
                );
              ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::AddFilesToFileGroup");			
	}
}

void CEventLogWriter::BackupLogs()
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::BackupLogs");

	// back up each event log
	for (int x = 0; x < m_eventLogs.GetSize(); x++)
	{
		BS_ASSERT(m_eventLogs[x].m_pwszName != NULL);
		BS_ASSERT(m_eventLogs[x].m_pwszName != NULL);
		
		CVssAutoWin32EventLogHandle hLog = 
			::OpenEventLog(NULL, m_eventLogs[x].m_pwszName);
		if (hLog == NULL)
		{
			ft.Throw(VSSDBG_WRITER, E_UNEXPECTED, 
				L"Failed to open event log %s.  [0x%08lx]", m_eventLogs[x].m_pwszName, ::GetLastError());
		}

		// --- build up the path that we will back up to
		VSS_PWSZ pwszBackupFile = ::wcsrchr(m_eventLogs[x].m_pwszFileName, DIR_SEP_CHAR);
		BS_ASSERT(pwszBackupFile != NULL);

		CBsString cwsBackupPath;
		cwsBackupPath.ExpandEnvironmentStrings(s_cwsEventLogsTargetDir);
		cwsBackupPath += pwszBackupFile;

		// --- NOTE: There's a potential failure scenario here.  If two different event logs have the same filename
		// --- in different directories, they will overwrite each other in the spit directory.  This will be fixed when the
		// --- writer is altered to be an in-place writer
		if (::BackupEventLog(hLog, cwsBackupPath) == FALSE)
		{
			ft.Throw(VSSDBG_WRITER, E_UNEXPECTED,
				L"Failed to backup event log %s to %s.  [0x%08lx]", m_eventLogs[x].m_pwszName,
												cwsBackupPath, ::GetLastError());
		}
	}
}

// static
DWORD CEventLogWriter::InitializeThreadFunc(VOID *pv)
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::InitializeThreadFunc");

	BOOL fCoinitializeSucceeded = false;

	try
	{
		// intialize MTA thread
		ft.hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_WRITER,
				E_UNEXPECTED,
				L"CoInitializeEx failed 0x%08lx", ft.hr
				);

        fCoinitializeSucceeded = true;

        //  Now initialize the base class and subscribe
		ft.hr = sm_pWriter->Initialize();
	}
	VSS_STANDARD_CATCH(ft)

	if (fCoinitializeSucceeded)
		CoUninitialize();

	sm_hrInitialize = ft.hr;
	return 0;

	UNREFERENCED_PARAMETER( pv );
}

// static
void CEventLogWriter::DestroyWriter()
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CEventLogWriter::DestroyWriter");
	
	if (sm_pWriter)
	{
		sm_pWriter->Uninitialize();
		delete sm_pWriter;
		sm_pWriter = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\writers\regwriter.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module regwriter.cxx | Implementation of the Registry Writer
    @end

Author:

    Stefan Steiner  [SSteiner]  07/23/2001

TBD:


Revision History:

    Name        Date        Comments
    ssteiner    07/23/2001  created

--*/
#include "stdafx.h"
#include "vs_idl.hxx"
#include "vs_hash.hxx"

#include <vswriter.h>
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "regwriter.hxx"
#include "allerror.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WRTREGRC"
//
////////////////////////////////////////////////////////////////////////

static GUID s_writerId =
    {
    0xAFBAB4A2, 0x367D, 0x4D15, 0xA5, 0x86, 0x71, 0xDB, 0xB1, 0x8F, 0x84, 0x85
    };

//  The display name of the registry writer.
static LPCWSTR s_wszWriterName    = L"Registry Writer";

//  The file group component name for the system registry hives
static LPCWSTR s_wszComponentName = L"Registry";

#define VALUE_NAME_MACHINE  L"\\REGISTRY\\MACHINE\\"
#define VALUE_NAME_USER     L"\\REGISTRY\\USER\\"


struct SRegistryHiveEntry
{
    LPCWSTR wszHiveFileName;
    HKEY hKey;
    LPCWSTR wszHiveName;
};

//  The list of system registry hives that are handled by this writer
static SRegistryHiveEntry s_sSystemRegistryHives[] = 
    { 
        { L"default",   HKEY_USERS,         L".DEFAULT" },
        { L"SAM",       HKEY_LOCAL_MACHINE, L"SAM"      },
        { L"SECURITY",  HKEY_LOCAL_MACHINE, L"SECURITY" },
        { L"software",  HKEY_LOCAL_MACHINE, L"SOFTWARE" }, 
        { L"system",    HKEY_LOCAL_MACHINE, L"SYSTEM"   },
        { NULL,         HKEY_LOCAL_MACHINE, NULL       }
    };

//  The list of extensions found on registry hive files that will be placed in the exclude list if they are found.
static LPCWSTR s_wszRegistryExt[] = 
    { 
        L"",        // Causes the hive file itself to be excluded
        L".LOG", 
        L".sav", 
        L".tmp.LOG", 
        L".alt", 
        NULL 
    };

//  The location of where the registry hives will be copied.
static CBsString s_cwsRegistryTargetDir = ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR L"\\Registry";

//  The location of the system registry hives
static CBsString s_cwsSystemRegistryHiveDir = L"%SystemRoot%\\system32\\config";

//  The location of the repair directory where the spit hives will be copied during thaw
static CBsString s_cwsRepairDir = L"%SystemRoot%\\repair";

//  Class wide member variables
CRegistryWriter *CRegistryWriter::sm_pWriter;
HRESULT CRegistryWriter::sm_hrInitialize;
    
HRESULT STDMETHODCALLTYPE CRegistryWriter::Initialize()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::Initialize");

    try
    {
        m_bPerformSnapshot    = FALSE;
        m_bSnapshotSuccessful = FALSE;

        ft.hr = CVssWriter::Initialize
            (
            s_writerId,
            s_wszWriterName,
            VSS_UT_BOOTABLESYSTEMSTATE,
            VSS_ST_OTHER,
            VSS_APP_SYSTEM,
            60000
            );

        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Failed to initialize the Registry writer.  hr = 0x%08lx",
                ft.hr
                );

        ft.hr = Subscribe();
        if (ft.HrFailed())
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Subscribing the Registry server writer failed. hr = %0x08lx",
                ft.hr
                );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

HRESULT STDMETHODCALLTYPE CRegistryWriter::Uninitialize()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::Uninitialize");

    return Unsubscribe();
}


// handle request for WRITER_METADATA
// implements CVssWriter::OnIdentify
bool STDMETHODCALLTYPE CRegistryWriter::OnIdentify(IVssCreateWriterMetadata *pMetadata)
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::OnIdentify");

    try
    {
        //
        //  Set up common path strings if OnIdentify hasn't been called before.
        //
        if ( m_cwsExpandedConfigDir.IsEmpty() )
        {
            if ( !m_cwsExpandedConfigDir.ExpandEnvironmentStrings( s_cwsSystemRegistryHiveDir ) )
            {
                ft.TranslateError( VSSDBG_WRITER, HRESULT_FROM_WIN32( ::GetLastError() ), L"CBsString::ExpandEnvironmentStrings" );
            }
        }

        if ( m_cwsExpandedRegistryTargetDir.IsEmpty() )
        {
            if ( !m_cwsExpandedRegistryTargetDir.ExpandEnvironmentStrings( s_cwsRegistryTargetDir ) )
            {
                ft.TranslateError( VSSDBG_WRITER, HRESULT_FROM_WIN32( ::GetLastError() ), L"CBsString::ExpandEnvironmentStrings" );
            }
        }

        //
        //  Set the restore method for the writer
        //
        ft.hr = pMetadata->SetRestoreMethod
            (
            VSS_RME_CUSTOM,
            NULL,
            NULL,
            VSS_WRE_NEVER,
            true 
            );
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::SetRestoreMethod");

        //
        //  Add the one file component
        //
    	ft.hr = pMetadata->AddComponent 
    	    (
            VSS_CT_FILEGROUP,
            NULL,
            s_wszComponentName,
            s_wszComponentName,
            NULL, // icon
            0,
            false,
            false,
            true 
            );
        ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::AddComponent");

        //
        //  Add a file group file entry for each hive
        //
        INT iHive;
        for ( iHive = 0 ; s_sSystemRegistryHives[ iHive ].wszHiveFileName != NULL ; ++iHive )
        {        
            ft.hr = pMetadata->AddFilesToFileGroup 
                (
                NULL,
                s_wszComponentName,
                s_cwsRegistryTargetDir,
                s_sSystemRegistryHives[ iHive ].wszHiveFileName,
                false,
                NULL
                );
            ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::AddFilesToFileGroup");
        }
        
        //
        //  Determine list of auxiliary registry files that are to be excluded in the metadata.  Sniff the
        //  config directory for each file.
        //
        for ( iHive = 0 ; s_sSystemRegistryHives[ iHive ].wszHiveFileName != NULL ; ++iHive )
        {
            CBsString cwsHivePath =  m_cwsExpandedConfigDir + L'\\';
            cwsHivePath += s_sSystemRegistryHives[ iHive ].wszHiveFileName;

            for ( INT iExt = 0 ; s_wszRegistryExt[ iExt ] != NULL ; ++iExt )
            {
                CBsString cwsFilePath = cwsHivePath + s_wszRegistryExt[ iExt ];
                
                //  Test for existence.
                if ( ::GetFileAttributesW( cwsFilePath ) != 0xFFFFFFFF )
                {
                    //  File exists, add it to the exclude list
                	ft.hr = pMetadata->AddExcludeFiles 
                	    (
                	    s_cwsSystemRegistryHiveDir,
                        CBsString( s_sSystemRegistryHives[ iHive ].wszHiveFileName ) + s_wszRegistryExt[ iExt ],
                        false
                        );
                    ft.CheckForErrorInternal(VSSDBG_WRITER, L"IVssCreateWriterMetadata::AddExcludeFiles");                    
                }
            }
        }        
    }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    return ft.HrSucceeded();
}

bool STDMETHODCALLTYPE CRegistryWriter::OnPrepareBackup(
    IN IVssWriterComponents *pWriterComponents
    )
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::OnPrepareBackup");

    try
    {
        //
        //  If the requestor has selected components, see if the Registry component
        //  has been selected.
        //
        if ( AreComponentsSelected() )
        {
            UINT cComponents;

            m_bPerformSnapshot = FALSE;
            
            ft.hr = pWriterComponents->GetComponentCount( &cComponents );
            ft.CheckForErrorInternal( VSSDBG_WRITER, L"IVssWriterComponents::GetComponentCount" );
            for( UINT iComponent = 0; iComponent < cComponents; iComponent++ )
            {
                //  Check to make sure the Registry component is selected.
                CComPtr<IVssComponent> pComponent;

                ft.hr = pWriterComponents->GetComponent( iComponent, &pComponent );
                ft.CheckForErrorInternal( VSSDBG_WRITER, L"IVssWriterComponents::GetComponent" );                
                
                CComBSTR bstrComponentName;
                ft.hr = pComponent->GetComponentName( &bstrComponentName);
                ft.CheckForErrorInternal( VSSDBG_WRITER, L"IVssComponent::GetComponentName" );

                if ( ::_wcsicmp( s_wszComponentName, bstrComponentName ) == 0 )
                {
                    //  The registry component has been selected
                    ft.Trace( VSSDBG_WRITER, L"Registry writer 'Registry' component selected, writer will copy registry hives" );
                    m_bPerformSnapshot = TRUE;
                    break;
                }                
            }
        }
        else
        {
            ft.Trace( VSSDBG_WRITER, L"No Registry writer components selected" );
        }
    }
    VSS_STANDARD_CATCH( ft );

    TranslateWriterError(ft.hr);

    return ft.HrSucceeded();
}

bool STDMETHODCALLTYPE CRegistryWriter::OnPrepareSnapshot()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::OnPrepareSnapshot");

    DWORD winStatus;
    HKEY hKeyBackup;
    
    try
    {
        m_bSnapshotSuccessful = FALSE;

        //
        //  First make sure the spit directory is empty.  If not, we must fail.
        //  Even if Registry is not selected, avoid backing up old staff so there's no confusion
        //
        ft.hr = ::RemoveDirectoryTree( m_cwsExpandedRegistryTargetDir );
        ft.CheckForError( VSSDBG_WRITER, L"RemoveDirectoryTree" );                    

        //
        //  If the registry component has not already been selected, check to see if Bootable state is selected
        //
        if ( !m_bPerformSnapshot && IsBootableSystemStateBackedUp() )
        {
            ft.Trace( VSSDBG_WRITER, L"Bootable system state snapshot, writer will copy registry hives" );
            m_bPerformSnapshot = TRUE;
        }
        
        if ( m_bPerformSnapshot )
        {

            //
            //  Now let's create the base target directory.
            //
            ft.hr = ::CreateTargetPath( m_cwsExpandedRegistryTargetDir );
            ft.CheckForErrorInternal( VSSDBG_WRITER, L"CreateTargetPath" );                    
            
            ft.Trace( VSSDBG_WRITER, L"Extacting system registry hives from: '%s'", m_cwsExpandedConfigDir.c_str() );
            ft.Trace( VSSDBG_WRITER, L"Placing copied hives in: '%s'", m_cwsExpandedRegistryTargetDir.c_str() );

            //
            //  Iterate through the hives and copy them to the spit directory
            //
            for ( INT iHive = 0 ; s_sSystemRegistryHives[ iHive ].wszHiveFileName != NULL ; ++iHive )
            {
                CBsString cwsHivePath =  m_cwsExpandedConfigDir + L'\\';
                cwsHivePath += s_sSystemRegistryHives[ iHive ].wszHiveFileName;
                CBsString cwsHiveTargetPath = m_cwsExpandedRegistryTargetDir + L'\\';
                cwsHiveTargetPath += s_sSystemRegistryHives[ iHive ].wszHiveFileName;
                
                ft.Trace( VSSDBG_WRITER, L"Copying %s hive from %s to: %s", s_sSystemRegistryHives[ iHive ].wszHiveFileName, 
                    cwsHivePath.c_str(), cwsHiveTargetPath.c_str() );

        		winStatus = ::RegCreateKeyExW(
        		    s_sSystemRegistryHives[ iHive ].hKey,
				    s_sSystemRegistryHives[ iHive ].wszHiveName,
				    0,
				    NULL,
				    REG_OPTION_BACKUP_RESTORE,
				    MAXIMUM_ALLOWED,
				    NULL,
				    &hKeyBackup,
				    NULL
				    );
        	
        		ft.hr = HRESULT_FROM_WIN32 (winStatus);
                ft.CheckForError( VSSDBG_WRITER, L"RegCreateKeyExW" );                    

                //
    		    //  Use the new RegSaveKeyExW with REG_NO_COMPRESSION option to 
    		    //  quickly spit out the hives.
    		    //
    		    winStatus = ::RegSaveKeyExW( 
    		        hKeyBackup, 
    		        cwsHiveTargetPath, 
    		        NULL, 
    		        REG_NO_COMPRESSION 
    		        );

    		    ::RegCloseKey( hKeyBackup );
    		    ft.hr = HRESULT_FROM_WIN32( winStatus );
                ft.CheckForError( VSSDBG_WRITER, L"RegSaveKeyExW" );   
            }

            // BUG 456075: Mark the snapshot as being performed only if the hive was succesfully saved.
            // This member is used to decide when to move the saved hive 
            // into teh %systemroot%\repair directory.
            if ( ft.HrSucceeded() )
                m_bSnapshotSuccessful = TRUE;
        }
    }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CRegistryWriter::OnFreeze()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::OnFreeze");


    try
    {
    }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError(ft.hr);

    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CRegistryWriter::OnThaw()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::OnThaw");

    try
    {
        if (  m_bSnapshotSuccessful )
        {   
            // Move the registry hives to the repair directory
            CBsString cwsExpandedRepairDir;
            cwsExpandedRepairDir.ExpandEnvironmentStrings( s_cwsRepairDir );
            
            ft.hr = ::MoveFilesInDirectory( m_cwsExpandedRegistryTargetDir, cwsExpandedRepairDir );
            if ( ft.HrFailed() )
            {
                ft.Trace( VSSDBG_WRITER, L"Warning, unable to move the registry hive from '%s' to '%s', hr: 0x08x",
                    m_cwsExpandedRegistryTargetDir.c_str(), cwsExpandedRepairDir.c_str(), ft.hr );
                ft.hr = S_OK;
            }
            m_bSnapshotSuccessful = FALSE;
        }

        if ( m_bPerformSnapshot )
        {
            //  Now remove the registry directory tree.
            ft.hr = ::RemoveDirectoryTree( m_cwsExpandedRegistryTargetDir );
            if ( ft.HrFailed()  )
            {
                ft.Trace( VSSDBG_WRITER, L"Warning, unable to remove the registry backup directory: %s, hr: 0x08x",
                    m_cwsExpandedRegistryTargetDir.c_str(), ft.hr );
                ft.hr = S_OK;
            }
            m_bPerformSnapshot = FALSE;
        }
    }
    VSS_STANDARD_CATCH( ft )

    TranslateWriterError( ft.hr );

    return ft.HrSucceeded();
}


bool STDMETHODCALLTYPE CRegistryWriter::OnAbort()
{
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::OnAbort");

    try
    {
        if ( m_bPerformSnapshot )
        {         
            // Do not clean up spit directory on Abort since abort may be sent
            // after cancellation. Then it can interfere with the Simulate code 
            // (used by NtBackup after cancellation) that invokes a Registry mini-writer
            //
            // RemoveDirectoryTree is being called in OnPrepareSnapshot such that there
            // is no danger of backing up old data

            m_bPerformSnapshot    = FALSE;
            m_bSnapshotSuccessful = FALSE;
        }
    }
    VSS_STANDARD_CATCH(ft)

    TranslateWriterError( ft.hr );
    
    return ft.HrSucceeded();
}

bool CRegistryWriter::IsPathInSnapshot(const WCHAR *wszPath) throw()
{
    return IsPathAffected(wszPath);
}

// translate a sql writer error code into a writer error
void CRegistryWriter::TranslateWriterError(HRESULT hr)
{
    switch(hr)
    {
        default:
            SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            break;

        case S_OK:
            break;

        case E_OUTOFMEMORY:
        case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
        case HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES):
        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES):
            SetWriterFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            break;
    }
}

//  Creates one instance of the Registry writer class.  If one already exists, it simple returns.
// static
HRESULT CRegistryWriter::CreateWriter()
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::CreateWriter");
    
    if ( sm_pWriter != NULL )
        return S_OK;

    //
    //  OK, spin up a thread to do the subscription in.
    //
	try
	{
		sm_pWriter = new CRegistryWriter;
		if (sm_pWriter == NULL)
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Allocation of CRegistryWriter object failed.");

		DWORD tid;

		HANDLE hThread = ::CreateThread
							(
							NULL,
							256* 1024,
							InitializeThreadFunc,
							NULL,
							0,
							&tid
							);

		if (hThread == NULL)
			ft.Throw
				(
				VSSDBG_WRITER,
				E_UNEXPECTED,
				L"CreateThread failed with error %d",
				::GetLastError()
				);

		// wait for thread to complete
        ::WaitForSingleObject( hThread, INFINITE );
		::CloseHandle( hThread );
		ft.hr = sm_hrInitialize;
	}
	VSS_STANDARD_CATCH(ft)
	    
	if (ft.HrFailed() && sm_pWriter)
	{
		delete sm_pWriter;
		sm_pWriter = NULL;
	}

	return ft.hr;    
}

// static
DWORD CRegistryWriter::InitializeThreadFunc(VOID *pv)
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::InitializeThreadFunc");

	BOOL fCoinitializeSucceeded = false;

	try
	{
		// intialize MTA thread
		ft.hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_WRITER,
				E_UNEXPECTED,
				L"CoInitializeEx failed 0x%08lx", ft.hr
				);

        fCoinitializeSucceeded = true;

        //  Now initialize the base class and subscribe
		ft.hr = sm_pWriter->Initialize();
	}
	VSS_STANDARD_CATCH(ft)

	if (fCoinitializeSucceeded)
		CoUninitialize();

	sm_hrInitialize = ft.hr;
	return 0;

	UNREFERENCED_PARAMETER( pv );
}

// static
void CRegistryWriter::DestroyWriter()
{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CRegistryWriter::DestroyWriter");
	
	if (sm_pWriter)
	{
		sm_pWriter->Uninitialize();
		delete sm_pWriter;
		sm_pWriter = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\writers\stdafx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    StdAfx.h

Abstract:

    Precompiled header file.

Author:

    Stefan R. Steiner   [ssteiner]        02-01-2000

Revision History:

--*/

#ifndef __H_STDAFX_
#define __H_STDAFX_

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)
#pragma warning(disable:4201)    // C4201: nonstandard extension used : nameless struct/union

// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#undef ASSERT
//#undef _ASSERTE

#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>

#include "vs_assert.hxx"

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <stddef.h>
#include <oleauto.h>
#include <atlconv.h>
#include <atlbase.h>

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include <vswriter.h>
#include <vsbackup.h>

#include "bsstring.hxx"
#include "wrtcommon.hxx"

#endif // __H_STDAFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\stdafx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    StdAfx.h

Abstract:

    Precompiled header file.

Author:

    Stefan R. Steiner   [ssteiner]        02-01-2000

Revision History:

	X-3	MCJ		Michael C. Johnson		12-Jun-2000
		Added vswriter.h and vsbackup.h

	X-2	MCJ		Michael C. Johnson		 6-Mar-2000
		Added coord.h and vsevent.h to include list.

--*/

#ifndef __H_STDAFX_
#define __H_STDAFX_

#pragma once

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)
#pragma warning(disable:4201)    // C4201: nonstandard extension used : nameless struct/union

// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#undef _ASSERTE

#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>
#include <devioctl.h>
#include <ntddstor.h>

#include "vs_assert.hxx"

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <stddef.h>
#include <oleauto.h>
#include <atlconv.h>
#include <atlbase.h>

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include <vswriter.h>
#include <vsbackup.h>

extern BOOL g_bInSimulateSnapshotFreeze;

#endif // __H_STDAFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrci.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrci.cpp

Abstract:

    Writer shim module for Ci

Author:

    Stefan R. Steiner   [ssteiner]        02-08-2000

Revision History:

	X-8	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-7	MCJ		Michael C. Johnson		18-Jul-2000
		143435: Change name of target path

	X-6	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Add an exclude list which covers the CI indices.

	X-5	MCJ		Michael C. Johnson		19-Jun-2000
		Apply code review comments.

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-2	MCJ		Michael C. Johnson		 7-Mar-2000
		Instead of stopping the CI service, just pause it. This will
		allow queries to continue but stop updates until we continue
		it.

--*/

#include "stdafx.h"

#include "wrtrdefs.h"
#include "wrtcommon.hxx"
#include <winsvc.h>

#pragma warning(disable:4100)

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCIC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING		L"ContentIndexingService"
#define COMPONENT_NAME			L"Content Indexing Service"

#define	CI_CATALOG_LIST_KEY		L"SYSTEM\\CurrentControlset\\Control\\ContentIndex\\Catalogs"
#define CI_CATALOG_VALUENAME_LOCATION	L"Location"

#define CATALOG_BUFFER_SIZE		(4096)

DeclareStaticUnicodeString (ucsIndexSubDirectoryName, L"\\catalog.wci");


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterCI : public CShimWriter
    {
public:
    CShimWriterCI (LPCWSTR pwszWriterName) : 
		CShimWriter (pwszWriterName), 
		m_dwPreviousServiceState(0),
		m_bStateChangeOutstanding(FALSE) {};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    HRESULT DoThaw (VOID);
    HRESULT DoShutdown (VOID);

    DWORD m_dwPreviousServiceState;
    BOOL  m_bStateChangeOutstanding;
    };


static CShimWriterCI ShimWriterCI (APPLICATION_STRING);

PCShimWriter pShimWriterCI = &ShimWriterCI;



/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**      NOTE: This method should never be called anymore.
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterCI::DoIdentify ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    DWORD		dwIndex                    = 0;
    HKEY		hkeyCatalogList            = NULL;
    BOOL		bCatalogListKeyOpened      = FALSE;
    BOOL		bContinueCatalogListSearch = TRUE;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;


    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, CATALOG_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, CATALOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							      NULL,
							      COMPONENT_NAME,
							      COMPONENT_NAME,
							      NULL, // icon
							      0,
							      true,
							      false,
							      false);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddComponent", 
		    L"CShimWriterCI::DoIdentify");
	}



    if (SUCCEEDED (hrStatus))
	{
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   CI_CATALOG_LIST_KEY,
				   0L,
				   KEY_READ,
				   &hkeyCatalogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus); 

	bCatalogListKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (catalog list)", 
		    L"CShimWriterCI::DoIdentify");
	}



    while (SUCCEEDED (hrStatus) && bContinueCatalogListSearch)
	{
	HKEY	hkeyCatalogName    = NULL;
 	DWORD	dwSubkeyNameLength = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyCatalogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueCatalogListSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterCI::DoIdentify");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    winStatus = RegOpenKeyExW (hkeyCatalogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyCatalogName);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (catalog value)", 
			L"CShimWriterCI::DoIdentify");


	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;


		StringTruncate (&ucsValueData, 0);

		winStatus = RegQueryValueExW (hkeyCatalogName,
					      CI_CATALOG_VALUENAME_LOCATION,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);

		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegQueryValueExW", 
			    L"CShimWriterCI::DoIdentify");



		if (SUCCEEDED (hrStatus) && (REG_SZ == dwValueType))
		    {
		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;

		    StringAppendString (&ucsValueData, &ucsIndexSubDirectoryName);


		    hrStatus = m_pIVssCreateWriterMetadata->AddExcludeFiles (ucsValueData.Buffer,
									     L"*",
									     true);

		    LogFailure (NULL, 
				hrStatus, 
				hrStatus, 
				m_pwszWriterName, 
				L"IVssCreateWriterMetadata::AddExcludeFiles", 
				L"CShimWriterCI::DoIdentify");
		    }

		RegCloseKey (hkeyCatalogName);
		}




	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}



    if (bCatalogListKeyOpened)
	{
	RegCloseKey (hkeyCatalogList);
	}



    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);

    return (hrStatus);
    } /* CShimWriterCI::DoIdentify () */


/*++

Routine Description:

    The CI writer PrepareForSnapshot function.  Currently all of the
    real work for this writer happens here. Pause the service if we can.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoPrepareForSnapshot ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterCI::DoPrepareForSnapshot");

    HRESULT hrStatus = VsServiceChangeState (L"cisvc",
					     SERVICE_PAUSED,
					     &m_dwPreviousServiceState,
					     &m_bStateChangeOutstanding);

    m_bParticipateInBackup = m_bStateChangeOutstanding;

    //  Not an error if cisvc couldn't be paused since it might be that CI is not installed.  The pause is only
    //  done as best effort.
    if ( FAILED( hrStatus ) )
        ft.Trace( VSSDBG_SHIM, L"VsServiceChangeState failed, hr: 0x%08x, probably because CI is not installed",
                  hrStatus );

    return (S_OK);
    } /* CShimWriterCI::DoPrepareForSnapshot () */



/*++

Routine Description:

    The CI writer Thaw function.  Return the service to 
    state in which we found it.

Arguments:

    Same arguments as those passed in the Thaw event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoThaw ()
    {
    HRESULT hrStatus = NOERROR;

    if (m_bStateChangeOutstanding)
	{
	hrStatus = VsServiceChangeState (L"cisvc",
					 m_dwPreviousServiceState,
					 NULL,
					 NULL);

	m_bStateChangeOutstanding = FAILED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"VsServiceChangeState", 
		    L"CShimWriterCI::DoThaw/DoAbort");

	}


    return (hrStatus);
    } /* CShimWriterCI::DoThaw () */



/*++

Routine Description:

    The CI writer Shutdown function.  Return the service to state in
    which we found it. We do our level best to put things back the way
    they were even if this writer has previously failed but only if we
    originally changed the state.

Arguments:

    None.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoShutdown ()
    {
    HRESULT hrStatus = NOERROR;

    if (m_bStateChangeOutstanding)
	{
	hrStatus = VsServiceChangeState (L"cisvc",
					 m_dwPreviousServiceState,
					 NULL,
					 NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"VsServiceChangeState", 
		    L"CShimWriterCI::DoShutdown");

	}


    return (hrStatus);
    } /* CShimWriterCI::DoShutdown () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtcommon\stdafx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    StdAfx.h

Abstract:

    Precompiled header file.

Author:

    Stefan R. Steiner   [ssteiner]        02-01-2000

Revision History:

--*/

#ifndef __H_STDAFX_
#define __H_STDAFX_

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)
#pragma warning(disable:4201)    // C4201: nonstandard extension used : nameless struct/union

// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#undef ASSERT
//#undef _ASSERTE

#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>

#include "vs_assert.hxx"

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <stddef.h>
#include <oleauto.h>
#include <atlconv.h>
#include <atlbase.h>

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include <vswriter.h>
#include <vsbackup.h>

#include "bsstring.hxx"
#include "wrtcommon.hxx"

#endif // __H_STDAFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrclus.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrclus.cpp | Implementation of SnapshotWriter for Cluster Database

    NOTE: This module is not used/compiled anymore since Clusters has its own snapshot writer.

Author:

    Michael C. Johnson [mikejohn] 31-Jan-2000


Description:
	
    Add comments.


Revision History:

	X-13	MCJ		Michael C. Johnson		22-Oct-2000
		209095: Dynamically load the cluster and net libraries to
		reduce the foot print for the unclustered.
 
	X-12	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-11	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-10	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Remove trailing '\' from Include/Exclude lists.

	X-9	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-8	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()
 
	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-5	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.
		Move save path under SystemState target path.

	X-4	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-3	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Fix broken assert in shutdown code, some path length checks
		and calculations.

	X-1	MCJ		Michael C. Johnson		31-Jan-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.

--*/


#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"
#include <clusapi.h>
#include <Sddl.h>
#include <lmshare.h>
#include <lmaccess.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCLUSC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING	L"ClusterDatabase"
#define COMPONENT_NAME		L"Cluster Database"
#define TARGET_PATH		ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING


DeclareStaticUnicodeString (ucsShareName, L"__NtBackup_cluster");


typedef DWORD		(WINAPI *PFnGetNodeClusterState)(LPCWSTR, PDWORD);
typedef HCLUSTER	(WINAPI *PFnOpenCluster)(LPCWSTR);
typedef DWORD		(WINAPI *PFnBackupClusterDatabase)(HCLUSTER, LPCWSTR);
typedef BOOL		(WINAPI *PFnCloseCluster)(HCLUSTER);

typedef NET_API_STATUS	(WINAPI *PFnNetShareAdd)(LPWSTR, DWORD, LPBYTE, LPDWORD);
typedef NET_API_STATUS	(WINAPI *PFnNetShareDel)(LPWSTR, LPWSTR, DWORD);



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/
class CShimWriterClusterDb : public CShimWriter
    {
public:
    CShimWriterClusterDb (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bBootableState) : 
		CShimWriter (pwszWriterName, pwszTargetPath, bBootableState),
		m_pfnDynamicGetNodeClusterState   (NULL),
		m_pfnDynamicOpenCluster           (NULL),
		m_pfnDynamicCloseCluster          (NULL),
		m_pfnDynamicBackupClusterDatabase (NULL),
		m_pfnDynamicNetShareAdd           (NULL),
		m_pfnDynamicNetShareDel           (NULL),
		m_hmodClusApi                     (NULL),
		m_hmodNetApi32                    (NULL) 
		{
            m_bSimulateOnly = TRUE;  //  Alert the calling code that this is for simulate only 
		};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT DoClusterDatabaseBackup (VOID);

    HRESULT DynamicRoutinesLoadCluster (VOID);
    HRESULT DynamicRoutinesLoadNetwork (VOID);
    HRESULT DynamicRoutinesUnloadAll   (VOID);
    HRESULT CreateShareDescriptor(PSECURITY_DESCRIPTOR& descriptor);

    PFnGetNodeClusterState	m_pfnDynamicGetNodeClusterState;
    PFnOpenCluster		m_pfnDynamicOpenCluster;
    PFnCloseCluster		m_pfnDynamicCloseCluster;
    PFnBackupClusterDatabase	m_pfnDynamicBackupClusterDatabase;
    PFnNetShareAdd		m_pfnDynamicNetShareAdd;
    PFnNetShareDel		m_pfnDynamicNetShareDel;
    HMODULE			m_hmodClusApi;
    HMODULE			m_hmodNetApi32;
    };


static CShimWriterClusterDb ShimWriterClusterDb (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterClusterDb = &ShimWriterClusterDb;



/*
**++
**
** Routine Description:
**
**	This routine loads the required Cluster DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesLoadCluster ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesLoadCluster");


    try 
	{
	if ((NULL != m_pfnDynamicGetNodeClusterState)   ||
	    (NULL != m_pfnDynamicOpenCluster)           ||
	    (NULL != m_pfnDynamicCloseCluster)          ||
	    (NULL != m_pfnDynamicBackupClusterDatabase) ||
	    !HandleInvalid (m_hmodClusApi))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodClusApi = LoadLibraryW (L"ClusApi.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodClusApi);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (ClusApi.dll)");



	m_pfnDynamicGetNodeClusterState = (PFnGetNodeClusterState) GetProcAddress (m_hmodClusApi, "GetNodeClusterState");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicGetNodeClusterState);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (GetNodeClusterState)");



	m_pfnDynamicOpenCluster = (PFnOpenCluster) GetProcAddress (m_hmodClusApi, "OpenCluster");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicOpenCluster);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (OpenCluster)");



	m_pfnDynamicCloseCluster = (PFnCloseCluster) GetProcAddress (m_hmodClusApi, "CloseCluster");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicCloseCluster);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (CloseCluster)");



	m_pfnDynamicBackupClusterDatabase = (PFnBackupClusterDatabase) GetProcAddress (m_hmodClusApi, "BackupClusterDatabase");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicBackupClusterDatabase);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (BackupClusterDatabase)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_pfnDynamicOpenCluster           = NULL;
	m_pfnDynamicCloseCluster          = NULL;
	m_pfnDynamicBackupClusterDatabase = NULL;
	m_hmodClusApi                     = NULL;
	}


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesLoadCluster () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesLoadNetwork ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesLoadNetwork");


    try 
	{
	if ((NULL != m_pfnDynamicNetShareAdd) ||
	    (NULL != m_pfnDynamicNetShareDel) ||
	    !HandleInvalid (m_hmodNetApi32))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodNetApi32 = LoadLibraryW (L"NetApi32.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodNetApi32);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (NetApi32.dll)");



	m_pfnDynamicNetShareAdd = (PFnNetShareAdd) GetProcAddress (m_hmodNetApi32, "NetShareAdd");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicNetShareAdd);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (NetShareAdd)");



	m_pfnDynamicNetShareDel = (PFnNetShareDel) GetProcAddress (m_hmodNetApi32, "NetShareDel");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicNetShareDel);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (NetShareDel)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodNetApi32)) FreeLibrary (m_hmodNetApi32);

	m_pfnDynamicNetShareAdd = NULL;
	m_pfnDynamicNetShareDel = NULL;
	m_hmodNetApi32          = NULL;
	}


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesLoadNetwork () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesUnloadAll ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesUnloadAll");


    try 
	{
	if (!HandleInvalid (m_hmodNetApi32)) FreeLibrary (m_hmodNetApi32);

	m_pfnDynamicNetShareAdd = NULL;
	m_pfnDynamicNetShareDel = NULL;
	m_hmodNetApi32          = NULL;



	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_pfnDynamicOpenCluster           = NULL;
	m_pfnDynamicCloseCluster          = NULL;
	m_pfnDynamicBackupClusterDatabase = NULL;
	m_hmodClusApi                     = NULL;
	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesUnloadAll () */

/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DoIdentify ()
    {
        //  No work to do, this is just a simulate only shim writer
        return S_OK;
    } /* CShimWriterClusterDb::DoIdentify () */


/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterClusterDb::DoPrepareForSnapshot ()
    {
	//  Only do work if in simulate snapshot freeze case.
    if ( !g_bInSimulateSnapshotFreeze )
        return S_OK;
    
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DoPrepareForSnapshot");
    HRESULT	hrStatus = NOERROR;
    DWORD	winStatus;
    DWORD	dwClusterNodeState;


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = DynamicRoutinesLoadCluster ();
	}


    if (SUCCEEDED (hrStatus))
	{
	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	m_bParticipateInBackup = SUCCEEDED (hrStatus) && (ClusterStateRunning == dwClusterNodeState);


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetNodeClusterState", 
		    L"CShimWriterClusterDb::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	hrStatus = DynamicRoutinesLoadNetwork ();
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	hrStatus = DoClusterDatabaseBackup ();
	}


    DynamicRoutinesUnloadAll ();


    return (hrStatus);
    } /* CShimWriterClusterDb::PrepareForFreeze () */



HRESULT CShimWriterClusterDb::DoClusterDatabaseBackup ()
    {
    HRESULT			hrStatus       = NOERROR;
    HCLUSTER			hCluster       = NULL;
    BOOL			bNetShareAdded = FALSE;
    BOOL			bSucceeded;
    SHARE_INFO_502		ShareInfo;
    UNICODE_STRING		ucsComputerName;
    UNICODE_STRING		ucsBackupPathLocal;
    UNICODE_STRING		ucsBackupPathNetwork;


    BS_ASSERT (MAX_COMPUTERNAME_LENGTH <= ((MAXUSHORT / sizeof (WCHAR)) - sizeof (UNICODE_NULL)));


    StringInitialise (&ucsComputerName);
    StringInitialise (&ucsBackupPathLocal);
    StringInitialise (&ucsBackupPathNetwork);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsBackupPathLocal,
						   m_pwszTargetPath,
						   0);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsComputerName,
				   (MAX_COMPUTERNAME_LENGTH * sizeof (WCHAR)) + sizeof (UNICODE_NULL));
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwNameLength = ucsComputerName.MaximumLength / sizeof (WCHAR);
	BOOL	bSucceeded   = GetComputerNameW (ucsComputerName.Buffer, &dwNameLength);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	if (SUCCEEDED (hrStatus))
	    {
	    ucsComputerName.Length = (USHORT) (dwNameLength * sizeof (WCHAR));
	    }
	else
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"GetComputerNameW", 
			L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	    }
	}



    if (SUCCEEDED (hrStatus))
	{
	if ((ucsComputerName.Length + ucsShareName.Length) > (MAXUSHORT - (sizeof (UNICODE_NULL) + 3 * sizeof (L'\\'))))
	    {
	    hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	    }
	else
	    {
	    hrStatus = StringAllocate (&ucsBackupPathNetwork,
				       (USHORT) (sizeof (L'\\')
						 + sizeof (L'\\')
						 + ucsComputerName.Length
						 + sizeof (L'\\')
						 + ucsShareName.Length
						 + sizeof (UNICODE_NULL)));
	    }
	}



    if (SUCCEEDED (hrStatus))
	{
	/*
	** Should we uniquify the directory name at all here
	** to cater for the possiblity that we may be involved
	** in more than one snapshot at a time?
	*/
	StringAppendString (&ucsBackupPathNetwork, L"\\\\");
	StringAppendString (&ucsBackupPathNetwork, &ucsComputerName);
	StringAppendString (&ucsBackupPathNetwork, L"\\");
	StringAppendString (&ucsBackupPathNetwork, &ucsShareName);


	memset (&ShareInfo, 0, sizeof (ShareInfo));

	ShareInfo.shi502_netname     = ucsShareName.Buffer;
	ShareInfo.shi502_type        = STYPE_DISKTREE;
	ShareInfo.shi502_permissions = ACCESS_READ | ACCESS_WRITE | ACCESS_CREATE;
	ShareInfo.shi502_max_uses    = 1;
	ShareInfo.shi502_path        = ucsBackupPathLocal.Buffer;
	hrStatus = CreateShareDescriptor(ShareInfo.shi502_security_descriptor);
       }

    if (SUCCEEDED(hrStatus))
    	{
    	NET_API_STATUS	netStatus;

        /*
        ** Make sure to try to delete the share first in case for some reason it exists.  This
        ** could happen if the previous shim instance was killed right after creating the
        ** share. Ignore the return code. Bug #280746.
        */
        m_pfnDynamicNetShareDel (NULL, ucsShareName.Buffer, 0);

	/*
	** Create the backup directory and share it out. Note that we
	** don't care if the CreateDirectoryW() fails: it could fail
	** for a number of legitimate reasons (eg already exists). If
	** the failure was significant then we won't be able to add
	** the share and we'll detect a problem at that point.
	*/
	netStatus = m_pfnDynamicNetShareAdd (NULL, 502, (LPBYTE)(&ShareInfo), NULL);
	hrStatus  = HRESULT_FROM_WIN32 (netStatus);

	bNetShareAdded = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"NetShareAdd", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");

	::LocalFree(ShareInfo.shi502_security_descriptor);
	}


    if (SUCCEEDED (hrStatus))
	{
	hCluster = m_pfnDynamicOpenCluster (NULL);

	hrStatus = GET_STATUS_FROM_HANDLE (hCluster);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"OpenCluster", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	winStatus = m_pfnDynamicBackupClusterDatabase (hCluster, ucsBackupPathNetwork.Buffer);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"BackupClusterDatabase", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	}


    /*
    ** All the cleanup code.
    */
    if (!HandleInvalid (hCluster)) m_pfnDynamicCloseCluster (hCluster);
    if (bNetShareAdded)            m_pfnDynamicNetShareDel (NULL, ucsShareName.Buffer, 0);

    StringFree (&ucsComputerName);
    StringFree (&ucsBackupPathLocal);
    StringFree (&ucsBackupPathNetwork);

    return (hrStatus);
    } /* DoClusterDatabaseBackup () */

HRESULT CShimWriterClusterDb::CreateShareDescriptor(PSECURITY_DESCRIPTOR& descriptor)
{
	CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterClusterDb::CreateShareDescriptor");
	
	WCHAR* sd = L"D:P(A;OICI;GA;;;SY)"
                                L"(A;OICI;GA;;;BA)"
			           L"(A;OICI;GA;;;BO)";
	if (::ConvertStringSecurityDescriptorToSecurityDescriptor(sd, SDDL_REVISION_1, 
								&descriptor, NULL) == FALSE)
		{
		::LocalFree(descriptor);
		ft.hr = HRESULT_FROM_WIN32(::GetLastError());
	       }

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrcomdb.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrcomdb.cpp | Implementation of SnapshotWriter for COM+ Registration Database



Author:

    Michael C. Johnson [mikejohn] 03-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-14	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-13	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-12	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Really remove trailing '\' from Include/Exclude lists.

	X-11	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.


	X-10	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-9	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-8	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-7	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-6	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.


	X-5	MCJ		Michael C. Johnson		22-Feb-2000
		Add SYSTEM_STATE_SUBDIR to COM+ database save path.

	X-4	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-3	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Ensure wide chars are used for saving the COM+ Db rather
		than the 'CHAR' type used by NtBackup (CHAR == WCHAR in
		NtBackup just to fool folk)
		Fix broken assert in shutdown code.
		Fix path length checks and calculations.

	X-1	MCJ		Michael C. Johnson		03-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.

--*/


#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCMDBC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING	L"ComRegistrationDatabase"
#define COMPONENT_NAME		L"COM+ Registration Database"
#define TARGET_PATH		ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

DeclareStaticUnicodeString (ucsBackupFilename, L"\\ComRegDb.bak");


HRESULT (WINAPI *RegDbBackup)(PWCHAR);

typedef HRESULT (WINAPI *PF_REG_DB_API)(PWCHAR);





/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterComDb : public CShimWriter
    {
public:
    CShimWriterComDb (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState) : 
		CShimWriter (pwszWriterName, pwszTargetPath, bParticipateInBootableState) 
        {
		        m_bSimulateOnly = TRUE;  //  Alert the calling code that this is for simulate only 
        };

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterComDb ShimWriterComDb (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterComPlusRegDb = &ShimWriterComDb;



/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterComDb::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterComDb::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");



	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (L"%SystemRoot%\\registration",
							      L"*.clb",
							      false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.clb)");




	/*
	** Exclude all *.crmlog files from the root down.
	*/
	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (DIR_SEP_STRING,
							      L"*.crmlog",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.crmlog)");

	} VSS_STANDARD_CATCH (ft)
								 


    return (ft.hr);
    } /* CShimWriterComDb::DoIdentify () */


/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer PrepareForSnapshot function.
**	Currently all of the real work for this writer happens here.
**
**
** Arguments:
**
**	Same arguments as those passed in the PrepareForSnapshot event.
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterComDb::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    HINSTANCE		hRegDbDll = NULL;
    UNICODE_STRING	ucsBackupPath;


    StringInitialise (&ucsBackupPath);


    hrStatus = StringCreateFromExpandedString (&ucsBackupPath,
					       m_pwszTargetPath,
					       ucsBackupFilename.Length / sizeof (WCHAR));



    if (SUCCEEDED (hrStatus))
	{
	hRegDbDll = LoadLibraryW (L"catsrvut.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hRegDbDll);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (catsrvut.dll)", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	RegDbBackup = (PF_REG_DB_API) GetProcAddress (hRegDbDll, "RegDBBackup");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != RegDbBackup);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (RegDbBackup)", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsBackupPath, &ucsBackupFilename);

	hrStatus = RegDbBackup (ucsBackupPath.Buffer);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegDbBackup", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}



    if (!HandleInvalid (hRegDbDll))
	{
	FreeLibrary (hRegDbDll);
	}



    StringFree (&ucsBackupPath);

    return (hrStatus);
    } /* DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrconfig.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrconfig.cpp | Implementation of SnapshotWriter for Config directory



Author:

    Michael C. Johnson [mikejohn] 18-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-20	MCJ		Michael C. Johnson		13-Sep-2000
		178282: Writer should only generate backup file if source 
			path is in volume list.

	X-19	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-18	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-17	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine. Also this is
		not a bootable state writer.

	X-16	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-15	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		 3-Mar-2000
		Determine correct errors (if any) during copy file scan loop
		in PrepareToSync and fail the operation if appropriate.

	X-3	MCJ		Michael C. Johnson		 2-Mar-2000
		Do a preparatory cleanup of the target save directory to make
		sure we don't have to deal with any junk left from a previous
		invokcation.
		Also be smarter about what we copy. In particular, there is
		no need to copy the registry related files or the event logs.

	X-2	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-1	MCJ		Michael C. Johnson		18-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCONFC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"ConfigDirectory"
#define COMPONENT_NAME				L"Config Directory"

#define TARGET_PATH				ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING
#define CONFIGDIR_SOURCE_PATH			L"%SystemRoot%\\system32\\config"


#define REGISTRY_SUBKEY_HIVELIST		L"SYSTEM\\CurrentControlSet\\Control\\hivelist"

#define EVENTLOG_SUBKEY_EVENTLOG		L"SYSTEM\\CurrentControlSet\\Services\\Eventlog"
#define EVENTLOG_VALUENAME_FILE			L"File"


#define REGISTRY_BUFFER_SIZE			(4096)
#define EVENTLOG_BUFFER_SIZE			(4096)

DeclareStaticUnicodeString (ucsHiveRecognitionPrefix, L"\\Device\\");


typedef struct _VertexRecord
    {
    UNICODE_STRING	ucsVertexName;
    } VERTEXRECORD, *PVERTEXRECORD, **PPVERTEXRECORD;


static PVOID NTAPI VertexAllocateNode (PRTL_GENERIC_TABLE pTable,
				       CLONG              clByteSize);

static VOID NTAPI VertexFreeNode (PRTL_GENERIC_TABLE pTable,
				  PVOID              pvBuffer);

static RTL_GENERIC_COMPARE_RESULTS NTAPI VertexCompareNode (PRTL_GENERIC_TABLE pTable,
							    PVOID              pvNode1,
							    PVOID              pvNode2);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterConfigDir : public CShimWriter
    {
public:
    CShimWriterConfigDir (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) 
	{
	PVOID	pvTableContext = NULL;

	RtlInitializeGenericTable (&m_StopList,
				   VertexCompareNode,
				   VertexAllocateNode,
				   VertexFreeNode,
				   pvTableContext);
	};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT CopyConfigDirFiles       (VOID);
    HRESULT PopulateStopList         (VOID);
    HRESULT PopulateStopListEventlog (VOID);
    HRESULT PopulateStopListRegistry (VOID);
    HRESULT CleanupStopList          (VOID);
    BOOL    FileInStopList           (PWCHAR pwszFilename);
    HRESULT VertexAdd                (PUNICODE_STRING pucsVertexName);

    RTL_GENERIC_TABLE	m_StopList;
    };


static CShimWriterConfigDir ShimWriterConfigDir (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterConfigDir = &ShimWriterConfigDir;



static PVOID NTAPI VertexAllocateNode (PRTL_GENERIC_TABLE pTable,
				       CLONG              clByteSize)
    {
    PVOID	pvBuffer;

    pvBuffer = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, clByteSize);

    return (pvBuffer);
    }



static VOID NTAPI VertexFreeNode (PRTL_GENERIC_TABLE pTable,
				  PVOID              pvBuffer)
    {
    HeapFree (GetProcessHeap (), 0, pvBuffer);

    return;
    }



/*
** In this usage of the package I don't actually care about ordering,
** just so long as I can re-find vertex information. To this end we
** need to specify the search 'key'. So, the 'key' is defined to be
** the file name and is expected to be unique to a vertex. If this
** changes then we'll need to re-visit this.
*/

static RTL_GENERIC_COMPARE_RESULTS NTAPI VertexCompareNode (PRTL_GENERIC_TABLE pTable,
							    PVOID              pvNode1,
							    PVOID              pvNode2)
    {
    PVERTEXRECORD		pVertex1   = (PVERTEXRECORD) pvNode1;
    PVERTEXRECORD		pVertex2   = (PVERTEXRECORD) pvNode2;
    RTL_GENERIC_COMPARE_RESULTS	Result;
    INT				iStringCompareResult;


    iStringCompareResult = RtlCompareUnicodeString (&pVertex1->ucsVertexName,
						    &pVertex2->ucsVertexName,
						    TRUE);

    if (iStringCompareResult < 0)
	{
	Result = GenericLessThan;
	}

    else if (iStringCompareResult > 0)
	{
	Result = GenericGreaterThan;
	}

    else
	{
	Result = GenericEqual;
	}


    return (Result);
    }



HRESULT CShimWriterConfigDir::VertexAdd (PUNICODE_STRING pucsVertexName)
    {
    HRESULT		Status = NOERROR;
    PVERTEXRECORD	pVertexRecord;
    PVERTEXRECORD	pNewVertexRecord;
    BOOLEAN		bNewElement;
    ULONG		ulVertexNodeSize = sizeof (VERTEXRECORD) +
					   sizeof (UNICODE_NULL) +
					   pucsVertexName->Length;


    pVertexRecord = (PVERTEXRECORD) HeapAlloc (GetProcessHeap(),
					       HEAP_ZERO_MEMORY,
					       ulVertexNodeSize);

    Status = GET_STATUS_FROM_POINTER (pVertexRecord);



    if (SUCCEEDED (Status))
	{
	/*
	** Fill in enough of the node to allow it to be inserted into
	** the table. We will need to fix up the unicode string buffer
	** address after insertion.
	*/
	pVertexRecord->ucsVertexName.Buffer        = (PWCHAR)((PBYTE)pVertexRecord + sizeof (VERTEXRECORD));
	pVertexRecord->ucsVertexName.Length        = 0;
	pVertexRecord->ucsVertexName.MaximumLength = (USHORT)(sizeof (UNICODE_NULL) + pucsVertexName->Length);

	RtlCopyUnicodeString (&pVertexRecord->ucsVertexName, pucsVertexName);


	pNewVertexRecord = (PVERTEXRECORD) RtlInsertElementGenericTable (&m_StopList,
									 pVertexRecord,
									 ulVertexNodeSize,
									 &bNewElement);


	if (NULL == pNewVertexRecord)
	    {
	    /*
	    ** An allocation attempt failed. Setup an appropriate return
	    ** status
	    */
	    Status = E_OUTOFMEMORY;
	    }

	else if (!bNewElement)
	    {
	    /*
	    ** Oh oh, this is a duplicate. Setup an appropriate return
	    ** status.
	    */
	    Status = HRESULT_FROM_WIN32 (ERROR_DUP_NAME);
	    }

	else
	    {
	    /*
	    ** If we have a record and it's a new record then we need to
	    ** fix up the address of the unicode string to make it point
	    ** to the string in the newly inserted node rather than the
	    ** record we constructed to do the insertion.
	    */
	    pNewVertexRecord->ucsVertexName.Buffer = (PWCHAR)((PBYTE)pNewVertexRecord + sizeof (VERTEXRECORD));
	    }
	}


    if (NULL != pVertexRecord)
	{
	HeapFree (GetProcessHeap(), 0, pVertexRecord);
	}


    return (Status);
    } /* VertexAdd () */


/*
**++
**
** Routine Description:
**
**	The configuration directory snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterConfigDir::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterConfigDir::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");



	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (CONFIGDIR_SOURCE_PATH,
							      L"*",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CShimWriterConfigDir::DoIdentify () */



/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterConfigDir::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    UNICODE_STRING	ucsSourcePath;


    StringInitialise (&ucsSourcePath);

    hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
					       CONFIGDIR_SOURCE_PATH);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = IsPathInVolumeArray (ucsSourcePath.Buffer,
					m_ulVolumeCount,
					m_ppwszVolumeNamesArray,
					&m_bParticipateInBackup);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = PopulateStopList ();
	}


    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = CopyConfigDirFiles ();
	}


    CleanupStopList ();
    StringFree (&ucsSourcePath);

    return (hrStatus);
    } /* CShimWriterConfigDir::DoPrepareForSnapshot () */



HRESULT CShimWriterConfigDir::PopulateStopList ()
    {
    HRESULT	hrStatus;


    /*
    ** We have a table (initialized in the constructor. Now we need to
    ** get the names of the files to add to the StopList. This will
    ** prevent the copy from attempting to copy these files. First we
    ** populate with registry files we don't want to copy, then with
    ** event log files that we don't want either.
    */
    hrStatus = PopulateStopListRegistry ();

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = PopulateStopListEventlog ();
	}


    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopList () */



HRESULT CShimWriterConfigDir::PopulateStopListEventlog ()
    {
    HRESULT		hrStatus                    = NOERROR;
    DWORD		winStatus;
    DWORD		dwIndex                     = 0;
    HKEY		hkeyEventLogList            = NULL;
    BOOL		bSucceeded                  = FALSE;
    BOOL		bEventLogListKeyOpened      = FALSE;
    BOOL		bEventLogValueFileKeyOpened = FALSE;
    BOOL		bContinueEventLogSearch     = TRUE;
    UNICODE_STRING	ucsConfigDirSourcePath;
    UNICODE_STRING	ucsEventLogSourcePath;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;


    StringInitialise (&ucsConfigDirSourcePath);
    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsConfigDirSourcePath,
						   CONFIGDIR_SOURCE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsConfigDirSourcePath, DIR_SEP_STRING);


	/*
	** We now have all the pieces in place so go search the eventlog list
	** for the logs to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   EVENTLOG_SUBKEY_EVENTLOG,
				   0L,
				   KEY_READ,
				   &hkeyEventLogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bEventLogListKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (eventlog list)", 
		    L"CShimWriterConfigDir::PopulateStopListEventlog");
	}



    while (SUCCEEDED (hrStatus) && bContinueEventLogSearch)
	{
	HKEY	hkeyEventLogValueFile       = NULL;
 	DWORD	dwSubkeyNameLength          = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyEventLogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueEventLogSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;



	    winStatus = RegOpenKeyExW (hkeyEventLogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyEventLogValueFile);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    bEventLogValueFileKeyOpened = SUCCEEDED (hrStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (eventlog name)", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");



	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;


		StringTruncate (&ucsValueData, 0);

		winStatus = RegQueryValueExW (hkeyEventLogValueFile,
					      EVENTLOG_VALUENAME_FILE,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);

		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegQueryValueExW", 
			    L"CShimWriterConfigDir::PopulateStopListEventlog");



		if (SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
		    {
		    HANDLE	hEventLog    = NULL;
		    PWCHAR	pwszFilename;


		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;



		    StringInitialise (&ucsEventLogSourcePath);

		    hrStatus = StringCreateFromExpandedString (&ucsEventLogSourcePath,
							       ucsValueData.Buffer,
							       0);



		    if (SUCCEEDED (hrStatus))
			{
			BOOL	bInConfigDir = RtlPrefixUnicodeString (&ucsConfigDirSourcePath,
								       &ucsEventLogSourcePath,
								       TRUE);

			if (bInConfigDir)
			    {
			    pwszFilename = wcsrchr (ucsEventLogSourcePath.Buffer, DIR_SEP_CHAR);

			    pwszFilename = (NULL == pwszFilename)
						? ucsEventLogSourcePath.Buffer
						: pwszFilename + 1;

			    StringTruncate (&ucsValueData, 0);
			    StringAppendString (&ucsValueData, pwszFilename);

			    hrStatus = VertexAdd (&ucsValueData);
			    }
			}


		    StringFree (&ucsEventLogSourcePath);
		    }
		}


	    if (bEventLogValueFileKeyOpened)
		{
		RegCloseKey (hkeyEventLogValueFile);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}




    if (bEventLogListKeyOpened)
	{
	RegCloseKey (hkeyEventLogList);
	}


    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);
    StringFree (&ucsConfigDirSourcePath);


    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopListEventlog () */


HRESULT CShimWriterConfigDir::PopulateStopListRegistry ()
    {
    HRESULT		hrStatus            = NOERROR;
    HKEY		hkeyHivelist        = NULL;
    INT			iIndex              = 0;
    BOOL		bHivelistKeyOpened  = FALSE;
    BOOL		bContinueHiveSearch = TRUE;
    DWORD		winStatus;
    PWCHAR		pwchLastSlash;
    PWCHAR		pwszFilename;
    USHORT		usRegistryHivePathOriginalLength;
    UNICODE_STRING	ucsRegistryHivePath;
    UNICODE_STRING	ucsHiveRecognitionPostfix;
    UNICODE_STRING	ucsValueName;
    UNICODE_STRING	ucsValueData;


    StringInitialise (&ucsRegistryHivePath);
    StringInitialise (&ucsHiveRecognitionPostfix);
    StringInitialise (&ucsValueName);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueName, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistryHivePath,
						   CONFIGDIR_SOURCE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwCharIndex;


	StringAppendString (&ucsRegistryHivePath, DIR_SEP_STRING);

	usRegistryHivePathOriginalLength = ucsRegistryHivePath.Length / sizeof (WCHAR);



	/*
	** Now we know the location of the hive files, determine the
	** postfix we are going to use to recognise hives when we
	** search the active hivelist key. To do this we just need to
	** lose the drive letter and the colon in the path, or to put
	** it another way, lose everthing before the first '\'. When
	** we are done, if everything works ucsRegistryHivePath will
	** look something like '\Windows\system32\config\'
	*/
	for (dwCharIndex = 0;
	     (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)))
		 && (DIR_SEP_CHAR != ucsRegistryHivePath.Buffer [dwCharIndex]);
	     dwCharIndex++)
	    {
	    /*
	    ** Empty loop body
	    */
	    }

	BS_ASSERT (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)));

	hrStatus = StringCreateFromString (&ucsHiveRecognitionPostfix, 
					   &ucsRegistryHivePath.Buffer [dwCharIndex]);
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** We now have all the pieces in place so go search the
	** hivelist for the hives to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (hive list)", 
		    L"CShimWriterConfigDir::PopulateStopListRegistry");
	}



    while (SUCCEEDED (hrStatus) && bContinueHiveSearch)
	{
	DWORD	dwValueNameLength = ucsValueName.MaximumLength / sizeof (WCHAR);
	DWORD	dwValueDataLength = ucsValueData.MaximumLength;
	DWORD	dwValueType       = REG_NONE;
	BOOL	bMatchPrefix;
	BOOL	bMatchPostfix;


	StringTruncate (&ucsValueName, 0);
	StringTruncate (&ucsValueData, 0);


	/*
	** should be of type REG_SZ
	*/
	winStatus = RegEnumValueW (hkeyHivelist,
				   iIndex,
				   ucsValueName.Buffer,
				   &dwValueNameLength,
				   NULL,
				   &dwValueType,
				   (PBYTE)ucsValueData.Buffer,
				   &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueHiveSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumValueW", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");
	    }

	else
	    {
	    UNICODE_STRING	ucsPostFix;

	    BS_ASSERT ((REG_SZ == dwValueType) && L"Not REG_SZ string as expected");

	    ucsValueName.Length = (USHORT)(dwValueNameLength * sizeof (WCHAR));
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueName.Buffer [ucsValueName.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    /*
	    ** If it's to be considered part of system state the hive
	    ** file itself must live in %SystemRoot%\system32\config
	    ** so we attempt to find something in the returned value
	    ** name which looks like it might match. The format of the
	    ** name we are expecting is something like
	    **
	    **	\Device\<Volume>\Windows\system32\config\filename
	    **
	    ** for a system which has system32 in the 'Windows'
	    ** directory.  
	    **
	    ** Now, we have a known prefix, '\Device\', and the
	    ** postfix before and including the last '\', something
	    ** like '\Windows\system32\config\' as we determined
	    ** earlier. So we should be in a position to identify the
	    ** hives files we are interested in. Remember, we don't
	    ** know the piece representing the actual volume which is
	    ** why we are doing all this matching of pre and
	    ** post-fixs.
	    */
	    bMatchPrefix = RtlPrefixUnicodeString (&ucsHiveRecognitionPrefix,
						   &ucsValueData,
						   TRUE);


	    /*
	    ** Locate the last '\' in the value data. After this will
	    ** be the filename (eg 'SAM') which we will want later and
	    ** before that should be the postfix (eg
	    ** '\Windows\system32\config\') by which we will recognise
	    ** this as a registry hive.
	    */
	    pwchLastSlash = wcsrchr (ucsValueData.Buffer, DIR_SEP_CHAR);

	    if ((NULL == pwchLastSlash) ||
		(ucsValueData.Length < (ucsHiveRecognitionPrefix.Length + ucsHiveRecognitionPostfix.Length)))
		{
		/*
		** We coundn't find a '\' or the value data wasn't
		** long enough.
		*/
		bMatchPostfix = FALSE;
		}
	    else
		{
		/*
		** Determine the name of the give file.
		*/
		pwszFilename = pwchLastSlash + 1;


		/*
		** Determine the postfix we are going to try to match
		** against. This should look something like
		** '\Windows\system32\config\SAM'.
		*/
		StringInitialise (&ucsPostFix,
				  pwszFilename - (ucsHiveRecognitionPostfix.Length / sizeof (WCHAR)));


		/*
		** See if the recognition string (eg
		** '\Windows\system32\config\') is a prefix of the
		** location of this hive file (eg
		** '\Windows\system32\config\SAM')
		*/
		bMatchPostfix = RtlPrefixUnicodeString (&ucsHiveRecognitionPostfix,
							&ucsPostFix,
							TRUE);
		}


	    if (bMatchPrefix && bMatchPostfix)
		{
		USHORT	usOriginalFilenameLength;


		/*
		** We got ourselves a real live registry hive! The
		** means we add the filename itself along with the
		** same name with .sav, .alt and .log extensions.
		*/
		StringTruncate (&ucsRegistryHivePath, 0);
		StringAppendString (&ucsRegistryHivePath, pwszFilename);

		usOriginalFilenameLength = ucsRegistryHivePath.Length / sizeof (WCHAR);


		hrStatus = VertexAdd (&ucsRegistryHivePath);

		if (SUCCEEDED (hrStatus))
		    {
		    StringAppendString (&ucsRegistryHivePath, L".alt");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }

		if (SUCCEEDED (hrStatus))
		    {
		    StringTruncate     (&ucsRegistryHivePath, usOriginalFilenameLength);
		    StringAppendString (&ucsRegistryHivePath, L".sav");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }

		if (SUCCEEDED (hrStatus))
		    {
		    StringTruncate     (&ucsRegistryHivePath, usOriginalFilenameLength);
		    StringAppendString (&ucsRegistryHivePath, L".log");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    iIndex++;
	    }
	}




    if (bHivelistKeyOpened)
	{
	RegCloseKey (hkeyHivelist);
	}

    StringFree (&ucsHiveRecognitionPostfix);
    StringFree (&ucsRegistryHivePath);
    StringFree (&ucsValueData);
    StringFree (&ucsValueName);



    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopListRegistry () */



HRESULT CShimWriterConfigDir::CleanupStopList ()
    {
    HRESULT		hrStatus          = NOERROR;
    ULONG		ulNumberOfEntries = RtlNumberGenericTableElements (&m_StopList);
    BOOL		bSucceeded        = FALSE;
    PVERTEXRECORD	pSearchRecord     = NULL;
    PVERTEXRECORD	pStopListEntry;


    pSearchRecord = (PVERTEXRECORD) HeapAlloc (GetProcessHeap (),
					       HEAP_ZERO_MEMORY,
					       sizeof (VERTEXRECORD) + (MAX_PATH * sizeof (WCHAR)));

    hrStatus = GET_STATUS_FROM_POINTER (pSearchRecord);



    if (SUCCEEDED (hrStatus))
	{
	StringInitialise (&pSearchRecord->ucsVertexName);

	pSearchRecord->ucsVertexName.Buffer = (PWCHAR)((PBYTE)pSearchRecord + sizeof (VERTEXRECORD));
	}



    while (SUCCEEDED (hrStatus) && ulNumberOfEntries--)
	{
	pStopListEntry = (PVERTEXRECORD) RtlGetElementGenericTable (&m_StopList, ulNumberOfEntries);

	StringCreateFromString (&pSearchRecord->ucsVertexName, &pStopListEntry->ucsVertexName);

	bSucceeded = RtlDeleteElementGenericTable (&m_StopList, pSearchRecord);
	}



    BS_ASSERT (RtlIsGenericTableEmpty (&m_StopList));


    if (NULL != pSearchRecord)
	{
	HeapFree (GetProcessHeap (), 0, pSearchRecord);
	}


    return (hrStatus);
    } /* CShimWriterConfigDir::CleanupStopList () */


BOOL CShimWriterConfigDir::FileInStopList (PWCHAR pwszFilename)
    {
    BOOL		bFoundInStoplist;
    VERTEXRECORD	SearchRecord;
    PVERTEXRECORD	pVertexRecord;



    bFoundInStoplist = NameIsDotOrDotDot (pwszFilename);

    if (!bFoundInStoplist)
	{
	StringCreateFromString (&SearchRecord.ucsVertexName, pwszFilename);

	pVertexRecord = (PVERTEXRECORD) RtlLookupElementGenericTable (&m_StopList, (PVOID) &SearchRecord);

	bFoundInStoplist = (NULL != pVertexRecord);

	StringFree (&SearchRecord.ucsVertexName);
	}


    return (bFoundInStoplist);
    } /* CShimWriterConfigDir::FileInStopList () */


HRESULT CShimWriterConfigDir::CopyConfigDirFiles ()
    {
    CVssFunctionTracer ft( VSSDBG_SHIM, L"CShimWriterConfigDir::CopyConfigDirFiles" );        
    HRESULT		hrStatus   = NOERROR;
    BOOL		bMoreFiles = FALSE;
    BOOL		bSucceeded;
    HANDLE		hFileScan;
    WIN32_FIND_DATA	sFileInformation;
    UNICODE_STRING	ucsFileSourcePath;
    UNICODE_STRING	ucsFileTargetPath;
    USHORT		usFileSourcePathOriginalLength;
    USHORT		usFileTargetPathOriginalLength;

    StringInitialise (&ucsFileSourcePath);
    StringInitialise (&ucsFileTargetPath);


    hrStatus = StringCreateFromExpandedString (&ucsFileSourcePath,
					       CONFIGDIR_SOURCE_PATH,
					       MAX_PATH);

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsFileTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsFileSourcePath, DIR_SEP_STRING);
	StringAppendString (&ucsFileTargetPath, DIR_SEP_STRING);


	usFileSourcePathOriginalLength = ucsFileSourcePath.Length / sizeof (WCHAR);
	usFileTargetPathOriginalLength = ucsFileTargetPath.Length / sizeof (WCHAR);


	StringAppendString (&ucsFileSourcePath, L"*");


	hFileScan = FindFirstFileW (ucsFileSourcePath.Buffer,
				    &sFileInformation);

	hrStatus = GET_STATUS_FROM_HANDLE (hFileScan);

	LogFailure (&ft, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"FindFirstFileW", 
		    L"CShimWriterConfigDir::CopyConfigDirFiles");
	}


    if (SUCCEEDED (hrStatus))
	{
	do
	    {
	    if (!FileInStopList (sFileInformation.cFileName))
		{
		StringTruncate (&ucsFileSourcePath, usFileSourcePathOriginalLength);
		StringTruncate (&ucsFileTargetPath, usFileTargetPathOriginalLength);

		StringAppendString (&ucsFileSourcePath, sFileInformation.cFileName);
		StringAppendString (&ucsFileTargetPath, sFileInformation.cFileName);


		bSucceeded = CopyFileExW (ucsFileSourcePath.Buffer,
					  ucsFileTargetPath.Buffer,
					  NULL,
					  NULL,
					  FALSE,
					  0);

		hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

                if ( FAILED( hrStatus ) )
                    {
                    ft.Trace( VSSDBG_SHIM, L"CopyFileExW( '%s', '%s', ... ) failed with rc: %d", 
                            ucsFileSourcePath.Buffer, ucsFileTargetPath.Buffer, ::GetLastError() );
                    hrStatus = S_OK;   // Make sure to clear out the error
                    }
                }


	    bMoreFiles = FindNextFileW (hFileScan, &sFileInformation);
	    } while ( bMoreFiles );


	bSucceeded = FindClose (hFileScan);
	}



    StringFree (&ucsFileTargetPath);
    StringFree (&ucsFileSourcePath);

    return (hrStatus);
    } /* CShimWriterConfigDir::CopyConfigDirFiles () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtcommon\common.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation


Abstract:

    module common.cxx | Implementation of SnapshotWriter common code

Author:

    Michael C. Johnson [mikejohn] 03-Feb-2000
    Stefan R. Steiner [SSteiner] 27-Jul-2001

Description:
        
    Contains general code and definitions used by the Shim writer and the various other writers.

Revision History:

reuvenl		05/02/2002		Incorporated code from common.h/cpp into this module

--*/


#include "stdafx.h"
#include "vssmsg.h"
#include "wrtcommon.hxx"
#include <accctrl.h>
#include <aclapi.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCOMNC"

// Definitions for internal static functions
static HRESULT ConstructSecurityAttributes (
    IN OUT PSECURITY_ATTRIBUTES  psaSecurityAttributes,
    IN BOOL                      bIncludeBackupOperator
    );

static VOID CleanupSecurityAttributes(
    IN PSECURITY_ATTRIBUTES psaSecurityAttributes
    );

static BOOL FixupFileInfo(
	IN LPCWSTR pwszPathName,
	IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	IN DWORD dwExtraAttributes);

static PWCHAR const GetStringFromStateCode (DWORD dwState);

static DWORD const GetControlCodeFromTargetState (const DWORD dwTargetState);

static DWORD const GetNormalisedState (DWORD dwCurrentState);

static HRESULT WaitForServiceToEnterState (SC_HANDLE   shService, 
					   DWORD       dwMaxDelayInMilliSeconds, 
					   const DWORD dwDesiredState);

/* 
** The first group of (overloaded) routines manipulate UNICODE_STRING
** strings. The rules which apply here are:
**
** 1) The Buffer field points to an array of characters (WCHAR) with
** the length of the buffer being specified in the MaximumLength
** field. If the Buffer field is non-NULL it must point to a valid
** buffer capable of holding at least one character.  If the Buffer
** field is NULL, the MaximumLength and Length fields must both be
** zero.
**
** 2) Any valid string in the buffer is always terminated with a
** UNICODE_NULL.
**
** 3) the MaximumLength describes the length of the buffer measured in
** bytes. This value must be even.
**
** 4) The Length field describes the number of valid characters in the
** buffer measured in BYTES, excluding the termination
** character. Since the string must always have a termination
** character ('\0'), the maximum value of Length is MaximumLength - 2.
**
**
** The routines available are:-
**
**	StringInitialise ()
**	StringTruncate ()
**	StringSetLength ()
**	StringAllocate ()
**	StringFree ()
**	StringCreateFromString ()
**	StringAppendString ()
**	StringCreateFromExpandedString ()
** 
*/


/*
**++
**
**  Routine Description:
**
**
**  Arguments:
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT StringInitialise (PUNICODE_STRING pucsString)
    {
    pucsString->Buffer        = NULL;
    pucsString->Length        = 0;
    pucsString->MaximumLength = 0;

    return (NOERROR);
    } /* StringInitialise () */


HRESULT StringInitialise (PUNICODE_STRING pucsString, LPCWSTR pwszString)
    {
    return (StringInitialise (pucsString, (PWCHAR) pwszString));
    }

HRESULT StringInitialise (PUNICODE_STRING pucsString, PWCHAR pwszString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pwszString) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Buffer        = pwszString;
	pucsString->Length        = (USHORT) ulStringLength;
	pucsString->MaximumLength = (USHORT) (ulStringLength + sizeof (UNICODE_NULL));
	}


    return (hrStatus);
    } /* StringInitialise () */


HRESULT StringTruncate (PUNICODE_STRING pucsString, USHORT usSizeInChars)
    {
    HRESULT	hrStatus    = NOERROR;
    USHORT	usNewLength = (USHORT)(usSizeInChars * sizeof (WCHAR));

    if (usNewLength > pucsString->Length)
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Buffer [usSizeInChars] = UNICODE_NULL;
	pucsString->Length                 = usNewLength;
	}


    return (hrStatus);
    } /* StringTruncate () */


HRESULT StringSetLength (PUNICODE_STRING pucsString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pucsString->Buffer) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Length        = (USHORT) ulStringLength;
	pucsString->MaximumLength = (USHORT) UMAX (pucsString->MaximumLength,
						   pucsString->Length + sizeof (UNICODE_NULL));
	}


    return (hrStatus);
    } /* StringSetLength () */


HRESULT StringAllocate (PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes)
    {
    HRESULT	hrStatus      = NOERROR;
    LPVOID	pvBuffer      = NULL;
    SIZE_T	cActualLength = 0;


    pvBuffer = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, usMaximumStringLengthInBytes);

    hrStatus = GET_STATUS_FROM_POINTER (pvBuffer);


    if (SUCCEEDED (hrStatus))
	{
	pucsString->Buffer        = (PWCHAR)pvBuffer;
	pucsString->Length        = 0;
	pucsString->MaximumLength = usMaximumStringLengthInBytes;


	cActualLength = HeapSize (GetProcessHeap (), 0, pvBuffer);

	if ((cActualLength <= MAXUSHORT) && (cActualLength > usMaximumStringLengthInBytes))
	    {
	    pucsString->MaximumLength = (USHORT) cActualLength;
	    }
	}


    return (hrStatus);
    } /* StringAllocate () */


HRESULT StringFree (PUNICODE_STRING pucsString)
    {
    HRESULT	hrStatus = NOERROR;
    BOOL	bSucceeded;


    if (NULL != pucsString->Buffer)
	{
	bSucceeded = HeapFree (GetProcessHeap (), 0, pucsString->Buffer);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
	}


    if (SUCCEEDED (hrStatus))
	{
	pucsString->Buffer        = NULL;
	pucsString->Length        = 0;
	pucsString->MaximumLength = 0;
	}


    return (hrStatus);
    } /* StringFree () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString)
    {
    HRESULT	hrStatus = NOERROR;


    hrStatus = StringAllocate (pucsNewString, pucsOriginalString->MaximumLength);


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pucsOriginalString->Buffer, pucsOriginalString->Length);

	pucsNewString->Length = pucsOriginalString->Length;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pwszOriginalString) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pwszOriginalString, ulStringLength);

	pucsNewString->Length = (USHORT) ulStringLength;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = pucsOriginalString->MaximumLength + (dwExtraChars * sizeof (WCHAR));


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pucsOriginalString->Buffer, pucsOriginalString->Length);

	pucsNewString->Length = pucsOriginalString->Length;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = (wcslen (pwszOriginalString) + dwExtraChars) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pwszOriginalString, wcslen(pwszOriginalString)*sizeof(WCHAR));

	pucsNewString->Length = (USHORT) (wcslen(pwszOriginalString)*sizeof(WCHAR));

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringAppendString (PUNICODE_STRING pucsTarget, PUNICODE_STRING pucsSource)
    {
    HRESULT	hrStatus = NOERROR;

    if (pucsSource->Length > (pucsTarget->MaximumLength - pucsTarget->Length - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	memmove (&pucsTarget->Buffer [pucsTarget->Length / sizeof (WCHAR)],
		 pucsSource->Buffer,
		 pucsSource->Length + sizeof (UNICODE_NULL));

	pucsTarget->Length += pucsSource->Length;
	}


    /*
    ** There should be no reason in this code using this routine to
    ** have to deal with a short buffer so trap potential problems.
    */
    BS_ASSERT (SUCCEEDED (hrStatus));


    return (hrStatus);
    } /* StringAppendString () */


HRESULT StringAppendString (PUNICODE_STRING pucsTarget, PWCHAR pwszSource)
    {
    HRESULT		hrStatus = NOERROR;
    UNICODE_STRING	ucsSource;


    StringInitialise (&ucsSource, pwszSource);

    hrStatus = StringAppendString (pucsTarget, &ucsSource);


    /*
    ** There should be no reason in this code using this routine to
    ** have to deal with a short buffer so trap potential problems.
    */
    BS_ASSERT (SUCCEEDED (hrStatus));


    return (hrStatus);
    } /* StringAppendString () */


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString)
    {
    return (StringCreateFromExpandedString (pucsNewString, pwszOriginalString, 0));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString)
    {
    return (StringCreateFromExpandedString (pucsNewString, pucsOriginalString->Buffer, 0));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars)
    {
    return (StringCreateFromExpandedString (pucsNewString, pucsOriginalString->Buffer, dwExtraChars));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus = NOERROR;
    DWORD	dwStringLength;


    /*
    ** Remember, ExpandEnvironmentStringsW () includes the terminating null in the response.
    */
    dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString, NULL, 0) + dwExtraChars;

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwStringLength);



    if (SUCCEEDED (hrStatus) && ((dwStringLength * sizeof (WCHAR)) > MAXUSHORT))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT)(dwStringLength * sizeof (WCHAR)));
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Note that if the expanded string has gotten bigger since we
	** allocated the buffer then too bad, we may not get all the
	** new translation. Not that we really expect these expanded
	** strings to have changed any time recently.
	*/
	dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString,
						    pucsNewString->Buffer,
						    pucsNewString->MaximumLength / sizeof (WCHAR));

	hrStatus = GET_STATUS_FROM_BOOL (0 != dwStringLength);


	if (SUCCEEDED (hrStatus))
	    {
	    pucsNewString->Length = (USHORT) ((dwStringLength - 1) * sizeof (WCHAR));
	    }
	}


    return (hrStatus);
    } /* StringCreateFromExpandedString () */



/*
**++
**
**  Routine Description:
**
**	Closes a standard Win32 handle and set it to INVALID_HANDLE_VALUE. 
**	Safe to be called multiple times on the same handle or on a handle 
**	initialised to INVALID_HANDLE_VALUE or NULL.
**
**
**  Arguments:
**
**	phHandle	Address of the handle to be closed
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	Any HRESULT from CloseHandle()
**
**-- 
*/

HRESULT CommonCloseHandle (PHANDLE phHandle)
    {
    CVssFunctionTracer ft(VSSDBG_WRTCMN, L"CommonCloseHandle");
    
    HRESULT	hrStatus = NOERROR;
    BOOL	bSucceeded;


    if ((INVALID_HANDLE_VALUE != *phHandle) && (NULL != *phHandle))
	{
	bSucceeded = CloseHandle (*phHandle);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	if (SUCCEEDED (hrStatus))
	    {
	    *phHandle = INVALID_HANDLE_VALUE;
	    }
	}


    return (hrStatus);
    } /* CommonCloseHandle () */

#define VALID_PATH( path ) ( ( (wcslen(path) >= 2) && ( path[0] == DIR_SEP_CHAR )  && ( path[1] == DIR_SEP_CHAR ) ) || \
                             ( (wcslen(path) >= 3) && iswalpha( path[0] ) && ( path[1] == L':' ) && ( path[2] == DIR_SEP_CHAR ) ) )

/*++
**
** Routine Description:
**
**      Creates any number of directories along a path.  Only works for
**      full path names with no relative elements in it.  Other than that
**      it works identically as CreateDirectory() works and sets the same
**      error codes except it doesn't return an error if the complete
**      path already exists.
**
** Arguments:
**
**      pwszPathName - The path with possible directory components to create.
**
**      lpSecurityAttributes -
**
** Return Value:
**
**      TRUE - Sucessful
**      FALSE - GetLastError() can return one of these (and others):
**              ERROR_ALREADY_EXISTS - when something other than a file exists somewhere in the path.
**              ERROR_BAD_PATHNAME   - when \\servername alone is specified in the pathname
**              ERROR_ACCESS_DENIED  - when x:\ alone is specified in the pathname and x: exists
**              ERROR_PATH_NOT_FOUND - when x: alone is specified in the pathname and x: doesn't exist.
**                                     Should not get this error code for any other reason.
**              ERROR_INVALID_NAME   - when pathname doesn't start with either x:\ or \\
**
**--
*/

BOOL VsCreateDirectories (
    IN LPCWSTR pwszPathName,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwExtraAttributes)
{
    DWORD dwObjAttribs, dwRetPreserve;
    BOOL bRet;

    CVssFunctionTracer ft(VSSDBG_WRTCMN, L"VsCreateDirectories");
    
    /*
    ** Make sure the path starts with the valid path prefixes
    */
    if (!VALID_PATH (pwszPathName))
    {
        SetLastError (ERROR_INVALID_NAME);
            return FALSE;
    }

    /*
    ** Save away the current last error code.
    */
    dwRetPreserve = GetLastError ();


    /*
    **  Now test for the most common case, the directory already exists.  This
    **  is the performance path.
    */

    dwObjAttribs = GetFileAttributesW (pwszPathName);
   
    if ((dwObjAttribs != 0xFFFFFFFF) && (dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY))
    {
        /*
        ** Don't return an error if the directory already exists.
        ** This is the one case where this function differs from
        ** CreateDirectory().  Notice that even though another type of
        ** file may exist with this pathname, no error is returned yet
        ** since I want the error to come from CreateDirectory() to
        ** get CreateDirectory() error behavior.
        **
        ** Since we're successful restore the last error code.
        */

        if (FixupFileInfo(pwszPathName, lpSecurityAttributes, dwExtraAttributes) == TRUE)
        {
        	SetLastError (dwRetPreserve);
	        return TRUE;
        }

        return FALSE;
    }


    /*
    ** Now try to create the directory using the full path.  Even
    ** though we might already know it exists as something other than
    ** a directory, get the error from CreateDirectory() instead of
    ** having to try to reverse engineer all possible errors that
    ** CreateDirectory() can return in the above code.
    **
    ** It is probably the second most common case that when this
    ** function is called that only the last component in the
    ** directory doesn't exist.  Let's try to make it.
    **
    ** Note that it appears if a UNC path is given with a number of
    ** non-existing path components the remote server automatically
    ** creates all of those components when CreateDirectory is called.
    ** Therefore, the next call is almost always successful when the
    ** path is a UNC.
    */
    bRet = CreateDirectoryW (pwszPathName, lpSecurityAttributes);

    if (bRet)
    {
        SetFileAttributesW (pwszPathName, dwExtraAttributes);

        /*
        ** Set it back to the last error code
        */
        SetLastError (dwRetPreserve);
        return TRUE;
    }

    else if (GetLastError () == ERROR_ALREADY_EXISTS)
    {
        /*
        ** Looks like someone created the name while we weren't
        ** looking. Check to see if it's a directory and return
        ** success if so, otherwise return the error that
        ** CreateDirectoryW() set.
        */
        dwObjAttribs = GetFileAttributesW (pwszPathName);

        if ((dwObjAttribs != 0xFFFFFFFF) && (dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY))
        {
            /*
            ** It's a directory. Declare victory.
            **
            ** Restore the last error code
            */

            if (FixupFileInfo(pwszPathName, lpSecurityAttributes, dwExtraAttributes) == TRUE)
            {
            	SetLastError (dwRetPreserve);
	       return TRUE;
            }
            return FALSE;
        }
        else
        {
            SetLastError (ERROR_ALREADY_EXISTS);

            return FALSE;
        }
    }
    else if (GetLastError () != ERROR_PATH_NOT_FOUND )
    {
        return FALSE;
    }

    /*
    ** Allocate memory to hold the string while processing the path.
    ** The passed in string is a const.
    */
    PWCHAR pwszTempPath = (PWCHAR) malloc ((wcslen (pwszPathName) + 1) * sizeof (WCHAR));

    BS_ASSERT (pwszTempPath != NULL);

    wcscpy (pwszTempPath, pwszPathName);

    /*
    ** Appears some components in the path don't exist.  Now try to
    ** create the components.
    */
    PWCHAR pwsz, pwszSlash;

    /*
    ** First skip the drive letter part or the \\server\sharename
    ** part and get to the first slash before the first level
    ** directory component.
    */
    if (pwszTempPath [1] == L':')
    {
        /*
        **  Path in the form of x:\..., skip first 2 chars
        */
        pwsz = pwszTempPath + 2;
    }
    else
    {
        /*
        ** Path should be in form of \\servername\sharename.  Can be
        ** \\?\d: Search to first slash after sharename
        **
        ** First search to first char of the share name
        */
        pwsz = pwszTempPath + 2;

        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
        {
            ++pwsz;
        }


        /*
        ** Eat up all continuous slashes and get to first char of the
        ** share name
        */
        while (*pwsz == DIR_SEP_CHAR)
        {
            ++pwsz;
        }


        if (*pwsz == L'\0')
        {
            /*
            ** This shouldn't have happened since the CreateDirectory
            ** call should have caught it.  Oh, well, deal with it.
            */
            SetLastError (ERROR_BAD_PATHNAME);

            free (pwszTempPath);

            return FALSE;
        }


        /*
        ** Now at first char of share name, let's search for first
        ** slash after the share name to get to the (first) shash in
        ** front the first level directory.
        */
        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
        {
            ++pwsz;
        }
    }


    /*
    ** Eat up all continuous slashes before the first level directory
    */
    while (*pwsz == DIR_SEP_CHAR)
    {
        ++pwsz;
    }


    /*
    ** Now at first char of the first level directory, let's search
    ** for first slash after the directory.
    */
    while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
    {
        ++pwsz;
    }


    /*
    ** If pwsz is pointing to a null char, that means only the first
    ** level directory needs to be created.  Fall through to the leaf
    ** node create directory.
    */
    while (*pwsz != L'\0')
    {
        pwszSlash = pwsz;  //  Keep pointer to the separator

        /*
        **  Eat up all continuous slashes.
        */
        while (*pwsz == DIR_SEP_CHAR)
        {
            ++pwsz;
        }


        if (*pwsz == L'\0')
        {
            /*
            ** There were just slashes at the end of the path.  Break
            ** out of loop, let the leaf node CreateDirectory create
            ** the last directory.
            */
            break;
        }


        /*
        ** Terminate the directory path at the current level.
        */
        *pwszSlash = L'\0';

        dwObjAttribs = GetFileAttributesW (pwszTempPath);

        if ((dwObjAttribs == 0XFFFFFFFF) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
        {
            bRet = CreateDirectoryW (pwszTempPath, lpSecurityAttributes);

            if (bRet)
            {
                SetFileAttributesW (pwszTempPath, dwExtraAttributes);
            }
            else
            {
                if (ERROR_ALREADY_EXISTS != GetLastError ())
                {
                    /*
                    **  Restore the slash.
                    */
                    *pwszSlash = DIR_SEP_CHAR;

                    free (pwszTempPath);
                    
                    return FALSE;
                }
                else
                {
                    /* 
                    ** Looks like someone created the name whilst we
                    ** weren't looking. Check to see if it's a
                    ** directory and continue if so, otherwise return
                    ** the error that CreateDirectoryW() set.
                    */
                    dwObjAttribs = GetFileAttributesW (pwszTempPath);

                    if ((dwObjAttribs == 0xFFFFFFFF) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
                        {
                        /*
                        ** It's not what we recognise as a
                        ** directory. Declare failure. Set the error
                        ** code to that which CreateDirectoryW()
                        ** returned, restore the slash, free the
                        ** buffer and get out of here.
                        */
                        SetLastError (ERROR_ALREADY_EXISTS);

                        *pwszSlash = DIR_SEP_CHAR;

                        free (pwszTempPath);

                        return FALSE;
                    }

			/*
			** If someone deletes the directory right before FixupFileInfo is called, the function will fail, and we'll return a 
			** partially-constructed directory tree.  This is not expected to happen (and the way we use these functions, only an
			** Administrator can do this), so it's not worth the effort to retry on failure */
                    if (FixupFileInfo(pwszTempPath, lpSecurityAttributes, dwExtraAttributes) == FALSE)
                    {
                    	   free(pwszTempPath);

                    	   return FALSE;
                    }
                }
            }
        }


        /*
        **  Restore the slash.
        */
        *pwszSlash = DIR_SEP_CHAR;

        /*
        ** Now at first char of the next level directory, let's search
        ** for first slash after the directory.
        */
        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
        {
            ++pwsz;
        }
    }


    free (pwszTempPath);

    pwszTempPath = NULL;


    /*
    **  Now make the last directory.
    */
    dwObjAttribs = GetFileAttributesW (pwszPathName);

    if ((dwObjAttribs == 0xFFFFffff) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
    {
        bRet = CreateDirectoryW (pwszPathName, lpSecurityAttributes);

        if (bRet)
        {
            SetFileAttributesW (pwszPathName, dwExtraAttributes);
        }
        else
        {
            // someone sneakily created the directory here
            dwObjAttribs = GetFileAttributesW (pwszPathName);
            if ((dwObjAttribs != 0xFFFFFFFF) && ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) != 0))
            {
            	if (FixupFileInfo(pwszPathName, lpSecurityAttributes, dwExtraAttributes) == FALSE)
            		return FALSE;
            }
            else
	            return FALSE;
        }
    }
    else if ( (dwObjAttribs != 0xFFFFFFFF) && ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) != 0))	// or here
    {
    	if (FixupFileInfo(pwszPathName, lpSecurityAttributes, dwExtraAttributes) == FALSE)
    		return FALSE;
    }


    SetLastError (dwRetPreserve);    //  Set back old last error code
    return TRUE;
}

/*
**++
**
**  Routine Description:
**
**      Changes the attributes and security information 
**      for a file or a directory.
**
**  Arguments:
**
**      pwszPathName       	The directory path to change
**	   lpSecurityAttributes	The new security information for the directory
**	   dwExtraAttributes	The new attributes for the directory
**
**
**  Side Effects:
**
**      None
**
**
**  Return Value:
**
** 	TRUE	-- Success
	FALSE	-- Failure.  GetLastError will contain the appropriate error code except
**			    for the case where we tried this on something that isn't a directory
**
**--
*/

BOOL FixupFileInfo(
	IN LPCWSTR pwszPathName,
	IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	IN DWORD dwExtraAttributes)
{
	CVssFunctionTracer ft(VSSDBG_WRTCMN, L"FixupFileInfo");

	// try and push down the required attributes
	if (SetFileAttributes(pwszPathName, dwExtraAttributes) == FALSE)
	{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		return FALSE;
	}

	// gather security information from the security descriptor
	PSID pOwner = NULL;
	PSID pGroup = NULL;	
	PACL pDacl = NULL;
	PACL pSacl = NULL;
	BOOL ownerDefaulted, groupDefaulted, DaclDefaulted, SaclDefaulted, DaclPresent, SaclPresent;
	SECURITY_DESCRIPTOR_CONTROL control;
	DWORD revision = 0;
	
	if ((GetSecurityDescriptorOwner(lpSecurityAttributes->lpSecurityDescriptor, &pOwner, &ownerDefaulted) == FALSE) ||
	(GetSecurityDescriptorGroup(lpSecurityAttributes->lpSecurityDescriptor, &pGroup, &groupDefaulted) == FALSE) || 
	(GetSecurityDescriptorDacl(lpSecurityAttributes->lpSecurityDescriptor, &DaclPresent, &pDacl, &DaclDefaulted) == FALSE) ||
	(GetSecurityDescriptorSacl(lpSecurityAttributes->lpSecurityDescriptor, &SaclPresent, &pSacl, &SaclDefaulted) == FALSE) ||
	(GetSecurityDescriptorControl(lpSecurityAttributes->lpSecurityDescriptor, &control, &revision) == FALSE))
	{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		return FALSE;
	}
	
	SECURITY_INFORMATION securityInformation;
	securityInformation = ((pDacl != NULL) ? DACL_SECURITY_INFORMATION : 0)      	|
		
					    ((pDacl != NULL && ((control & SE_DACL_PROTECTED) != 0))
					                  ? PROTECTED_DACL_SECURITY_INFORMATION : 0)	|
					                  
					    ((pSacl != NULL) ? SACL_SECURITY_INFORMATION : 0)       	|

					    ((pSacl != NULL && ((control & SE_SACL_PROTECTED) != 0))
					    	          ? PROTECTED_SACL_SECURITY_INFORMATION : 0)	|
					    		    

					    ((pOwner != NULL) ? OWNER_SECURITY_INFORMATION : 0) 	|
					    
					    ((pGroup != NULL) ? GROUP_SECURITY_INFORMATION : 0);

	// push down the new security information to the file	
	ft.hr = SetNamedSecurityInfo(const_cast<LPWSTR>(pwszPathName), 
				SE_FILE_OBJECT, securityInformation, pOwner, pGroup, pDacl, pSacl);

	return ft.HrSucceeded();
}

/*
** The next set of rountes are used to change the state of SCM
** controlled services, typically between RUNNING and either PAUSED or
** STOPPED.
**
** The initial collection are for manipulating the states, control
** codes and getting the string equivalents to be used for tracing
** purposes.
**
** The major routines is VsServiceChangeState(). This is called
** specifying the reuiqred state for the service and after some
** validation, it makes the appropriate request of the SCM and calls
** WaitForServiceToEnterState() to wait until the services reaches the
** desired state, or it times out.  
*/

static PWCHAR const GetStringFromStateCode (DWORD dwState)
    {    
    PWCHAR	pwszReturnedString = NULL;


    switch (dwState)
	{
	case 0:                        pwszReturnedString = L"UnSpecified";     break;
	case SERVICE_STOPPED:          pwszReturnedString = L"Stopped";         break;
	case SERVICE_START_PENDING:    pwszReturnedString = L"StartPending";    break;
	case SERVICE_STOP_PENDING:     pwszReturnedString = L"StopPending";     break;
	case SERVICE_RUNNING:          pwszReturnedString = L"Running";         break;
	case SERVICE_CONTINUE_PENDING: pwszReturnedString = L"ContinuePending"; break;
	case SERVICE_PAUSE_PENDING:    pwszReturnedString = L"PausePending";    break;
	case SERVICE_PAUSED:           pwszReturnedString = L"Paused";          break;
	default:                       pwszReturnedString = L"UNKKNOWN STATE";  break;
	}


    return (pwszReturnedString);
    } /* GetStringFromStateCode () */


static DWORD const GetControlCodeFromTargetState (const DWORD dwTargetState)
    {
    DWORD	dwServiceControlCode;


    switch (dwTargetState)
	{
	case SERVICE_STOPPED: dwServiceControlCode = SERVICE_CONTROL_STOP;     break;
	case SERVICE_PAUSED:  dwServiceControlCode = SERVICE_CONTROL_PAUSE;    break;
	case SERVICE_RUNNING: dwServiceControlCode = SERVICE_CONTROL_CONTINUE; break;
	default:              dwServiceControlCode = 0;                        break;
	}

    return (dwServiceControlCode);
    } /* GetControlCodeFromTargetState () */


static DWORD const GetNormalisedState (DWORD dwCurrentState)
    {
    DWORD	dwNormalisedState;


    switch (dwCurrentState)
	{
	case SERVICE_STOPPED:
	case SERVICE_STOP_PENDING:
	    dwNormalisedState = SERVICE_STOPPED;
	    break;

	case SERVICE_START_PENDING:
	case SERVICE_CONTINUE_PENDING:
	case SERVICE_RUNNING:
	    dwNormalisedState = SERVICE_RUNNING;
	    break;

	case SERVICE_PAUSED:
	case SERVICE_PAUSE_PENDING:
	    dwNormalisedState = SERVICE_PAUSED;
	    break;

	default:
	    dwNormalisedState = 0;
	    break;
	}

    return (dwNormalisedState);
    } /* GetNormalisedState () */

/*
**++
**
**  Routine Description:
**
**	Wait for the specified service to enter the specified
**	state. The routine polls the serivce for it's current state
**	every dwServiceStatePollingIntervalInMilliSeconds milliseconds
**	to see if the service has reached the desired state. If the
**	repeated delay eventually reaches the timeout period the
**	routine stops polling and returns a failure status.
**
**	NOTE: since this routine just sleeps between service state 
**	interrogations, it effectively stalls from the point of view
**	of the caller.
**
**
**  Arguments:
**
**	shService			handle to the service being manipulated
**	dwMaxDelayInMilliSeconds	timeout period
**	dwDesiredState			state to move the service into
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	HRESULT for ERROR_TIMOUT if the service did not reach the required state in the required time
**
**-- 
*/

static HRESULT WaitForServiceToEnterState (SC_HANDLE   shService, 
					   DWORD       dwMaxDelayInMilliSeconds, 
					   const DWORD dwDesiredState)
    {
    CVssFunctionTracer ft (VSSDBG_WRTCMN, L"WaitForServiceToEnterState");

    DWORD		dwRemainingDelay = dwMaxDelayInMilliSeconds;
    DWORD		dwInitialState;
    const DWORD		dwServiceStatePollingIntervalInMilliSeconds = 100;
    BOOL		bSucceeded;
    SERVICE_STATUS	sSStat;



    try
	{
	bSucceeded = QueryServiceStatus (shService, &sSStat);

	ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);

	dwInitialState = sSStat.dwCurrentState;

	ft.Trace (VSSDBG_WRTCMN,
		  L"Initial QueryServiceStatus returned: 0x%08X with current state '%s' and desired state '%s'",
		  ft.hr,
		  GetStringFromStateCode (dwInitialState),
		  GetStringFromStateCode (dwDesiredState));


	while ((dwDesiredState != sSStat.dwCurrentState) && (dwRemainingDelay > 0))
	    {
	    Sleep (UMIN (dwServiceStatePollingIntervalInMilliSeconds, dwRemainingDelay));

	    dwRemainingDelay -= (UMIN (dwServiceStatePollingIntervalInMilliSeconds, dwRemainingDelay));

	    if (0 == dwRemainingDelay)
		{
		ft.Throw (VSSDBG_WRTCMN,
			  HRESULT_FROM_WIN32 (ERROR_TIMEOUT),
			  L"Exceeded maximum delay (%dms)",
			  dwMaxDelayInMilliSeconds);
		}

	    bSucceeded = QueryServiceStatus (shService, &sSStat);

	    ft.ThrowIf (!bSucceeded,
			VSSDBG_WRTCMN,
			GET_STATUS_FROM_BOOL (bSucceeded),
			L"QueryServiceStatus shows '%s' as current state",
			GetStringFromStateCode (sSStat.dwCurrentState));
	    }



	ft.Trace (VSSDBG_WRTCMN,
		  L"Service state change from '%s' to '%s' took %u milliseconds",
		  GetStringFromStateCode (dwInitialState),
		  GetStringFromStateCode (sSStat.dwCurrentState),
		  dwMaxDelayInMilliSeconds - dwRemainingDelay);
	}
    VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* WaitForServiceToEnterState () */

/*
**++
**
**  Routine Description:
**
**	Changes the state of a service if appropriate.
**
**
**  Arguments:
**
**	pwszServiceName		The real service name, i.e. cisvc
**	dwRequestedState	the state code for the state we wish to enter
**	pdwReturnedOldState	pointer to location to receive current service state.
**				Can be NULL of current state not required
**	pbReturnedStateChanged	pointer to location to receive flag indicating if  
**				service changed state. Pointer can be NULL if flag
**				value not required.
**
**
**  Return Value:
**
**	Any HRESULT resulting from faiure communication with the
**	SCM (Service Control Manager).
**
**--
*/

HRESULT VsServiceChangeState (LPCWSTR	pwszServiceName,
			      DWORD	dwRequestedState,
			      PDWORD	pdwReturnedOldState,
			      PBOOL	pbReturnedStateChanged)
    {
    CVssFunctionTracer ft (VSSDBG_WRTCMN, L"VsServiceChangeState");

    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;
    DWORD		dwOldState  = 0;
    BOOL		bSucceeded;
    SERVICE_STATUS	sSStat;
    const DWORD		dwNormalisedRequestedState = GetNormalisedState (dwRequestedState);


    ft.Trace (VSSDBG_WRTCMN,
	      L"Service '%s' requested to change to state '%s' (normalised to '%s')",
	      pwszServiceName,
	      GetStringFromStateCode (dwRequestedState),
	      GetStringFromStateCode (dwNormalisedRequestedState));


    RETURN_VALUE_IF_REQUIRED (pbReturnedStateChanged, FALSE);


    try
	{
        /*
	**  Connect to the local service control manager
        */
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

	ft.hr = GET_STATUS_FROM_HANDLE (shSCManager);

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_WRTCMN,
		    ft.hr,
		    L"Called OpenSCManager()");


        /*
	**  Get a handle to the service
        */
        shSCService = OpenService (shSCManager, pwszServiceName, SERVICE_ALL_ACCESS);

	ft.hr = GET_STATUS_FROM_HANDLE (shSCService);


	/*
	** If it's an invalid name or the service doesn't exist then
	** fail gracefully. For all other failures do the normal
	** thing. Oh yes, if on the off-chance we should happen to
	** succeed, carry on.
	*/
	if ((HRESULT_FROM_WIN32 (ERROR_INVALID_NAME)           == ft.hr) ||
	    (HRESULT_FROM_WIN32 (ERROR_SERVICE_DOES_NOT_EXIST) == ft.hr))
	    {
	    ft.Trace (VSSDBG_WRTCMN, L"'%s' service not found", pwszServiceName);
	    }

	else if (ft.HrFailed ())
	    {
	    /*
	    ** See if the service doesn't exist
            */
	    ft.Throw (VSSDBG_WRTCMN, E_FAIL, L"ERROR - OpenService() returned: %d", ft.hr);
	    }

        else
	    {
            /*
	    ** Now query the service to see what state it is in at the moment.
            */
	    bSucceeded = QueryServiceStatus (shSCService, &sSStat);

	    ft.ThrowIf (!bSucceeded,
			VSSDBG_WRTCMN,
			GET_STATUS_FROM_BOOL (bSucceeded),
			L"QueryServiceStatus shows '%s' as current state",
			GetStringFromStateCode (sSStat.dwCurrentState));


	    dwOldState = sSStat.dwCurrentState;



	    /*
	    ** Now we decide what to do.
	    **	    If we are already in the requested state, we do nothing.
	    **	    If we are stopped and are requested to pause, we do nothing
	    **	    otherwise we make the attempt to change state.
	    */
            if (dwNormalisedRequestedState == dwOldState)
		{
		/*
		** We are already in the requested state, so do
		** nothing. We should even tell folk of that. We're
		** proud to be doing nothing.
		*/
                ft.Trace (VSSDBG_WRTCMN,
			  L"'%s' service is already in requested state: doing nothing",
			  pwszServiceName);

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState, dwOldState);
		}

	    else if ((SERVICE_STOPPED == sSStat.dwCurrentState) && (SERVICE_PAUSED == dwNormalisedRequestedState))
		{
		/*
		** Do nothing. Just log the fact and move on.
		*/
		ft.Trace (VSSDBG_WRTCMN,
			  L"Asked to PAUSE the '%s' service which is already STOPPED",
			  pwszServiceName);

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState, dwOldState);
		}

	    else
		{
		/*
		** We want a state which is different from the one
		** we're in at the moment. Generally this just means
		** calling ControlService() asking for the new state
		** except if the service is currently stopped. If
		** that's so, then we call StartService()
		*/
		if (SERVICE_STOPPED == sSStat.dwCurrentState)
		    {
		    /*
		    ** Call StartService to get the ball rolling
		    */
		    bSucceeded = StartService (shSCService, 0, NULL);
		    }

		else
		    {
		    bSucceeded = ControlService (shSCService,
						 GetControlCodeFromTargetState (dwNormalisedRequestedState),
						 &sSStat);
		    }

		ft.ThrowIf (!bSucceeded,
			    VSSDBG_WRTCMN,
			    GET_STATUS_FROM_BOOL (bSucceeded),
			    (SERVICE_STOPPED == sSStat.dwCurrentState)
							? L"StartService attempting '%s' to '%s', now at '%s'"
							: L"ControlService attempting '%s' to '%s', now at '%s'",
			    GetStringFromStateCode (dwOldState),
			    GetStringFromStateCode (dwNormalisedRequestedState),
			    GetStringFromStateCode (sSStat.dwCurrentState));

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState,    dwOldState);
		RETURN_VALUE_IF_REQUIRED (pbReturnedStateChanged, TRUE);


		ft.hr = WaitForServiceToEnterState (shSCService, 15000, dwNormalisedRequestedState);

		if (ft.HrFailed ())
		    {
		    ft.Throw (VSSDBG_WRTCMN,
			      ft.hr,
			      L"WaitForServiceToEnterState() failed with 0x%08X",
			      ft.hr);
		    }

		}
	    }
	} VSS_STANDARD_CATCH (ft);



    /*
    **  Now close the service and service control manager handles
    */
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);

    return (ft.hr);
    } /* VsServiceChangeState () */

/*
**++
**
**  Routine Description:
**
**      Deletes all the sub-directories and files in the specified
**      directory and then deletes the directory itself.
**
**      If the directory does not exist then simply return S_OK.
**
**  Arguments:
**
**      pucsDirectoryPath       The directory path to clear out
**
**
**  Side Effects:
**
**      None
**
**
**  Return Value:
**
**      Out of memory or any HRESULT from
**
**              RemoveDirectory()
**              DeleteFile()
**              FindFirstFile()
**
**--
*/

HRESULT 	RemoveDirectoryTree (
    IN LPCWSTR pwszDirectoryPath
    )
{
    HANDLE              hFileScan               = INVALID_HANDLE_VALUE;
    DWORD               dwSubDirectoriesEntered = 0;
    INT                 iCurrentPathCursor      = 0;
    BOOL                bSucceeded;
    WIN32_FIND_DATAW    FileFindData;
    CBsString           cwsCurrentPath;

    CVssFunctionTracer ft(VSSDBG_WRTCMN, L"RemoveDirectoryTree");

    try
    {
        ft.Trace( VSSDBG_WRTCMN, L"Recursive delete of the '%s' directory", pwszDirectoryPath );
        
        cwsCurrentPath = pwszDirectoryPath;
        iCurrentPathCursor = cwsCurrentPath.ReverseFind( DIR_SEP_CHAR ) + 1;

        while ( 1 )
        {
            if ( HandleInvalid ( hFileScan ) )
            {
                /*
                ** No valid scan handle so start a new scan
                */
                ft.Trace( VSSDBG_WRTCMN, L"FindFirstFileW( %s, ... )", cwsCurrentPath.c_str() );
                
                hFileScan = FindFirstFileW( cwsCurrentPath, &FileFindData);
                if ( ( hFileScan == INVALID_HANDLE_VALUE ) && ( 
                        ( ::GetLastError() == ERROR_FILE_NOT_FOUND ) 
                        || ( ::GetLastError() == ERROR_PATH_NOT_FOUND ) 
                   ) )
                {
                    //  Directory is empty or does not exists
                    ft.hr = S_OK;
                    break;
                }                                        
                ft.hr = GET_STATUS_FROM_HANDLE( hFileScan );
                ft.CheckForError(VSSDBG_WRTCMN, L"RemoveDirectoryTree - FindFirstFileW");

                cwsCurrentPath.GetBufferSetLength( iCurrentPathCursor );
                cwsCurrentPath += FileFindData.cFileName;                
            }
            else
            {
                /*
                ** Continue with the existing scan
                */
                bSucceeded = FindNextFileW( hFileScan, &FileFindData );
                ft.hr = GET_STATUS_FROM_BOOL( bSucceeded );

                if ( HRESULT_FROM_WIN32( ERROR_NO_MORE_FILES ) == ft.hr )
                {
                    FindClose( hFileScan );
                    hFileScan = INVALID_HANDLE_VALUE;

                    if ( dwSubDirectoriesEntered > 0 )
                    {
                        /*
                        ** This is a scan of a sub-directory that is now 
                        ** complete so delete the sub-directory itself.
                        */
                        cwsCurrentPath.GetBufferSetLength( iCurrentPathCursor - 1 );
                        ft.Trace( VSSDBG_WRTCMN, L"RemoveDirectoryW( %s, ... )", cwsCurrentPath.c_str() );

                        bSucceeded = RemoveDirectoryW( cwsCurrentPath );
                        ft.hr = GET_STATUS_FROM_BOOL( bSucceeded );
                        ft.CheckForError(VSSDBG_WRTCMN, L"RemoveDirectoryTree - RemoveDirectoryW");

                        dwSubDirectoriesEntered--;
                    }

                    if ( 0 == dwSubDirectoriesEntered )
                    {
                        /*
                        ** We are back to where we started except that the 
                        ** requested directory is now gone. Time to leave.
                        */
                        ft.hr = S_OK;
                        break;
                    }
                    else
                    {
                        /*
                        ** Move back up one directory level, reset the cursor 
                        ** and prepare the path buffer to begin a new scan.
                        */
                        iCurrentPathCursor = cwsCurrentPath.ReverseFind( DIR_SEP_CHAR ) + 1;
                        
                        cwsCurrentPath.GetBufferSetLength( iCurrentPathCursor);
                        cwsCurrentPath += "\\*";
                    }

                    /*
                    ** No files to be processed on this pass so go back and try to 
                    ** find another or leave the loop as we've finished the task. 
                    */
                    continue;
                } 

                ft.CheckForError( VSSDBG_WRTCMN, L"RemoveDirectoryTree - FindNextFileW" );
                
                cwsCurrentPath.GetBufferSetLength( iCurrentPathCursor );
                cwsCurrentPath += FileFindData.cFileName;                
            }

            if (FileFindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                SetFileAttributesW (cwsCurrentPath, 
                                    FileFindData.dwFileAttributes ^ (FILE_ATTRIBUTE_READONLY));
            }


            if ( !NameIsDotOrDotDot( FileFindData.cFileName ) )
            {
                if ( ( FileFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) ||
                    !( FileFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
                {
                    ft.Trace( VSSDBG_WRTCMN, L"DeleteFileW( %s, ... )", cwsCurrentPath.c_str() );
                    bSucceeded = DeleteFileW( cwsCurrentPath );
                    ft.hr = GET_STATUS_FROM_BOOL( bSucceeded );
                    ft.CheckForError( VSSDBG_WRTCMN, L"RemoveDirectoryTree - DeleteFileW" );                
                }
                else
                {
                    ft.Trace( VSSDBG_WRTCMN, L"RemoveDirectoryW( %s, ... )", cwsCurrentPath.c_str() );
                    bSucceeded = RemoveDirectoryW( cwsCurrentPath );
        		    ft.hr = GET_STATUS_FROM_BOOL( bSucceeded );

        		    if ( HRESULT_FROM_WIN32( ERROR_DIR_NOT_EMPTY ) == ft.hr )
                    {
                        ft.Trace( VSSDBG_WRTCMN, L"Dir not empty after calling RemoveDirectoryW( %s, ... )", cwsCurrentPath.c_str() );
                        
                        /*
                        ** The directory wasn't empty so move down one level, 
                        ** close the old scan and start a new one. 
                        */
                        FindClose (hFileScan);
                        hFileScan = INVALID_HANDLE_VALUE;
                        
                        cwsCurrentPath += DIR_SEP_STRING L"*";
                        iCurrentPathCursor = cwsCurrentPath.GetLength() - 1;
                        dwSubDirectoriesEntered++;
                    }
        		    else 
        		    {
            		    ft.CheckForError( VSSDBG_WRTCMN, L"RemoveDirectoryTree - RemoveDirectoryW" );
        		    }
                }
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (!HandleInvalid (hFileScan)) 
        FindClose (hFileScan);

    return( ft.hr );
} /* RemoveDirectoryTree () */


/*
**++
**
**  Routine Description:
**
**      Routines to construct and cleanup a security descriptor which
**      can be applied to limit access to an object to member of
**      either the Administrators or Backup Operators group.
**
**
**  Arguments:
**
**      psaSecurityAttributes   Pointer to a SecurityAttributes
**                              structure which has already been
**                              setup to point to a blank
**                              security descriptor
**
**      eSaType                 What we are building the SA for
**
**      bIncludeBackupOperator  Whether or not to include an ACE to
**                              grant BackupOperator access
**
**
**  Return Value:
**
**      Any HRESULT from
**              InitializeSecurityDescriptor()
**              AllocateAndInitializeSid()
**              SetEntriesInAcl()
**              SetSecurityDescriptorDacl()
**
**--
*/

static HRESULT ConstructSecurityAttributes (
    IN OUT PSECURITY_ATTRIBUTES  psaSecurityAttributes,
    IN BOOL                      bIncludeBackupOperator
    )
{
    DWORD                       dwStatus;
    DWORD                       dwAccessMask         = 0;
    BOOL                        bSucceeded;
    PSID                        psidBackupOperators  = NULL;
    PSID                        psidAdministrators   = NULL;
    PACL                        paclDiscretionaryAcl = NULL;
    SID_IDENTIFIER_AUTHORITY    sidNtAuthority       = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS             eaExplicitAccess [2];

    CVssFunctionTracer ft(VSSDBG_WRTCMN, L"ConstructSecurityAttributes");

    try
    {
        dwAccessMask = FILE_ALL_ACCESS;

        /*
        ** Initialise the security descriptor.
        */
        bSucceeded = ::InitializeSecurityDescriptor (
            psaSecurityAttributes->lpSecurityDescriptor,
            SECURITY_DESCRIPTOR_REVISION
            );

        ft.hr = GET_STATUS_FROM_BOOL( bSucceeded );
        ft.CheckForError( VSSDBG_WRTCMN, L"InitializeSecurityDescriptor" );

        if ( bIncludeBackupOperator )
        {
            /*
            ** Create a SID for the Backup Operators group.
            */
            bSucceeded = ::AllocateAndInitializeSid (
                &sidNtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_BACKUP_OPS,
                0, 0, 0, 0, 0, 0,
                &psidBackupOperators
                );

            ft.hr = GET_STATUS_FROM_BOOL ( bSucceeded );
            ft.CheckForError( VSSDBG_WRTCMN, L"AllocateAndInitializeSid" );
        }

        /*
        ** Create a SID for the Administrators group.
        */
        bSucceeded = ::AllocateAndInitializeSid (
            &sidNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators);

        ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);
        ft.CheckForError( VSSDBG_WRTCMN, L"AllocateAndInitializeSid" );

        /*
        ** Initialize the array of EXPLICIT_ACCESS structures for an
        ** ACEs we are setting.
        **
        ** The first ACE allows the Backup Operators group full access
        ** and the second, allowa the Administrators group full
        ** access.
        */
        eaExplicitAccess[0].grfAccessPermissions             = dwAccessMask;
        eaExplicitAccess[0].grfAccessMode                    = SET_ACCESS;
        eaExplicitAccess[0].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        eaExplicitAccess[0].Trustee.pMultipleTrustee         = NULL;
        eaExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
        eaExplicitAccess[0].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
        eaExplicitAccess[0].Trustee.ptstrName                = (LPTSTR) psidAdministrators;


        if ( bIncludeBackupOperator )
        {
            eaExplicitAccess[1].grfAccessPermissions             = dwAccessMask;
            eaExplicitAccess[1].grfAccessMode                    = SET_ACCESS;
            eaExplicitAccess[1].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            eaExplicitAccess[1].Trustee.pMultipleTrustee         = NULL;
            eaExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            eaExplicitAccess[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
            eaExplicitAccess[1].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
            eaExplicitAccess[1].Trustee.ptstrName                = (LPTSTR) psidBackupOperators;
        }


        /*
        ** Create a new ACL that contains the new ACEs.
        */
        dwStatus = ::SetEntriesInAcl(
            bIncludeBackupOperator ? 2 : 1,
            eaExplicitAccess,
            NULL,
            &paclDiscretionaryAcl
            );

        ft.hr = HRESULT_FROM_WIN32 (dwStatus);
        ft.CheckForError( VSSDBG_WRTCMN, L"SetEntriesInAcl" );
        
        /*
        ** Add the ACL to the security descriptor.
        */
        bSucceeded = ::SetSecurityDescriptorDacl (
            psaSecurityAttributes->lpSecurityDescriptor,
            TRUE,
            paclDiscretionaryAcl,
            FALSE
            );

        ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);
        ft.CheckForError( VSSDBG_WRTCMN, L"SetSecurityDescriptorDacl" );

        paclDiscretionaryAcl = NULL;

        bSucceeded = ::SetSecurityDescriptorControl (
        	psaSecurityAttributes->lpSecurityDescriptor,
        	SE_DACL_PROTECTED,
        	SE_DACL_PROTECTED);
        ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);
        ft.CheckForError( VSSDBG_WRTCMN, L"SetSecurityDescriptorControl" );
    }
    VSS_STANDARD_CATCH( ft );

    /*
    ** Clean up any left over junk.
    */
    if ( NULL != psidAdministrators )    
        FreeSid ( psidAdministrators );
    if ( NULL != psidBackupOperators )   
        FreeSid ( psidBackupOperators );
    if ( NULL != paclDiscretionaryAcl )  
        LocalFree (paclDiscretionaryAcl );
    
    return ( ft.hr );
} /* ConstructSecurityAttributes () */


static VOID CleanupSecurityAttributes(
    IN PSECURITY_ATTRIBUTES psaSecurityAttributes
    )
{
    CVssFunctionTracer ft(VSSDBG_WRTCMN, L"CleanupSecurityAttributes");

    BOOL        bSucceeded;
    BOOL        bDaclPresent         = FALSE;
    BOOL        bDaclDefaulted       = TRUE;
    PACL        paclDiscretionaryAcl = NULL;

    try
    {
        bSucceeded = ::GetSecurityDescriptorDacl(
            psaSecurityAttributes->lpSecurityDescriptor,
            &bDaclPresent,
            &paclDiscretionaryAcl,
            &bDaclDefaulted
            );

        if ( bSucceeded && bDaclPresent && !bDaclDefaulted && ( NULL != paclDiscretionaryAcl ) )
        {
            LocalFree( paclDiscretionaryAcl );
        }
    }
    VSS_STANDARD_CATCH( ft );
} /* CleanupSecurityAttributes () */


/*
**++
**
**  Routine Description:
**
**      Creates a new target directory specified by the target path
**      member variable if not NULL. It will create any necessary
**      parent directories too.
**
**      NOTE: already exists type errors are ignored.
**
**
**  Arguments:
**
**      pwszTargetPath  directory to create and apply security attributes
**
**
**  Return Value:
**
**      Any HRESULT resulting from memory allocation or directory creation attempts.
**--
*/

HRESULT CreateTargetPath(
    IN LPCWSTR pwszTargetPath
    )
{
    CVssFunctionTracer ft(VSSDBG_WRTCMN, L"CreateTargetPath");

    ACL                 DiscretionaryAcl;
    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;
    BOOL                bSucceeded;
    DWORD               dwFileAttributes               = 0;
    const DWORD         dwExtraAttributes              = FILE_ATTRIBUTE_ARCHIVE |
                                                         FILE_ATTRIBUTE_HIDDEN  |
                                                         FILE_ATTRIBUTE_SYSTEM  |
                                                         FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;

    try
    {
        if ( NULL != pwszTargetPath )
        {
            /*
            ** We really want a no access acl on this directory but
            ** because of various problems with the EventLog and
            ** ConfigDir writers we will settle for admin or backup
            ** operator access only. The only possible accessor is
            ** Backup which is supposed to have the SE_BACKUP_NAME
            ** priv which will effectively bypass the ACL. No one else
            ** needs to see this stuff.
            */
            saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
            saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
            saSecurityAttributes.bInheritHandle       = FALSE;

            ft.hr = ::ConstructSecurityAttributes( &saSecurityAttributes, FALSE );
            ft.CheckForError( VSSDBG_WRTCMN, L"ConstructSecurityAttributes" );

	     CBsString expandedTarget;
	     ft.hr = GET_STATUS_FROM_BOOL(expandedTarget.ExpandEnvironmentStrings(pwszTargetPath));
	     ft.CheckForError(VSSDBG_WRTCMN, L"ExpandEnvironmentStrings");
	     
            bSucceeded = ::VsCreateDirectories (
                expandedTarget,
                &saSecurityAttributes,
                dwExtraAttributes
                );

            ft.hr = GET_STATUS_FROM_BOOL( bSucceeded );
            if ( ft.hr == HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) )
            {
                ft.hr = S_OK;
            }

             ::CleanupSecurityAttributes( &saSecurityAttributes );
             ft.CheckForError( VSSDBG_WRTCMN, L"VsCreateDirectories" );
            }
    }
    VSS_STANDARD_CATCH( ft );
    
    return( ft.hr );
} /* CreateTargetPath () */

/*
**++
**
**  Routine Description:
**
**	Deletes all the files present in the directory pointed at by the target
**	path member variable if not NULL. It will also remove the target directory
**	itself, eg for a target path of c:\dir1\dir2 all files under dir2 will be
**	removed and then dir2 itself will be deleted.
**
**
**  Arguments:
**
**	pwszTargetPath
**
**
**  Return Value:
**
**	Any HRESULT resulting from memory allocation or file and
**	directory deletion attempts.
**--
*/

HRESULT CleanupTargetPath (LPCWSTR pwszTargetPath)
    {
    CVssFunctionTracer ft(VSSDBG_WRTCMN, L"CleanupTargetPath");
   
    HRESULT		hrStatus         = NOERROR;
    DWORD		dwFileAttributes = 0;
  	  BOOL		bSucceeded;
    WCHAR		wszTempBuffer [50];
    UNICODE_STRING	ucsTargetPath;
    UNICODE_STRING	ucsTargetPathAlternateName;



    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsTargetPathAlternateName);


    if (NULL != pwszTargetPath)
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   pwszTargetPath,
						   MAX_PATH);


	if (SUCCEEDED (hrStatus))
	    {
	    hrStatus = StringCreateFromString (&ucsTargetPathAlternateName,
					       &ucsTargetPath,
					       MAX_PATH);
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    dwFileAttributes = GetFileAttributesW (ucsTargetPath.Buffer);


	    hrStatus = GET_STATUS_FROM_BOOL ( -1 != dwFileAttributes);


	    if ((HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus) ||
		(HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND) == hrStatus))
		{
		hrStatus         = NOERROR;
		dwFileAttributes = 0;
		}

	    else if (SUCCEEDED (hrStatus))
		{
		/*
		** If there is a file there then blow it away, or if it's
		** a directory, blow it and all it's contents away. This
		** is our directory and no one but us gets to play there.
		*/
		hrStatus = RemoveDirectoryTree (CBsString(&ucsTargetPath));

		if (FAILED (hrStatus))
		    {
		    srand ((unsigned) time (NULL));

		    _itow (rand (), wszTempBuffer, 16);

		    StringAppendString (&ucsTargetPathAlternateName, wszTempBuffer);

		    bSucceeded = MoveFileW (ucsTargetPath.Buffer,
					    ucsTargetPathAlternateName.Buffer);

		    if (bSucceeded)
			{
			BsDebugTraceAlways (0,
					    DEBUG_TRACE_VSSAPI,
					    (L"VSSAPI::CleanupTargetPath: "
					     L"FAILED to delete %s with status 0x%08X so renamed to %s",
					     ucsTargetPath.Buffer,
					     hrStatus,
					     ucsTargetPathAlternateName.Buffer));
			}
		    else
			{
			BsDebugTraceAlways (0,
					    DEBUG_TRACE_VSSAPI,
					    (L"VSSAPI::CleanupTargetPath: "
					     L"FAILED to delete %s with status 0x%08X and "
					     L"FAILED to rename to %s with status 0x%08X",
					     ucsTargetPath.Buffer,
					     hrStatus,
					     ucsTargetPathAlternateName.Buffer,
					     GET_STATUS_FROM_BOOL (bSucceeded)));
			}
		    }
		}
	    }
	}


    StringFree (&ucsTargetPathAlternateName);
    StringFree (&ucsTargetPath);

    return (hrStatus);
    } /* CleanupTargetPath () */

/*
**++
**
**  Routine Description:
**
**	Moves the contents of the source directory to the target directory.
**
**  Arguments:
**
**	pwszSourceDirectoryPath	Source directory for the files to be moved
**	pwszTargetDirectoryPath	Target directory for the files to be moved
**
**
**  Side Effects:
**
**	An intermediate error can leave directory in a partial moved
**	state where some of the files have been moved but not all.
**
**
**  Return Value:
**
**	Any HRESULT from FindFirstFile() etc or from MoveFileEx()
**
**  Remarks - copied from the wrtrshim\src\common.cpp file and
**  switched to using CBsStrings.
**-- 
*/

HRESULT MoveFilesInDirectory (
    IN CBsString cwsSourceDirectoryPath,
	IN CBsString cwsTargetDirectoryPath
	)
{
    CVssFunctionTracer ft( VSSDBG_WRTCMN, L"MoveFilesInDirectory" );

    HANDLE		hFileScan             = INVALID_HANDLE_VALUE;

    try
    {
        WIN32_FIND_DATA	sFileInformation;
        
        if ( cwsSourceDirectoryPath.Tail() != DIR_SEP_CHAR )
            cwsSourceDirectoryPath += DIR_SEP_CHAR;
        
        if ( cwsTargetDirectoryPath.Tail() != DIR_SEP_CHAR )
            cwsTargetDirectoryPath += DIR_SEP_CHAR;

        hFileScan = ::FindFirstFileW (
            cwsSourceDirectoryPath + L'*',
			&sFileInformation
			);

        ft.hr = GET_STATUS_FROM_BOOL( INVALID_HANDLE_VALUE != hFileScan );
        ft.CheckForError( VSSDBG_WRTCMN, L"FindFirstFileW" );        

        BOOL bMoreFiles;
    	do
   	    {
    	    if ( !NameIsDotOrDotDot( sFileInformation.cFileName ) )
    		{
                BOOL bSucceeded;
                CBsString cwsSourceFile = cwsSourceDirectoryPath + sFileInformation.cFileName;
                CBsString cwsTargetFile = cwsTargetDirectoryPath + sFileInformation.cFileName;

                ft.Trace( VSSDBG_WRTCMN, L"Moving '%s' to '%s'", cwsSourceFile.c_str(), cwsTargetFile.c_str() );
                
        		bSucceeded = ::MoveFileExW( 
        		    cwsSourceDirectoryPath + sFileInformation.cFileName,
        			cwsTargetDirectoryPath + sFileInformation.cFileName,
    			    MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING
    			    );

           		ft.hr = GET_STATUS_FROM_BOOL( bSucceeded );
                ft.CheckForError( VSSDBG_WRTCMN, L"MoveFileExW" );
    	    }

        	bMoreFiles = ::FindNextFileW( hFileScan, &sFileInformation );
    	} while ( bMoreFiles );

	    /*
	    ** If the last move operation was successful determine the
	    ** reason for terminating the scan. No need to report an
	    ** error if all that happened was that we have finished
	    ** what we were asked to do.
	    */
	    ft.hr = GET_STATUS_FROM_FILESCAN( bMoreFiles );
        ft.CheckForError( VSSDBG_WRTCMN, L"FindNextFileW" );
    }
    VSS_STANDARD_CATCH( ft );

    if ( hFileScan != INVALID_HANDLE_VALUE )
    	::FindClose( hFileScan );
        
    return( ft.hr );
}

/*
**++
**
**  Routine Description:
**
**	Checks a path against an array of pointers to volume names to
**	see if path is affected by any of the volumes in the array
**
**
**  Arguments:
**
**	pwszPath			Path to be checked
**	ulVolumeCount			Number of volumes in volume array
**	ppwszVolumeNamesArray		address of the array
**	pbReturnedFoundInVolumeArray	pointer to a location to store the 
**					result of the check
**
**
**  Side Effects:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from:-
**		GetVolumePathNameW()
**		GetVolumeNameForVolumeMountPoint()
**
**-- 
*/

HRESULT IsPathInVolumeArray (IN LPCWSTR      pwszPath,
			     IN const ULONG  ulVolumeCount,
			     IN LPCWSTR     *ppwszVolumeNamesArray,
			     OUT PBOOL       pbReturnedFoundInVolumeArray) 
    {
    CVssFunctionTracer ft(VSSDBG_WRTCMN, L"IsPathInVolumeArray");
    
    HRESULT		hrStatus  = NOERROR;
    BOOL		bFound    = FALSE;
    BOOL		bContinue = TRUE;
    ULONG		ulIndex;
    WCHAR		wszVolumeName [MAX_VOLUMENAME_LENGTH];
    UNICODE_STRING	ucsVolumeMountPoint;


    StringInitialise (&ucsVolumeMountPoint);


    if ((0 == ulVolumeCount) || (NULL == pbReturnedFoundInVolumeArray))
	{
	BS_ASSERT (false);

	bContinue = FALSE;
	}



    if (bContinue) 
	{
	/*
	** We need a string that is at least as big as the supplied
	** path. 
	*/
	hrStatus = StringAllocate (&ucsVolumeMountPoint, wcslen (pwszPath) * sizeof (WCHAR));

	bContinue = SUCCEEDED (hrStatus);
	}



    if (bContinue) 
	{
	/*
	** Get the volume mount point
	*/
	bContinue = GetVolumePathNameW (pwszPath, 
					ucsVolumeMountPoint.Buffer, 
					ucsVolumeMountPoint.MaximumLength / sizeof (WCHAR));

	hrStatus = GET_STATUS_FROM_BOOL (bContinue);
	}



    if (bContinue)
	{
	/*
	** Get the volume name
	*/
	bContinue = GetVolumeNameForVolumeMountPointW (ucsVolumeMountPoint.Buffer, 
						       wszVolumeName, 
						       SIZEOF_ARRAY (wszVolumeName));

	hrStatus = GET_STATUS_FROM_BOOL (bContinue);
	}


    if (bContinue)
	{
	/*
	** Search to see if that volume is within snapshotted volumes
	*/
	for (ulIndex = 0; !bFound && (ulIndex < ulVolumeCount); ulIndex++)
	    {
	    BS_ASSERT (NULL != ppwszVolumeNamesArray [ulIndex]);

	    if (0 == wcscmp (wszVolumeName, ppwszVolumeNamesArray [ulIndex]))
		{
		bFound = TRUE;
		}
	    }
	}



    RETURN_VALUE_IF_REQUIRED (pbReturnedFoundInVolumeArray, bFound);

    StringFree (&ucsVolumeMountPoint);

    return (hrStatus);
    } /* IsPathInVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal writer errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
**		
**
**-- 
*/

const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure)
    {
    BOOL bStatusUpdated;

    return (ClassifyWriterFailure (hrWriterFailure, bStatusUpdated));
    } /* ClassifyWriterFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal writer errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**	bStatusUpdated	TRUE if the status is re-mapped 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **		
**
**-- 
*/

const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure, BOOL &bStatusUpdated)
    {
    HRESULT hrStatus;


    switch (hrWriterFailure)
	{
	case NOERROR:
	case VSS_E_WRITERERROR_OUTOFRESOURCES:
	case VSS_E_WRITERERROR_RETRYABLE:
	case VSS_E_WRITERERROR_NONRETRYABLE:
	case VSS_E_WRITERERROR_TIMEOUT:
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
	    /*
	    ** These are ok as they are so no need to transmogrify them.
	    */
	    hrStatus       = hrWriterFailure;
	    bStatusUpdated = FALSE;
	    break;


	case E_OUTOFMEMORY:
	case HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_SEARCH_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_USER_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_LOG_SPACE):
	case HRESULT_FROM_WIN32 (ERROR_DISK_FULL):
	    hrStatus = VSS_E_WRITERERROR_OUTOFRESOURCES;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_READY):
	    hrStatus       = VSS_E_WRITERERROR_RETRYABLE;
	    bStatusUpdated = TRUE;
            break;


	case HRESULT_FROM_WIN32 (ERROR_TIMEOUT):
	    hrStatus       = VSS_E_WRITERERROR_TIMEOUT;
	    bStatusUpdated = TRUE;
	    break;



	case E_UNEXPECTED:
	case E_INVALIDARG:	// equal to HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER)
	case E_ACCESSDENIED:
	case HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_PRIVILEGE_NOT_HELD):
	case HRESULT_FROM_WIN32 (ERROR_NOT_LOCKED):
	case HRESULT_FROM_WIN32 (ERROR_LOCKED):

	default:
	    hrStatus       = VSS_E_WRITERERROR_NONRETRYABLE;
	    bStatusUpdated = TRUE;
	    break;
	}


    return (hrStatus);
    } /* ClassifyWriterFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **--
*/

const HRESULT ClassifyShimFailure (HRESULT hrWriterFailure)
    {
    BOOL bStatusUpdated;

    return (ClassifyShimFailure (hrWriterFailure, bStatusUpdated));
    } /* ClassifyShimFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**	bStatusUpdated	TRUE if the status is re-mapped 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_BAD_STATE
**		VSS_E_SNAPSHOT_SET_IN_PROGRESS
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **--
*/

const HRESULT ClassifyShimFailure (HRESULT hrWriterFailure, BOOL &bStatusUpdated)
    {
    HRESULT hrStatus;


    switch (hrWriterFailure)
	{
	case NOERROR:
	case E_OUTOFMEMORY:
	case E_ACCESSDENIED:
	case E_INVALIDARG:	// equal to HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER)
	case E_UNEXPECTED:
	case VSS_E_BAD_STATE:
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:
	case VSS_E_WRITERERROR_RETRYABLE:
	case VSS_E_WRITERERROR_NONRETRYABLE:
	case VSS_E_WRITERERROR_TIMEOUT:
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
	case VSS_E_WRITERERROR_OUTOFRESOURCES:
	    /*
	    ** These are ok as they are so no need to transmogrify them.
	    */
	    hrStatus       = hrWriterFailure;
	    bStatusUpdated = FALSE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_LOCKED):
	    hrStatus       = VSS_E_BAD_STATE;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_LOCKED):
	    hrStatus       = VSS_E_SNAPSHOT_SET_IN_PROGRESS;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_SEARCH_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_USER_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_LOG_SPACE):
	case HRESULT_FROM_WIN32 (ERROR_DISK_FULL):
	    hrStatus       = E_OUTOFMEMORY;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_PRIVILEGE_NOT_HELD):
	    hrStatus       = E_ACCESSDENIED;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_TIMEOUT):
	case HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_NOT_READY):

	default:
	    hrStatus       = E_UNEXPECTED;
	    bStatusUpdated = TRUE;
	    break;
	}


    return (hrStatus);
    } /* ClassifyShimFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim or shim
**	writer errors into one of the narrow set of responses we are
**	permitted to send back to the requestor.
**
**	The determination is made to classify either as a shim error
**	or as a writer error based upon whether or not a writer name
**	is supplied. If it is supplied then the assumption is made
**	that this is a writer failure and so the error is classified
**	accordingly.
**
**	Note that this is a worker routine for the LogFailure() macro
**	and the two are intended to be used in concert.
**
**
**  Arguments:
**
**	pft			Pointer to a Function trace class
**	pwszNameWriter		The name of the applicable writer or NULL or L""
**	pwszNameCalledRoutine	The name of the routine that returned the failure status
**
**
**  Side Effects:
**
**	hr field of *pft updated 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_BAD_STATE
**		VSS_E_SNAPSHOT_SET_IN_PROGRESS
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
**
**--
*/

HRESULT LogFailureWorker (CVssFunctionTracer	*pft,
			  LPCWSTR		 pwszNameWriter,
			  LPCWSTR		 pwszNameCalledRoutine)
    {
    if (pft->HrFailed ())
	{
	BOOL	bStatusRemapped;
	HRESULT	hrStatusClassified = ((NULL == pwszNameWriter) || (L'\0' == pwszNameWriter [0])) 
						? ClassifyShimFailure   (pft->hr, bStatusRemapped)
						: ClassifyWriterFailure (pft->hr, bStatusRemapped);

	if (bStatusRemapped)
	    {
	    if (((NULL == pwszNameCalledRoutine) || (L'\0' == pwszNameCalledRoutine [0])) &&
		((NULL == pwszNameWriter)        || (L'\0' == pwszNameWriter [0])))
		{
		pft->LogError (VSS_ERROR_SHIM_GENERAL_FAILURE,
			       VSSDBG_WRTCMN << pft->hr << hrStatusClassified);

		pft->Trace (VSSDBG_WRTCMN, 
			    L"FAILED with status 0x%08lX (converted to 0x%08lX)",
			    pft->hr,
			    hrStatusClassified);
		}


	    else if ((NULL == pwszNameCalledRoutine) || (L'\0' == pwszNameCalledRoutine [0]))
		{
		pft->LogError (VSS_ERROR_SHIM_WRITER_GENERAL_FAILURE,
			       VSSDBG_WRTCMN << pft->hr << hrStatusClassified << pwszNameWriter);

		pft->Trace (VSSDBG_WRTCMN, 
			    L"FAILED in writer %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameWriter,
			    pft->hr,
			    hrStatusClassified);
		}


	    else if ((NULL == pwszNameWriter) || (L'\0' == pwszNameWriter [0]))
		{
		pft->LogError (VSS_ERROR_SHIM_FAILED_SYSTEM_CALL,
			       VSSDBG_WRTCMN << pft->hr << hrStatusClassified <<  pwszNameCalledRoutine);

		pft->Trace (VSSDBG_WRTCMN, 
			    L"FAILED calling routine %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameCalledRoutine,
			    pft->hr,
			    hrStatusClassified);
		}


	    else
		{
		pft->LogError (VSS_ERROR_SHIM_WRITER_FAILED_SYSTEM_CALL,
			       VSSDBG_WRTCMN << pft->hr << hrStatusClassified << pwszNameWriter << pwszNameCalledRoutine);

		pft->Trace (VSSDBG_WRTCMN, 
			    L"FAILED in writer %s calling routine %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameWriter,
			    pwszNameCalledRoutine,
			    pft->hr,
			    hrStatusClassified);
		}

	    pft->hr = hrStatusClassified;
	    }
	}


    return (pft->hr);
    } /* LogFailureWorker () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrdefs.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrdefs.h

Abstract:

    Definitions for snapshot shim writers

Author:

    Stefan R. Steiner   [ssteiner]        01-31-2000

Revision History:

	X-10	MCJ		Michael C. Johnson		21-Sep-2000
		185047: Need to distinguish Thaw event from Abort events.

	X-9	MCJ		Michael C. Johnson		 8-Aug-2000
		153807: Replace CleanDirectory() and EmptyDirectory() with a 
		        more comprehensive directory tree cleanup routine
			RemoveDirectoryTree() (not in CShimWriter class).

	X-8	MCJ		Michael C. Johnson		12-Jun-2000
		Have the shim writers reposnd to OnIdentify events from the 
		snapshot coordinator. This requies splitting the shim writers 
		into two groups (selected by BootableState)

	X-7	MCJ		Michael C. Johnson		 6-Jun-2000
		Add method CShimWriter::CreateTargetPath() to aid in moving
		common target directory processing to method 
		CShimWriter::PrepareForSnapshot()

	X-6	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		18-Feb-2000
		Added ConfigDir writer to the writers function table.

	X-3	MCJ		Michael C. Johnson		09-Feb-2000
		Added Registry and Event log writers to the writers
		function table.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Added IIS Metabase writer to the writers function
		table.

--*/

#ifndef __H_WRTRDEFS_
#define __H_WRTRDEFS_

#pragma once

#ifdef  __cplusplus
extern "C" {
#endif


/*
** Possible state to put a shim writer into. If this is changed you
** MUST change the state table manipulated by CShimWriter::SetState()
*/
typedef enum _ShimWriterState
    {
     stateUnknown = 0
    ,stateStarting
    ,stateStarted
    ,statePreparingForSnapshot
    ,statePreparedForSnapshot
    ,stateFreezing
    ,stateFrozen
    ,stateThawing
    ,stateAborting
    ,stateThawed
    ,stateFinishing
    ,stateFinished
    ,stateMaximumValue
    } SHIMWRITERSTATE;



class CShimWriter
    {
public:
    CShimWriter (LPCWSTR pwszApplicationString);
    CShimWriter (LPCWSTR pwszApplicationString, BOOL bParticipateInBootableState);
    CShimWriter (LPCWSTR pwszApplicationString, LPCWSTR pwszTargetPath);
    CShimWriter (LPCWSTR pwszApplicationString, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState);

    virtual ~CShimWriter (VOID);

    HRESULT Startup  (void);
    HRESULT Shutdown (void);

    HRESULT Identify (IN IVssCreateWriterMetadata *pIVssCreateWriterMetadata);

    HRESULT PrepareForSnapshot (
				IN BOOL     bBootableStateBackup,
				IN ULONG    ulVolumeCount,
				IN LPCWSTR *ppwszVolumeNamesList);

    HRESULT Freeze ();
    HRESULT Thaw   ();
    HRESULT Abort  ();

private:
    HRESULT SetState (SHIMWRITERSTATE ssNewWriterState, HRESULT hrNewStatus);
    LPCWSTR GetStringFromStateCode (SHIMWRITERSTATE ssStateCode);


    /*
    ** These DoXxxx() are the routines that an individual writer may
    ** choose to over-ride.
    */
    virtual HRESULT DoStartup            (void);
    virtual HRESULT DoIdentify           (void);
    virtual HRESULT DoPrepareForBackup   (void);
    virtual HRESULT DoPrepareForSnapshot (void);
    virtual HRESULT DoFreeze             (void);
    virtual HRESULT DoThaw               (void);
    virtual HRESULT DoAbort              (void);
    virtual HRESULT DoBackupComplete     (void);
    virtual HRESULT DoShutdown           (void);


public:
    const BOOL			 m_bBootableStateWriter;
    const LPCWSTR		 m_pwszWriterName;
    BOOL                 m_bSimulateOnly;

protected:
    const LPCWSTR		 m_pwszTargetPath;
    SHIMWRITERSTATE		 m_ssCurrentState;
    HRESULT			 m_hrStatus;
    BOOL			 m_bParticipateInBackup;
    ULONG			 m_ulVolumeCount;
    LPCWSTR			*m_ppwszVolumeNamesArray;
    IVssCreateWriterMetadata	*m_pIVssCreateWriterMetadata;
    IVssWriterComponents	*m_pIVssWriterComponents;
    };


typedef CShimWriter *PCShimWriter;



} // extern "C"

#endif // __H_WRTRDEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\samples\requestor\main.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	main.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"


///////////////////////////////////////////////////////////////////////////////
// Main functions


extern "C" __cdecl wmain(int argc, WCHAR **argv)
{
    INT     nReturnCode = 0;

    try
	{
        CVssSampleRequestor requestor;

        // Parsing the command line
        // Eliminate the first argument (program name)
        requestor.ParseCommandLine( argc-1, argv+1 );

        // Initialize internal objects
        requestor.Initialize();

        // Gather writer status
        requestor.GatherWriterMetadata();

        // Create snapshot set, if needed
        requestor.CreateSnapshotSet();

        // Wait for user input
        wprintf(L"\nPress <Enter> to continue...\n");
        getwchar();

        // Complete the backup
        requestor.BackupComplete();
	}
    catch(INT nCatchedReturnCode)
	{
    	nReturnCode = nCatchedReturnCode;
	}

    return (nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrregistry.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrregistry.cpp | Implementation of SnapshotWriter for Registry hives


NOTE: This mini-writer is only used for simulated snapshots

Author:

    Michael C. Johnson [mikejohn] 08-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-14	MCJ		Michael C. Johnson		22-Oct-2000
		209095: Dynamically load the cluster library to reduce the 
		foot print for the unclustered.

	X-13	MCJ		Michael C. Johnson		18-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-12	MCJ		Michael C. Johnson		25-Sep-2000
		185047: Leave copies of registry files in repair directory
			for compatibility with Win2k behaviour.
		182895: Need to collect cluster registry hive too.

	X-11	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-10	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-9	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-8	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()
 
	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-5	MCJ		Michael C. Johnson		 2-Mar-2000
		Do not copy the extra registry files as it turns out we have
		no need for them after all.
		Also do a preparatory cleanup of the save location to remove
		any old stuff left around from a previous run.

	X-4	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-3	MCJ		Michael C. Johnson		22-Feb-2000
		Add SYSTEM_STATE_SUBDIR to registry save path.

	X-2	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-1	MCJ		Michael C. Johnson		08-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"
#include <aclapi.h>
#include <clusapi.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHREGC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"Registry"
#define COMPONENT_NAME				APPLICATION_STRING

#define TARGET_PATH				ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING
#define REGISTRY_HIVE_PATH			L"%SystemRoot%\\system32\\config"

#define REGISTRY_SUBKEY_HIVELIST		L"SYSTEM\\CurrentControlSet\\Control\\hivelist"

#define REGISTRY_BUFFER_SIZE			(4096)

#define REPAIR_PATH				L"%SystemRoot%\\Repair\\"

#define	CLUSTER_HIVE_PATH			L"%SystemRoot%\\Cluster"
#define	CLUSTER_SUBKEY_HIVE_NAME		L"Cluster"


DeclareStaticUnicodeString (ucsHiveRecognitionPrefix,    L"\\Device\\");
DeclareStaticUnicodeString (ucsValueNameMachinePrefix,   L"\\REGISTRY\\MACHINE\\");
DeclareStaticUnicodeString (ucsValueNameUserPrefix,      L"\\REGISTRY\\USER\\");

DeclareStaticUnicodeString (ucsValuenameClusterHivefile, L"\\REGISTRY\\MACHINE\\Cluster");
DeclareStaticUnicodeString (ucsClusterHiveFilename,      L"ClusDb");



typedef DWORD	(WINAPI *PFnGetNodeClusterState)(LPCWSTR, PDWORD);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterRegistry : public CShimWriter
    {
public:
    CShimWriterRegistry (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState) :
		CShimWriter (pwszWriterName, pwszTargetPath, bParticipateInBootableState),
		m_pfnDynamicGetNodeClusterState (NULL),
		m_hmodClusApi                   (NULL) 
		{ 
		        m_bSimulateOnly = TRUE;  //  Alert the calling code that this is for simulate only 
		};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    HRESULT DoThaw (VOID);
    HRESULT DoAbort (VOID);

    HRESULT BackupRegistryHives (VOID);
    HRESULT BackupClusterHives (VOID);

    HRESULT DynamicRoutinesLoadCluster (VOID);
    HRESULT DynamicRoutinesUnloadAll   (VOID);


    PFnGetNodeClusterState	m_pfnDynamicGetNodeClusterState;
    HMODULE			m_hmodClusApi;
    };


static CShimWriterRegistry ShimWriterRegistry (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterRegistry = &ShimWriterRegistry;



/*
**++
**
** Routine Description:
**
**	This routine loads the required Cluster DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DynamicRoutinesLoadCluster ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRegistry::DynamicRoutinesLoadCluster");


    try 
	{
	if ((NULL != m_pfnDynamicGetNodeClusterState)   ||
	    !HandleInvalid (m_hmodClusApi))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodClusApi = LoadLibraryW (L"ClusApi.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodClusApi);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (ClusApi.dll)");



	m_pfnDynamicGetNodeClusterState = (PFnGetNodeClusterState) GetProcAddress (m_hmodClusApi, "GetNodeClusterState");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicGetNodeClusterState);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (GetNodeClusterState)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_hmodClusApi                     = NULL;
	}


    return (ft.hr);
    } /* CShimWriterRegistry::DynamicRoutinesLoadCluster () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DynamicRoutinesUnloadAll ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRegistry::DynamicRoutinesUnloadAll");


    try 
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_hmodClusApi                     = NULL;
	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CShimWriterRegistry::DynamicRoutinesUnloadAll () */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DoIdentify ()
    {

    return (S_OK);
    } /* CShimWriterRegistry::DoIdentify () */

/*
**++
**
**  Routine Description:
**
**	This routine invokes all the necessary functions to save all 
**	of the interesting 'system' hives.
**
**
**  Arguments:
**
**	Implicit through class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DoPrepareForSnapshot ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CShimWriterRegistry::DoPrepareForSnapshot");
    DWORD		winStatus;
    DWORD		dwClusterNodeState;
    BOOL		bClusterRunning = FALSE;


    try
	{
	//  Only do work if in simulate snapshot freeze case.
        if ( g_bInSimulateSnapshotFreeze )
            {
        	ft.hr = DynamicRoutinesLoadCluster ();

        	LogAndThrowOnFailure (ft, m_pwszWriterName, L"DynamicRoutinesLoadCluster");



        	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

        	ft.hr = HRESULT_FROM_WIN32 (winStatus);

        	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetNodeClusterState");
         
        	bClusterRunning = (ClusterStateRunning == dwClusterNodeState);



        	ft.hr = BackupRegistryHives ();

        	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRegistry::BackupRegistryHives");



        	if (bClusterRunning)
        	    {
        	    ft.hr = BackupClusterHives ();

        	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRegistry::BackupClusterHives");
        	    }
            }
       	} 
    VSS_STANDARD_CATCH (ft);
    
    DynamicRoutinesUnloadAll ();

    return (ft.hr);
    } /* CShimWriterRegistry::DoPrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Captures the standard registry hives.
**
**
**  Arguments:
**
**	Implicit through the class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::BackupRegistryHives ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    HKEY		hkeyHivelist        = NULL;
    HKEY		hkeyRoot            = NULL;
    HKEY		hkeyBackup          = NULL;
    INT			iIndex              = 0;
    BOOL		bSucceeded          = FALSE;
    BOOL		bHivelistKeyOpened  = FALSE;
    BOOL		bContinueHiveSearch = TRUE;
    PWCHAR		pwchLastSlash;
    PWCHAR		pwszFilename;
    PWCHAR		pwszKeyName;
    UNICODE_STRING	ucsRegistrySavePath;
    UNICODE_STRING	ucsRegistryHivePath;
    UNICODE_STRING	ucsHiveRecognitionPostfix;
    UNICODE_STRING	ucsValueName;
    UNICODE_STRING	ucsValueData;
    USHORT		usRegistrySavePathRootLength = 0;


    StringInitialise (&ucsRegistrySavePath);
    StringInitialise (&ucsRegistryHivePath);
    StringInitialise (&ucsHiveRecognitionPostfix);
    StringInitialise (&ucsValueName);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueName, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistryHivePath,
						   REGISTRY_HIVE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistrySavePath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwCharIndex;


	StringAppendString (&ucsRegistryHivePath, DIR_SEP_STRING);
	StringAppendString (&ucsRegistrySavePath, DIR_SEP_STRING);

	usRegistrySavePathRootLength = ucsRegistrySavePath.Length / sizeof (WCHAR);


	/*
	** Now we know the location of the hive files, determine the
	** postfix we are going to use to recognise hives when we
	** search the active hivelist key. To do this we just need to
	** lose the drive letter and the colon in the path, or to put
	** it another way, lose everthing before the first '\'. When
	** we are done, if everything works ucsRegistryHivePath will
	** look something like '\Windows\system32\config\'
	*/
	for (dwCharIndex = 0;
	     (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)))
		 && (DIR_SEP_CHAR != ucsRegistryHivePath.Buffer [dwCharIndex]);
	     dwCharIndex++)
	    {
	    /*
	    ** Empty loop body
	    */
	    }

	BS_ASSERT(dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)));

	hrStatus = StringCreateFromString (&ucsHiveRecognitionPostfix, &ucsRegistryHivePath.Buffer [dwCharIndex]);
	}



    if (SUCCEEDED (hrStatus))
	{
	/*
	** We now have all the pieces in place so go search the
	** hivelist for the hives to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (hive list)", 
		    L"CShimWriterRegistry::BackupRegistryHives");
	}



    while (SUCCEEDED (hrStatus) && bContinueHiveSearch)
	{
	DWORD	dwValueNameLength = ucsValueName.MaximumLength / sizeof (WCHAR);
	DWORD	dwValueDataLength = ucsValueData.MaximumLength;
	DWORD	dwValueType       = REG_NONE;
	BOOL	bMatchPrefix;
	BOOL	bMatchPostfix;


	StringTruncate (&ucsValueName, 0);
	StringTruncate (&ucsValueData, 0);


	/*
	** should be of type REG_SZ
	*/
	winStatus = RegEnumValueW (hkeyHivelist,
				   iIndex,
				   ucsValueName.Buffer,
				   &dwValueNameLength,
				   NULL,
				   &dwValueType,
				   (PBYTE)ucsValueData.Buffer,
				   &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueHiveSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumValueW", 
			L"CShimWriterRegistry::BackupRegistryHives");
	    }

	else
	    {
	    UNICODE_STRING	ucsPostFix;

	    BS_ASSERT ((REG_SZ == dwValueType) && L"Not REG_SZ string as expected");

	    ucsValueName.Length = (USHORT)(dwValueNameLength * sizeof (WCHAR));
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueName.Buffer [ucsValueName.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    /*
	    ** If it's to be considered part of system state the hive
	    ** file itself must live in %SystemRoot%\system32\config
	    ** so we attempt to find something in the returned value
	    ** name which looks like it might match. The format of the
	    ** name we are expecting is something like
	    **
	    **	\Device\<Volume>\Windows\system32\config\filename
	    **
	    ** for a system which has system32 in the 'Windows'
	    ** directory.  
	    **
	    ** Now, we have the known prefix, '\Device\', and the
	    ** postfix before and including the last '\', something
	    ** like '\Windows\system32\config\' as we determined
	    ** earlier. So we should be in a position to identify the
	    ** hives files we are interested in. Remember, we don't
	    ** know the piece representing the actual volume which is
	    ** why we are doing all this matching of pre and
	    ** post-fixs.
	    */
	    bMatchPrefix = RtlPrefixUnicodeString (&ucsHiveRecognitionPrefix,
						   &ucsValueData,
						   TRUE);


	    /*
	    ** Locate the last '\' in the value data. After this will
	    ** be the filename (eg 'SAM') which we will want later and
	    ** before that should be the postfix (eg
	    ** '\Windows\system32\config\') by which we will recognise
	    ** this as a registry hive.
	    */
	    pwchLastSlash = wcsrchr (ucsValueData.Buffer, DIR_SEP_CHAR);

	    if ((NULL == pwchLastSlash) ||
		(ucsValueData.Length < (ucsHiveRecognitionPrefix.Length + ucsHiveRecognitionPostfix.Length)))
		{
		/*
		** We coundn't find a '\' or the value data wasn't
		** long enough.
		*/
		bMatchPostfix = FALSE;
		}
	    else
		{
		/*
		** Determine the name of the give file.
		*/
		pwszFilename = pwchLastSlash + 1;


		/*
		** Determine the postfix we are going to try to match
		** against. This should look something like
		** '\Windows\system32\config\SAM'.
		*/
		StringInitialise (&ucsPostFix,
				  pwszFilename - (ucsHiveRecognitionPostfix.Length / sizeof (WCHAR)));



		/*
		** See if the recognition string (eg
		** '\Windows\system32\config\') is a prefix of the
		** location of this hive file (eg
		** '\Windows\system32\config\SAM')
		*/
		bMatchPostfix = RtlPrefixUnicodeString (&ucsHiveRecognitionPostfix,
							&ucsPostFix,
							TRUE);
		}


	    if (bMatchPrefix && bMatchPostfix)
		{
		/*
		** We got ourselves a real live registry hive!
		*/
		/*
		** generate savename from hive name.
		*/
		StringAppendString (&ucsRegistrySavePath, pwszFilename);


		/*
		** Decide which registry root this is under by
		** comparing the value name we retrieved earlier (eg
		** '\REGISTRY\MACHINE\SAM') against the
		** '\REGISTRY\MACHINE' prefix.
		**
		** Note that we only expect either HKLM or HKLU so we
		** assume if it's not HKLM it must be HKLU. If that
		** changes this test must be re-visited.
		*/
		hkeyRoot = RtlPrefixUnicodeString (&ucsValueNameMachinePrefix,
						   &ucsValueName,
						   TRUE)
				? HKEY_LOCAL_MACHINE
				: HKEY_USERS;


		BS_ASSERT ((HKEY_LOCAL_MACHINE == hkeyRoot) ||
			   (RtlPrefixUnicodeString (&ucsValueNameUserPrefix,
						    &ucsValueName,
						    TRUE)));
						    

		/*
		** Need to find what name to use for the key we are
		** going to do the registry save from. In most cases
		** this is going to be the same as the filename, eg
		** the 'HKLM\SAM' for the 'SAM' hive file, but in some
		** (e.g. for the default user stuff) it's going to
		** have a '.' prefix, eg 'HKLU\.DEFAULT' for the
		** 'default' hive file. So we do the generic thing and
		** use whatever is after the last '\' in the value
		** name.
		*/
		pwszKeyName = wcsrchr (ucsValueName.Buffer, DIR_SEP_CHAR) + 1;

		winStatus = RegCreateKeyEx (hkeyRoot,
					    pwszKeyName,
					    0,
					    NULL,
					    REG_OPTION_BACKUP_RESTORE,
					    MAXIMUM_ALLOWED,
					    NULL,
					    &hkeyBackup,
					    NULL);
	
		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegCreateKeyEx", 
			    L"CShimWriterRegistry::BackupRegistryHives");


		if (SUCCEEDED (hrStatus))
		    {
		    //
		    //  Use the new RegSaveKeyExW with REG_NO_COMPRESSION option to 
		    //  quickly spit out the hives.
		    //
		    winStatus = RegSaveKeyExW (hkeyBackup, ucsRegistrySavePath.Buffer, NULL, REG_NO_COMPRESSION);

		    hrStatus = HRESULT_FROM_WIN32 (winStatus);

		    LogFailure (NULL, 
				hrStatus, 
				hrStatus, 
				m_pwszWriterName, 
				L"RegSaveKey", 
				L"CShimWriterRegistry::BackupRegistryHives");


		    RegCloseKey (hkeyBackup);
		    }


		StringTruncate (&ucsRegistrySavePath, usRegistrySavePathRootLength);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    iIndex++;
	    }
	}



    if (bHivelistKeyOpened)
	{
	RegCloseKey (hkeyHivelist);
	}

    StringFree (&ucsHiveRecognitionPostfix);
    StringFree (&ucsRegistryHivePath);
    StringFree (&ucsRegistrySavePath);
    StringFree (&ucsValueData);
    StringFree (&ucsValueName);

    return (hrStatus);
    } /* CShimWriterRegistry::BackupRegistryHives () */

/*
**++
**
**  Routine Description:
**
**	Captures the cluster registry hive.
**
**
**  Arguments:
**
**	Implicit through the class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/


HRESULT CShimWriterRegistry::BackupClusterHives ()
    {
    HRESULT		hrStatus           = NOERROR;
    DWORD		winStatus;
    DWORD		dwValueType        = REG_NONE;
    DWORD		dwValueDataLength;
    HCLUSTER		hCluster           = NULL;
    HKEY		hkeyHivelist       = NULL;
    HKEY		hkeyBackup         = NULL;
    BOOL		bHivelistKeyOpened = FALSE;
    BOOL		bClusterPresent    = FALSE;
    BOOL		bSucceeded;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsBackupPath;
    UNICODE_STRING	ucsBackupHiveFilename;



    StringInitialise (&ucsValueData);
    StringInitialise (&ucsBackupPath);
    StringInitialise (&ucsBackupHiveFilename);


    hrStatus = StringCreateFromExpandedString (&ucsBackupPath,
					       m_pwszTargetPath,
					       0);

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsBackupHiveFilename, ucsBackupPath.Length
								+ sizeof (DIR_SEP_CHAR)
								+ ucsClusterHiveFilename.Length
								+ sizeof (UNICODE_NULL));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, &ucsBackupPath);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, DIR_SEP_STRING);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, &ucsClusterHiveFilename);
	}



    /*
    ** Check for presence of cluster hive in hivelist. That should be
    ** there (error out if missing) and have the value we expect. Then
    ** do a RegSaveKey() to collect a copy of the hive.
    */
    if (SUCCEEDED (hrStatus))
	{
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (cluster hive)", 
		    L"CShimWriterRegistry::BackupClusterHives");
	}



    if (SUCCEEDED (hrStatus))
	{
	dwValueDataLength = ucsValueData.MaximumLength;

	winStatus = RegQueryValueExW (hkeyHivelist,
				      ucsValuenameClusterHivefile.Buffer,
				      NULL,
				      &dwValueType,
				      (PBYTE)ucsValueData.Buffer,
				      &dwValueDataLength);

	hrStatus = (REG_SZ == dwValueType) 
			? HRESULT_FROM_WIN32 (winStatus)
			: HRESULT_FROM_WIN32 (ERROR_CLUSTER_INVALID_NODE);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegQueryValueExW", 
		    L"CShimWriterRegistry::BackupClusterHives");
	}



    if (SUCCEEDED (hrStatus))
	{
	ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	/*
	** Looks like the cluster hive exists. Try to back it up to
	** the spit directory.
	*/
	winStatus = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
				    CLUSTER_SUBKEY_HIVE_NAME,
				    0,
				    NULL,
				    REG_OPTION_BACKUP_RESTORE,
				    MAXIMUM_ALLOWED,
				    NULL,
				    &hkeyBackup,
				    NULL);
	
	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegCreateKeyEx", 
		    L"CShimWriterRegistry::BackupClusterHives");

	if (SUCCEEDED (hrStatus))
	    {
	    winStatus = RegSaveKey (hkeyBackup, 
				    ucsBackupHiveFilename.Buffer, 
				    NULL);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegSaveKey", 
			L"CShimWriterRegistry::BackupClusterHives");

	    RegCloseKey (hkeyBackup);
	    }
	}



    /*
    ** All the cleanup code.
    */
    if (bHivelistKeyOpened)        RegCloseKey (hkeyHivelist);

    StringFree (&ucsBackupHiveFilename);
    StringFree (&ucsBackupPath);
    StringFree (&ucsValueData);

    return (hrStatus);
    } /* CShimWriterRegistry::BackupClusterHives () */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoThaw() function. This will
**	place a copy of all the generated registry hives in the repair
**	directory to maintain backwards compatibility with Win2k and
**	so keep PSS happy.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- 
*/

HRESULT CShimWriterRegistry::DoThaw ()
    {
    HRESULT		hrStatus;
    UNICODE_STRING	ucsWriterResultPath;
    UNICODE_STRING	ucsRepairDirectory;

    if ( !g_bInSimulateSnapshotFreeze )
        return S_OK;

    StringInitialise (&ucsWriterResultPath);
    StringInitialise (&ucsRepairDirectory);


    hrStatus = StringCreateFromExpandedString (&ucsWriterResultPath, m_pwszTargetPath, MAX_PATH);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRepairDirectory, REPAIR_PATH, MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = MoveFilesInDirectory (&ucsWriterResultPath, &ucsRepairDirectory);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterRegistry::DoThaw");
	}


    StringFree (&ucsWriterResultPath);
    StringFree (&ucsRepairDirectory);

    return (hrStatus);
    } /* CShimWriterRegistry::DoThaw() */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoAbort() function. Since the
**	default action for DoAbort() is to call DoThaw() and we don't
**	want to copy the possibly incomplete set of registry files to
**	the repair directory..
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- 
*/

HRESULT CShimWriterRegistry::DoAbort ()
    {
    /*
    ** We don't actually need to do anything here as the cleanup will
    ** happen automatically in the calling code. We just need to
    ** prevent the default DoAbort() method call.
    */

    return (NOERROR);
    } /* CShimWriterRegistry::DoAbort() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrmetabase.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrmetabase.cpp | Implementation of SnapshotWriter for IIS MetaBase.bin file

    NOTE: This module is not used/compiled anymore since IIS has its own snapshot writer.

Author:

    Michael C. Johnson [mikejohn] 06-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-9	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Remove trailing '\' from Include/Exclude lists.

	X-8	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		23-Mar-2000
		Fix bug where we didn't allow for the possibility that IIS
		may not be running on the machine.

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-3	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-2	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-1	MCJ		Michael C. Johnson		06-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"



#define APPLICATION_STRING	L"IisMetaBase"
#define COMPONENT_NAME		L"IIS Metabase"
#define METABASE_DIRECTORY	L"%SystemRoot%\\system32\\inetsrv"
#define METABASE_FILENAME	L"Metabase.bin"
#define METABASE_PATH		METABASE_DIRECTORY DIR_SEP_STRING METABASE_FILENAME




/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterMetabase : public CShimWriter
    {
public:
    CShimWriterMetabase(LPCWSTR pwszWriterName, BOOL bParticipateInBootableState) : 
		CShimWriter (pwszWriterName, bParticipateInBootableState), 
		m_hMetabaseFile(INVALID_HANDLE_VALUE)
		{
            m_bSimulateOnly = TRUE;  //  Alert the calling code that this is for simulate only 
		};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoFreeze   (VOID);
    HRESULT DoThaw     (VOID);
    HANDLE  m_hMetabaseFile;
    };


static CShimWriterMetabase ShimWriterMetabase (APPLICATION_STRING, TRUE);

PCShimWriter pShimWriterIisMetabase = &ShimWriterMetabase;



/*
**++
**
** Routine Description:
**
**	The IIS metabase snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterMetabase::DoIdentify ()
    {
    return (S_OK);
    } /* CShimWriterMetabase::DoIdentify () */



HRESULT CShimWriterMetabase::DoFreeze ()
    {
	//  Only do work if in simulate snapshot freeze case.
    if ( !g_bInSimulateSnapshotFreeze )
        return S_OK;

    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CShimWriterMetabase::DoFreeze");

    UNICODE_STRING	ucsMetabasePath;
    HRESULT		hrStatus;


    StringInitialise (&ucsMetabasePath);

    hrStatus = StringCreateFromExpandedString (&ucsMetabasePath,
					       METABASE_PATH,
					       0);


    /*
    ** Attempt to acquire read access to the file. This will stop
    ** anyone else opening it for updates until we release the open
    ** during the Thaw call.
    */
    if (SUCCEEDED (hrStatus))
	{
	m_hMetabaseFile = CreateFileW (ucsMetabasePath.Buffer,
				       GENERIC_READ,
				       FILE_SHARE_READ,
				       NULL,
				       OPEN_EXISTING,
				       FILE_FLAG_BACKUP_SEMANTICS,
				       NULL);

	hrStatus = GET_STATUS_FROM_BOOL (INVALID_HANDLE_VALUE != m_hMetabaseFile);

	if ((HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus) ||
	    (HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND) == hrStatus))
	    {
	    /*
	    ** Failure to find the file just means that IIS is not
	    ** running here and so there is no file to prevent writes
	    ** to.
	    */
	    hrStatus = NOERROR;
	    }
	}
	

    StringFree (&ucsMetabasePath);

    return (hrStatus);
    } /* CShimWriterMetabase::DoFreeze () */



HRESULT CShimWriterMetabase::DoThaw ()
    {
	//  Only do work if in simulate snapshot freeze case.
    if ( !g_bInSimulateSnapshotFreeze )
        return S_OK;

    HRESULT	hrStatus;


    /*
    ** Note that the handle may be invalid if we did not open the
    ** metabase file, but CommonCloseHandle() can cope with that case.
    */
    hrStatus = CommonCloseHandle (&m_hMetabaseFile);


    return (hrStatus);
    } /* CShimWriterMetabase::DoThaw () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrshim.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrshim.cpp

Abstract:

    Contains the defintion for the Shim writers.
    BUGBUG: Uses code that currently sets the SE handler.  Since the SEH is process
        wide, this can/will effect the user of this DLL.  Need to fix.

Author:

    SSteiner    1/27/2000

Revision History:

	Name		Date		Comments
    reuvenl	5/01/2002  Removed vssapi functions to vssapi.cpp
    SSteiner    2/10/2000   Added single instance support to the shim dll
    MikeJohn    2/17/2000   Added test entry point TestShimWriter()
    MikeJohn    2/23/2000   Stop phaseAll invoking freeze levels 2 and 1
                            Add new entry points to allow triggering shim
                            without snapshots.
    mikejohn	03/09/2000  Move to using CVssWriter class
    mikejohn	03/24/2000  Fix minor problem in TestShimWriters() causing
                            freeze to be skipped
    mikejohn    04/28/2000  Rename vswrshim.dll to VssAPI.dll
    mikejohn	05/15/2000  107129: Ensure that all the writers receive all
			            the events even in the presence of
				    earlier failures.
			    108586: Check the privs of the callers of all the
			            public entry points. Also remove the
				    TestShimWriters() entry point.
			    108543: Ensure that SimulateXxxx() calls work once
				    the shim has had a successful invocation
				    of RegisterSnapshotSubscriptions()
    mikejohn	05/26/2000  120443: Make shim listen to all OnAbort events
			    120445: Ensure shim never quits on first error
				    when delivering events
			    108580: SimulateSnapshotFreeze can be called
				    asynchronously
			    123097: Allow selection of bootable state
			    General clean up and removal of boiler-plate code,
			    correct state engine and ensure shim can undo
			    everything it did.
    mikejohn	06/02/2000  Make shim sensitive to volume list
    mikejohn	06/06/2000  Move common target directory cleanup and creation
			    into CShimWriter::PrepareForSnapshot()
    mikejohn	06/14/2000  Change the return code from async freeze to be
			    compatible with the snapshot coordinator
    mikejohn	06/15/2000  Temporarily remove the debug trace statement for
			    thread creation/deletion in the vssapi dll to see
			    if ameliorates effects of the rapid thread
			    creation/deletion problem.
    mikejohn	06/16/2000  Have the shim writers respond to OnIdentify events
			    from the snapshot coordinator. This requies
			    splitting the shim writers into two groups
			    (selected by BootableState)
    mikejohn	06/19/2000  Apply code review comments.
			    128883: Add shim writer for WMI database
    mikejohn	07/05/2000  143367: Do all shim writer processing in a worker
			    thread to allow the acquisition of a mutex that can
			    be held over the Prepare to Thaw/Abort codepath.
			    Also remove the spit directory cleanup calls for paths
			    not protected by the mutex.
			    141305: Ensure Writers call SetWriterFailure() if they
			    are about to fail in response to an OnXxxx() event.
    mikejohn	08/08/2000  94487:  Add an ACL to the spit directory tree to limit
			            access to members of the Administrators group
				    or those holding the Backup privilege.
			    153807: Replace CleanDirectory() and EmptyDirectory()
				    with a more comprehensive directory tree
				    cleanup routine RemoveDirectoryTree() (not in
				    CShimWriter class).
    mikejohn	09/12/2000  177925: Check option flags argument unused bits are
				    all set to zero (ie MBZ bits)
			    180192: Fix PREFIX bug in DllMain()
    mikejohn	10/04/2000  177624: Apply error scrub changes and log errors to
				    event log
    mikejohn	10/21/2000  209047: Remove the metabase shim writer now that
				    there is a real one.
    mikejohn	10/23/2000  210070: Test for NULL ptr in SimulatesnapshotFreeze() rather
				    than taking AV exception
			    210264: Prevent SimulateXxxx() calls from returning
				    Win32 errors.
			    210305: Check SnapshotSetId on SimulateSnapshotXxxx() calls
			    210393: Return appropriate error message for an invalid arg.
    ssteiner	11/10/2000  143810 Move SimulateSnapshotXxxx() calls to be hosted by VsSvc.
    mikejohn	11/30/2000  245587: Return the correct error codes for access denied.
			    245896: Build security descriptors correctly
    ssteiner   	03/09/2001  289822, 321150, 323786 Removed mutexes, changed state table, changed
                shutdown.

--*/


#include "stdafx.h"

#include <aclapi.h>
#include <comadmin.h>

/*
** ATL
*/

#include "comadmin.hxx"

#include "vssmsg.h"
#include "wrtrdefs.h"
#include "wrtcommon.hxx"
#include "vs_sec.hxx"


/*
** We just need the following to obtain the definition of UnregisterSnapshotSubscriptions()
*/
#include "vs_idl.hxx"
#include "vs_inc.hxx"
#include "vs_reg.hxx"

#include "vs_wmxml.hxx"

#include "ntddsnap.h"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHWSHMC"

/*
** External definitions to allow us to link in the various shim writer
** instances. No need to place these in a header file as this is the
** only place they are or should be used
*/

extern PCShimWriter pShimWriterCI;		// in wrtrci.cpp
extern PCShimWriter pShimWriterClusterDb;	// in wrtrclus.cpp
extern PCShimWriter pShimWriterComPlusRegDb;	// in wrtrcomdb.cpp
extern PCShimWriter pShimWriterConfigDir;	// in wrtrconfig.cpp
extern PCShimWriter pShimWriterEventLog;	// in wrtreventlog.cpp
extern PCShimWriter pShimWriterRegistry;	// in wrtrregistry.cpp
extern PCShimWriter pShimWriterRSM;		// in wrtrrsm.cpp
extern PCShimWriter pShimWriterTLS;		// in wrtrtls.cpp
extern PCShimWriter pShimWriterWMI;		// in wrtrwmi.cpp
extern PCShimWriter pShimWriterIisMetabase;     // in wrtrmetabase.cpp

#define SHIM_APPLICATION_NAME_BOOTABLE_STATE	L"Microsoft Writer (Bootable State)"
#define SHIM_APPLICATION_NAME_SIMULATE_ONLY	L"Microsoft Writer (Simulate Only)"


#define WORKER_THREAD_SHUTDOWN_TIMEOUT	(2 * 1000)
#define WORKER_THREAD_REQUEST_TIMEOUT	(5 * 60 * 1000)

const VSS_ID idWriterBootableState =
    {
    0xf2436e37,
    0x09f5,
    0x41af,
    {0x9b, 0x2a, 0x4c, 0xa2, 0x43, 0x5d, 0xbf, 0xd5}
    };

const VSS_ID idWriterSimulateOnly =
    {
    0xe38c2e3c,
    0xd4fb,
    0x4f4d,
    {0x95, 0x50, 0xfc, 0xaf, 0xda, 0x8a, 0xae, 0x9a}
    };

typedef enum _SecurityAttributeType
    {
    esatUndefined = 0,
    esatMutex,
    esatFile
    } SecurityAttributeType;


typedef enum _WriterType
    {
    eWriterTypeUndefined = 0,
    eBootableStateOnly,
    eNonBootableStateOnly,
    eAllWriters
    } WriterType;


typedef enum _RequestOpCode
    {
    eOpUndefined = 0,
    eOpDeliverEventStartup,
    eOpDeliverEventIdentify,
    eOpDeliverEventPrepareForBackup,
    eOpDeliverEventPrepareForSnapshot,
    eOpDeliverEventFreeze,
    eOpDeliverEventThaw,
    eOpDeliverEventAbort,
    eOpWorkerThreadShutdown
    } RequestOpCode;


typedef enum _ThreadStatus
    {
    eStatusUndefined = 0,
    eStatusWaitingForOpRequest,
    eStatusProcessingOpRequest,
    eStatusNotRunning
    } ThreadStatus;


typedef struct _ArgsIdentify
    {
    IVssCreateWriterMetadata *pIVssCreateWriterMetadata;
    } ArgsIdentify;


typedef struct _ArgsPrepareForSnapshot
    {
    GUID     guidSnapshotSetId;
    BOOL     bBootableStateBackup;
    ULONG    ulVolumeCount;
    LPCWSTR *ppwszVolumeNamesArray;
    volatile bool *pbCancelAsync;
    } ArgsPrepareForSnapshot;


typedef struct _ArgsFreeze
    {
    GUID     guidSnapshotSetId;
    volatile bool *pbCancelAsync;
    } ArgsFreeze;


typedef struct _ArgsThaw
    {
    GUID     guidSnapshotSetId;
    } ArgsThaw;


typedef struct _ArgsAbort
    {
    GUID     guidSnapshotSetId;
    } ArgsAbort;


typedef union _ThreadArgs
    {
    ArgsIdentify		wtArgsIdentify;
    ArgsPrepareForSnapshot	wtArgsPrepareForSnapshot;
    ArgsFreeze			wtArgsFreeze;
    ArgsThaw			wtArgsThaw;
    ArgsAbort			wtArgsAbort;
    } ThreadArgs, *PThreadArgs;

class CVssWriterShim : public CVssWriter
    {
public:
	CVssWriterShim (LPCWSTR       pwszWriterName,
			LPCWSTR       pwszWriterSpitDirectoryRoot,
			VSS_ID        idWriter,
			BOOL	      bBootableState,
			ULONG         ulWriterCount,
			PCShimWriter *prpCShimWriterArray,
			BOOL          bSimulateSnapshotOnly);

	~CVssWriterShim ();

	HRESULT	RegisterWriterShim (VOID);
	HRESULT	UnRegisterWriterShim (VOID);

	HRESULT WorkerThreadStartup (void);
	HRESULT WorkerThreadRequestOperation (RequestOpCode eOperation,
					      PThreadArgs   pwtArgs);

	virtual bool STDMETHODCALLTYPE OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot ();
	virtual bool STDMETHODCALLTYPE OnFreeze ();
	virtual bool STDMETHODCALLTYPE OnThaw ();
	virtual bool STDMETHODCALLTYPE OnAbort ();


private:
	static DWORD WINAPI RegisterWriterShimThreadFunc (void *pv);
	void	DoRegistration (void);


	static DWORD WINAPI WorkerThreadJacket (void *pvThisPtr);

	HRESULT WorkerThread (void);
	HRESULT WorkerThreadRequestProcessor (void);


	HRESULT	DeliverEventStartup  (void);
	HRESULT	DeliverEventShutdown (void);

	HRESULT	DeliverEventIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);

	HRESULT	DeliverEventPrepareForSnapshot (BOOL     bBootableStateBackup,
						GUID     guidSnapshotSetId,
						ULONG    ulVolumeCount,
						LPCWSTR *ppwszVolumeNamesArray,
                                                volatile bool *pbCancelAsync );

	HRESULT	DeliverEventFreeze (GUID guidSnapshotSetId, volatile bool *pbCancelAsync );	
	HRESULT	DeliverEventThaw   (GUID guidSnapshotSetId);
	HRESULT	DeliverEventAbort  (GUID guidSnapshotSetId);

	const LPCWSTR		 m_pwszWriterName;
	const VSS_ID		 m_idWriter;
	const BOOL		 m_bBootableState;
	const LPCWSTR		 m_pwszWriterSpitDirectoryRoot;
	const ULONG		 m_ulWriterCount;
	const PCShimWriter	*m_prpCShimWriterArray;
	const BOOL               m_bSimulateSnapshotOnly;


	HRESULT		m_hrInitialize;
	BOOL		m_bSubscribed;

	BOOL		m_bRegisteredInThisProcess;
	BOOL		m_bDirectStartupCalled;

	RequestOpCode	m_eRequestedOperation;
	HRESULT		m_hrStatusRequestedOperation;
	HANDLE		m_hEventOperationRequest;
	HANDLE		m_hEventOperationCompleted;

	HANDLE		m_hWorkerThread;
	HRESULT		m_hrWorkerThreadCompletionStatus;
	ThreadStatus	m_eThreadStatus;
	ThreadArgs	m_wtArgs;
	
	CBsCritSec	m_cCriticalSection;

};

typedef CVssWriterShim *PCVssWriterShim;


// VssApi shim exports
typedef HRESULT ( APIENTRY *PFunc_SimulateSnapshotFreezeInternal ) (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR  *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync
    );

typedef HRESULT ( APIENTRY *PFunc_SimulateSnapshotThawInternal ) (
    IN GUID guidSnapshotSetId
    );

HRESULT APIENTRY SimulateSnapshotFreezeInternal (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync
    );

HRESULT APIENTRY SimulateSnapshotThawInternal (
    IN GUID guidSnapshotSetId );

static HRESULT NormaliseVolumeArray (ULONG   ulVolumeCount,
				     LPWSTR pwszVolumeNameArray[],
				     PPWCHAR ppwszReturnedVolumeNameArray[]);

static VOID CleanupVolumeArray (PPWCHAR prpwszNormalisedVolumeNameArray[]);


static HRESULT InitialiseGlobalState ();
static HRESULT CleanupGlobalState (void);


//
//  The following shim mini-writers are used during simulate snapshot ONLY
//  (right now all mini-writers are being used in Simulate mode only)
//
static PCShimWriter g_rpShimWritersArrayBootableState[] = {
							  pShimWriterClusterDb,         // The Cluster Database writer
							  pShimWriterIisMetabase,       // The IIS metabase writer
							  pShimWriterRegistry,          // The simulate only Registry writer							  
							  pShimWriterComPlusRegDb };	// The COM+ registration Db writer

//
//  The following shim mini-writers are used during simulate snapshot ONLY
//
static PCShimWriter g_rpShimWritersArraySimulateOnly[] = {
							  pShimWriterRSM,		// The Removeable Storage Manager writer
							  pShimWriterCI,		// The Content Indexing writer
							  pShimWriterEventLog,          // The Event Log writer
							  pShimWriterTLS};		// The TermServer Licencing service writer

#define COUNT_SHIM_WRITERS_BOOTABLE_STATE	(SIZEOF_ARRAY (g_rpShimWritersArrayBootableState))
#define COUNT_SHIM_WRITERS_SIMULATE_ONLY	(SIZEOF_ARRAY (g_rpShimWritersArraySimulateOnly))


static PCVssWriterShim	g_pCVssWriterShimBootableState = NULL;
static PCVssWriterShim	g_pCVssWriterShimSimulateOnly  = NULL;
static BOOL		g_bGlobalStateInitialised      = FALSE;
static CBsCritSec	g_cCritSec;
static HRESULT          g_hrSimulateFreezeStatus       = NOERROR;
BOOL                    g_bInSimulateSnapshotFreeze    = FALSE;

static GUID		g_guidSnapshotInProgress       = GUID_NULL;


/*
**++
**
**  Routine Description:
**
**	Converts the supplied array of volume names into something we
**	trust. Once the array is finished with a call must be made to
**	CleanupVolumeArray().
**
**
**  Arguments:
**
**	ulVolumeCount                Number of volumes in the supplied array
**	pwszVolumeNameArray          supplied array of volume names
**	ppwszReturnedVolumeNameArray returned array of volume names
**	
**
**  Return Value:
**
**	Any HRESULT from memory allocation, or volume name conversions.
**
**--
*/

static HRESULT NormaliseVolumeArray (ULONG   ulVolumeCount,
				     LPWSTR pwszVolumeNamesArray[],
				     PPWCHAR ppwszReturnedVolumeNamesArray[])
    {
    HRESULT	hrStatus                       = NOERROR;
    PPWCHAR	pwszNormalisedVolumeNamesArray = NULL;
    BOOL	bSucceeded;



    if ((0 < ulVolumeCount) && (NULL != pwszVolumeNamesArray))
	{
	pwszNormalisedVolumeNamesArray = (PPWCHAR) HeapAlloc (GetProcessHeap (),
							      HEAP_ZERO_MEMORY,
							      (ulVolumeCount * (MAX_VOLUMENAME_SIZE + sizeof (PWCHAR))));

	hrStatus = GET_STATUS_FROM_POINTER (pwszNormalisedVolumeNamesArray);


	for (ULONG ulIndex = 0; SUCCEEDED (hrStatus) && (ulIndex < ulVolumeCount); ulIndex++)
	    {
	    pwszNormalisedVolumeNamesArray [ulIndex] = (PWCHAR)((PBYTE)pwszNormalisedVolumeNamesArray
								+ (ulVolumeCount * sizeof (PWCHAR))
								+ (ulIndex * MAX_VOLUMENAME_SIZE));

	    bSucceeded = GetVolumeNameForVolumeMountPointW (pwszVolumeNamesArray [ulIndex],
							    pwszNormalisedVolumeNamesArray [ulIndex],
							    MAX_VOLUMENAME_SIZE);

            if ( !bSucceeded )
                {
                //
                //  See if this is one of the object not found errors.  Bug #223058.
                //
                DWORD dwErr = ::GetLastError();
                if ( dwErr == ERROR_FILE_NOT_FOUND || dwErr == ERROR_DEVICE_NOT_CONNECTED
                     || dwErr == ERROR_NOT_READY )
                    {
                    hrStatus = VSS_E_OBJECT_NOT_FOUND;
                    }
                else
                    {
                    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
                    }

	        LogFailure (NULL,
		    	    hrStatus,
			    hrStatus,
			    NULL,
			    L"GetVolumeNameForVolumeMountPointW",
			    L"NormaliseVolumeArray");
	        }
	    }
        }

    if (SUCCEEDED (hrStatus))
	{
	*ppwszReturnedVolumeNamesArray = pwszNormalisedVolumeNamesArray;
	}

    else
	{
	*ppwszReturnedVolumeNamesArray = NULL;

	if (NULL != pwszNormalisedVolumeNamesArray)
	    {
	    HeapFree (GetProcessHeap (), 0, pwszNormalisedVolumeNamesArray);
	    }
	}


    return (hrStatus);
    } /* NormaliseVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	Cleans up whatever was allocated by NormaliseVolumeArray.
**
**
**  Arguments:
**
**	prpwszNormalisedVolumeNameArray	array of volume names
**	
**
**  Return Value:
**
**	None
**
**--
*/

static VOID CleanupVolumeArray (PPWCHAR prpwszNormalisedVolumeNameArray[])
    {
    if (NULL != *prpwszNormalisedVolumeNameArray)
	{
	HeapFree (GetProcessHeap (), 0, *prpwszNormalisedVolumeNameArray);
	*prpwszNormalisedVolumeNameArray = NULL;
	}
    } /* CleanupVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to register the COM event
**	subscriptions for Snapshot event notifications and to prepare
**	the shim writers to be invoked either via the snapshot event
**	delivery mechanisim or via a call to the SimulateSnapshotXxxx()
**	routines.
**
**
**  Arguments:
**
**      ppFuncFreeze - Returns a pointer to the internal simulate freeze
**          function.
**      ppFuncThaw - Returns a pointer to the internal simulate thaw
**          function.
**
**	None
**
**  Return Value:
**
**	Any HRESULT from COM Event subscription functions or from the Snapshot writer
**	Init functions.
**
**--
*/
HRESULT RegisterSnapshotSubscriptions (
    OUT PFunc_SimulateSnapshotFreezeInternal *ppFuncFreeze,
    OUT PFunc_SimulateSnapshotThawInternal *ppFuncThaw
    )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::RegisterSnapshotSubscriptions");

    BOOL		bPrivilegesSufficient = FALSE;


    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

	ft.ThrowIf ( ( ppFuncFreeze == NULL ) || ( ppFuncThaw == NULL ),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED internal function pointers are NULL");

        *ppFuncFreeze = NULL;
  	*ppFuncThaw = NULL;

	ft.hr = InitialiseGlobalState ();

        //
        //  Set up pointers to the internal snapshot freeze and thaw
        //
        *ppFuncFreeze = &SimulateSnapshotFreezeInternal;
  	*ppFuncThaw = &SimulateSnapshotThawInternal;
	}
    VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* RegisterSnapshotSubscriptions () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to unregister the COM event subscriptions
**	for Snapshot event notifications and to cleanup any outstanding shim writer state.
**
**  Arguments:
**
**	None
**
**  Return Value:
**
**	Any HRESULT from COM Event unregister subscription functions or from the Snapshot
**	writer Finished functions.
**
**--
*/

HRESULT UnregisterSnapshotSubscriptions (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"VssAPI::UnregisterSnapshotSubscriptions");

    BOOL		bPrivilegesSufficient;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

	CleanupGlobalState ();
	} VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* UnregisterSnapshotSubscriptions () */

/*
**++
**
**  Routine Description:
**
**	Initializes the shim global state in preparation for
**	responding to either writer requests or calls to
**	SimulateSnapshotFreeze and SimulateSnapshotThaw.
**
**
**
**  Arguments:
**
**      NONE
**
**  Return Value:
**
**	Any HRESULT from COM Event register subscription functions, Snapshot
**	writer startup functions, thread, event or mutex creation.
**	
**
**--
*/

static HRESULT InitialiseGlobalState ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::InitialiseGlobalState");

    PCVssWriterShim	pCVssWriterShimBootableStateLocal = NULL;
    PCVssWriterShim	pCVssWriterShimSimulateOnlyLocal  = NULL;

    try
	{
	if ((g_bGlobalStateInitialised)              ||
	    (NULL != g_pCVssWriterShimBootableState) ||
	    (NULL != g_pCVssWriterShimSimulateOnly))
	    {
	    /*
	    ** The following condition should never occur on a user system
	    ** but may well be seen by application developers.
	    */
	    ft.LogError (VSS_ERROR_SHIM_ALREADY_INITIALISED,
			 VSSDBG_SHIM);

	    BS_ASSERT (FALSE && "Illegal second attempt to initialise global state");

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED as writer instances already exist");
	    }


	/*
	** Create the writer shim instances.
	*/
	pCVssWriterShimBootableStateLocal = new CVssWriterShim (SHIM_APPLICATION_NAME_BOOTABLE_STATE,
								ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR,
								idWriterBootableState,
								TRUE,
								COUNT_SHIM_WRITERS_BOOTABLE_STATE,
								g_rpShimWritersArrayBootableState,
								TRUE);      // Bug 622487 (Com+ was the last mini-writer active in none-simulate mode)

	if (NULL == pCVssWriterShimBootableStateLocal)
	    {
	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_ALLOCATE_WRITER_INSTANCE,
			 VSSDBG_SHIM << SHIM_APPLICATION_NAME_BOOTABLE_STATE);

	    ft.Throw (VSSDBG_SHIM,
		      E_OUTOFMEMORY,
		      L"FAILED to allocate CvssWriterShim object for BootableState");
	    }



	pCVssWriterShimSimulateOnlyLocal  = new CVssWriterShim (SHIM_APPLICATION_NAME_SIMULATE_ONLY,
								ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR,
								idWriterSimulateOnly,
								FALSE,
								COUNT_SHIM_WRITERS_SIMULATE_ONLY,
								g_rpShimWritersArraySimulateOnly,
								TRUE);

	if (NULL == pCVssWriterShimSimulateOnlyLocal)
	    {
	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_ALLOCATE_WRITER_INSTANCE,
			 VSSDBG_SHIM << SHIM_APPLICATION_NAME_SIMULATE_ONLY);

	    ft.Throw (VSSDBG_SHIM,
		      E_OUTOFMEMORY,
		      L"FAILED to allocate CvssWriterShim object for Simulate Snapshot.");
	    }



	ft.hr = pCVssWriterShimBootableStateLocal->WorkerThreadStartup ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to start the BootableState shim writer worker thread");



	ft.hr = pCVssWriterShimSimulateOnlyLocal->WorkerThreadStartup ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to start the SimulateOnly shim writer worker thread");


	/*
	** Do the startup work.
	*/
	ft.hr = pCVssWriterShimBootableStateLocal->RegisterWriterShim ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to register the BootableState shim writer class");



	ft.hr = pCVssWriterShimSimulateOnlyLocal->RegisterWriterShim ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to register the SimulateState shim writer class");

	/*
	** Now that everything is ok, transfer ownership of the
	** instances of the shim writer class to the final locations
	*/
	g_pCVssWriterShimBootableState = pCVssWriterShimBootableStateLocal;
	g_pCVssWriterShimSimulateOnly  = pCVssWriterShimSimulateOnlyLocal;

	pCVssWriterShimBootableStateLocal = NULL;
	pCVssWriterShimSimulateOnlyLocal  = NULL;

	g_bGlobalStateInitialised = TRUE;
	} VSS_STANDARD_CATCH (ft);



    delete pCVssWriterShimBootableStateLocal;
    delete pCVssWriterShimSimulateOnlyLocal;

    return (ft.hr);
    } /* InitialiseGlobalState () */


/*
**++
**
**  Routine Description:
**
**	Cleans up the shim global state 
**
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT thrown by CVssWriterShim object destruction.
**	
**
**--
*/

static HRESULT CleanupGlobalState (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"VssAPI::CleanupGlobalState");

    PCVssWriterShim	pCVssWriterShimBootableStateLocal;
    PCVssWriterShim	pCVssWriterShimSimulateOnlyLocal;

    try
	{
	if ( g_bGlobalStateInitialised )
	        {
        	g_bGlobalStateInitialised = FALSE;
        	
        	pCVssWriterShimBootableStateLocal = g_pCVssWriterShimBootableState;
        	pCVssWriterShimSimulateOnlyLocal  = g_pCVssWriterShimSimulateOnly;

        	g_pCVssWriterShimBootableState = NULL;
        	g_pCVssWriterShimSimulateOnly  = NULL;


        	delete pCVssWriterShimBootableStateLocal;
        	delete pCVssWriterShimSimulateOnlyLocal;
        	}
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* CleanupGlobalState () */

/*
**++
**
**  Routine Description:
**
**	Internal routine to package up the calls to deliver the
**	PrepareForSnapshot and Freeze events.
**
**  NOTE: This function is called outside the DLL by a thread in the VsSvc process.  Its
**  entry point is returned from RegisterSnapshotSubscriptions and is NOT exported by
**  the DLL.
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**      pbCancelAsync           Pointer to a bool that may become set to true while the freeze
**                              operation is underway.  When it becomes true, the freeze operation
**                              should stop.
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer PrepareForFreeze or Freeze functions.
**
**--
*/

HRESULT APIENTRY SimulateSnapshotFreezeInternal (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR  *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotFreezeInternal");

    HRESULT		hrBootableState = NOERROR;
    HRESULT		hrSimulateOnly  = NOERROR;
    ThreadArgs		wtArgs;
    PPWCHAR		rpwszNormalisedVolumeNameArray = NULL;

    g_hrSimulateFreezeStatus = NOERROR;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

        ft.ThrowIf ( pbCancelAsync == NULL,
                     VSSDBG_SHIM,
                     E_INVALIDARG,
                     L"pbCancelAsync is NULL" );

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 1" );

	if (!g_bGlobalStateInitialised)
	    {
	    // This should be impossible since the only way an external caller of this
	    // DLL can call this function is by getting the address of this function
	    // by calling RegisterSnapshotSubscriptions first.
	    ft.Throw ( VSSDBG_SHIM,
		       VSS_E_BAD_STATE,
			L"SimulateSnapshotFreezeInternal called before RegisterSnapshotSubscriptions was called or after UnregisterSnapshotSubscriptions was called");
	    }
	
	BS_ASSERT ((g_bGlobalStateInitialised)              &&
		   (NULL != g_pCVssWriterShimBootableState) &&
		   (NULL != g_pCVssWriterShimSimulateOnly));

        //  The registry shim writer needs to know this
        g_bInSimulateSnapshotFreeze = TRUE;
        
	ft.hr = NormaliseVolumeArray (ulVolumeCount,
				      ppwszVolumeNamesArray,
				      &rpwszNormalisedVolumeNameArray);

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED as unable to normalise volume array");

	ft.ThrowIf (g_guidSnapshotInProgress != GUID_NULL,
		    VSSDBG_SHIM,
		    VSS_E_SNAPSHOT_SET_IN_PROGRESS,
		    L"FAILED due to unmatched SimulateSnapshotFreeze()");

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 2" );

	g_guidSnapshotInProgress = guidSnapshotSetId;

	wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup  = ((ulOptionFlags & VSS_SW_BOOTABLE_STATE) != 0);
	wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId     = guidSnapshotSetId;
	wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount         = ulVolumeCount;
	wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray = (LPCWSTR *)rpwszNormalisedVolumeNameArray;
	wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync         = pbCancelAsync;

	hrSimulateOnly  = g_pCVssWriterShimSimulateOnly->WorkerThreadRequestOperation  (eOpDeliverEventPrepareForSnapshot,
											&wtArgs);

	hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventPrepareForSnapshot,
											&wtArgs);

	ft.ThrowIf (FAILED (hrSimulateOnly),
		    VSSDBG_SHIM,
		    hrSimulateOnly,
		    L"FAILED sending PrepareForSnapshot events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending PrepareForSnapshot events to Bootable state writers");

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 3" );
	
	wtArgs.wtArgsFreeze.guidSnapshotSetId = guidSnapshotSetId;
	wtArgs.wtArgsFreeze.pbCancelAsync     = pbCancelAsync;

	hrSimulateOnly  = g_pCVssWriterShimSimulateOnly->WorkerThreadRequestOperation  (eOpDeliverEventFreeze, &wtArgs);
	hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventFreeze, &wtArgs);

	ft.ThrowIf (FAILED (hrSimulateOnly),
		    VSSDBG_SHIM,
		    hrSimulateOnly,
		    L"FAILED sending Freeze events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending Freeze events to Bootable state writers");

        g_bInSimulateSnapshotFreeze = FALSE;
	}
    VSS_STANDARD_CATCH (ft);
    
    CleanupVolumeArray (&rpwszNormalisedVolumeNameArray);

    // Store away the freeze status
    g_hrSimulateFreezeStatus = ft.hr;
    
    g_bInSimulateSnapshotFreeze = FALSE;  // in case exception was thrown
    
    return (ft.hr);
    } /* SimulateSnapshotFreezeInternal () */

/*
**++
**
**  Routine Description:
**
**  NOTE: This function is called outside the DLL by a thread in the VsSvc process.  Its
**  entry point is returned from RegisterSnapshotSubscriptions and is NOT exported by
**  the DLL.
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer Thaw functions.
**
**--
*/

HRESULT APIENTRY SimulateSnapshotThawInternal (
    IN GUID guidSnapshotSetId )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotThawInternal");
    HRESULT		hrBootableState       = NOERROR;
    HRESULT		hrSimulateOnly        = NOERROR;
    ThreadArgs		wtArgs;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

	if (!g_bGlobalStateInitialised)
	    {
	    // This should be impossible since the only way an external caller of this
	    // DLL can call this function is by getting the address of this function
	    // by calling RegisterSnapshotSubscriptions first.
	    ft.Throw ( VSSDBG_SHIM,
		       VSS_E_BAD_STATE,
			L"SimulateSnapshotThawInternal called before RegisterSnapshotSubscriptions was called or after UnregisterSnapshotSubscriptions was called");
	    }
	
	ft.ThrowIf (g_guidSnapshotInProgress == GUID_NULL && SUCCEEDED( g_hrSimulateFreezeStatus ),
		    VSSDBG_SHIM,
		    VSS_E_BAD_STATE,
		    L"FAILED as SimulateSnapshotFreezeInternal() has not been called");

	ft.ThrowIf (g_guidSnapshotInProgress != guidSnapshotSetId,
		    VSSDBG_SHIM,
		    VSS_E_BAD_STATE,
		    L"FAILED due to incorrect SnapshotSetId");

	BS_ASSERT ((g_bGlobalStateInitialised)              &&
		   (NULL != g_pCVssWriterShimBootableState) &&
		   (NULL != g_pCVssWriterShimSimulateOnly));

        g_bInSimulateSnapshotFreeze = TRUE;
        
        // If the simulate snapshot freeze was successful, send thaw events to the mini-writers otherwise send
        // abort events.  Bug # 286927.
        if ( SUCCEEDED( g_hrSimulateFreezeStatus ) )
            {
            wtArgs.wtArgsThaw.guidSnapshotSetId = guidSnapshotSetId;
	    hrSimulateOnly  = g_pCVssWriterShimSimulateOnly->WorkerThreadRequestOperation  (eOpDeliverEventThaw, &wtArgs);
	    hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventThaw, &wtArgs);
            }
        else
            {
            wtArgs.wtArgsAbort.guidSnapshotSetId = guidSnapshotSetId;
	    hrSimulateOnly  = g_pCVssWriterShimSimulateOnly->WorkerThreadRequestOperation  (eOpDeliverEventAbort, &wtArgs);
	    hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventAbort, &wtArgs);
            }

	ft.ThrowIf (FAILED (hrSimulateOnly),
		    VSSDBG_SHIM,
		    hrSimulateOnly,
		    L"FAILED sending Thaw events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending Thaw events to Bootable state writers");

	g_guidSnapshotInProgress = GUID_NULL;
	g_hrSimulateFreezeStatus = NOERROR;
        g_bInSimulateSnapshotFreeze = FALSE;
	}
    VSS_STANDARD_CATCH (ft);
    
    g_bInSimulateSnapshotFreeze = FALSE;  // in case exception was thrown
    
    return (ft.hr);
    } /* SimulateSnapshotThawInternal () */


/*
**************************************************************
**************************************************************
**
** CShimWriter implementation
**
**
**************************************************************
**************************************************************
*/

/*
**++
**
**  Routine Description:
**
**	Set of constructors for the CShimWriter class which
**	iniatialise all of the data member of the class, either to
**	default values or to some supplied parameters.
**
**	This class is used to manage instance of a single sub or
**	mini-writer which does basic backup of a single service or
**	entity.
**
**	A collection of these mini-writers is managed by the
**	CVssWriterShim class which connects this group of mini-writers
**	to the main snapshot coordination engine.
**
**	Effectively the CShimWriter class looks down to the
**	mini-writer and the CVssWriterShim class looks up up to the
**	coordinator.
**
**
**  Arguments:
**
**	swtWriterType                             Does this writer need to be invoked
**						  for bootable (aka System) state backups
**	pwszWriterName	                          Name of the shim writer
**	pwszTargetPath	(optional, default NULL)  Path used to save any 'spit' files
**
**
**  Return Value:
**
**	None
**--
*/

CShimWriter::CShimWriter(LPCWSTR pwszWriterName) :
	m_bBootableStateWriter(FALSE),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(NULL),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL),
	m_bSimulateOnly(FALSE)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) :
	m_bBootableStateWriter(FALSE),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(pwszTargetPath),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL),
	m_bSimulateOnly(FALSE)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, BOOL bBootableStateWriter) :
	m_bBootableStateWriter(bBootableStateWriter),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(NULL),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL),
	m_bSimulateOnly(FALSE)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bBootableStateWriter) :
	m_bBootableStateWriter(bBootableStateWriter),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(pwszTargetPath),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL),
	m_bSimulateOnly(FALSE)
    {
    }



/*
**++
**
**  Routine Description:
**
**	Destructor for the CShimWriter class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	None
**--
*/

CShimWriter::~CShimWriter()
    {
    }

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoStartup() method and to set the writer state
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoStartup() method.
**--
*/

HRESULT CShimWriter::Startup ()
    {
    HRESULT hrStatus = SetState (stateStarting, NOERROR);

    if (SUCCEEDED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Startup: Sending Startup to %s", m_pwszWriterName));

	hrStatus = SetState (stateStarted, DoStartup ());

	LogFailure (NULL, hrStatus, hrStatus, m_pwszWriterName, L"CShimWriter::DoStartup", L"CShimWriter::Startup");
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Startup: FAILURE (0x%08X) in state %s sending Startup to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Startup () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoIdentify() method and to update the writer metadata
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Identify (IN IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    HRESULT	hrStatus = NOERROR;

    BsDebugTraceAlways (0,
			DEBUG_TRACE_VSS_SHIM,
			(L"CShimWriter::Identify: Sending Identify to %s", m_pwszWriterName));

    m_pIVssCreateWriterMetadata = pIVssCreateWriterMetadata;


    hrStatus = DoIdentify ();

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Identify: FAILURE (0x%08X) in state %s sending Identify to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    m_pIVssCreateWriterMetadata = NULL;

    return (hrStatus);
    } /* CShimWriter::Identify () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoPrepareForSnapshot() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoPrepareForSnapshot() method.
**--
*/

HRESULT CShimWriter::PrepareForSnapshot (
					 IN BOOL     bBootableStateBackup,
					 IN ULONG    ulVolumeCount,
					 IN LPCWSTR *ppwszVolumeNamesArray)
    {
    HRESULT	hrStatus = SetState (statePreparingForSnapshot, NOERROR);


    if ( m_bSimulateOnly && !g_bInSimulateSnapshotFreeze )
    {
	hrStatus = SetState (statePreparedForSnapshot, hrStatus);
        return( hrStatus );
    }
    
    if (SUCCEEDED (hrStatus))
	{
	/*
	** Ensure no garbage left over from a previous run
	*/
	hrStatus = CleanupTargetPath (m_pwszTargetPath);

        if ( FAILED( hrStatus ) )                
            {
            LogFailure (NULL, hrStatus, hrStatus, m_pwszWriterName, L"CleanupTargetPath", L"CShimWriter::PrepareForSnapshot");
            }
        }

    if (SUCCEEDED( hrStatus ) )
        {
	m_ulVolumeCount         = ulVolumeCount;
	m_ppwszVolumeNamesArray = ppwszVolumeNamesArray;
	m_bParticipateInBackup  = TRUE;


	if (( m_bBootableStateWriter && bBootableStateBackup) ||
	    (!m_bBootableStateWriter && (ulVolumeCount > 0)))
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::PrepareForSnapshot: Sending PrepareForSnapshot to %s",
				 m_pwszWriterName));


		    hrStatus = CreateTargetPath (m_pwszTargetPath);

	    if (SUCCEEDED (hrStatus))
		{
		hrStatus = DoPrepareForSnapshot ();
		}

	    if (!m_bParticipateInBackup)
		{
		/*
		** The writer has chosen to exclude itself so we should
		** clean up the target path to prevent confusing the
		** backup app.
		*/
		BsDebugTraceAlways (0,
				    DEBUG_TRACE_VSS_SHIM,
				    (L"CShimWriter::PrepareForSnapshot: Self-exclusion from further participation by %s",
				     m_pwszWriterName));

		CleanupTargetPath (m_pwszTargetPath);
		}
	    }

	else
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::PrepareForSnapshot: Wrong WriterType/BackupType/VolumeCount combination - "
				 L"no further participation from %s",
				 m_pwszWriterName));

	    m_bParticipateInBackup = FALSE;
	    }


	hrStatus = SetState (statePreparedForSnapshot, hrStatus);
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::PrepareForSnapshot: FAILURE (0x%08X) in state %s sending PrepareForSnapshot to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::PrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoFreeze() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoFreeze() method.
**--
*/

HRESULT CShimWriter::Freeze ()
    {
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateFreezing, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Freeze: Sending Freeze to %s", m_pwszWriterName));

	    hrStatus = DoFreeze ();
	    }

	hrStatus = SetState (stateFrozen, hrStatus);
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Freeze: FAILURE (0x%08X) in state %s sending Freeze to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Freeze () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoThaw() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Thaw ()
    {
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateThawing, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Thaw: Sending Thaw to %s", m_pwszWriterName));

	    hrStatus = DoThaw ();
	    }

	hrStatus = SetState (stateThawed, hrStatus);
	}

    //  Clean up
    if ( !m_bSimulateOnly || g_bInSimulateSnapshotFreeze )
        CleanupTargetPath (m_pwszTargetPath);

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Thaw: FAILURE (0x%08X) in state %s sending Thaw to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Thaw () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoAbort() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Abort ()
    {
    //  The global snapshot set id may be NULL in certain cases.  Bug #289822.
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateAborting, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Abort: Sending Abort to %s", m_pwszWriterName));

	    hrStatus = DoAbort ();
	    }

	hrStatus = SetState (stateThawed, hrStatus);
	}


    //  Clean up
    if ( !m_bSimulateOnly || g_bInSimulateSnapshotFreeze )
        CleanupTargetPath (m_pwszTargetPath);

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Abort: FAILURE (0x%08X) in state %s sending Abort to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Abort () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoShutdown() method and to set the writer state
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoShutdown() method.
**--
*/

HRESULT CShimWriter::Shutdown ()
    {
    HRESULT hrStatus = SetState (stateFinishing, NOERROR);

    if (SUCCEEDED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Shutdown: Sending Shutdown to %s", m_pwszWriterName));

	hrStatus = SetState (stateFinished, DoShutdown ());
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Shutdown: FAILURE (0x%08X) in state %s sending Shutdown to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Shutdown () */

/*
**++
**
**  Routine Description:
**
**	Routine (and associated table) describing the states the shim
**	writers can get in to. Shim writer always follow this table and
**	if they fail, can deposit the failure code in the status member
**	variable under the control of this routine.
**
**	Note that entering the Thawing or Finishing states are kind of
**	like a reset on the status as one of the requirements on the
**	shim is that a Thaw event or unload need to make sure that the
**	writers have cleaned up.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Success
**	HRESULT for ERROR_INVALID_STATE for an illegal transition attempt
**	failure code from a previous (failed) operation
**--
*/


/*
** This table describes the set of legal state transitions that a shim
** writer should follow. That is, for a given current state
** ('CurState'), which new states ('NewState') are legal. For example,
** going from 'Started' to 'Preparing' is leagal but from Started' to
** 'Freezing' is no.
**
** Each externally visible state is actually a combination of an
** 'step-in-progress' state and a 'step-completed state eg 'starting'
** and 'started'.
**
** The normal sequence of states for a writer is expected to be :-
**
**	   Unknown
**	to Started
**	to Prepared
**	to Frozen
**	to Thawed
**	to Finished or Prepared
**
** There are a couple of exceptions. For example, since for the shim
** writers a 'Thaw' request is equivalent to 'Abort' the 'Thawing'
** state can be reached from 'Prepared', 'Frozen' or 'Thawed'
*/
static BOOL StateTransitionTable [stateMaximumValue][stateMaximumValue] = {
    /*      NewState   Unknown Starting Started Preparing Prepared Freezing Frozen Thawing Aborting Thawed Finishing Finished */
    /* CurState                                                                                                      */
    /*    Unknown   */ {FALSE, TRUE,    FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,    FALSE },
    /*    Starting  */ {FALSE, FALSE,   TRUE,   FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,    FALSE },
    /*    Started   */ {FALSE, TRUE,    FALSE,  TRUE,     FALSE,   FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Preparing */ {FALSE, FALSE,   FALSE,  FALSE,    TRUE,    FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,    FALSE },
    /*    Prepared  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   TRUE,    FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Freezing  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   TRUE,  FALSE,  TRUE,    FALSE, TRUE,    FALSE },
    /*    Frozen    */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, TRUE,   TRUE,    FALSE, TRUE,     FALSE },
    /*    Thawing   */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   TRUE,  TRUE,    FALSE },
    /*    Aborting  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   TRUE,  TRUE,    FALSE },
    /*    Thawed    */ {FALSE, TRUE,    FALSE,  TRUE,     FALSE,   FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Finishing */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, FALSE,    TRUE  },
    /*    Finished  */ {FALSE, TRUE,    FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,     TRUE  }};

LPCWSTR CShimWriter::GetStringFromStateCode (SHIMWRITERSTATE ssStateCode)
    {
    LPCWSTR pwszReturnedString = L"";

    switch (ssStateCode)
	{
	case stateUnknown:              pwszReturnedString = L"Unknown";              break;
	case stateStarting:             pwszReturnedString = L"Starting";             break;
	case stateStarted:              pwszReturnedString = L"Started";              break;
	case statePreparingForSnapshot: pwszReturnedString = L"PreparingForSnapshot"; break;
	case statePreparedForSnapshot:  pwszReturnedString = L"PreparedForSnapshot";  break;
	case stateFreezing:             pwszReturnedString = L"Freezing";             break;
	case stateFrozen:               pwszReturnedString = L"Frozen";               break;
	case stateThawing:              pwszReturnedString = L"Thawing";              break;
	case stateThawed:               pwszReturnedString = L"Thawed";               break;
	case stateAborting:             pwszReturnedString = L"Aborting";             break;
	case stateFinishing:            pwszReturnedString = L"Finishing";            break;
	case stateFinished:             pwszReturnedString = L"Finished";             break;
	default:                        pwszReturnedString = L"UNDEFINED STATE";      break;
	}

    return (pwszReturnedString);
    }


HRESULT CShimWriter::SetState (SHIMWRITERSTATE	ssNewState,
			       HRESULT		hrWriterStatus)
    {
    HRESULT hrStatus = S_OK;

    if (!StateTransitionTable [m_ssCurrentState][ssNewState])
	{
	//  Bad transition.  Only print out function tracer enter/exit stuff in this error case, otherwise
	//  we'll have too many trace messages.
        CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriter::SetState - INVALID STATE" );
	ft.Trace(VSSDBG_SHIM, L"MiniWriter: %s, OldState: %s, NewState: %s, hrWriterStatus: 0x%08x",
                m_pwszWriterName, GetStringFromStateCode( m_ssCurrentState ), GetStringFromStateCode( ssNewState ),
       	        hrWriterStatus);
	hrStatus = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
	ft.hr = hrStatus;       //  Will print out in function exit trace.
	}
    else
	{
	/*
	** The status maintained by the shim writer class is the last
	** status returned by the writer where any failure status
	** 'latches' and cannot be overriden until we are entering
	** either a 'Aborting' or 'Finishing' state. In those cases
	** the maintained status is updated (effectively reset) with
	** whatever has been specified.
	*/
	if (SUCCEEDED (m_hrStatus)         ||
	    (stateAborting  == ssNewState) ||
	    (stateFinishing == ssNewState))
	    {
	    m_hrStatus = hrWriterStatus;
	    }

	m_ssCurrentState = ssNewState;

	hrStatus = m_hrStatus;
	}


    return (hrStatus);
    } /* CShimWriter::SetState () */

/*
**++
**
**  Routine Description:
**
**	Default implementations of the shim writer event routines that an
**	individual shim writer can choose to implement (over-ride) or not
**	as it sees fit.
**
**
**  Arguments (implicit):
**
**	None except m_pwszTargetPath for DoThaw() and DoShutdown()
**
**
**  Return Value:
**
**	NOERROR for the default routines
**	Any HRESULT from the shim writer overridden functions.
**--
*/

HRESULT CShimWriter::DoStartup ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoIdentify ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoPrepareForBackup ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoPrepareForSnapshot ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoFreeze ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoThaw ()
    {
    if ( !m_bSimulateOnly || g_bInSimulateSnapshotFreeze )
        CleanupTargetPath (m_pwszTargetPath);

    return (NOERROR);
    }


HRESULT CShimWriter::DoAbort ()
    {
    return (DoThaw ());
    }


HRESULT CShimWriter::DoBackupComplete ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoShutdown ()
    {
    return (NOERROR);
    }




/*
**************************************************************
**************************************************************
**
** CVssWriterShim implementation
**
**
**************************************************************
**************************************************************
*/

/*
**++
**
**  Routine Description:
**
**	Constructor for the CVssWriterShim class which iniatialise all
**	of the data member of the class, either to default values or
**	to some supplied parameters.
**
**	This class is used to respond to events from the snapshot
**	coordinator and to distribute those events to a collection of
**	sub or mini-writers, a single instance of which is managed by
**	the CShimWriter class.
**
**	Effectively the CShimWriter class looks down to the
**	mini-writer and the CVssWriterShim lookup up to the
**	coordinator.
**
**
**  Arguments:
**
**	pwszWriterName		Name of the shim writer
**	idWriter		Id of the writer
**	bBootableState		Set for a bootable state writer
**	ulWriterCount		How many sub or mini-writers are managed
**	prpCShimWriterArray	Array of function pointer tables for mini-writers
**
**
**  Return Value:
**
**	None
**--
*/

CVssWriterShim::CVssWriterShim (LPCWSTR       pwszWriterName,
				LPCWSTR       pwszWriterSpitDirectoryRoot,
				VSS_ID        idWriter,
				BOOL          bBootableState,
				ULONG         ulWriterCount,
				PCShimWriter *prpCShimWriterArray,
				BOOL          bSimulateSnapshotOnly) :
	m_pwszWriterName(pwszWriterName),
	m_pwszWriterSpitDirectoryRoot(pwszWriterSpitDirectoryRoot),
	m_idWriter(idWriter),
	m_bBootableState(bBootableState),
	m_hrInitialize(HRESULT_FROM_WIN32 (ERROR_NOT_READY)),
	m_bSubscribed(FALSE),
	m_ulWriterCount(ulWriterCount),
	m_prpCShimWriterArray(prpCShimWriterArray),
	m_bSimulateSnapshotOnly(bSimulateSnapshotOnly),
	m_bRegisteredInThisProcess(FALSE),
	m_bDirectStartupCalled(FALSE),
	m_eRequestedOperation(eOpUndefined),
	m_hrStatusRequestedOperation(HRESULT_FROM_WIN32 (ERROR_NOT_READY)),
	m_hEventOperationRequest(INVALID_HANDLE_VALUE),
	m_hEventOperationCompleted(INVALID_HANDLE_VALUE),
	m_hWorkerThread(INVALID_HANDLE_VALUE),
	m_eThreadStatus(eStatusNotRunning),
	m_hrWorkerThreadCompletionStatus(NOERROR)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::CVssWriterShim");

    memset (&m_wtArgs, 0x00, sizeof (m_wtArgs));
    } /* CVssWriterShim::CVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Destructor for the CVssWriterShim class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	None
**--
*/

CVssWriterShim::~CVssWriterShim ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::~CVssWriterShim");

    // call this before thread shutdown
    UnRegisterWriterShim();
    
    try
    	{     	
       if (!HandleInvalid(m_hWorkerThread))	
       	{
       	WorkerThreadRequestOperation(eOpWorkerThreadShutdown, NULL);
       	
	       HRESULT result = WaitForSingleObject(m_hWorkerThread, INFINITE);
	       if (result == WAIT_FAILED)
	       	ft.TranslateWin32Error(VSSDBG_SHIM, L"WaitForSingleObject failed on thread handle");
              }
       }
    VSS_STANDARD_CATCH(ft)
    
    DeliverEventShutdown();
    
    CommonCloseHandle (&m_hEventOperationCompleted);
    CommonCloseHandle (&m_hEventOperationRequest);
    CommonCloseHandle (&m_hWorkerThread);
    } /* CVssWriterShim::~CVssWriterShim () */

/*
**++
**
**  Routine Description:
**
**	Registers all of the COM Event subscriptions by creating a
**	thread to call the event subscription routines. A thread is
**	used to ensure that there are no thread dependencies on any of
**	the shims thread when the COM event system delivers events.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

HRESULT CVssWriterShim::RegisterWriterShim (VOID)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"RegisterCVssWriterShim");

    try
	{
	/*
	** Do the subscriptions in a multithreaded apartment so
	** that callbacks come in on a separate thread.
	*/
	DWORD tid;
	DWORD dwStatusWait;
	HANDLE hThread = CreateThread (NULL,
				       256 * 1024,
				       CVssWriterShim::RegisterWriterShimThreadFunc,
				       this,
				       0,
				       &tid);


	ft.hr = GET_STATUS_FROM_HANDLE (hThread);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CreateThread");



	/*
	** wait for thread to complete
	*/
	dwStatusWait = WaitForSingleObject (hThread, INFINITE);

	if (WAIT_FAILED == dwStatusWait)
	    {
	    ft.hr = GET_STATUS_FROM_BOOL (FALSE);
	    }


	CloseHandle (hThread);


	LogAndThrowOnFailure (ft,
			      m_pwszWriterName,
			      L"WaitForSingleObject");


	ft.hr = m_hrInitialize;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::RegisterCVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Wrapper routine to get from a thread start point into the
**	class based CVssWriterShim::DoRegistration()
**
**
**  Arguments:
**
**	pv	Address of an argument block
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

DWORD WINAPI CVssWriterShim::RegisterWriterShimThreadFunc (void *pv)
	{
	CVssWriterShim *pShim = (CVssWriterShim *) pv;

	pShim->DoRegistration ();
	return 0;
	} /* CVssWriterShim::RegisterWriterShimThreadFunc () */

/*
**++
**
**  Routine Description:
**
**	Registers all of the COM Event subscriptions. The actual
**	writer initialisation and subscription happens here.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

void CVssWriterShim::DoRegistration (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::DoRegistration");

    BOOL fCoinitializeSucceeded = false;

    try
	{
	ft.Trace (VSSDBG_SHIM, L"Registering Subscriptions");

	if (m_bSubscribed)
	    {
	    /*
	    ** Shouldn't be seen by an end user but might be seen by a developer
	    */
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    BS_ASSERT (false && L"FAILED as already initialized/subscribed CVssWriterShim class");

	    LogAndThrowOnFailure (ft, m_pwszWriterName, NULL);
	    }



	/*
	** Set ourselves up in a multi-threaded apartment
	*/
	ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CoInitializeEx");


	fCoinitializeSucceeded = true;


	/*
	** Try enabling SE_BACKUP_NAME privilege
	*/
	ft.hr = TurnOnSecurityPrivilegeBackup();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"TurnOnSecurityPrivilegeBackup");


	/*
	** Get all the mini-writers ready to receive events
	*/
	ft.hr = DeliverEventStartup ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::DeliverEventStartup");

        if ( ! m_bSimulateSnapshotOnly )
        {
               	/*
        	** Initialize the writer class
        	*/
        	ft.hr = Initialize (m_idWriter,
        			    m_pwszWriterName,
        			    m_bBootableState ? VSS_UT_BOOTABLESYSTEMSTATE : VSS_UT_SYSTEMSERVICE,
        			    VSS_ST_OTHER,
        			    VSS_APP_SYSTEM);

        	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::Initialize");

        	/*
        	** Connect the writer to the COM event system
        	*/
        	ft.hr = Subscribe ();

        	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::Subscribe");
        }

	/*
	** We are officially subscribed and ready to do work.
	*/
	m_bSubscribed = TRUE;

	} VSS_STANDARD_CATCH(ft);


    if (fCoinitializeSucceeded)
	{
	CoUninitialize();
	}

    m_hrInitialize = ft.hr;
    } /* CVssWriterShim::DoRegistration () */

/*
**++
**
**  Routine Description:
**
**	Disconnect the writer from the COM Event subscriptions.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM UnSubscription methods.
**	S_OK if no errors.
**
**--
*/

HRESULT CVssWriterShim::UnRegisterWriterShim (VOID)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"UnRegisterCVssWriterShim");


    if (m_bSubscribed)
	{
	if ( !m_bSimulateSnapshotOnly )
	    {
        	/*
        	** First remove all the subscriptions and when that is safely
        	** done call all Finished functions in function table and then
        	** close the mutex handle.
        	**
        	** Note that we have to persevere in the case of errors as we
        	** cannot assume that the caller will ever re-attempt the
        	** unregister following a failure and we need to make sure
        	** that we limit the damage as much as possible (ie we restart
        	** paused services etc). The best we can do is trace/log the
        	** problem.
        	*/
        	ft.hr = Unsubscribe ();

        	LogFailure (&ft,
        		    ft.hr,
        		    ft.hr,
        		    m_pwszWriterName,
        		    L"CVssWriterShim::Unsubscribe",
        		    L"CVssWriterShim::UnRegisterWriterShim");
	    }
	m_bSubscribed = FALSE;
	}


    return (ft.hr);
    } /* UnRegisterCVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Event handling routines to take the OnXxxx() method calls
**	invoked by the COM event delivery mechanism and request the
**	internal worker thread to spread the word to the individual
**	mini-writers being managed by this class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM UnSubscription methods.
**	S_OK if no errors.
**
**--
*/


bool STDMETHODCALLTYPE CVssWriterShim::OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnIdentify");
    ThreadArgs	wtArgs;


    try
	{
	wtArgs.wtArgsIdentify.pIVssCreateWriterMetadata = pIVssCreateWriterMetadata;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnIdentify for %s", m_pwszWriterName);


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventIdentify, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ft.hr);
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnIdentify () */



bool STDMETHODCALLTYPE CVssWriterShim::OnPrepareSnapshot ()
    {
    CVssFunctionTracer   ft (VSSDBG_SHIM, L"CVssWriterShim::OnPrepareSnapshot");
    ThreadArgs		 wtArgs;


    try
	{
	wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup  = IsBootableSystemStateBackedUp ();
	wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId     = GetCurrentSnapshotSetId ();
	wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount         = GetCurrentVolumeCount ();
	wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray = GetCurrentVolumeArray ();
	wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync         = NULL;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnPrepareSnapshot for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"    BootableState = %s", wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup ? L"yes" : L"no");
	ft.Trace (VSSDBG_SHIM, L"    SnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId));
	ft.Trace (VSSDBG_SHIM, L"    VolumeCount   = %d", wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount);


	for (UINT iVolumeCount = 0;
	     iVolumeCount < wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount;
	     iVolumeCount++)
	    {
	    ft.Trace (VSSDBG_SHIM,
		      L"        VolumeNamesList [%d] = %s",
		      iVolumeCount,
		      wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray [iVolumeCount]);
	    }



	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventPrepareForSnapshot, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ft.hr);
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnPrepare () */



bool STDMETHODCALLTYPE CVssWriterShim::OnFreeze ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnFreeze");
    ThreadArgs		wtArgs;


    try
	{
	wtArgs.wtArgsFreeze.guidSnapshotSetId = GetCurrentSnapshotSetId ();
	wtArgs.wtArgsFreeze.pbCancelAsync     = NULL;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnFreeze for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsFreeze.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventFreeze, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnFreeze () */



bool STDMETHODCALLTYPE CVssWriterShim::OnThaw ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnThaw");
    ThreadArgs		wtArgs;


    try
	{
	wtArgs.wtArgsThaw.guidSnapshotSetId = GetCurrentSnapshotSetId ();

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnThaw for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsThaw.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventThaw, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnThaw () */



bool STDMETHODCALLTYPE CVssWriterShim::OnAbort ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnAbort");
    ThreadArgs		wtArgs;
    const GUID		guidSnapshotSetId = GetCurrentSnapshotSetId ();


    try
	{
	wtArgs.wtArgsAbort.guidSnapshotSetId = GetCurrentSnapshotSetId ();

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnAbort for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsAbort.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventAbort, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnAbort () */


/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver an 'Identify' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Identify() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventIdentify");
    HRESULT		hrLastFailure = NOERROR;
    BOOL		bCallWriter;


    /*
    ** First setup the Restore Method.  Specify a custom restore method.
    */
    ft.hr = pIVssCreateWriterMetadata->SetRestoreMethod (VSS_RME_CUSTOM,
                                                         NULL,
                                                         NULL,
                                                         VSS_WRE_NEVER,
                                                         true);
    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::DeliverEventIdentify");
	
    /*
    ** Send Identify to selected group of writer in function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone should get to hear about the Identify.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Identify)(pIVssCreateWriterMetadata);

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Identify",
		    L"CVssWriterShim::DeliverEventIdentify");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventIdentify () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'PrepareForSnapshot' event
**	by processing each of the class instances in the rgpShimWriters[] array and calling
**	the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer PrepareForSnapshot() functions.
**
**
**--
*/

HRESULT CVssWriterShim::DeliverEventPrepareForSnapshot (BOOL     bBootableStateBackup,
							GUID     guidSnapshotSetId,
							ULONG    ulVolumeCount,
							LPCWSTR *ppwszVolumeNamesArray,
                                                        volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventPrepareForSnapshot");
    HRESULT		hrLastFailure = NOERROR;
    LPCWSTR		pwszTraceStringWriterType;
    UNICODE_STRING	ucsWriterRootDirectory;


    try
	{
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"    BootableState = %s",   bBootableStateBackup ? L"yes" : L"no");
	ft.Trace (VSSDBG_SHIM, L"    SnapshotSetID = "      WSTR_GUID_FMT, GUID_PRINTF_ARG (guidSnapshotSetId));
	ft.Trace (VSSDBG_SHIM, L"    VolumeCount   = %d",   ulVolumeCount);

	for (UINT iVolumeCount = 0; iVolumeCount < ulVolumeCount; iVolumeCount++)
	    {
	    ft.Trace (VSSDBG_SHIM,
		      L"        VolumeNamesList [%d] = %s",
		      iVolumeCount,
		      ppwszVolumeNamesArray [iVolumeCount]);
	    }

	/*
	** Send PrepareForSnapshot to selected group of writers in
	** function table. We are going to do all of the writers in
	** the group even if one of them fails partway
	** through. However we will skip sending the freeze event if a
	** writer fails the prepare.
	*/
	for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->PrepareForSnapshot) (bBootableStateBackup,
									   ulVolumeCount,
									   ppwszVolumeNamesArray);

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::PrepareForSnapshot",
			L"CVssWriterShim::DeliverEventPrepareForSnapshot");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}

            ft.ThrowIf ( pbCancelAsync != NULL && *pbCancelAsync,
                         VSSDBG_SHIM,
                         VSS_S_ASYNC_CANCELLED,
                         L"User cancelled async operation" );	
	    }


	ft.hr = hrLastFailure;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::DeliverEventPrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Freeze' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Freeze() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventFreeze (GUID guidSnapshotSetId,
                                            volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventFreeze");
    HRESULT		hrLastFailure = NOERROR;


    try
	{
	/*
	** Send Freeze to a selected group of writers in function
	** table. Note that all writers in the group get called and
	** for freezing at level2
	*/
	for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Freeze)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Freeze",
			L"CVssWriterShim::DeliverEventFreeze");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	
            ft.ThrowIf ( pbCancelAsync != NULL && *pbCancelAsync,
                         VSSDBG_SHIM,
                         VSS_S_ASYNC_CANCELLED,
                         L"User cancelled async operation - 2" );	
	    }

	ft.hr = hrLastFailure;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::DeliverEventFreeze () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Thaw' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Thaw() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventThaw (GUID guidSnapshotSetId)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventThaw");

    UNICODE_STRING	ucsWriterRootDirectory;
    HRESULT		hrStatus;
    HRESULT		hrLastFailure = NOERROR;
    ULONG		ulIndex       = m_ulWriterCount;


    try
	{
	/*
	** Send Thaw to selected group of writers in the function
	** table. Keep going for all the writers in the group even if
	** one of them fails. Everyone MUST get to hear about the
	** Thaw.
	*/
	while (ulIndex--)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Thaw)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Thaw",
			L"CVssWriterShim::DeliverEventThaw");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	    }

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CVssWriterShim::DeliverEventThaw () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver an 'Abort' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Abort() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventAbort (GUID guidSnapshotSetId)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventAbort");


    UNICODE_STRING	ucsWriterRootDirectory;
    HRESULT		hrStatus;
    HRESULT		hrLastFailure = NOERROR;
    ULONG		ulIndex       = m_ulWriterCount;


    try
	{
	/*
	** Send Abort to selected group of writers in the function
	** table. Keep going for all the writers in the group even if
	** one of them fails. Everyone MUST get to hear about the
	** Abort.
	*/
	while (ulIndex--)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Abort)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Abort",
			L"CVssWriterShim::DeliverEventAbort");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	    }

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CVssWriterShim::DeliverEventAbort () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Startup' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point. This gives the shim writer the
**	chance to set up some initial state. This is called once in response to
**	a registration of the shim writer. It is NOT called for each individual
**	Prepare/Freeze/Thaw sequence.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Startup() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventStartup ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventStartup");
    HRESULT		hrLastFailure = NOERROR;


    /*
    ** Send Startup to selected group of writers in the function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone MUST get to hear about the Startup.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Startup)();

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Startup",
		    L"CVssWriterShim::DeliverEventStartup");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventStartup () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Shutdown' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point. This gives the shim writer the
**	chance to cleanup any oustanding state. It is expected that Shutdown might
**	be called at any time as a reponse to an unload of the DLL housing this
**	code. A call to the shutdown routines may be follwed by either a call to
**	the destructor for the class instance or the startup function. This
**	routine is NOT called for each individual Prepare/Freeze/Thaw sequence.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**      This method is NOT called by the worker thread, it is only called in the CVssWriterShim
**      destructor.
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Shutdown() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventShutdown ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventShutdown");
    HRESULT		hrLastFailure = NOERROR;


    /*
    ** Send Shutdown to selected group of writers in the function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone MUST get to hear about the Shutdown.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Shutdown)();

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Shutdown",
		    L"CVssWriterShim::DeliverEventShutdown");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventShutdown () */


/*
**++
**
**  Routine Description:
**
**	Routines to operate a worker thread which is used to provide a
**	stable context under which to call the mini-writers.
**
**	The prime need for this statble context is the mutex (which
**	must belong to a thread) which is used to protect the
**	PrepareForSnapshot, Freeze, Thaw/Abort event sequence as
**	executed by the writer from that executed by direct calls to
**	the SimulateSnapshotXxxx() routines.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from
**		CreateEventW()
**		CreateThread()
**		ConstructSecurityAttributes()
**
**--
*/

HRESULT CVssWriterShim::WorkerThreadStartup (void)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::WorkerThreadStartup");

    HRESULT		hrStatusClassified = NOERROR;

    SECURITY_DESCRIPTOR	sdSecurityDescriptor;


    try
	{
	if (!HandleInvalid (m_hWorkerThread)          ||
	    !HandleInvalid (m_hEventOperationRequest) ||
	    !HandleInvalid (m_hEventOperationCompleted))
	    {
	    ft.LogError (VSS_ERROR_SHIM_WORKER_THREAD_ALREADY_RUNNING,
			 VSSDBG_SHIM << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED with invalid handle for worker thread, mutex or events");
	    }


	m_hEventOperationRequest = CreateEventW (NULL, FALSE, FALSE, NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hEventOperationRequest);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_REQUEST_EVENT,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED to create OperationRequest event for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified);
	    }


	m_hEventOperationCompleted = CreateEventW (NULL, FALSE, FALSE, NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hEventOperationCompleted);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_COMPLETION_EVENT,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED to create OperationCompleted event for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified );
	    }


	m_hWorkerThread = CreateThread (NULL,
					0,
					CVssWriterShim::WorkerThreadJacket,
					this,
					0,
					NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hWorkerThread);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_THREAD,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED creating worker thread for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified );
	    }



	ft.Trace (VSSDBG_SHIM, L"Created worker thread for writer %s", m_pwszWriterName);

	} VSS_STANDARD_CATCH (ft);



    if (ft.HrFailed ())
	{
	CommonCloseHandle (&m_hEventOperationCompleted);
	CommonCloseHandle (&m_hEventOperationRequest);

	m_eThreadStatus = eStatusNotRunning;
	m_hWorkerThread = INVALID_HANDLE_VALUE;
	}
    else if (ft.HrSucceeded())
    	m_eThreadStatus = eStatusWaitingForOpRequest;

    return (ft.hr);
    } /* CVssWriterShim::WorkerThreadStartup () */

/*
**++
**
**  Routine Description:
**
**	Wrapper routine to get from a thread start point into the
**	class based CVssWriterShim::WorkerThread()
**
**
**  Arguments:
**
**	pvThisPtr	Address of an class 'this' pointer
**
**
**  Return Value:
**
**	None
**
**--
*/

DWORD WINAPI CVssWriterShim::WorkerThreadJacket (void *pvThisPtr)
    {
    PCVssWriterShim pCVssWriterShim = (PCVssWriterShim) pvThisPtr;

    pCVssWriterShim->WorkerThread ();

    return (0);
    } /* CVssWriterShim::WorkerThreadJacket () */

/*
**++
**
**  Routine Description:
**
**	Worker thread to deliver requested events to mini-writers.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT generated by the mini-writers.
**
**--
*/

HRESULT CVssWriterShim::WorkerThread (void)
    {
    HRESULT	hrStatus  = NOERROR;
    BOOL	bContinue = TRUE;
    BOOL	bSucceeded;
    DWORD	dwStatusWait;


    while (bContinue)
	{
	m_eThreadStatus = eStatusWaitingForOpRequest;

	dwStatusWait = WaitForSingleObject (m_hEventOperationRequest, INFINITE);


	m_eThreadStatus = eStatusProcessingOpRequest;

	switch (dwStatusWait)
	    {
	    case WAIT_OBJECT_0:
		hrStatus = NOERROR;
		break;


	    case WAIT_FAILED:
		hrStatus = GET_STATUS_FROM_BOOL (FALSE);
		break;


	    default:
		hrStatus = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
		break;
	    }



	if (FAILED (hrStatus))
	    {
	    /*
	    ** If we have had any failures operating the thread then
	    ** it's time to leave.
	    */
	    LogFailure (NULL,
			hrStatus,
			m_hrStatusRequestedOperation,
			m_pwszWriterName,
			L"WaitForSingleObject",
			L"CVssWriterShim::WorkerThread");

	    m_hrStatusRequestedOperation = hrStatus;

	    bContinue = FALSE;
	    }
	else
	    {
	    /*
	    ** We've been asked to do something. find out what and go do it.
	    */
	    switch (m_eRequestedOperation)
		{
		case eOpDeliverEventStartup:
		    m_hrStatusRequestedOperation = DeliverEventStartup ();
		    break;

		case eOpDeliverEventIdentify:
		    m_hrStatusRequestedOperation = DeliverEventIdentify (m_wtArgs.wtArgsIdentify.pIVssCreateWriterMetadata);
		    break;
			
		case eOpDeliverEventPrepareForBackup:
		    m_hrStatusRequestedOperation = NOERROR;
		    break;

		case eOpDeliverEventPrepareForSnapshot:
		    m_hrStatusRequestedOperation = DeliverEventPrepareForSnapshot (m_wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup,
										   m_wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId,
										   m_wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount,
										   m_wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray,
										   m_wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync);
		    break;
		
		case eOpDeliverEventFreeze:
		    m_hrStatusRequestedOperation = DeliverEventFreeze (m_wtArgs.wtArgsFreeze.guidSnapshotSetId,
							                 m_wtArgs.wtArgsFreeze.pbCancelAsync);
		    break;

		case eOpDeliverEventThaw:
		    m_hrStatusRequestedOperation = DeliverEventThaw (m_wtArgs.wtArgsThaw.guidSnapshotSetId);
		    break;

		case eOpDeliverEventAbort:
		    m_hrStatusRequestedOperation = DeliverEventAbort (m_wtArgs.wtArgsAbort.guidSnapshotSetId);
		    break;

		case eOpWorkerThreadShutdown:
		    m_hrStatusRequestedOperation = NOERROR;
		    hrStatus                     = NOERROR;

		    bContinue = FALSE;
		    break;

		default:
		    LogFailure (NULL,
				HRESULT_FROM_WIN32 (ERROR_INVALID_OPERATION),
				m_hrStatusRequestedOperation,
				m_pwszWriterName,
				L"CVssWriterShim::DeliverEventUnknown",
				L"CVssWriterShim::WorkerThread");

		    break;
		}
	    }



	if (!bContinue)
	    {
	    m_eThreadStatus                  = eStatusNotRunning;
	    m_hrWorkerThreadCompletionStatus = hrStatus;
	    }



	/*
	** The SetEvent() must be the last call on a shutdown to touch
	** the class as by the very next instruction it may no longer
	** be there.
	*/
	bSucceeded = SetEvent (m_hEventOperationCompleted);

	LogFailure (NULL,
		    GET_STATUS_FROM_BOOL (bSucceeded),
		    hrStatus,
		    L"(UNKNOWN)",
		    L"SetEvent",
		    L"CVssWriterShim::WorkerThread");


	bContinue &= bSucceeded;
	}


    return (hrStatus);
    } /* CVssWriterShim::WorkerThread () */

/*
**++
**
**  Routine Description:
**
**	Routine to request an operation of the worker thread for this
**	class. Uses a critical section to ensure only on operation can
**	be outstanding at any one time.
**
**
**  Arguments:
**
**	eOperation	Code to selct the required operation
**	pThreadArgs	Pointer to a block of args specific to the operation
**
**
**  Return Value:
**
**	Any HRESULT generated by the operation.
**
**--
*/

HRESULT CVssWriterShim::WorkerThreadRequestOperation (RequestOpCode eOperation, PThreadArgs pThreadArgs)
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::RequestOperation");

    DWORD	dwStatusWait;
    BOOL	bSucceeded;


    try
	{
        CBsAutoLock cAutoLock (m_cCriticalSection);


	if ((m_eThreadStatus != eStatusProcessingOpRequest &&
	    m_eThreadStatus != eStatusWaitingForOpRequest))
	    {
	    ft.LogError (VSS_ERROR_SHIM_WRITER_NO_WORKER_THREAD,
			 VSSDBG_SHIM << m_pwszWriterName << eOperation);

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED requesting operation 0x%02X in %s due to missing worker thread",
		      eOperation,
		      m_pwszWriterName);
	    }


	if (NULL != pThreadArgs)
	    {
	    m_wtArgs = *pThreadArgs;
	    }

	m_eRequestedOperation = eOperation;

	bSucceeded = SetEvent (m_hEventOperationRequest);

	ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"SetEvent");




	dwStatusWait = WaitForSingleObject (m_hEventOperationCompleted, INFINITE);

	switch (dwStatusWait)
	    {
	    case WAIT_OBJECT_0:

		ft.hr = m_hrStatusRequestedOperation;

		ft.ThrowIf (ft.HrFailed (),
			    VSSDBG_SHIM,
			    ft.hr,
			    L"FAILED whilst processing requested operation 0x%02X", eOperation);

		break;


	    case WAIT_FAILED:
		ft.hr = GET_STATUS_FROM_BOOL (FALSE);
		break;


	    default:
		ft.hr = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
		break;
	    }


	if (ft.HrFailed ())
	    {
	    HRESULT hrStatusClassified = ClassifyWriterFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_WRITER_FAILED_OPERATION,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified<< m_pwszWriterName << eOperation );

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED with 0x%08lX (converted to 0x%08lX) waiting for completion of requested operation 0x%02X in writer %s",
		      ft.hr,
		      hrStatusClassified,
		      eOperation,
		      m_pwszWriterName);
	    }
	} VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* CVssWriterShim::RequestOperation () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrwmi.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrwmi.cpp

Abstract:

    Writer shim module for WMI Database
    
    NOTE: This module is not used/compiled anymore since WMI has its own snapshot writer.
    
Author:

    Michael C. Johnson [mikejohn]	22-Jun--2000

Revision History:

	X-7	MCJ		Michael C. Johnson		 7-Dec-2000
		235991: Remove workaround for the now re-instated WMI backup API

	X-6	MCJ		Michael C. Johnson		17-Nov-2000
		235987: Add workaround for broken WMI backup API

	X-5	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-4	MCJ		Michael C. Johnson		13-Sep-2000
		178282: Writer should only generate backup file if source 
			path is in volume list.

	X-3	MCJ		Michael C. Johnson		22-Aug-2000
		167335: Pull workaround for broken WMI backup API.
		169412: Add repository to the exclude list.

	X-2	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-1	MCJ		Michael C. Johnson		 9-Mar-2000
		Initial version based upon code originally in NtBackup.

--*/

#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"
#include <wbemcli.h>



#define APPLICATION_STRING	L"WmiDatabase"
#define COMPONENT_NAME		L"WMI Database"

#define TARGET_PATH		ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define REPOSITORY_PATH		L"%SystemRoot%\\system32\\wbem\\Repository"

DeclareStaticUnicodeString (ucsBackupFilename, L"\\WBEM.bak");



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterWMI : public CShimWriter
    {
public:
    CShimWriterWMI (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterWMI ShimWriterWMI (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterWMI = &ShimWriterWMI;




/*
**++
**
**  Routine Description:
**
**	The Terminal Services Licensing Server database snapshot
**	writer DoIdentify() function.
**
**
**  Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
**  Return Value:
**
**	Any HRESULT from adding items to backup metadata document.
**
**-- 
*/

HRESULT CShimWriterWMI::DoIdentify ()
    {
    HRESULT	hrStatus;


    hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							  NULL,
							  COMPONENT_NAME,
							  COMPONENT_NAME,
							  NULL, // icon
							  0,
							  true,
							  false,
							  false);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"IVssCreateWriterMetadata::AddComponent", 
		L"CShimWriterWMI::DoIdentify");



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     m_pwszTargetPath,
								     L"*",
								     true,
								     NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddFilesToFileGroup", 
		    L"CShimWriterWMI::DoIdentify");
	}



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddExcludeFiles (REPOSITORY_PATH,
								 L"*",
								 true);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddExcludeFiles", 
		    L"CShimWriterWMI::DoIdentify");
	}


    return (hrStatus);
    } /* CShimWriterWMI::DoIdentify () */


/*
**++
**
**  Routine Description:
**
**	The WMI writer PrepareForFreeze function.  Currently all of the
**	real work for this writer happens here.
**
**
**  Arguments:
**
**	Same arguments as those passed in the PrepareForFreeze event.
**
**
**  Return Value:
**
**	Any HRESULT from string allocation or Wbem calls to create an
**	interface pointer or calls to backup through that interface.
**
**--
*/

HRESULT CShimWriterWMI::DoPrepareForSnapshot ()
    {
    HRESULT		 hrStatus            = NOERROR;
    BOOL		 bInstanceCreated    = FALSE;
    IWbemBackupRestore	*pIWbemBackupRestore = NULL ;
    UNICODE_STRING	 ucsTargetPath;
    UNICODE_STRING	 ucsSourcePath;



    StringInitialise (&ucsSourcePath);
    StringInitialise (&ucsTargetPath);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
						   REPOSITORY_PATH);
	}



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = IsPathInVolumeArray (ucsSourcePath.Buffer,
					m_ulVolumeCount,
					m_ppwszVolumeNamesArray,
					&m_bParticipateInBackup);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   ucsBackupFilename.Length);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	StringAppendString (&ucsTargetPath, &ucsBackupFilename);


	/*
	** We can be certain that we've already had a call to
	** CoInitialzeEx() in this thread, so we can just go ahead and
	** make our COM calls.
	*/
    ft.CoCreateInstanceWithLog(
            VSSDBG_WRITER,
            CLSID_WbemBackupRestore,
            L"WbemBackupRestore",
            CLSCTX_LOCAL_SERVER,
            IID_IWbemBackupRestore,
            (IUnknown**)&(pIWbemBackupRestore));
	bInstanceCreated = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"CoCreateInstance", 
		    L"CShimWriterWMI::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = pIWbemBackupRestore->Backup (ucsTargetPath.Buffer, 
						WBEM_FLAG_BACKUP_RESTORE_DEFAULT);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IWbemBackupRestore::Backup", 
		    L"CShimWriterWMI::DoPrepareForSnapshot");
	}




    if (bInstanceCreated) pIWbemBackupRestore->Release ();

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);


    return (hrStatus);
    } /* CShimWriterWMI::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrtls.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrtls.cpp

Abstract:

    Writer shim module for Terminal Server Licensing

Author:

    Stefan R. Steiner   [ssteiner]        02-13-2000

Revision History:

	X-9	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-8	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path
		141365: Workaround problem in loading tls236.dll by 
		        pre-loading user32

	X-7	MCJ		Michael C. Johnson		21-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-6	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-5	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		23-Mar-2000
		Get writer to use same context mechanism as most of the other
		writers.

	X-2	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

--*/

#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHTLSC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING	L"TerminalServicesLicensingServer"
#define COMPONENT_NAME		L"Terminal Services Licensing Server"

#define TARGET_PATH		ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING


#define	EXPORTPATH_SUBKEY	L"System\\CurrentControlSet\\services\\TermServLicensing\\Parameters"
#define	EXPORTPATH_VALUENAME	L"DBPath"
#define EXPORTPATH_DIRECTORY	L"\\Export\\"


/*
**  Terminal service licensing DLL function prototype
*/
typedef DWORD (WINAPI *PFUNC_ExportTlsDatabaseC)(VOID);



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterTLS : public CShimWriter
    {
public:
    CShimWriterTLS (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterTLS ShimWriterTLS (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterTLS = &ShimWriterTLS;




/*
**++
**
** Routine Description:
**
**	The Terminal Services Licensing Server database snapshot
**	writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- */

HRESULT CShimWriterTLS::DoIdentify ()
    {
    HRESULT	hrStatus;


    hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							  NULL,
							  COMPONENT_NAME,
							  COMPONENT_NAME,
							  NULL, // icon
							  0,
							  true,
							  false,
							  false);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"IVssCreateWriterMetadata::AddComponent", 
		L"CShimWriterTLS::DoIdentify");


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     m_pwszTargetPath,
								     L"*",
								     true,
								     NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddFilesToFileGroup", 
		    L"CShimWriterTLS::DoIdentify");
	}


    return (hrStatus);
    } /* CShimWriterTLS::DoIdentify () */


/*
**++
**
**  Routine Description:
**
**	The TLS writer PrepareForFreeze function.  Currently all of the
**	real work for this writer happens here.
**
**  Arguments:
**
**	Same arguments as those passed in the PrepareForFreeze event.
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterTLS::DoPrepareForSnapshot ()
    {
    HRESULT			hrStatus;
    DWORD			dwStatus;
    DWORD			dwValueDataLength;
    DWORD			dwValueType;
    BOOL			bSucceeded;
    BOOL			bExportPathKeyOpened = FALSE;
    UNICODE_STRING		ucsTargetPath;
    UNICODE_STRING		ucsSourcePath;
    UNICODE_STRING		ucsValueData;
    PFUNC_ExportTlsDatabaseC	ExportTlsDatabaseC   = NULL;
    HMODULE			hLibraryTermServ     = NULL;
    HMODULE			hLibraryUser32       = NULL;
    HKEY			hkeyExportPath       = NULL;



    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsSourcePath);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueData,
			       REGISTRY_BUFFER_SIZE * sizeof (WCHAR));


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsTargetPath, DIR_SEP_STRING);


	dwStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				  EXPORTPATH_SUBKEY,
				  0,
				  KEY_QUERY_VALUE,
				  &hkeyExportPath);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	bExportPathKeyOpened = SUCCEEDED (hrStatus);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no exportpath subkey entry"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	
	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	** Everything is setup, so first check to see if there is a
	** registry key present which will tell us where the
	** ExportTlsDatabaseC() call is going to dump it's file. Also,
	** if it's got environment variables in it make sure they get
	** expanded.
	*/
	dwValueDataLength = ucsValueData.MaximumLength;
	dwValueType       = REG_NONE;

	dwStatus = RegQueryValueExW (hkeyExportPath,
				     EXPORTPATH_VALUENAME,
				     NULL,
				     &dwValueType,
				     (PBYTE) ucsValueData.Buffer,
				     &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no DBPath entry"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	
	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegQueryValueExW", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
	{
	ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
						   ucsValueData.Buffer,
						   MAX_PATH);


	if (SUCCEEDED (hrStatus))
	    {
	    /*
	    **  That gets us the root, now append the actual directory
	    */
	    StringAppendString (&ucsSourcePath, EXPORTPATH_DIRECTORY);
	    }
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	** As a workaround to a problem with unloading - reloading
	** user32 pre-load things so we can guarantee at least one
	** reference on it and stop it going away over the critical
	** point.
	*/
	hLibraryUser32 = LoadLibraryW (L"user32.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hLibraryUser32);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (user32.dll)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
        /*
	**  Now tell TLS to export the database
        **
	**
        **  First load the TLS backup DLL
	*/
        hLibraryTermServ = LoadLibraryW (L"tls236.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hLibraryTermServ);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    /*
	    **  Terminal Server Licensing service probably not installed
	    */
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no tls236.dll found"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (tls236.dll)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
        /*
	** Now setup the function pointer to the export function
	*/
	ExportTlsDatabaseC = (PFUNC_ExportTlsDatabaseC) GetProcAddress (hLibraryTermServ, 
									"ExportTlsDatabaseC");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != ExportTlsDatabaseC);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (ExportTlsDatabaseC)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	try
	    {
	    /*
	    ** Perform the export
	    */
	    dwStatus = ExportTlsDatabaseC();

	    hrStatus = HRESULT_FROM_WIN32 (dwStatus);
	    }

	catch (DWORD dwStatus)
	    {
	    hrStatus = HRESULT_FROM_WIN32 (dwStatus);
	    }

	catch (...)
	    {
	    hrStatus = E_UNEXPECTED;
	    }



	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    /*
	    **  Terminal Server Licensing service probably not running
	    */
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not running, "
				 L"perhaps not a DomainController?"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"ExportTlsDatabaseC", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	**  Now move the files in the export directory to the TLS backup directory
	*/
	hrStatus = MoveFilesInDirectory (&ucsSourcePath, &ucsTargetPath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}





    /*
    ** Release the libraries
    */
    if (bExportPathKeyOpened)              RegCloseKey (hkeyExportPath);
    if (!HandleInvalid (hLibraryTermServ)) FreeLibrary (hLibraryTermServ);
    if (!HandleInvalid (hLibraryUser32))   FreeLibrary (hLibraryUser32);

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);
    StringFree (&ucsValueData);

    return (hrStatus);
    } /* CShimWriterTLS::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrrsm.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrrsm.cpp

Abstract:

    Writer shim module for RSM

Author:

    Stefan R. Steiner   [ssteiner]        01-31-2000

Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

 	X-10	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path
		Also remove trailing '\' on export sibdurectory reported in 
		metadata.

	X-9	MCJ		Michael C. Johnson		18-Jul-2000
		145021: Load the Ntms dll dynamically to reduce footprint.

	X-8	MCJ		Michael C. Johnson		27-Jun-2000
		Add an alternative location mapping for the restore of the
		RSM spit files.
		Handle change in RSM startup behaviour which means calls to 
		OpenNtmsSession() may fail until service has started.

	X-7	MCJ		Michael C. Johnson		21-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-6	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-5	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		21-Mar-2000
		Get writer to use same context mechanism as most of the other
		writers.
		Check registry for presence of export path definition and use
		it if present.
		Also ensure it cleans up after itself.

	X-2	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

--*/

#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"
#include <ntmsapi.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHRSMC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING		L"RemovableStorageManager"
#define COMPONENT_NAME			L"Removable Storage Manager"
#define TARGET_PATH			ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define EXPORT_SUBDIRECTORY		L"\\Export"

#define SUBKEY_SOURCE_PATH_ROOT		L"SYSTEM\\CurrentControlSet\\Control\\NTMS\\NtmsData"
#define DEFAULT_SOURCE_PATH_ROOT	L"%SystemRoot%\\system32\\NtmsData"


#define NTMS_OPEN_SESSION_RETRY_PERIOD		(20)		// in seconds
#define NTMS_OPEN_SESSION_POLLING_INTERVAL	(100)		// in milli-seconds
#define NTMS_OPEN_SESSION_ATTEMPTS		((NTMS_OPEN_SESSION_RETRY_PERIOD * 1000) / NTMS_OPEN_SESSION_POLLING_INTERVAL)


typedef HANDLE (WINAPI *PFnOpenNtmsSessionW)   (LPCWSTR, LPCWSTR, DWORD);
typedef DWORD  (WINAPI *PFnCloseNtmsSession)   (HANDLE);
typedef DWORD  (WINAPI *PFnExportNtmsDatabase) (HANDLE);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterRSM : public CShimWriter
    {
public:
    CShimWriterRSM (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT DetermineDatabaseLocation (PUNICODE_STRING pucsDatabasePath);
    };


static CShimWriterRSM ShimWriterRSM (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterRSM = &ShimWriterRSM;


/*
**++
**
** Routine Description:
**
**	DetermineDatabaseLocation() attempts to locate the RSM (aka
**	NTMS) database location following the same rules as RSM uses.
**
**
** Arguments:
**
**	pucsDatabasePath	initliased unicode string
**
**
** Return Value:
**
**	HRESULTS from memory allocation failures and registry operations 
**
**-- 
*/

HRESULT CShimWriterRSM::DetermineDatabaseLocation (PUNICODE_STRING pucsDatabasePath)
    {
    HRESULT		hrStatus = NOERROR;
    DWORD		dwStatus;
    DWORD		dwValueDataLength;
    DWORD		dwValueType;
    UNICODE_STRING	ucsValueData;


    StringInitialise (&ucsValueData);

    StringFree (pucsDatabasePath);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, 
				   REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Everything is setup, so first check to see if there is a
	** registry key present which will tell us where the Ntms
	** database is supposed to live. If it's got environment
	** variables in it make sure they get expanded.
	**
	** If there is no key we fall back to the default location.
	*/
	dwValueDataLength = ucsValueData.MaximumLength;
	dwValueType       = REG_NONE;

	dwStatus = RegQueryValueExW (HKEY_LOCAL_MACHINE,
				     SUBKEY_SOURCE_PATH_ROOT,
				     NULL,
				     &dwValueType,
				     (PBYTE) ucsValueData.Buffer,
				     &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) != hrStatus))
	    {
	    /*
	    ** This may be a real failure so log it just in case
	    ** things stop working later on.
	    */
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegQueryValueExW", 
			L"CShimWriterRSM::DetermineDatabaseLocation");
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    }



	if (SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
	    {
	    hrStatus = StringCreateFromExpandedString (pucsDatabasePath,
						       ucsValueData.Buffer,
						       MAX_PATH);
	    }

	else if (SUCCEEDED (hrStatus) && (REG_SZ == dwValueType))
	    {
	    hrStatus = StringAllocate (pucsDatabasePath,
				       MAX_PATH * sizeof (WCHAR));


	    if (SUCCEEDED (hrStatus))
		{
		StringAppendString (pucsDatabasePath, &ucsValueData);
		}
	    }

	else
	    {
	    /*
	    ** Ok we either failed to find the registry key or what we did
	    ** get wasn't suitable for us to use so fall back to the
	    ** 'standard default' location and just pray that's where the
	    ** ExportNtmsDatabase() call actually dumps it's data.
	    */
	    hrStatus = StringCreateFromExpandedString (pucsDatabasePath,
						       DEFAULT_SOURCE_PATH_ROOT,
						       MAX_PATH);
	    }
	}



    StringFree (&ucsValueData);


    return (hrStatus);
    } /* CShimWriterRSM::DetermineDatabaseLocation () */

/*
**++
**
** Routine Description:
**
**	The Removable Storage Manager database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRSM::DoIdentify ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRSM::DoIdentify");
    UNICODE_STRING	ucsDatabaseLocation;


    StringInitialise (&ucsDatabaseLocation);



    try
	{
	ft.hr = DetermineDatabaseLocation (&ucsDatabaseLocation);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRSM::DetermineDatabaseLocation");




	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (ucsDatabaseLocation.Buffer,
							      L"*",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");



	} 
    VSS_STANDARD_CATCH (ft)




    StringFree (&ucsDatabaseLocation);

    return (ft.hr);
    } /* CShimWriterRSM::DoIdentify () */

/*++

Routine Description:

    The RSM writer PrepareForFreeze function.  Currently all of the
    real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForFreeze event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterRSM::DoPrepareForSnapshot ()
    {
    HRESULT			hrStatus = NOERROR;
    HANDLE			hRsm     = INVALID_HANDLE_VALUE;
    HMODULE			hNtmsDll = NULL;
    DWORD			dwStatus;
    UNICODE_STRING		ucsTargetPath;
    UNICODE_STRING		ucsSourcePath;
    PFnOpenNtmsSessionW		DynamicOpenNtmsSessionW;
    PFnExportNtmsDatabase	DynamicExportNtmsDatabase;
    PFnCloseNtmsSession		DynamicCloseNtmsSession;


    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsSourcePath);


    hNtmsDll = LoadLibraryW (L"ntmsapi.dll");

    hrStatus = GET_STATUS_FROM_HANDLE (hNtmsDll);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"LoadLibraryW (ntmsapi.dll)", 
		L"CShimWriterRSM::DoPrepareForSnapshot");



    if (SUCCEEDED (hrStatus))
	{
	DynamicOpenNtmsSessionW = (PFnOpenNtmsSessionW) GetProcAddress (hNtmsDll, "OpenNtmsSessionW");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicOpenNtmsSessionW);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (OpenNtmsSessionW)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	DynamicExportNtmsDatabase = (PFnExportNtmsDatabase) GetProcAddress (hNtmsDll, "ExportNtmsDatabase");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicExportNtmsDatabase);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (ExportNtmsDatabase)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	DynamicCloseNtmsSession = (PFnCloseNtmsSession) GetProcAddress (hNtmsDll, "CloseNtmsSession");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicCloseNtmsSession);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (CloseNtmsSession)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	/*
	** Get ourselves a copy of the target path we can play with
	*/
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Find the location of the database. The export files are
	** stored in a subdirectory off this.
	*/
	hrStatus = DetermineDatabaseLocation (&ucsSourcePath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"DetermineDatabaseLocation", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	ULONG	ulOpenSessionRetryAttempts = NTMS_OPEN_SESSION_ATTEMPTS;
	BOOL	bRetryNtmsOpenSession;


	/*
	** Add the necessary trailing bits and pieces to the source
	** and target paths. Note that we know that there is enough
	** space already so this cannot fail.
	*/
	StringAppendString (&ucsSourcePath, EXPORT_SUBDIRECTORY);


	/*
	** Now connect to RSM and tell it to copy the database
	**
	** As far as we know the RSM should dump the database in the
	** location we've already determined. If not then we are
	** sunk. Not much we can do about that.
	**
	** 
	*/
	do 
	    {	
	    hRsm = DynamicOpenNtmsSessionW (NULL, L"RSM Snapshot Writer", 0);

	    hrStatus = GET_STATUS_FROM_BOOL (INVALID_HANDLE_VALUE != hRsm);

	    bRetryNtmsOpenSession = (HRESULT_FROM_WIN32 (ERROR_NOT_READY) == hrStatus);

	    if (bRetryNtmsOpenSession)
		{
		Sleep (NTMS_OPEN_SESSION_POLLING_INTERVAL);
		}
	    } while (bRetryNtmsOpenSession && (--ulOpenSessionRetryAttempts > 0));


	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::DoPrepareForSnapshot: OpenNtmsSession() took %u retries",
			     NTMS_OPEN_SESSION_ATTEMPTS - ulOpenSessionRetryAttempts));


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"OpenNtmsSessionW", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	dwStatus = DynamicExportNtmsDatabase (hRsm);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"ExportNtmsDatabase", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");


	dwStatus = DynamicCloseNtmsSession (hRsm);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = MoveFilesInDirectory (&ucsSourcePath, &ucsTargetPath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (!HandleInvalid (hNtmsDll))
	{
	FreeLibrary (hNtmsDll);
	}

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);

    return (hrStatus);
    } /* CShimWriterRSM::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtreventlog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtreventlog.cpp | Implementation of SnapshotWriter for Event logs



Author:

    Michael C. Johnson [mikejohn] 14-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-10	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-9	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.


	X-8	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-7	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-6	MCJ		Michael C. Johnson		02-Jun-2000
		Make event log writer sensitive to which volumes are being 
		backed up/snapshotted.

	X-5	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-4	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-3	MCJ		Michael C. Johnson		 3-Mar-2000
		Remove inner registry search loop, instead use a direct
		lookup.
		Do a preparatory cleanup of the target save directory to make
		sure we don't have to deal with any junk left from a previous
		invokcation.
		

	X-2	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-1	MCJ		Michael C. Johnson		14-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "wrtcommon.hxx"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHEVLGC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"EventLogs"
#define COMPONENT_NAME				L"Event Logs"
#define TARGET_PATH				ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define EVENTLOG_SUBKEY_EVENTLOG		L"SYSTEM\\CurrentControlSet\\Services\\Eventlog"
#define EVENTLOG_VALUENAME_FILE			L"File"

#define EVENTLOG_BUFFER_SIZE			(4096)

DeclareStaticUnicodeString (ucsValueRecognitionFile, EVENTLOG_VALUENAME_FILE);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterEventLog : public CShimWriter
    {
public:
    CShimWriterEventLog (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterEventLog ShimWriterEventLog (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterEventLog = &ShimWriterEventLog;




/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterEventLog::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterEventLog::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (L"%SystemRoot%\\system32\\config",
								 L"*.evt",
								 false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CShimWriterEventLog::DoIdentify () */


/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT from HapeAlloc(), RegXxxx() or event log operations

--*/

HRESULT CShimWriterEventLog::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    DWORD		dwIndex                     = 0;
    HKEY		hkeyEventLogList            = NULL;
    BOOL		bSucceeded                  = FALSE;
    BOOL		bEventLogListKeyOpened      = FALSE;
    BOOL		bEventLogValueFileKeyOpened = FALSE;
    BOOL		bContinueEventLogSearch     = TRUE;
    UNICODE_STRING	ucsEventLogSourcePath;
    UNICODE_STRING	ucsEventLogTargetPath;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;
    USHORT		usEventLogTargetPathRootLength;



    StringInitialise (&ucsEventLogTargetPath);
    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsEventLogTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsEventLogTargetPath, DIR_SEP_STRING);

	usEventLogTargetPathRootLength = ucsEventLogTargetPath.Length / sizeof (WCHAR);



	/*
	** We now have all the pieces in place so go search the eventlog list
	** for the logs to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   EVENTLOG_SUBKEY_EVENTLOG,
				   0L,
				   KEY_READ,
				   &hkeyEventLogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bEventLogListKeyOpened = SUCCEEDED (hrStatus);


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (eventlog list)", 
		    L"CShimWriterEventLog::DoPrepareForSnapshot");
	}



    while (SUCCEEDED (hrStatus) && bContinueEventLogSearch)
	{
	HKEY	hkeyEventLogValueFile       = NULL;
 	DWORD	dwSubkeyNameLength          = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyEventLogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);



	if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus))
	    {
	    hrStatus = NOERROR;

	    bContinueEventLogSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterEventLog::DoPrepareForSnapshot");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;



	    winStatus = RegOpenKeyExW (hkeyEventLogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyEventLogValueFile);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    bEventLogValueFileKeyOpened = SUCCEEDED (hrStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (eventlog name)", 
			L"CShimWriterEventLog::DoPrepareForSnapshot");


	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;

		StringTruncate (&ucsValueData, 0);
		StringTruncate (&ucsEventLogTargetPath, usEventLogTargetPathRootLength);		


		winStatus = RegQueryValueExW (hkeyEventLogValueFile,
					      EVENTLOG_VALUENAME_FILE,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);


		hrStatus = HRESULT_FROM_WIN32 (winStatus);

                if ( FAILED( hrStatus ) )
                    {
                    //  If there is any reason that we can't query the File reg value, then skip this entry.  Probably
                    //  a bogus event log entry in the registry.
                    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterEventLog::DoPrepareForSnapshot");
                    ft.Trace( VSSDBG_SHIM, L"Error querying event log reg value File, 0x%08x, skipping entry", hrStatus );
                    hrStatus = S_OK;
                    }
                else if (REG_EXPAND_SZ == dwValueType)
		    {
		    HANDLE	hEventLog          = NULL;
		    BOOL	bIncludeInSnapshot = FALSE;
		    PWCHAR	pwszFilename;


		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;



		    StringInitialise (&ucsEventLogSourcePath);

		    hrStatus = StringCreateFromExpandedString (&ucsEventLogSourcePath,
							       ucsValueData.Buffer,
							       0);


		    if (SUCCEEDED (hrStatus))
			{
			hrStatus = IsPathInVolumeArray (ucsEventLogSourcePath.Buffer,
							m_ulVolumeCount,
							m_ppwszVolumeNamesArray,
							&bIncludeInSnapshot);
			}



		    if (SUCCEEDED (hrStatus) && bIncludeInSnapshot)
			{
			pwszFilename = wcsrchr (ucsEventLogSourcePath.Buffer, DIR_SEP_CHAR);

			pwszFilename = (NULL == pwszFilename)
						? ucsEventLogSourcePath.Buffer
						: pwszFilename + 1;

			StringAppendString (&ucsEventLogTargetPath, pwszFilename);



			hEventLog = OpenEventLogW (NULL,
						   ucsSubkeyName.Buffer);

			hrStatus = GET_STATUS_FROM_BOOL (NULL != hEventLog);

			LogFailure (NULL, 
				    hrStatus, 
				    hrStatus, 
				    m_pwszWriterName, 
				    L"OpenEventLogW", 
				    L"CShimWriterEventLog::DoPrepareForSnapshot");
			}


		    if (SUCCEEDED (hrStatus) && bIncludeInSnapshot)
			{
			bSucceeded = BackupEventLogW (hEventLog,
						      ucsEventLogTargetPath.Buffer);

			hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

			LogFailure (NULL, 
				    hrStatus, 
				    hrStatus, 
				    m_pwszWriterName, 
				    L"BackupEventLogW", 
				    L"CShimWriterEventLog::DoPrepareForSnapshot");


			bSucceeded = CloseEventLog (hEventLog);
			}


		    StringFree (&ucsEventLogSourcePath);
		    }
		}


	    if (bEventLogValueFileKeyOpened)
		{
		RegCloseKey (hkeyEventLogValueFile);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}



    if (bEventLogListKeyOpened)
	{
	RegCloseKey (hkeyEventLogList);
	}


    StringFree (&ucsEventLogTargetPath);
    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);

    return (hrStatus);
    } /* DoEventLogFreeze () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\server\samples\requestor\util.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	util.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/

///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"



///////////////////////////////////////////////////////////////////////////////
// Print usage


void CVssSampleRequestor::PrintUsage()
{
    wprintf(
        L"\nUsage:\n"
        L"      vsreq [-b] [-s] [-x <file.xml>] [<volumes>]\n"
        L"\nOptions:\n"
        L"      -b              Backup includes bootable & system state.\n"
        L"      -s              Enable component selection.\n"
        L"      -x <file.xml>   Generate an XML file containing the backup metadata\n"
        L"      <volumes>       Specifies the volumes to be part of the snapshot set\n"
        L"                      The volumes in the list must be distinct and \n"
        L"                      must be separated by space. A volume must be \n"
        L"                      terminated with a trailing backslask (for example C:\\).\n"
        L"\n"
        L"\nExample:\n"
        L"      The following command will create a snapshot set\n"
        L"      on the volumes mounted under c:\\ and d:\\\n"
        L"\n"
        L"              vsreq c:\\ d:\\ \n"
        L"\n"
        L"      The following command will create a snapshot set on the volumes \n"
        L"      that contain selected components and also the volume c:\\\n"
        L"      Also, the backup will contain bootable and system state.\n"
        L"      The XML results will be stored in file.xml\n"
        L"\n"
        L"              vsreq -b -s -x file.xml c:\\ \n"
        );
    throw(2);
}


void CVssSampleRequestor::ParseCommandLine(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        )
{
    if (nArgsCount == 0)
        PrintUsage();

    // For each argument in the command line
    bool bParsingVolumes = false;
    INT nCurrentArg = nArgsCount;
    WCHAR ** ppwszCurrentArg = ppwszArgsArray;
    for(; nCurrentArg--; ppwszCurrentArg++)
    {
        if (!bParsingVolumes) {
            // Check for Bootable & system state option
            if (!m_bBootableSystemState && !wcscmp(*ppwszCurrentArg, L"-b")) {
                m_bBootableSystemState = true;
                continue;
            }

            // Check for Selected components option
            if (!m_bComponentSelectionEnabled && !wcscmp(*ppwszCurrentArg, L"-s")) {
                m_bComponentSelectionEnabled = true;
                continue;
            }

            // Check for Xml file option
            if (!m_pwszXmlFile && !wcscmp(*ppwszCurrentArg, L"-x")) {
                if (nCurrentArg-- == 0)
                    return PrintUsage();
                ppwszCurrentArg++;
                m_pwszXmlFile = _wcsdup(*ppwszCurrentArg);

		  DWORD dwAttributes = ::GetFileAttributes(m_pwszXmlFile);
                if (dwAttributes != INVALID_FILE_ATTRIBU